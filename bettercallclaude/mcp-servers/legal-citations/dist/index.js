#!/usr/bin/env node
import { createRequire } from 'module'; const require = createRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        if (super(), !exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super(), this._items = typeof code == "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        let item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => (c instanceof Name && (names[c.str] = (names[c.str] || 0) + 1), names), {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      let code = [strs[0]], i = 0;
      for (; i < args.length; )
        addCodeArg(code, args[i]), code.push(strs[++i]);
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      let expr = [safeStringify(strs[0])], i = 0;
      for (; i < args.length; )
        expr.push(plus), addCodeArg(expr, args[i]), expr.push(plus, safeStringify(strs[++i]));
      return optimize(expr), new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      arg instanceof _Code ? code.push(...arg._items) : arg instanceof Name ? code.push(arg) : code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      for (; i < expr.length - 1; ) {
        if (expr[i] === plus) {
          let res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string")
        return b instanceof Name || a[a.length - 1] !== '"' ? void 0 : typeof b != "string" ? `${a.slice(0, -1)}${b}"` : b[0] === '"' ? a.slice(0, -1) + b.slice(1) : void 0;
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key))
        return new _Code(`${key}`);
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code(), ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`), this.value = name.value;
      }
    }, UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2.Started = 0] = "Started", UsedValueState2[UsedValueState2.Completed = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {}, this._prefixes = prefixes, this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        let ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (!((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0) && _b.has(prefix) || this._prefixes && !this._prefixes.has(prefix))
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr), this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value, this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`, ValueScope = class extends Scope {
      constructor(opts) {
        super(opts), this._values = {}, this._scope = opts.scope, this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        let name = this.toName(nameOrPrefix), { prefix } = name, valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref, vs = this._values[prefix];
        if (vs) {
          let _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        vs.set(valueKey, name);
        let s = this._scope[prefix] || (this._scope[prefix] = []), itemIndex = s.length;
        return s[itemIndex] = value.ref, name.setValue(value, { property: prefix, itemIndex }), name;
      }
      getValue(prefix, keyOrRef) {
        let vs = this._values[prefix];
        if (vs)
          return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (let prefix in values) {
          let vs = values[prefix];
          if (!vs)
            continue;
          let nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              let def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode?.(name))
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            else
              throw new ValueError(name);
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code(), scope_1 = require_scope(), code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: !0, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: !0, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: !0, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: !0, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: !0, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: !0, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: !0, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }, Def = class extends Node {
      constructor(varKind, name, rhs) {
        super(), this.varKind = varKind, this.name = name, this.rhs = rhs;
      }
      render({ es5, _n }) {
        let varKind = es5 ? scope_1.varKinds.var : this.varKind, rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (names[this.name.str])
          return this.rhs && (this.rhs = optimizeExpr(this.rhs, names, constants)), this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }, Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super(), this.lhs = lhs, this.rhs = rhs, this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!(this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects))
          return this.rhs = optimizeExpr(this.rhs, names, constants), this;
      }
      get names() {
        let names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    }, AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects), this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }, Label = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }, Break = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `break${this.label ? ` ${this.label}` : ""};` + _n;
      }
    }, Throw = class extends Node {
      constructor(error2) {
        super(), this.error = error2;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }, AnyCode = class extends Node {
      constructor(code) {
        super(), this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        return this.code = optimizeExpr(this.code, names, constants), this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }, ParentNode = class extends Node {
      constructor(nodes = []) {
        super(), this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i].optimizeNodes();
          Array.isArray(n) ? nodes.splice(i, 1, ...n) : n ? nodes[i] = n : nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i];
          n.optimizeNames(names, constants) || (subtractNames(names, n.names), nodes.splice(i, 1));
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    }, BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }, Root = class extends ParentNode {
    }, Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes), this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        return this.else && (code += "else " + this.else.render(opts)), code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let cond = this.condition;
        if (cond === !0)
          return this.nodes;
        let e = this.else;
        if (e) {
          let ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e)
          return cond === !1 ? e instanceof _If ? e : e.nodes : this.nodes.length ? this : new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        if (!(cond === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        if (this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants), !!(super.optimizeNames(names, constants) || this.else))
          return this.condition = optimizeExpr(this.condition, names, constants), this;
      }
      get names() {
        let names = super.names;
        return addExprNames(names, this.condition), this.else && addNames(names, this.else.names), names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super(), this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iteration = optimizeExpr(this.iteration, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }, ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super(), this.varKind = varKind, this.name = name, this.from = from, this.to = to;
      }
      render(opts) {
        let varKind = opts.es5 ? scope_1.varKinds.var : this.varKind, { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        let names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    }, ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super(), this.loop = loop, this.varKind = varKind, this.name = name, this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iterable = optimizeExpr(this.iterable, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }, Func = class extends BlockNode {
      constructor(name, args, async) {
        super(), this.name = name, this.args = args, this.async = async;
      }
      render(opts) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        return this.catch && (code += this.catch.render(opts)), this.finally && (code += this.finally.render(opts)), code;
      }
      optimizeNodes() {
        var _a2, _b;
        return super.optimizeNodes(), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNodes(), (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes(), this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        return super.optimizeNames(names, constants), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNames(names, constants), (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants), this;
      }
      get names() {
        let names = super.names;
        return this.catch && addNames(names, this.catch.names), this.finally && addNames(names, this.finally.names), names;
      }
    }, Catch = class extends BlockNode {
      constructor(error2) {
        super(), this.error = error2;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...opts, _n: opts.lines ? `
` : "" }, this._extScope = extScope, this._scope = new scope_1.Scope({ parent: extScope }), this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        let name = this._extScope.value(prefixOrName, value);
        return (this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name), name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        let name = this._scope.toName(nameOrPrefix);
        return rhs !== void 0 && constant && (this._constants[name.str] = rhs), this._leafNode(new Def(varKind, name, rhs)), name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        return typeof c == "function" ? c() : c !== code_1.nil && this._leafNode(new AnyCode(c)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        let code = ["{"];
        for (let [key, value] of keyValues)
          code.length > 1 && code.push(","), code.push(key), (key !== value || this.opts.es5) && (code.push(":"), (0, code_1.addCodeArg)(code, value));
        return code.push("}"), new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        if (this._blockNode(new If(condition)), thenBody && elseBody)
          this.code(thenBody).else().code(elseBody).endIf();
        else if (thenBody)
          this.code(thenBody).endIf();
        else if (elseBody)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        return this._blockNode(node), forBody && this.code(forBody).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        let name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          let arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`), forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        let node = new Return();
        if (this._blockNode(node), this.code(value), node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        let node = new Try();
        if (this._blockNode(node), this.code(tryBody), catchCode) {
          let error2 = this.name("e");
          this._currNode = node.catch = new Catch(error2), catchCode(error2);
        }
        return finallyCode && (this._currNode = node.finally = new Finally(), this.code(finallyCode)), this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error2) {
        return this._leafNode(new Throw(error2));
      }
      // start self-balancing block
      block(body, nodeCount) {
        return this._blockStarts.push(this._nodes.length), body && this.code(body).endBlock(nodeCount), this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        let len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        let toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount)
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        return this._nodes.length = len, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        return this._blockNode(new Func(name, args, async)), funcBody && this.code(funcBody).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        for (; n-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(node) {
        return this._currNode.nodes.push(node), this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node), this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        let n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        let n = this._currNode;
        if (!(n instanceof If))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = n.else = node, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        let ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => (c instanceof code_1.Name && (c = replaceName(c)), c instanceof code_1._Code ? items.push(...c._items) : items.push(c), items), []));
      function replaceName(n) {
        let c = constants[n.str];
        return c === void 0 || names[n.str] !== 1 ? n : (delete names[n.str], c);
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen(), code_1 = require_code();
    function toHash(arr) {
      let hash2 = {};
      for (let item of arr)
        hash2[item] = !0;
      return hash2;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      return typeof schema == "boolean" ? schema : Object.keys(schema).length === 0 ? !0 : (checkUnknownRules(it, schema), !schemaHasRules(schema, it.self.RULES.all));
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      let { opts, self } = it;
      if (!opts.strictSchema || typeof schema == "boolean")
        return;
      let rules = self.RULES.keywords;
      for (let key in schema)
        rules[key] || checkStrictMode(it, `unknown keyword: "${key}"`);
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (rules[key])
          return !0;
      return !1;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (key !== "$ref" && RULES.all[key])
          return !0;
      return !1;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      return typeof str == "number" ? `${str}` : str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs))
        for (let x of xs)
          f(x);
      else
        f(xs);
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
      return (gen, from, to, toName) => {
        let res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, !0), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          from === !0 ? gen.assign(to, !0) : (gen.assign(to, (0, codegen_1._)`${to} || {}`), setEvaluated(gen, to, from));
        }),
        mergeValues: (from, to) => from === !0 ? !0 : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === !0 ? !0 : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === !0 ? !0 : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === !0)
        return gen.var("props", !0);
      let props = gen.var("props", (0, codegen_1._)`{}`);
      return ps !== void 0 && setEvaluated(gen, props, ps), props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, !0));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2.Num = 0] = "Num", Type2[Type2.Str = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        let isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (mode) {
        if (msg = `strict mode: ${msg}`, mode === !0)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      overrideAllErrors ?? (compositeRule || allErrors) ? addError(gen, errObj) : returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      addError(gen, errObj), compositeRule || allErrors || returnErrors(it, names_1.default.vErrors);
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount), gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      let err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`), gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath))), gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`), it.opts.verbose && (gen.assign((0, codegen_1._)`${err}.schema`, schemaValue), gen.assign((0, codegen_1._)`${err}.data`, data));
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      let err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`), gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      let { gen, validateName, schemaEnv } = it;
      schemaEnv.$async ? gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`) : (gen.assign((0, codegen_1._)`${validateName}.errors`, errs), gen.return(!1));
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error2, errorPaths) {
      let { createErrors } = cxt.it;
      return createErrors === !1 ? (0, codegen_1._)`{}` : errorObject(cxt, error2, errorPaths);
    }
    function errorObject(cxt, error2, errorPaths = {}) {
      let { gen, it } = cxt, keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      return extraErrorProps(cxt, error2, keyValues), gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      let instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      return schemaPath && (schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`), [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      let { keyword, data, schemaValue, it } = cxt, { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]), opts.messages && keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]), opts.verbose && keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]), propertyName && keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors(), codegen_1 = require_codegen(), names_1 = require_names(), boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      let { gen, schema, validateName } = it;
      schema === !1 ? falseSchemaError(it, !1) : typeof schema == "object" && schema.$async === !0 ? gen.return(names_1.default.data) : (gen.assign((0, codegen_1._)`${validateName}.errors`, null), gen.return(!0));
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      let { gen, schema } = it;
      schema === !1 ? (gen.var(valid, !1), falseSchemaError(it)) : gen.var(valid, !0);
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      let { gen, data } = it, cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"], jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      let groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      let group = self.RULES.types[type];
      return group && group !== !0 && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules(), applicability_1 = require_applicability(), errors_1 = require_errors(), codegen_1 = require_codegen(), util_1 = require_util(), DataType;
    (function(DataType2) {
      DataType2[DataType2.Correct = 0] = "Correct", DataType2[DataType2.Wrong = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      let types = getJSONTypes(schema.type);
      if (types.includes("null")) {
        if (schema.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        schema.nullable === !0 && types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      let types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      let { gen, data, opts } = it, coerceTo = coerceToTypes(types, opts.coerceTypes), checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        let wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          coerceTo.length ? coerceData(it, types, coerceTo) : reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      let { gen, data, opts } = it, dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`), coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      opts.coerceTypes === "array" && gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))), gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (let t of coerceTo)
        (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") && coerceSpecificType(t);
      gen.else(), reportTypeError(it), gen.endIf(), gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced), assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, !1).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, !0);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`), gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      let EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ, cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1)
        return checkDataType(dataTypes[0], data, strictNums, correct);
      let cond, types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        let notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`, delete types.null, delete types.array, delete types.object;
      } else
        cond = codegen_1.nil;
      types.number && delete types.integer;
      for (let t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      let cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      let { gen, data, schema } = it, schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function assignDefaults(it, ty) {
      let { properties, items } = it.schema;
      if (ty === "object" && properties)
        for (let key in properties)
          assignDefault(it, key, properties[key].default);
      else ty === "array" && Array.isArray(items) && items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      let { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      let childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      opts.useDefaults === "empty" && (condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`), gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names(), util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      let { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, !0), cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, !0), cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      let dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data, valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      it.opts.dynamicRef && valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      let args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      let u = opts.unicodeRegExp ? "u" : "", { regExp } = opts.code, rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      if (it.allErrors) {
        let validArr = gen.let("valid", !0);
        return validateItems(() => gen.assign(validArr, !1)), validArr;
      }
      return gen.var(valid, !0), validateItems(() => gen.break()), valid;
      function validateItems(notValid) {
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid), gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      let { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated)
        return;
      let valid = gen.let("valid", !1), schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        let schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: !0
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`), cxt.mergeValidEvaluated(schCxt, schValid) || gen.if((0, codegen_1.not)(valid));
      })), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
    }
    exports.validateUnion = validateUnion;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen(), names_1 = require_names(), code_1 = require_code2(), errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      let { gen, keyword, schema, parentSchema, it } = cxt, macroSchema = def.macro.call(it.self, schema, parentSchema, it), schemaRef = useKeyword(gen, keyword, macroSchema);
      it.opts.validateSchema !== !1 && it.self.validateSchema(macroSchema, !0);
      let valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: !0
      }, valid), cxt.pass(valid, () => cxt.error(!0));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      let { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      let validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate, validateRef = useKeyword(gen, keyword, validate), valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword), cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === !1)
          assignValid(), def.modifying && modifyData(cxt), reportErrs(() => cxt.error());
        else {
          let ruleErrs = def.async ? validateAsync() : validateSync();
          def.modifying && modifyData(cxt), reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        let ruleErrs = gen.let("ruleErrs", null);
        return gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, !1).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e))), ruleErrs;
      }
      function validateSync() {
        let validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        return gen.assign(validateErrs, null), assignValid(codegen_1.nil), validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        let passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self, passSchema = !("compile" in def && !$data || def.schema === !1);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      let { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      let { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`), (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = !1) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema > "u");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword)
        throw new Error("ajv implementation error");
      let deps = def.dependencies;
      if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)))
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      if (def.validateSchema && !def.validateSchema(schema[keyword])) {
        let msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (keyword !== void 0) {
        let sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      let { gen } = it;
      if (dataProp !== void 0) {
        let { errorPath, dataPathArr, opts } = it, nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, !0);
        dataContextProps(nextData), subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`, subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`, subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        let nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, !0);
        dataContextProps(nextData), propertyName !== void 0 && (subschema.propertyName = propertyName);
      }
      dataTypes && (subschema.dataTypes = dataTypes);
      function dataContextProps(_nextData) {
        subschema.data = _nextData, subschema.dataLevel = it.dataLevel + 1, subschema.dataTypes = [], it.definedProperties = /* @__PURE__ */ new Set(), subschema.parentData = it.data, subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      compositeRule !== void 0 && (subschema.compositeRule = compositeRule), createErrors !== void 0 && (subschema.createErrors = createErrors), allErrors !== void 0 && (subschema.allErrors = allErrors), subschema.jtdDiscriminator = jtdDiscriminator, subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// mcp-servers-src/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "mcp-servers-src/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return !0;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return !1;
        var length, i, keys;
        if (Array.isArray(a)) {
          if (length = a.length, length != b.length) return !1;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return !1;
          return !0;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return !1;
        }
        return !0;
      }
      return a !== a && b !== b;
    };
  }
});

// mcp-servers-src/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "mcp-servers-src/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      }, post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    };
    traverse.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    };
    traverse.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    };
    traverse.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords)
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object")
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util(), equal = require_fast_deep_equal(), traverse = require_json_schema_traverse(), SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = !0) {
      return typeof schema == "boolean" ? !0 : limit === !0 ? !hasRef(schema) : limit ? countKeys(schema) <= limit : !1;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (let key in schema) {
        if (REF_KEYWORDS.has(key))
          return !0;
        let sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef) || typeof sch == "object" && hasRef(sch))
          return !0;
      }
      return !1;
    }
    function countKeys(schema) {
      let count = 0;
      for (let key in schema) {
        if (key === "$ref")
          return 1 / 0;
        if (count++, !SIMPLE_INLINED.has(key) && (typeof schema[key] == "object" && (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch)), count === 1 / 0))
          return 1 / 0;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      normalize !== !1 && (id = normalizeId(id));
      let p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      return resolver.serialize(p).split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      return id = normalizeId(id), resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      let { schemaId, uriResolver } = this.opts, schId = normalizeId(schema[schemaId] || baseId), baseIds = { "": schId }, pathPrefix = getFullPath(uriResolver, schId, !1), localRefs = {}, schemaRefs = /* @__PURE__ */ new Set();
      return traverse(schema, { allKeys: !0 }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        let fullPath = pathPrefix + jsonPtr, innerBaseId = baseIds[parentJsonPtr];
        typeof sch[schemaId] == "string" && (innerBaseId = addRef.call(this, sch[schemaId])), addAnchor.call(this, sch.$anchor), addAnchor.call(this, sch.$dynamicAnchor), baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          let _resolve = this.opts.uriResolver.resolve;
          if (ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref), schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          return typeof schOrRef == "string" && (schOrRef = this.refs[schOrRef]), typeof schOrRef == "object" ? checkAmbiguosRef(sch, schOrRef.schema, ref) : ref !== normalizeId(fullPath) && (ref[0] === "#" ? (checkAmbiguosRef(sch, localRefs[ref], ref), localRefs[ref] = sch) : this.refs[ref] = fullPath), ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      }), localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema(), dataType_1 = require_dataType(), applicability_1 = require_applicability(), dataType_2 = require_dataType(), defaults_1 = require_defaults(), keyword_1 = require_keyword(), subschema_1 = require_subschema(), codegen_1 = require_codegen(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        topSchemaObjCode(it);
        return;
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      opts.code.es5 ? gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`), destructureValCxtES5(gen, opts), gen.code(body);
      }) : gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`), gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`), gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`), gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`), gen.var(names_1.default.rootData, names_1.default.data), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      let { schema, opts, gen } = it;
      validateFunction(it, () => {
        opts.$comment && schema.$comment && commentKeyword(it), checkNoDefault(it), gen.let(names_1.default.vErrors, null), gen.let(names_1.default.errors, 0), opts.unevaluated && resetEvaluated(it), typeAndKeywords(it), returnResults(it);
      });
    }
    function resetEvaluated(it) {
      let { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`), gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`)), gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      let schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        subSchemaObjCode(it, valid);
        return;
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (self.RULES.all[key])
          return !0;
      return !1;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      let { schema, gen, opts } = it;
      opts.$comment && schema.$comment && commentKeyword(it), updateContext(it), checkAsyncSchema(it);
      let errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount), gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it), checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], !1, errsCount);
      let types = (0, dataType_1.getSchemaTypes)(it.schema), checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      let { schema, errSchemaPath, opts, self } = it;
      schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES) && self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
    function checkNoDefault(it) {
      let { schema, opts } = it;
      schema.default !== void 0 && opts.useDefaults && opts.strictSchema && (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
    function updateContext(it) {
      let schId = it.schema[it.opts.schemaId];
      schId && (it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId));
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      let msg = schema.$comment;
      if (opts.$comment === !0)
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      else if (typeof opts.$comment == "function") {
        let schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`, rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      let { gen, schemaEnv, validateName, ValidationError, opts } = it;
      schemaEnv.$async ? gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`)) : (gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors), opts.unevaluated && assignEvaluated(it), gen.return((0, codegen_1._)`${names_1.default.errors} === 0`));
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      props instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.props`, props), items instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      let { gen, schema, data, allErrors, opts, self } = it, { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      opts.jtd || checkStrictTypes(it, types), gen.block(() => {
        for (let group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        (0, applicability_1.shouldUseGroup)(schema, group) && (group.type ? (gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)), iterateKeywords(it, group), types.length === 1 && types[0] === group.type && typeErrors && (gen.else(), (0, dataType_2.reportTypeError)(it)), gen.endIf()) : iterateKeywords(it, group), allErrors || gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`));
      }
    }
    function iterateKeywords(it, group) {
      let { gen, schema, opts: { useDefaults } } = it;
      useDefaults && (0, defaults_1.assignDefaults)(it, group.type), gen.block(() => {
        for (let rule of group.rules)
          (0, applicability_1.shouldUseRule)(schema, rule) && keywordCode(it, rule.keyword, rule.definition, group.type);
      });
    }
    function checkStrictTypes(it, types) {
      it.schemaEnv.meta || !it.opts.strictTypes || (checkContextTypes(it, types), it.opts.allowUnionTypes || checkMultipleTypes(it, types), checkKeywordTypes(it, it.dataTypes));
    }
    function checkContextTypes(it, types) {
      if (types.length) {
        if (!it.dataTypes.length) {
          it.dataTypes = types;
          return;
        }
        types.forEach((t) => {
          includesType(it.dataTypes, t) || strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }), narrowSchemaTypes(it, types);
      }
    }
    function checkMultipleTypes(it, ts) {
      ts.length > 1 && !(ts.length === 2 && ts.includes("null")) && strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
    function checkKeywordTypes(it, ts) {
      let rules = it.self.RULES.all;
      for (let keyword in rules) {
        let rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          let { type } = rule.definition;
          type.length && !type.some((t) => hasApplicableType(ts, t)) && strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      let ts = [];
      for (let t of it.dataTypes)
        includesType(withTypes, t) ? ts.push(t) : withTypes.includes("integer") && t === "number" && ts.push("integer");
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      let schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`, (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        if ((0, keyword_1.validateKeywordUsage)(it, def, keyword), this.gen = it.gen, this.allErrors = it.allErrors, this.keyword = keyword, this.data = it.data, this.schema = it.schema[keyword], this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data), this.schemaType = def.schemaType, this.parentSchema = it.schema, this.params = {}, this.it = it, this.def = def, this.$data)
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        else if (this.schemaCode = this.schemaValue, !(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined))
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        ("code" in def ? def.trackErrors : def.errors !== !1) && (this.errsCount = it.gen.const("_errs", names_1.default.errors));
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition), failAction ? failAction() : this.error(), successAction ? (this.gen.else(), successAction(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(condition), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        let { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams), this._error(append, errorPaths), this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        this.allErrors || this.gen.if(cond);
      }
      setParams(obj, assign) {
        assign ? Object.assign(this.params, obj) : this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid), codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        let { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid)), valid !== codegen_1.nil && gen.assign(valid, !0), (schemaType.length || def.validateSchema) && (gen.elseIf(this.invalid$data()), this.$dataError(), valid !== codegen_1.nil && gen.assign(valid, !1)), gen.else();
      }
      invalid$data() {
        let { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            let st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            let validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        let subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl), (0, subschema_1.extendSubschemaMode)(subschema, appl);
        let nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        return subschemaCode(nextContext, valid), nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        let { it, gen } = this;
        it.opts.unevaluated && (it.props !== !0 && schemaCxt.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)), it.items !== !0 && schemaCxt.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)));
      }
      mergeValidEvaluated(schemaCxt, valid) {
        let { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== !0 || it.items !== !0))
          return gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name)), !0;
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      let cxt = new KeywordCxt(it, def, keyword);
      "code" in def ? def.code(cxt, ruleType) : cxt.$data && def.validate ? (0, keyword_1.funcKeywordCode)(cxt, def) : "macro" in def ? (0, keyword_1.macroKeywordCode)(cxt, def) : (def.compile || def.validate) && (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer, data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data, data = names_1.default.rootData;
      } else {
        let matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        let up = +matches[1];
        if (jsonPointer = matches[2], jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        if (data = dataNames[dataLevel - up], !jsonPointer)
          return data;
      }
      let expr = data, segments = jsonPointer.split("/");
      for (let segment of segments)
        segment && (data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`, expr = (0, codegen_1._)`${expr} && ${data}`);
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed"), this.errors = errors, this.ajv = this.validation = !0;
      }
    };
    exports.default = ValidationError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var resolve_1 = require_resolve(), MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`), this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref), this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen(), validation_error_1 = require_validation_error(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), validate_1 = require_validate(), SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {}, this.dynamicAnchors = {};
        let schema;
        typeof env.schema == "object" && (schema = env.schema), this.schema = env.schema, this.schemaId = env.schemaId, this.root = env.root || this, this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema?.[env.schemaId || "$id"]), this.schemaPath = env.schemaPath, this.localRefs = env.localRefs, this.meta = env.meta, this.$async = schema?.$async, this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      let _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      let rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId), { es5, lines } = this.opts.code, { ownProperties } = this.opts, gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties }), _ValidationError;
      sch.$async && (_ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      }));
      let validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      let schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === !0 ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      }, sourceCode;
      try {
        this._compilations.add(sch), (0, validate_1.validateFunctionCode)(schemaCxt), gen.optimize(this.opts.code.optimize);
        let validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`, this.opts.code.process && (sourceCode = this.opts.code.process(sourceCode, sch));
        let validate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode)(this, this.scope.get());
        if (this.scope.value(validateName, { ref: validate }), validate.errors = null, validate.schema = sch.schema, validate.schemaEnv = sch, sch.$async && (validate.$async = !0), this.opts.code.source === !0 && (validate.source = { validateName, validateCode, scopeValues: gen._values }), this.opts.unevaluated) {
          let { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          }, validate.source && (validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated));
        }
        return sch.validate = validate, sch;
      } catch (e) {
        throw delete sch.validate, delete sch.validateName, sourceCode && this.logger.error("Error compiling schema, function code:", sourceCode), e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      let schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        let schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref], { schemaId } = this.opts;
        schema && (_sch = new SchemaEnv({ schema, schemaId, root, baseId }));
      }
      if (_sch !== void 0)
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      return (0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs) ? sch.schema : sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (let sch of this._compilations)
        if (sameSchemaEnv(sch, schEnv))
          return sch;
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      for (; typeof (sch = this.refs[ref]) == "string"; )
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      let p = this.opts.uriResolver.parse(ref), refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p), baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId)
        return getJsonPointer.call(this, p, root);
      let id = (0, resolve_1.normalizeId)(refPath), schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        let sch = resolveSchema.call(this, root, schOrRef);
        return typeof sch?.schema != "object" ? void 0 : getJsonPointer.call(this, p, sch);
      }
      if (typeof schOrRef?.schema == "object") {
        if (schOrRef.validate || compileSchema.call(this, schOrRef), id === (0, resolve_1.normalizeId)(ref)) {
          let { schema } = schOrRef, { schemaId } = this.opts, schId = schema[schemaId];
          return schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId)), new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
      }
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (let part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
          return;
        let partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        let schId = typeof schema == "object" && schema[this.opts.schemaId];
        !PREVENT_SCOPE_CHANGE.has(part) && schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId));
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        let $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      let { schemaId } = this.opts;
      if (env = env || new SchemaEnv({ schema, schemaId, root, baseId }), env.schema !== env.root.schema)
        return env;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: !1
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "", code = 0, i = 0;
      for (i = 0; i < input.length; i++)
        if (code = input[i].charCodeAt(0), code !== 48) {
          if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
            return "";
          acc += input[i];
          break;
        }
      for (i += 1; i < input.length; i++) {
        if (code = input[i].charCodeAt(0), !(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
          return "";
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      return buffer.length = 0, !0;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        let hex3 = stringArrayToHexStripped(buffer);
        if (hex3 !== "")
          address.push(hex3);
        else
          return output.error = !0, !1;
        buffer.length = 0;
      }
      return !0;
    }
    function getIPV6(input) {
      let tokenCount = 0, output = { error: !1, address: "", zone: "" }, address = [], buffer = [], endipv6Encountered = !1, endIpv6 = !1, consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        let cursor = input[i];
        if (!(cursor === "[" || cursor === "]"))
          if (cursor === ":") {
            if (endipv6Encountered === !0 && (endIpv6 = !0), !consume(buffer, address, output))
              break;
            if (++tokenCount > 7) {
              output.error = !0;
              break;
            }
            i > 0 && input[i - 1] === ":" && (endipv6Encountered = !0), address.push(":");
            continue;
          } else if (cursor === "%") {
            if (!consume(buffer, address, output))
              break;
            consume = consumeIsZone;
          } else {
            buffer.push(cursor);
            continue;
          }
      }
      return buffer.length && (consume === consumeIsZone ? output.zone = buffer.join("") : endIpv6 ? address.push(buffer.join("")) : address.push(stringArrayToHexStripped(buffer))), output.address = address.join(""), output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2)
        return { host, isIPV6: !1 };
      let ipv63 = getIPV6(host);
      if (ipv63.error)
        return { host, isIPV6: !1 };
      {
        let newHost = ipv63.address, escapedHost = ipv63.address;
        return ipv63.zone && (newHost += "%" + ipv63.zone, escapedHost += "%25" + ipv63.zone), { host: newHost, isIPV6: !0, escapedHost };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++)
        str[i] === token && ind++;
      return ind;
    }
    function removeDotSegments(path) {
      let input = path, output = [], nextSlash = -1, len = 0;
      for (; len = input.length; ) {
        if (len === 1) {
          if (input === ".")
            break;
          if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".")
              break;
            if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/" && (input[1] === "." || input[1] === "/")) {
            output.push("/");
            break;
          }
        } else if (len === 3 && input === "/..") {
          output.length !== 0 && output.pop(), output.push("/");
          break;
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/" && input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === "." && input[3] === "/") {
            input = input.slice(3), output.length !== 0 && output.pop();
            continue;
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else
          output.push(input.slice(0, nextSlash)), input = input.slice(nextSlash);
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      let func = esc2 !== !0 ? escape : unescape;
      return component.scheme !== void 0 && (component.scheme = func(component.scheme)), component.userinfo !== void 0 && (component.userinfo = func(component.userinfo)), component.host !== void 0 && (component.host = func(component.host)), component.path !== void 0 && (component.path = func(component.path)), component.query !== void 0 && (component.query = func(component.query)), component.fragment !== void 0 && (component.fragment = func(component.fragment)), component;
    }
    function recomposeAuthority(component) {
      let uriTokens = [];
      if (component.userinfo !== void 0 && (uriTokens.push(component.userinfo), uriTokens.push("@")), component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          let ipV6res = normalizeIPv6(host);
          ipV6res.isIPV6 === !0 ? host = `[${ipV6res.escapedHost}]` : host = component.host;
        }
        uriTokens.push(host);
      }
      return (typeof component.port == "number" || typeof component.port == "string") && (uriTokens.push(":"), uriTokens.push(String(component.port))), uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var { isUUID } = require_utils(), URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      return wsComponent.secure === !0 ? !0 : wsComponent.secure === !1 ? !1 : wsComponent.scheme ? wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S") : !1;
    }
    function httpParse(component) {
      return component.host || (component.error = component.error || "HTTP URIs must have a host."), component;
    }
    function httpSerialize(component) {
      let secure = String(component.scheme).toLowerCase() === "https";
      return (component.port === (secure ? 443 : 80) || component.port === "") && (component.port = void 0), component.path || (component.path = "/"), component;
    }
    function wsParse(wsComponent) {
      return wsComponent.secure = wsIsSecure(wsComponent), wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : ""), wsComponent.path = void 0, wsComponent.query = void 0, wsComponent;
    }
    function wsSerialize(wsComponent) {
      if ((wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") && (wsComponent.port = void 0), typeof wsComponent.secure == "boolean" && (wsComponent.scheme = wsComponent.secure ? "wss" : "ws", wsComponent.secure = void 0), wsComponent.resourceName) {
        let [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0, wsComponent.query = query, wsComponent.resourceName = void 0;
      }
      return wsComponent.fragment = void 0, wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path)
        return urnComponent.error = "URN can not be parsed", urnComponent;
      let matches = urnComponent.path.match(URN_REG);
      if (matches) {
        let scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase(), urnComponent.nss = matches[2];
        let urnScheme = `${scheme}:${options.nid || urnComponent.nid}`, schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0, schemeHandler && (urnComponent = schemeHandler.parse(urnComponent, options));
      } else
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      let scheme = options.scheme || urnComponent.scheme || "urn", nid = urnComponent.nid.toLowerCase(), urnScheme = `${scheme}:${options.nid || nid}`, schemeHandler = getSchemeHandler(urnScheme);
      schemeHandler && (urnComponent = schemeHandler.serialize(urnComponent, options));
      let uriComponent = urnComponent, nss = urnComponent.nss;
      return uriComponent.path = `${nid || options.nid}:${nss}`, options.skipEscape = !0, uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      let uuidComponent = urnComponent;
      return uuidComponent.uuid = uuidComponent.nss, uuidComponent.nss = void 0, !options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid)) && (uuidComponent.error = uuidComponent.error || "UUID is not valid."), uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      let urnComponent = uuidComponent;
      return urnComponent.nss = (uuidComponent.uuid || "").toLowerCase(), urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: wsParse,
        serialize: wsSerialize
      }
    ), wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    ), urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: !0
      }
    ), urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: !0
      }
    ), SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils(), { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      return typeof uri == "string" ? uri = /** @type {T} */
      serialize(parse3(uri, options), options) : typeof uri == "object" && (uri = /** @type {T} */
      parse3(serialize(uri, options), options)), uri;
    }
    function resolve(baseURI, relativeURI, options) {
      let schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" }, resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, !0);
      return schemelessOptions.skipEscape = !0, serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      let target = {};
      return skipNormalization || (base = parse3(serialize(base, options), options), relative = parse3(serialize(relative, options), options)), options = options || {}, !options.tolerant && relative.scheme ? (target.scheme = relative.scheme, target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0 ? (target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.path ? (relative.path[0] === "/" ? target.path = removeDotSegments(relative.path) : ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path ? target.path = "/" + relative.path : base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path, target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, relative.query !== void 0 ? target.query = relative.query : target.query = base.query), target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), target.scheme = base.scheme), target.fragment = relative.fragment, target;
    }
    function equal(uriA, uriB, options) {
      return typeof uriA == "string" ? (uriA = unescape(uriA), uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), !0), { ...options, skipEscape: !0 })) : typeof uriA == "object" && (uriA = serialize(normalizeComponentEncoding(uriA, !0), { ...options, skipEscape: !0 })), typeof uriB == "string" ? (uriB = unescape(uriB), uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), !0), { ...options, skipEscape: !0 })) : typeof uriB == "object" && (uriB = serialize(normalizeComponentEncoding(uriB, !0), { ...options, skipEscape: !0 })), uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      let component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      }, options = Object.assign({}, opts), uriTokens = [], schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      schemeHandler && schemeHandler.serialize && schemeHandler.serialize(component, options), component.path !== void 0 && (options.skipEscape ? component.path = unescape(component.path) : (component.path = escape(component.path), component.scheme !== void 0 && (component.path = component.path.split("%3A").join(":")))), options.reference !== "suffix" && component.scheme && uriTokens.push(component.scheme, ":");
      let authority = recomposeAuthority(component);
      if (authority !== void 0 && (options.reference !== "suffix" && uriTokens.push("//"), uriTokens.push(authority), component.path && component.path[0] !== "/" && uriTokens.push("/")), component.path !== void 0) {
        let s = component.path;
        !options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath) && (s = removeDotSegments(s)), authority === void 0 && s[0] === "/" && s[1] === "/" && (s = "/%2F" + s.slice(2)), uriTokens.push(s);
      }
      return component.query !== void 0 && uriTokens.push("?", component.query), component.fragment !== void 0 && uriTokens.push("#", component.fragment), uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      let options = Object.assign({}, opts), parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, isIP = !1;
      options.reference === "suffix" && (options.scheme ? uri = options.scheme + ":" + uri : uri = "//" + uri);
      let matches = uri.match(URI_PARSE);
      if (matches) {
        if (parsed.scheme = matches[1], parsed.userinfo = matches[3], parsed.host = matches[4], parsed.port = parseInt(matches[5], 10), parsed.path = matches[6] || "", parsed.query = matches[7], parsed.fragment = matches[8], isNaN(parsed.port) && (parsed.port = matches[5]), parsed.host)
          if (isIPv4(parsed.host) === !1) {
            let ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase(), isIP = ipv6result.isIPV6;
          } else
            isIP = !0;
        parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path ? parsed.reference = "same-document" : parsed.scheme === void 0 ? parsed.reference = "relative" : parsed.fragment === void 0 ? parsed.reference = "absolute" : parsed.reference = "uri", options.reference && options.reference !== "suffix" && options.reference !== parsed.reference && (parsed.error = parsed.error || "URI is not a " + options.reference + " reference.");
        let schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport) && parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === !1 && nonSimpleDomain(parsed.host))
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) && (uri.indexOf("%") !== -1 && (parsed.scheme !== void 0 && (parsed.scheme = unescape(parsed.scheme)), parsed.host !== void 0 && (parsed.host = unescape(parsed.host))), parsed.path && (parsed.path = escape(unescape(parsed.path))), parsed.fragment && (parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment)))), schemeHandler && schemeHandler.parse && schemeHandler.parse(parsed, options);
      } else
        parsed.error = parsed.error || "URI can not be parsed.";
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error(), ref_error_1 = require_ref_error(), rules_1 = require_rules(), compile_1 = require_compile(), codegen_2 = require_codegen(), resolve_1 = require_resolve(), dataType_1 = require_dataType(), util_1 = require_util(), $dataRefSchema = require_data(), uri_1 = require_uri(), defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"], EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      let s = o.strict, _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize, optimize = _optz === !0 || _optz === void 0 ? 1 : _optz || 0, regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp, uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : !0,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : !0,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : !1,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : !0,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : !0,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : !0,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : !0,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : !0,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : !0,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : !0,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : !0,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), opts = this.opts = { ...opts, ...requiredOptions(opts) };
        let { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines }), this.logger = getLogger(opts.logger);
        let formatOpt = opts.validateFormats;
        opts.validateFormats = !1, this.RULES = (0, rules_1.getRules)(), checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED"), checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn"), this._metaOpts = getMetaSchemaOptions.call(this), opts.formats && addInitialFormats.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), opts.keywords && addInitialKeywords.call(this, opts.keywords), typeof opts.meta == "object" && this.addMetaSchema(opts.meta), addInitialSchemas.call(this), opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data, meta: meta3, schemaId } = this.opts, _dataRefSchema = $dataRefSchema;
        schemaId === "id" && (_dataRefSchema = { ...$dataRefSchema }, _dataRefSchema.id = _dataRefSchema.$id, delete _dataRefSchema.$id), meta3 && $data && this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], !1);
      }
      defaultMeta() {
        let { meta: meta3, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          if (v = this.getSchema(schemaKeyRef), !v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else
          v = this.compile(schemaKeyRef);
        let valid = v(data);
        return "$async" in v || (this.errors = v.errors), valid;
      }
      compile(schema, _meta) {
        let sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta3) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        let { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta3);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          let sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          $ref && !this.getSchema($ref) && await runCompileAsync.call(this, { $ref }, !0);
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            return checkLoaded.call(this, e), await loadMissingSchema.call(this, e.missingSchema), _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref])
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
        async function loadMissingSchema(ref) {
          let _schema = await _loadSchema.call(this, ref);
          this.refs[ref] || await loadMetaSchema.call(this, _schema.$schema), this.refs[ref] || this.addSchema(_schema, ref, meta3);
        }
        async function _loadSchema(ref) {
          let p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (let sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema == "object") {
          let { schemaId } = this.opts;
          if (id = schema[schemaId], id !== void 0 && typeof id != "string")
            throw new Error(`schema ${schemaId} must be string`);
        }
        return key = (0, resolve_1.normalizeId)(key || id), this._checkUnique(key), this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        return this.addSchema(schema, key, !0, _validateSchema), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return !0;
        let $schema;
        if ($schema = schema.$schema, $schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        if ($schema = $schema || this.opts.defaultMeta || this.defaultMeta(), !$schema)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        let valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          let message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        for (; typeof (sch = getSchEnv.call(this, keyRef)) == "string"; )
          keyRef = sch;
        if (sch === void 0) {
          let { schemaId } = this.opts, root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          if (sch = compile_1.resolveSchema.call(this, root, keyRef), !sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp)
          return this._removeAllSchemas(this.schemas, schemaKeyRef), this._removeAllSchemas(this.refs, schemaKeyRef), this;
        switch (typeof schemaKeyRef) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            let sch = getSchEnv.call(this, schemaKeyRef);
            return typeof sch == "object" && this._cache.delete(sch.schema), delete this.schemas[schemaKeyRef], delete this.refs[schemaKeyRef], this;
          }
          case "object": {
            let cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            return id && (id = (0, resolve_1.normalizeId)(id), delete this.schemas[id], delete this.refs[id]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (let def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string")
          keyword = kwdOrDef, typeof def == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), def.keyword = keyword);
        else if (typeof kwdOrDef == "object" && def === void 0) {
          if (def = kwdOrDef, keyword = def.keyword, Array.isArray(keyword) && !keyword.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (checkKeyword.call(this, keyword, def), !def)
          return (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd)), this;
        keywordMetaschema.call(this, def);
        let definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        return (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))), this;
      }
      getKeyword(keyword) {
        let rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        let { RULES } = this;
        delete RULES.keywords[keyword], delete RULES.all[keyword];
        for (let group of RULES.rules) {
          let i = group.rules.findIndex((rule) => rule.keyword === keyword);
          i >= 0 && group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        return typeof format == "string" && (format = new RegExp(format)), this.formats[name] = format, this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        return !errors || errors.length === 0 ? "No errors" : errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        let rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (let jsonPointer of keywordsJsonPointers) {
          let segments = jsonPointer.split("/").slice(1), keywords = metaSchema;
          for (let seg of segments)
            keywords = keywords[seg];
          for (let key in rules) {
            let rule = rules[key];
            if (typeof rule != "object")
              continue;
            let { $data } = rule.definition, schema = keywords[key];
            $data && schema && (keywords[key] = schemaOrData(schema));
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (let keyRef in schemas) {
          let sch = schemas[keyRef];
          (!regex || regex.test(keyRef)) && (typeof sch == "string" ? delete schemas[keyRef] : sch && !sch.meta && (this._cache.delete(sch.schema), delete schemas[keyRef]));
        }
      }
      _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id, { schemaId } = this.opts;
        if (typeof schema == "object")
          id = schema[schemaId];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        let localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        return sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs }), this._cache.set(sch.schema, sch), addSchema && !baseId.startsWith("#") && (baseId && this._checkUnique(baseId), this.refs[baseId] = sch), validateSchema && this.validateSchema(schema, !0), sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id])
          throw new Error(`schema with key or id "${id}" already exists`);
      }
      _compileSchemaEnv(sch) {
        if (sch.meta ? this._compileMetaSchema(sch) : compile_1.compileSchema.call(this, sch), !sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        let currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (let key in checkOpts) {
        let opt = key;
        opt in options && this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      return keyRef = (0, resolve_1.normalizeId)(keyRef), this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      let optsSchemas = this.opts.schemas;
      if (optsSchemas)
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (let key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (let name in this.opts.formats) {
        let format = this.opts.formats[name];
        format && this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let keyword in defs) {
        let def = defs[keyword];
        def.keyword || (def.keyword = keyword), this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      let metaOpts = { ...this.opts };
      for (let opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === !1)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      let { RULES } = this;
      if ((0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      }), !!def && def.$data && !("code" in def || "validate" in def))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      let post = definition?.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      let { RULES } = this, ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (ruleGroup || (ruleGroup = { type: dataType, rules: [] }, RULES.rules.push(ruleGroup)), RULES.keywords[keyword] = !0, !definition)
        return;
      let rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      definition.before ? addBeforeRule.call(this, ruleGroup, rule, definition.before) : ruleGroup.rules.push(rule), RULES.all[keyword] = rule, (_a2 = definition.implements) === null || _a2 === void 0 || _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      let i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      i >= 0 ? ruleGroup.rules.splice(i, 0, rule) : (ruleGroup.rules.push(rule), this.logger.warn(`rule ${before} is not defined`));
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      metaSchema !== void 0 && (def.$data && this.opts.$data && (metaSchema = schemaOrData(metaSchema)), def.validateSchema = this.compile(metaSchema, !0));
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error(), code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), compile_1 = require_compile(), util_1 = require_util(), def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        let { gen, schema: $ref, it } = cxt, { baseId, schemaEnv: env, validateName, opts, self } = it, { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        let schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          let rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          let v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          let schName = gen.scopeValue("schema", opts.code.source === !0 ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch }), valid = gen.name("valid"), schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt), cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      let { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      let { gen, it } = cxt, { allErrors, schemaEnv: env, opts } = it, passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      $async ? callAsyncRef() : callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        let valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`), addEvaluatedFrom(v), allErrors || gen.assign(valid, !0);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e)), addErrorsFrom(e), allErrors || gen.assign(valid, !1);
        }), cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        let errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`), gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        let schEvaluated = (_a2 = sch?.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== !0)
          if (schEvaluated && !schEvaluated.dynamicProps)
            schEvaluated.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props));
          else {
            let props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        if (it.items !== !0)
          if (schEvaluated && !schEvaluated.dynamicItems)
            schEvaluated.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items));
          else {
            let items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var id_1 = require_id(), ref_1 = require_ref(), core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    }, def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    }, def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, it } = cxt, prec = it.opts.multipleOfPrecision, res = gen.let("res"), invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function ucs2length(str) {
      let len = str.length, length = 0, pos = 0, value;
      for (; pos < len; )
        length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), (value & 64512) === 56320 && pos++);
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), ucs2length_1 = require_ucs2length(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode, it } = cxt, op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT, len = it.opts.unicode === !1 ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    }, def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { data, $data, schema, schemaCode, it } = cxt, u = it.opts.unicodeRegExp ? "u" : "", regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    }, def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, schemaCode, data, $data, it } = cxt, { opts } = it;
        if (!$data && schema.length === 0)
          return;
        let useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors ? allErrorsMode() : exitOnErrorMode(), opts.strictRequired) {
          let props = cxt.parentSchema.properties, { definedProperties } = cxt.it;
          for (let requiredKey of schema)
            if (props?.[requiredKey] === void 0 && !definedProperties.has(requiredKey)) {
              let schemaPath = it.schemaEnv.baseId + it.errSchemaPath, msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
        }
        function allErrorsMode() {
          if (useLoop || $data)
            cxt.block$data(codegen_1.nil, loopAllRequired);
          else
            for (let prop of schema)
              (0, code_1.checkReportMissingProp)(cxt, prop);
        }
        function exitOnErrorMode() {
          let missing = gen.let("missing");
          if (useLoop || $data) {
            let valid = gen.let("valid", !0);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid)), cxt.ok(valid);
          } else
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing)), (0, code_1.reportMissingProp)(cxt, missing), gen.else();
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop }), gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing }), gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties)), gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(), gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var dataType_1 = require_dataType(), codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    }, def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        let valid = gen.let("valid"), itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`), cxt.ok(valid);
        function validateUniqueItems() {
          let i = gen.let("i", (0, codegen_1._)`${data}.length`), j = gen.let("j");
          cxt.setParams({ i, j }), gen.assign(valid, !0), gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          let item = gen.name("item"), wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong), indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`), gen.if(wrongType, (0, codegen_1._)`continue`), itemTypes.length > 1 && gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`), gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`), cxt.error(), gen.assign(valid, !1).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          let eql = (0, util_1.useFunc)(gen, equal_1.default), outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error(), gen.assign(valid, !1).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    }, def = {
      keyword: "const",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schemaCode, schema } = cxt;
        $data || schema && typeof schema == "object" ? cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`) : cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    }, def = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        let useLoop = schema.length >= it.opts.loopEnum, eql, getEql = () => eql ?? (eql = (0, util_1.useFunc)(gen, equal_1.default)), valid;
        if (useLoop || $data)
          valid = gen.let("valid"), cxt.block$data(valid, loopEnum);
        else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          let vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, !1), gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, !0).break()));
        }
        function equalCode(vSchema, i) {
          let sch = schema[i];
          return typeof sch == "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var limitNumber_1 = require_limitNumber(), multipleOf_1 = require_multipleOf(), limitLength_1 = require_limitLength(), pattern_1 = require_pattern(), limitProperties_1 = require_limitProperties(), required_1 = require_required(), limitItems_1 = require_limitItems(), uniqueItems_1 = require_uniqueItems(), const_1 = require_const(), enum_1 = require_enum(), validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { parentSchema, it } = cxt, { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      let { gen, schema, data, keyword, it } = cxt;
      it.items = !0;
      let len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === !1)
        cxt.setParams({ len: items.length }), cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        let valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid)), cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid), it.allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        let { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      let { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema), it.opts.unevaluated && schArr.length && it.items !== !0 && (it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items));
      let valid = gen.name("valid"), len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        (0, util_1.alwaysValidSchema)(it, sch) || (gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid)), cxt.ok(valid));
      });
      function checkStrictTuple(sch) {
        let { opts, errSchemaPath } = it, l = schArr.length, fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === !1);
        if (opts.strictTuples && !fullTuple) {
          let msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var items_1 = require_items(), def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), additionalItems_1 = require_additionalItems(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { schema, parentSchema, it } = cxt, { prefixItems } = parentSchema;
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && (prefixItems ? (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems) : cxt.ok((0, code_1.validateArray)(cxt)));
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    }, def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt, min, max, { minContains, maxContains } = parentSchema;
        it.opts.next ? (min = minContains === void 0 ? 1 : minContains, max = maxContains) : min = 1;
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (cxt.setParams({ min, max }), max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid'), cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          max !== void 0 && (cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`), cxt.pass(cond);
          return;
        }
        it.items = !0;
        let valid = gen.name("valid");
        max === void 0 && min === 1 ? validateItems(valid, () => gen.if(valid, () => gen.break())) : min === 0 ? (gen.let(valid, !0), max !== void 0 && gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount)) : (gen.let(valid, !1), validateItemsWithCount()), cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          let schValid = gen.name("_valid"), count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: !0
            }, _valid), block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`), max === void 0 ? gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0).break()) : (gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, !1).break()), min === 1 ? gen.assign(valid, !0) : gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0)));
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        let property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        let [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps), validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      let propertyDeps = {}, schemaDeps = {};
      for (let key in schema) {
        if (key === "__proto__")
          continue;
        let deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      let { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      let missing = gen.let("missing");
      for (let prop in propertyDeps) {
        let deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        let hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        }), it.allErrors ? gen.if(hasProperty, () => {
          for (let depProp of deps)
            (0, code_1.checkReportMissingProp)(cxt, depProp);
        }) : (gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`), (0, code_1.reportMissingProp)(cxt, missing), gen.else());
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      for (let prop in schemaDeps)
        (0, util_1.alwaysValidSchema)(it, schemaDeps[prop]) || (gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            let schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, !0)
          // TODO var
        ), cxt.ok(valid));
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    }, def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error2,
      code(cxt) {
        let { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        let valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key }), cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: !0
          }, valid), gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(!0), it.allErrors || gen.break();
          });
        }), cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), util_1 = require_util(), error2 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    }, def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        let { allErrors, opts } = it;
        if (it.props = !0, opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        let props = (0, code_1.allSchemaProperties)(parentSchema.properties), patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties(), cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            !props.length && !patProps.length ? additionalPropertyCode(key) : gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            let propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else props.length ? definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`)) : definedProp = codegen_1.nil;
          return patProps.length && (definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`))), (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === !1) {
            deleteAdditional(key);
            return;
          }
          if (schema === !1) {
            cxt.setParams({ additionalProperty: key }), cxt.error(), allErrors || gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            let valid = gen.name("valid");
            opts.removeAdditional === "failing" ? (applyAdditionalSchema(key, valid, !1), gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset(), deleteAdditional(key);
            })) : (applyAdditionalSchema(key, valid), allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break()));
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          let subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          errors === !1 && Object.assign(subschema, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var validate_1 = require_validate(), code_1 = require_code2(), util_1 = require_util(), additionalProperties_1 = require_additionalProperties(), def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt;
        it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0 && additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        let allProps = (0, code_1.allSchemaProperties)(schema);
        for (let prop of allProps)
          it.definedProperties.add(prop);
        it.opts.unevaluated && allProps.length && it.props !== !0 && (it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props));
        let properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        let valid = gen.name("valid");
        for (let prop of properties)
          hasDefault(prop) ? applyPropertySchema(prop) : (gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)), applyPropertySchema(prop), it.allErrors || gen.else().var(valid, !0), gen.endIf()), cxt.it.definedProperties.add(prop), cxt.ok(valid);
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), util_2 = require_util(), def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, data, parentSchema, it } = cxt, { opts } = it, patterns = (0, code_1.allSchemaProperties)(schema), alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === !0))
          return;
        let checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties, valid = gen.name("valid");
        it.props !== !0 && !(it.props instanceof codegen_1.Name) && (it.props = (0, util_2.evaluatedPropsToName)(gen, it.props));
        let { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (let pat of patterns)
            checkProperties && checkMatchingProperties(pat), it.allErrors ? validateProperties(pat) : (gen.var(valid, !0), validateProperties(pat), gen.if(valid));
        }
        function checkMatchingProperties(pat) {
          for (let prop in checkProperties)
            new RegExp(pat).test(prop) && (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              let alwaysValid = alwaysValidPatterns.includes(pat);
              alwaysValid || cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid), it.opts.unevaluated && props !== !0 ? gen.assign((0, codegen_1._)`${props}[${key}]`, !0) : !alwaysValid && !it.allErrors && gen.if((0, codegen_1.not)(valid), () => gen.break());
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(cxt) {
        let { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        let valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, valid), cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    }, def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        let schArr = schema, valid = gen.let("valid", !1), passing = gen.let("passing", null), schValid = gen.name("_valid");
        cxt.setParams({ passing }), gen.block(validateOneOf), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            (0, util_1.alwaysValidSchema)(it, sch) ? gen.var(schValid, !0) : schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: !0
            }, schValid), i > 0 && gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, !1).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else(), gen.if(schValid, () => {
              gen.assign(valid, !0), gen.assign(passing, i), schCxt && cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        let { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        let valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          let schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid), cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    }, def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, parentSchema, it } = cxt;
        parentSchema.then === void 0 && parentSchema.else === void 0 && (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        let hasThen = hasSchema(it, "then"), hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        let valid = gen.let("valid", !0), schValid = gen.name("_valid");
        if (validateIf(), cxt.reset(), hasThen && hasElse) {
          let ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause }), gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else hasThen ? gen.if(schValid, validateClause("then")) : gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        cxt.pass(valid, () => cxt.error(!0));
        function validateIf() {
          let schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            let schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid), cxt.mergeValidEvaluated(schCxt, valid), ifClause ? gen.assign(ifClause, (0, codegen_1._)`${keyword}`) : cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      let schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        parentSchema.if === void 0 && (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var additionalItems_1 = require_additionalItems(), prefixItems_1 = require_prefixItems(), items_1 = require_items(), items2020_1 = require_items2020(), contains_1 = require_contains(), dependencies_1 = require_dependencies(), propertyNames_1 = require_propertyNames(), additionalProperties_1 = require_additionalProperties(), properties_1 = require_properties(), patternProperties_1 = require_patternProperties(), not_1 = require_not(), anyOf_1 = require_anyOf(), oneOf_1 = require_oneOf(), allOf_1 = require_allOf(), if_1 = require_if(), thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = !1) {
      let applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      return draft2020 ? applicator.push(prefixItems_1.default, items2020_1.default) : applicator.push(additionalItems_1.default, items_1.default), applicator.push(contains_1.default), applicator;
    }
    exports.default = getApplicator;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    }, def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt, ruleType) {
        let { gen, data, $data, schema, schemaCode, it } = cxt, { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        $data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`), fType = gen.let("fType"), format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)), cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            return opts.strictSchema === !1 ? codegen_1.nil : (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            let callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`, validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          let formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === !0)
            return;
          let [fmtType, format, fmtRef] = getFormat(formatDef);
          fmtType === ruleType && cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === !1) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            let code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0, fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            return typeof fmtDef == "object" && !(fmtDef instanceof RegExp) ? [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`] : ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var format_1 = require_format(), format = [format_1.default];
    exports.default = format;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var core_1 = require_core2(), validation_1 = require_validation(), applicator_1 = require_applicator(), format_1 = require_format2(), metadata_1 = require_metadata(), draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2.Tag = "tag", DiscrError2.Mapping = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), types_1 = require_types(), compile_1 = require_compile(), ref_error_1 = require_ref_error(), util_1 = require_util(), error2 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    }, def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error2,
      code(cxt) {
        let { gen, data, schema, parentSchema, it } = cxt, { oneOf } = parentSchema;
        if (!it.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        let tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        let valid = gen.let("valid", !1), tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(!1, { discrError: types_1.DiscrError.Tag, tag, tagName })), cxt.ok(valid);
        function validateMapping() {
          let mapping = getMapping();
          gen.if(!1);
          for (let tagValue in mapping)
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`), gen.assign(valid, applyTagSchema(mapping[tagValue]));
          gen.else(), cxt.error(!1, { discrError: types_1.DiscrError.Mapping, tag, tagName }), gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          let _valid = gen.name("valid"), schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          return cxt.mergeEvaluated(schCxt, codegen_1.Name), _valid;
        }
        function getMapping() {
          var _a2;
          let oneOfMapping = {}, topRequired = hasRequired(parentSchema), tagRequired = !0;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (sch?.$ref && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              let ref = sch.$ref;
              if (sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref), sch instanceof compile_1.SchemaEnv && (sch = sch.schema), sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            let propSch = (_a2 = sch?.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            tagRequired = tagRequired && (topRequired || hasRequired(sch)), addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const)
              addMapping(sch.const, i);
            else if (sch.enum)
              for (let tagValue of sch.enum)
                addMapping(tagValue, i);
            else
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping)
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: !0,
        readOnly: {
          type: "boolean",
          default: !1
        },
        examples: {
          type: "array",
          items: !0
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: !1
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: {
          type: "array",
          items: !0,
          minItems: 1,
          uniqueItems: !0
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: !0
    };
  }
});

// mcp-servers-src/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core(), draft7_1 = require_draft7(), discriminator_1 = require_discriminator(), draft7MetaSchema = require_json_schema_draft_07(), META_SUPPORT_DATA = ["/properties"], META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies(), draft7_1.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        let metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, !1), this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: !0, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: !0, get: function() {
      return ref_error_1.default;
    } });
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date4, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(!0), compareTime),
      "date-time": fmtDef(getDateTime(!0), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date4(str) {
      let matches = DATE.exec(str);
      if (!matches)
        return !1;
      let year = +matches[1], month = +matches[2], day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (d1 && d2)
        return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function(str) {
        let matches = TIME.exec(str);
        if (!matches)
          return !1;
        let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return !1;
        if (hr <= 23 && min <= 59 && sec < 60)
          return !0;
        let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return;
      let t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf(), t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (t1 && t2)
        return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return;
      let a1 = TIME.exec(t1), a2 = TIME.exec(t2);
      if (a1 && a2)
        return t1 = a1[1] + a1[2] + a1[3], t2 = a2[1] + a2[2] + a2[3], t1 > t2 ? 1 : t1 < t2 ? -1 : 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      let time3 = getTime(strictTimeZone);
      return function(str) {
        let dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date4(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let d1 = new Date(dt1).valueOf(), d2 = new Date(dt2).valueOf();
      if (d1 && d2)
        return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let [d1, t1] = dt1.split(DATE_TIME_SEPARATOR), [d2, t2] = dt2.split(DATE_TIME_SEPARATOR), res = compareDate(d1, d2);
      if (res !== void 0)
        return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      return BYTE.lastIndex = 0, BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31), MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return !0;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return !1;
      try {
        return new RegExp(str), !0;
      } catch {
        return !1;
      }
    }
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv(), codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, keyword, it } = cxt, { opts, self } = it;
        if (!opts.validateFormats)
          return;
        let fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        fCxt.$data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          let format = fCxt.schema, fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === !0)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function")
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          let fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => (ajv.addKeyword(exports.formatLimitDefinition), ajv);
    exports.default = formatLimitPlugin;
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formats_1 = require_formats(), limit_1 = require_limit(), codegen_1 = require_codegen(), fullName = new codegen_1.Name("fullFormats"), fastName = new codegen_1.Name("fastFormats"), formatsPlugin = (ajv, opts = { keywords: !0 }) => {
      if (Array.isArray(opts))
        return addFormats(ajv, opts, formats_1.fullFormats, fullName), ajv;
      let [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName], list = opts.formats || formats_1.formatNames;
      return addFormats(ajv, list, formats, exportName), opts.keywords && (0, limit_1.default)(ajv), ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      let f = (mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats)[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a2, _b;
      (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== void 0 || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
      for (let f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.default = formatsPlugin;
  }
});

// mcp-servers-src/node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2, util2.arrayToEnum = (items) => {
    let obj = {};
    for (let item of items)
      obj[item] = item;
    return obj;
  }, util2.getValidEnumValues = (obj) => {
    let validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] != "number"), filtered = {};
    for (let k of validKeys)
      filtered[k] = obj[k];
    return util2.objectValues(filtered);
  }, util2.objectValues = (obj) => util2.objectKeys(obj).map(function(e) {
    return obj[e];
  }), util2.objectKeys = typeof Object.keys == "function" ? (obj) => Object.keys(obj) : (object3) => {
    let keys = [];
    for (let key in object3)
      Object.prototype.hasOwnProperty.call(object3, key) && keys.push(key);
    return keys;
  }, util2.find = (arr, checker) => {
    for (let item of arr)
      if (checker(item))
        return item;
  }, util2.isInteger = typeof Number.isInteger == "function" ? (val) => Number.isInteger(val) : (val) => typeof val == "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val == "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2, util2.jsonStringifyReplacer = (_, value) => typeof value == "bigint" ? value.toString() : value;
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => ({
    ...first,
    ...second
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (data) => {
  switch (typeof data) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(data) ? ZodParsedType.array : data === null ? ZodParsedType.null : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && data instanceof Map ? ZodParsedType.map : typeof Set < "u" && data instanceof Set ? ZodParsedType.set : typeof Date < "u" && data instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// mcp-servers-src/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super(), this.issues = [], this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    }, this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    let actualProto = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, actualProto) : this.__proto__ = actualProto, this.name = "ZodError", this.issues = issues;
  }
  format(_mapper) {
    let mapper = _mapper || function(issue2) {
      return issue2.message;
    }, fieldErrors = { _errors: [] }, processError = (error2) => {
      for (let issue2 of error2.issues)
        if (issue2.code === "invalid_union")
          issue2.unionErrors.map(processError);
        else if (issue2.code === "invalid_return_type")
          processError(issue2.returnTypeError);
        else if (issue2.code === "invalid_arguments")
          processError(issue2.argumentsError);
        else if (issue2.path.length === 0)
          fieldErrors._errors.push(mapper(issue2));
        else {
          let curr = fieldErrors, i = 0;
          for (; i < issue2.path.length; ) {
            let el = issue2.path[i];
            i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
          }
        }
    };
    return processError(this), fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError))
      throw new Error(`Not a ZodError: ${value}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    let fieldErrors = /* @__PURE__ */ Object.create(null), formErrors = [];
    for (let sub of this.issues)
      if (sub.path.length > 0) {
        let firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [], fieldErrors[firstEl].push(mapper(sub));
      } else
        formErrors.push(mapper(sub));
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => new ZodError(issues);

// mcp-servers-src/node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      issue2.received === ZodParsedType.undefined ? message = "Required" : message = `Expected ${issue2.expected}, received ${issue2.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      message = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      message = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof issue2.validation == "object" ? "includes" in issue2.validation ? (message = `Invalid input: must include "${issue2.validation.includes}"`, typeof issue2.validation.position == "number" && (message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`)) : "startsWith" in issue2.validation ? message = `Invalid input: must start with "${issue2.validation.startsWith}"` : "endsWith" in issue2.validation ? message = `Invalid input: must end with "${issue2.validation.endsWith}"` : util.assertNever(issue2.validation) : issue2.validation !== "regex" ? message = `Invalid ${issue2.validation}` : message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "more than"} ${issue2.minimum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "over"} ${issue2.minimum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "bigint" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue2.minimum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "less than"} ${issue2.maximum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "under"} ${issue2.maximum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "bigint" ? message = `BigInt must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly" : issue2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue2.maximum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError, util.assertNever(issue2);
  }
  return { message };
}, en_default = errorMap;

// mcp-servers-src/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// mcp-servers-src/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  let { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0)
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  let errorMessage = "", maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (let map2 of maps)
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  let overrideMap = getErrorMap(), issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(status, results) {
    let arrayValue = [];
    for (let s of results) {
      if (s.status === "aborted")
        return INVALID;
      s.status === "dirty" && status.dirty(), arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    let syncPairs = [];
    for (let pair of pairs) {
      let key = await pair.key, value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    let finalObject = {};
    for (let pair of pairs) {
      let { key, value } = pair;
      if (key.status === "aborted" || value.status === "aborted")
        return INVALID;
      key.status === "dirty" && status.dirty(), value.status === "dirty" && status.dirty(), key.value !== "__proto__" && (typeof value.value < "u" || pair.alwaysSet) && (finalObject[key.value] = value.value);
    }
    return { status: status.value, value: finalObject };
  }
}, INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise < "u" && x instanceof Promise;

// mcp-servers-src/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message == "string" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message == "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// mcp-servers-src/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}, handleResult = (ctx, result) => {
  if (isValid(result))
    return { success: !0, data: result.value };
  if (!ctx.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      let error2 = new ZodError(ctx.common.issues);
      return this._error = error2, this._error;
    }
  };
};
function processCreateParams(params) {
  if (!params)
    return {};
  let { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return errorMap2 ? { errorMap: errorMap2, description } : { errorMap: (iss, ctx) => {
    let { message } = params;
    return iss.code === "invalid_enum_value" ? { message: message ?? ctx.defaultError } : typeof ctx.data > "u" ? { message: message ?? required_error ?? ctx.defaultError } : iss.code !== "invalid_type" ? { message: ctx.defaultError } : { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    let result = this._parse(input);
    if (isAsync(result))
      throw new Error("Synchronous parse encountered promise.");
    return result;
  }
  _parseAsync(input) {
    let result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    let result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    let ctx = {
      common: {
        issues: [],
        async: params?.async ?? !1,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    let ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async)
      try {
        let result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        err?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), ctx.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    let result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    let ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: !0
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    let getIssueProperties = (val) => typeof message == "string" || typeof message > "u" ? { message } : typeof message == "function" ? message(val) : message;
    return this._refinement((val, ctx) => {
      let result = check2(val), setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      return typeof Promise < "u" && result instanceof Promise ? result.then((data) => data ? !0 : (setError(), !1)) : result ? !0 : (setError(), !1);
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => check2(val) ? !0 : (ctx.addIssue(typeof refinementData == "function" ? refinementData(val, ctx) : refinementData), !1));
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    let defaultValueFunc = typeof def == "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    let catchValueFunc = typeof def == "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    let This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", emojiRegex, ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = "[0-5]\\d";
  args.precision ? secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}` : args.precision == null && (secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`);
  let secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`, opts = [];
  return opts.push(args.local ? "Z?" : "Z"), args.offset && opts.push("([+-]\\d{2}:?\\d{2})"), regex = `${regex}(${opts.join("|")})`, new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4Regex.test(ip) || (version2 === "v6" || !version2) && ipv6Regex.test(ip));
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return !1;
  try {
    let [header] = jwt2.split(".");
    if (!header)
      return !1;
    let base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "="), decoded = JSON.parse(atob(base643));
    return !(typeof decoded != "object" || decoded === null || "typ" in decoded && decoded?.typ !== "JWT" || !decoded.alg || alg && decoded.alg !== alg);
  } catch {
    return !1;
  }
}
function isValidCidr(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip) || (version2 === "v6" || !version2) && ipv6CidrRegex.test(ip));
}
var ZodString = class _ZodString2 extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = String(input.data)), this._getType(input) !== ZodParsedType.string) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      if (check2.kind === "min")
        input.data.length < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "max")
        input.data.length > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "length") {
        let tooBig = input.data.length > check2.value, tooSmall = input.data.length < check2.value;
        (tooBig || tooSmall) && (ctx = this._getOrReturnCtx(input, ctx), tooBig ? addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }) : tooSmall && addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }), status.dirty());
      } else if (check2.kind === "email")
        emailRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "uuid")
        uuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "nanoid")
        nanoidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid")
        cuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid2")
        cuid2Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "ulid")
        ulidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "url")
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          }), status.dirty();
        }
      else check2.kind === "regex" ? (check2.regex.lastIndex = 0, check2.regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "regex",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty())) : check2.kind === "trim" ? input.data = input.data.trim() : check2.kind === "includes" ? input.data.includes(check2.value, check2.position) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { includes: check2.value, position: check2.position },
        message: check2.message
      }), status.dirty()) : check2.kind === "toLowerCase" ? input.data = input.data.toLowerCase() : check2.kind === "toUpperCase" ? input.data = input.data.toUpperCase() : check2.kind === "startsWith" ? input.data.startsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { startsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "endsWith" ? input.data.endsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { endsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "datetime" ? datetimeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "datetime",
        message: check2.message
      }), status.dirty()) : check2.kind === "date" ? dateRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "date",
        message: check2.message
      }), status.dirty()) : check2.kind === "time" ? timeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "time",
        message: check2.message
      }), status.dirty()) : check2.kind === "duration" ? durationRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "duration",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "ip" ? isValidIP(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "ip",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "jwt" ? isValidJWT(input.data, check2.alg) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "jwt",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "cidr" ? isValidCidr(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "cidr",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64" ? base64Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64url" ? base64urlRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64url",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: options
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      offset: options?.offset ?? !1,
      local: options?.local ?? !1,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: options
    }) : this._addCheck({
      kind: "time",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxLength() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodString.create = (params) => new ZodString({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodString,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
function floatSafeRemainder(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepDecCount = (step.toString().split(".")[1] || "").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce && (input.data = Number(input.data)), this._getType(input) !== ZodParsedType.number) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      }), INVALID;
    }
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "int" ? util.isInteger(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: check2.message
      }), status.dirty()) : check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? floatSafeRemainder(input.data, check2.value) !== 0 && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : check2.kind === "finite" ? Number.isFinite(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_finite,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (let ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
        return !0;
      ch.kind === "min" ? (min === null || ch.value > min) && (min = ch.value) : ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce)
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    if (this._getType(input) !== ZodParsedType.bigint)
      return this._getInvalidInput(input);
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? input.data % check2.value !== BigInt(0) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    }), INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodBigInt.create = (params) => new ZodBigInt({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodBigInt,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = !!input.data), this._getType(input) !== ZodParsedType.boolean) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = new Date(input.data)), this._getType(input) !== ZodParsedType.date) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      }), INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      check2.kind === "min" ? input.data.getTime() < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        minimum: check2.value,
        type: "date"
      }), status.dirty()) : check2.kind === "max" ? input.data.getTime() > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        maximum: check2.value,
        type: "date"
      }), status.dirty()) : util.assertNever(check2);
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => new ZodDate({
  checks: [],
  coerce: params?.coerce || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(params)
});
var ZodSymbol = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.symbol) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(params)
});
var ZodUndefined = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(params)
});
var ZodNull = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.null) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(params)
});
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(params)
});
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(params)
});
var ZodNever = class extends ZodType {
  _parse(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    }), INVALID;
  }
};
ZodNever.create = (params) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(params)
});
var ZodVoid = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(params)
});
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    let { ctx, status } = this._processInputParams(input), def = this._def;
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (def.exactLength !== null) {
      let tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;
      (tooBig || tooSmall) && (addIssueToContext(ctx, {
        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: tooSmall ? def.exactLength.value : void 0,
        maximum: tooBig ? def.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: def.exactLength.message
      }), status.dirty());
    }
    if (def.minLength !== null && ctx.data.length < def.minLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.minLength.message
    }), status.dirty()), def.maxLength !== null && ctx.data.length > def.maxLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.maxLength.message
    }), status.dirty()), ctx.common.async)
      return Promise.all([...ctx.data].map((item, i) => def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result2) => ParseStatus.mergeArray(status, result2));
    let result = [...ctx.data].map((item, i) => def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => new ZodArray({
  type: schema,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(params)
});
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    let newShape = {};
    for (let key in schema.shape) {
      let fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else return schema instanceof ZodArray ? new ZodArray({
    ...schema._def,
    type: deepPartialify(schema.element)
  }) : schema instanceof ZodOptional ? ZodOptional.create(deepPartialify(schema.unwrap())) : schema instanceof ZodNullable ? ZodNullable.create(deepPartialify(schema.unwrap())) : schema instanceof ZodTuple ? ZodTuple.create(schema.items.map((item) => deepPartialify(item))) : schema;
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    let shape = this._def.shape(), keys = util.objectKeys(shape);
    return this._cached = { shape, keys }, this._cached;
  }
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.object) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      }), INVALID;
    }
    let { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (let key in ctx.data)
        shapeKeys.includes(key) || extraKeys.push(key);
    let pairs = [];
    for (let key of shapeKeys) {
      let keyValidator = shape[key], value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      let unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough")
        for (let key of extraKeys)
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
      else if (unknownKeys === "strict")
        extraKeys.length > 0 && (addIssueToContext(ctx, {
          code: ZodIssueCode.unrecognized_keys,
          keys: extraKeys
        }), status.dirty());
      else if (unknownKeys !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let catchall = this._def.catchall;
      for (let key of extraKeys) {
        let value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    return ctx.common.async ? Promise.resolve().then(async () => {
      let syncPairs = [];
      for (let pair of pairs) {
        let key = await pair.key, value = await pair.value;
        syncPairs.push({
          key,
          value,
          alwaysSet: pair.alwaysSet
        });
      }
      return syncPairs;
    }).then((syncPairs) => ParseStatus.mergeObjectSync(status, syncPairs)) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    return errorUtil.errToObj, new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          let defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          return issue2.code === "unrecognized_keys" ? {
            message: errorUtil.errToObj(message).message ?? defaultError
          } : {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    return new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    let shape = {};
    for (let key of util.objectKeys(mask))
      mask[key] && this.shape[key] && (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    let shape = {};
    for (let key of util.objectKeys(this.shape))
      mask[key] || (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape)) {
      let fieldSchema = this.shape[key];
      mask && !mask[key] ? newShape[key] = fieldSchema : newShape[key] = fieldSchema.optional();
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape))
      if (mask && !mask[key])
        newShape[key] = this.shape[key];
      else {
        let newField = this.shape[key];
        for (; newField instanceof ZodOptional; )
          newField = newField._def.innerType;
        newShape[key] = newField;
      }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.strictCreate = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.lazycreate = (shape, params) => new ZodObject({
  shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
var ZodUnion = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), options = this._def.options;
    function handleResults(results) {
      for (let result of results)
        if (result.result.status === "valid")
          return result.result;
      for (let result of results)
        if (result.result.status === "dirty")
          return ctx.common.issues.push(...result.ctx.common.issues), result.result;
      let unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
    if (ctx.common.async)
      return Promise.all(options.map(async (option) => {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    {
      let dirty, issues = [];
      for (let option of options) {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }, result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid")
          return result;
        result.status === "dirty" && !dirty && (dirty = { result, ctx: childCtx }), childCtx.common.issues.length && issues.push(childCtx.common.issues);
      }
      if (dirty)
        return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
      let unionErrors = issues.map((issues2) => new ZodError(issues2));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => new ZodUnion({
  options: types,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(params)
});
var getDiscriminator = (type) => type instanceof ZodLazy ? getDiscriminator(type.schema) : type instanceof ZodEffects ? getDiscriminator(type.innerType()) : type instanceof ZodLiteral ? [type.value] : type instanceof ZodEnum ? type.options : type instanceof ZodNativeEnum ? util.objectValues(type.enum) : type instanceof ZodDefault ? getDiscriminator(type._def.innerType) : type instanceof ZodUndefined ? [void 0] : type instanceof ZodNull ? [null] : type instanceof ZodOptional ? [void 0, ...getDiscriminator(type.unwrap())] : type instanceof ZodNullable ? [null, ...getDiscriminator(type.unwrap())] : type instanceof ZodBranded || type instanceof ZodReadonly ? getDiscriminator(type.unwrap()) : type instanceof ZodCatch ? getDiscriminator(type._def.innerType) : [], ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);
    return option ? ctx.common.async ? option._parseAsync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : option._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : (addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [discriminator]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    let optionsMap = /* @__PURE__ */ new Map();
    for (let type of options) {
      let discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length)
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      for (let value of discriminatorValues) {
        if (optionsMap.has(value))
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  let aType = getParsedType(a), bType = getParsedType(b);
  if (a === b)
    return { valid: !0, data: a };
  if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    let bKeys = util.objectKeys(b), sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid)
        return { valid: !1 };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length)
      return { valid: !1 };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid)
        return { valid: !1 };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  } else return aType === ZodParsedType.date && bType === ZodParsedType.date && +a == +b ? { valid: !0, data: a } : { valid: !1 };
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight))
        return INVALID;
      let merged = mergeValues(parsedLeft.value, parsedRight.value);
      return merged.valid ? ((isDirty(parsedLeft) || isDirty(parsedRight)) && status.dirty(), { status: status.value, value: merged.data }) : (addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return ctx.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }),
      this._def.right._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
    ]).then(([left, right]) => handleParsed(left, right)) : handleParsed(this._def.left._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }), this._def.right._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }));
  }
};
ZodIntersection.create = (left, right, params) => new ZodIntersection({
  left,
  right,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(params)
});
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (ctx.data.length < this._def.items.length)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && ctx.data.length > this._def.items.length && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), status.dirty());
    let items = [...ctx.data].map((item, itemIndex) => {
      let schema = this._def.items[itemIndex] || this._def.rest;
      return schema ? schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)) : null;
    }).filter((x) => !!x);
    return ctx.common.async ? Promise.all(items).then((results) => ParseStatus.mergeArray(status, results)) : ParseStatus.mergeArray(status, items);
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;
    for (let key in ctx.data)
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    return ctx.common.async ? ParseStatus.mergeObjectAsync(status, pairs) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    return second instanceof ZodType ? new _ZodRecord({
      keyType: first,
      valueType: second,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(third)
    }) : new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}, ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      }), INVALID;
    let keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => ({
      key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
      value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
    }));
    if (ctx.common.async) {
      let finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let pair of pairs) {
          let key = await pair.key, value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted")
            return INVALID;
          (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      let finalMap = /* @__PURE__ */ new Map();
      for (let pair of pairs) {
        let key = pair.key, value = pair.value;
        if (key.status === "aborted" || value.status === "aborted")
          return INVALID;
        (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => new ZodMap({
  valueType,
  keyType,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(params)
});
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      }), INVALID;
    let def = this._def;
    def.minSize !== null && ctx.data.size < def.minSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.minSize.message
    }), status.dirty()), def.maxSize !== null && ctx.data.size > def.maxSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.maxSize.message
    }), status.dirty());
    let valueType = this._def.valueType;
    function finalizeSet(elements2) {
      let parsedSet = /* @__PURE__ */ new Set();
      for (let element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        element.status === "dirty" && status.dirty(), parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    let elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ctx.common.async ? Promise.all(elements).then((elements2) => finalizeSet(elements2)) : finalizeSet(elements);
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => new ZodSet({
  valueType,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(params)
});
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      }), INVALID;
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    let params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      let me = this;
      return OK(async function(...args) {
        let error2 = new ZodError([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          throw error2.addIssue(makeArgsIssue(args, e)), error2;
        }), result = await Reflect.apply(fn, this, parsedArgs);
        return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          throw error2.addIssue(makeReturnsIssue(result, e)), error2;
        });
      });
    } else {
      let me = this;
      return OK(function(...args) {
        let parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success)
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        let result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success)
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    return this.parse(func);
  }
  strictImplement(func) {
    return this.parse(func);
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}, ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => new ZodLazy({
  getter,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(params)
});
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => new ZodLiteral({
  value,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(params)
});
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data != "string") {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(input.data)) {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Values() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    let nativeEnumValues = util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(util.getValidEnumValues(this._def.values))), !this._cache.has(input.data)) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => new ZodNativeEnum({
  values,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(params)
});
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      }), INVALID;
    let promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => this._def.type.parseAsync(data, {
      path: ctx.path,
      errorMap: ctx.common.contextualErrorMap
    })));
  }
};
ZodPromise.create = (schema, params) => new ZodPromise({
  type: schema,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(params)
});
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg), arg.fatal ? status.abort() : status.dirty();
      },
      get path() {
        return ctx.path;
      }
    };
    if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === "preprocess") {
      let processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async)
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          let result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
        });
      {
        if (status.value === "aborted")
          return INVALID;
        let result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
      }
    }
    if (effect.type === "refinement") {
      let executeRefinement = (acc) => {
        let result = effect.refinement(acc, checkCtx);
        if (ctx.common.async)
          return Promise.resolve(result);
        if (result instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return acc;
      };
      if (ctx.common.async === !1) {
        let inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value), { status: status.value, value: inner.value });
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value).then(() => ({ status: status.value, value: inner.value }))));
    }
    if (effect.type === "transform")
      if (ctx.common.async === !1) {
        let base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        let result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: status.value, value: result };
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => isValid(base) ? Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
          status: status.value,
          value: result
        })) : INVALID);
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => new ZodEffects({
  schema,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect,
  ...processCreateParams(params)
});
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => new ZodEffects({
  schema,
  effect: { type: "preprocess", transform: preprocess2 },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(params)
});
var ZodOptional = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => new ZodOptional({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(params)
});
var ZodNullable = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => new ZodNullable({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(params)
});
var ZodDefault = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return ctx.parsedType === ZodParsedType.undefined && (data = this._def.defaultValue()), this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => new ZodDefault({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof params.default == "function" ? params.default : () => params.default,
  ...processCreateParams(params)
});
var ZodCatch = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    }, result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    return isAsync(result) ? result.then((result2) => ({
      status: "valid",
      value: result2.status === "valid" ? result2.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    })) : {
      status: "valid",
      value: result.status === "valid" ? result.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => new ZodCatch({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof params.catch == "function" ? params.catch : () => params.catch,
  ...processCreateParams(params)
});
var ZodNaN = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.nan) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(params)
});
var BRAND = Symbol("zod_brand"), ZodBranded = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.common.async)
      return (async () => {
        let inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), DIRTY(inResult.value)) : this._def.out._parseAsync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      })();
    {
      let inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), {
        status: "dirty",
        value: inResult.value
      }) : this._def.out._parseSync({
        data: inResult.value,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}, ZodReadonly = class extends ZodType {
  _parse(input) {
    let result = this._def.innerType._parse(input), freeze = (data) => (isValid(data) && (data.value = Object.freeze(data.value)), data);
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => new ZodReadonly({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(params)
});
var late = {
  object: ZodObject.lazycreate
}, ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3.ZodString = "ZodString", ZodFirstPartyTypeKind3.ZodNumber = "ZodNumber", ZodFirstPartyTypeKind3.ZodNaN = "ZodNaN", ZodFirstPartyTypeKind3.ZodBigInt = "ZodBigInt", ZodFirstPartyTypeKind3.ZodBoolean = "ZodBoolean", ZodFirstPartyTypeKind3.ZodDate = "ZodDate", ZodFirstPartyTypeKind3.ZodSymbol = "ZodSymbol", ZodFirstPartyTypeKind3.ZodUndefined = "ZodUndefined", ZodFirstPartyTypeKind3.ZodNull = "ZodNull", ZodFirstPartyTypeKind3.ZodAny = "ZodAny", ZodFirstPartyTypeKind3.ZodUnknown = "ZodUnknown", ZodFirstPartyTypeKind3.ZodNever = "ZodNever", ZodFirstPartyTypeKind3.ZodVoid = "ZodVoid", ZodFirstPartyTypeKind3.ZodArray = "ZodArray", ZodFirstPartyTypeKind3.ZodObject = "ZodObject", ZodFirstPartyTypeKind3.ZodUnion = "ZodUnion", ZodFirstPartyTypeKind3.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ZodFirstPartyTypeKind3.ZodIntersection = "ZodIntersection", ZodFirstPartyTypeKind3.ZodTuple = "ZodTuple", ZodFirstPartyTypeKind3.ZodRecord = "ZodRecord", ZodFirstPartyTypeKind3.ZodMap = "ZodMap", ZodFirstPartyTypeKind3.ZodSet = "ZodSet", ZodFirstPartyTypeKind3.ZodFunction = "ZodFunction", ZodFirstPartyTypeKind3.ZodLazy = "ZodLazy", ZodFirstPartyTypeKind3.ZodLiteral = "ZodLiteral", ZodFirstPartyTypeKind3.ZodEnum = "ZodEnum", ZodFirstPartyTypeKind3.ZodEffects = "ZodEffects", ZodFirstPartyTypeKind3.ZodNativeEnum = "ZodNativeEnum", ZodFirstPartyTypeKind3.ZodOptional = "ZodOptional", ZodFirstPartyTypeKind3.ZodNullable = "ZodNullable", ZodFirstPartyTypeKind3.ZodDefault = "ZodDefault", ZodFirstPartyTypeKind3.ZodCatch = "ZodCatch", ZodFirstPartyTypeKind3.ZodPromise = "ZodPromise", ZodFirstPartyTypeKind3.ZodBranded = "ZodBranded", ZodFirstPartyTypeKind3.ZodPipeline = "ZodPipeline", ZodFirstPartyTypeKind3.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create;

// mcp-servers-src/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (inst._zod || Object.defineProperty(inst, "_zod", {
      value: {
        def,
        constr: _,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), inst._zod.traits.has(name))
      return;
    inst._zod.traits.add(name), initializer3(inst, def);
    let proto = _.prototype, keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      let k = keys[i];
      k in inst || (inst[k] = proto[k].bind(inst));
    }
  }
  let Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    let inst = params?.Parent ? new Definition() : this;
    init(inst, def), (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (let fn of inst._zod.deferred)
      fn();
    return inst;
  }
  return Object.defineProperty(_, "init", { value: init }), Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => params?.Parent && inst instanceof params.Parent ? !0 : inst?._zod?.traits?.has(name)
  }), Object.defineProperty(_, "name", { value: name }), _;
}
var $brand = Symbol("zod_brand"), $ZodAsyncError = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}, $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`), this.name = "ZodEncodeError";
  }
}, globalConfig = {};
function config(newConfig) {
  return newConfig && Object.assign(globalConfig, newConfig), globalConfig;
}

// mcp-servers-src/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  let numericValues = Object.values(entries).filter((v) => typeof v == "number");
  return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  return typeof value == "bigint" ? value.toString() : value;
}
function cached(getter) {
  return {
    get value() {
      {
        let value = getter();
        return Object.defineProperty(this, "value", { value }), value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input == null;
}
function cleanRegex(source) {
  let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepString = step.toString(), stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    let match = stepString.match(/\d?e-(\d?)/);
    match?.[1] && (stepDecCount = Number.parseInt(match[1]));
  }
  let decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object3, key, getter) {
  let value;
  Object.defineProperty(object3, key, {
    get() {
      if (value !== EVALUATING)
        return value === void 0 && (value = EVALUATING, value = getter()), value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function mergeDefs(...defs) {
  let mergedDescriptors = {};
  for (let def of defs) {
    let descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  return path ? path.reduce((acc, key) => acc?.[key], obj) : obj;
}
function promiseAllObject(promisesObj) {
  let keys = Object.keys(promisesObj), promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    let resolvedObj = {};
    for (let i = 0; i < keys.length; i++)
      resolvedObj[keys[i]] = results[i];
    return resolvedObj;
  });
}
function randomString(length = 10) {
  let chars = "abcdefghijklmnopqrstuvwxyz", str = "";
  for (let i = 0; i < length; i++)
    str += chars[Math.floor(Math.random() * chars.length)];
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data == "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    let F = Function;
    return new F(""), !0;
  } catch {
    return !1;
  }
});
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  let ctor = o.constructor;
  if (ctor === void 0 || typeof ctor != "function")
    return !0;
  let prot = ctor.prototype;
  return !(isObject(prot) === !1 || Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === !1);
}
function shallowClone(o) {
  return isPlainObject(o) ? { ...o } : Array.isArray(o) ? [...o] : o;
}
function numKeys(data) {
  let keyCount = 0;
  for (let key in data)
    Object.prototype.hasOwnProperty.call(data, key) && keyCount++;
  return keyCount;
}
var getParsedType2 = (data) => {
  let t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(data) ? "array" : data === null ? "null" : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? "promise" : typeof Map < "u" && data instanceof Map ? "map" : typeof Set < "u" && data instanceof Set ? "set" : typeof Date < "u" && data instanceof Date ? "date" : typeof File < "u" && data instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]), primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  let cl = new inst._zod.constr(def ?? inst._zod.def);
  return (!def || params?.parent) && (cl._zod.parent = inst), cl;
}
function normalizeParams(_params) {
  let params = _params;
  if (!params)
    return {};
  if (typeof params == "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  return delete params.message, typeof params.error == "string" ? { ...params, error: () => params.error } : params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      return target ?? (target = getter()), Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      return target ?? (target = getter()), Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      return target ?? (target = getter()), Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      return target ?? (target = getter()), Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      return target ?? (target = getter()), Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      return target ?? (target = getter()), Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      return target ?? (target = getter()), Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  return typeof value == "bigint" ? value.toString() + "n" : typeof value == "string" ? `"${value}"` : `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional");
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = {};
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && (newShape[key] = currDef.shape[key]);
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = { ...schema._zod.def.shape };
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && delete newShape[key];
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to extend: expected a plain object");
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0) {
    let existingShape = schema._zod.def.shape;
    for (let key in shape)
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  let def = mergeDefs(a._zod.def, {
    get shape() {
      let _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in oldShape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key]);
        }
      else
        for (let key in oldShape)
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
      return assignProp(this, "shape", shape), shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in shape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          }));
        }
      else
        for (let key in oldShape)
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
      return assignProp(this, "shape", shape), shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === !0)
    return !0;
  for (let i = startIndex; i < x.issues.length; i++)
    if (x.issues[i]?.continue !== !0)
      return !0;
  return !1;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    return (_a2 = iss).path ?? (_a2.path = []), iss.path.unshift(path), iss;
  });
}
function unwrapMessage(message) {
  return typeof message == "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  let full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    let message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  return delete full.inst, delete full.continue, ctx?.reportInput || delete full.input, full;
}
function getSizableOrigin(input) {
  return input instanceof Set ? "set" : input instanceof Map ? "map" : input instanceof File ? "file" : "unknown";
}
function getLengthableOrigin(input) {
  return Array.isArray(input) ? "array" : typeof input == "string" ? "string" : "unknown";
}
function parsedType(data) {
  let t = typeof data;
  switch (t) {
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "object": {
      if (data === null)
        return "null";
      if (Array.isArray(data))
        return "array";
      let obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor)
        return obj.constructor.name;
    }
  }
  return t;
}
function issue(...args) {
  let [iss, input, inst] = args;
  return typeof iss == "string" ? {
    message: iss,
    code: "custom",
    input,
    inst
  } : { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => Number.isNaN(Number.parseInt(k, 10))).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  let binaryString = atob(base643), bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++)
    bytes[i] = binaryString.charCodeAt(i);
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++)
    binaryString += String.fromCharCode(bytes[i]);
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  let base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/"), padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  let cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  let bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2)
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// mcp-servers-src/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError", Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: !1
  }), Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: !1
  }), inst.message = JSON.stringify(def, jsonStringifyReplacer, 2), Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: !1
  });
}, $ZodError = $constructor("$ZodError", initializer), $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = {}, formErrors = [];
  for (let sub of error2.issues)
    sub.path.length > 0 ? (fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub))) : formErrors.push(mapper(sub));
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = { _errors: [] }, processError = (error3) => {
    for (let issue2 of error3.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues });
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues });
      else if (issue2.path.length === 0)
        fieldErrors._errors.push(mapper(issue2));
      else {
        let curr = fieldErrors, i = 0;
        for (; i < issue2.path.length; ) {
          let el = issue2.path[i];
          i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
        }
      }
  };
  return processError(error2), fieldErrors;
}

// mcp-servers-src/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !1 }) : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  if (result.issues.length) {
    let e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, _params?.callee), e;
  }
  return result.value;
}, parse = /* @__PURE__ */ _parse($ZodRealError), _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise && (result = await result), result.issues.length) {
    let e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, params?.callee), e;
  }
  return result.value;
}, parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError), _safeParse = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? { ..._ctx, async: !1 } : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  return result.issues.length ? {
    success: !1,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParse = /* @__PURE__ */ _safeParse($ZodRealError), _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  return result instanceof Promise && (result = await result), result.issues.length ? {
    success: !1,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError), _encode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var _decode = (_Err) => (schema, value, _ctx) => _parse(_Err)(schema, value, _ctx);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var _decodeAsync = (_Err) => async (schema, value, _ctx) => _parseAsync(_Err)(schema, value, _ctx);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var _safeDecode = (_Err) => (schema, value, _ctx) => _safeParse(_Err)(schema, value, _ctx);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => _safeParseAsync(_Err)(schema, value, _ctx);

// mcp-servers-src/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/, cuid2 = /^[0-9a-z]+$/, ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, xid = /^[0-9a-vA-V]{20}$/, ksuid = /^[A-Za-z0-9]{27}$/, nanoid = /^[a-zA-Z0-9_-]{21}$/, duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, uuid = (version2) => version2 ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, uuid4 = /* @__PURE__ */ uuid(4), uuid6 = /* @__PURE__ */ uuid(6), uuid7 = /* @__PURE__ */ uuid(7), email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, idnEmail = unicodeEmail, browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, _emoji = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, mac = (delimiter) => {
  let escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, base64url = /^[A-Za-z0-9_-]*$/, hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, e164 = /^\+[1-9]\d{6,14}$/, dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  let hhmm = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof args.precision == "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  let time3 = timeSource({ precision: args.precision }), opts = ["Z"];
  args.local && opts.push(""), args.offset && opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let timeRegex2 = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  let regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${regex}$`);
}, bigint = /^-?\d+n?$/, integer = /^-?\d+$/, number = /^-?\d+(?:\.\d+)?$/, boolean = /^(?:true|false)$/i, _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/, uppercase = /^[^a-z]*$/, hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/, md5_base64 = /* @__PURE__ */ fixedBase64(22, "=="), md5_base64url = /* @__PURE__ */ fixedBase64url(22), sha1_hex = /^[0-9a-fA-F]{40}$/, sha1_base64 = /* @__PURE__ */ fixedBase64(27, "="), sha1_base64url = /* @__PURE__ */ fixedBase64url(27), sha256_hex = /^[0-9a-fA-F]{64}$/, sha256_base64 = /* @__PURE__ */ fixedBase64(43, "="), sha256_base64url = /* @__PURE__ */ fixedBase64url(43), sha384_hex = /^[0-9a-fA-F]{96}$/, sha384_base64 = /* @__PURE__ */ fixedBase64(64, ""), sha384_base64url = /* @__PURE__ */ fixedBase64url(64), sha512_hex = /^[0-9a-fA-F]{128}$/, sha512_base64 = /* @__PURE__ */ fixedBase64(86, "=="), sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// mcp-servers-src/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {}), inst._zod.def = def, (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
}), numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    def.value < curr && (def.inclusive ? bag.maximum = def.value : bag.exclusiveMaximum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value <= def.value : payload.value < def.value) || payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    def.value > curr && (def.inclusive ? bag.minimum = def.value : bag.exclusiveMinimum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value >= def.value : payload.value > def.value) || payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  }), inst._zod.check = (payload) => {
    if (typeof payload.value != typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof payload.value == "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0) || payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def), def.format = def.format || "float64";
  let isInt = def.format?.includes("int"), origin = isInt ? "int" : "number", [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum, isInt && (bag.pattern = integer);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: !1,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        input > 0 ? payload.issues.push({
          input,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        }) : payload.issues.push({
          input,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        });
        return;
      }
    }
    input < minimum && payload.issues.push({
      origin: "number",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "number",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  let [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input < minimum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size <= def.maximum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size >= def.minimum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.size, bag.maximum = def.size, bag.size = def.size;
  }), inst._zod.check = (payload) => {
    let input = payload.value, size = input.size;
    if (size === def.size)
      return;
    let tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length <= def.maximum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length >= def.minimum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.length, bag.maximum = def.length, bag.length = def.length;
  }), inst._zod.check = (payload) => {
    let input = payload.value, length = input.length;
    if (length === def.length)
      return;
    let origin = getLengthableOrigin(input), tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, def.pattern && (bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(def.pattern));
  }), def.pattern ? (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? { pattern: def.pattern.toString() } : {},
      inst,
      continue: !def.abort
    });
  }) : (_b = inst._zod).check ?? (_b.check = () => {
  });
}), $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  let escapedRegex = escapeRegex(def.includes), pattern = new RegExp(typeof def.position == "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern, inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.includes(def.includes, def.position) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.startsWith(def.prefix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.endsWith(def.suffix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  result.issues.length && payload.issues.push(...prefixIssues(property, result.issues));
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    let result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise)
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    handleCheckPropertyResult(result, payload, def.property);
  };
}), $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  let mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  }), inst._zod.check = (payload) => {
    mimeSet.has(payload.value.type) || payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// mcp-servers-src/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [], this.indent = 0, this && (this.args = args);
  }
  indented(fn) {
    this.indent += 1, fn(this), this.indent -= 1;
  }
  write(arg) {
    if (typeof arg == "function") {
      arg(this, { execution: "sync" }), arg(this, { execution: "async" });
      return;
    }
    let lines = arg.split(`
`).filter((x) => x), minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length)), dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (let line of dedented)
      this.content.push(line);
  }
  compile() {
    let F = Function, args = this?.args, lines = [...(this?.content ?? [""]).map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
};

// mcp-servers-src/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// mcp-servers-src/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {}), inst._zod.def = def, inst._zod.bag = inst._zod.bag || {}, inst._zod.version = version;
  let checks = [...inst._zod.def.checks ?? []];
  inst._zod.traits.has("$ZodCheck") && checks.unshift(inst);
  for (let ch of checks)
    for (let fn of ch._zod.onattach)
      fn(inst);
  if (checks.length === 0)
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []), inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  else {
    let runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload), asyncResult;
      for (let ch of checks2) {
        if (ch._zod.def.when) {
          if (!ch._zod.def.when(payload))
            continue;
        } else if (isAborted2)
          continue;
        let currLen = payload.issues.length, _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === !1)
          throw new $ZodAsyncError();
        if (asyncResult || _ instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _, payload.issues.length !== currLen && (isAborted2 || (isAborted2 = aborted(payload, currLen)));
          });
        else {
          if (payload.issues.length === currLen)
            continue;
          isAborted2 || (isAborted2 = aborted(payload, currLen));
        }
      }
      return asyncResult ? asyncResult.then(() => payload) : payload;
    }, handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary))
        return canary.aborted = !0, canary;
      let checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks)
        return inst._zod.parse(payload, ctx);
      if (ctx.direction === "backward") {
        let canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: !0 });
        return canary instanceof Promise ? canary.then((canary2) => handleCanaryResult(canary2, payload, ctx)) : handleCanaryResult(canary, payload, ctx);
      }
      let result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        let r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag), inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch {
      }
    return typeof payload.value == "string" || payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), $ZodString.init(inst, def);
}), $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid), $ZodStringFormat.init(inst, def);
}), $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    let v = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
}), $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email), $ZodStringFormat.init(inst, def);
}), $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    try {
      let trimmed = payload.value.trim(), url2 = new URL(trimmed);
      def.hostname && (def.hostname.lastIndex = 0, def.hostname.test(url2.hostname) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: def.hostname.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.protocol && (def.protocol.lastIndex = 0, def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: def.protocol.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.normalize ? payload.value = url2.href : payload.value = trimmed;
      return;
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji()), $ZodStringFormat.init(inst, def);
}), $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid), $ZodStringFormat.init(inst, def);
}), $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid), $ZodStringFormat.init(inst, def);
}), $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2), $ZodStringFormat.init(inst, def);
}), $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid), $ZodStringFormat.init(inst, def);
}), $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid), $ZodStringFormat.init(inst, def);
}), $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid), $ZodStringFormat.init(inst, def);
}), $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date), $ZodStringFormat.init(inst, def);
}), $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration), $ZodStringFormat.init(inst, def);
}), $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv4";
}), $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv6", inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter)), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "mac";
}), $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4), $ZodStringFormat.init(inst, def);
}), $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6), $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    let parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      let [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      let prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return !0;
  if (data.length % 4 !== 0)
    return !1;
  try {
    return atob(data), !0;
  } catch {
    return !1;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64", inst._zod.check = (payload) => {
    isValidBase64(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return !1;
  let base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/"), padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64url", inst._zod.check = (payload) => {
    isValidBase64URL(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164), $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    let tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return !1;
    let [header] = tokensParts;
    if (!header)
      return !1;
    let parsedHeader = JSON.parse(atob(header));
    return !("typ" in parsedHeader && parsedHeader?.typ !== "JWT" || !parsedHeader.alg || algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm));
  } catch {
    return !1;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    isValidJWT2(payload.value, def.alg) || payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.fn(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = inst._zod.bag.pattern ?? number, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch {
      }
    let input = payload.value;
    if (typeof input == "number" && !Number.isNaN(input) && Number.isFinite(input))
      return payload;
    let received = typeof input == "number" ? Number.isNaN(input) ? "NaN" : Number.isFinite(input) ? void 0 : "Infinity" : void 0;
    return payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    }), payload;
  };
}), $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def), $ZodNumber.init(inst, def);
}), $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = boolean, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = !!payload.value;
      } catch {
      }
    let input = payload.value;
    return typeof input == "boolean" || payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = bigint, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch {
      }
    return typeof payload.value == "bigint" || payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def), $ZodBigInt.init(inst, def);
}), $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input == "symbol" || payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _undefined, inst._zod.values = /* @__PURE__ */ new Set([void 0]), inst._zod.optin = "optional", inst._zod.optout = "optional", inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _null, inst._zod.values = /* @__PURE__ */ new Set([null]), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input === null || payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => (payload.issues.push({
    expected: "never",
    code: "invalid_type",
    input: payload.value,
    inst
  }), payload);
}), $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = new Date(payload.value);
      } catch {
      }
    let input = payload.value, isDate = input instanceof Date;
    return isDate && !Number.isNaN(input.getTime()) || payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    }), payload;
  };
});
function handleArrayResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = Array(input.length);
    let proms = [];
    for (let i = 0; i < input.length; i++) {
      let item = input[i], result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleArrayResult(result2, payload, i))) : handleArrayResult(result, payload, i);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input))
      return;
    final.issues.push(...prefixIssues(key, result.issues));
  }
  result.value === void 0 ? key in input && (final.value[key] = void 0) : final.value[key] = result.value;
}
function normalizeDef(def) {
  let keys = Object.keys(def.shape);
  for (let k of keys)
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
  let okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  let unrecognized = [], keySet = def.keySet, _catchall = def.catchall._zod, t = _catchall.def.type, isOptionalOut = _catchall.optout === "optional";
  for (let key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    let r = _catchall.run({ value: input[key], issues: [] }, ctx);
    r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
  }
  return unrecognized.length && payload.issues.push({
    code: "unrecognized_keys",
    keys: unrecognized,
    input,
    inst
  }), proms.length ? Promise.all(proms).then(() => payload) : payload;
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  if ($ZodType.init(inst, def), !Object.getOwnPropertyDescriptor(def, "shape")?.get) {
    let sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        let newSh = { ...sh };
        return Object.defineProperty(def, "shape", {
          value: newSh
        }), newSh;
      }
    });
  }
  let _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    let shape = def.shape, propValues = {};
    for (let key in shape) {
      let field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (let v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  let isObject2 = isObject, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    if (!isObject2(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = {};
    let proms = [], shape = value.shape;
    for (let key of value.keys) {
      let el = shape[key], isOptionalOut = el._zod.optout === "optional", r = el._zod.run({ value: input[key], issues: [] }, ctx);
      r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
    return catchall ? handleCatchall(proms, input, payload, ctx, _normalized.value, inst) : proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  let superParse = inst._zod.parse, _normalized = cached(() => normalizeDef(def)), generateFastpass = (shape) => {
    let doc = new Doc(["shape", "payload", "ctx"]), normalized = _normalized.value, parseStr = (key) => {
      let k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write("const input = payload.value;");
    let ids = /* @__PURE__ */ Object.create(null), counter = 0;
    for (let key of normalized.keys)
      ids[key] = `key_${counter++}`;
    doc.write("const newResult = {};");
    for (let key of normalized.keys) {
      let id = ids[key], k = esc(key), isOptionalOut = shape[key]?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`), isOptionalOut ? doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `) : doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write("payload.value = newResult;"), doc.write("return payload;");
    let fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, fastpass, isObject2 = isObject, jit = !globalConfig.jitless, fastEnabled = jit && allowsEval.value, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    return isObject2(input) ? jit && fastEnabled && ctx?.async === !1 && ctx.jitless !== !0 ? (fastpass || (fastpass = generateFastpass(def.shape)), payload = fastpass(payload, ctx), catchall ? handleCatchall([], input, payload, ctx, value, inst) : payload) : superParse(payload, ctx) : (payload.issues.push({
      expected: "object",
      code: "invalid_type",
      input,
      inst
    }), payload);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (let result of results)
    if (result.issues.length === 0)
      return final.value = result.value, final;
  let nonaborted = results.filter((r) => !aborted(r));
  return nonaborted.length === 1 ? (final.value = nonaborted[0].value, nonaborted[0]) : (final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }), final);
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values))
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
  }), defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      let patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
  });
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    return async ? Promise.all(results).then((results2) => handleUnionResults(results2, payload, inst, ctx)) : handleUnionResults(results, payload, inst, ctx);
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  let successes = results.filter((r) => r.issues.length === 0);
  return successes.length === 1 ? (final.value = successes[0].value, final) : (successes.length === 0 ? final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }) : final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: [],
    inclusive: !1
  }), final);
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def), def.inclusive = !1;
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      result instanceof Promise ? (results.push(result), async = !0) : results.push(result);
    }
    return async ? Promise.all(results).then((results2) => handleExclusiveUnionResults(results2, payload, inst, ctx)) : handleExclusiveUnionResults(results, payload, inst, ctx);
  };
}), $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = !1, $ZodUnion.init(inst, def);
  let _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    let propValues = {};
    for (let option of def.options) {
      let pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (let [k, v] of Object.entries(pv)) {
        propValues[k] || (propValues[k] = /* @__PURE__ */ new Set());
        for (let val of v)
          propValues[k].add(val);
      }
    }
    return propValues;
  });
  let disc = cached(() => {
    let opts = def.options, map2 = /* @__PURE__ */ new Map();
    for (let o of opts) {
      let values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (let v of values) {
        if (map2.has(v))
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isObject(input))
      return payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      }), payload;
    let opt = disc.value.get(input?.[def.discriminator]);
    return opt ? opt._zod.run(payload, ctx) : def.unionFallback ? _super(payload, ctx) : (payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    }), payload);
  };
}), $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value, left = def.left._zod.run({ value: input, issues: [] }, ctx), right = def.right._zod.run({ value: input, issues: [] }, ctx);
    return left instanceof Promise || right instanceof Promise ? Promise.all([left, right]).then(([left2, right2]) => handleIntersectionResults(payload, left2, right2)) : handleIntersectionResults(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b)
    return { valid: !0, data: a };
  if (a instanceof Date && b instanceof Date && +a == +b)
    return { valid: !0, data: a };
  if (isPlainObject(a) && isPlainObject(b)) {
    let bKeys = Object.keys(b), sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length)
      return { valid: !1, mergeErrorPath: [] };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  let unrecKeys = /* @__PURE__ */ new Map(), unrecIssue;
  for (let iss of left.issues)
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).l = !0;
    } else
      result.issues.push(iss);
  for (let iss of right.issues)
    if (iss.code === "unrecognized_keys")
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).r = !0;
    else
      result.issues.push(iss);
  let bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue && result.issues.push({ ...unrecIssue, keys: bothKeys }), aborted(result))
    return result;
  let merged = mergeValues2(left.value, right.value);
  if (!merged.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  return result.value = merged.data, result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  let items = def.items;
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      }), payload;
    payload.value = [];
    let proms = [], reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional"), optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      let tooBig = input.length > items.length, tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall)
        return payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: !0 } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        }), payload;
    }
    let i = -1;
    for (let item of items) {
      if (i++, i >= input.length && i >= optStart)
        continue;
      let result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
    }
    if (def.rest) {
      let rest = input.slice(items.length);
      for (let el of rest) {
        i++;
        let result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleTupleResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isPlainObject(input))
      return payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [], values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      let recordKeys = /* @__PURE__ */ new Set();
      for (let key of values)
        if (typeof key == "string" || typeof key == "number" || typeof key == "symbol") {
          recordKeys.add(typeof key == "number" ? key.toString() : key);
          let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          result instanceof Promise ? proms.push(result.then((result2) => {
            result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[key] = result2.value;
          })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[key] = result.value);
        }
      let unrecognized;
      for (let key in input)
        recordKeys.has(key) || (unrecognized = unrecognized ?? [], unrecognized.push(key));
      unrecognized && unrecognized.length > 0 && payload.issues.push({
        code: "unrecognized_keys",
        input,
        inst,
        keys: unrecognized
      });
    } else {
      payload.value = {};
      for (let key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof key == "string" && number.test(key) && keyResult.issues.length) {
          let retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          retryResult.issues.length === 0 && (keyResult = retryResult);
        }
        if (keyResult.issues.length) {
          def.mode === "loose" ? payload.value[key] = input[key] : payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          continue;
        }
        let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => {
          result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[keyResult.value] = result2.value;
        })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[keyResult.value] = result.value);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Map))
      return payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (let [key, value] of input) {
      let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx), valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      keyResult instanceof Promise || valueResult instanceof Promise ? proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
        handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
      })) : handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  keyResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, keyResult.issues)) : final.issues.push({
    code: "invalid_key",
    origin: "map",
    input,
    inst,
    issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), valueResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, valueResult.issues)) : final.issues.push({
    origin: "map",
    code: "invalid_element",
    input,
    inst,
    key,
    issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Set))
      return payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (let item of input) {
      let result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleSetResult(result2, payload))) : handleSetResult(result, payload);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleSetResult(result, final) {
  result.issues.length && final.issues.push(...result.issues), final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  let values = getEnumValues(def.entries), valuesSet = new Set(values);
  inst._zod.values = valuesSet, inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o == "string" ? escapeRegex(o) : o.toString()).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return valuesSet.has(input) || payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    }), payload;
  };
}), $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  if ($ZodType.init(inst, def), def.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  let values = new Set(def.values);
  inst._zod.values = values, inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o == "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return values.has(input) || payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    }), payload;
  };
}), $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input instanceof File || payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    let _out = def.transform(payload.value, payload);
    if (ctx.async)
      return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output2) => (payload.value = output2, payload));
    if (_out instanceof Promise)
      throw new $ZodAsyncError();
    return payload.value = _out, payload;
  };
});
function handleOptionalResult(result, input) {
  return result.issues.length && input === void 0 ? { issues: [], value: void 0 } : result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", inst._zod.optout = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      let result = def.innerType._zod.run(payload, ctx);
      return result instanceof Promise ? result.then((r) => handleOptionalResult(r, payload.value)) : handleOptionalResult(result, payload.value);
    }
    return payload.value === void 0 ? payload : def.innerType._zod.run(payload, ctx);
  };
}), $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern), inst._zod.parse = (payload, ctx) => def.innerType._zod.run(payload, ctx);
}), $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  }), defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0), inst._zod.parse = (payload, ctx) => payload.value === null ? payload : def.innerType._zod.run(payload, ctx);
}), $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0)
      return payload.value = def.defaultValue, payload;
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleDefaultResult(result2, def)) : handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  return payload.value === void 0 && (payload.value = def.defaultValue), payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => (ctx.direction === "backward" || payload.value === void 0 && (payload.value = def.defaultValue), def.innerType._zod.run(payload, ctx));
}), $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => {
    let v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleNonOptionalResult(result2, inst)) : handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  return !payload.issues.length && payload.value === void 0 && payload.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: payload.value,
    inst
  }), payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError("ZodSuccess");
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.issues.length === 0, payload)) : (payload.value = result.issues.length === 0, payload);
  };
}), $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.value, result2.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload)) : (payload.value = result.value, result.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload);
  };
}), $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => ((typeof payload.value != "number" || !Number.isNaN(payload.value)) && payload.issues.push({
    input: payload.value,
    inst,
    expected: "nan",
    code: "invalid_type"
  }), payload);
}), $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handlePipeResult(right2, def.in, ctx)) : handlePipeResult(right, def.in, ctx);
    }
    let left = def.in._zod.run(payload, ctx);
    return left instanceof Promise ? left.then((left2) => handlePipeResult(left2, def.out, ctx)) : handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if ((ctx.direction || "forward") === "forward") {
      let left = def.in._zod.run(payload, ctx);
      return left instanceof Promise ? left.then((left2) => handleCodecAResult(left2, def, ctx)) : handleCodecAResult(left, def, ctx);
    } else {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handleCodecAResult(right2, def, ctx)) : handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length)
    return result.aborted = !0, result;
  if ((ctx.direction || "forward") === "forward") {
    let transformed = def.transform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx)) : handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    let transformed = def.reverseTransform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx)) : handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin), defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then(handleReadonlyResult) : handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  return payload.value = Object.freeze(payload.value), payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  let regexParts = [];
  for (let part of def.parts)
    if (typeof part == "object" && part !== null) {
      if (!part._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      let source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part))
      regexParts.push(escapeRegex(`${part}`));
    else
      throw new Error(`Invalid template literal part: ${part}`);
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`), inst._zod.parse = (payload, _ctx) => typeof payload.value != "string" ? (payload.issues.push({
    input: payload.value,
    inst,
    expected: "string",
    code: "invalid_type"
  }), payload) : (inst._zod.pattern.lastIndex = 0, inst._zod.pattern.test(payload.value) || payload.issues.push({
    input: payload.value,
    inst,
    code: "invalid_format",
    format: def.format ?? "template_literal",
    pattern: inst._zod.pattern.source
  }), payload);
}), $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => ($ZodType.init(inst, def), inst._def = def, inst._zod.def = def, inst.implement = (func) => {
  if (typeof func != "function")
    throw new Error("implement() must be called with a function");
  return function(...args) {
    let parsedArgs = inst._def.input ? parse(inst._def.input, args) : args, result = Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? parse(inst._def.output, result) : result;
  };
}, inst.implementAsync = (func) => {
  if (typeof func != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...args) {
    let parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args, result = await Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? await parseAsync(inst._def.output, result) : result;
  };
}, inst._zod.parse = (payload, _ctx) => typeof payload.value != "function" ? (payload.issues.push({
  code: "invalid_type",
  expected: "function",
  input: payload.value,
  inst
}), payload) : (inst._def.output && inst._def.output._zod.def.type === "promise" ? payload.value = inst.implementAsync(payload.value) : payload.value = inst.implement(payload.value), payload), inst.input = (...args) => {
  let F = inst.constructor;
  return Array.isArray(args[0]) ? new F({
    type: "function",
    input: new $ZodTuple({
      type: "tuple",
      items: args[0],
      rest: args[1]
    }),
    output: inst._def.output
  }) : new F({
    type: "function",
    input: args[0],
    output: inst._def.output
  });
}, inst.output = (output) => {
  let F = inst.constructor;
  return new F({
    type: "function",
    input: inst._def.input,
    output
  });
}, inst)), $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
}), $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "innerType", () => def.getter()), defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern), defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues), defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0), defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0), inst._zod.parse = (payload, ctx) => inst._zod.innerType._zod.run(payload, ctx);
}), $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def), $ZodType.init(inst, def), inst._zod.parse = (payload, _) => payload, inst._zod.check = (payload) => {
    let input = payload.value, r = def.fn(input);
    if (r instanceof Promise)
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    handleRefineResult(r, payload, input, inst);
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    let _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    inst._zod.def.params && (_iss.params = inst._zod.def.params), payload.issues.push(issue(_iss));
  }
}

// mcp-servers-src/node_modules/zod/v4/locales/en.js
var error = () => {
  let Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        return issue2.values.length === 1 ? `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}` : `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        return sizing ? `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}` : `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        return sizing ? `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}` : `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        return _issue.format === "starts_with" ? `Invalid string: must start with "${_issue.prefix}"` : _issue.format === "ends_with" ? `Invalid string: must end with "${_issue.suffix}"` : _issue.format === "includes" ? `Invalid string: must include "${_issue.includes}"` : _issue.format === "regex" ? `Invalid string: must match pattern ${_issue.pattern}` : `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function en_default2() {
  return {
    localeError: error()
  };
}

// mcp-servers-src/node_modules/zod/v4/core/registries.js
var _a, $output = Symbol("ZodOutput"), $input = Symbol("ZodInput"), $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    let meta3 = _meta[0];
    return this._map.set(schema, meta3), meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.set(meta3.id, schema), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(schema) {
    let meta3 = this._map.get(schema);
    return meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.delete(meta3.id), this._map.delete(schema), this;
  }
  get(schema) {
    let p = schema._zod.parent;
    if (p) {
      let pm = { ...this.get(p) ?? {} };
      delete pm.id;
      let f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// mcp-servers-src/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  return new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  let norm = normalizeParams(_params);
  return norm.abort ?? (norm.abort = !0), new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  return new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  let ch = /* @__PURE__ */ _check((payload) => (payload.addIssue = (issue2) => {
    if (typeof issue2 == "string")
      payload.issues.push(issue(issue2, payload.value, ch._zod.def));
    else {
      let _issue = issue2;
      _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = ch), _issue.continue ?? (_issue.continue = !ch._zod.def.abort), payload.issues.push(issue(_issue));
    }
  }, fn(payload.value, payload)));
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  let ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  return ch._zod.check = fn, ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  let ch = new $ZodCheck({ check: "describe" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  let ch = new $ZodCheck({ check: "meta" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  let params = normalizeParams(_params), truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  params.case !== "sensitive" && (truthyArray = truthyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v), falsyArray = falsyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v));
  let truthySet = new Set(truthyArray), falsySet = new Set(falsyArray), _Codec = Classes.Codec ?? $ZodCodec, _Boolean = Classes.Boolean ?? $ZodBoolean, _String = Classes.String ?? $ZodString, stringSchema = new _String({ type: "string", error: params.error }), booleanSchema = new _Boolean({ type: "boolean", error: params.error }), codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      return params.case !== "sensitive" && (data = data.toLowerCase()), truthySet.has(data) ? !0 : falsySet.has(data) ? !1 : (payload.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...truthySet, ...falsySet],
        input: payload.value,
        inst: codec2,
        continue: !1
      }), {});
    },
    reverseTransform: (input, _payload) => input === !0 ? truthyArray[0] || "true" : falsyArray[0] || "false",
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  let params = normalizeParams(_params), def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex == "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  return fnOrRegex instanceof RegExp && (def.pattern = fnOrRegex), new Class2(def);
}

// mcp-servers-src/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  return target === "draft-4" && (target = "draft-04"), target === "draft-7" && (target = "draft-07"), {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  let def = schema._zod.def, seen = ctx.seen.get(schema);
  if (seen)
    return seen.count++, _params.schemaPath.includes(schema) && (seen.cycle = _params.path), seen.schema;
  let result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  let overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema)
    result.schema = overrideSchema;
  else {
    let params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema)
      schema._zod.processJSONSchema(ctx, result.schema, params);
    else {
      let _json = result.schema, processor = ctx.processors[def.type];
      if (!processor)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      processor(schema, ctx, _json, params);
    }
    let parent = schema._zod.parent;
    parent && (result.ref || (result.ref = parent), process2(parent, ctx, params), ctx.seen.get(parent).isParent = !0);
  }
  let meta3 = ctx.metadataRegistry.get(schema);
  return meta3 && Object.assign(result.schema, meta3), ctx.io === "input" && isTransforming(schema) && (delete result.schema.examples, delete result.schema.default), ctx.io === "input" && result.schema._prefault && ((_a2 = result.schema).default ?? (_a2.default = result.schema._prefault)), delete result.schema._prefault, ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let idToSchema = /* @__PURE__ */ new Map();
  for (let entry of ctx.seen.entries()) {
    let id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      let existing = idToSchema.get(id);
      if (existing && existing !== entry[0])
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      idToSchema.set(id, entry[0]);
    }
  }
  let makeURI = (entry) => {
    let defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      let externalId = ctx.external.registry.get(entry[0])?.id, uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId)
        return { ref: uriGenerator(externalId) };
      let id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      return entry[1].defId = id, { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root)
      return { ref: "#" };
    let defUriPrefix = `#/${defsSegment}/`, defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, extractToDef = (entry) => {
    if (entry[1].schema.$ref)
      return;
    let seen = entry[1], { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema }, defId && (seen.defId = defId);
    let schema2 = seen.schema;
    for (let key in schema2)
      delete schema2[key];
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw")
    for (let entry of ctx.seen.entries()) {
      let seen = entry[1];
      if (seen.cycle)
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      let ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    if (ctx.metadataRegistry.get(entry[0])?.id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1 && ctx.reused === "ref") {
      extractToDef(entry);
      continue;
    }
  }
}
function finalize(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let flattenRef = (zodSchema) => {
    let seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    let schema2 = seen.def ?? seen.schema, _cached = { ...schema2 }, ref = seen.ref;
    if (seen.ref = null, ref) {
      flattenRef(ref);
      let refSeen = ctx.seen.get(ref), refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0") ? (schema2.allOf = schema2.allOf ?? [], schema2.allOf.push(refSchema)) : Object.assign(schema2, refSchema), Object.assign(schema2, _cached), zodSchema._zod.parent === ref)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in _cached || delete schema2[key];
      if (refSchema.$ref && refSeen.def)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key]) && delete schema2[key];
    }
    let parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      let parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref && (schema2.$ref = parentSeen.schema.$ref, parentSeen.def))
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key]) && delete schema2[key];
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (let entry of [...ctx.seen.entries()].reverse())
    flattenRef(entry[0]);
  let result = {};
  if (ctx.target === "draft-2020-12" ? result.$schema = "https://json-schema.org/draft/2020-12/schema" : ctx.target === "draft-07" ? result.$schema = "http://json-schema.org/draft-07/schema#" : ctx.target === "draft-04" ? result.$schema = "http://json-schema.org/draft-04/schema#" : ctx.target, ctx.external?.uri) {
    let id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  let defs = ctx.external?.defs ?? {};
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    seen.def && seen.defId && (defs[seen.defId] = seen.def);
  }
  ctx.external || Object.keys(defs).length > 0 && (ctx.target === "draft-2020-12" ? result.$defs = defs : result.definitions = defs);
  try {
    let finalized = JSON.parse(JSON.stringify(result));
    return Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), finalized;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  let ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return !1;
  ctx.seen.add(_schema);
  let def = _schema._zod.def;
  if (def.type === "transform")
    return !0;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault")
    return isTransforming(def.innerType, ctx);
  if (def.type === "intersection")
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  if (def.type === "record" || def.type === "map")
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  if (def.type === "pipe")
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  if (def.type === "object") {
    for (let key in def.shape)
      if (isTransforming(def.shape[key], ctx))
        return !0;
    return !1;
  }
  if (def.type === "union") {
    for (let option of def.options)
      if (isTransforming(option, ctx))
        return !0;
    return !1;
  }
  if (def.type === "tuple") {
    for (let item of def.items)
      if (isTransforming(item, ctx))
        return !0;
    return !!(def.rest && isTransforming(def.rest, ctx));
  }
  return !1;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  let ctx = initializeContext({ ...params, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  let { libraryOptions, target } = params ?? {}, ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
};

// mcp-servers-src/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, stringProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json;
  json2.type = "string";
  let { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum == "number" && (json2.minLength = minimum), typeof maximum == "number" && (json2.maxLength = maximum), format && (json2.format = formatMap[format] ?? format, json2.format === "" && delete json2.format, format === "time" && delete json2.format), contentEncoding && (json2.contentEncoding = contentEncoding), patterns && patterns.size > 0) {
    let regexes = [...patterns];
    regexes.length === 1 ? json2.pattern = regexes[0].source : regexes.length > 1 && (json2.allOf = [
      ...regexes.map((regex) => ({
        ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: regex.source
      }))
    ]);
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json, { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  typeof format == "string" && format.includes("int") ? json2.type = "integer" : json2.type = "number", typeof exclusiveMinimum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.minimum = exclusiveMinimum, json2.exclusiveMinimum = !0) : json2.exclusiveMinimum = exclusiveMinimum), typeof minimum == "number" && (json2.minimum = minimum, typeof exclusiveMinimum == "number" && ctx.target !== "draft-04" && (exclusiveMinimum >= minimum ? delete json2.minimum : delete json2.exclusiveMinimum)), typeof exclusiveMaximum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.maximum = exclusiveMaximum, json2.exclusiveMaximum = !0) : json2.exclusiveMaximum = exclusiveMaximum), typeof maximum == "number" && (json2.maximum = maximum, typeof exclusiveMaximum == "number" && ctx.target !== "draft-04" && (exclusiveMaximum <= maximum ? delete json2.maximum : delete json2.exclusiveMaximum)), typeof multipleOf == "number" && (json2.multipleOf = multipleOf);
}, booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, nullProcessor = (_schema, ctx, json2, _params) => {
  ctx.target === "openapi-3.0" ? (json2.type = "string", json2.nullable = !0, json2.enum = [null]) : json2.type = "null";
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {
}, unknownProcessor = (_schema, _ctx, _json, _params) => {
}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, enumProcessor = (schema, _ctx, json2, _params) => {
  let def = schema._zod.def, values = getEnumValues(def.entries);
  values.every((v) => typeof v == "number") && (json2.type = "number"), values.every((v) => typeof v == "string") && (json2.type = "string"), json2.enum = values;
}, literalProcessor = (schema, ctx, json2, _params) => {
  let def = schema._zod.def, vals = [];
  for (let val of def.values)
    if (val === void 0) {
      if (ctx.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof val == "bigint") {
      if (ctx.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      vals.push(Number(val));
    } else
      vals.push(val);
  if (vals.length !== 0)
    if (vals.length === 1) {
      let val = vals[0];
      json2.type = val === null ? "null" : typeof val, ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? json2.enum = [val] : json2.const = val;
    } else
      vals.every((v) => typeof v == "number") && (json2.type = "number"), vals.every((v) => typeof v == "string") && (json2.type = "string"), vals.every((v) => typeof v == "boolean") && (json2.type = "boolean"), vals.every((v) => v === null) && (json2.type = "null"), json2.enum = vals;
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string", _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum, maximum, mime } = schema._zod.bag;
  minimum !== void 0 && (file2.minLength = minimum), maximum !== void 0 && (file2.maxLength = maximum), mime ? mime.length === 1 ? (file2.contentMediaType = mime[0], Object.assign(_json, file2)) : (Object.assign(_json, file2), _json.anyOf = mime.map((m) => ({ contentMediaType: m }))) : Object.assign(_json, file2);
}, successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, arrayProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def, { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum), json2.type = "array", json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object", json2.properties = {};
  let shape = def.shape;
  for (let key in shape)
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  let allKeys = new Set(Object.keys(shape)), requiredKeys = new Set([...allKeys].filter((key) => {
    let v = def.shape[key]._zod;
    return ctx.io === "input" ? v.optin === void 0 : v.optout === void 0;
  }));
  requiredKeys.size > 0 && (json2.required = Array.from(requiredKeys)), def.catchall?._zod.def.type === "never" ? json2.additionalProperties = !1 : def.catchall ? def.catchall && (json2.additionalProperties = process2(def.catchall, ctx, {
    ...params,
    path: [...params.path, "additionalProperties"]
  })) : ctx.io === "output" && (json2.additionalProperties = !1);
}, unionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, isExclusive = def.inclusive === !1, options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  isExclusive ? json2.oneOf = options : json2.anyOf = options;
}, intersectionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  }), b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  }), isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1, allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "array";
  let prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items", restPath = ctx.target === "draft-2020-12" || ctx.target === "openapi-3.0" ? "items" : "additionalItems", prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  })), rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  ctx.target === "draft-2020-12" ? (json2.prefixItems = prefixItems, rest && (json2.items = rest)) : ctx.target === "openapi-3.0" ? (json2.items = {
    anyOf: prefixItems
  }, rest && json2.items.anyOf.push(rest), json2.minItems = prefixItems.length, rest || (json2.maxItems = prefixItems.length)) : (json2.items = prefixItems, rest && (json2.additionalItems = rest));
  let { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum);
}, recordProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object";
  let keyType = def.keyType, patterns = keyType._zod.bag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    let valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (let pattern of patterns)
      json2.patternProperties[pattern.source] = valueSchema;
  } else
    (ctx.target === "draft-07" || ctx.target === "draft-2020-12") && (json2.propertyNames = process2(def.keyType, ctx, {
      ...params,
      path: [...params.path, "propertyNames"]
    })), json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  let keyValues = keyType._zod.values;
  if (keyValues) {
    let validKeyValues = [...keyValues].filter((v) => typeof v == "string" || typeof v == "number");
    validKeyValues.length > 0 && (json2.required = validKeyValues);
  }
}, nullableProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, inner = process2(def.innerType, ctx, params), seen = ctx.seen.get(schema);
  ctx.target === "openapi-3.0" ? (seen.ref = def.innerType, json2.nullable = !0) : json2.anyOf = [inner, { type: "null" }];
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, ctx.io === "input" && (json2._prefault = JSON.parse(JSON.stringify(def.defaultValue)));
}, catchProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def, innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.readOnly = !0;
}, promiseProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  let innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  return !!s._zod;
}
function safeParse2(schema, data) {
  return isZ4Schema(schema) ? safeParse(schema, data) : schema.safeParse(data);
}
function getObjectShape(schema) {
  if (!schema)
    return;
  let rawShape;
  if (isZ4Schema(schema) ? rawShape = schema._zod?.def?.shape : rawShape = schema.shape, !!rawShape) {
    if (typeof rawShape == "function")
      try {
        return rawShape();
      } catch {
        return;
      }
    return rawShape;
  }
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    let def2 = schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0)
        return def2.values[0];
    }
  }
  let def = schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0)
      return def.values[0];
  }
  let directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
}

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var schemas_exports3 = {};
__export(schemas_exports3, {
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object2,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// mcp-servers-src/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// mcp-servers-src/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def), ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def), ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// mcp-servers-src/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues), inst.name = "ZodError", Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, ZodError2 = $constructor("ZodError", initializer2), ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// mcp-servers-src/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError), parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError), safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError), safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError), encode2 = /* @__PURE__ */ _encode(ZodRealError), decode2 = /* @__PURE__ */ _decode(ZodRealError), encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError), decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError), safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError), safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError), safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError), safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => ($ZodType.init(inst, def), Object.assign(inst["~standard"], {
  jsonSchema: {
    input: createStandardJSONSchemaMethod(inst, "input"),
    output: createStandardJSONSchemaMethod(inst, "output")
  }
}), inst.toJSONSchema = createToJSONSchemaMethod(inst, {}), inst.def = def, inst.type = def.type, Object.defineProperty(inst, "_def", { value: def }), inst.check = (...checks) => inst.clone(util_exports.mergeDefs(def, {
  checks: [
    ...def.checks ?? [],
    ...checks.map((ch) => typeof ch == "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
  ]
}), {
  parent: !0
}), inst.with = inst.check, inst.clone = (def2, params) => clone(inst, def2, params), inst.brand = () => inst, inst.register = (reg, meta3) => (reg.add(inst, meta3), inst), inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse }), inst.safeParse = (data, params) => safeParse3(inst, data, params), inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync }), inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params), inst.spa = inst.safeParseAsync, inst.encode = (data, params) => encode2(inst, data, params), inst.decode = (data, params) => decode2(inst, data, params), inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params), inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params), inst.safeEncode = (data, params) => safeEncode2(inst, data, params), inst.safeDecode = (data, params) => safeDecode2(inst, data, params), inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params), inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params), inst.refine = (check2, params) => inst.check(refine(check2, params)), inst.superRefine = (refinement) => inst.check(superRefine(refinement)), inst.overwrite = (fn) => inst.check(_overwrite(fn)), inst.optional = () => optional(inst), inst.exactOptional = () => exactOptional(inst), inst.nullable = () => nullable(inst), inst.nullish = () => optional(nullable(inst)), inst.nonoptional = (params) => nonoptional(inst, params), inst.array = () => array(inst), inst.or = (arg) => union([inst, arg]), inst.and = (arg) => intersection(inst, arg), inst.transform = (tx) => pipe(inst, transform(tx)), inst.default = (def2) => _default(inst, def2), inst.prefault = (def2) => prefault(inst, def2), inst.catch = (params) => _catch(inst, params), inst.pipe = (target) => pipe(inst, target), inst.readonly = () => readonly(inst), inst.describe = (description) => {
  let cl = inst.clone();
  return globalRegistry.add(cl, { description }), cl;
}, Object.defineProperty(inst, "description", {
  get() {
    return globalRegistry.get(inst)?.description;
  },
  configurable: !0
}), inst.meta = (...args) => {
  if (args.length === 0)
    return globalRegistry.get(inst);
  let cl = inst.clone();
  return globalRegistry.add(cl, args[0]), cl;
}, inst.isOptional = () => inst.safeParse(void 0).success, inst.isNullable = () => inst.safeParse(null).success, inst.apply = (fn) => fn(inst), inst)), _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  let bag = inst._zod.bag;
  inst.format = bag.format ?? null, inst.minLength = bag.minimum ?? null, inst.maxLength = bag.maximum ?? null, inst.regex = (...args) => inst.check(_regex(...args)), inst.includes = (...args) => inst.check(_includes(...args)), inst.startsWith = (...args) => inst.check(_startsWith(...args)), inst.endsWith = (...args) => inst.check(_endsWith(...args)), inst.min = (...args) => inst.check(_minLength(...args)), inst.max = (...args) => inst.check(_maxLength(...args)), inst.length = (...args) => inst.check(_length(...args)), inst.nonempty = (...args) => inst.check(_minLength(1, ...args)), inst.lowercase = (params) => inst.check(_lowercase(params)), inst.uppercase = (params) => inst.check(_uppercase(params)), inst.trim = () => inst.check(_trim()), inst.normalize = (...args) => inst.check(_normalize(...args)), inst.toLowerCase = () => inst.check(_toLowerCase()), inst.toUpperCase = () => inst.check(_toUpperCase()), inst.slugify = () => inst.check(_slugify());
}), ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def), _ZodString.init(inst, def), inst.email = (params) => inst.check(_email(ZodEmail, params)), inst.url = (params) => inst.check(_url(ZodURL, params)), inst.jwt = (params) => inst.check(_jwt(ZodJWT, params)), inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.uuid = (params) => inst.check(_uuid(ZodUUID, params)), inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params)), inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params)), inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params)), inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.cuid = (params) => inst.check(_cuid(ZodCUID, params)), inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params)), inst.ulid = (params) => inst.check(_ulid(ZodULID, params)), inst.base64 = (params) => inst.check(_base64(ZodBase64, params)), inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params)), inst.xid = (params) => inst.check(_xid(ZodXID, params)), inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params)), inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params)), inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params)), inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params)), inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params)), inst.e164 = (params) => inst.check(_e164(ZodE164, params)), inst.datetime = (params) => inst.check(datetime2(params)), inst.date = (params) => inst.check(date2(params)), inst.time = (params) => inst.check(time2(params)), inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString2, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), _ZodString.init(inst, def);
}), ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def), ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def), ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def), ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def), ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def), ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def), ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def), ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def), ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def), ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def), ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def), ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  let enc = params?.enc ?? "hex", format = `${alg}_${enc}`, regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.int = (params) => inst.check(int(params)), inst.safe = (params) => inst.check(int(params)), inst.positive = (params) => inst.check(_gt(0, params)), inst.nonnegative = (params) => inst.check(_gte(0, params)), inst.negative = (params) => inst.check(_lt(0, params)), inst.nonpositive = (params) => inst.check(_lte(0, params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params)), inst.step = (value, params) => inst.check(_multipleOf(value, params)), inst.finite = () => inst;
  let bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5), inst.isFinite = !0, inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber2, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def), ZodNumber2.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.positive = (params) => inst.check(_gt(BigInt(0), params)), inst.negative = (params) => inst.check(_lt(BigInt(0), params)), inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params)), inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  let bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null, inst.maxValue = bag.maximum ?? null, inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt2, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def), ZodBigInt2.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params), inst.min = (value, params) => inst.check(_gte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params));
  let c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null, inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params), inst.element = def.element, inst.min = (minLength, params) => inst.check(_minLength(minLength, params)), inst.nonempty = (params) => inst.check(_minLength(1, params)), inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params)), inst.length = (len, params) => inst.check(_length(len, params)), inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray2, element, params);
}
function keyof(schema) {
  let shape = schema._zod.def.shape;
  return _enum(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params), util_exports.defineLazy(inst, "shape", () => def.shape), inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)), inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall }), inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() }), inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 }), inst.extend = (incoming) => util_exports.extend(inst, incoming), inst.safeExtend = (incoming) => util_exports.safeExtend(inst, incoming), inst.merge = (other) => util_exports.merge(inst, other), inst.pick = (mask) => util_exports.pick(inst, mask), inst.omit = (mask) => util_exports.omit(inst, mask), inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]), inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  let def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodXor.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: !1,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params), inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  let hasRest = _paramsOrRest instanceof $ZodType, params = hasRest ? _params : _paramsOrRest, rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  let k = clone(keyType);
  return k._zod.values = void 0, new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType, inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params), inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params), inst.enum = def.entries, inst.options = Object.values(def.entries);
  let keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    let newEntries = {};
    for (let value of values)
      if (keys.has(value))
        newEntries[value] = def.entries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  }, inst.exclude = (values, params) => {
    let newEntries = { ...def.entries };
    for (let value of values)
      if (keys.has(value))
        delete newEntries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  let entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params), inst.values = new Set(def.values), Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params), inst.min = (size, params) => inst.check(_minSize(size, params)), inst.max = (size, params) => inst.check(_maxSize(size, params)), inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params), inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    payload.addIssue = (issue2) => {
      if (typeof issue2 == "string")
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      else {
        let _issue = issue2;
        _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = inst), payload.issues.push(util_exports.issue(_issue));
      }
    };
    let output = def.transform(payload.value, payload);
    return output instanceof Promise ? output.then((output2) => (payload.value = output2, payload)) : (payload.value = output, payload);
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue == "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN2, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params), inst.in = def.in, inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def), $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  let ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return ch._zod.check = fn, ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => !0), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe, meta2 = meta;
function _instanceof(cls, params = {}) {
  let inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: !0,
    ...util_exports.normalizeParams(params)
  });
  return inst._zod.bag.Class = cls, inst._zod.check = (payload) => {
    payload.value instanceof cls || payload.issues.push({
      code: "invalid_type",
      expected: cls.name,
      input: payload.value,
      inst,
      path: [...inst._zod.def.path ?? []]
    });
  }, inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json(params) {
  let jsonSchema = lazy(() => union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]));
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// mcp-servers-src/node_modules/zod/v4/classic/compat.js
var ZodFirstPartyTypeKind2;
ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {});

// mcp-servers-src/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports3,
  ...checks_exports2,
  iso: iso_exports2
};

// mcp-servers-src/node_modules/zod/v4/classic/external.js
config(en_default2());

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"], RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task", JSONRPC_VERSION = "2.0", AssertObjectSchema = custom((v) => v !== null && (typeof v == "object" || typeof v == "function")), ProgressTokenSchema = union([string2(), number2().int()]), CursorSchema = string2(), TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number2().optional()
}), TaskMetadataSchema = object2({
  ttl: number2().optional()
}), RelatedTaskMetadataSchema = object2({
  taskId: string2()
}), RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
}), BaseRequestParamsSchema = object2({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
}), TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
}), isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success, RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.loose().optional()
}), NotificationsParamsSchema = object2({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.loose().optional()
}), ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), RequestIdSchema = union([string2(), number2().int()]), JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict(), isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success, JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict(), isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success, JSONRPCResultResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict(), isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2.ConnectionClosed = -32e3] = "ConnectionClosed", ErrorCode2[ErrorCode2.RequestTimeout = -32001] = "RequestTimeout", ErrorCode2[ErrorCode2.ParseError = -32700] = "ParseError", ErrorCode2[ErrorCode2.InvalidRequest = -32600] = "InvalidRequest", ErrorCode2[ErrorCode2.MethodNotFound = -32601] = "MethodNotFound", ErrorCode2[ErrorCode2.InvalidParams = -32602] = "InvalidParams", ErrorCode2[ErrorCode2.InternalError = -32603] = "InternalError", ErrorCode2[ErrorCode2.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object2({
    /**
     * The error type that occurred.
     */
    code: number2().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string2(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]), JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]), EmptyResultSchema = ResultSchema.strict(), CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string2().optional()
}), CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
}), IconSchema = object2({
  /**
   * URL or data URI for the icon.
   */
  src: string2(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string2().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string2()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
}), IconsSchema = object2({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
}), BaseMetadataSchema = object2({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string2(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string2().optional()
}), ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string2().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string2().optional()
}), FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown())), ElicitationCapabilitySchema = preprocess((value) => value && typeof value == "object" && !Array.isArray(value) && Object.keys(value).length === 0 ? { form: {} } : value, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional())), ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ClientCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object2({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object2({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
}), InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
}), InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object2({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object2({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean2().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object2({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
}), InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string2().optional()
}), InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
}), ProgressSchema = object2({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number2(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number2()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string2())
}), ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
}), ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
}), PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
}), PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
}), PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
}), TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]), TaskSchema = object2({
  taskId: string2(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string2(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string2(),
  pollInterval: optional(number2()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string2())
}), CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
}), TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema), TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
}), GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskResultSchema = ResultSchema.merge(TaskSchema), GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskPayloadResultSchema = ResultSchema.loose(), ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
}), ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
}), CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), CancelTaskResultSchema = ResultSchema.merge(TaskSchema), ResourceContentsSchema = object2({
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string2()
}), Base64Schema = string2().refine((val) => {
  try {
    return atob(val), !0;
  } catch {
    return !1;
  }
}, { message: "Invalid Base64 string" }), BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
}), RoleSchema = _enum(["user", "assistant"]), AnnotationsSchema = object2({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number2().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports2.datetime({ offset: !0 }).optional()
}), ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string2(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
}), ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
}), ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
}), ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
}), ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string2()
}), ReadResourceRequestParamsSchema = ResourceRequestParamsSchema, ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
}), ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
}), ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
}), SubscribeRequestParamsSchema = ResourceRequestParamsSchema, SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
}), UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema, UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
}), ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string2()
}), ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
}), PromptArgumentSchema = object2({
  /**
   * The name of the argument.
   */
  name: string2(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string2()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean2())
}), PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string2()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
}), ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
}), GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string2(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string2(), string2()).optional()
}), GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
}), TextContentSchema = object2({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ImageContentSchema = object2({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), AudioContentSchema = object2({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ToolUseContentSchema = object2({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string2(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string2(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string2(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
}), ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]), PromptMessageSchema = object2({
  role: RoleSchema,
  content: ContentBlockSchema
}), GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string2().optional(),
  messages: array(PromptMessageSchema)
}), PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ToolAnnotationsSchema = object2({
  /**
   * A human-readable title for the tool.
   */
  title: string2().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean2().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean2().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean2().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean2().optional()
}), ToolExecutionSchema = object2({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
}), ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string2().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
}), ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
}), CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string2(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean2().optional()
}), CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
})), CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string2(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string2(), unknown()).optional()
}), CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
}), ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ListChangedOptionsBaseSchema = object2({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean2().default(!0),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number2().int().nonnegative().default(300)
}), LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
}), SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
}), LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string2().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
}), LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
}), ModelHintSchema = object2({
  /**
   * A hint for a model name.
   */
  name: string2().optional()
}), ModelPreferencesSchema = object2({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number2().min(0).max(1).optional()
}), ToolChoiceSchema = object2({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
}), ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).loose().optional(),
  isError: boolean2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]), SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]), SamplingMessageSchema = object2({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string2().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
}), CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
}), CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
}), CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
}), BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
}), StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
}), NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
}), UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
}), TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
}), LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
}), SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]), UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
}), TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
}), MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]), EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]), PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]), ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string2(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
}), ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string2(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string2(),
  /**
   * The URL that the user should navigate to.
   */
  url: string2().url()
}), ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]), ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
}), ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string2()
}), ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
}), ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
}), ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string2()
}), CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object2({
    /**
     * The name of the argument
     */
    name: string2(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string2()
  }),
  context: object2({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string2(), string2()).optional()
  }).optional()
}), CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string2()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number2().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean2())
  })
}), RootSchema = object2({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string2().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
}), ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
}), RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]), ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]), ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`), this.code = code, this.data = data, this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      let errorData = data;
      if (errorData.elicitations)
        return new UrlElicitationRequiredError(errorData.elicitations, message);
    }
    return new _McpError(code, message, data);
  }
}, UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  let methodSchema = getObjectShape(schema)?.method;
  if (!methodSchema)
    throw new Error("Schema is missing a method literal");
  let value = getLiteralValue(methodSchema);
  if (typeof value != "string")
    throw new Error("Schema method literal must be a string");
  return value;
}
function parseWithCompat(schema, data) {
  let result = safeParse2(schema, data);
  if (!result.success)
    throw result.error;
  return result.data;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4, Protocol = class {
  constructor(_options) {
    this._options = _options, this._requestMessageId = 0, this._requestHandlers = /* @__PURE__ */ new Map(), this._requestHandlerAbortControllers = /* @__PURE__ */ new Map(), this._notificationHandlers = /* @__PURE__ */ new Map(), this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers = /* @__PURE__ */ new Map(), this._timeoutInfo = /* @__PURE__ */ new Map(), this._pendingDebouncedNotifications = /* @__PURE__ */ new Set(), this._taskProgressTokens = /* @__PURE__ */ new Map(), this._requestResolvers = /* @__PURE__ */ new Map(), this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    }), this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    }), this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    ), this._taskStore = _options?.taskStore, this._taskMessageQueue = _options?.taskMessageQueue, this._taskStore && (this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
      let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
      if (!task)
        throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
      return {
        ...task
      };
    }), this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
      let handleTaskResult = async () => {
        let taskId = request.params.taskId;
        if (this._taskMessageQueue) {
          let queuedMessage;
          for (; queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId); ) {
            if (queuedMessage.type === "response" || queuedMessage.type === "error") {
              let message = queuedMessage.message, requestId = message.id, resolver = this._requestResolvers.get(requestId);
              if (resolver)
                if (this._requestResolvers.delete(requestId), queuedMessage.type === "response")
                  resolver(message);
                else {
                  let errorMessage = message, error2 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                  resolver(error2);
                }
              else {
                let messageType = queuedMessage.type === "response" ? "Response" : "Error";
                this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
              }
              continue;
            }
            await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
          }
        }
        let task = await this._taskStore.getTask(taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
        if (!isTerminal(task.status))
          return await this._waitForTaskUpdate(taskId, extra.signal), await handleTaskResult();
        if (isTerminal(task.status)) {
          let result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
          return this._clearTaskQueue(taskId), {
            ...result,
            _meta: {
              ...result._meta,
              [RELATED_TASK_META_KEY]: {
                taskId
              }
            }
          };
        }
        return await handleTaskResult();
      };
      return await handleTaskResult();
    }), this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
      try {
        let { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
        return {
          tasks,
          nextCursor,
          _meta: {}
        };
      } catch (error2) {
        throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }), this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
      try {
        let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
        await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId), this._clearTaskQueue(request.params.taskId);
        let cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!cancelledTask)
          throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
        return {
          _meta: {},
          ...cancelledTask
        };
      } catch (error2) {
        throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }));
  }
  async _oncancel(notification) {
    if (!notification.params.requestId)
      return;
    this._requestHandlerAbortControllers.get(notification.params.requestId)?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = !1) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    if (!info)
      return !1;
    let totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout)
      throw this._timeoutInfo.delete(messageId), McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    return clearTimeout(info.timeoutId), info.timeoutId = setTimeout(info.onTimeout, info.timeout), !0;
  }
  _cleanupTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    info && (clearTimeout(info.timeoutId), this._timeoutInfo.delete(messageId));
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport)
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    this._transport = transport;
    let _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.(), this._onclose();
    };
    let _onerror = this.transport?.onerror;
    this._transport.onerror = (error2) => {
      _onerror?.(error2), this._onerror(error2);
    };
    let _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra), isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message) ? this._onresponse(message) : isJSONRPCRequest(message) ? this._onrequest(message, extra) : isJSONRPCNotification(message) ? this._onnotification(message) : this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
    }, await this._transport.start();
  }
  _onclose() {
    let responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
    for (let controller of this._requestHandlerAbortControllers.values())
      controller.abort();
    this._requestHandlerAbortControllers.clear();
    let error2 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0, this.onclose?.();
    for (let handler of responseHandlers.values())
      handler(error2);
  }
  _onerror(error2) {
    this.onerror?.(error2);
  }
  _onnotification(notification) {
    let handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    handler !== void 0 && Promise.resolve().then(() => handler(notification)).catch((error2) => this._onerror(new Error(`Uncaught error in notification handler: ${error2}`)));
  }
  _onrequest(request, extra) {
    let handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler, capturedTransport = this._transport, relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      relatedTaskId && this._taskMessageQueue ? this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId).catch((error2) => this._onerror(new Error(`Failed to enqueue error response: ${error2}`))) : capturedTransport?.send(errorResponse).catch((error2) => this._onerror(new Error(`Failed to send an error response: ${error2}`)));
      return;
    }
    let abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    let taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0, taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0, fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        let notificationOptions = { relatedRequestId: request.id };
        relatedTaskId && (notificationOptions.relatedTask = { taskId: relatedTaskId }), await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        if (abortController.signal.aborted)
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        let requestOptions = { ...options, relatedRequestId: request.id };
        relatedTaskId && !requestOptions.relatedTask && (requestOptions.relatedTask = { taskId: relatedTaskId });
        let effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        return effectiveTaskId && taskStore && await taskStore.updateTaskStatus(effectiveTaskId, "input_required"), await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      taskCreationParams && this.assertTaskHandlerCapability(request.method);
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted)
        return;
      let response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "response",
        message: response,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(response);
    }, async (error2) => {
      if (abortController.signal.aborted)
        return;
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error2.code) ? error2.code : ErrorCode.InternalError,
          message: error2.message ?? "Internal error",
          ...error2.data !== void 0 && { data: error2.data }
        }
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(errorResponse);
    }).catch((error2) => this._onerror(new Error(`Failed to send response: ${error2}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    let { progressToken, ...params } = notification.params, messageId = Number(progressToken), handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    let responseHandler = this._responseHandlers.get(messageId), timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress)
      try {
        this._resetTimeout(messageId);
      } catch (error2) {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), responseHandler(error2);
        return;
      }
    handler(params);
  }
  _onresponse(response) {
    let messageId = Number(response.id), resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      if (this._requestResolvers.delete(messageId), isJSONRPCResultResponse(response))
        resolver(response);
      else {
        let error2 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error2);
      }
      return;
    }
    let handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId), this._cleanupTimeout(messageId);
    let isTaskResponse = !1;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result == "object") {
      let result = response.result;
      if (result.task && typeof result.task == "object") {
        let task = result.task;
        typeof task.taskId == "string" && (isTaskResponse = !0, this._taskProgressTokens.set(task.taskId, messageId));
      }
    }
    if (isTaskResponse || this._progressHandlers.delete(messageId), isJSONRPCResultResponse(response))
      handler(response);
    else {
      let error2 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error2);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    let { task } = options ?? {};
    if (!task) {
      try {
        yield { type: "result", result: await this.request(request, resultSchema, options) };
      } catch (error2) {
        yield {
          type: "error",
          error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
        };
      }
      return;
    }
    let taskId;
    try {
      let createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task)
        taskId = createResult.task.taskId, yield { type: "taskCreated", task: createResult.task };
      else
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      for (; ; ) {
        let task2 = await this.getTask({ taskId }, options);
        if (yield { type: "taskStatus", task: task2 }, isTerminal(task2.status)) {
          task2.status === "completed" ? yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) } : task2.status === "failed" ? yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
          } : task2.status === "cancelled" && (yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
          });
          return;
        }
        if (task2.status === "input_required") {
          yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) };
          return;
        }
        let pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval)), options?.signal?.throwIfAborted();
      }
    } catch (error2) {
      yield {
        type: "error",
        error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    let { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      let earlyReject = (error2) => {
        reject(error2);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === !0)
        try {
          this.assertCapabilityForMethod(request.method), task && this.assertTaskCapability(request.method);
        } catch (e) {
          earlyReject(e);
          return;
        }
      options?.signal?.throwIfAborted();
      let messageId = this._requestMessageId++, jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      options?.onprogress && (this._progressHandlers.set(messageId, options.onprogress), jsonrpcRequest.params = {
        ...request.params,
        _meta: {
          ...request.params?._meta || {},
          progressToken: messageId
        }
      }), task && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        task
      }), relatedTask && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        _meta: {
          ...jsonrpcRequest.params?._meta || {},
          [RELATED_TASK_META_KEY]: relatedTask
        }
      });
      let cancel = (reason) => {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error3) => this._onerror(new Error(`Failed to send cancellation: ${error3}`)));
        let error2 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error2);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (!options?.signal?.aborted) {
          if (response instanceof Error)
            return reject(response);
          try {
            let parseResult = safeParse2(resultSchema, response.result);
            parseResult.success ? resolve(parseResult.data) : reject(parseResult.error);
          } catch (error2) {
            reject(error2);
          }
        }
      }), options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      let timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC, timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? !1);
      let relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        let responseResolver = (response) => {
          let handler = this._responseHandlers.get(messageId);
          handler ? handler(response) : this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
        };
        this._requestResolvers.set(messageId, responseResolver), this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
      } else
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport)
      throw new Error("Not connected");
    this.assertNotificationCapability(notification.method);
    let relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      let jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    if ((this._options?.debouncedNotificationMethods ?? []).includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask) {
      if (this._pendingDebouncedNotifications.has(notification.method))
        return;
      this._pendingDebouncedNotifications.add(notification.method), Promise.resolve().then(() => {
        if (this._pendingDebouncedNotifications.delete(notification.method), !this._transport)
          return;
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        options?.relatedTask && (jsonrpcNotification2 = {
          ...jsonrpcNotification2,
          params: {
            ...jsonrpcNotification2.params,
            _meta: {
              ...jsonrpcNotification2.params?._meta || {},
              [RELATED_TASK_META_KEY]: options.relatedTask
            }
          }
        }), this._transport?.send(jsonrpcNotification2, options).catch((error2) => this._onerror(error2));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    options?.relatedTask && (jsonrpcNotification = {
      ...jsonrpcNotification,
      params: {
        ...jsonrpcNotification.params,
        _meta: {
          ...jsonrpcNotification.params?._meta || {},
          [RELATED_TASK_META_KEY]: options.relatedTask
        }
      }
    }), await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    let method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method), this._requestHandlers.set(method, (request, extra) => {
      let parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method))
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    let method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      let parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    let progressToken = this._taskProgressTokens.get(taskId);
    progressToken !== void 0 && (this._progressHandlers.delete(progressToken), this._taskProgressTokens.delete(taskId));
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue)
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    let maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      let messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (let message of messages)
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          let requestId = message.message.id, resolver = this._requestResolvers.get(requestId);
          resolver ? (resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(requestId)) : this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
        }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      let task = await this._taskStore?.getTask(taskId);
      task?.pollInterval && (interval = task.pollInterval);
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      let timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId), reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: !0 });
    });
  }
  requestTaskStore(request, sessionId) {
    let taskStore = this._taskStore;
    if (!taskStore)
      throw new Error("No task store configured");
    return {
      createTask: async (taskParams) => {
        if (!request)
          throw new Error("No request provided");
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        let task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification), isTerminal(task.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      getTaskResult: (taskId) => taskStore.getTaskResult(taskId, sessionId),
      updateTaskStatus: async (taskId, status, statusMessage) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        let updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification), isTerminal(updatedTask.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      listTasks: (cursor) => taskStore.listTasks(cursor, sessionId)
    };
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  let result = { ...base };
  for (let key in additional) {
    let k = key, addValue = additional[k];
    if (addValue === void 0)
      continue;
    let baseValue = result[k];
    isPlainObject2(baseValue) && isPlainObject2(addValue) ? result[k] = { ...baseValue, ...addValue } : result[k] = addValue;
  }
  return result;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1), import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  let ajv = new import_ajv.default({
    strict: !1,
    validateFormats: !0,
    validateSchema: !1,
    allErrors: !0
  });
  return (0, import_ajv_formats.default)(ajv), ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    let ajvValidator = "$id" in schema && typeof schema.$id == "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => ajvValidator(input) ? {
      valid: !0,
      data: input,
      errorMessage: void 0
    } : {
      valid: !1,
      data: void 0,
      errorMessage: this._ajv.errorsText(ajvValidator.errors)
    };
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
var ExperimentalServerTasks = class {
  constructor(_server) {
    this._server = _server;
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._server.requestStream(request, resultSchema, options);
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._server.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._server.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._server.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._server.cancelTask({ taskId }, options);
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call)
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage)
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create)
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      break;
    default:
      break;
  }
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server = class extends Protocol {
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    super(options), this._serverInfo = _serverInfo, this._loggingLevels = /* @__PURE__ */ new Map(), this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index])), this.isMessageIgnored = (level, sessionId) => {
      let currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : !1;
    }, this._capabilities = options?.capabilities ?? {}, this._instructions = options?.instructions, this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator(), this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request)), this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.()), this._capabilities.logging && this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
      let transportSessionId = extra.sessionId || extra.requestInfo?.headers["mcp-session-id"] || void 0, { level } = request.params, parseResult = LoggingLevelSchema.safeParse(level);
      return parseResult.success && this._loggingLevels.set(transportSessionId, parseResult.data), {};
    });
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    return this._experimental || (this._experimental = {
      tasks: new ExperimentalServerTasks(this)
    }), this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport)
      throw new Error("Cannot register capabilities after connecting to transport");
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce server-side validation for tools/call.
   */
  setRequestHandler(requestSchema, handler) {
    let methodSchema = getObjectShape(requestSchema)?.method;
    if (!methodSchema)
      throw new Error("Schema is missing a method literal");
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      let v4Schema = methodSchema;
      methodValue = v4Schema._zod?.def?.value ?? v4Schema.value;
    } else {
      let v3Schema = methodSchema;
      methodValue = v3Schema._def?.value ?? v3Schema.value;
    }
    if (typeof methodValue != "string")
      throw new Error("Schema method literal must be a string");
    if (methodValue === "tools/call") {
      let wrappedHandler = async (request, extra) => {
        let validatedRequest = safeParse2(CallToolRequestSchema, request);
        if (!validatedRequest.success) {
          let errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
        }
        let { params } = validatedRequest.data, result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          let taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            let errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        let validationResult = safeParse2(CallToolResultSchema, result);
        if (!validationResult.success) {
          let errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._clientCapabilities?.sampling)
          throw new Error(`Client does not support sampling (required for ${method})`);
        break;
      case "elicitation/create":
        if (!this._clientCapabilities?.elicitation)
          throw new Error(`Client does not support elicitation (required for ${method})`);
        break;
      case "roots/list":
        if (!this._clientCapabilities?.roots)
          throw new Error(`Client does not support listing roots (required for ${method})`);
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging)
          throw new Error(`Server does not support logging (required for ${method})`);
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources)
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools)
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts)
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        break;
      case "notifications/elicitation/complete":
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error(`Client does not support URL elicitation (required for ${method})`);
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (this._capabilities)
      switch (method) {
        case "completion/complete":
          if (!this._capabilities.completions)
            throw new Error(`Server does not support completions (required for ${method})`);
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging)
            throw new Error(`Server does not support logging (required for ${method})`);
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts)
            throw new Error(`Server does not support prompts (required for ${method})`);
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources)
            throw new Error(`Server does not support resources (required for ${method})`);
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools)
            throw new Error(`Server does not support tools (required for ${method})`);
          break;
        case "tasks/get":
        case "tasks/list":
        case "tasks/result":
        case "tasks/cancel":
          if (!this._capabilities.tasks)
            throw new Error(`Server does not support tasks capability (required for ${method})`);
          break;
        case "ping":
        case "initialize":
          break;
      }
  }
  assertTaskCapability(method) {
    assertClientRequestTaskCapability(this._clientCapabilities?.tasks?.requests, method, "Client");
  }
  assertTaskHandlerCapability(method) {
    this._capabilities && assertToolsCallTaskCapability(this._capabilities.tasks?.requests, method, "Server");
  }
  async _oninitialize(request) {
    let requestedVersion = request.params.protocolVersion;
    return this._clientCapabilities = request.params.capabilities, this._clientVersion = request.params.clientInfo, {
      protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  // Implementation
  async createMessage(params, options) {
    if ((params.tools || params.toolChoice) && !this._clientCapabilities?.sampling?.tools)
      throw new Error("Client does not support sampling tools capability.");
    if (params.messages.length > 0) {
      let lastMessage = params.messages[params.messages.length - 1], lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content], hasToolResults = lastContent.some((c) => c.type === "tool_result"), previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0, previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [], hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
      if (hasToolResults) {
        if (lastContent.some((c) => c.type !== "tool_result"))
          throw new Error("The last message must contain only tool_result content if any is present");
        if (!hasPreviousToolUse)
          throw new Error("tool_result blocks are not matching any tool_use from the previous message");
      }
      if (hasPreviousToolUse) {
        let toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id)), toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
        if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id)))
          throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
      }
    }
    return params.tools ? this.request({ method: "sampling/createMessage", params }, CreateMessageResultWithToolsSchema, options) : this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  /**
   * Creates an elicitation request for the given parameters.
   * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
   * @param params The parameters for the elicitation request.
   * @param options Optional request options.
   * @returns The result of the elicitation request.
   */
  async elicitInput(params, options) {
    switch (params.mode ?? "form") {
      case "url": {
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error("Client does not support url elicitation.");
        let urlParams = params;
        return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options);
      }
      case "form": {
        if (!this._clientCapabilities?.elicitation?.form)
          throw new Error("Client does not support form elicitation.");
        let formParams = params.mode === "form" ? params : { ...params, mode: "form" }, result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content && formParams.requestedSchema)
          try {
            let validationResult = this._jsonSchemaValidator.getValidator(formParams.requestedSchema)(result.content);
            if (!validationResult.valid)
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
          } catch (error2) {
            throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error2 instanceof Error ? error2.message : String(error2)}`);
          }
        return result;
      }
    }
  }
  /**
   * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
   * notification for the specified elicitation ID.
   *
   * @param elicitationId The ID of the elicitation to mark as complete.
   * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
   * @returns A function that emits the completion notification when awaited.
   */
  createElicitationCompletionNotifier(elicitationId, options) {
    if (!this._clientCapabilities?.elicitation?.url)
      throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
    return () => this.notification({
      method: "notifications/elicitation/complete",
      params: {
        elicitationId
      }
    }, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging && !this.isMessageIgnored(params.level, sessionId))
      return this.notification({ method: "notifications/message", params });
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
import process3 from "node:process";

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer)
      return null;
    let index = this._buffer.indexOf(`
`);
    if (index === -1)
      return null;
    let line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    return this._buffer = this._buffer.subarray(index + 1), deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var StdioServerTransport = class {
  constructor(_stdin = process3.stdin, _stdout = process3.stdout) {
    this._stdin = _stdin, this._stdout = _stdout, this._readBuffer = new ReadBuffer(), this._started = !1, this._ondata = (chunk) => {
      this._readBuffer.append(chunk), this.processReadBuffer();
    }, this._onerror = (error2) => {
      this.onerror?.(error2);
    };
  }
  /**
   * Starts listening for messages on stdin.
   */
  async start() {
    if (this._started)
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    this._started = !0, this._stdin.on("data", this._ondata), this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    for (; ; )
      try {
        let message = this._readBuffer.readMessage();
        if (message === null)
          break;
        this.onmessage?.(message);
      } catch (error2) {
        this.onerror?.(error2);
      }
  }
  async close() {
    this._stdin.off("data", this._ondata), this._stdin.off("error", this._onerror), this._stdin.listenerCount("data") === 0 && this._stdin.pause(), this._readBuffer.clear(), this.onclose?.();
  }
  send(message) {
    return new Promise((resolve) => {
      let json2 = serializeMessage(message);
      this._stdout.write(json2) ? resolve() : this._stdout.once("drain", resolve);
    });
  }
};

// mcp-servers-src/legal-citations/src/validators/citation-validator.ts
var CitationValidator = class _CitationValidator {
  // BGE/ATF/DTF citation patterns
  static BGE_PATTERN = /^BGE\s+(\d{1,3})\s+([IVX]+)\s+(\d+)$/i;
  static ATF_PATTERN = /^ATF\s+(\d{1,3})\s+([IVX]+)\s+(\d+)$/i;
  static DTF_PATTERN = /^DTF\s+(\d{1,3})\s+([IVX]+)\s+(\d+)$/i;
  // Statutory citation patterns (simplified)
  static STATUTE_PATTERN = /^Art\.\s*(\d+[a-z]?)(?:\s+Abs\.\s*(\d+))?(?:\s+lit\.\s*([a-z]))?(?:\s+Ziff\.\s*(\d+))?\s+(ZGB|OR|StGB|StPO|ZPO|BV|SchKG|DSG|URG|MSchG|PatG)/i;
  static STATUTE_PATTERN_FR = /^art\.\s*(\d+[a-z]?)(?:\s+al\.\s*(\d+))?(?:\s+let\.\s*([a-z]))?(?:\s+ch\.\s*(\d+))?\s+(CC|CO|CP|CPP|CPC|Cst|LP|LPD|LDA|LPM|LBI)/i;
  static STATUTE_PATTERN_IT = /^art\.\s*(\d+[a-z]?)(?:\s+cpv\.\s*(\d+))?(?:\s+lett\.\s*([a-z]))?(?:\s+n\.\s*(\d+))?\s+(CC|CO|CP|CPP|CPC|Cost|LEF|LPD|LDA|LPM|LBI)/i;
  // Valid Swiss federal statutes
  static VALID_STATUTES_DE = /* @__PURE__ */ new Set([
    "ZGB",
    "OR",
    "StGB",
    "StPO",
    "ZPO",
    "BV",
    "SchKG",
    "DSG",
    "URG",
    "MSchG",
    "PatG",
    "KG",
    "VVG",
    "ATSG",
    "AHVG",
    "IVG",
    "UVG",
    "BVG",
    "ELG",
    "FZG",
    "AVIG"
  ]);
  static VALID_STATUTES_FR = /* @__PURE__ */ new Set([
    "CC",
    "CO",
    "CP",
    "CPP",
    "CPC",
    "Cst",
    "LP",
    "LPD",
    "LDA",
    "LPM",
    "LBI",
    "LCart",
    "LCA",
    "LPGA",
    "LAVS",
    "LAI",
    "LAA",
    "LPP",
    "LPC",
    "LACI",
    "LPGA"
  ]);
  static VALID_STATUTES_IT = /* @__PURE__ */ new Set([
    "CC",
    "CO",
    "CP",
    "CPP",
    "CPC",
    "Cost",
    "LEF",
    "LPD",
    "LDA",
    "LPM",
    "LBI",
    "LCart",
    "LCA",
    "LPGA",
    "LAVS",
    "LAI",
    "LAINF",
    "LPP",
    "LPC",
    "LADI"
  ]);
  // Valid BGE chambers (Roman numerals)
  static VALID_CHAMBERS = /* @__PURE__ */ new Set([
    "I",
    "II",
    "III",
    "IV",
    "V",
    "VI",
    "VII",
    "VIII",
    "IX",
    "X"
  ]);
  /**
   * Validate a BGE (Bundesgericht) citation
   */
  validateBGE(citation) {
    let normalized = citation.trim(), match = _CitationValidator.BGE_PATTERN.exec(normalized);
    if (!match)
      return {
        valid: !1,
        type: "bge",
        errors: ["Invalid BGE citation format. Expected: BGE [volume] [chamber] [page]"]
      };
    let [, volume, chamber, page] = match, errors = [], warnings = [], volumeNum = parseInt(volume, 10);
    (volumeNum < 1 || volumeNum > 200) && warnings.push(`Unusual BGE volume number: ${volume}`), _CitationValidator.VALID_CHAMBERS.has(chamber.toUpperCase()) || errors.push(`Invalid BGE chamber: ${chamber}. Must be Roman numeral I-X`), parseInt(page, 10) < 1 && errors.push(`Invalid page number: ${page}`);
    let components = {
      volume,
      chamber: chamber.toUpperCase(),
      page
    };
    return {
      valid: errors.length === 0,
      type: "bge",
      normalized: `BGE ${volume} ${chamber.toUpperCase()} ${page}`,
      components,
      errors: errors.length > 0 ? errors : void 0,
      warnings: warnings.length > 0 ? warnings : void 0
    };
  }
  /**
   * Validate an ATF (Arrts du Tribunal fdral) citation
   */
  validateATF(citation) {
    let normalized = citation.trim(), match = _CitationValidator.ATF_PATTERN.exec(normalized);
    if (!match)
      return {
        valid: !1,
        type: "atf",
        errors: ["Invalid ATF citation format. Expected: ATF [volume] [chamber] [page]"]
      };
    let [, volume, chamber, page] = match, errors = [], warnings = [], volumeNum = parseInt(volume, 10);
    (volumeNum < 1 || volumeNum > 200) && warnings.push(`Unusual ATF volume number: ${volume}`), _CitationValidator.VALID_CHAMBERS.has(chamber.toUpperCase()) || errors.push(`Invalid ATF chamber: ${chamber}. Must be Roman numeral I-X`), parseInt(page, 10) < 1 && errors.push(`Invalid page number: ${page}`);
    let components = {
      volume,
      chamber: chamber.toUpperCase(),
      page
    };
    return {
      valid: errors.length === 0,
      type: "atf",
      normalized: `ATF ${volume} ${chamber.toUpperCase()} ${page}`,
      components,
      errors: errors.length > 0 ? errors : void 0,
      warnings: warnings.length > 0 ? warnings : void 0
    };
  }
  /**
   * Validate a DTF (Decisioni del Tribunale federale) citation
   */
  validateDTF(citation) {
    let normalized = citation.trim(), match = _CitationValidator.DTF_PATTERN.exec(normalized);
    if (!match)
      return {
        valid: !1,
        type: "dtf",
        errors: ["Invalid DTF citation format. Expected: DTF [volume] [chamber] [page]"]
      };
    let [, volume, chamber, page] = match, errors = [], warnings = [], volumeNum = parseInt(volume, 10);
    (volumeNum < 1 || volumeNum > 200) && warnings.push(`Unusual DTF volume number: ${volume}`), _CitationValidator.VALID_CHAMBERS.has(chamber.toUpperCase()) || errors.push(`Invalid DTF chamber: ${chamber}. Must be Roman numeral I-X`), parseInt(page, 10) < 1 && errors.push(`Invalid page number: ${page}`);
    let components = {
      volume,
      chamber: chamber.toUpperCase(),
      page
    };
    return {
      valid: errors.length === 0,
      type: "dtf",
      normalized: `DTF ${volume} ${chamber.toUpperCase()} ${page}`,
      components,
      errors: errors.length > 0 ? errors : void 0,
      warnings: warnings.length > 0 ? warnings : void 0
    };
  }
  /**
   * Validate a statutory citation (German)
   */
  validateStatuteDE(citation) {
    let normalized = citation.trim(), match = _CitationValidator.STATUTE_PATTERN.exec(normalized);
    if (!match)
      return {
        valid: !1,
        type: "statute",
        errors: ["Invalid statute citation format (DE). Expected: Art. [number] [Abs. X] [lit. a] [statute]"]
      };
    let [, article, paragraph, letter, number3, statute] = match, errors = [], warnings = [], statuteUpper = statute.toUpperCase();
    _CitationValidator.VALID_STATUTES_DE.has(statuteUpper) || errors.push(`Unknown statute code: ${statute}. Valid codes: ${Array.from(_CitationValidator.VALID_STATUTES_DE).join(", ")}`);
    let components = {
      statute: statute.toUpperCase(),
      article,
      paragraph: paragraph || void 0,
      letter: letter || void 0,
      number: number3 || void 0
    }, norm = `Art. ${article}`;
    return paragraph && (norm += ` Abs. ${paragraph}`), letter && (norm += ` lit. ${letter}`), number3 && (norm += ` Ziff. ${number3}`), norm += ` ${statute.toUpperCase()}`, {
      valid: errors.length === 0,
      type: "statute",
      normalized: norm,
      components,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Validate a statutory citation (French)
   */
  validateStatuteFR(citation) {
    let normalized = citation.trim(), match = _CitationValidator.STATUTE_PATTERN_FR.exec(normalized);
    if (!match)
      return {
        valid: !1,
        type: "statute",
        errors: ["Invalid statute citation format (FR). Expected: art. [number] [al. X] [let. a] [statute]"]
      };
    let [, article, paragraph, letter, number3, statute] = match, errors = [];
    _CitationValidator.VALID_STATUTES_FR.has(statute.toUpperCase()) || errors.push(`Unknown statute code: ${statute}`);
    let components = {
      statute: statute.toUpperCase(),
      article,
      paragraph: paragraph || void 0,
      letter: letter || void 0,
      number: number3 || void 0
    }, norm = `art. ${article}`;
    return paragraph && (norm += ` al. ${paragraph}`), letter && (norm += ` let. ${letter}`), number3 && (norm += ` ch. ${number3}`), norm += ` ${statute.toUpperCase()}`, {
      valid: errors.length === 0,
      type: "statute",
      normalized: norm,
      components,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Validate a statutory citation (Italian)
   */
  validateStatuteIT(citation) {
    let normalized = citation.trim(), match = _CitationValidator.STATUTE_PATTERN_IT.exec(normalized);
    if (!match)
      return {
        valid: !1,
        type: "statute",
        errors: ["Invalid statute citation format (IT). Expected: art. [number] [cpv. X] [lett. a] [statute]"]
      };
    let [, article, paragraph, letter, number3, statute] = match, errors = [];
    _CitationValidator.VALID_STATUTES_IT.has(statute.toUpperCase()) || errors.push(`Unknown statute code: ${statute}`);
    let components = {
      statute: statute.toUpperCase(),
      article,
      paragraph: paragraph || void 0,
      letter: letter || void 0,
      number: number3 || void 0
    }, norm = `art. ${article}`;
    return paragraph && (norm += ` cpv. ${paragraph}`), letter && (norm += ` lett. ${letter}`), number3 && (norm += ` n. ${number3}`), norm += ` ${statute.toUpperCase()}`, {
      valid: errors.length === 0,
      type: "statute",
      normalized: norm,
      components,
      errors: errors.length > 0 ? errors : void 0
    };
  }
  /**
   * Auto-detect citation type and validate
   */
  validate(citation) {
    let normalized = citation.trim().toUpperCase();
    if (normalized.startsWith("BGE"))
      return this.validateBGE(citation);
    if (normalized.startsWith("ATF"))
      return this.validateATF(citation);
    if (normalized.startsWith("DTF"))
      return this.validateDTF(citation);
    if (normalized.startsWith("ART.")) {
      let resultDE = this.validateStatuteDE(citation);
      if (resultDE.valid) return resultDE;
      let resultFR = this.validateStatuteFR(citation);
      if (resultFR.valid) return resultFR;
      let resultIT = this.validateStatuteIT(citation);
      return resultIT.valid ? resultIT : resultDE;
    }
    return {
      valid: !1,
      type: "unknown",
      errors: ["Unable to detect citation type. Supported: BGE/ATF/DTF, Art. [statute]"]
    };
  }
};

// mcp-servers-src/legal-citations/src/formatters/citation-formatter.ts
var CitationFormatter = class _CitationFormatter {
  // Statute name mappings across languages
  static STATUTE_NAMES = {
    ZGB: {
      de: "ZGB",
      fr: "CC",
      it: "CC",
      en: "CC"
      // Swiss Civil Code
    },
    CC: {
      de: "ZGB",
      fr: "CC",
      it: "CC",
      en: "CC"
    },
    OR: {
      de: "OR",
      fr: "CO",
      it: "CO",
      en: "CO"
      // Code of Obligations
    },
    CO: {
      de: "OR",
      fr: "CO",
      it: "CO",
      en: "CO"
    },
    STGB: {
      de: "StGB",
      fr: "CP",
      it: "CP",
      en: "CP"
      // Criminal Code
    },
    CP: {
      de: "StGB",
      fr: "CP",
      it: "CP",
      en: "CP"
    },
    STPO: {
      de: "StPO",
      fr: "CPP",
      it: "CPP",
      en: "CPP"
      // Criminal Procedure Code
    },
    CPP: {
      de: "StPO",
      fr: "CPP",
      it: "CPP",
      en: "CPP"
    },
    ZPO: {
      de: "ZPO",
      fr: "CPC",
      it: "CPC",
      en: "CPC"
      // Civil Procedure Code
    },
    CPC: {
      de: "ZPO",
      fr: "CPC",
      it: "CPC",
      en: "CPC"
    },
    BV: {
      de: "BV",
      fr: "Cst",
      it: "Cost",
      en: "Cst"
      // Federal Constitution
    },
    CST: {
      de: "BV",
      fr: "Cst",
      it: "Cost",
      en: "Cst"
    },
    COST: {
      de: "BV",
      fr: "Cst",
      it: "Cost",
      en: "Cst"
    },
    SCHKG: {
      de: "SchKG",
      fr: "LP",
      it: "LEF",
      en: "DEBA"
      // Debt Collection and Bankruptcy Act
    },
    LP: {
      de: "SchKG",
      fr: "LP",
      it: "LEF",
      en: "DEBA"
    },
    LEF: {
      de: "SchKG",
      fr: "LP",
      it: "LEF",
      en: "DEBA"
    },
    DSG: {
      de: "DSG",
      fr: "LPD",
      it: "LPD",
      en: "DPA"
      // Data Protection Act
    },
    LPD: {
      de: "DSG",
      fr: "LPD",
      it: "LPD",
      en: "DPA"
    }
  };
  // Full statute names
  static STATUTE_FULL_NAMES = {
    ZGB: {
      de: "Schweizerisches Zivilgesetzbuch",
      fr: "Code civil suisse",
      it: "Codice civile svizzero",
      en: "Swiss Civil Code"
    },
    OR: {
      de: "Obligationenrecht",
      fr: "Code des obligations",
      it: "Codice delle obbligazioni",
      en: "Code of Obligations"
    },
    StGB: {
      de: "Schweizerisches Strafgesetzbuch",
      fr: "Code p\xE9nal suisse",
      it: "Codice penale svizzero",
      en: "Swiss Criminal Code"
    },
    BV: {
      de: "Bundesverfassung der Schweizerischen Eidgenossenschaft",
      fr: "Constitution f\xE9d\xE9rale de la Conf\xE9d\xE9ration suisse",
      it: "Costituzione federale della Confederazione Svizzera",
      en: "Federal Constitution of the Swiss Confederation"
    }
  };
  // Citation component labels by language
  static LABELS = {
    de: {
      article: "Art.",
      paragraph: "Abs.",
      letter: "lit.",
      number: "Ziff."
    },
    fr: {
      article: "art.",
      paragraph: "al.",
      letter: "let.",
      number: "ch."
    },
    it: {
      article: "art.",
      paragraph: "cpv.",
      letter: "lett.",
      number: "n."
    },
    en: {
      article: "Art.",
      paragraph: "para.",
      letter: "let.",
      number: "no."
    }
  };
  /**
   * Format a BGE/ATF/DTF citation to target language
   */
  formatCourtCitation(type, components, targetLanguage) {
    let { volume, chamber, page } = components, citation = `${this.convertCourtCitationPrefix(type, targetLanguage)} ${volume} ${chamber} ${page}`;
    return {
      citation,
      language: targetLanguage,
      type,
      abbreviatedReference: citation,
      fullReference: citation
    };
  }
  /**
   * Convert BGE/ATF/DTF prefix based on language
   */
  convertCourtCitationPrefix(sourceType, targetLanguage) {
    return {
      de: "BGE",
      fr: "ATF",
      it: "DTF",
      en: "BGE"
      // Use German abbreviation for English
    }[targetLanguage];
  }
  /**
   * Format a statutory citation to target language
   */
  formatStatutoryCitation(components, targetLanguage, options = { language: targetLanguage }) {
    let { article, paragraph, letter, number: number3, statute } = components;
    if (!statute || !article)
      throw new Error("Statute and article are required for statutory citations");
    let labels = _CitationFormatter.LABELS[targetLanguage], convertedStatute = this.convertStatuteCode(statute, targetLanguage), citation = `${labels.article} ${article}`;
    paragraph && (citation += ` ${labels.paragraph} ${paragraph}`), letter && (citation += ` ${labels.letter} ${letter}`), number3 && (citation += ` ${labels.number} ${number3}`), citation += ` ${convertedStatute}`;
    let fullReference = citation;
    if (options.fullStatuteName) {
      let fullName = _CitationFormatter.STATUTE_FULL_NAMES[statute]?.[targetLanguage];
      fullName && (fullReference = `${citation} (${fullName})`);
    }
    return {
      citation,
      language: targetLanguage,
      type: "statute",
      abbreviatedReference: citation,
      fullReference
    };
  }
  /**
   * Convert statute code between languages
   */
  convertStatuteCode(statute, targetLanguage) {
    let normalizedStatute = statute.toUpperCase();
    if (_CitationFormatter.STATUTE_NAMES[normalizedStatute])
      return _CitationFormatter.STATUTE_NAMES[normalizedStatute][targetLanguage];
    for (let [baseStatute, translations] of Object.entries(_CitationFormatter.STATUTE_NAMES))
      for (let translation of Object.values(translations))
        if (translation.toUpperCase() === normalizedStatute)
          return translations[targetLanguage];
    return statute;
  }
  /**
   * Format any citation type to target language
   */
  format(type, components, targetLanguage, options) {
    let opts = {
      language: targetLanguage,
      includeAbbreviations: !0,
      fullStatuteName: !1,
      ...options
    };
    if (type === "bge" || type === "atf" || type === "dtf")
      return this.formatCourtCitation(type, components, targetLanguage);
    if (type === "statute" || type === "article")
      return this.formatStatutoryCitation(components, targetLanguage, opts);
    throw new Error(`Unsupported citation type for formatting: ${type}`);
  }
  /**
   * Convert citation from one language to another
   */
  convert(citation, sourceLanguage, targetLanguage, components, type) {
    return this.format(type, components, targetLanguage);
  }
  /**
   * Get all available translations for a citation
   */
  getAllTranslations(type, components) {
    let languages = ["de", "fr", "it", "en"], translations = {};
    for (let lang of languages)
      try {
        let formatted = this.format(type, components, lang);
        translations[lang] = formatted.citation;
      } catch {
      }
    return translations;
  }
};

// mcp-servers-src/legal-citations/src/parsers/citation-parser.ts
var CitationParser = class {
  validator;
  constructor() {
    this.validator = new CitationValidator();
  }
  /**
   * Detect language from citation string
   */
  detectLanguage(citation) {
    let normalized = citation.trim().toLowerCase();
    return normalized.includes(" al. ") || normalized.includes(" let. ") || normalized.includes(" ch. ") ? "fr" : normalized.includes(" cpv. ") || normalized.includes(" lett. ") ? "it" : normalized.includes(" abs. ") || normalized.includes(" lit. ") || normalized.includes(" ziff. ") ? "de" : normalized.startsWith("atf") ? "fr" : normalized.startsWith("dtf") ? "it" : normalized.startsWith("bge") ? "de" : normalized.includes(" cc") || normalized.includes(" co") || normalized.includes(" cst") ? normalized.includes(" cpv.") ? "it" : "fr" : (normalized.includes(" zgb") || normalized.includes(" or") || normalized.includes(" bv"), "de");
  }
  /**
   * Detect citation type
   */
  detectType(citation) {
    let normalized = citation.trim().toUpperCase();
    return normalized.startsWith("BGE") ? "bge" : normalized.startsWith("ATF") ? "atf" : normalized.startsWith("DTF") ? "dtf" : normalized.startsWith("ART.") ? "statute" : "unknown";
  }
  /**
   * Parse any Swiss legal citation
   */
  parse(citation) {
    let type = this.detectType(citation), language = this.detectLanguage(citation), validationResult = this.validator.validate(citation), parsed = {
      original: citation,
      type,
      components: validationResult.components || {},
      language,
      isValid: validationResult.valid
    };
    return !validationResult.valid && validationResult.errors && (parsed.suggestions = this.generateSuggestions(citation, type, language)), parsed;
  }
  /**
   * Parse multiple citations from text
   */
  parseMultiple(text) {
    let patterns = [
      // BGE/ATF/DTF: "BGE 123 IV 456"
      /(?:BGE|ATF|DTF)\s+\d{1,3}\s+[IVX]+\s+\d+/gi,
      // Statutory: "Art. 123 OR"
      /Art\.\s*\d+[a-z]?(?:\s+(?:Abs|al|cpv)\.\s*\d+)?(?:\s+(?:lit|let|lett)\.\s*[a-z])?(?:\s+(?:Ziff|ch|n)\.\s*\d+)?\s+[A-Z]{2,}/gi
    ], citations = [], foundCitations = /* @__PURE__ */ new Set();
    for (let pattern of patterns) {
      let matches = text.matchAll(pattern);
      for (let match of matches) {
        let citation = match[0];
        foundCitations.has(citation) || (foundCitations.add(citation), citations.push(this.parse(citation)));
      }
    }
    return citations;
  }
  /**
   * Generate suggestions for invalid citations
   */
  generateSuggestions(citation, type, language) {
    let suggestions = [];
    return (type === "bge" || type === "atf" || type === "dtf") && (suggestions.push("Format: BGE [volume] [chamber] [page]"), suggestions.push("Example: BGE 147 IV 73"), suggestions.push("Chamber must be Roman numeral (I-X)")), type === "statute" && (language === "de" ? (suggestions.push("Format: Art. [number] [Abs. X] [lit. a] [statute]"), suggestions.push("Example: Art. 97 Abs. 1 OR")) : language === "fr" ? (suggestions.push("Format: art. [number] [al. X] [let. a] [statute]"), suggestions.push("Example: art. 97 al. 1 CO")) : language === "it" && (suggestions.push("Format: art. [number] [cpv. X] [lett. a] [statute]"), suggestions.push("Example: art. 97 cpv. 1 CO"))), suggestions;
  }
  /**
   * Extract article number from citation
   */
  extractArticleNumber(citation) {
    let match = /Art\.\s*(\d+[a-z]?)/i.exec(citation);
    return match ? match[1] : null;
  }
  /**
   * Extract statute code from citation
   */
  extractStatuteCode(citation) {
    let match = /\s([A-Z]{2,})$/i.exec(citation.trim());
    return match ? match[1].toUpperCase() : null;
  }
  /**
   * Check if text contains legal citations
   */
  containsCitations(text) {
    return /(?:BGE|ATF|DTF)\s+\d{1,3}\s+[IVX]+\s+\d+|Art\.\s*\d+[a-z]?.*[A-Z]{2,}/i.test(text);
  }
  /**
   * Count citations in text
   */
  countCitations(text) {
    return this.parseMultiple(text).length;
  }
};

// mcp-servers-src/legal-citations/src/index.ts
var FEDLEX_BASE_URL = "https://www.fedlex.admin.ch/eli", STATUTE_SR_MAPPING = {
  // Civil Law
  ZGB: "210",
  // Zivilgesetzbuch
  CC: "210",
  // Code civil
  CCS: "210",
  // Codice civile svizzero
  // Obligations
  OR: "220",
  // Obligationenrecht
  CO: "220",
  // Code des obligations
  // Criminal Law
  StGB: "311.0",
  // Strafgesetzbuch
  CP: "311.0",
  // Code pnal
  CPS: "311.0",
  // Codice penale svizzero
  // Federal Constitution
  BV: "101",
  // Bundesverfassung
  Cst: "101",
  // Constitution fdrale
  Cost: "101",
  // Costituzione federale
  // Administrative Law
  VwVG: "172.021",
  // Verwaltungsverfahrensgesetz
  PA: "172.021",
  // Loi sur la procdure administrative
  // BGG
  BGG: "173.110",
  // Bundesgerichtsgesetz
  LTF: "173.110",
  // Loi sur le Tribunal fdral
  // SchKG
  SchKG: "281.1",
  // Schuldbetreibungs- und Konkursgesetz
  LP: "281.1",
  // Loi sur la poursuite pour dettes
  // ZPO
  ZPO: "272",
  // Zivilprozessordnung
  CPC: "272",
  // Code de procdure civile
  // StPO
  StPO: "312.0",
  // Strafprozessordnung
  CPP: "312.0",
  // Code de procdure pnale
  // AVIG
  AVIG: "837.0",
  // Arbeitslosenversicherungsgesetz
  LACI: "837.0",
  // Loi sur l'assurance-chmage
  // AHVG
  AHVG: "831.10",
  // AHV-Gesetz
  LAVS: "831.10",
  // Loi sur l'AVS
  // IVG
  IVG: "831.20",
  // Invalidenversicherungsgesetz
  LAI: "831.20",
  // Loi sur l'AI
  // BVG
  BVG: "831.40",
  // Bundesgesetz ber die berufliche Vorsorge
  LPP: "831.40",
  // Loi sur la prvoyance professionnelle
  // UVG
  UVG: "832.20",
  // Unfallversicherungsgesetz
  LAA: "832.20",
  // Loi sur l'assurance-accidents
  // KVG
  KVG: "832.10",
  // Krankenversicherungsgesetz
  LAMal: "832.10",
  // Loi sur l'assurance-maladie
  // DSG
  DSG: "235.1",
  // Datenschutzgesetz
  LPD: "235.1",
  // Loi sur la protection des donnes
  // IPRG
  IPRG: "291",
  // Bundesgesetz ber das Internationale Privatrecht
  LDIP: "291",
  // Loi sur le droit international priv
  // MWStG
  MWStG: "641.20",
  // Mehrwertsteuergesetz
  LTVA: "641.20",
  // Loi sur la TVA
  // DBG
  DBG: "642.11",
  // Direkte Bundessteuer
  LIFD: "642.11"
  // Loi sur l'impt fdral direct
}, STATUTE_FULL_NAMES = {
  ZGB: {
    de: "Schweizerisches Zivilgesetzbuch",
    fr: "Code civil suisse",
    it: "Codice civile svizzero",
    en: "Swiss Civil Code"
  },
  OR: {
    de: "Obligationenrecht",
    fr: "Code des obligations",
    it: "Diritto delle obbligazioni",
    en: "Code of Obligations"
  },
  StGB: {
    de: "Schweizerisches Strafgesetzbuch",
    fr: "Code p\xE9nal suisse",
    it: "Codice penale svizzero",
    en: "Swiss Criminal Code"
  },
  BV: {
    de: "Bundesverfassung der Schweizerischen Eidgenossenschaft",
    fr: "Constitution f\xE9d\xE9rale de la Conf\xE9d\xE9ration suisse",
    it: "Costituzione federale della Confederazione Svizzera",
    en: "Federal Constitution of the Swiss Confederation"
  },
  BGG: {
    de: "Bundesgerichtsgesetz",
    fr: "Loi sur le Tribunal f\xE9d\xE9ral",
    it: "Legge sul Tribunale federale",
    en: "Federal Supreme Court Act"
  },
  ZPO: {
    de: "Schweizerische Zivilprozessordnung",
    fr: "Code de proc\xE9dure civile",
    it: "Codice di diritto processuale civile svizzero",
    en: "Swiss Civil Procedure Code"
  },
  StPO: {
    de: "Schweizerische Strafprozessordnung",
    fr: "Code de proc\xE9dure p\xE9nale suisse",
    it: "Codice di diritto processuale penale svizzero",
    en: "Swiss Criminal Procedure Code"
  }
}, LegalCitationsMCPServer = class {
  server;
  validator;
  formatter;
  parser;
  constructor() {
    this.server = new Server(
      {
        name: "legal-citations",
        version: "1.1.0"
      },
      {
        capabilities: {
          tools: {}
        }
      }
    ), this.validator = new CitationValidator(), this.formatter = new CitationFormatter(), this.parser = new CitationParser(), this.setupToolHandlers(), this.setupErrorHandling();
  }
  setupErrorHandling() {
    this.server.onerror = (error2) => {
      console.error("[MCP Error]", error2);
    }, process.on("SIGINT", async () => {
      await this.server.close(), process.exit(0);
    });
  }
  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => ({
      tools: [
        {
          name: "validate_citation",
          description: "Validate a Swiss legal citation (BGE/ATF/DTF or statutory). Returns validation result with normalized citation and error messages if invalid.",
          inputSchema: {
            type: "object",
            properties: {
              citation: {
                type: "string",
                description: 'The legal citation to validate (e.g., "BGE 147 IV 73", "Art. 97 OR")'
              }
            },
            required: ["citation"]
          }
        },
        {
          name: "format_citation",
          description: "Format a Swiss legal citation to a specific language (DE/FR/IT/EN). Converts citation components while preserving legal meaning.",
          inputSchema: {
            type: "object",
            properties: {
              citation: {
                type: "string",
                description: "The legal citation to format"
              },
              targetLanguage: {
                type: "string",
                enum: ["de", "fr", "it", "en"],
                description: "Target language for formatting (de=German, fr=French, it=Italian, en=English)"
              },
              fullStatuteName: {
                type: "boolean",
                description: "Include full statute name in parentheses (optional, default: false)",
                default: !1
              }
            },
            required: ["citation", "targetLanguage"]
          }
        },
        {
          name: "convert_citation",
          description: "Convert a citation from one language to another. Auto-detects source language and converts to target language.",
          inputSchema: {
            type: "object",
            properties: {
              citation: {
                type: "string",
                description: "The legal citation to convert"
              },
              targetLanguage: {
                type: "string",
                enum: ["de", "fr", "it", "en"],
                description: "Target language (de=German, fr=French, it=Italian, en=English)"
              },
              fullStatuteName: {
                type: "boolean",
                description: "Include full statute name (optional, default: false)",
                default: !1
              }
            },
            required: ["citation", "targetLanguage"]
          }
        },
        {
          name: "parse_citation",
          description: "Parse a Swiss legal citation and extract all components. Returns citation type, language, components, and validity status.",
          inputSchema: {
            type: "object",
            properties: {
              citation: {
                type: "string",
                description: "The legal citation to parse"
              }
            },
            required: ["citation"]
          }
        },
        {
          name: "get_provision_text",
          description: "Retrieve the official text of a Swiss statutory provision from Fedlex. Returns the provision text in the requested language with metadata.",
          inputSchema: {
            type: "object",
            properties: {
              statute: {
                type: "string",
                description: 'Statute abbreviation (e.g., "OR", "ZGB", "StGB", "BV", "BGG")'
              },
              article: {
                type: "number",
                description: "Article number"
              },
              paragraph: {
                type: "number",
                description: "Paragraph/Absatz number (optional)"
              },
              letter: {
                type: "string",
                description: 'Letter/Buchstabe (optional, e.g., "a", "b")'
              },
              language: {
                type: "string",
                enum: ["de", "fr", "it"],
                description: "Language for the provision text (default: de)"
              },
              asOfDate: {
                type: "string",
                description: "Point-in-time version (ISO date format, optional)"
              }
            },
            required: ["statute", "article"]
          }
        },
        {
          name: "extract_citations",
          description: "Extract all legal citations from a document or text. Identifies BGE/ATF/DTF case citations and statutory references.",
          inputSchema: {
            type: "object",
            properties: {
              text: {
                type: "string",
                description: "The document text to analyze for citations"
              },
              includeTypes: {
                type: "array",
                items: {
                  type: "string",
                  enum: ["bge", "atf", "dtf", "statute", "cantonal", "all"]
                },
                description: "Types of citations to extract (default: all)"
              },
              validateCitations: {
                type: "boolean",
                description: "Whether to validate each extracted citation (default: true)"
              }
            },
            required: ["text"]
          }
        },
        {
          name: "standardize_document_citations",
          description: "Standardize all legal citations in a document to a consistent format and language. Returns the document with normalized citations.",
          inputSchema: {
            type: "object",
            properties: {
              text: {
                type: "string",
                description: "The document text containing citations to standardize"
              },
              targetLanguage: {
                type: "string",
                enum: ["de", "fr", "it", "en"],
                description: "Target language for standardized citations"
              },
              format: {
                type: "string",
                enum: ["short", "long", "academic"],
                description: "Citation format style (default: short)"
              },
              includeFullNames: {
                type: "boolean",
                description: "Include full statute names (default: false)"
              }
            },
            required: ["text", "targetLanguage"]
          }
        },
        {
          name: "compare_citation_versions",
          description: "Compare different versions of a statutory provision over time. Shows changes between versions with effective dates.",
          inputSchema: {
            type: "object",
            properties: {
              statute: {
                type: "string",
                description: 'Statute abbreviation (e.g., "OR", "ZGB")'
              },
              article: {
                type: "number",
                description: "Article number"
              },
              paragraph: {
                type: "number",
                description: "Paragraph number (optional)"
              },
              dateFrom: {
                type: "string",
                description: "Start date for version comparison (ISO format)"
              },
              dateTo: {
                type: "string",
                description: "End date for version comparison (ISO format, default: today)"
              },
              language: {
                type: "string",
                enum: ["de", "fr", "it"],
                description: "Language for provision text (default: de)"
              }
            },
            required: ["statute", "article"]
          }
        }
      ]
    })), this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      let { name, arguments: args } = request.params;
      try {
        switch (name) {
          case "validate_citation":
            return await this.handleValidateCitation(args);
          case "format_citation":
            return await this.handleFormatCitation(args);
          case "convert_citation":
            return await this.handleConvertCitation(args);
          case "parse_citation":
            return await this.handleParseCitation(args);
          case "get_provision_text":
            return await this.handleGetProvisionText(args);
          case "extract_citations":
            return await this.handleExtractCitations(args);
          case "standardize_document_citations":
            return await this.handleStandardizeDocumentCitations(args);
          case "compare_citation_versions":
            return await this.handleCompareCitationVersions(args);
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${name}`
            );
        }
      } catch (error2) {
        if (error2 instanceof McpError)
          throw error2;
        let errorMessage = error2 instanceof Error ? error2.message : "Unknown error";
        throw new McpError(
          ErrorCode.InternalError,
          `Error executing tool ${name}: ${errorMessage}`
        );
      }
    });
  }
  async handleValidateCitation(args) {
    let { citation } = args;
    if (!citation || typeof citation != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "Citation parameter is required and must be a string"
      );
    let result = this.validator.validate(citation);
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              valid: result.valid,
              type: result.type,
              normalized: result.normalized,
              components: result.components,
              errors: result.errors,
              warnings: result.warnings
            },
            null,
            2
          )
        }
      ]
    };
  }
  async handleFormatCitation(args) {
    let { citation, targetLanguage, fullStatuteName = !1 } = args;
    if (!citation || typeof citation != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "Citation parameter is required and must be a string"
      );
    if (!targetLanguage || !["de", "fr", "it", "en"].includes(targetLanguage))
      throw new McpError(
        ErrorCode.InvalidParams,
        "targetLanguage must be one of: de, fr, it, en"
      );
    let parsed = this.parser.parse(citation);
    if (!parsed.isValid)
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid citation: ${citation}`
      );
    let options = {
      language: targetLanguage,
      fullStatuteName
    }, formatted = this.formatter.format(
      parsed.type,
      parsed.components,
      targetLanguage,
      options
    );
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              original: citation,
              formatted: formatted.citation,
              language: formatted.language,
              type: formatted.type,
              fullReference: formatted.fullReference
            },
            null,
            2
          )
        }
      ]
    };
  }
  async handleConvertCitation(args) {
    let { citation, targetLanguage, fullStatuteName = !1 } = args;
    if (!citation || typeof citation != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "Citation parameter is required and must be a string"
      );
    if (!targetLanguage || !["de", "fr", "it", "en"].includes(targetLanguage))
      throw new McpError(
        ErrorCode.InvalidParams,
        "targetLanguage must be one of: de, fr, it, en"
      );
    let parsed = this.parser.parse(citation);
    if (!parsed.isValid)
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid citation: ${citation}`
      );
    let allTranslations = this.formatter.getAllTranslations(
      parsed.type,
      parsed.components
    ), options = {
      language: targetLanguage,
      fullStatuteName
    }, formatted = this.formatter.format(
      parsed.type,
      parsed.components,
      targetLanguage,
      options
    );
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              original: citation,
              sourceLanguage: parsed.language,
              targetLanguage,
              converted: formatted.citation,
              fullReference: formatted.fullReference,
              allTranslations
            },
            null,
            2
          )
        }
      ]
    };
  }
  async handleParseCitation(args) {
    let { citation } = args;
    if (!citation || typeof citation != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "Citation parameter is required and must be a string"
      );
    let parsed = this.parser.parse(citation);
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              original: parsed.original,
              type: parsed.type,
              language: parsed.language,
              components: parsed.components,
              isValid: parsed.isValid,
              suggestions: parsed.suggestions
            },
            null,
            2
          )
        }
      ]
    };
  }
  /**
   * Get provision text from Fedlex
   */
  async handleGetProvisionText(args) {
    let { statute, article, paragraph, letter, language = "de", asOfDate } = args;
    if (!statute || typeof statute != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "statute parameter is required and must be a string"
      );
    if (typeof article != "number")
      throw new McpError(
        ErrorCode.InvalidParams,
        "article parameter is required and must be a number"
      );
    let normalizedStatute = statute.toUpperCase(), srNumber = STATUTE_SR_MAPPING[normalizedStatute] || STATUTE_SR_MAPPING[statute];
    if (!srNumber)
      throw new McpError(
        ErrorCode.InvalidParams,
        `Unknown statute abbreviation: ${statute}. Supported: ${Object.keys(STATUTE_SR_MAPPING).join(", ")}`
      );
    let langCode = language === "de" ? "de" : language === "fr" ? "fr" : "it", fedlexUrl = `${FEDLEX_BASE_URL}/cc/${srNumber}/${langCode}`, formattedCitation = this.buildProvisionReference(
      normalizedStatute,
      article,
      paragraph,
      letter,
      language
    ), provisionText = await this.fetchProvisionText(
      srNumber,
      article,
      paragraph,
      letter,
      langCode,
      asOfDate
    ), fullStatuteName = STATUTE_FULL_NAMES[normalizedStatute]?.[language] || STATUTE_FULL_NAMES[Object.keys(STATUTE_SR_MAPPING).find((k) => STATUTE_SR_MAPPING[k] === srNumber) || ""]?.[language] || normalizedStatute;
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              provision: {
                statute: normalizedStatute,
                srNumber,
                article,
                paragraph,
                letter,
                formattedCitation,
                fullStatuteName
              },
              text: provisionText.text,
              effectiveDate: provisionText.effectiveDate,
              language,
              fedlexUrl,
              metadata: {
                lastModified: provisionText.lastModified,
                version: provisionText.version
              }
            },
            null,
            2
          )
        }
      ]
    };
  }
  /**
   * Build a formatted provision reference
   */
  buildProvisionReference(statute, article, paragraph, letter, language = "de") {
    let l = {
      de: { art: "Art.", abs: "Abs.", lit: "lit." },
      fr: { art: "art.", abs: "al.", lit: "let." },
      it: { art: "art.", abs: "cpv.", lit: "lett." },
      en: { art: "Art.", abs: "para.", lit: "lit." }
    }[language], ref = `${l.art} ${article}`;
    return paragraph && (ref += ` ${l.abs} ${paragraph}`), letter && (ref += ` ${l.lit} ${letter}`), ref += ` ${statute}`, ref;
  }
  /**
   * Fetch provision text (simulated - in production would call Fedlex API)
   */
  async fetchProvisionText(srNumber, article, paragraph, letter, language = "de", asOfDate) {
    let effectiveDate = asOfDate || (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    return {
      text: `[Provision text would be fetched from Fedlex API: SR ${srNumber}, Art. ${article}${paragraph ? ` Abs. ${paragraph}` : ""}${letter ? ` lit. ${letter}` : ""}]`,
      effectiveDate,
      lastModified: (/* @__PURE__ */ new Date()).toISOString(),
      version: "current"
    };
  }
  /**
   * Extract all legal citations from document text
   */
  async handleExtractCitations(args) {
    let { text, includeTypes = ["all"], validateCitations = !0 } = args;
    if (!text || typeof text != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "text parameter is required and must be a string"
      );
    let extractedCitations = [], patterns = [
      // BGE/ATF/DTF patterns
      { regex: /BGE\s+\d{1,3}\s+[IV]+\s+\d+/gi, type: "bge" },
      { regex: /ATF\s+\d{1,3}\s+[IV]+\s+\d+/gi, type: "atf" },
      { regex: /DTF\s+\d{1,3}\s+[IV]+\s+\d+/gi, type: "dtf" },
      // Statute patterns (German)
      { regex: /Art\.\s*\d+[a-z]?\s*(Abs\.\s*\d+)?\s*(lit\.\s*[a-z])?\s*(Ziff\.\s*\d+)?\s*(ZGB|OR|StGB|BV|BGG|ZPO|StPO|SchKG|VwVG|AVIG|AHVG|IVG|BVG|UVG|KVG|DSG|IPRG|MWStG|DBG)/gi, type: "statute" },
      // Statute patterns (French)
      { regex: /art\.\s*\d+[a-z]?\s*(al\.\s*\d+)?\s*(let\.\s*[a-z])?\s*(ch\.\s*\d+)?\s*(CC|CO|CP|Cst|LTF|CPC|CPP|LP|PA|LACI|LAVS|LAI|LPP|LAA|LAMal|LPD|LDIP|LTVA|LIFD)/gi, type: "statute" },
      // Statute patterns (Italian)
      { regex: /art\.\s*\d+[a-z]?\s*(cpv\.\s*\d+)?\s*(lett\.\s*[a-z])?\s*(n\.\s*\d+)?\s*(CCS|CO|CPS|Cost)/gi, type: "statute" },
      // Cantonal court patterns
      { regex: /[A-Z]{2,4}[-_]\d{4}[-_]\d+/g, type: "cantonal" }
    ], shouldIncludeAll = includeTypes.includes("all"), filteredPatterns = patterns.filter(
      (p) => shouldIncludeAll || includeTypes.includes(p.type)
    );
    for (let { regex, type } of filteredPatterns) {
      let match, regexCopy = new RegExp(regex.source, regex.flags);
      for (; (match = regexCopy.exec(text)) !== null; ) {
        let citation = match[0].trim(), position = { start: match.index, end: match.index + citation.length };
        if (!extractedCitations.some(
          (ec) => ec.citation === citation && ec.position.start === position.start
        )) {
          let entry = {
            citation,
            type,
            position
          };
          if (validateCitations) {
            let parsed = this.parser.parse(citation);
            entry.parsed = parsed, entry.valid = parsed.isValid;
          }
          extractedCitations.push(entry);
        }
      }
    }
    extractedCitations.sort((a, b) => a.position.start - b.position.start);
    let statistics = {
      total: extractedCitations.length,
      byType: {},
      validCount: extractedCitations.filter((c) => c.valid !== !1).length,
      invalidCount: extractedCitations.filter((c) => c.valid === !1).length
    };
    for (let citation of extractedCitations)
      statistics.byType[citation.type] = (statistics.byType[citation.type] || 0) + 1;
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              citations: extractedCitations,
              statistics,
              textLength: text.length
            },
            null,
            2
          )
        }
      ]
    };
  }
  /**
   * Standardize all citations in a document to consistent format
   */
  async handleStandardizeDocumentCitations(args) {
    let { text, targetLanguage, format = "short", includeFullNames = !1 } = args;
    if (!text || typeof text != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "text parameter is required and must be a string"
      );
    if (!targetLanguage || !["de", "fr", "it", "en"].includes(targetLanguage))
      throw new McpError(
        ErrorCode.InvalidParams,
        "targetLanguage must be one of: de, fr, it, en"
      );
    let extractResult = await this.handleExtractCitations({
      text,
      includeTypes: ["all"],
      validateCitations: !0
    }), citations = JSON.parse(extractResult.content[0].text).citations, replacements = [];
    for (let citationEntry of citations) {
      if (!citationEntry.valid || !citationEntry.parsed)
        continue;
      let parsed = citationEntry.parsed, options = {
        language: targetLanguage,
        fullStatuteName: includeFullNames
      }, formatted = this.formatter.format(
        parsed.type,
        parsed.components,
        targetLanguage,
        options
      ), standardized = formatted.citation;
      format === "long" && formatted.fullReference ? standardized = formatted.fullReference : format === "academic" && formatted.fullReference && formatted.citation !== formatted.fullReference && (standardized = `${formatted.citation} (${formatted.fullReference})`), standardized !== citationEntry.citation && replacements.push({
        original: citationEntry.citation,
        standardized,
        position: citationEntry.position
      });
    }
    let standardizedText = text, sortedReplacements = [...replacements].sort(
      (a, b) => b.position.start - a.position.start
    );
    for (let replacement of sortedReplacements)
      standardizedText = standardizedText.substring(0, replacement.position.start) + replacement.standardized + standardizedText.substring(replacement.position.end);
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              originalText: text,
              standardizedText,
              targetLanguage,
              format,
              replacements,
              statistics: {
                totalCitations: citations.length,
                standardized: replacements.length,
                unchanged: citations.length - replacements.length
              }
            },
            null,
            2
          )
        }
      ]
    };
  }
  /**
   * Compare provision versions over time
   */
  async handleCompareCitationVersions(args) {
    let { statute, article, paragraph, dateFrom, dateTo, language = "de" } = args;
    if (!statute || typeof statute != "string")
      throw new McpError(
        ErrorCode.InvalidParams,
        "statute parameter is required and must be a string"
      );
    if (typeof article != "number")
      throw new McpError(
        ErrorCode.InvalidParams,
        "article parameter is required and must be a number"
      );
    let normalizedStatute = statute.toUpperCase(), srNumber = STATUTE_SR_MAPPING[normalizedStatute] || STATUTE_SR_MAPPING[statute];
    if (!srNumber)
      throw new McpError(
        ErrorCode.InvalidParams,
        `Unknown statute abbreviation: ${statute}`
      );
    let fromDate = dateFrom ? new Date(dateFrom) : /* @__PURE__ */ new Date("2000-01-01"), toDate = dateTo ? new Date(dateTo) : /* @__PURE__ */ new Date(), versions = await this.fetchProvisionVersions(
      srNumber,
      article,
      paragraph,
      fromDate,
      toDate,
      language
    ), formattedCitation = this.buildProvisionReference(
      normalizedStatute,
      article,
      paragraph,
      void 0,
      language
    );
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify(
            {
              success: !0,
              provision: {
                statute: normalizedStatute,
                srNumber,
                article,
                paragraph,
                formattedCitation
              },
              dateRange: {
                from: fromDate.toISOString().split("T")[0],
                to: toDate.toISOString().split("T")[0]
              },
              versions,
              totalVersions: versions.length,
              hasChanges: versions.length > 1
            },
            null,
            2
          )
        }
      ]
    };
  }
  /**
   * Fetch provision versions (simulated - would call Fedlex API in production)
   */
  async fetchProvisionVersions(srNumber, article, paragraph, fromDate, toDate, language) {
    return [
      {
        effectiveDate: fromDate.toISOString().split("T")[0],
        text: `[Historical version of SR ${srNumber} Art. ${article}${paragraph ? ` Abs. ${paragraph}` : ""} - would be fetched from Fedlex]`,
        changeType: "initial",
        changeDescription: "Original enactment"
      },
      {
        effectiveDate: toDate.toISOString().split("T")[0],
        text: `[Current version of SR ${srNumber} Art. ${article}${paragraph ? ` Abs. ${paragraph}` : ""} - would be fetched from Fedlex]`,
        changeType: "current",
        changeDescription: "Current version in force"
      }
    ];
  }
  async run() {
    let transport = new StdioServerTransport();
    await this.server.connect(transport), console.error("Legal Citations MCP server running on stdio"), console.error("Version: 1.1.0"), console.error("Capabilities: validate_citation, format_citation, convert_citation, parse_citation, get_provision_text, extract_citations, standardize_document_citations, compare_citation_versions");
  }
}, server = new LegalCitationsMCPServer();
server.run().catch((error2) => {
  console.error("Fatal error running server:", error2), process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2NvZGVnZW4vc2NvcGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91dGlsLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL25hbWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9ycy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3J1bGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3JlZl9lcnJvci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91cmkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvcmUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2lkLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvY29yZS9yZWYudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91Y3MybGVuZ3RoLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcGF0dGVybi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRJdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS9lcXVhbC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2NvbnN0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zMjAyMC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydHlOYW1lcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3BhdHRlcm5Qcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9vbmVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci90aGVuRWxzZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZm9ybWF0L2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvbWV0YWRhdGEudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kcmFmdDcudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvbiIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvc3JjL2Zvcm1hdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvbGltaXQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy91dGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL1pvZEVycm9yLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvZXJyb3JzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY29yZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3V0aWwuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2V4ZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9kb2MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS92ZXJzaW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvbG9jYWxlcy9lbi5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2lzdHJpZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9hcGkuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS90by1qc29uLXNjaGVtYS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2pzb24tc2NoZW1hLXByb2Nlc3NvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvem9kLWNvbXBhdC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9pc28uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2NvbXBhdC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2Zyb20tanNvbi1zY2hlbWEuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9leHRlcm5hbC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2ludGVyZmFjZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vT3B0aW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3NlcnZlci96b2QtanNvbi1zY2hlbWEtY29tcGF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL3Byb3RvY29sLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvdmFsaWRhdGlvbi9hanYtcHJvdmlkZXIudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9leHBlcmltZW50YWwvdGFza3Mvc2VydmVyLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2hlbHBlcnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zaGFyZWQvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2xlZ2FsLWNpdGF0aW9ucy9zcmMvdmFsaWRhdG9ycy9jaXRhdGlvbi12YWxpZGF0b3IudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2xlZ2FsLWNpdGF0aW9ucy9zcmMvZm9ybWF0dGVycy9jaXRhdGlvbi1mb3JtYXR0ZXIudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2xlZ2FsLWNpdGF0aW9ucy9zcmMvcGFyc2Vycy9jaXRhdGlvbi1wYXJzZXIudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2xlZ2FsLWNpdGF0aW9ucy9zcmMvaW5kZXgudHMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXh0cmFuZW91cy1jbGFzc1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIF9Db2RlT3JOYW1lIHtcbiAgYWJzdHJhY3QgcmVhZG9ubHkgc3RyOiBzdHJpbmdcbiAgYWJzdHJhY3QgcmVhZG9ubHkgbmFtZXM6IFVzZWROYW1lc1xuICBhYnN0cmFjdCB0b1N0cmluZygpOiBzdHJpbmdcbiAgYWJzdHJhY3QgZW1wdHlTdHIoKTogYm9vbGVhblxufVxuXG5leHBvcnQgY29uc3QgSURFTlRJRklFUiA9IC9eW2EteiRfXVthLXokXzAtOV0qJC9pXG5cbmV4cG9ydCBjbGFzcyBOYW1lIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICByZWFkb25seSBzdHI6IHN0cmluZ1xuICBjb25zdHJ1Y3RvcihzOiBzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgaWYgKCFJREVOVElGSUVSLnRlc3QocykpIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5hbWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcIilcbiAgICB0aGlzLnN0ciA9IHNcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RyXG4gIH1cblxuICBlbXB0eVN0cigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB7W3RoaXMuc3RyXTogMX1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgX0NvZGUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gIHJlYWRvbmx5IF9pdGVtczogcmVhZG9ubHkgQ29kZUl0ZW1bXVxuICBwcml2YXRlIF9zdHI/OiBzdHJpbmdcbiAgcHJpdmF0ZSBfbmFtZXM/OiBVc2VkTmFtZXNcblxuICBjb25zdHJ1Y3Rvcihjb2RlOiBzdHJpbmcgfCByZWFkb25seSBDb2RlSXRlbVtdKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuX2l0ZW1zID0gdHlwZW9mIGNvZGUgPT09IFwic3RyaW5nXCIgPyBbY29kZV0gOiBjb2RlXG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0clxuICB9XG5cbiAgZW1wdHlTdHIoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA+IDEpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtc1swXVxuICAgIHJldHVybiBpdGVtID09PSBcIlwiIHx8IGl0ZW0gPT09ICdcIlwiJ1xuICB9XG5cbiAgZ2V0IHN0cigpOiBzdHJpbmcge1xuICAgIHJldHVybiAodGhpcy5fc3RyID8/PSB0aGlzLl9pdGVtcy5yZWR1Y2UoKHM6IHN0cmluZywgYzogQ29kZUl0ZW0pID0+IGAke3N9JHtjfWAsIFwiXCIpKVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuICh0aGlzLl9uYW1lcyA/Pz0gdGhpcy5faXRlbXMucmVkdWNlKChuYW1lczogVXNlZE5hbWVzLCBjKSA9PiB7XG4gICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpIG5hbWVzW2Muc3RyXSA9IChuYW1lc1tjLnN0cl0gfHwgMCkgKyAxXG4gICAgICByZXR1cm4gbmFtZXNcbiAgICB9LCB7fSkpXG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgQ29kZUl0ZW0gPSBOYW1lIHwgc3RyaW5nIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxcblxuZXhwb3J0IHR5cGUgVXNlZE5hbWVzID0gUmVjb3JkPHN0cmluZywgbnVtYmVyIHwgdW5kZWZpbmVkPlxuXG5leHBvcnQgdHlwZSBDb2RlID0gX0NvZGUgfCBOYW1lXG5cbmV4cG9ydCB0eXBlIFNhZmVFeHByID0gQ29kZSB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsXG5cbmV4cG9ydCBjb25zdCBuaWwgPSBuZXcgX0NvZGUoXCJcIilcblxudHlwZSBDb2RlQXJnID0gU2FmZUV4cHIgfCBzdHJpbmcgfCB1bmRlZmluZWRcblxuZXhwb3J0IGZ1bmN0aW9uIF8oc3RyczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLmFyZ3M6IENvZGVBcmdbXSk6IF9Db2RlIHtcbiAgY29uc3QgY29kZTogQ29kZUl0ZW1bXSA9IFtzdHJzWzBdXVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgIGFkZENvZGVBcmcoY29kZSwgYXJnc1tpXSlcbiAgICBjb2RlLnB1c2goc3Ryc1srK2ldKVxuICB9XG4gIHJldHVybiBuZXcgX0NvZGUoY29kZSlcbn1cblxuY29uc3QgcGx1cyA9IG5ldyBfQ29kZShcIitcIilcblxuZXhwb3J0IGZ1bmN0aW9uIHN0cihzdHJzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogKENvZGVBcmcgfCBzdHJpbmdbXSlbXSk6IF9Db2RlIHtcbiAgY29uc3QgZXhwcjogQ29kZUl0ZW1bXSA9IFtzYWZlU3RyaW5naWZ5KHN0cnNbMF0pXVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgIGV4cHIucHVzaChwbHVzKVxuICAgIGFkZENvZGVBcmcoZXhwciwgYXJnc1tpXSlcbiAgICBleHByLnB1c2gocGx1cywgc2FmZVN0cmluZ2lmeShzdHJzWysraV0pKVxuICB9XG4gIG9wdGltaXplKGV4cHIpXG4gIHJldHVybiBuZXcgX0NvZGUoZXhwcilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZENvZGVBcmcoY29kZTogQ29kZUl0ZW1bXSwgYXJnOiBDb2RlQXJnIHwgc3RyaW5nW10pOiB2b2lkIHtcbiAgaWYgKGFyZyBpbnN0YW5jZW9mIF9Db2RlKSBjb2RlLnB1c2goLi4uYXJnLl9pdGVtcylcbiAgZWxzZSBpZiAoYXJnIGluc3RhbmNlb2YgTmFtZSkgY29kZS5wdXNoKGFyZylcbiAgZWxzZSBjb2RlLnB1c2goaW50ZXJwb2xhdGUoYXJnKSlcbn1cblxuZnVuY3Rpb24gb3B0aW1pemUoZXhwcjogQ29kZUl0ZW1bXSk6IHZvaWQge1xuICBsZXQgaSA9IDFcbiAgd2hpbGUgKGkgPCBleHByLmxlbmd0aCAtIDEpIHtcbiAgICBpZiAoZXhwcltpXSA9PT0gcGx1cykge1xuICAgICAgY29uc3QgcmVzID0gbWVyZ2VFeHBySXRlbXMoZXhwcltpIC0gMV0sIGV4cHJbaSArIDFdKVxuICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGV4cHIuc3BsaWNlKGkgLSAxLCAzLCByZXMpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBleHByW2krK10gPSBcIitcIlxuICAgIH1cbiAgICBpKytcbiAgfVxufVxuXG5mdW5jdGlvbiBtZXJnZUV4cHJJdGVtcyhhOiBDb2RlSXRlbSwgYjogQ29kZUl0ZW0pOiBDb2RlSXRlbSB8IHVuZGVmaW5lZCB7XG4gIGlmIChiID09PSAnXCJcIicpIHJldHVybiBhXG4gIGlmIChhID09PSAnXCJcIicpIHJldHVybiBiXG4gIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBOYW1lIHx8IGFbYS5sZW5ndGggLSAxXSAhPT0gJ1wiJykgcmV0dXJuXG4gICAgaWYgKHR5cGVvZiBiICE9IFwic3RyaW5nXCIpIHJldHVybiBgJHthLnNsaWNlKDAsIC0xKX0ke2J9XCJgXG4gICAgaWYgKGJbMF0gPT09ICdcIicpIHJldHVybiBhLnNsaWNlKDAsIC0xKSArIGIuc2xpY2UoMSlcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodHlwZW9mIGIgPT0gXCJzdHJpbmdcIiAmJiBiWzBdID09PSAnXCInICYmICEoYSBpbnN0YW5jZW9mIE5hbWUpKSByZXR1cm4gYFwiJHthfSR7Yi5zbGljZSgxKX1gXG4gIHJldHVyblxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyQ29uY2F0KGMxOiBDb2RlLCBjMjogQ29kZSk6IENvZGUge1xuICByZXR1cm4gYzIuZW1wdHlTdHIoKSA/IGMxIDogYzEuZW1wdHlTdHIoKSA/IGMyIDogc3RyYCR7YzF9JHtjMn1gXG59XG5cbi8vIFRPRE8gZG8gbm90IGFsbG93IGFycmF5cyBoZXJlXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZSh4Pzogc3RyaW5nIHwgc3RyaW5nW10gfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbCk6IFNhZmVFeHByIHwgc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgeCA9PT0gbnVsbFxuICAgID8geFxuICAgIDogc2FmZVN0cmluZ2lmeShBcnJheS5pc0FycmF5KHgpID8geC5qb2luKFwiLFwiKSA6IHgpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnkoeDogdW5rbm93bik6IENvZGUge1xuICByZXR1cm4gbmV3IF9Db2RlKHNhZmVTdHJpbmdpZnkoeCkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYWZlU3RyaW5naWZ5KHg6IHVua25vd24pOiBzdHJpbmcge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoeClcbiAgICAucmVwbGFjZSgvXFx1MjAyOC9nLCBcIlxcXFx1MjAyOFwiKVxuICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9wZXJ0eShrZXk6IENvZGUgfCBzdHJpbmcgfCBudW1iZXIpOiBDb2RlIHtcbiAgcmV0dXJuIHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBJREVOVElGSUVSLnRlc3Qoa2V5KSA/IG5ldyBfQ29kZShgLiR7a2V5fWApIDogX2BbJHtrZXl9XWBcbn1cblxuLy9Eb2VzIGJlc3QgZWZmb3J0IHRvIGZvcm1hdCB0aGUgbmFtZSBwcm9wZXJseVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVzbUV4cG9ydE5hbWUoa2V5OiBDb2RlIHwgc3RyaW5nIHwgbnVtYmVyKTogQ29kZSB7XG4gIGlmICh0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgSURFTlRJRklFUi50ZXN0KGtleSkpIHtcbiAgICByZXR1cm4gbmV3IF9Db2RlKGAke2tleX1gKVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogaW52YWxpZCBleHBvcnQgbmFtZTogJHtrZXl9LCB1c2UgZXhwbGljaXQgJGlkIG5hbWUgbWFwcGluZ2ApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWdleHBDb2RlKHJ4OiBSZWdFeHApOiBDb2RlIHtcbiAgcmV0dXJuIG5ldyBfQ29kZShyeC50b1N0cmluZygpKVxufVxuIiwgImltcG9ydCB7XywgbmlsLCBDb2RlLCBOYW1lfSBmcm9tIFwiLi9jb2RlXCJcblxuaW50ZXJmYWNlIE5hbWVHcm91cCB7XG4gIHByZWZpeDogc3RyaW5nXG4gIGluZGV4OiBudW1iZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBOYW1lVmFsdWUge1xuICByZWY6IFZhbHVlUmVmZXJlbmNlIC8vIHRoaXMgaXMgdGhlIHJlZmVyZW5jZSB0byBhbnkgdmFsdWUgdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gZnJvbSBnZW5lcmF0ZWQgY29kZSB2aWEgYGdsb2JhbHNgIHZhciBpbiB0aGUgY2xvc3VyZVxuICBrZXk/OiB1bmtub3duIC8vIGFueSBrZXkgdG8gaWRlbnRpZnkgYSBnbG9iYWwgdG8gYXZvaWQgZHVwbGljYXRlcywgaWYgbm90IHBhc3NlZCByZWYgaXMgdXNlZFxuICBjb2RlPzogQ29kZSAvLyB0aGlzIGlzIHRoZSBjb2RlIGNyZWF0aW5nIHRoZSB2YWx1ZSBuZWVkZWQgZm9yIHN0YW5kYWxvbmUgY29kZSB3aXRfb3V0IGNsb3N1cmUgLSBjYW4gYmUgYSBwcmltaXRpdmUgdmFsdWUsIGZ1bmN0aW9uIG9yIGltcG9ydCAoYHJlcXVpcmVgKVxufVxuXG5leHBvcnQgdHlwZSBWYWx1ZVJlZmVyZW5jZSA9IHVua25vd24gLy8gcG9zc2libHkgbWFrZSBDb2RlR2VuIHBhcmFtZXRlcml6ZWQgdHlwZSBvbiB0aGlzIHR5cGVcblxuY2xhc3MgVmFsdWVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVhZG9ubHkgdmFsdWU/OiBOYW1lVmFsdWVcbiAgY29uc3RydWN0b3IobmFtZTogVmFsdWVTY29wZU5hbWUpIHtcbiAgICBzdXBlcihgQ29kZUdlbjogXCJjb2RlXCIgZm9yICR7bmFtZX0gbm90IGRlZmluZWRgKVxuICAgIHRoaXMudmFsdWUgPSBuYW1lLnZhbHVlXG4gIH1cbn1cblxuaW50ZXJmYWNlIFNjb3BlT3B0aW9ucyB7XG4gIHByZWZpeGVzPzogU2V0PHN0cmluZz5cbiAgcGFyZW50PzogU2NvcGVcbn1cblxuaW50ZXJmYWNlIFZhbHVlU2NvcGVPcHRpb25zIGV4dGVuZHMgU2NvcGVPcHRpb25zIHtcbiAgc2NvcGU6IFNjb3BlU3RvcmVcbiAgZXM1PzogYm9vbGVhblxuICBsaW5lcz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU2NvcGVTdG9yZSA9IFJlY29yZDxzdHJpbmcsIFZhbHVlUmVmZXJlbmNlW10gfCB1bmRlZmluZWQ+XG5cbnR5cGUgU2NvcGVWYWx1ZXMgPSB7XG4gIFtQcmVmaXggaW4gc3RyaW5nXT86IE1hcDx1bmtub3duLCBWYWx1ZVNjb3BlTmFtZT5cbn1cblxuZXhwb3J0IHR5cGUgU2NvcGVWYWx1ZVNldHMgPSB7XG4gIFtQcmVmaXggaW4gc3RyaW5nXT86IFNldDxWYWx1ZVNjb3BlTmFtZT5cbn1cblxuZXhwb3J0IGVudW0gVXNlZFZhbHVlU3RhdGUge1xuICBTdGFydGVkLFxuICBDb21wbGV0ZWQsXG59XG5cbmV4cG9ydCB0eXBlIFVzZWRTY29wZVZhbHVlcyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogTWFwPFZhbHVlU2NvcGVOYW1lLCBVc2VkVmFsdWVTdGF0ZSB8IHVuZGVmaW5lZD5cbn1cblxuZXhwb3J0IGNvbnN0IHZhcktpbmRzID0ge1xuICBjb25zdDogbmV3IE5hbWUoXCJjb25zdFwiKSxcbiAgbGV0OiBuZXcgTmFtZShcImxldFwiKSxcbiAgdmFyOiBuZXcgTmFtZShcInZhclwiKSxcbn1cblxuZXhwb3J0IGNsYXNzIFNjb3BlIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9uYW1lczoge1tQcmVmaXggaW4gc3RyaW5nXT86IE5hbWVHcm91cH0gPSB7fVxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3ByZWZpeGVzPzogU2V0PHN0cmluZz5cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9wYXJlbnQ/OiBTY29wZVxuXG4gIGNvbnN0cnVjdG9yKHtwcmVmaXhlcywgcGFyZW50fTogU2NvcGVPcHRpb25zID0ge30pIHtcbiAgICB0aGlzLl9wcmVmaXhlcyA9IHByZWZpeGVzXG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50XG4gIH1cblxuICB0b05hbWUobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nKTogTmFtZSB7XG4gICAgcmV0dXJuIG5hbWVPclByZWZpeCBpbnN0YW5jZW9mIE5hbWUgPyBuYW1lT3JQcmVmaXggOiB0aGlzLm5hbWUobmFtZU9yUHJlZml4KVxuICB9XG5cbiAgbmFtZShwcmVmaXg6IHN0cmluZyk6IE5hbWUge1xuICAgIHJldHVybiBuZXcgTmFtZSh0aGlzLl9uZXdOYW1lKHByZWZpeCkpXG4gIH1cblxuICBwcm90ZWN0ZWQgX25ld05hbWUocHJlZml4OiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IG5nID0gdGhpcy5fbmFtZXNbcHJlZml4XSB8fCB0aGlzLl9uYW1lR3JvdXAocHJlZml4KVxuICAgIHJldHVybiBgJHtwcmVmaXh9JHtuZy5pbmRleCsrfWBcbiAgfVxuXG4gIHByaXZhdGUgX25hbWVHcm91cChwcmVmaXg6IHN0cmluZyk6IE5hbWVHcm91cCB7XG4gICAgaWYgKHRoaXMuX3BhcmVudD8uX3ByZWZpeGVzPy5oYXMocHJlZml4KSB8fCAodGhpcy5fcHJlZml4ZXMgJiYgIXRoaXMuX3ByZWZpeGVzLmhhcyhwcmVmaXgpKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBwcmVmaXggXCIke3ByZWZpeH1cIiBpcyBub3QgYWxsb3dlZCBpbiB0aGlzIHNjb3BlYClcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLl9uYW1lc1twcmVmaXhdID0ge3ByZWZpeCwgaW5kZXg6IDB9KVxuICB9XG59XG5cbmludGVyZmFjZSBTY29wZVBhdGgge1xuICBwcm9wZXJ0eTogc3RyaW5nXG4gIGl0ZW1JbmRleDogbnVtYmVyXG59XG5cbmV4cG9ydCBjbGFzcyBWYWx1ZVNjb3BlTmFtZSBleHRlbmRzIE5hbWUge1xuICByZWFkb25seSBwcmVmaXg6IHN0cmluZ1xuICB2YWx1ZT86IE5hbWVWYWx1ZVxuICBzY29wZVBhdGg/OiBDb2RlXG5cbiAgY29uc3RydWN0b3IocHJlZml4OiBzdHJpbmcsIG5hbWVTdHI6IHN0cmluZykge1xuICAgIHN1cGVyKG5hbWVTdHIpXG4gICAgdGhpcy5wcmVmaXggPSBwcmVmaXhcbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlOiBOYW1lVmFsdWUsIHtwcm9wZXJ0eSwgaXRlbUluZGV4fTogU2NvcGVQYXRoKTogdm9pZCB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlXG4gICAgdGhpcy5zY29wZVBhdGggPSBfYC4ke25ldyBOYW1lKHByb3BlcnR5KX1bJHtpdGVtSW5kZXh9XWBcbiAgfVxufVxuXG5pbnRlcmZhY2UgVlNPcHRpb25zIGV4dGVuZHMgVmFsdWVTY29wZU9wdGlvbnMge1xuICBfbjogQ29kZVxufVxuXG5jb25zdCBsaW5lID0gX2BcXG5gXG5cbmV4cG9ydCBjbGFzcyBWYWx1ZVNjb3BlIGV4dGVuZHMgU2NvcGUge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3ZhbHVlczogU2NvcGVWYWx1ZXMgPSB7fVxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3Njb3BlOiBTY29wZVN0b3JlXG4gIHJlYWRvbmx5IG9wdHM6IFZTT3B0aW9uc1xuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IFZhbHVlU2NvcGVPcHRpb25zKSB7XG4gICAgc3VwZXIob3B0cylcbiAgICB0aGlzLl9zY29wZSA9IG9wdHMuc2NvcGVcbiAgICB0aGlzLm9wdHMgPSB7Li4ub3B0cywgX246IG9wdHMubGluZXMgPyBsaW5lIDogbmlsfVxuICB9XG5cbiAgZ2V0KCk6IFNjb3BlU3RvcmUge1xuICAgIHJldHVybiB0aGlzLl9zY29wZVxuICB9XG5cbiAgbmFtZShwcmVmaXg6IHN0cmluZyk6IFZhbHVlU2NvcGVOYW1lIHtcbiAgICByZXR1cm4gbmV3IFZhbHVlU2NvcGVOYW1lKHByZWZpeCwgdGhpcy5fbmV3TmFtZShwcmVmaXgpKVxuICB9XG5cbiAgdmFsdWUobmFtZU9yUHJlZml4OiBWYWx1ZVNjb3BlTmFtZSB8IHN0cmluZywgdmFsdWU6IE5hbWVWYWx1ZSk6IFZhbHVlU2NvcGVOYW1lIHtcbiAgICBpZiAodmFsdWUucmVmID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IHJlZiBtdXN0IGJlIHBhc3NlZCBpbiB2YWx1ZVwiKVxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLnRvTmFtZShuYW1lT3JQcmVmaXgpIGFzIFZhbHVlU2NvcGVOYW1lXG4gICAgY29uc3Qge3ByZWZpeH0gPSBuYW1lXG4gICAgY29uc3QgdmFsdWVLZXkgPSB2YWx1ZS5rZXkgPz8gdmFsdWUucmVmXG4gICAgbGV0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF1cbiAgICBpZiAodnMpIHtcbiAgICAgIGNvbnN0IF9uYW1lID0gdnMuZ2V0KHZhbHVlS2V5KVxuICAgICAgaWYgKF9uYW1lKSByZXR1cm4gX25hbWVcbiAgICB9IGVsc2Uge1xuICAgICAgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XSA9IG5ldyBNYXAoKVxuICAgIH1cbiAgICB2cy5zZXQodmFsdWVLZXksIG5hbWUpXG5cbiAgICBjb25zdCBzID0gdGhpcy5fc2NvcGVbcHJlZml4XSB8fCAodGhpcy5fc2NvcGVbcHJlZml4XSA9IFtdKVxuICAgIGNvbnN0IGl0ZW1JbmRleCA9IHMubGVuZ3RoXG4gICAgc1tpdGVtSW5kZXhdID0gdmFsdWUucmVmXG4gICAgbmFtZS5zZXRWYWx1ZSh2YWx1ZSwge3Byb3BlcnR5OiBwcmVmaXgsIGl0ZW1JbmRleH0pXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIGdldFZhbHVlKHByZWZpeDogc3RyaW5nLCBrZXlPclJlZjogdW5rbm93bik6IFZhbHVlU2NvcGVOYW1lIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdXG4gICAgaWYgKCF2cykgcmV0dXJuXG4gICAgcmV0dXJuIHZzLmdldChrZXlPclJlZilcbiAgfVxuXG4gIHNjb3BlUmVmcyhzY29wZU5hbWU6IE5hbWUsIHZhbHVlczogU2NvcGVWYWx1ZXMgfCBTY29wZVZhbHVlU2V0cyA9IHRoaXMuX3ZhbHVlcyk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXModmFsdWVzLCAobmFtZTogVmFsdWVTY29wZU5hbWUpID0+IHtcbiAgICAgIGlmIChuYW1lLnNjb3BlUGF0aCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYClcbiAgICAgIHJldHVybiBfYCR7c2NvcGVOYW1lfSR7bmFtZS5zY29wZVBhdGh9YFxuICAgIH0pXG4gIH1cblxuICBzY29wZUNvZGUoXG4gICAgdmFsdWVzOiBTY29wZVZhbHVlcyB8IFNjb3BlVmFsdWVTZXRzID0gdGhpcy5fdmFsdWVzLFxuICAgIHVzZWRWYWx1ZXM/OiBVc2VkU2NvcGVWYWx1ZXMsXG4gICAgZ2V0Q29kZT86IChuOiBWYWx1ZVNjb3BlTmFtZSkgPT4gQ29kZSB8IHVuZGVmaW5lZFxuICApOiBDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKFxuICAgICAgdmFsdWVzLFxuICAgICAgKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lLnZhbHVlID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKVxuICAgICAgICByZXR1cm4gbmFtZS52YWx1ZS5jb2RlXG4gICAgICB9LFxuICAgICAgdXNlZFZhbHVlcyxcbiAgICAgIGdldENvZGVcbiAgICApXG4gIH1cblxuICBwcml2YXRlIF9yZWR1Y2VWYWx1ZXMoXG4gICAgdmFsdWVzOiBTY29wZVZhbHVlcyB8IFNjb3BlVmFsdWVTZXRzLFxuICAgIHZhbHVlQ29kZTogKG46IFZhbHVlU2NvcGVOYW1lKSA9PiBDb2RlIHwgdW5kZWZpbmVkLFxuICAgIHVzZWRWYWx1ZXM6IFVzZWRTY29wZVZhbHVlcyA9IHt9LFxuICAgIGdldENvZGU/OiAobjogVmFsdWVTY29wZU5hbWUpID0+IENvZGUgfCB1bmRlZmluZWRcbiAgKTogQ29kZSB7XG4gICAgbGV0IGNvZGU6IENvZGUgPSBuaWxcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBpbiB2YWx1ZXMpIHtcbiAgICAgIGNvbnN0IHZzID0gdmFsdWVzW3ByZWZpeF1cbiAgICAgIGlmICghdnMpIGNvbnRpbnVlXG4gICAgICBjb25zdCBuYW1lU2V0ID0gKHVzZWRWYWx1ZXNbcHJlZml4XSA9IHVzZWRWYWx1ZXNbcHJlZml4XSB8fCBuZXcgTWFwKCkpXG4gICAgICB2cy5mb3JFYWNoKChuYW1lOiBWYWx1ZVNjb3BlTmFtZSkgPT4ge1xuICAgICAgICBpZiAobmFtZVNldC5oYXMobmFtZSkpIHJldHVyblxuICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5TdGFydGVkKVxuICAgICAgICBsZXQgYyA9IHZhbHVlQ29kZShuYW1lKVxuICAgICAgICBpZiAoYykge1xuICAgICAgICAgIGNvbnN0IGRlZiA9IHRoaXMub3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB2YXJLaW5kcy5jb25zdFxuICAgICAgICAgIGNvZGUgPSBfYCR7Y29kZX0ke2RlZn0gJHtuYW1lfSA9ICR7Y307JHt0aGlzLm9wdHMuX259YFxuICAgICAgICB9IGVsc2UgaWYgKChjID0gZ2V0Q29kZT8uKG5hbWUpKSkge1xuICAgICAgICAgIGNvZGUgPSBfYCR7Y29kZX0ke2N9JHt0aGlzLm9wdHMuX259YFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKG5hbWUpXG4gICAgICAgIH1cbiAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuQ29tcGxldGVkKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtTY29wZVZhbHVlU2V0cywgTmFtZVZhbHVlLCBWYWx1ZVNjb3BlLCBWYWx1ZVNjb3BlTmFtZX0gZnJvbSBcIi4vc2NvcGVcIlxuaW1wb3J0IHtfLCBuaWwsIF9Db2RlLCBDb2RlLCBOYW1lLCBVc2VkTmFtZXMsIENvZGVJdGVtLCBhZGRDb2RlQXJnLCBfQ29kZU9yTmFtZX0gZnJvbSBcIi4vY29kZVwiXG5pbXBvcnQge1Njb3BlLCB2YXJLaW5kc30gZnJvbSBcIi4vc2NvcGVcIlxuXG5leHBvcnQge18sIHN0ciwgc3RyQ29uY2F0LCBuaWwsIGdldFByb3BlcnR5LCBzdHJpbmdpZnksIHJlZ2V4cENvZGUsIE5hbWUsIENvZGV9IGZyb20gXCIuL2NvZGVcIlxuZXhwb3J0IHtTY29wZSwgU2NvcGVTdG9yZSwgVmFsdWVTY29wZSwgVmFsdWVTY29wZU5hbWUsIFNjb3BlVmFsdWVTZXRzLCB2YXJLaW5kc30gZnJvbSBcIi4vc2NvcGVcIlxuXG4vLyB0eXBlIGZvciBleHByZXNzaW9ucyB0aGF0IGNhbiBiZSBzYWZlbHkgaW5zZXJ0ZWQgaW4gY29kZSB3aXRob3V0IHF1b3Rlc1xuZXhwb3J0IHR5cGUgU2FmZUV4cHIgPSBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxcblxuLy8gdHlwZSB0aGF0IGlzIGVpdGhlciBDb2RlIG9mIGZ1bmN0aW9uIHRoYXQgYWRkcyBjb2RlIHRvIENvZGVHZW4gaW5zdGFuY2UgdXNpbmcgaXRzIG1ldGhvZHNcbmV4cG9ydCB0eXBlIEJsb2NrID0gQ29kZSB8ICgoKSA9PiB2b2lkKVxuXG5leHBvcnQgY29uc3Qgb3BlcmF0b3JzID0ge1xuICBHVDogbmV3IF9Db2RlKFwiPlwiKSxcbiAgR1RFOiBuZXcgX0NvZGUoXCI+PVwiKSxcbiAgTFQ6IG5ldyBfQ29kZShcIjxcIiksXG4gIExURTogbmV3IF9Db2RlKFwiPD1cIiksXG4gIEVROiBuZXcgX0NvZGUoXCI9PT1cIiksXG4gIE5FUTogbmV3IF9Db2RlKFwiIT09XCIpLFxuICBOT1Q6IG5ldyBfQ29kZShcIiFcIiksXG4gIE9SOiBuZXcgX0NvZGUoXCJ8fFwiKSxcbiAgQU5EOiBuZXcgX0NvZGUoXCImJlwiKSxcbiAgQUREOiBuZXcgX0NvZGUoXCIrXCIpLFxufVxuXG5hYnN0cmFjdCBjbGFzcyBOb2RlIHtcbiAgYWJzdHJhY3QgcmVhZG9ubHkgbmFtZXM6IFVzZWROYW1lc1xuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB8IENoaWxkTm9kZSB8IENoaWxkTm9kZVtdIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhfbmFtZXM6IFVzZWROYW1lcywgX2NvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGdldCBjb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiAxXG4gIC8vIH1cbn1cblxuY2xhc3MgRGVmIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFyS2luZDogTmFtZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5hbWU6IE5hbWUsXG4gICAgcHJpdmF0ZSByaHM/OiBTYWZlRXhwclxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe2VzNSwgX259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhcktpbmQgPSBlczUgPyB2YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmRcbiAgICBjb25zdCByaHMgPSB0aGlzLnJocyA9PT0gdW5kZWZpbmVkID8gXCJcIiA6IGAgPSAke3RoaXMucmhzfWBcbiAgICByZXR1cm4gYCR7dmFyS2luZH0gJHt0aGlzLm5hbWV9JHtyaHN9O2AgKyBfblxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghbmFtZXNbdGhpcy5uYW1lLnN0cl0pIHJldHVyblxuICAgIGlmICh0aGlzLnJocykgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLnJocyBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gdGhpcy5yaHMubmFtZXMgOiB7fVxuICB9XG59XG5cbmNsYXNzIEFzc2lnbiBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBsaHM6IENvZGUsXG4gICAgcHVibGljIHJoczogU2FmZUV4cHIsXG4gICAgcHJpdmF0ZSByZWFkb25seSBzaWRlRWZmZWN0cz86IGJvb2xlYW5cbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMubGhzfSA9ICR7dGhpcy5yaHN9O2AgKyBfblxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICh0aGlzLmxocyBpbnN0YW5jZW9mIE5hbWUgJiYgIW5hbWVzW3RoaXMubGhzLnN0cl0gJiYgIXRoaXMuc2lkZUVmZmVjdHMpIHJldHVyblxuICAgIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICBjb25zdCBuYW1lcyA9IHRoaXMubGhzIGluc3RhbmNlb2YgTmFtZSA/IHt9IDogey4uLnRoaXMubGhzLm5hbWVzfVxuICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMucmhzKVxuICB9XG59XG5cbmNsYXNzIEFzc2lnbk9wIGV4dGVuZHMgQXNzaWduIHtcbiAgY29uc3RydWN0b3IoXG4gICAgbGhzOiBDb2RlLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgb3A6IENvZGUsXG4gICAgcmhzOiBTYWZlRXhwcixcbiAgICBzaWRlRWZmZWN0cz86IGJvb2xlYW5cbiAgKSB7XG4gICAgc3VwZXIobGhzLCByaHMsIHNpZGVFZmZlY3RzKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMubGhzfSAke3RoaXMub3B9PSAke3RoaXMucmhzfTtgICsgX25cbiAgfVxufVxuXG5jbGFzcyBMYWJlbCBleHRlbmRzIE5vZGUge1xuICByZWFkb25seSBuYW1lczogVXNlZE5hbWVzID0ge31cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbGFiZWw6IE5hbWUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5sYWJlbH06YCArIF9uXG4gIH1cbn1cblxuY2xhc3MgQnJlYWsgZXh0ZW5kcyBOb2RlIHtcbiAgcmVhZG9ubHkgbmFtZXM6IFVzZWROYW1lcyA9IHt9XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGxhYmVsPzogQ29kZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IGxhYmVsID0gdGhpcy5sYWJlbCA/IGAgJHt0aGlzLmxhYmVsfWAgOiBcIlwiXG4gICAgcmV0dXJuIGBicmVhayR7bGFiZWx9O2AgKyBfblxuICB9XG59XG5cbmNsYXNzIFRocm93IGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGVycm9yOiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGB0aHJvdyAke3RoaXMuZXJyb3J9O2AgKyBfblxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMuZXJyb3IubmFtZXNcbiAgfVxufVxuXG5jbGFzcyBBbnlDb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29kZTogU2FmZUV4cHIpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb2RlfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29kZX1gID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMge1xuICAgIHRoaXMuY29kZSA9IG9wdGltaXplRXhwcih0aGlzLmNvZGUsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLmNvZGUgaW5zdGFuY2VvZiBfQ29kZU9yTmFtZSA/IHRoaXMuY29kZS5uYW1lcyA6IHt9XG4gIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgUGFyZW50Tm9kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBub2RlczogQ2hpbGROb2RlW10gPSBbXSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoY29kZSwgbikgPT4gY29kZSArIG4ucmVuZGVyKG9wdHMpLCBcIlwiKVxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtub2Rlc30gPSB0aGlzXG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICBjb25zdCBuID0gbm9kZXNbaV0ub3B0aW1pemVOb2RlcygpXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShuKSkgbm9kZXMuc3BsaWNlKGksIDEsIC4uLm4pXG4gICAgICBlbHNlIGlmIChuKSBub2Rlc1tpXSA9IG5cbiAgICAgIGVsc2Ugbm9kZXMuc3BsaWNlKGksIDEpXG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHtub2Rlc30gPSB0aGlzXG4gICAgbGV0IGkgPSBub2Rlcy5sZW5ndGhcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAvLyBpdGVyYXRpbmcgYmFja3dhcmRzIGltcHJvdmVzIDEtcGFzcyBvcHRpbWl6YXRpb25cbiAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXVxuICAgICAgaWYgKG4ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgY29udGludWVcbiAgICAgIHN1YnRyYWN0TmFtZXMobmFtZXMsIG4ubmFtZXMpXG4gICAgICBub2Rlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIG4pID0+IGFkZE5hbWVzKG5hbWVzLCBuLm5hbWVzKSwge30pXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGMsIG4pID0+IGMgKyBuLmNvdW50LCAxKVxuICAvLyB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEJsb2NrTm9kZSBleHRlbmRzIFBhcmVudE5vZGUge1xuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJ7XCIgKyBvcHRzLl9uICsgc3VwZXIucmVuZGVyKG9wdHMpICsgXCJ9XCIgKyBvcHRzLl9uXG4gIH1cbn1cblxuY2xhc3MgUm9vdCBleHRlbmRzIFBhcmVudE5vZGUge31cblxuY2xhc3MgRWxzZSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJlbHNlXCJcbn1cblxuY2xhc3MgSWYgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiaWZcIlxuICBlbHNlPzogSWYgfCBFbHNlXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbixcbiAgICBub2Rlcz86IENoaWxkTm9kZVtdXG4gICkge1xuICAgIHN1cGVyKG5vZGVzKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgbGV0IGNvZGUgPSBgaWYoJHt0aGlzLmNvbmRpdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmVsc2UpIGNvZGUgKz0gXCJlbHNlIFwiICsgdGhpcy5lbHNlLnJlbmRlcihvcHRzKVxuICAgIHJldHVybiBjb2RlXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IElmIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKVxuICAgIGNvbnN0IGNvbmQgPSB0aGlzLmNvbmRpdGlvblxuICAgIGlmIChjb25kID09PSB0cnVlKSByZXR1cm4gdGhpcy5ub2RlcyAvLyBlbHNlIGlzIGlnbm9yZWQgaGVyZVxuICAgIGxldCBlID0gdGhpcy5lbHNlXG4gICAgaWYgKGUpIHtcbiAgICAgIGNvbnN0IG5zID0gZS5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIGUgPSB0aGlzLmVsc2UgPSBBcnJheS5pc0FycmF5KG5zKSA/IG5ldyBFbHNlKG5zKSA6IChucyBhcyBFbHNlIHwgdW5kZWZpbmVkKVxuICAgIH1cbiAgICBpZiAoZSkge1xuICAgICAgaWYgKGNvbmQgPT09IGZhbHNlKSByZXR1cm4gZSBpbnN0YW5jZW9mIElmID8gZSA6IGUubm9kZXNcbiAgICAgIGlmICh0aGlzLm5vZGVzLmxlbmd0aCkgcmV0dXJuIHRoaXNcbiAgICAgIHJldHVybiBuZXcgSWYobm90KGNvbmQpLCBlIGluc3RhbmNlb2YgSWYgPyBbZV0gOiBlLm5vZGVzKVxuICAgIH1cbiAgICBpZiAoY29uZCA9PT0gZmFsc2UgfHwgIXRoaXMubm9kZXMubGVuZ3RoKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICB0aGlzLmVsc2UgPSB0aGlzLmVsc2U/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICBpZiAoIShzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpIHx8IHRoaXMuZWxzZSkpIHJldHVyblxuICAgIHRoaXMuY29uZGl0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuY29uZGl0aW9uLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzXG4gICAgYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLmNvbmRpdGlvbilcbiAgICBpZiAodGhpcy5lbHNlKSBhZGROYW1lcyhuYW1lcywgdGhpcy5lbHNlLm5hbWVzKVxuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHN1cGVyLmNvdW50ICsgKHRoaXMuZWxzZT8uY291bnQgfHwgMClcbiAgLy8gfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBGb3IgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiZm9yXCJcbn1cblxuY2xhc3MgRm9yTG9vcCBleHRlbmRzIEZvciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgaXRlcmF0aW9uOiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBmb3IoJHt0aGlzLml0ZXJhdGlvbn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgcmV0dXJuXG4gICAgdGhpcy5pdGVyYXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYXRpb24sIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYXRpb24ubmFtZXMpXG4gIH1cbn1cblxuY2xhc3MgRm9yUmFuZ2UgZXh0ZW5kcyBGb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhcktpbmQ6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZnJvbTogU2FmZUV4cHIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB0bzogU2FmZUV4cHJcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFyS2luZCA9IG9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kXG4gICAgY29uc3Qge25hbWUsIGZyb20sIHRvfSA9IHRoaXNcbiAgICByZXR1cm4gYGZvcigke3ZhcktpbmR9ICR7bmFtZX09JHtmcm9tfTsgJHtuYW1lfTwke3RvfTsgJHtuYW1lfSsrKWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gYWRkRXhwck5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLmZyb20pXG4gICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy50bylcbiAgfVxufVxuXG5jbGFzcyBGb3JJdGVyIGV4dGVuZHMgRm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb29wOiBcIm9mXCIgfCBcImluXCIsXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogTmFtZSxcbiAgICBwcml2YXRlIGl0ZXJhYmxlOiBDb2RlXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgZm9yKCR7dGhpcy52YXJLaW5kfSAke3RoaXMubmFtZX0gJHt0aGlzLmxvb3B9ICR7dGhpcy5pdGVyYWJsZX0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIGlmICghc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSkgcmV0dXJuXG4gICAgdGhpcy5pdGVyYWJsZSA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhYmxlLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmFibGUubmFtZXMpXG4gIH1cbn1cblxuY2xhc3MgRnVuYyBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmdW5jXCJcbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIG5hbWU6IE5hbWUsXG4gICAgcHVibGljIGFyZ3M6IENvZGUsXG4gICAgcHVibGljIGFzeW5jPzogYm9vbGVhblxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBfYXN5bmMgPSB0aGlzLmFzeW5jID8gXCJhc3luYyBcIiA6IFwiXCJcbiAgICByZXR1cm4gYCR7X2FzeW5jfWZ1bmN0aW9uICR7dGhpcy5uYW1lfSgke3RoaXMuYXJnc30pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG59XG5cbmNsYXNzIFJldHVybiBleHRlbmRzIFBhcmVudE5vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwicmV0dXJuXCJcblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJyZXR1cm4gXCIgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBUcnkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBjYXRjaD86IENhdGNoXG4gIGZpbmFsbHk/OiBGaW5hbGx5XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgbGV0IGNvZGUgPSBcInRyeVwiICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuY2F0Y2gpIGNvZGUgKz0gdGhpcy5jYXRjaC5yZW5kZXIob3B0cylcbiAgICBpZiAodGhpcy5maW5hbGx5KSBjb2RlICs9IHRoaXMuZmluYWxseS5yZW5kZXIob3B0cylcbiAgICByZXR1cm4gY29kZVxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHtcbiAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKClcbiAgICB0aGlzLmNhdGNoPy5vcHRpbWl6ZU5vZGVzKCkgYXMgQ2F0Y2ggfCB1bmRlZmluZWRcbiAgICB0aGlzLmZpbmFsbHk/Lm9wdGltaXplTm9kZXMoKSBhcyBGaW5hbGx5IHwgdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHtcbiAgICBzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpXG4gICAgdGhpcy5jYXRjaD8ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIHRoaXMuZmluYWxseT8ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICBjb25zdCBuYW1lcyA9IHN1cGVyLm5hbWVzXG4gICAgaWYgKHRoaXMuY2F0Y2gpIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmNhdGNoLm5hbWVzKVxuICAgIGlmICh0aGlzLmZpbmFsbHkpIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmZpbmFsbHkubmFtZXMpXG4gICAgcmV0dXJuIG5hbWVzXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gc3VwZXIuY291bnQgKyAodGhpcy5jYXRjaD8uY291bnQgfHwgMCkgKyAodGhpcy5maW5hbGx5Py5jb3VudCB8fCAwKVxuICAvLyB9XG59XG5cbmNsYXNzIENhdGNoIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImNhdGNoXCJcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgZXJyb3I6IE5hbWUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGNhdGNoKCR7dGhpcy5lcnJvcn0pYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG59XG5cbmNsYXNzIEZpbmFsbHkgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiZmluYWxseVwiXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBcImZpbmFsbHlcIiArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG59XG5cbnR5cGUgU3RhcnRCbG9ja05vZGUgPSBJZiB8IEZvciB8IEZ1bmMgfCBSZXR1cm4gfCBUcnlcblxudHlwZSBMZWFmTm9kZSA9IERlZiB8IEFzc2lnbiB8IExhYmVsIHwgQnJlYWsgfCBUaHJvdyB8IEFueUNvZGVcblxudHlwZSBDaGlsZE5vZGUgPSBTdGFydEJsb2NrTm9kZSB8IExlYWZOb2RlXG5cbnR5cGUgRW5kQmxvY2tOb2RlVHlwZSA9XG4gIHwgdHlwZW9mIElmXG4gIHwgdHlwZW9mIEVsc2VcbiAgfCB0eXBlb2YgRm9yXG4gIHwgdHlwZW9mIEZ1bmNcbiAgfCB0eXBlb2YgUmV0dXJuXG4gIHwgdHlwZW9mIENhdGNoXG4gIHwgdHlwZW9mIEZpbmFsbHlcblxudHlwZSBDb25zdGFudHMgPSBSZWNvcmQ8c3RyaW5nLCBTYWZlRXhwciB8IHVuZGVmaW5lZD5cblxuZXhwb3J0IGludGVyZmFjZSBDb2RlR2VuT3B0aW9ucyB7XG4gIGVzNT86IGJvb2xlYW5cbiAgbGluZXM/OiBib29sZWFuXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBDR09wdGlvbnMgZXh0ZW5kcyBDb2RlR2VuT3B0aW9ucyB7XG4gIF9uOiBcIlxcblwiIHwgXCJcIlxufVxuXG5leHBvcnQgY2xhc3MgQ29kZUdlbiB7XG4gIHJlYWRvbmx5IF9zY29wZTogU2NvcGVcbiAgcmVhZG9ubHkgX2V4dFNjb3BlOiBWYWx1ZVNjb3BlXG4gIHJlYWRvbmx5IF92YWx1ZXM6IFNjb3BlVmFsdWVTZXRzID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBfbm9kZXM6IFBhcmVudE5vZGVbXVxuICBwcml2YXRlIHJlYWRvbmx5IF9ibG9ja1N0YXJ0czogbnVtYmVyW10gPSBbXVxuICBwcml2YXRlIHJlYWRvbmx5IF9jb25zdGFudHM6IENvbnN0YW50cyA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgb3B0czogQ0dPcHRpb25zXG5cbiAgY29uc3RydWN0b3IoZXh0U2NvcGU6IFZhbHVlU2NvcGUsIG9wdHM6IENvZGVHZW5PcHRpb25zID0ge30pIHtcbiAgICB0aGlzLm9wdHMgPSB7Li4ub3B0cywgX246IG9wdHMubGluZXMgPyBcIlxcblwiIDogXCJcIn1cbiAgICB0aGlzLl9leHRTY29wZSA9IGV4dFNjb3BlXG4gICAgdGhpcy5fc2NvcGUgPSBuZXcgU2NvcGUoe3BhcmVudDogZXh0U2NvcGV9KVxuICAgIHRoaXMuX25vZGVzID0gW25ldyBSb290KCldXG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLl9yb290LnJlbmRlcih0aGlzLm9wdHMpXG4gIH1cblxuICAvLyByZXR1cm5zIHVuaXF1ZSBuYW1lIGluIHRoZSBpbnRlcm5hbCBzY29wZVxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njb3BlLm5hbWUocHJlZml4KVxuICB9XG5cbiAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlXG4gIHNjb3BlTmFtZShwcmVmaXg6IHN0cmluZyk6IFZhbHVlU2NvcGVOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUubmFtZShwcmVmaXgpXG4gIH1cblxuICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgYW5kIGFzc2lnbnMgdmFsdWUgdG8gaXRcbiAgc2NvcGVWYWx1ZShwcmVmaXhPck5hbWU6IFZhbHVlU2NvcGVOYW1lIHwgc3RyaW5nLCB2YWx1ZTogTmFtZVZhbHVlKTogTmFtZSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX2V4dFNjb3BlLnZhbHVlKHByZWZpeE9yTmFtZSwgdmFsdWUpXG4gICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdIHx8ICh0aGlzLl92YWx1ZXNbbmFtZS5wcmVmaXhdID0gbmV3IFNldCgpKVxuICAgIHZzLmFkZChuYW1lKVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICBnZXRTY29wZVZhbHVlKHByZWZpeDogc3RyaW5nLCBrZXlPclJlZjogdW5rbm93bik6IFZhbHVlU2NvcGVOYW1lIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuZ2V0VmFsdWUocHJlZml4LCBrZXlPclJlZilcbiAgfVxuXG4gIC8vIHJldHVybiBjb2RlIHRoYXQgYXNzaWducyB2YWx1ZXMgaW4gdGhlIGV4dGVybmFsIHNjb3BlIHRvIHRoZSBuYW1lcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHlcbiAgLy8gKHNhbWUgbmFtZXMgdGhhdCB3ZXJlIHJldHVybmVkIGJ5IGdlbi5zY29wZU5hbWUgb3IgZ2VuLnNjb3BlVmFsdWUpXG4gIHNjb3BlUmVmcyhzY29wZU5hbWU6IE5hbWUpOiBDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVSZWZzKHNjb3BlTmFtZSwgdGhpcy5fdmFsdWVzKVxuICB9XG5cbiAgc2NvcGVDb2RlKCk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZUNvZGUodGhpcy5fdmFsdWVzKVxuICB9XG5cbiAgcHJpdmF0ZSBfZGVmKFxuICAgIHZhcktpbmQ6IE5hbWUsXG4gICAgbmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLFxuICAgIHJocz86IFNhZmVFeHByLFxuICAgIGNvbnN0YW50PzogYm9vbGVhblxuICApOiBOYW1lIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeClcbiAgICBpZiAocmhzICE9PSB1bmRlZmluZWQgJiYgY29uc3RhbnQpIHRoaXMuX2NvbnN0YW50c1tuYW1lLnN0cl0gPSByaHNcbiAgICB0aGlzLl9sZWFmTm9kZShuZXcgRGVmKHZhcktpbmQsIG5hbWUsIHJocykpXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIC8vIGBjb25zdGAgZGVjbGFyYXRpb24gKGB2YXJgIGluIGVzNSBtb2RlKVxuICBjb25zdChuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsIHJoczogU2FmZUV4cHIsIF9jb25zdGFudD86IGJvb2xlYW4pOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmKHZhcktpbmRzLmNvbnN0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KVxuICB9XG5cbiAgLy8gYGxldGAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50IChgdmFyYCBpbiBlczUgbW9kZSlcbiAgbGV0KG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZywgcmhzPzogU2FmZUV4cHIsIF9jb25zdGFudD86IGJvb2xlYW4pOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmKHZhcktpbmRzLmxldCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGB2YXJgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudFxuICB2YXIobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLCByaHM/OiBTYWZlRXhwciwgX2NvbnN0YW50PzogYm9vbGVhbik6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9kZWYodmFyS2luZHMudmFyLCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KVxuICB9XG5cbiAgLy8gYXNzaWdubWVudCBjb2RlXG4gIGFzc2lnbihsaHM6IENvZGUsIHJoczogU2FmZUV4cHIsIHNpZGVFZmZlY3RzPzogYm9vbGVhbik6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduKGxocywgcmhzLCBzaWRlRWZmZWN0cykpXG4gIH1cblxuICAvLyBgKz1gIGNvZGVcbiAgYWRkKGxoczogQ29kZSwgcmhzOiBTYWZlRXhwcik6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQXNzaWduT3AobGhzLCBvcGVyYXRvcnMuQURELCByaHMpKVxuICB9XG5cbiAgLy8gYXBwZW5kcyBwYXNzZWQgU2FmZUV4cHIgdG8gY29kZSBvciBleGVjdXRlcyBCbG9ja1xuICBjb2RlKGM6IEJsb2NrIHwgU2FmZUV4cHIpOiBDb2RlR2VuIHtcbiAgICBpZiAodHlwZW9mIGMgPT0gXCJmdW5jdGlvblwiKSBjKClcbiAgICBlbHNlIGlmIChjICE9PSBuaWwpIHRoaXMuX2xlYWZOb2RlKG5ldyBBbnlDb2RlKGMpKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyByZXR1cm5zIGNvZGUgZm9yIG9iamVjdCBsaXRlcmFsIGZvciB0aGUgcGFzc2VkIGFyZ3VtZW50IGxpc3Qgb2Yga2V5LXZhbHVlIHBhaXJzXG4gIG9iamVjdCguLi5rZXlWYWx1ZXM6IFtOYW1lIHwgc3RyaW5nLCBTYWZlRXhwciB8IHN0cmluZ11bXSk6IF9Db2RlIHtcbiAgICBjb25zdCBjb2RlOiBDb2RlSXRlbVtdID0gW1wie1wiXVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGtleVZhbHVlcykge1xuICAgICAgaWYgKGNvZGUubGVuZ3RoID4gMSkgY29kZS5wdXNoKFwiLFwiKVxuICAgICAgY29kZS5wdXNoKGtleSlcbiAgICAgIGlmIChrZXkgIT09IHZhbHVlIHx8IHRoaXMub3B0cy5lczUpIHtcbiAgICAgICAgY29kZS5wdXNoKFwiOlwiKVxuICAgICAgICBhZGRDb2RlQXJnKGNvZGUsIHZhbHVlKVxuICAgICAgfVxuICAgIH1cbiAgICBjb2RlLnB1c2goXCJ9XCIpXG4gICAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKVxuICB9XG5cbiAgLy8gYGlmYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgdGhlbkJvZHlgIGFuZCwgb3B0aW9uYWxseSwgYGVsc2VCb2R5YCBhcmUgcGFzc2VkKVxuICBpZihjb25kaXRpb246IENvZGUgfCBib29sZWFuLCB0aGVuQm9keT86IEJsb2NrLCBlbHNlQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBJZihjb25kaXRpb24pKVxuXG4gICAgaWYgKHRoZW5Cb2R5ICYmIGVsc2VCb2R5KSB7XG4gICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVsc2UoKS5jb2RlKGVsc2VCb2R5KS5lbmRJZigpXG4gICAgfSBlbHNlIGlmICh0aGVuQm9keSkge1xuICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbmRJZigpXG4gICAgfSBlbHNlIGlmIChlbHNlQm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiBib2R5IHdpdGhvdXQgXCJ0aGVuXCIgYm9keScpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBgZWxzZSBpZmAgY2xhdXNlIC0gaW52YWxpZCB3aXRob3V0IGBpZmAgb3IgYWZ0ZXIgYGVsc2VgIGNsYXVzZXNcbiAgZWxzZUlmKGNvbmRpdGlvbjogQ29kZSB8IGJvb2xlYW4pOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IElmKGNvbmRpdGlvbikpXG4gIH1cblxuICAvLyBgZWxzZWAgY2xhdXNlIC0gb25seSB2YWxpZCBhZnRlciBgaWZgIG9yIGBlbHNlIGlmYCBjbGF1c2VzXG4gIGVsc2UoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBFbHNlKCkpXG4gIH1cblxuICAvLyBlbmQgYGlmYCBzdGF0ZW1lbnQgKG5lZWRlZCBpZiBnZW4uaWYgd2FzIHVzZWQgb25seSB3aXRoIGNvbmRpdGlvbilcbiAgZW5kSWYoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShJZiwgRWxzZSlcbiAgfVxuXG4gIHByaXZhdGUgX2Zvcihub2RlOiBGb3IsIGZvckJvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIGlmIChmb3JCb2R5KSB0aGlzLmNvZGUoZm9yQm9keSkuZW5kRm9yKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYSBnZW5lcmljIGBmb3JgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGBmb3JCb2R5YCBpcyBwYXNzZWQpXG4gIGZvcihpdGVyYXRpb246IENvZGUsIGZvckJvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckxvb3AoaXRlcmF0aW9uKSwgZm9yQm9keSlcbiAgfVxuXG4gIC8vIGBmb3JgIHN0YXRlbWVudCBmb3IgYSByYW5nZSBvZiB2YWx1ZXNcbiAgZm9yUmFuZ2UoXG4gICAgbmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLFxuICAgIGZyb206IFNhZmVFeHByLFxuICAgIHRvOiBTYWZlRXhwcixcbiAgICBmb3JCb2R5OiAoaW5kZXg6IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHRoaXMub3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB2YXJLaW5kcy5sZXRcbiAgKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yUmFuZ2UodmFyS2luZCwgbmFtZSwgZnJvbSwgdG8pLCAoKSA9PiBmb3JCb2R5KG5hbWUpKVxuICB9XG5cbiAgLy8gYGZvci1vZmAgc3RhdGVtZW50IChpbiBlczUgbW9kZSByZXBsYWNlIHdpdGggYSBub3JtYWwgZm9yIGxvb3ApXG4gIGZvck9mKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBpdGVyYWJsZTogQ29kZSxcbiAgICBmb3JCb2R5OiAoaXRlbTogTmFtZSkgPT4gdm9pZCxcbiAgICB2YXJLaW5kOiBDb2RlID0gdmFyS2luZHMuY29uc3RcbiAgKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgaWYgKHRoaXMub3B0cy5lczUpIHtcbiAgICAgIGNvbnN0IGFyciA9IGl0ZXJhYmxlIGluc3RhbmNlb2YgTmFtZSA/IGl0ZXJhYmxlIDogdGhpcy52YXIoXCJfYXJyXCIsIGl0ZXJhYmxlKVxuICAgICAgcmV0dXJuIHRoaXMuZm9yUmFuZ2UoXCJfaVwiLCAwLCBfYCR7YXJyfS5sZW5ndGhgLCAoaSkgPT4ge1xuICAgICAgICB0aGlzLnZhcihuYW1lLCBfYCR7YXJyfVske2l9XWApXG4gICAgICAgIGZvckJvZHkobmFtZSlcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJvZlwiLCB2YXJLaW5kLCBuYW1lLCBpdGVyYWJsZSksICgpID0+IGZvckJvZHkobmFtZSkpXG4gIH1cblxuICAvLyBgZm9yLWluYCBzdGF0ZW1lbnQuXG4gIC8vIFdpdGggb3B0aW9uIGBvd25Qcm9wZXJ0aWVzYCByZXBsYWNlZCB3aXRoIGEgYGZvci1vZmAgbG9vcCBmb3Igb2JqZWN0IGtleXNcbiAgZm9ySW4oXG4gICAgbmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLFxuICAgIG9iajogQ29kZSxcbiAgICBmb3JCb2R5OiAoaXRlbTogTmFtZSkgPT4gdm9pZCxcbiAgICB2YXJLaW5kOiBDb2RlID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmNvbnN0XG4gICk6IENvZGVHZW4ge1xuICAgIGlmICh0aGlzLm9wdHMub3duUHJvcGVydGllcykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9yT2YobmFtZU9yUHJlZml4LCBfYE9iamVjdC5rZXlzKCR7b2JqfSlgLCBmb3JCb2R5KVxuICAgIH1cbiAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeClcbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwiaW5cIiwgdmFyS2luZCwgbmFtZSwgb2JqKSwgKCkgPT4gZm9yQm9keShuYW1lKSlcbiAgfVxuXG4gIC8vIGVuZCBgZm9yYCBsb29wXG4gIGVuZEZvcigpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZvcilcbiAgfVxuXG4gIC8vIGBsYWJlbGAgc3RhdGVtZW50XG4gIGxhYmVsKGxhYmVsOiBOYW1lKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBMYWJlbChsYWJlbCkpXG4gIH1cblxuICAvLyBgYnJlYWtgIHN0YXRlbWVudFxuICBicmVhayhsYWJlbD86IENvZGUpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEJyZWFrKGxhYmVsKSlcbiAgfVxuXG4gIC8vIGByZXR1cm5gIHN0YXRlbWVudFxuICByZXR1cm4odmFsdWU6IEJsb2NrIHwgU2FmZUV4cHIpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBub2RlID0gbmV3IFJldHVybigpXG4gICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpXG4gICAgdGhpcy5jb2RlKHZhbHVlKVxuICAgIGlmIChub2RlLm5vZGVzLmxlbmd0aCAhPT0gMSkgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInJldHVyblwiIHNob3VsZCBoYXZlIG9uZSBub2RlJylcbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKFJldHVybilcbiAgfVxuXG4gIC8vIGB0cnlgIHN0YXRlbWVudFxuICB0cnkodHJ5Qm9keTogQmxvY2ssIGNhdGNoQ29kZT86IChlOiBOYW1lKSA9PiB2b2lkLCBmaW5hbGx5Q29kZT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgaWYgKCFjYXRjaENvZGUgJiYgIWZpbmFsbHlDb2RlKSB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwidHJ5XCIgd2l0aG91dCBcImNhdGNoXCIgYW5kIFwiZmluYWxseVwiJylcbiAgICBjb25zdCBub2RlID0gbmV3IFRyeSgpXG4gICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpXG4gICAgdGhpcy5jb2RlKHRyeUJvZHkpXG4gICAgaWYgKGNhdGNoQ29kZSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLm5hbWUoXCJlXCIpXG4gICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuY2F0Y2ggPSBuZXcgQ2F0Y2goZXJyb3IpXG4gICAgICBjYXRjaENvZGUoZXJyb3IpXG4gICAgfVxuICAgIGlmIChmaW5hbGx5Q29kZSkge1xuICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmZpbmFsbHkgPSBuZXcgRmluYWxseSgpXG4gICAgICB0aGlzLmNvZGUoZmluYWxseUNvZGUpXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoQ2F0Y2gsIEZpbmFsbHkpXG4gIH1cblxuICAvLyBgdGhyb3dgIHN0YXRlbWVudFxuICB0aHJvdyhlcnJvcjogQ29kZSk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgVGhyb3coZXJyb3IpKVxuICB9XG5cbiAgLy8gc3RhcnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgYmxvY2soYm9keT86IEJsb2NrLCBub2RlQ291bnQ/OiBudW1iZXIpOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja1N0YXJ0cy5wdXNoKHRoaXMuX25vZGVzLmxlbmd0aClcbiAgICBpZiAoYm9keSkgdGhpcy5jb2RlKGJvZHkpLmVuZEJsb2NrKG5vZGVDb3VudClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZW5kIHRoZSBjdXJyZW50IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gIGVuZEJsb2NrKG5vZGVDb3VudD86IG51bWJlcik6IENvZGVHZW4ge1xuICAgIGNvbnN0IGxlbiA9IHRoaXMuX2Jsb2NrU3RhcnRzLnBvcCgpXG4gICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBub3QgaW4gc2VsZi1iYWxhbmNpbmcgYmxvY2tcIilcbiAgICBjb25zdCB0b0Nsb3NlID0gdGhpcy5fbm9kZXMubGVuZ3RoIC0gbGVuXG4gICAgaWYgKHRvQ2xvc2UgPCAwIHx8IChub2RlQ291bnQgIT09IHVuZGVmaW5lZCAmJiB0b0Nsb3NlICE9PSBub2RlQ291bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHdyb25nIG51bWJlciBvZiBub2RlczogJHt0b0Nsb3NlfSB2cyAke25vZGVDb3VudH0gZXhwZWN0ZWRgKVxuICAgIH1cbiAgICB0aGlzLl9ub2Rlcy5sZW5ndGggPSBsZW5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYGZ1bmN0aW9uYCBoZWFkaW5nIChvciBkZWZpbml0aW9uIGlmIGZ1bmNCb2R5IGlzIHBhc3NlZClcbiAgZnVuYyhuYW1lOiBOYW1lLCBhcmdzOiBDb2RlID0gbmlsLCBhc3luYz86IGJvb2xlYW4sIGZ1bmNCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja05vZGUobmV3IEZ1bmMobmFtZSwgYXJncywgYXN5bmMpKVxuICAgIGlmIChmdW5jQm9keSkgdGhpcy5jb2RlKGZ1bmNCb2R5KS5lbmRGdW5jKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZW5kIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgZW5kRnVuYygpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKEZ1bmMpXG4gIH1cblxuICBvcHRpbWl6ZShuID0gMSk6IHZvaWQge1xuICAgIHdoaWxlIChuLS0gPiAwKSB7XG4gICAgICB0aGlzLl9yb290Lm9wdGltaXplTm9kZXMoKVxuICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5hbWVzKHRoaXMuX3Jvb3QubmFtZXMsIHRoaXMuX2NvbnN0YW50cylcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9sZWFmTm9kZShub2RlOiBMZWFmTm9kZSk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBfYmxvY2tOb2RlKG5vZGU6IFN0YXJ0QmxvY2tOb2RlKTogdm9pZCB7XG4gICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKVxuICAgIHRoaXMuX25vZGVzLnB1c2gobm9kZSlcbiAgfVxuXG4gIHByaXZhdGUgX2VuZEJsb2NrTm9kZShOMTogRW5kQmxvY2tOb2RlVHlwZSwgTjI/OiBFbmRCbG9ja05vZGVUeXBlKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlXG4gICAgaWYgKG4gaW5zdGFuY2VvZiBOMSB8fCAoTjIgJiYgbiBpbnN0YW5jZW9mIE4yKSkge1xuICAgICAgdGhpcy5fbm9kZXMucG9wKClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbm90IGluIGJsb2NrIFwiJHtOMiA/IGAke04xLmtpbmR9LyR7TjIua2luZH1gIDogTjEua2luZH1cImApXG4gIH1cblxuICBwcml2YXRlIF9lbHNlTm9kZShub2RlOiBJZiB8IEVsc2UpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGVcbiAgICBpZiAoIShuIGluc3RhbmNlb2YgSWYpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIHdpdGhvdXQgXCJpZlwiJylcbiAgICB9XG4gICAgdGhpcy5fY3Vyck5vZGUgPSBuLmVsc2UgPSBub2RlXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IF9yb290KCk6IFJvb3Qge1xuICAgIHJldHVybiB0aGlzLl9ub2Rlc1swXSBhcyBSb290XG4gIH1cblxuICBwcml2YXRlIGdldCBfY3Vyck5vZGUoKTogUGFyZW50Tm9kZSB7XG4gICAgY29uc3QgbnMgPSB0aGlzLl9ub2Rlc1xuICAgIHJldHVybiBuc1tucy5sZW5ndGggLSAxXVxuICB9XG5cbiAgcHJpdmF0ZSBzZXQgX2N1cnJOb2RlKG5vZGU6IFBhcmVudE5vZGUpIHtcbiAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzXG4gICAgbnNbbnMubGVuZ3RoIC0gMV0gPSBub2RlXG4gIH1cblxuICAvLyBnZXQgbm9kZUNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHRoaXMuX3Jvb3QuY291bnRcbiAgLy8gfVxufVxuXG5mdW5jdGlvbiBhZGROYW1lcyhuYW1lczogVXNlZE5hbWVzLCBmcm9tOiBVc2VkTmFtZXMpOiBVc2VkTmFtZXMge1xuICBmb3IgKGNvbnN0IG4gaW4gZnJvbSkgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgKyAoZnJvbVtuXSB8fCAwKVxuICByZXR1cm4gbmFtZXNcbn1cblxuZnVuY3Rpb24gYWRkRXhwck5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGZyb206IFNhZmVFeHByKTogVXNlZE5hbWVzIHtcbiAgcmV0dXJuIGZyb20gaW5zdGFuY2VvZiBfQ29kZU9yTmFtZSA/IGFkZE5hbWVzKG5hbWVzLCBmcm9tLm5hbWVzKSA6IG5hbWVzXG59XG5cbmZ1bmN0aW9uIG9wdGltaXplRXhwcjxUIGV4dGVuZHMgU2FmZUV4cHIgfCBDb2RlPihleHByOiBULCBuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IFRcbmZ1bmN0aW9uIG9wdGltaXplRXhwcihleHByOiBTYWZlRXhwciwgbmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiBTYWZlRXhwciB7XG4gIGlmIChleHByIGluc3RhbmNlb2YgTmFtZSkgcmV0dXJuIHJlcGxhY2VOYW1lKGV4cHIpXG4gIGlmICghY2FuT3B0aW1pemUoZXhwcikpIHJldHVybiBleHByXG4gIHJldHVybiBuZXcgX0NvZGUoXG4gICAgZXhwci5faXRlbXMucmVkdWNlKChpdGVtczogQ29kZUl0ZW1bXSwgYzogU2FmZUV4cHIgfCBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSkgYyA9IHJlcGxhY2VOYW1lKGMpXG4gICAgICBpZiAoYyBpbnN0YW5jZW9mIF9Db2RlKSBpdGVtcy5wdXNoKC4uLmMuX2l0ZW1zKVxuICAgICAgZWxzZSBpdGVtcy5wdXNoKGMpXG4gICAgICByZXR1cm4gaXRlbXNcbiAgICB9LCBbXSlcbiAgKVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2VOYW1lKG46IE5hbWUpOiBTYWZlRXhwciB7XG4gICAgY29uc3QgYyA9IGNvbnN0YW50c1tuLnN0cl1cbiAgICBpZiAoYyA9PT0gdW5kZWZpbmVkIHx8IG5hbWVzW24uc3RyXSAhPT0gMSkgcmV0dXJuIG5cbiAgICBkZWxldGUgbmFtZXNbbi5zdHJdXG4gICAgcmV0dXJuIGNcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbk9wdGltaXplKGU6IFNhZmVFeHByKTogZSBpcyBfQ29kZSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGUgaW5zdGFuY2VvZiBfQ29kZSAmJlxuICAgICAgZS5faXRlbXMuc29tZShcbiAgICAgICAgKGMpID0+IGMgaW5zdGFuY2VvZiBOYW1lICYmIG5hbWVzW2Muc3RyXSA9PT0gMSAmJiBjb25zdGFudHNbYy5zdHJdICE9PSB1bmRlZmluZWRcbiAgICAgIClcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gc3VidHJhY3ROYW1lcyhuYW1lczogVXNlZE5hbWVzLCBmcm9tOiBVc2VkTmFtZXMpOiB2b2lkIHtcbiAgZm9yIChjb25zdCBuIGluIGZyb20pIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApIC0gKGZyb21bbl0gfHwgMClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vdDxUIGV4dGVuZHMgQ29kZSB8IFNhZmVFeHByPih4OiBUKTogVFxuZXhwb3J0IGZ1bmN0aW9uIG5vdCh4OiBDb2RlIHwgU2FmZUV4cHIpOiBDb2RlIHwgU2FmZUV4cHIge1xuICByZXR1cm4gdHlwZW9mIHggPT0gXCJib29sZWFuXCIgfHwgdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB4ID09PSBudWxsID8gIXggOiBfYCEke3Bhcih4KX1gXG59XG5cbmNvbnN0IGFuZENvZGUgPSBtYXBwZW5kKG9wZXJhdG9ycy5BTkQpXG5cbi8vIGJvb2xlYW4gQU5EICgmJikgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gYW5kKC4uLmFyZ3M6IENvZGVbXSk6IENvZGUge1xuICByZXR1cm4gYXJncy5yZWR1Y2UoYW5kQ29kZSlcbn1cblxuY29uc3Qgb3JDb2RlID0gbWFwcGVuZChvcGVyYXRvcnMuT1IpXG5cbi8vIGJvb2xlYW4gT1IgKHx8KSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmV4cG9ydCBmdW5jdGlvbiBvciguLi5hcmdzOiBDb2RlW10pOiBDb2RlIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKG9yQ29kZSlcbn1cblxudHlwZSBNQXBwZW5kID0gKHg6IENvZGUsIHk6IENvZGUpID0+IENvZGVcblxuZnVuY3Rpb24gbWFwcGVuZChvcDogQ29kZSk6IE1BcHBlbmQge1xuICByZXR1cm4gKHgsIHkpID0+ICh4ID09PSBuaWwgPyB5IDogeSA9PT0gbmlsID8geCA6IF9gJHtwYXIoeCl9ICR7b3B9ICR7cGFyKHkpfWApXG59XG5cbmZ1bmN0aW9uIHBhcih4OiBDb2RlKTogQ29kZSB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgTmFtZSA/IHggOiBfYCgke3h9KWBcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hLCBFdmFsdWF0ZWRQcm9wZXJ0aWVzLCBFdmFsdWF0ZWRJdGVtc30gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi5cIlxuaW1wb3J0IHtfLCBnZXRQcm9wZXJ0eSwgQ29kZSwgTmFtZSwgQ29kZUdlbn0gZnJvbSBcIi4vY29kZWdlblwiXG5pbXBvcnQge19Db2RlfSBmcm9tIFwiLi9jb2RlZ2VuL2NvZGVcIlxuaW1wb3J0IHR5cGUge1J1bGUsIFZhbGlkYXRpb25SdWxlc30gZnJvbSBcIi4vcnVsZXNcIlxuXG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBTZXRcbmV4cG9ydCBmdW5jdGlvbiB0b0hhc2g8VCBleHRlbmRzIHN0cmluZyA9IHN0cmluZz4oYXJyOiBUW10pOiB7W0sgaW4gVF0/OiB0cnVlfSB7XG4gIGNvbnN0IGhhc2g6IHtbSyBpbiBUXT86IHRydWV9ID0ge31cbiAgZm9yIChjb25zdCBpdGVtIG9mIGFycikgaGFzaFtpdGVtXSA9IHRydWVcbiAgcmV0dXJuIGhhc2hcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsd2F5c1ZhbGlkU2NoZW1hKGl0OiBTY2hlbWFDeHQsIHNjaGVtYTogQW55U2NoZW1hKTogYm9vbGVhbiB8IHZvaWQge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHNjaGVtYVxuICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hKS5sZW5ndGggPT09IDApIHJldHVybiB0cnVlXG4gIGNoZWNrVW5rbm93blJ1bGVzKGl0LCBzY2hlbWEpXG4gIHJldHVybiAhc2NoZW1hSGFzUnVsZXMoc2NoZW1hLCBpdC5zZWxmLlJVTEVTLmFsbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrVW5rbm93blJ1bGVzKGl0OiBTY2hlbWFDeHQsIHNjaGVtYTogQW55U2NoZW1hID0gaXQuc2NoZW1hKTogdm9pZCB7XG4gIGNvbnN0IHtvcHRzLCBzZWxmfSA9IGl0XG4gIGlmICghb3B0cy5zdHJpY3RTY2hlbWEpIHJldHVyblxuICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpIHJldHVyblxuICBjb25zdCBydWxlcyA9IHNlbGYuUlVMRVMua2V5d29yZHNcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKCFydWxlc1trZXldKSBjaGVja1N0cmljdE1vZGUoaXQsIGB1bmtub3duIGtleXdvcmQ6IFwiJHtrZXl9XCJgKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFIYXNSdWxlcyhcbiAgc2NoZW1hOiBBbnlTY2hlbWEsXG4gIHJ1bGVzOiB7W0tleSBpbiBzdHJpbmddPzogYm9vbGVhbiB8IFJ1bGV9XG4pOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiAhc2NoZW1hXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkgaWYgKHJ1bGVzW2tleV0pIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hOiBBbnlTY2hlbWEsIFJVTEVTOiBWYWxpZGF0aW9uUnVsZXMpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiAhc2NoZW1hXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkgaWYgKGtleSAhPT0gXCIkcmVmXCIgJiYgUlVMRVMuYWxsW2tleV0pIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hUmVmT3JWYWwoXG4gIHt0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGh9OiBTY2hlbWFPYmpDeHQsXG4gIHNjaGVtYTogdW5rbm93bixcbiAga2V5d29yZDogc3RyaW5nLFxuICAkZGF0YT86IHN0cmluZyB8IGZhbHNlXG4pOiBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiB7XG4gIGlmICghJGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiBzY2hlbWFcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiKSByZXR1cm4gX2Ake3NjaGVtYX1gXG4gIH1cbiAgcmV0dXJuIF9gJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofSR7Z2V0UHJvcGVydHkoa2V5d29yZCl9YFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVGcmFnbWVudChzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB1bmVzY2FwZUpzb25Qb2ludGVyKGRlY29kZVVSSUNvbXBvbmVudChzdHIpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRnJhZ21lbnQoc3RyOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZUpzb25Qb2ludGVyKHN0cikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVKc29uUG9pbnRlcihzdHI6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gIGlmICh0eXBlb2Ygc3RyID09IFwibnVtYmVyXCIpIHJldHVybiBgJHtzdHJ9YFxuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXC8vZywgXCJ+MVwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5lc2NhcGVKc29uUG9pbnRlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfjEvZywgXCIvXCIpLnJlcGxhY2UoL34wL2csIFwiflwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZWFjaEl0ZW08VD4oeHM6IFQgfCBUW10sIGY6ICh4OiBUKSA9PiB2b2lkKTogdm9pZCB7XG4gIGlmIChBcnJheS5pc0FycmF5KHhzKSkge1xuICAgIGZvciAoY29uc3QgeCBvZiB4cykgZih4KVxuICB9IGVsc2Uge1xuICAgIGYoeHMpXG4gIH1cbn1cblxudHlwZSBTb21lRXZhbHVhdGVkID0gRXZhbHVhdGVkUHJvcGVydGllcyB8IEV2YWx1YXRlZEl0ZW1zXG5cbnR5cGUgTWVyZ2VFdmFsdWF0ZWRGdW5jPFQgZXh0ZW5kcyBTb21lRXZhbHVhdGVkPiA9IChcbiAgZ2VuOiBDb2RlR2VuLFxuICBmcm9tOiBOYW1lIHwgVCxcbiAgdG86IE5hbWUgfCBFeGNsdWRlPFQsIHRydWU+IHwgdW5kZWZpbmVkLFxuICB0b05hbWU/OiB0eXBlb2YgTmFtZVxuKSA9PiBOYW1lIHwgVFxuXG5pbnRlcmZhY2UgTWFrZU1lcmdlRnVuY0FyZ3M8VCBleHRlbmRzIFNvbWVFdmFsdWF0ZWQ+IHtcbiAgbWVyZ2VOYW1lczogKGdlbjogQ29kZUdlbiwgZnJvbTogTmFtZSwgdG86IE5hbWUpID0+IHZvaWRcbiAgbWVyZ2VUb05hbWU6IChnZW46IENvZGVHZW4sIGZyb206IFQsIHRvOiBOYW1lKSA9PiB2b2lkXG4gIG1lcmdlVmFsdWVzOiAoZnJvbTogVCwgdG86IEV4Y2x1ZGU8VCwgdHJ1ZT4pID0+IFRcbiAgcmVzdWx0VG9OYW1lOiAoZ2VuOiBDb2RlR2VuLCByZXM/OiBUKSA9PiBOYW1lXG59XG5cbmZ1bmN0aW9uIG1ha2VNZXJnZUV2YWx1YXRlZDxUIGV4dGVuZHMgU29tZUV2YWx1YXRlZD4oe1xuICBtZXJnZU5hbWVzLFxuICBtZXJnZVRvTmFtZSxcbiAgbWVyZ2VWYWx1ZXMsXG4gIHJlc3VsdFRvTmFtZSxcbn06IE1ha2VNZXJnZUZ1bmNBcmdzPFQ+KTogTWVyZ2VFdmFsdWF0ZWRGdW5jPFQ+IHtcbiAgcmV0dXJuIChnZW4sIGZyb20sIHRvLCB0b05hbWUpID0+IHtcbiAgICBjb25zdCByZXMgPVxuICAgICAgdG8gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IGZyb21cbiAgICAgICAgOiB0byBpbnN0YW5jZW9mIE5hbWVcbiAgICAgICAgPyAoZnJvbSBpbnN0YW5jZW9mIE5hbWUgPyBtZXJnZU5hbWVzKGdlbiwgZnJvbSwgdG8pIDogbWVyZ2VUb05hbWUoZ2VuLCBmcm9tLCB0byksIHRvKVxuICAgICAgICA6IGZyb20gaW5zdGFuY2VvZiBOYW1lXG4gICAgICAgID8gKG1lcmdlVG9OYW1lKGdlbiwgdG8sIGZyb20pLCBmcm9tKVxuICAgICAgICA6IG1lcmdlVmFsdWVzKGZyb20sIHRvKVxuICAgIHJldHVybiB0b05hbWUgPT09IE5hbWUgJiYgIShyZXMgaW5zdGFuY2VvZiBOYW1lKSA/IHJlc3VsdFRvTmFtZShnZW4sIHJlcykgOiByZXNcbiAgfVxufVxuXG5pbnRlcmZhY2UgTWVyZ2VFdmFsdWF0ZWQge1xuICBwcm9wczogTWVyZ2VFdmFsdWF0ZWRGdW5jPEV2YWx1YXRlZFByb3BlcnRpZXM+XG4gIGl0ZW1zOiBNZXJnZUV2YWx1YXRlZEZ1bmM8RXZhbHVhdGVkSXRlbXM+XG59XG5cbmV4cG9ydCBjb25zdCBtZXJnZUV2YWx1YXRlZDogTWVyZ2VFdmFsdWF0ZWQgPSB7XG4gIHByb3BzOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PlxuICAgICAgZ2VuLmlmKF9gJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgICAgICBnZW4uaWYoXG4gICAgICAgICAgX2Ake2Zyb219ID09PSB0cnVlYCxcbiAgICAgICAgICAoKSA9PiBnZW4uYXNzaWduKHRvLCB0cnVlKSxcbiAgICAgICAgICAoKSA9PiBnZW4uYXNzaWduKHRvLCBfYCR7dG99IHx8IHt9YCkuY29kZShfYE9iamVjdC5hc3NpZ24oJHt0b30sICR7ZnJvbX0pYClcbiAgICAgICAgKVxuICAgICAgfSksXG4gICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PlxuICAgICAgZ2VuLmlmKF9gJHt0b30gIT09IHRydWVgLCAoKSA9PiB7XG4gICAgICAgIGlmIChmcm9tID09PSB0cnVlKSB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih0bywgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW4uYXNzaWduKHRvLCBfYCR7dG99IHx8IHt9YClcbiAgICAgICAgICBzZXRFdmFsdWF0ZWQoZ2VuLCB0bywgZnJvbSlcbiAgICAgICAgfVxuICAgICAgfSksXG4gICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogey4uLmZyb20sIC4uLnRvfSksXG4gICAgcmVzdWx0VG9OYW1lOiBldmFsdWF0ZWRQcm9wc1RvTmFtZSxcbiAgfSksXG4gIGl0ZW1zOiBtYWtlTWVyZ2VFdmFsdWF0ZWQoe1xuICAgIG1lcmdlTmFtZXM6IChnZW4sIGZyb20sIHRvKSA9PlxuICAgICAgZ2VuLmlmKF9gJHt0b30gIT09IHRydWUgJiYgJHtmcm9tfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT5cbiAgICAgICAgZ2VuLmFzc2lnbih0bywgX2Ake2Zyb219ID09PSB0cnVlID8gdHJ1ZSA6ICR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApXG4gICAgICApLFxuICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlYCwgKCkgPT5cbiAgICAgICAgZ2VuLmFzc2lnbih0bywgZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBfYCR7dG99ID4gJHtmcm9tfSA/ICR7dG99IDogJHtmcm9tfWApXG4gICAgICApLFxuICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IE1hdGgubWF4KGZyb20sIHRvKSksXG4gICAgcmVzdWx0VG9OYW1lOiAoZ2VuLCBpdGVtcykgPT4gZ2VuLnZhcihcIml0ZW1zXCIsIGl0ZW1zKSxcbiAgfSksXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW46IENvZGVHZW4sIHBzPzogRXZhbHVhdGVkUHJvcGVydGllcyk6IE5hbWUge1xuICBpZiAocHMgPT09IHRydWUpIHJldHVybiBnZW4udmFyKFwicHJvcHNcIiwgdHJ1ZSlcbiAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgX2B7fWApXG4gIGlmIChwcyAhPT0gdW5kZWZpbmVkKSBzZXRFdmFsdWF0ZWQoZ2VuLCBwcm9wcywgcHMpXG4gIHJldHVybiBwcm9wc1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0RXZhbHVhdGVkKGdlbjogQ29kZUdlbiwgcHJvcHM6IE5hbWUsIHBzOiB7W0sgaW4gc3RyaW5nXT86IHRydWV9KTogdm9pZCB7XG4gIE9iamVjdC5rZXlzKHBzKS5mb3JFYWNoKChwKSA9PiBnZW4uYXNzaWduKF9gJHtwcm9wc30ke2dldFByb3BlcnR5KHApfWAsIHRydWUpKVxufVxuXG5jb25zdCBzbmlwcGV0czoge1tTIGluIHN0cmluZ10/OiBfQ29kZX0gPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gdXNlRnVuYyhnZW46IENvZGVHZW4sIGY6IHtjb2RlOiBzdHJpbmd9KTogTmFtZSB7XG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgIHJlZjogZixcbiAgICBjb2RlOiBzbmlwcGV0c1tmLmNvZGVdIHx8IChzbmlwcGV0c1tmLmNvZGVdID0gbmV3IF9Db2RlKGYuY29kZSkpLFxuICB9KVxufVxuXG5leHBvcnQgZW51bSBUeXBlIHtcbiAgTnVtLFxuICBTdHIsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvclBhdGgoXG4gIGRhdGFQcm9wOiBOYW1lIHwgc3RyaW5nIHwgbnVtYmVyLFxuICBkYXRhUHJvcFR5cGU/OiBUeXBlLFxuICBqc1Byb3BlcnR5U3ludGF4PzogYm9vbGVhblxuKTogQ29kZSB8IHN0cmluZyB7XG4gIC8vIGxldCBwYXRoXG4gIGlmIChkYXRhUHJvcCBpbnN0YW5jZW9mIE5hbWUpIHtcbiAgICBjb25zdCBpc051bWJlciA9IGRhdGFQcm9wVHlwZSA9PT0gVHlwZS5OdW1cbiAgICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheFxuICAgICAgPyBpc051bWJlclxuICAgICAgICA/IF9gXCJbXCIgKyAke2RhdGFQcm9wfSArIFwiXVwiYFxuICAgICAgICA6IF9gXCJbJ1wiICsgJHtkYXRhUHJvcH0gKyBcIiddXCJgXG4gICAgICA6IGlzTnVtYmVyXG4gICAgICA/IF9gXCIvXCIgKyAke2RhdGFQcm9wfWBcbiAgICAgIDogX2BcIi9cIiArICR7ZGF0YVByb3B9LnJlcGxhY2UoL34vZywgXCJ+MFwiKS5yZXBsYWNlKC9cXFxcLy9nLCBcIn4xXCIpYCAvLyBUT0RPIG1heWJlIHVzZSBnbG9iYWwgZXNjYXBlUG9pbnRlclxuICB9XG4gIHJldHVybiBqc1Byb3BlcnR5U3ludGF4ID8gZ2V0UHJvcGVydHkoZGF0YVByb3ApLnRvU3RyaW5nKCkgOiBcIi9cIiArIGVzY2FwZUpzb25Qb2ludGVyKGRhdGFQcm9wKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tTdHJpY3RNb2RlKFxuICBpdDogU2NoZW1hQ3h0LFxuICBtc2c6IHN0cmluZyxcbiAgbW9kZTogYm9vbGVhbiB8IFwibG9nXCIgPSBpdC5vcHRzLnN0cmljdFNjaGVtYVxuKTogdm9pZCB7XG4gIGlmICghbW9kZSkgcmV0dXJuXG4gIG1zZyA9IGBzdHJpY3QgbW9kZTogJHttc2d9YFxuICBpZiAobW9kZSA9PT0gdHJ1ZSkgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgaXQuc2VsZi5sb2dnZXIud2Fybihtc2cpXG59XG4iLCAiaW1wb3J0IHtOYW1lfSBmcm9tIFwiLi9jb2RlZ2VuXCJcblxuY29uc3QgbmFtZXMgPSB7XG4gIC8vIHZhbGlkYXRpb24gZnVuY3Rpb24gYXJndW1lbnRzXG4gIGRhdGE6IG5ldyBOYW1lKFwiZGF0YVwiKSwgLy8gZGF0YSBwYXNzZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICAvLyBhcmdzIHBhc3NlZCBmcm9tIHJlZmVyZW5jaW5nIHNjaGVtYVxuICB2YWxDeHQ6IG5ldyBOYW1lKFwidmFsQ3h0XCIpLCAvLyB2YWxpZGF0aW9uL2RhdGEgY29udGV4dCAtIHNob3VsZCBub3QgYmUgdXNlZCBkaXJlY3RseSwgaXQgaXMgZGVzdHJ1Y3R1cmVkIHRvIHRoZSBuYW1lcyBiZWxvd1xuICBpbnN0YW5jZVBhdGg6IG5ldyBOYW1lKFwiaW5zdGFuY2VQYXRoXCIpLFxuICBwYXJlbnREYXRhOiBuZXcgTmFtZShcInBhcmVudERhdGFcIiksXG4gIHBhcmVudERhdGFQcm9wZXJ0eTogbmV3IE5hbWUoXCJwYXJlbnREYXRhUHJvcGVydHlcIiksXG4gIHJvb3REYXRhOiBuZXcgTmFtZShcInJvb3REYXRhXCIpLCAvLyByb290IGRhdGEgLSBzYW1lIGFzIHRoZSBkYXRhIHBhc3NlZCB0byB0aGUgZmlyc3QvdG9wIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgZHluYW1pY0FuY2hvcnM6IG5ldyBOYW1lKFwiZHluYW1pY0FuY2hvcnNcIiksIC8vIHVzZWQgdG8gc3VwcG9ydCByZWN1cnNpdmVSZWYgYW5kIGR5bmFtaWNSZWZcbiAgLy8gZnVuY3Rpb24gc2NvcGVkIHZhcmlhYmxlc1xuICB2RXJyb3JzOiBuZXcgTmFtZShcInZFcnJvcnNcIiksIC8vIG51bGwgb3IgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgZXJyb3JzOiBuZXcgTmFtZShcImVycm9yc1wiKSwgLy8gY291bnRlciBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICB0aGlzOiBuZXcgTmFtZShcInRoaXNcIiksXG4gIC8vIFwiZ2xvYmFsc1wiXG4gIHNlbGY6IG5ldyBOYW1lKFwic2VsZlwiKSxcbiAgc2NvcGU6IG5ldyBOYW1lKFwic2NvcGVcIiksXG4gIC8vIEpURCBzZXJpYWxpemUvcGFyc2UgbmFtZSBmb3IgSlNPTiBzdHJpbmcgYW5kIHBvc2l0aW9uXG4gIGpzb246IG5ldyBOYW1lKFwianNvblwiKSxcbiAganNvblBvczogbmV3IE5hbWUoXCJqc29uUG9zXCIpLFxuICBqc29uTGVuOiBuZXcgTmFtZShcImpzb25MZW5cIiksXG4gIGpzb25QYXJ0OiBuZXcgTmFtZShcImpzb25QYXJ0XCIpLFxufVxuXG5leHBvcnQgZGVmYXVsdCBuYW1lc1xuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkRXJyb3JDeHQsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi9pbmRleFwiXG5pbXBvcnQge0NvZGVHZW4sIF8sIHN0ciwgc3RyQ29uY2F0LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi9jb2RlZ2VuXCJcbmltcG9ydCB7U2FmZUV4cHJ9IGZyb20gXCIuL2NvZGVnZW4vY29kZVwiXG5pbXBvcnQge2dldEVycm9yUGF0aCwgVHlwZX0gZnJvbSBcIi4vdXRpbFwiXG5pbXBvcnQgTiBmcm9tIFwiLi9uYW1lc1wiXG5cbmV4cG9ydCBjb25zdCBrZXl3b3JkRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7a2V5d29yZH0pID0+IHN0cmBtdXN0IHBhc3MgXCIke2tleXdvcmR9XCIga2V5d29yZCB2YWxpZGF0aW9uYCxcbn1cblxuZXhwb3J0IGNvbnN0IGtleXdvcmQkRGF0YUVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmQsIHNjaGVtYVR5cGV9KSA9PlxuICAgIHNjaGVtYVR5cGVcbiAgICAgID8gc3RyYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgbXVzdCBiZSAke3NjaGVtYVR5cGV9ICgkZGF0YSlgXG4gICAgICA6IHN0cmBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIGlzIGludmFsaWQgKCRkYXRhKWAsXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JQYXRocyB7XG4gIGluc3RhbmNlUGF0aD86IENvZGVcbiAgc2NoZW1hUGF0aD86IHN0cmluZ1xuICBwYXJlbnRTY2hlbWE/OiBib29sZWFuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRFcnJvcihcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ga2V5d29yZEVycm9yLFxuICBlcnJvclBhdGhzPzogRXJyb3JQYXRocyxcbiAgb3ZlcnJpZGVBbGxFcnJvcnM/OiBib29sZWFuXG4pOiB2b2lkIHtcbiAgY29uc3Qge2l0fSA9IGN4dFxuICBjb25zdCB7Z2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnN9ID0gaXRcbiAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpXG4gIGlmIChvdmVycmlkZUFsbEVycm9ycyA/PyAoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuRXJyb3JzKGl0LCBfYFske2Vyck9ian1dYClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0RXh0cmFFcnJvcihcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ga2V5d29yZEVycm9yLFxuICBlcnJvclBhdGhzPzogRXJyb3JQYXRoc1xuKTogdm9pZCB7XG4gIGNvbnN0IHtpdH0gPSBjeHRcbiAgY29uc3Qge2dlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzfSA9IGl0XG4gIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKVxuICBhZGRFcnJvcihnZW4sIGVyck9iailcbiAgaWYgKCEoY29tcG9zaXRlUnVsZSB8fCBhbGxFcnJvcnMpKSB7XG4gICAgcmV0dXJuRXJyb3JzKGl0LCBOLnZFcnJvcnMpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc2V0RXJyb3JzQ291bnQoZ2VuOiBDb2RlR2VuLCBlcnJzQ291bnQ6IE5hbWUpOiB2b2lkIHtcbiAgZ2VuLmFzc2lnbihOLmVycm9ycywgZXJyc0NvdW50KVxuICBnZW4uaWYoX2Ake04udkVycm9yc30gIT09IG51bGxgLCAoKSA9PlxuICAgIGdlbi5pZihcbiAgICAgIGVycnNDb3VudCxcbiAgICAgICgpID0+IGdlbi5hc3NpZ24oX2Ake04udkVycm9yc30ubGVuZ3RoYCwgZXJyc0NvdW50KSxcbiAgICAgICgpID0+IGdlbi5hc3NpZ24oTi52RXJyb3JzLCBudWxsKVxuICAgIClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kRXJyb3JzKHtcbiAgZ2VuLFxuICBrZXl3b3JkLFxuICBzY2hlbWFWYWx1ZSxcbiAgZGF0YSxcbiAgZXJyc0NvdW50LFxuICBpdCxcbn06IEtleXdvcmRFcnJvckN4dCk6IHZvaWQge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGVycnNDb3VudCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgY29uc3QgZXJyID0gZ2VuLm5hbWUoXCJlcnJcIilcbiAgZ2VuLmZvclJhbmdlKFwiaVwiLCBlcnJzQ291bnQsIE4uZXJyb3JzLCAoaSkgPT4ge1xuICAgIGdlbi5jb25zdChlcnIsIF9gJHtOLnZFcnJvcnN9WyR7aX1dYClcbiAgICBnZW4uaWYoX2Ake2Vycn0uaW5zdGFuY2VQYXRoID09PSB1bmRlZmluZWRgLCAoKSA9PlxuICAgICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5pbnN0YW5jZVBhdGhgLCBzdHJDb25jYXQoTi5pbnN0YW5jZVBhdGgsIGl0LmVycm9yUGF0aCkpXG4gICAgKVxuICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uc2NoZW1hUGF0aGAsIHN0cmAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gKVxuICAgIGlmIChpdC5vcHRzLnZlcmJvc2UpIHtcbiAgICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uc2NoZW1hYCwgc2NoZW1hVmFsdWUpXG4gICAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LmRhdGFgLCBkYXRhKVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3IoZ2VuOiBDb2RlR2VuLCBlcnJPYmo6IENvZGUpOiB2b2lkIHtcbiAgY29uc3QgZXJyID0gZ2VuLmNvbnN0KFwiZXJyXCIsIGVyck9iailcbiAgZ2VuLmlmKFxuICAgIF9gJHtOLnZFcnJvcnN9ID09PSBudWxsYCxcbiAgICAoKSA9PiBnZW4uYXNzaWduKE4udkVycm9ycywgX2BbJHtlcnJ9XWApLFxuICAgIF9gJHtOLnZFcnJvcnN9LnB1c2goJHtlcnJ9KWBcbiAgKVxuICBnZW4uY29kZShfYCR7Ti5lcnJvcnN9KytgKVxufVxuXG5mdW5jdGlvbiByZXR1cm5FcnJvcnMoaXQ6IFNjaGVtYUN4dCwgZXJyczogQ29kZSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYUVudn0gPSBpdFxuICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgIGdlbi50aHJvdyhfYG5ldyAke2l0LlZhbGlkYXRpb25FcnJvciBhcyBOYW1lfSgke2VycnN9KWApXG4gIH0gZWxzZSB7XG4gICAgZ2VuLmFzc2lnbihfYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBlcnJzKVxuICAgIGdlbi5yZXR1cm4oZmFsc2UpXG4gIH1cbn1cblxuY29uc3QgRSA9IHtcbiAga2V5d29yZDogbmV3IE5hbWUoXCJrZXl3b3JkXCIpLFxuICBzY2hlbWFQYXRoOiBuZXcgTmFtZShcInNjaGVtYVBhdGhcIiksIC8vIGFsc28gdXNlZCBpbiBKVEQgZXJyb3JzXG4gIHBhcmFtczogbmV3IE5hbWUoXCJwYXJhbXNcIiksXG4gIHByb3BlcnR5TmFtZTogbmV3IE5hbWUoXCJwcm9wZXJ0eU5hbWVcIiksXG4gIG1lc3NhZ2U6IG5ldyBOYW1lKFwibWVzc2FnZVwiKSxcbiAgc2NoZW1hOiBuZXcgTmFtZShcInNjaGVtYVwiKSxcbiAgcGFyZW50U2NoZW1hOiBuZXcgTmFtZShcInBhcmVudFNjaGVtYVwiKSxcbn1cblxuZnVuY3Rpb24gZXJyb3JPYmplY3RDb2RlKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzXG4pOiBDb2RlIHtcbiAgY29uc3Qge2NyZWF0ZUVycm9yc30gPSBjeHQuaXRcbiAgaWYgKGNyZWF0ZUVycm9ycyA9PT0gZmFsc2UpIHJldHVybiBfYHt9YFxuICByZXR1cm4gZXJyb3JPYmplY3QoY3h0LCBlcnJvciwgZXJyb3JQYXRocylcbn1cblxuZnVuY3Rpb24gZXJyb3JPYmplY3QoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgZXJyb3JQYXRoczogRXJyb3JQYXRocyA9IHt9XG4pOiBDb2RlIHtcbiAgY29uc3Qge2dlbiwgaXR9ID0gY3h0XG4gIGNvbnN0IGtleVZhbHVlczogW05hbWUsIFNhZmVFeHByIHwgc3RyaW5nXVtdID0gW1xuICAgIGVycm9ySW5zdGFuY2VQYXRoKGl0LCBlcnJvclBhdGhzKSxcbiAgICBlcnJvclNjaGVtYVBhdGgoY3h0LCBlcnJvclBhdGhzKSxcbiAgXVxuICBleHRyYUVycm9yUHJvcHMoY3h0LCBlcnJvciwga2V5VmFsdWVzKVxuICByZXR1cm4gZ2VuLm9iamVjdCguLi5rZXlWYWx1ZXMpXG59XG5cbmZ1bmN0aW9uIGVycm9ySW5zdGFuY2VQYXRoKHtlcnJvclBhdGh9OiBTY2hlbWFDeHQsIHtpbnN0YW5jZVBhdGh9OiBFcnJvclBhdGhzKTogW05hbWUsIENvZGVdIHtcbiAgY29uc3QgaW5zdFBhdGggPSBpbnN0YW5jZVBhdGhcbiAgICA/IHN0cmAke2Vycm9yUGF0aH0ke2dldEVycm9yUGF0aChpbnN0YW5jZVBhdGgsIFR5cGUuU3RyKX1gXG4gICAgOiBlcnJvclBhdGhcbiAgcmV0dXJuIFtOLmluc3RhbmNlUGF0aCwgc3RyQ29uY2F0KE4uaW5zdGFuY2VQYXRoLCBpbnN0UGF0aCldXG59XG5cbmZ1bmN0aW9uIGVycm9yU2NoZW1hUGF0aChcbiAge2tleXdvcmQsIGl0OiB7ZXJyU2NoZW1hUGF0aH19OiBLZXl3b3JkRXJyb3JDeHQsXG4gIHtzY2hlbWFQYXRoLCBwYXJlbnRTY2hlbWF9OiBFcnJvclBhdGhzXG4pOiBbTmFtZSwgc3RyaW5nIHwgQ29kZV0ge1xuICBsZXQgc2NoUGF0aCA9IHBhcmVudFNjaGVtYSA/IGVyclNjaGVtYVBhdGggOiBzdHJgJHtlcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YFxuICBpZiAoc2NoZW1hUGF0aCkge1xuICAgIHNjaFBhdGggPSBzdHJgJHtzY2hQYXRofSR7Z2V0RXJyb3JQYXRoKHNjaGVtYVBhdGgsIFR5cGUuU3RyKX1gXG4gIH1cbiAgcmV0dXJuIFtFLnNjaGVtYVBhdGgsIHNjaFBhdGhdXG59XG5cbmZ1bmN0aW9uIGV4dHJhRXJyb3JQcm9wcyhcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIHtwYXJhbXMsIG1lc3NhZ2V9OiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBrZXlWYWx1ZXM6IFtOYW1lLCBTYWZlRXhwciB8IHN0cmluZ11bXVxuKTogdm9pZCB7XG4gIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFWYWx1ZSwgaXR9ID0gY3h0XG4gIGNvbnN0IHtvcHRzLCBwcm9wZXJ0eU5hbWUsIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aH0gPSBpdFxuICBrZXlWYWx1ZXMucHVzaChcbiAgICBbRS5rZXl3b3JkLCBrZXl3b3JkXSxcbiAgICBbRS5wYXJhbXMsIHR5cGVvZiBwYXJhbXMgPT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGN4dCkgOiBwYXJhbXMgfHwgX2B7fWBdXG4gIClcbiAgaWYgKG9wdHMubWVzc2FnZXMpIHtcbiAgICBrZXlWYWx1ZXMucHVzaChbRS5tZXNzYWdlLCB0eXBlb2YgbWVzc2FnZSA9PSBcImZ1bmN0aW9uXCIgPyBtZXNzYWdlKGN4dCkgOiBtZXNzYWdlXSlcbiAgfVxuICBpZiAob3B0cy52ZXJib3NlKSB7XG4gICAga2V5VmFsdWVzLnB1c2goXG4gICAgICBbRS5zY2hlbWEsIHNjaGVtYVZhbHVlXSxcbiAgICAgIFtFLnBhcmVudFNjaGVtYSwgX2Ake3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YF0sXG4gICAgICBbTi5kYXRhLCBkYXRhXVxuICAgIClcbiAgfVxuICBpZiAocHJvcGVydHlOYW1lKSBrZXlWYWx1ZXMucHVzaChbRS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZV0pXG59XG4iLCAiaW1wb3J0IHR5cGUge0tleXdvcmRFcnJvckRlZmluaXRpb24sIEtleXdvcmRFcnJvckN4dH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge3JlcG9ydEVycm9yfSBmcm9tIFwiLi4vZXJyb3JzXCJcbmltcG9ydCB7XywgTmFtZX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uL25hbWVzXCJcblxuY29uc3QgYm9vbEVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcImJvb2xlYW4gc2NoZW1hIGlzIGZhbHNlXCIsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdDogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYSwgdmFsaWRhdGVOYW1lfSA9IGl0XG4gIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgZmFsc2VTY2hlbWFFcnJvcihpdCwgZmFsc2UpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYS4kYXN5bmMgPT09IHRydWUpIHtcbiAgICBnZW4ucmV0dXJuKE4uZGF0YSlcbiAgfSBlbHNlIHtcbiAgICBnZW4uYXNzaWduKF9gJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIG51bGwpXG4gICAgZ2VuLnJldHVybih0cnVlKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBib29sT3JFbXB0eVNjaGVtYShpdDogU2NoZW1hQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWF9ID0gaXRcbiAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICBnZW4udmFyKHZhbGlkLCBmYWxzZSkgLy8gVE9ETyB2YXJcbiAgICBmYWxzZVNjaGVtYUVycm9yKGl0KVxuICB9IGVsc2Uge1xuICAgIGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gIH1cbn1cblxuZnVuY3Rpb24gZmFsc2VTY2hlbWFFcnJvcihpdDogU2NoZW1hQ3h0LCBvdmVycmlkZUFsbEVycm9ycz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YX0gPSBpdFxuICAvLyBUT0RPIG1heWJlIHNvbWUgb3RoZXIgaW50ZXJmYWNlIHNob3VsZCBiZSB1c2VkIGZvciBub24ta2V5d29yZCB2YWxpZGF0aW9uIGVycm9ycy4uLlxuICBjb25zdCBjeHQ6IEtleXdvcmRFcnJvckN4dCA9IHtcbiAgICBnZW4sXG4gICAga2V5d29yZDogXCJmYWxzZSBzY2hlbWFcIixcbiAgICBkYXRhLFxuICAgIHNjaGVtYTogZmFsc2UsXG4gICAgc2NoZW1hQ29kZTogZmFsc2UsXG4gICAgc2NoZW1hVmFsdWU6IGZhbHNlLFxuICAgIHBhcmFtczoge30sXG4gICAgaXQsXG4gIH1cbiAgcmVwb3J0RXJyb3IoY3h0LCBib29sRXJyb3IsIHVuZGVmaW5lZCwgb3ZlcnJpZGVBbGxFcnJvcnMpXG59XG4iLCAiaW1wb3J0IHR5cGUge0FkZGVkS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi90eXBlc1wiXG5cbmNvbnN0IF9qc29uVHlwZXMgPSBbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIiwgXCJvYmplY3RcIiwgXCJhcnJheVwiXSBhcyBjb25zdFxuXG5leHBvcnQgdHlwZSBKU09OVHlwZSA9ICh0eXBlb2YgX2pzb25UeXBlcylbbnVtYmVyXVxuXG5jb25zdCBqc29uVHlwZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldChfanNvblR5cGVzKVxuXG5leHBvcnQgZnVuY3Rpb24gaXNKU09OVHlwZSh4OiB1bmtub3duKTogeCBpcyBKU09OVHlwZSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PSBcInN0cmluZ1wiICYmIGpzb25UeXBlcy5oYXMoeClcbn1cblxudHlwZSBWYWxpZGF0aW9uVHlwZXMgPSB7XG4gIFtLIGluIEpTT05UeXBlXTogYm9vbGVhbiB8IFJ1bGVHcm91cCB8IHVuZGVmaW5lZFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFZhbGlkYXRpb25SdWxlcyB7XG4gIHJ1bGVzOiBSdWxlR3JvdXBbXVxuICBwb3N0OiBSdWxlR3JvdXBcbiAgYWxsOiB7W0tleSBpbiBzdHJpbmddPzogYm9vbGVhbiB8IFJ1bGV9IC8vIHJ1bGVzIHRoYXQgaGF2ZSB0byBiZSB2YWxpZGF0ZWRcbiAga2V5d29yZHM6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFufSAvLyBhbGwga25vd24ga2V5d29yZHMgKHN1cGVyc2V0IG9mIFwiYWxsXCIpXG4gIHR5cGVzOiBWYWxpZGF0aW9uVHlwZXNcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSdWxlR3JvdXAge1xuICB0eXBlPzogSlNPTlR5cGVcbiAgcnVsZXM6IFJ1bGVbXVxufVxuXG4vLyBUaGlzIGludGVyZmFjZSB3cmFwcyBLZXl3b3JkRGVmaW5pdGlvbiBiZWNhdXNlIGRlZmluaXRpb24gY2FuIGhhdmUgbXVsdGlwbGUga2V5d29yZHNcbmV4cG9ydCBpbnRlcmZhY2UgUnVsZSB7XG4gIGtleXdvcmQ6IHN0cmluZ1xuICBkZWZpbml0aW9uOiBBZGRlZEtleXdvcmREZWZpbml0aW9uXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdWxlcygpOiBWYWxpZGF0aW9uUnVsZXMge1xuICBjb25zdCBncm91cHM6IFJlY29yZDxcIm51bWJlclwiIHwgXCJzdHJpbmdcIiB8IFwiYXJyYXlcIiB8IFwib2JqZWN0XCIsIFJ1bGVHcm91cD4gPSB7XG4gICAgbnVtYmVyOiB7dHlwZTogXCJudW1iZXJcIiwgcnVsZXM6IFtdfSxcbiAgICBzdHJpbmc6IHt0eXBlOiBcInN0cmluZ1wiLCBydWxlczogW119LFxuICAgIGFycmF5OiB7dHlwZTogXCJhcnJheVwiLCBydWxlczogW119LFxuICAgIG9iamVjdDoge3R5cGU6IFwib2JqZWN0XCIsIHJ1bGVzOiBbXX0sXG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlczogey4uLmdyb3VwcywgaW50ZWdlcjogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgbnVsbDogdHJ1ZX0sXG4gICAgcnVsZXM6IFt7cnVsZXM6IFtdfSwgZ3JvdXBzLm51bWJlciwgZ3JvdXBzLnN0cmluZywgZ3JvdXBzLmFycmF5LCBncm91cHMub2JqZWN0XSxcbiAgICBwb3N0OiB7cnVsZXM6IFtdfSxcbiAgICBhbGw6IHt9LFxuICAgIGtleXdvcmRzOiB7fSxcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWFPYmplY3R9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHR5cGUge0pTT05UeXBlLCBSdWxlR3JvdXAsIFJ1bGV9IGZyb20gXCIuLi9ydWxlc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoXG4gIHtzY2hlbWEsIHNlbGZ9OiBTY2hlbWFPYmpDeHQsXG4gIHR5cGU6IEpTT05UeXBlXG4pOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgZ3JvdXAgPSBzZWxmLlJVTEVTLnR5cGVzW3R5cGVdXG4gIHJldHVybiBncm91cCAmJiBncm91cCAhPT0gdHJ1ZSAmJiBzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVXNlR3JvdXAoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsIGdyb3VwOiBSdWxlR3JvdXApOiBib29sZWFuIHtcbiAgcmV0dXJuIGdyb3VwLnJ1bGVzLnNvbWUoKHJ1bGUpID0+IHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFVzZVJ1bGUoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsIHJ1bGU6IFJ1bGUpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIChcbiAgICBzY2hlbWFbcnVsZS5rZXl3b3JkXSAhPT0gdW5kZWZpbmVkIHx8XG4gICAgcnVsZS5kZWZpbml0aW9uLmltcGxlbWVudHM/LnNvbWUoKGt3ZCkgPT4gc2NoZW1hW2t3ZF0gIT09IHVuZGVmaW5lZClcbiAgKVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yQ3h0LFxuICBFcnJvck9iamVjdCxcbiAgQW55U2NoZW1hT2JqZWN0LFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7aXNKU09OVHlwZSwgSlNPTlR5cGV9IGZyb20gXCIuLi9ydWxlc1wiXG5pbXBvcnQge3NjaGVtYUhhc1J1bGVzRm9yVHlwZX0gZnJvbSBcIi4vYXBwbGljYWJpbGl0eVwiXG5pbXBvcnQge3JlcG9ydEVycm9yfSBmcm9tIFwiLi4vZXJyb3JzXCJcbmltcG9ydCB7XywgbmlsLCBhbmQsIG5vdCwgb3BlcmF0b3JzLCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQge3RvSGFzaCwgc2NoZW1hUmVmT3JWYWx9IGZyb20gXCIuLi91dGlsXCJcblxuZXhwb3J0IGVudW0gRGF0YVR5cGUge1xuICBDb3JyZWN0LFxuICBXcm9uZyxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVR5cGVzKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0KTogSlNPTlR5cGVbXSB7XG4gIGNvbnN0IHR5cGVzID0gZ2V0SlNPTlR5cGVzKHNjaGVtYS50eXBlKVxuICBjb25zdCBoYXNOdWxsID0gdHlwZXMuaW5jbHVkZXMoXCJudWxsXCIpXG4gIGlmIChoYXNOdWxsKSB7XG4gICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gZmFsc2UpIHRocm93IG5ldyBFcnJvcihcInR5cGU6IG51bGwgY29udHJhZGljdHMgbnVsbGFibGU6IGZhbHNlXCIpXG4gIH0gZWxzZSB7XG4gICAgaWYgKCF0eXBlcy5sZW5ndGggJiYgc2NoZW1hLm51bGxhYmxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJudWxsYWJsZVwiIGNhbm5vdCBiZSB1c2VkIHdpdGhvdXQgXCJ0eXBlXCInKVxuICAgIH1cbiAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlKSB0eXBlcy5wdXNoKFwibnVsbFwiKVxuICB9XG4gIHJldHVybiB0eXBlc1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGdldEpTT05UeXBlcyh0czogdW5rbm93biB8IHVua25vd25bXSk6IEpTT05UeXBlW10ge1xuICBjb25zdCB0eXBlczogdW5rbm93bltdID0gQXJyYXkuaXNBcnJheSh0cykgPyB0cyA6IHRzID8gW3RzXSA6IFtdXG4gIGlmICh0eXBlcy5ldmVyeShpc0pTT05UeXBlKSkgcmV0dXJuIHR5cGVzXG4gIHRocm93IG5ldyBFcnJvcihcInR5cGUgbXVzdCBiZSBKU09OVHlwZSBvciBKU09OVHlwZVtdOiBcIiArIHR5cGVzLmpvaW4oXCIsXCIpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSk6IGJvb2xlYW4ge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBvcHRzfSA9IGl0XG4gIGNvbnN0IGNvZXJjZVRvID0gY29lcmNlVG9UeXBlcyh0eXBlcywgb3B0cy5jb2VyY2VUeXBlcylcbiAgY29uc3QgY2hlY2tUeXBlcyA9XG4gICAgdHlwZXMubGVuZ3RoID4gMCAmJlxuICAgICEoY29lcmNlVG8ubGVuZ3RoID09PSAwICYmIHR5cGVzLmxlbmd0aCA9PT0gMSAmJiBzY2hlbWFIYXNSdWxlc0ZvclR5cGUoaXQsIHR5cGVzWzBdKSlcbiAgaWYgKGNoZWNrVHlwZXMpIHtcbiAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZylcbiAgICBnZW4uaWYod3JvbmdUeXBlLCAoKSA9PiB7XG4gICAgICBpZiAoY29lcmNlVG8ubGVuZ3RoKSBjb2VyY2VEYXRhKGl0LCB0eXBlcywgY29lcmNlVG8pXG4gICAgICBlbHNlIHJlcG9ydFR5cGVFcnJvcihpdClcbiAgICB9KVxuICB9XG4gIHJldHVybiBjaGVja1R5cGVzXG59XG5cbmNvbnN0IENPRVJDSUJMRTogU2V0PEpTT05UeXBlPiA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCJdKVxuZnVuY3Rpb24gY29lcmNlVG9UeXBlcyh0eXBlczogSlNPTlR5cGVbXSwgY29lcmNlVHlwZXM/OiBib29sZWFuIHwgXCJhcnJheVwiKTogSlNPTlR5cGVbXSB7XG4gIHJldHVybiBjb2VyY2VUeXBlc1xuICAgID8gdHlwZXMuZmlsdGVyKCh0KSA9PiBDT0VSQ0lCTEUuaGFzKHQpIHx8IChjb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiICYmIHQgPT09IFwiYXJyYXlcIikpXG4gICAgOiBbXVxufVxuXG5mdW5jdGlvbiBjb2VyY2VEYXRhKGl0OiBTY2hlbWFPYmpDeHQsIHR5cGVzOiBKU09OVHlwZVtdLCBjb2VyY2VUbzogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBvcHRzfSA9IGl0XG4gIGNvbnN0IGRhdGFUeXBlID0gZ2VuLmxldChcImRhdGFUeXBlXCIsIF9gdHlwZW9mICR7ZGF0YX1gKVxuICBjb25zdCBjb2VyY2VkID0gZ2VuLmxldChcImNvZXJjZWRcIiwgX2B1bmRlZmluZWRgKVxuICBpZiAob3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSB7XG4gICAgZ2VuLmlmKF9gJHtkYXRhVHlwZX0gPT0gJ29iamVjdCcgJiYgQXJyYXkuaXNBcnJheSgke2RhdGF9KSAmJiAke2RhdGF9Lmxlbmd0aCA9PSAxYCwgKCkgPT5cbiAgICAgIGdlblxuICAgICAgICAuYXNzaWduKGRhdGEsIF9gJHtkYXRhfVswXWApXG4gICAgICAgIC5hc3NpZ24oZGF0YVR5cGUsIF9gdHlwZW9mICR7ZGF0YX1gKVxuICAgICAgICAuaWYoY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycyksICgpID0+IGdlbi5hc3NpZ24oY29lcmNlZCwgZGF0YSkpXG4gICAgKVxuICB9XG4gIGdlbi5pZihfYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGApXG4gIGZvciAoY29uc3QgdCBvZiBjb2VyY2VUbykge1xuICAgIGlmIChDT0VSQ0lCTEUuaGFzKHQpIHx8ICh0ID09PSBcImFycmF5XCIgJiYgb3B0cy5jb2VyY2VUeXBlcyA9PT0gXCJhcnJheVwiKSkge1xuICAgICAgY29lcmNlU3BlY2lmaWNUeXBlKHQpXG4gICAgfVxuICB9XG4gIGdlbi5lbHNlKClcbiAgcmVwb3J0VHlwZUVycm9yKGl0KVxuICBnZW4uZW5kSWYoKVxuXG4gIGdlbi5pZihfYCR7Y29lcmNlZH0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICBnZW4uYXNzaWduKGRhdGEsIGNvZXJjZWQpXG4gICAgYXNzaWduUGFyZW50RGF0YShpdCwgY29lcmNlZClcbiAgfSlcblxuICBmdW5jdGlvbiBjb2VyY2VTcGVjaWZpY1R5cGUodDogc3RyaW5nKTogdm9pZCB7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGFUeXBlfSA9PSBcIm51bWJlclwiIHx8ICR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gXCJcIiArICR7ZGF0YX1gKVxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gXCJcImApXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKFxuICAgICAgICAgICAgX2Ake2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSlgXG4gICAgICAgICAgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2ArJHtkYXRhfWApXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihcbiAgICAgICAgICAgIF9gJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiICYmICR7ZGF0YX0gJiYgJHtkYXRhfSA9PSArJHtkYXRhfSAmJiAhKCR7ZGF0YX0gJSAxKSlgXG4gICAgICAgICAgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2ArJHtkYXRhfWApXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihfYCR7ZGF0YX0gPT09IFwiZmFsc2VcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgZmFsc2UpXG4gICAgICAgICAgLmVsc2VJZihfYCR7ZGF0YX0gPT09IFwidHJ1ZVwiIHx8ICR7ZGF0YX0gPT09IDFgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgdHJ1ZSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgICBnZW4uZWxzZUlmKF9gJHtkYXRhfSA9PT0gXCJcIiB8fCAke2RhdGF9ID09PSAwIHx8ICR7ZGF0YX0gPT09IGZhbHNlYClcbiAgICAgICAgZ2VuLmFzc2lnbihjb2VyY2VkLCBudWxsKVxuICAgICAgICByZXR1cm5cblxuICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoXG4gICAgICAgICAgICBfYCR7ZGF0YVR5cGV9ID09PSBcInN0cmluZ1wiIHx8ICR7ZGF0YVR5cGV9ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgIHx8ICR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gWyR7ZGF0YX1dYClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUGFyZW50RGF0YSh7Z2VuLCBwYXJlbnREYXRhLCBwYXJlbnREYXRhUHJvcGVydHl9OiBTY2hlbWFPYmpDeHQsIGV4cHI6IE5hbWUpOiB2b2lkIHtcbiAgLy8gVE9ETyB1c2UgZ2VuLnByb3BlcnR5XG4gIGdlbi5pZihfYCR7cGFyZW50RGF0YX0gIT09IHVuZGVmaW5lZGAsICgpID0+XG4gICAgZ2VuLmFzc2lnbihfYCR7cGFyZW50RGF0YX1bJHtwYXJlbnREYXRhUHJvcGVydHl9XWAsIGV4cHIpXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRGF0YVR5cGUoXG4gIGRhdGFUeXBlOiBKU09OVHlwZSxcbiAgZGF0YTogTmFtZSxcbiAgc3RyaWN0TnVtcz86IGJvb2xlYW4gfCBcImxvZ1wiLFxuICBjb3JyZWN0ID0gRGF0YVR5cGUuQ29ycmVjdFxuKTogQ29kZSB7XG4gIGNvbnN0IEVRID0gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IG9wZXJhdG9ycy5FUSA6IG9wZXJhdG9ycy5ORVFcbiAgbGV0IGNvbmQ6IENvZGVcbiAgc3dpdGNoIChkYXRhVHlwZSkge1xuICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICByZXR1cm4gX2Ake2RhdGF9ICR7RVF9IG51bGxgXG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICBjb25kID0gX2BBcnJheS5pc0FycmF5KCR7ZGF0YX0pYFxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICBjb25kID0gX2Ake2RhdGF9ICYmIHR5cGVvZiAke2RhdGF9ID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoJHtkYXRhfSlgXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICBjb25kID0gbnVtQ29uZChfYCEoJHtkYXRhfSAlIDEpICYmICFpc05hTigke2RhdGF9KWApXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGNvbmQgPSBudW1Db25kKClcbiAgICAgIGJyZWFrXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBfYHR5cGVvZiAke2RhdGF9ICR7RVF9ICR7ZGF0YVR5cGV9YFxuICB9XG4gIHJldHVybiBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gY29uZCA6IG5vdChjb25kKVxuXG4gIGZ1bmN0aW9uIG51bUNvbmQoX2NvbmQ6IENvZGUgPSBuaWwpOiBDb2RlIHtcbiAgICByZXR1cm4gYW5kKF9gdHlwZW9mICR7ZGF0YX0gPT0gXCJudW1iZXJcImAsIF9jb25kLCBzdHJpY3ROdW1zID8gX2Bpc0Zpbml0ZSgke2RhdGF9KWAgOiBuaWwpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRGF0YVR5cGVzKFxuICBkYXRhVHlwZXM6IEpTT05UeXBlW10sXG4gIGRhdGE6IE5hbWUsXG4gIHN0cmljdE51bXM/OiBib29sZWFuIHwgXCJsb2dcIixcbiAgY29ycmVjdD86IERhdGFUeXBlXG4pOiBDb2RlIHtcbiAgaWYgKGRhdGFUeXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gY2hlY2tEYXRhVHlwZShkYXRhVHlwZXNbMF0sIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpXG4gIH1cbiAgbGV0IGNvbmQ6IENvZGVcbiAgY29uc3QgdHlwZXMgPSB0b0hhc2goZGF0YVR5cGVzKVxuICBpZiAodHlwZXMuYXJyYXkgJiYgdHlwZXMub2JqZWN0KSB7XG4gICAgY29uc3Qgbm90T2JqID0gX2B0eXBlb2YgJHtkYXRhfSAhPSBcIm9iamVjdFwiYFxuICAgIGNvbmQgPSB0eXBlcy5udWxsID8gbm90T2JqIDogX2AhJHtkYXRhfSB8fCAke25vdE9ian1gXG4gICAgZGVsZXRlIHR5cGVzLm51bGxcbiAgICBkZWxldGUgdHlwZXMuYXJyYXlcbiAgICBkZWxldGUgdHlwZXMub2JqZWN0XG4gIH0gZWxzZSB7XG4gICAgY29uZCA9IG5pbFxuICB9XG4gIGlmICh0eXBlcy5udW1iZXIpIGRlbGV0ZSB0eXBlcy5pbnRlZ2VyXG4gIGZvciAoY29uc3QgdCBpbiB0eXBlcykgY29uZCA9IGFuZChjb25kLCBjaGVja0RhdGFUeXBlKHQgYXMgSlNPTlR5cGUsIGRhdGEsIHN0cmljdE51bXMsIGNvcnJlY3QpKVxuICByZXR1cm4gY29uZFxufVxuXG5leHBvcnQgdHlwZSBUeXBlRXJyb3IgPSBFcnJvck9iamVjdDxcInR5cGVcIiwge3R5cGU6IHN0cmluZ30+XG5cbmNvbnN0IHR5cGVFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWF9KSA9PiBgbXVzdCBiZSAke3NjaGVtYX1gLFxuICBwYXJhbXM6ICh7c2NoZW1hLCBzY2hlbWFWYWx1ZX0pID0+XG4gICAgdHlwZW9mIHNjaGVtYSA9PSBcInN0cmluZ1wiID8gX2B7dHlwZTogJHtzY2hlbWF9fWAgOiBfYHt0eXBlOiAke3NjaGVtYVZhbHVlfX1gLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0VHlwZUVycm9yKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3QgY3h0ID0gZ2V0VHlwZUVycm9yQ29udGV4dChpdClcbiAgcmVwb3J0RXJyb3IoY3h0LCB0eXBlRXJyb3IpXG59XG5cbmZ1bmN0aW9uIGdldFR5cGVFcnJvckNvbnRleHQoaXQ6IFNjaGVtYU9iakN4dCk6IEtleXdvcmRFcnJvckN4dCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIHNjaGVtYX0gPSBpdFxuICBjb25zdCBzY2hlbWFDb2RlID0gc2NoZW1hUmVmT3JWYWwoaXQsIHNjaGVtYSwgXCJ0eXBlXCIpXG4gIHJldHVybiB7XG4gICAgZ2VuLFxuICAgIGtleXdvcmQ6IFwidHlwZVwiLFxuICAgIGRhdGEsXG4gICAgc2NoZW1hOiBzY2hlbWEudHlwZSxcbiAgICBzY2hlbWFDb2RlLFxuICAgIHNjaGVtYVZhbHVlOiBzY2hlbWFDb2RlLFxuICAgIHBhcmVudFNjaGVtYTogc2NoZW1hLFxuICAgIHBhcmFtczoge30sXG4gICAgaXQsXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtfLCBnZXRQcm9wZXJ0eSwgc3RyaW5naWZ5fSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQge2NoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uL3V0aWxcIlxuXG5leHBvcnQgZnVuY3Rpb24gYXNzaWduRGVmYXVsdHMoaXQ6IFNjaGVtYU9iakN4dCwgdHk/OiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qge3Byb3BlcnRpZXMsIGl0ZW1zfSA9IGl0LnNjaGVtYVxuICBpZiAodHkgPT09IFwib2JqZWN0XCIgJiYgcHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGFzc2lnbkRlZmF1bHQoaXQsIGtleSwgcHJvcGVydGllc1trZXldLmRlZmF1bHQpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5ID09PSBcImFycmF5XCIgJiYgQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBpdGVtcy5mb3JFYWNoKChzY2gsIGk6IG51bWJlcikgPT4gYXNzaWduRGVmYXVsdChpdCwgaSwgc2NoLmRlZmF1bHQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkRlZmF1bHQoaXQ6IFNjaGVtYU9iakN4dCwgcHJvcDogc3RyaW5nIHwgbnVtYmVyLCBkZWZhdWx0VmFsdWU6IHVua25vd24pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgY29tcG9zaXRlUnVsZSwgZGF0YSwgb3B0c30gPSBpdFxuICBpZiAoZGVmYXVsdFZhbHVlID09PSB1bmRlZmluZWQpIHJldHVyblxuICBjb25zdCBjaGlsZERhdGEgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHByb3ApfWBcbiAgaWYgKGNvbXBvc2l0ZVJ1bGUpIHtcbiAgICBjaGVja1N0cmljdE1vZGUoaXQsIGBkZWZhdWx0IGlzIGlnbm9yZWQgZm9yOiAke2NoaWxkRGF0YX1gKVxuICAgIHJldHVyblxuICB9XG5cbiAgbGV0IGNvbmRpdGlvbiA9IF9gJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgXG4gIGlmIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIpIHtcbiAgICBjb25kaXRpb24gPSBfYCR7Y29uZGl0aW9ufSB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYFxuICB9XG4gIC8vIGAke2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGAgK1xuICAvLyAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiID8gYCB8fCAke2NoaWxkRGF0YX0gPT09IG51bGwgfHwgJHtjaGlsZERhdGF9ID09PSBcIlwiYCA6IFwiXCIpXG4gIGdlbi5pZihjb25kaXRpb24sIF9gJHtjaGlsZERhdGF9ID0gJHtzdHJpbmdpZnkoZGVmYXVsdFZhbHVlKX1gKVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWEsIFNjaGVtYU1hcH0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHR9IGZyb20gXCIuLi9jb21waWxlXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge0NvZGVHZW4sIF8sIGFuZCwgb3IsIG5vdCwgbmlsLCBzdHJDb25jYXQsIGdldFByb3BlcnR5LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIFR5cGV9IGZyb20gXCIuLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IE4gZnJvbSBcIi4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vY29tcGlsZS91dGlsXCJcbmV4cG9ydCBmdW5jdGlvbiBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dDogS2V5d29yZEN4dCwgcHJvcDogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGl0fSA9IGN4dFxuICBnZW4uaWYobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksICgpID0+IHtcbiAgICBjeHQuc2V0UGFyYW1zKHttaXNzaW5nUHJvcGVydHk6IF9gJHtwcm9wfWB9LCB0cnVlKVxuICAgIGN4dC5lcnJvcigpXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja01pc3NpbmdQcm9wKFxuICB7Z2VuLCBkYXRhLCBpdDoge29wdHN9fTogS2V5d29yZEN4dCxcbiAgcHJvcGVydGllczogc3RyaW5nW10sXG4gIG1pc3Npbmc6IE5hbWVcbik6IENvZGUge1xuICByZXR1cm4gb3IoXG4gICAgLi4ucHJvcGVydGllcy5tYXAoKHByb3ApID0+XG4gICAgICBhbmQobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksIF9gJHttaXNzaW5nfSA9ICR7cHJvcH1gKVxuICAgIClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0TWlzc2luZ1Byb3AoY3h0OiBLZXl3b3JkQ3h0LCBtaXNzaW5nOiBOYW1lKTogdm9pZCB7XG4gIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogbWlzc2luZ30sIHRydWUpXG4gIGN4dC5lcnJvcigpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNQcm9wRnVuYyhnZW46IENvZGVHZW4pOiBOYW1lIHtcbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgIHJlZjogT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICBjb2RlOiBfYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNPd25Qcm9wZXJ0eShnZW46IENvZGVHZW4sIGRhdGE6IE5hbWUsIHByb3BlcnR5OiBOYW1lIHwgc3RyaW5nKTogQ29kZSB7XG4gIHJldHVybiBfYCR7aGFzUHJvcEZ1bmMoZ2VuKX0uY2FsbCgke2RhdGF9LCAke3Byb3BlcnR5fSlgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9wZXJ0eUluRGF0YShcbiAgZ2VuOiBDb2RlR2VuLFxuICBkYXRhOiBOYW1lLFxuICBwcm9wZXJ0eTogTmFtZSB8IHN0cmluZyxcbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbik6IENvZGUge1xuICBjb25zdCBjb25kID0gX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eShwcm9wZXJ0eSl9ICE9PSB1bmRlZmluZWRgXG4gIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gX2Ake2NvbmR9ICYmICR7aXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KX1gIDogY29uZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm9Qcm9wZXJ0eUluRGF0YShcbiAgZ2VuOiBDb2RlR2VuLFxuICBkYXRhOiBOYW1lLFxuICBwcm9wZXJ0eTogTmFtZSB8IHN0cmluZyxcbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbik6IENvZGUge1xuICBjb25zdCBjb25kID0gX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eShwcm9wZXJ0eSl9ID09PSB1bmRlZmluZWRgXG4gIHJldHVybiBvd25Qcm9wZXJ0aWVzID8gb3IoY29uZCwgbm90KGlzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSkpKSA6IGNvbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwPzogU2NoZW1hTWFwKTogc3RyaW5nW10ge1xuICByZXR1cm4gc2NoZW1hTWFwID8gT2JqZWN0LmtleXMoc2NoZW1hTWFwKS5maWx0ZXIoKHApID0+IHAgIT09IFwiX19wcm90b19fXCIpIDogW11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYVByb3BlcnRpZXMoaXQ6IFNjaGVtYUN4dCwgc2NoZW1hTWFwOiBTY2hlbWFNYXApOiBzdHJpbmdbXSB7XG4gIHJldHVybiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcCkuZmlsdGVyKFxuICAgIChwKSA9PiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYU1hcFtwXSBhcyBBbnlTY2hlbWEpXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZUNvZGUoXG4gIHtzY2hlbWFDb2RlLCBkYXRhLCBpdDoge2dlbiwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRoLCBlcnJvclBhdGh9LCBpdH06IEtleXdvcmRDeHQsXG4gIGZ1bmM6IENvZGUsXG4gIGNvbnRleHQ6IENvZGUsXG4gIHBhc3NTY2hlbWE/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgZGF0YUFuZFNjaGVtYSA9IHBhc3NTY2hlbWEgPyBfYCR7c2NoZW1hQ29kZX0sICR7ZGF0YX0sICR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gIDogZGF0YVxuICBjb25zdCB2YWxDeHQ6IFtOYW1lLCBDb2RlIHwgbnVtYmVyXVtdID0gW1xuICAgIFtOLmluc3RhbmNlUGF0aCwgc3RyQ29uY2F0KE4uaW5zdGFuY2VQYXRoLCBlcnJvclBhdGgpXSxcbiAgICBbTi5wYXJlbnREYXRhLCBpdC5wYXJlbnREYXRhXSxcbiAgICBbTi5wYXJlbnREYXRhUHJvcGVydHksIGl0LnBhcmVudERhdGFQcm9wZXJ0eV0sXG4gICAgW04ucm9vdERhdGEsIE4ucm9vdERhdGFdLFxuICBdXG4gIGlmIChpdC5vcHRzLmR5bmFtaWNSZWYpIHZhbEN4dC5wdXNoKFtOLmR5bmFtaWNBbmNob3JzLCBOLmR5bmFtaWNBbmNob3JzXSlcbiAgY29uc3QgYXJncyA9IF9gJHtkYXRhQW5kU2NoZW1hfSwgJHtnZW4ub2JqZWN0KC4uLnZhbEN4dCl9YFxuICByZXR1cm4gY29udGV4dCAhPT0gbmlsID8gX2Ake2Z1bmN9LmNhbGwoJHtjb250ZXh0fSwgJHthcmdzfSlgIDogX2Ake2Z1bmN9KCR7YXJnc30pYFxufVxuXG5jb25zdCBuZXdSZWdFeHAgPSBfYG5ldyBSZWdFeHBgXG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQYXR0ZXJuKHtnZW4sIGl0OiB7b3B0c319OiBLZXl3b3JkQ3h0LCBwYXR0ZXJuOiBzdHJpbmcpOiBOYW1lIHtcbiAgY29uc3QgdSA9IG9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIlxuICBjb25zdCB7cmVnRXhwfSA9IG9wdHMuY29kZVxuICBjb25zdCByeCA9IHJlZ0V4cChwYXR0ZXJuLCB1KVxuXG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcInBhdHRlcm5cIiwge1xuICAgIGtleTogcngudG9TdHJpbmcoKSxcbiAgICByZWY6IHJ4LFxuICAgIGNvZGU6IF9gJHtyZWdFeHAuY29kZSA9PT0gXCJuZXcgUmVnRXhwXCIgPyBuZXdSZWdFeHAgOiB1c2VGdW5jKGdlbiwgcmVnRXhwKX0oJHtwYXR0ZXJufSwgJHt1fSlgLFxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBcnJheShjeHQ6IEtleXdvcmRDeHQpOiBOYW1lIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgY29uc3QgdmFsaWRBcnIgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSlcbiAgICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5hc3NpZ24odmFsaWRBcnIsIGZhbHNlKSlcbiAgICByZXR1cm4gdmFsaWRBcnJcbiAgfVxuICBnZW4udmFyKHZhbGlkLCB0cnVlKVxuICB2YWxpZGF0ZUl0ZW1zKCgpID0+IGdlbi5icmVhaygpKVxuICByZXR1cm4gdmFsaWRcblxuICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKG5vdFZhbGlkOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLk51bSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICAgIGdlbi5pZihub3QodmFsaWQpLCBub3RWYWxpZClcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVVuaW9uKGN4dDogS2V5d29yZEN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICBjb25zdCBhbHdheXNWYWxpZCA9IHNjaGVtYS5zb21lKChzY2g6IEFueVNjaGVtYSkgPT4gYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpXG4gIGlmIChhbHdheXNWYWxpZCAmJiAhaXQub3B0cy51bmV2YWx1YXRlZCkgcmV0dXJuXG5cbiAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpXG4gIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcblxuICBnZW4uYmxvY2soKCkgPT5cbiAgICBzY2hlbWEuZm9yRWFjaCgoX3NjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgc2NoVmFsaWRcbiAgICAgIClcbiAgICAgIGdlbi5hc3NpZ24odmFsaWQsIF9gJHt2YWxpZH0gfHwgJHtzY2hWYWxpZH1gKVxuICAgICAgY29uc3QgbWVyZ2VkID0gY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCBzY2hWYWxpZClcbiAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXMvSXRlbXNgIG5vdCBzdXBwb3J0ZWQgKG9wdHMudW5ldmFsdWF0ZWQgIT09IHRydWUpXG4gICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyBhbmQgaXRlbXMgd2VyZSBldmFsdWF0ZWQgKGl0LnByb3BzID09PSB0cnVlICYmIGl0Lml0ZW1zID09PSB0cnVlKVxuICAgICAgaWYgKCFtZXJnZWQpIGdlbi5pZihub3QodmFsaWQpKVxuICAgIH0pXG4gIClcblxuICBjeHQucmVzdWx0KFxuICAgIHZhbGlkLFxuICAgICgpID0+IGN4dC5yZXNldCgpLFxuICAgICgpID0+IGN4dC5lcnJvcih0cnVlKVxuICApXG59XG4iLCAiaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuXCJcbmltcG9ydCB0eXBlIHtcbiAgQW55U2NoZW1hLFxuICBTY2hlbWFWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBNYWNyb0tleXdvcmREZWZpbml0aW9uLFxuICBGdW5jS2V5d29yZERlZmluaXRpb24sXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtfLCBuaWwsIG5vdCwgc3RyaW5naWZ5LCBDb2RlLCBOYW1lLCBDb2RlR2VufSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vbmFtZXNcIlxuaW1wb3J0IHR5cGUge0pTT05UeXBlfSBmcm9tIFwiLi4vcnVsZXNcIlxuaW1wb3J0IHtjYWxsVmFsaWRhdGVDb2RlfSBmcm9tIFwiLi4vLi4vdm9jYWJ1bGFyaWVzL2NvZGVcIlxuaW1wb3J0IHtleHRlbmRFcnJvcnN9IGZyb20gXCIuLi9lcnJvcnNcIlxuXG50eXBlIEtleXdvcmRDb21waWxhdGlvblJlc3VsdCA9IEFueVNjaGVtYSB8IFNjaGVtYVZhbGlkYXRlRnVuY3Rpb24gfCBBbnlWYWxpZGF0ZUZ1bmN0aW9uXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWNyb0tleXdvcmRDb2RlKGN4dDogS2V5d29yZEN4dCwgZGVmOiBNYWNyb0tleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgY29uc3QgbWFjcm9TY2hlbWEgPSBkZWYubWFjcm8uY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpXG4gIGNvbnN0IHNjaGVtYVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCBtYWNyb1NjaGVtYSlcbiAgaWYgKGl0Lm9wdHMudmFsaWRhdGVTY2hlbWEgIT09IGZhbHNlKSBpdC5zZWxmLnZhbGlkYXRlU2NoZW1hKG1hY3JvU2NoZW1hLCB0cnVlKVxuXG4gIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICBjeHQuc3Vic2NoZW1hKFxuICAgIHtcbiAgICAgIHNjaGVtYTogbWFjcm9TY2hlbWEsXG4gICAgICBzY2hlbWFQYXRoOiBuaWwsXG4gICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgIHRvcFNjaGVtYVJlZjogc2NoZW1hUmVmLFxuICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICB9LFxuICAgIHZhbGlkXG4gIClcbiAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1bmNLZXl3b3JkQ29kZShjeHQ6IEtleXdvcmRDeHQsIGRlZjogRnVuY0tleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGtleXdvcmQsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCAkZGF0YSwgaXR9ID0gY3h0XG4gIGNoZWNrQXN5bmNLZXl3b3JkKGl0LCBkZWYpXG4gIGNvbnN0IHZhbGlkYXRlID1cbiAgICAhJGRhdGEgJiYgZGVmLmNvbXBpbGUgPyBkZWYuY29tcGlsZS5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdCkgOiBkZWYudmFsaWRhdGVcbiAgY29uc3QgdmFsaWRhdGVSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgdmFsaWRhdGUpXG4gIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpXG4gIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZUtleXdvcmQpXG4gIGN4dC5vayhkZWYudmFsaWQgPz8gdmFsaWQpXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkKCk6IHZvaWQge1xuICAgIGlmIChkZWYuZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgYXNzaWduVmFsaWQoKVxuICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpIG1vZGlmeURhdGEoY3h0KVxuICAgICAgcmVwb3J0RXJycygoKSA9PiBjeHQuZXJyb3IoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcnVsZUVycnMgPSBkZWYuYXN5bmMgPyB2YWxpZGF0ZUFzeW5jKCkgOiB2YWxpZGF0ZVN5bmMoKVxuICAgICAgaWYgKGRlZi5tb2RpZnlpbmcpIG1vZGlmeURhdGEoY3h0KVxuICAgICAgcmVwb3J0RXJycygoKSA9PiBhZGRFcnJzKGN4dCwgcnVsZUVycnMpKVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlQXN5bmMoKTogTmFtZSB7XG4gICAgY29uc3QgcnVsZUVycnMgPSBnZW4ubGV0KFwicnVsZUVycnNcIiwgbnVsbClcbiAgICBnZW4udHJ5KFxuICAgICAgKCkgPT4gYXNzaWduVmFsaWQoX2Bhd2FpdCBgKSxcbiAgICAgIChlKSA9PlxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuaWYoXG4gICAgICAgICAgX2Ake2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX1gLFxuICAgICAgICAgICgpID0+IGdlbi5hc3NpZ24ocnVsZUVycnMsIF9gJHtlfS5lcnJvcnNgKSxcbiAgICAgICAgICAoKSA9PiBnZW4udGhyb3coZSlcbiAgICAgICAgKVxuICAgIClcbiAgICByZXR1cm4gcnVsZUVycnNcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlU3luYygpOiBDb2RlIHtcbiAgICBjb25zdCB2YWxpZGF0ZUVycnMgPSBfYCR7dmFsaWRhdGVSZWZ9LmVycm9yc2BcbiAgICBnZW4uYXNzaWduKHZhbGlkYXRlRXJycywgbnVsbClcbiAgICBhc3NpZ25WYWxpZChuaWwpXG4gICAgcmV0dXJuIHZhbGlkYXRlRXJyc1xuICB9XG5cbiAgZnVuY3Rpb24gYXNzaWduVmFsaWQoX2F3YWl0OiBDb2RlID0gZGVmLmFzeW5jID8gX2Bhd2FpdCBgIDogbmlsKTogdm9pZCB7XG4gICAgY29uc3QgcGFzc0N4dCA9IGl0Lm9wdHMucGFzc0NvbnRleHQgPyBOLnRoaXMgOiBOLnNlbGZcbiAgICBjb25zdCBwYXNzU2NoZW1hID0gISgoXCJjb21waWxlXCIgaW4gZGVmICYmICEkZGF0YSkgfHwgZGVmLnNjaGVtYSA9PT0gZmFsc2UpXG4gICAgZ2VuLmFzc2lnbihcbiAgICAgIHZhbGlkLFxuICAgICAgX2Ake19hd2FpdH0ke2NhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2YWxpZGF0ZVJlZiwgcGFzc0N4dCwgcGFzc1NjaGVtYSl9YCxcbiAgICAgIGRlZi5tb2RpZnlpbmdcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiByZXBvcnRFcnJzKGVycm9yczogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGdlbi5pZihub3QoZGVmLnZhbGlkID8/IHZhbGlkKSwgZXJyb3JzKVxuICB9XG59XG5cbmZ1bmN0aW9uIG1vZGlmeURhdGEoY3h0OiBLZXl3b3JkQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGl0fSA9IGN4dFxuICBnZW4uaWYoaXQucGFyZW50RGF0YSwgKCkgPT4gZ2VuLmFzc2lnbihkYXRhLCBfYCR7aXQucGFyZW50RGF0YX1bJHtpdC5wYXJlbnREYXRhUHJvcGVydHl9XWApKVxufVxuXG5mdW5jdGlvbiBhZGRFcnJzKGN4dDogS2V5d29yZEN4dCwgZXJyczogQ29kZSk6IHZvaWQge1xuICBjb25zdCB7Z2VufSA9IGN4dFxuICBnZW4uaWYoXG4gICAgX2BBcnJheS5pc0FycmF5KCR7ZXJyc30pYCxcbiAgICAoKSA9PiB7XG4gICAgICBnZW5cbiAgICAgICAgLmFzc2lnbihOLnZFcnJvcnMsIF9gJHtOLnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7Ti52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKVxuICAgICAgICAuYXNzaWduKE4uZXJyb3JzLCBfYCR7Ti52RXJyb3JzfS5sZW5ndGhgKVxuICAgICAgZXh0ZW5kRXJyb3JzKGN4dClcbiAgICB9LFxuICAgICgpID0+IGN4dC5lcnJvcigpXG4gIClcbn1cblxuZnVuY3Rpb24gY2hlY2tBc3luY0tleXdvcmQoe3NjaGVtYUVudn06IFNjaGVtYU9iakN4dCwgZGVmOiBGdW5jS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgaWYgKGRlZi5hc3luYyAmJiAhc2NoZW1hRW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMga2V5d29yZCBpbiBzeW5jIHNjaGVtYVwiKVxufVxuXG5mdW5jdGlvbiB1c2VLZXl3b3JkKGdlbjogQ29kZUdlbiwga2V5d29yZDogc3RyaW5nLCByZXN1bHQ/OiBLZXl3b3JkQ29tcGlsYXRpb25SZXN1bHQpOiBOYW1lIHtcbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYGtleXdvcmQgXCIke2tleXdvcmR9XCIgZmFpbGVkIHRvIGNvbXBpbGVgKVxuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXG4gICAgXCJrZXl3b3JkXCIsXG4gICAgdHlwZW9mIHJlc3VsdCA9PSBcImZ1bmN0aW9uXCIgPyB7cmVmOiByZXN1bHR9IDoge3JlZjogcmVzdWx0LCBjb2RlOiBzdHJpbmdpZnkocmVzdWx0KX1cbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRTY2hlbWFUeXBlKFxuICBzY2hlbWE6IHVua25vd24sXG4gIHNjaGVtYVR5cGU6IEpTT05UeXBlW10sXG4gIGFsbG93VW5kZWZpbmVkID0gZmFsc2Vcbik6IGJvb2xlYW4ge1xuICAvLyBUT0RPIGFkZCB0ZXN0c1xuICByZXR1cm4gKFxuICAgICFzY2hlbWFUeXBlLmxlbmd0aCB8fFxuICAgIHNjaGVtYVR5cGUuc29tZSgoc3QpID0+XG4gICAgICBzdCA9PT0gXCJhcnJheVwiXG4gICAgICAgID8gQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgIDogc3QgPT09IFwib2JqZWN0XCJcbiAgICAgICAgPyBzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgOiB0eXBlb2Ygc2NoZW1hID09IHN0IHx8IChhbGxvd1VuZGVmaW5lZCAmJiB0eXBlb2Ygc2NoZW1hID09IFwidW5kZWZpbmVkXCIpXG4gICAgKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmRVc2FnZShcbiAge3NjaGVtYSwgb3B0cywgc2VsZiwgZXJyU2NoZW1hUGF0aH06IFNjaGVtYU9iakN4dCxcbiAgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBrZXl3b3JkOiBzdHJpbmdcbik6IHZvaWQge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmLmtleXdvcmQpID8gIWRlZi5rZXl3b3JkLmluY2x1ZGVzKGtleXdvcmQpIDogZGVmLmtleXdvcmQgIT09IGtleXdvcmQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgfVxuXG4gIGNvbnN0IGRlcHMgPSBkZWYuZGVwZW5kZW5jaWVzXG4gIGlmIChkZXBzPy5zb21lKChrd2QpID0+ICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2NoZW1hLCBrd2QpKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgcGFyZW50IHNjaGVtYSBtdXN0IGhhdmUgZGVwZW5kZW5jaWVzIG9mICR7a2V5d29yZH06ICR7ZGVwcy5qb2luKFwiLFwiKX1gKVxuICB9XG5cbiAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgIGNvbnN0IHZhbGlkID0gZGVmLnZhbGlkYXRlU2NoZW1hKHNjaGVtYVtrZXl3b3JkXSlcbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICBjb25zdCBtc2cgPVxuICAgICAgICBga2V5d29yZCBcIiR7a2V5d29yZH1cIiB2YWx1ZSBpcyBpbnZhbGlkIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCI6IGAgK1xuICAgICAgICBzZWxmLmVycm9yc1RleHQoZGVmLnZhbGlkYXRlU2NoZW1hLmVycm9ycylcbiAgICAgIGlmIChvcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKSBzZWxmLmxvZ2dlci5lcnJvcihtc2cpXG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihtc2cpXG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge18sIHN0ciwgZ2V0UHJvcGVydHksIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7ZXNjYXBlRnJhZ21lbnQsIGdldEVycm9yUGF0aCwgVHlwZX0gZnJvbSBcIi4uL3V0aWxcIlxuaW1wb3J0IHR5cGUge0pTT05UeXBlfSBmcm9tIFwiLi4vcnVsZXNcIlxuXG5leHBvcnQgaW50ZXJmYWNlIFN1YnNjaGVtYUNvbnRleHQge1xuICAvLyBUT0RPIHVzZSBPcHRpb25hbD8gYWxpZ24gd2l0aCBTY2hlbUN4dCBwcm9wZXJ0eSB0eXBlc1xuICBzY2hlbWE6IEFueVNjaGVtYVxuICBzY2hlbWFQYXRoOiBDb2RlXG4gIGVyclNjaGVtYVBhdGg6IHN0cmluZ1xuICB0b3BTY2hlbWFSZWY/OiBDb2RlXG4gIGVycm9yUGF0aD86IENvZGVcbiAgZGF0YUxldmVsPzogbnVtYmVyXG4gIGRhdGFUeXBlcz86IEpTT05UeXBlW11cbiAgZGF0YT86IE5hbWVcbiAgcGFyZW50RGF0YT86IE5hbWVcbiAgcGFyZW50RGF0YVByb3BlcnR5PzogQ29kZSB8IG51bWJlclxuICBkYXRhTmFtZXM/OiBOYW1lW11cbiAgZGF0YVBhdGhBcnI/OiAoQ29kZSB8IG51bWJlcilbXVxuICBwcm9wZXJ0eU5hbWU/OiBOYW1lXG4gIGp0ZERpc2NyaW1pbmF0b3I/OiBzdHJpbmdcbiAganRkTWV0YWRhdGE/OiBib29sZWFuXG4gIGNvbXBvc2l0ZVJ1bGU/OiB0cnVlXG4gIGNyZWF0ZUVycm9ycz86IGJvb2xlYW5cbiAgYWxsRXJyb3JzPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBTdWJzY2hlbWFBcmdzID0gUGFydGlhbDx7XG4gIGtleXdvcmQ6IHN0cmluZ1xuICBzY2hlbWFQcm9wOiBzdHJpbmcgfCBudW1iZXJcbiAgc2NoZW1hOiBBbnlTY2hlbWFcbiAgc2NoZW1hUGF0aDogQ29kZVxuICBlcnJTY2hlbWFQYXRoOiBzdHJpbmdcbiAgdG9wU2NoZW1hUmVmOiBDb2RlXG4gIGRhdGE6IE5hbWUgfCBDb2RlXG4gIGRhdGFQcm9wOiBDb2RlIHwgc3RyaW5nIHwgbnVtYmVyXG4gIGRhdGFUeXBlczogSlNPTlR5cGVbXVxuICBkZWZpbmVkUHJvcGVydGllczogU2V0PHN0cmluZz5cbiAgcHJvcGVydHlOYW1lOiBOYW1lXG4gIGRhdGFQcm9wVHlwZTogVHlwZVxuICBqdGREaXNjcmltaW5hdG9yOiBzdHJpbmdcbiAganRkTWV0YWRhdGE6IGJvb2xlYW5cbiAgY29tcG9zaXRlUnVsZTogdHJ1ZVxuICBjcmVhdGVFcnJvcnM6IGJvb2xlYW5cbiAgYWxsRXJyb3JzOiBib29sZWFuXG59PlxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3Vic2NoZW1hKFxuICBpdDogU2NoZW1hT2JqQ3h0LFxuICB7a2V5d29yZCwgc2NoZW1hUHJvcCwgc2NoZW1hLCBzY2hlbWFQYXRoLCBlcnJTY2hlbWFQYXRoLCB0b3BTY2hlbWFSZWZ9OiBTdWJzY2hlbWFBcmdzXG4pOiBTdWJzY2hlbWFDb250ZXh0IHtcbiAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCAmJiBzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImtleXdvcmRcIiBhbmQgXCJzY2hlbWFcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKVxuICB9XG5cbiAgaWYgKGtleXdvcmQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNjaCA9IGl0LnNjaGVtYVtrZXl3b3JkXVxuICAgIHJldHVybiBzY2hlbWFQcm9wID09PSB1bmRlZmluZWRcbiAgICAgID8ge1xuICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IF9gJHtpdC5zY2hlbWFQYXRofSR7Z2V0UHJvcGVydHkoa2V5d29yZCl9YCxcbiAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YCxcbiAgICAgICAgfVxuICAgICAgOiB7XG4gICAgICAgICAgc2NoZW1hOiBzY2hbc2NoZW1hUHJvcF0sXG4gICAgICAgICAgc2NoZW1hUGF0aDogX2Ake2l0LnNjaGVtYVBhdGh9JHtnZXRQcm9wZXJ0eShrZXl3b3JkKX0ke2dldFByb3BlcnR5KHNjaGVtYVByb3ApfWAsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfS8ke2VzY2FwZUZyYWdtZW50KHNjaGVtYVByb3ApfWAsXG4gICAgICAgIH1cbiAgfVxuXG4gIGlmIChzY2hlbWEgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChzY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgZXJyU2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IHRvcFNjaGVtYVJlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wic2NoZW1hUGF0aFwiLCBcImVyclNjaGVtYVBhdGhcIiBhbmQgXCJ0b3BTY2hlbWFSZWZcIiBhcmUgcmVxdWlyZWQgd2l0aCBcInNjaGVtYVwiJylcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjaGVtYSxcbiAgICAgIHNjaGVtYVBhdGgsXG4gICAgICB0b3BTY2hlbWFSZWYsXG4gICAgICBlcnJTY2hlbWFQYXRoLFxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcignZWl0aGVyIFwia2V5d29yZFwiIG9yIFwic2NoZW1hXCIgbXVzdCBiZSBwYXNzZWQnKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hRGF0YShcbiAgc3Vic2NoZW1hOiBTdWJzY2hlbWFDb250ZXh0LFxuICBpdDogU2NoZW1hT2JqQ3h0LFxuICB7ZGF0YVByb3AsIGRhdGFQcm9wVHlwZTogZHBUeXBlLCBkYXRhLCBkYXRhVHlwZXMsIHByb3BlcnR5TmFtZX06IFN1YnNjaGVtYUFyZ3Ncbik6IHZvaWQge1xuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkICYmIGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJkYXRhXCIgYW5kIFwiZGF0YVByb3BcIiBwYXNzZWQsIG9ubHkgb25lIGFsbG93ZWQnKVxuICB9XG5cbiAgY29uc3Qge2dlbn0gPSBpdFxuXG4gIGlmIChkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qge2Vycm9yUGF0aCwgZGF0YVBhdGhBcnIsIG9wdHN9ID0gaXRcbiAgICBjb25zdCBuZXh0RGF0YSA9IGdlbi5sZXQoXCJkYXRhXCIsIF9gJHtpdC5kYXRhfSR7Z2V0UHJvcGVydHkoZGF0YVByb3ApfWAsIHRydWUpXG4gICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSlcbiAgICBzdWJzY2hlbWEuZXJyb3JQYXRoID0gc3RyYCR7ZXJyb3JQYXRofSR7Z2V0RXJyb3JQYXRoKGRhdGFQcm9wLCBkcFR5cGUsIG9wdHMuanNQcm9wZXJ0eVN5bnRheCl9YFxuICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHkgPSBfYCR7ZGF0YVByb3B9YFxuICAgIHN1YnNjaGVtYS5kYXRhUGF0aEFyciA9IFsuLi5kYXRhUGF0aEFyciwgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eV1cbiAgfVxuXG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBuZXh0RGF0YSA9IGRhdGEgaW5zdGFuY2VvZiBOYW1lID8gZGF0YSA6IGdlbi5sZXQoXCJkYXRhXCIsIGRhdGEsIHRydWUpIC8vIHJlcGxhY2VhYmxlIGlmIHVzZWQgb25jZT9cbiAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKVxuICAgIGlmIChwcm9wZXJ0eU5hbWUgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLnByb3BlcnR5TmFtZSA9IHByb3BlcnR5TmFtZVxuICAgIC8vIFRPRE8gc29tZXRoaW5nIGlzIHBvc3NpYmx5IHdyb25nIGhlcmUgd2l0aCBub3QgY2hhbmdpbmcgcGFyZW50RGF0YVByb3BlcnR5IGFuZCBub3QgYXBwZW5kaW5nIGRhdGFQYXRoQXJyXG4gIH1cblxuICBpZiAoZGF0YVR5cGVzKSBzdWJzY2hlbWEuZGF0YVR5cGVzID0gZGF0YVR5cGVzXG5cbiAgZnVuY3Rpb24gZGF0YUNvbnRleHRQcm9wcyhfbmV4dERhdGE6IE5hbWUpOiB2b2lkIHtcbiAgICBzdWJzY2hlbWEuZGF0YSA9IF9uZXh0RGF0YVxuICAgIHN1YnNjaGVtYS5kYXRhTGV2ZWwgPSBpdC5kYXRhTGV2ZWwgKyAxXG4gICAgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IFtdXG4gICAgaXQuZGVmaW5lZFByb3BlcnRpZXMgPSBuZXcgU2V0PHN0cmluZz4oKVxuICAgIHN1YnNjaGVtYS5wYXJlbnREYXRhID0gaXQuZGF0YVxuICAgIHN1YnNjaGVtYS5kYXRhTmFtZXMgPSBbLi4uaXQuZGF0YU5hbWVzLCBfbmV4dERhdGFdXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYU1vZGUoXG4gIHN1YnNjaGVtYTogU3Vic2NoZW1hQ29udGV4dCxcbiAge2p0ZERpc2NyaW1pbmF0b3IsIGp0ZE1ldGFkYXRhLCBjb21wb3NpdGVSdWxlLCBjcmVhdGVFcnJvcnMsIGFsbEVycm9yc306IFN1YnNjaGVtYUFyZ3Ncbik6IHZvaWQge1xuICBpZiAoY29tcG9zaXRlUnVsZSAhPT0gdW5kZWZpbmVkKSBzdWJzY2hlbWEuY29tcG9zaXRlUnVsZSA9IGNvbXBvc2l0ZVJ1bGVcbiAgaWYgKGNyZWF0ZUVycm9ycyAhPT0gdW5kZWZpbmVkKSBzdWJzY2hlbWEuY3JlYXRlRXJyb3JzID0gY3JlYXRlRXJyb3JzXG4gIGlmIChhbGxFcnJvcnMgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmFsbEVycm9ycyA9IGFsbEVycm9yc1xuICBzdWJzY2hlbWEuanRkRGlzY3JpbWluYXRvciA9IGp0ZERpc2NyaW1pbmF0b3IgLy8gbm90IGluaGVyaXRlZFxuICBzdWJzY2hlbWEuanRkTWV0YWRhdGEgPSBqdGRNZXRhZGF0YSAvLyBub3QgaW5oZXJpdGVkXG59XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkbyBub3QgZWRpdCAuanMgZmlsZXMgZGlyZWN0bHkgLSBlZGl0IHNyYy9pbmRleC5qc3RcblxuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZXF1YWwoYSwgYikge1xuICBpZiAoYSA9PT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgJiYgYiAmJiB0eXBlb2YgYSA9PSAnb2JqZWN0JyAmJiB0eXBlb2YgYiA9PSAnb2JqZWN0Jykge1xuICAgIGlmIChhLmNvbnN0cnVjdG9yICE9PSBiLmNvbnN0cnVjdG9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgbGVuZ3RoLCBpLCBrZXlzO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT0gYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgICAgaWYgKCFlcXVhbChhW2ldLCBiW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG5cblxuICAgIGlmIChhLmNvbnN0cnVjdG9yID09PSBSZWdFeHApIHJldHVybiBhLnNvdXJjZSA9PT0gYi5zb3VyY2UgJiYgYS5mbGFncyA9PT0gYi5mbGFncztcbiAgICBpZiAoYS52YWx1ZU9mICE9PSBPYmplY3QucHJvdG90eXBlLnZhbHVlT2YpIHJldHVybiBhLnZhbHVlT2YoKSA9PT0gYi52YWx1ZU9mKCk7XG4gICAgaWYgKGEudG9TdHJpbmcgIT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHJldHVybiBhLnRvU3RyaW5nKCkgPT09IGIudG9TdHJpbmcoKTtcblxuICAgIGtleXMgPSBPYmplY3Qua2V5cyhhKTtcbiAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhiKS5sZW5ndGgpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOylcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleXNbaV0pKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoIWVxdWFsKGFba2V5XSwgYltrZXldKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLy8gdHJ1ZSBpZiBib3RoIE5hTiwgZmFsc2Ugb3RoZXJ3aXNlXG4gIHJldHVybiBhIT09YSAmJiBiIT09Yjtcbn07XG4iLCAiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzY2hlbWEsIG9wdHMsIGNiKSB7XG4gIC8vIExlZ2FjeSBzdXBwb3J0IGZvciB2MC4zLjEgYW5kIGVhcmxpZXIuXG4gIGlmICh0eXBlb2Ygb3B0cyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuXG4gIGNiID0gb3B0cy5jYiB8fCBjYjtcbiAgdmFyIHByZSA9ICh0eXBlb2YgY2IgPT0gJ2Z1bmN0aW9uJykgPyBjYiA6IGNiLnByZSB8fCBmdW5jdGlvbigpIHt9O1xuICB2YXIgcG9zdCA9IGNiLnBvc3QgfHwgZnVuY3Rpb24oKSB7fTtcblxuICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsICcnLCBzY2hlbWEpO1xufTtcblxuXG50cmF2ZXJzZS5rZXl3b3JkcyA9IHtcbiAgYWRkaXRpb25hbEl0ZW1zOiB0cnVlLFxuICBpdGVtczogdHJ1ZSxcbiAgY29udGFpbnM6IHRydWUsXG4gIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICBwcm9wZXJ0eU5hbWVzOiB0cnVlLFxuICBub3Q6IHRydWUsXG4gIGlmOiB0cnVlLFxuICB0aGVuOiB0cnVlLFxuICBlbHNlOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5hcnJheUtleXdvcmRzID0ge1xuICBpdGVtczogdHJ1ZSxcbiAgYWxsT2Y6IHRydWUsXG4gIGFueU9mOiB0cnVlLFxuICBvbmVPZjogdHJ1ZVxufTtcblxudHJhdmVyc2UucHJvcHNLZXl3b3JkcyA9IHtcbiAgJGRlZnM6IHRydWUsXG4gIGRlZmluaXRpb25zOiB0cnVlLFxuICBwcm9wZXJ0aWVzOiB0cnVlLFxuICBwYXR0ZXJuUHJvcGVydGllczogdHJ1ZSxcbiAgZGVwZW5kZW5jaWVzOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5za2lwS2V5d29yZHMgPSB7XG4gIGRlZmF1bHQ6IHRydWUsXG4gIGVudW06IHRydWUsXG4gIGNvbnN0OiB0cnVlLFxuICByZXF1aXJlZDogdHJ1ZSxcbiAgbWF4aW11bTogdHJ1ZSxcbiAgbWluaW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWF4aW11bTogdHJ1ZSxcbiAgZXhjbHVzaXZlTWluaW11bTogdHJ1ZSxcbiAgbXVsdGlwbGVPZjogdHJ1ZSxcbiAgbWF4TGVuZ3RoOiB0cnVlLFxuICBtaW5MZW5ndGg6IHRydWUsXG4gIHBhdHRlcm46IHRydWUsXG4gIGZvcm1hdDogdHJ1ZSxcbiAgbWF4SXRlbXM6IHRydWUsXG4gIG1pbkl0ZW1zOiB0cnVlLFxuICB1bmlxdWVJdGVtczogdHJ1ZSxcbiAgbWF4UHJvcGVydGllczogdHJ1ZSxcbiAgbWluUHJvcGVydGllczogdHJ1ZVxufTtcblxuXG5mdW5jdGlvbiBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpIHtcbiAgaWYgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICBwcmUoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICB2YXIgc2NoID0gc2NoZW1hW2tleV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpKSB7XG4gICAgICAgIGlmIChrZXkgaW4gdHJhdmVyc2UuYXJyYXlLZXl3b3Jkcykge1xuICAgICAgICAgIGZvciAodmFyIGk9MDsgaTxzY2gubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbaV0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBpLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgaSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLnByb3BzS2V5d29yZHMpIHtcbiAgICAgICAgaWYgKHNjaCAmJiB0eXBlb2Ygc2NoID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBzY2gpXG4gICAgICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2hbcHJvcF0sIGpzb25QdHIgKyAnLycgKyBrZXkgKyAnLycgKyBlc2NhcGVKc29uUHRyKHByb3ApLCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSwgcHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoa2V5IGluIHRyYXZlcnNlLmtleXdvcmRzIHx8IChvcHRzLmFsbEtleXMgJiYgIShrZXkgaW4gdHJhdmVyc2Uuc2tpcEtleXdvcmRzKSkpIHtcbiAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoLCBqc29uUHRyICsgJy8nICsga2V5LCByb290U2NoZW1hLCBqc29uUHRyLCBrZXksIHNjaGVtYSk7XG4gICAgICB9XG4gICAgfVxuICAgIHBvc3Qoc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KTtcbiAgfVxufVxuXG5cbmZ1bmN0aW9uIGVzY2FwZUpzb25QdHIoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCAnfjAnKS5yZXBsYWNlKC9cXC8vZywgJ34xJyk7XG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYSwgQW55U2NoZW1hT2JqZWN0LCBVcmlSZXNvbHZlcn0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIEFqdiBmcm9tIFwiLi4vYWp2XCJcbmltcG9ydCB0eXBlIHtVUklDb21wb25lbnR9IGZyb20gXCJmYXN0LXVyaVwiXG5pbXBvcnQge2VhY2hJdGVtfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCAqIGFzIGVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIlxuaW1wb3J0ICogYXMgdHJhdmVyc2UgZnJvbSBcImpzb24tc2NoZW1hLXRyYXZlcnNlXCJcblxuLy8gdGhlIGhhc2ggb2YgbG9jYWwgcmVmZXJlbmNlcyBpbnNpZGUgdGhlIHNjaGVtYSAoY3JlYXRlZCBieSBnZXRTY2hlbWFSZWZzKSwgdXNlZCBmb3IgaW5saW5lIHJlc29sdXRpb25cbmV4cG9ydCB0eXBlIExvY2FsUmVmcyA9IHtbUmVmIGluIHN0cmluZ10/OiBBbnlTY2hlbWFPYmplY3R9XG5cbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIGtleXdvcmQgZGVmaW5pdGlvbnNcbmNvbnN0IFNJTVBMRV9JTkxJTkVEID0gbmV3IFNldChbXG4gIFwidHlwZVwiLFxuICBcImZvcm1hdFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJtYXhMZW5ndGhcIixcbiAgXCJtaW5MZW5ndGhcIixcbiAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gIFwibWluUHJvcGVydGllc1wiLFxuICBcIm1heEl0ZW1zXCIsXG4gIFwibWluSXRlbXNcIixcbiAgXCJtYXhpbXVtXCIsXG4gIFwibWluaW11bVwiLFxuICBcInVuaXF1ZUl0ZW1zXCIsXG4gIFwibXVsdGlwbGVPZlwiLFxuICBcInJlcXVpcmVkXCIsXG4gIFwiZW51bVwiLFxuICBcImNvbnN0XCIsXG5dKVxuXG5leHBvcnQgZnVuY3Rpb24gaW5saW5lUmVmKHNjaGVtYTogQW55U2NoZW1hLCBsaW1pdDogYm9vbGVhbiB8IG51bWJlciA9IHRydWUpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB0cnVlXG4gIGlmIChsaW1pdCA9PT0gdHJ1ZSkgcmV0dXJuICFoYXNSZWYoc2NoZW1hKVxuICBpZiAoIWxpbWl0KSByZXR1cm4gZmFsc2VcbiAgcmV0dXJuIGNvdW50S2V5cyhzY2hlbWEpIDw9IGxpbWl0XG59XG5cbmNvbnN0IFJFRl9LRVlXT1JEUyA9IG5ldyBTZXQoW1xuICBcIiRyZWZcIixcbiAgXCIkcmVjdXJzaXZlUmVmXCIsXG4gIFwiJHJlY3Vyc2l2ZUFuY2hvclwiLFxuICBcIiRkeW5hbWljUmVmXCIsXG4gIFwiJGR5bmFtaWNBbmNob3JcIixcbl0pXG5cbmZ1bmN0aW9uIGhhc1JlZihzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IGJvb2xlYW4ge1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoUkVGX0tFWVdPUkRTLmhhcyhrZXkpKSByZXR1cm4gdHJ1ZVxuICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtrZXldXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSAmJiBzY2guc29tZShoYXNSZWYpKSByZXR1cm4gdHJ1ZVxuICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIgJiYgaGFzUmVmKHNjaCkpIHJldHVybiB0cnVlXG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGNvdW50S2V5cyhzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IG51bWJlciB7XG4gIGxldCBjb3VudCA9IDBcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKGtleSA9PT0gXCIkcmVmXCIpIHJldHVybiBJbmZpbml0eVxuICAgIGNvdW50KytcbiAgICBpZiAoU0lNUExFX0lOTElORUQuaGFzKGtleSkpIGNvbnRpbnVlXG4gICAgaWYgKHR5cGVvZiBzY2hlbWFba2V5XSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBlYWNoSXRlbShzY2hlbWFba2V5XSwgKHNjaCkgPT4gKGNvdW50ICs9IGNvdW50S2V5cyhzY2gpKSlcbiAgICB9XG4gICAgaWYgKGNvdW50ID09PSBJbmZpbml0eSkgcmV0dXJuIEluZmluaXR5XG4gIH1cbiAgcmV0dXJuIGNvdW50XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsUGF0aChyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIGlkID0gXCJcIiwgbm9ybWFsaXplPzogYm9vbGVhbik6IHN0cmluZyB7XG4gIGlmIChub3JtYWxpemUgIT09IGZhbHNlKSBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICBjb25zdCBwID0gcmVzb2x2ZXIucGFyc2UoaWQpXG4gIHJldHVybiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfZ2V0RnVsbFBhdGgocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBwOiBVUklDb21wb25lbnQpOiBzdHJpbmcge1xuICBjb25zdCBzZXJpYWxpemVkID0gcmVzb2x2ZXIuc2VyaWFsaXplKHApXG4gIHJldHVybiBzZXJpYWxpemVkLnNwbGl0KFwiI1wiKVswXSArIFwiI1wiXG59XG5cbmNvbnN0IFRSQUlMSU5HX1NMQVNIX0hBU0ggPSAvI1xcLz8kL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUlkKGlkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICByZXR1cm4gaWQgPyBpZC5yZXBsYWNlKFRSQUlMSU5HX1NMQVNIX0hBU0gsIFwiXCIpIDogXCJcIlxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVVybChyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIGJhc2VJZDogc3RyaW5nLCBpZDogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWQgPSBub3JtYWxpemVJZChpZClcbiAgcmV0dXJuIHJlc29sdmVyLnJlc29sdmUoYmFzZUlkLCBpZClcbn1cblxuY29uc3QgQU5DSE9SID0gL15bYS16X11bLWEtejAtOS5fXSokL2lcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFNjaGVtYVJlZnModGhpczogQWp2LCBzY2hlbWE6IEFueVNjaGVtYSwgYmFzZUlkOiBzdHJpbmcpOiBMb2NhbFJlZnMge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHt9XG4gIGNvbnN0IHtzY2hlbWFJZCwgdXJpUmVzb2x2ZXJ9ID0gdGhpcy5vcHRzXG4gIGNvbnN0IHNjaElkID0gbm9ybWFsaXplSWQoc2NoZW1hW3NjaGVtYUlkXSB8fCBiYXNlSWQpXG4gIGNvbnN0IGJhc2VJZHM6IHtbSnNvblB0ciBpbiBzdHJpbmddPzogc3RyaW5nfSA9IHtcIlwiOiBzY2hJZH1cbiAgY29uc3QgcGF0aFByZWZpeCA9IGdldEZ1bGxQYXRoKHVyaVJlc29sdmVyLCBzY2hJZCwgZmFsc2UpXG4gIGNvbnN0IGxvY2FsUmVmczogTG9jYWxSZWZzID0ge31cbiAgY29uc3Qgc2NoZW1hUmVmczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KClcblxuICB0cmF2ZXJzZShzY2hlbWEsIHthbGxLZXlzOiB0cnVlfSwgKHNjaCwganNvblB0ciwgXywgcGFyZW50SnNvblB0cikgPT4ge1xuICAgIGlmIChwYXJlbnRKc29uUHRyID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIGNvbnN0IGZ1bGxQYXRoID0gcGF0aFByZWZpeCArIGpzb25QdHJcbiAgICBsZXQgaW5uZXJCYXNlSWQgPSBiYXNlSWRzW3BhcmVudEpzb25QdHJdXG4gICAgaWYgKHR5cGVvZiBzY2hbc2NoZW1hSWRdID09IFwic3RyaW5nXCIpIGlubmVyQmFzZUlkID0gYWRkUmVmLmNhbGwodGhpcywgc2NoW3NjaGVtYUlkXSlcbiAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGFuY2hvcilcbiAgICBhZGRBbmNob3IuY2FsbCh0aGlzLCBzY2guJGR5bmFtaWNBbmNob3IpXG4gICAgYmFzZUlkc1tqc29uUHRyXSA9IGlubmVyQmFzZUlkXG5cbiAgICBmdW5jdGlvbiBhZGRSZWYodGhpczogQWp2LCByZWY6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgICBjb25zdCBfcmVzb2x2ZSA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5yZXNvbHZlXG4gICAgICByZWYgPSBub3JtYWxpemVJZChpbm5lckJhc2VJZCA/IF9yZXNvbHZlKGlubmVyQmFzZUlkLCByZWYpIDogcmVmKVxuICAgICAgaWYgKHNjaGVtYVJlZnMuaGFzKHJlZikpIHRocm93IGFtYmlndW9zKHJlZilcbiAgICAgIHNjaGVtYVJlZnMuYWRkKHJlZilcbiAgICAgIGxldCBzY2hPclJlZiA9IHRoaXMucmVmc1tyZWZdXG4gICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHNjaE9yUmVmID0gdGhpcy5yZWZzW3NjaE9yUmVmXVxuICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBzY2hPclJlZi5zY2hlbWEsIHJlZilcbiAgICAgIH0gZWxzZSBpZiAocmVmICE9PSBub3JtYWxpemVJZChmdWxsUGF0aCkpIHtcbiAgICAgICAgaWYgKHJlZlswXSA9PT0gXCIjXCIpIHtcbiAgICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgbG9jYWxSZWZzW3JlZl0sIHJlZilcbiAgICAgICAgICBsb2NhbFJlZnNbcmVmXSA9IHNjaFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucmVmc1tyZWZdID0gZnVsbFBhdGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZlxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEFuY2hvcih0aGlzOiBBanYsIGFuY2hvcjogdW5rbm93bik6IHZvaWQge1xuICAgICAgaWYgKHR5cGVvZiBhbmNob3IgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoIUFOQ0hPUi50ZXN0KGFuY2hvcikpIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBhbmNob3IgXCIke2FuY2hvcn1cImApXG4gICAgICAgIGFkZFJlZi5jYWxsKHRoaXMsIGAjJHthbmNob3J9YClcbiAgICAgIH1cbiAgICB9XG4gIH0pXG5cbiAgcmV0dXJuIGxvY2FsUmVmc1xuXG4gIGZ1bmN0aW9uIGNoZWNrQW1iaWd1b3NSZWYoc2NoMTogQW55U2NoZW1hLCBzY2gyOiBBbnlTY2hlbWEgfCB1bmRlZmluZWQsIHJlZjogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHNjaDIgIT09IHVuZGVmaW5lZCAmJiAhZXF1YWwoc2NoMSwgc2NoMikpIHRocm93IGFtYmlndW9zKHJlZilcbiAgfVxuXG4gIGZ1bmN0aW9uIGFtYmlndW9zKHJlZjogc3RyaW5nKTogRXJyb3Ige1xuICAgIHJldHVybiBuZXcgRXJyb3IoYHJlZmVyZW5jZSBcIiR7cmVmfVwiIHJlc29sdmVzIHRvIG1vcmUgdGhhbiBvbmUgc2NoZW1hYClcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEtleXdvcmRFcnJvckN4dCxcbiAgS2V5d29yZEN4dFBhcmFtcyxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB0eXBlIHtJbnN0YW5jZU9wdGlvbnN9IGZyb20gXCIuLi8uLi9jb3JlXCJcbmltcG9ydCB7Ym9vbE9yRW1wdHlTY2hlbWEsIHRvcEJvb2xPckVtcHR5U2NoZW1hfSBmcm9tIFwiLi9ib29sU2NoZW1hXCJcbmltcG9ydCB7Y29lcmNlQW5kQ2hlY2tEYXRhVHlwZSwgZ2V0U2NoZW1hVHlwZXN9IGZyb20gXCIuL2RhdGFUeXBlXCJcbmltcG9ydCB7c2hvdWxkVXNlR3JvdXAsIHNob3VsZFVzZVJ1bGV9IGZyb20gXCIuL2FwcGxpY2FiaWxpdHlcIlxuaW1wb3J0IHtjaGVja0RhdGFUeXBlLCBjaGVja0RhdGFUeXBlcywgcmVwb3J0VHlwZUVycm9yLCBEYXRhVHlwZX0gZnJvbSBcIi4vZGF0YVR5cGVcIlxuaW1wb3J0IHthc3NpZ25EZWZhdWx0c30gZnJvbSBcIi4vZGVmYXVsdHNcIlxuaW1wb3J0IHtmdW5jS2V5d29yZENvZGUsIG1hY3JvS2V5d29yZENvZGUsIHZhbGlkYXRlS2V5d29yZFVzYWdlLCB2YWxpZFNjaGVtYVR5cGV9IGZyb20gXCIuL2tleXdvcmRcIlxuaW1wb3J0IHtnZXRTdWJzY2hlbWEsIGV4dGVuZFN1YnNjaGVtYURhdGEsIFN1YnNjaGVtYUFyZ3MsIGV4dGVuZFN1YnNjaGVtYU1vZGV9IGZyb20gXCIuL3N1YnNjaGVtYVwiXG5pbXBvcnQge18sIG5pbCwgc3RyLCBvciwgbm90LCBnZXRQcm9wZXJ0eSwgQmxvY2ssIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5pbXBvcnQge3Jlc29sdmVVcmx9IGZyb20gXCIuLi9yZXNvbHZlXCJcbmltcG9ydCB7XG4gIHNjaGVtYVJlZk9yVmFsLFxuICBzY2hlbWFIYXNSdWxlc0J1dFJlZixcbiAgY2hlY2tVbmtub3duUnVsZXMsXG4gIGNoZWNrU3RyaWN0TW9kZSxcbiAgdW5lc2NhcGVKc29uUG9pbnRlcixcbiAgbWVyZ2VFdmFsdWF0ZWQsXG59IGZyb20gXCIuLi91dGlsXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZSwgUnVsZSwgUnVsZUdyb3VwfSBmcm9tIFwiLi4vcnVsZXNcIlxuaW1wb3J0IHtcbiAgRXJyb3JQYXRocyxcbiAgcmVwb3J0RXJyb3IsXG4gIHJlcG9ydEV4dHJhRXJyb3IsXG4gIHJlc2V0RXJyb3JzQ291bnQsXG4gIGtleXdvcmQkRGF0YUVycm9yLFxufSBmcm9tIFwiLi4vZXJyb3JzXCJcblxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gZ2VuZXJhdGVzIHZhbGlkYXRpb24gZnVuY3Rpb24sIHN1YnNjaGVtYUNvZGUgKGJlbG93KSBpcyB1c2VkIGZvciBzdWJzY2hlbWFzXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvZGUoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgY2hlY2tLZXl3b3JkcyhpdClcbiAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICB0b3BTY2hlbWFPYmpDb2RlKGl0KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0KSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbihcbiAge2dlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWEsIHNjaGVtYUVudiwgb3B0c306IFNjaGVtYUN4dCxcbiAgYm9keTogQmxvY2tcbik6IHZvaWQge1xuICBpZiAob3B0cy5jb2RlLmVzNSkge1xuICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgX2Ake04uZGF0YX0sICR7Ti52YWxDeHR9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT4ge1xuICAgICAgZ2VuLmNvZGUoX2BcInVzZSBzdHJpY3RcIjsgJHtmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cyl9YClcbiAgICAgIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbiwgb3B0cylcbiAgICAgIGdlbi5jb2RlKGJvZHkpXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIF9gJHtOLmRhdGF9LCAke2Rlc3RydWN0dXJlVmFsQ3h0KG9wdHMpfWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+XG4gICAgICBnZW4uY29kZShmdW5jU291cmNlVXJsKHNjaGVtYSwgb3B0cykpLmNvZGUoYm9keSlcbiAgICApXG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHQob3B0czogSW5zdGFuY2VPcHRpb25zKTogQ29kZSB7XG4gIHJldHVybiBfYHske04uaW5zdGFuY2VQYXRofT1cIlwiLCAke04ucGFyZW50RGF0YX0sICR7Ti5wYXJlbnREYXRhUHJvcGVydHl9LCAke04ucm9vdERhdGF9PSR7XG4gICAgTi5kYXRhXG4gIH0ke29wdHMuZHluYW1pY1JlZiA/IF9gLCAke04uZHluYW1pY0FuY2hvcnN9PXt9YCA6IG5pbH19PXt9YFxufVxuXG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW46IENvZGVHZW4sIG9wdHM6IEluc3RhbmNlT3B0aW9ucyk6IHZvaWQge1xuICBnZW4uaWYoXG4gICAgTi52YWxDeHQsXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuLnZhcihOLmluc3RhbmNlUGF0aCwgX2Ake04udmFsQ3h0fS4ke04uaW5zdGFuY2VQYXRofWApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YSwgX2Ake04udmFsQ3h0fS4ke04ucGFyZW50RGF0YX1gKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGFQcm9wZXJ0eSwgX2Ake04udmFsQ3h0fS4ke04ucGFyZW50RGF0YVByb3BlcnR5fWApXG4gICAgICBnZW4udmFyKE4ucm9vdERhdGEsIF9gJHtOLnZhbEN4dH0uJHtOLnJvb3REYXRhfWApXG4gICAgICBpZiAob3B0cy5keW5hbWljUmVmKSBnZW4udmFyKE4uZHluYW1pY0FuY2hvcnMsIF9gJHtOLnZhbEN4dH0uJHtOLmR5bmFtaWNBbmNob3JzfWApXG4gICAgfSxcbiAgICAoKSA9PiB7XG4gICAgICBnZW4udmFyKE4uaW5zdGFuY2VQYXRoLCBfYFwiXCJgKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGEsIF9gdW5kZWZpbmVkYClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhUHJvcGVydHksIF9gdW5kZWZpbmVkYClcbiAgICAgIGdlbi52YXIoTi5yb290RGF0YSwgTi5kYXRhKVxuICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZikgZ2VuLnZhcihOLmR5bmFtaWNBbmNob3JzLCBfYHt9YClcbiAgICB9XG4gIClcbn1cblxuZnVuY3Rpb24gdG9wU2NoZW1hT2JqQ29kZShpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIG9wdHMsIGdlbn0gPSBpdFxuICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB7XG4gICAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KSBjb21tZW50S2V5d29yZChpdClcbiAgICBjaGVja05vRGVmYXVsdChpdClcbiAgICBnZW4ubGV0KE4udkVycm9ycywgbnVsbClcbiAgICBnZW4ubGV0KE4uZXJyb3JzLCAwKVxuICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKSByZXNldEV2YWx1YXRlZChpdClcbiAgICB0eXBlQW5kS2V5d29yZHMoaXQpXG4gICAgcmV0dXJuUmVzdWx0cyhpdClcbiAgfSlcbiAgcmV0dXJuXG59XG5cbmZ1bmN0aW9uIHJlc2V0RXZhbHVhdGVkKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgLy8gVE9ETyBtYXliZSBzb21lIGhvb2sgdG8gZXhlY3V0ZSBpdCBpbiB0aGUgZW5kIHRvIGNoZWNrIHdoZXRoZXIgcHJvcHMvaXRlbXMgYXJlIE5hbWUsIGFzIGluIGFzc2lnbkV2YWx1YXRlZFxuICBjb25zdCB7Z2VuLCB2YWxpZGF0ZU5hbWV9ID0gaXRcbiAgaXQuZXZhbHVhdGVkID0gZ2VuLmNvbnN0KFwiZXZhbHVhdGVkXCIsIF9gJHt2YWxpZGF0ZU5hbWV9LmV2YWx1YXRlZGApXG4gIGdlbi5pZihfYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljUHJvcHNgLCAoKSA9PiBnZW4uYXNzaWduKF9gJHtpdC5ldmFsdWF0ZWR9LnByb3BzYCwgX2B1bmRlZmluZWRgKSlcbiAgZ2VuLmlmKF9gJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNJdGVtc2AsICgpID0+IGdlbi5hc3NpZ24oX2Ake2l0LmV2YWx1YXRlZH0uaXRlbXNgLCBfYHVuZGVmaW5lZGApKVxufVxuXG5mdW5jdGlvbiBmdW5jU291cmNlVXJsKHNjaGVtYTogQW55U2NoZW1hLCBvcHRzOiBJbnN0YW5jZU9wdGlvbnMpOiBDb2RlIHtcbiAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hW29wdHMuc2NoZW1hSWRdXG4gIHJldHVybiBzY2hJZCAmJiAob3B0cy5jb2RlLnNvdXJjZSB8fCBvcHRzLmNvZGUucHJvY2VzcykgPyBfYC8qIyBzb3VyY2VVUkw9JHtzY2hJZH0gKi9gIDogbmlsXG59XG5cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCByZWN1cnNpdmVseSB0byBnZW5lcmF0ZSBjb2RlIGZvciBzdWItc2NoZW1hc1xuZnVuY3Rpb24gc3Vic2NoZW1hQ29kZShpdDogU2NoZW1hQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBpZiAoaXNTY2hlbWFPYmooaXQpKSB7XG4gICAgY2hlY2tLZXl3b3JkcyhpdClcbiAgICBpZiAoc2NoZW1hQ3h0SGFzUnVsZXMoaXQpKSB7XG4gICAgICBzdWJTY2hlbWFPYmpDb2RlKGl0LCB2YWxpZClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICBib29sT3JFbXB0eVNjaGVtYShpdCwgdmFsaWQpXG59XG5cbmZ1bmN0aW9uIHNjaGVtYUN4dEhhc1J1bGVzKHtzY2hlbWEsIHNlbGZ9OiBTY2hlbWFDeHQpOiBib29sZWFuIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiAhc2NoZW1hXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkgaWYgKHNlbGYuUlVMRVMuYWxsW2tleV0pIHJldHVybiB0cnVlXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBpc1NjaGVtYU9iaihpdDogU2NoZW1hQ3h0KTogaXQgaXMgU2NoZW1hT2JqQ3h0IHtcbiAgcmV0dXJuIHR5cGVvZiBpdC5zY2hlbWEgIT0gXCJib29sZWFuXCJcbn1cblxuZnVuY3Rpb24gc3ViU2NoZW1hT2JqQ29kZShpdDogU2NoZW1hT2JqQ3h0LCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBnZW4sIG9wdHN9ID0gaXRcbiAgaWYgKG9wdHMuJGNvbW1lbnQgJiYgc2NoZW1hLiRjb21tZW50KSBjb21tZW50S2V5d29yZChpdClcbiAgdXBkYXRlQ29udGV4dChpdClcbiAgY2hlY2tBc3luY1NjaGVtYShpdClcbiAgY29uc3QgZXJyc0NvdW50ID0gZ2VuLmNvbnN0KFwiX2VycnNcIiwgTi5lcnJvcnMpXG4gIHR5cGVBbmRLZXl3b3JkcyhpdCwgZXJyc0NvdW50KVxuICAvLyBUT0RPIHZhclxuICBnZW4udmFyKHZhbGlkLCBfYCR7ZXJyc0NvdW50fSA9PT0gJHtOLmVycm9yc31gKVxufVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY2hlY2tVbmtub3duUnVsZXMoaXQpXG4gIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0KVxufVxuXG5mdW5jdGlvbiB0eXBlQW5kS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCwgZXJyc0NvdW50PzogTmFtZSk6IHZvaWQge1xuICBpZiAoaXQub3B0cy5qdGQpIHJldHVybiBzY2hlbWFLZXl3b3JkcyhpdCwgW10sIGZhbHNlLCBlcnJzQ291bnQpXG4gIGNvbnN0IHR5cGVzID0gZ2V0U2NoZW1hVHlwZXMoaXQuc2NoZW1hKVxuICBjb25zdCBjaGVja2VkVHlwZXMgPSBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0LCB0eXBlcylcbiAgc2NoZW1hS2V5d29yZHMoaXQsIHR5cGVzLCAhY2hlY2tlZFR5cGVzLCBlcnJzQ291bnQpXG59XG5cbmZ1bmN0aW9uIGNoZWNrUmVmc0FuZEtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0cywgc2VsZn0gPSBpdFxuICBpZiAoc2NoZW1hLiRyZWYgJiYgb3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgJiYgc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBzZWxmLlJVTEVTKSkge1xuICAgIHNlbGYubG9nZ2VyLndhcm4oYCRyZWY6IGtleXdvcmRzIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9EZWZhdWx0KGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgb3B0c30gPSBpdFxuICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCAmJiBvcHRzLnVzZURlZmF1bHRzICYmIG9wdHMuc3RyaWN0U2NoZW1hKSB7XG4gICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBcImRlZmF1bHQgaXMgaWdub3JlZCBpbiB0aGUgc2NoZW1hIHJvb3RcIilcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0KGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qgc2NoSWQgPSBpdC5zY2hlbWFbaXQub3B0cy5zY2hlbWFJZF1cbiAgaWYgKHNjaElkKSBpdC5iYXNlSWQgPSByZXNvbHZlVXJsKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgc2NoSWQpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQXN5bmNTY2hlbWEoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBpZiAoaXQuc2NoZW1hLiRhc3luYyAmJiAhaXQuc2NoZW1hRW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIGluIHN5bmMgc2NoZW1hXCIpXG59XG5cbmZ1bmN0aW9uIGNvbW1lbnRLZXl3b3JkKHtnZW4sIHNjaGVtYUVudiwgc2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzfTogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IG1zZyA9IHNjaGVtYS4kY29tbWVudFxuICBpZiAob3B0cy4kY29tbWVudCA9PT0gdHJ1ZSkge1xuICAgIGdlbi5jb2RlKF9gJHtOLnNlbGZ9LmxvZ2dlci5sb2coJHttc2d9KWApXG4gIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuJGNvbW1lbnQgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uc3Qgc2NoZW1hUGF0aCA9IHN0cmAke2VyclNjaGVtYVBhdGh9LyRjb21tZW50YFxuICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHtyZWY6IHNjaGVtYUVudi5yb290fSlcbiAgICBnZW4uY29kZShfYCR7Ti5zZWxmfS5vcHRzLiRjb21tZW50KCR7bXNnfSwgJHtzY2hlbWFQYXRofSwgJHtyb290TmFtZX0uc2NoZW1hKWApXG4gIH1cbn1cblxuZnVuY3Rpb24gcmV0dXJuUmVzdWx0cyhpdDogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYUVudiwgdmFsaWRhdGVOYW1lLCBWYWxpZGF0aW9uRXJyb3IsIG9wdHN9ID0gaXRcbiAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICAvLyBUT0RPIGFzc2lnbiB1bmV2YWx1YXRlZFxuICAgIGdlbi5pZihcbiAgICAgIF9gJHtOLmVycm9yc30gPT09IDBgLFxuICAgICAgKCkgPT4gZ2VuLnJldHVybihOLmRhdGEpLFxuICAgICAgKCkgPT4gZ2VuLnRocm93KF9gbmV3ICR7VmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9KCR7Ti52RXJyb3JzfSlgKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICBnZW4uYXNzaWduKF9gJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIE4udkVycm9ycylcbiAgICBpZiAob3B0cy51bmV2YWx1YXRlZCkgYXNzaWduRXZhbHVhdGVkKGl0KVxuICAgIGdlbi5yZXR1cm4oX2Ake04uZXJyb3JzfSA9PT0gMGApXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduRXZhbHVhdGVkKHtnZW4sIGV2YWx1YXRlZCwgcHJvcHMsIGl0ZW1zfTogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGlmIChwcm9wcyBpbnN0YW5jZW9mIE5hbWUpIGdlbi5hc3NpZ24oX2Ake2V2YWx1YXRlZH0ucHJvcHNgLCBwcm9wcylcbiAgaWYgKGl0ZW1zIGluc3RhbmNlb2YgTmFtZSkgZ2VuLmFzc2lnbihfYCR7ZXZhbHVhdGVkfS5pdGVtc2AsIGl0ZW1zKVxufVxuXG5mdW5jdGlvbiBzY2hlbWFLZXl3b3JkcyhcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAgdHlwZXM6IEpTT05UeXBlW10sXG4gIHR5cGVFcnJvcnM6IGJvb2xlYW4sXG4gIGVycnNDb3VudD86IE5hbWVcbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGFsbEVycm9ycywgb3B0cywgc2VsZn0gPSBpdFxuICBjb25zdCB7UlVMRVN9ID0gc2VsZlxuICBpZiAoc2NoZW1hLiRyZWYgJiYgKG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmIHx8ICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIFJVTEVTKSkpIHtcbiAgICBnZW4uYmxvY2soKCkgPT4ga2V5d29yZENvZGUoaXQsIFwiJHJlZlwiLCAoUlVMRVMuYWxsLiRyZWYgYXMgUnVsZSkuZGVmaW5pdGlvbikpIC8vIFRPRE8gdHlwZWNhc3RcbiAgICByZXR1cm5cbiAgfVxuICBpZiAoIW9wdHMuanRkKSBjaGVja1N0cmljdFR5cGVzKGl0LCB0eXBlcylcbiAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSBncm91cEtleXdvcmRzKGdyb3VwKVxuICAgIGdyb3VwS2V5d29yZHMoUlVMRVMucG9zdClcbiAgfSlcblxuICBmdW5jdGlvbiBncm91cEtleXdvcmRzKGdyb3VwOiBSdWxlR3JvdXApOiB2b2lkIHtcbiAgICBpZiAoIXNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApKSByZXR1cm5cbiAgICBpZiAoZ3JvdXAudHlwZSkge1xuICAgICAgZ2VuLmlmKGNoZWNrRGF0YVR5cGUoZ3JvdXAudHlwZSwgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSlcbiAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApXG4gICAgICBpZiAodHlwZXMubGVuZ3RoID09PSAxICYmIHR5cGVzWzBdID09PSBncm91cC50eXBlICYmIHR5cGVFcnJvcnMpIHtcbiAgICAgICAgZ2VuLmVsc2UoKVxuICAgICAgICByZXBvcnRUeXBlRXJyb3IoaXQpXG4gICAgICB9XG4gICAgICBnZW4uZW5kSWYoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKVxuICAgIH1cbiAgICAvLyBUT0RPIG1ha2UgaXQgXCJva1wiIGNhbGw/XG4gICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5pZihfYCR7Ti5lcnJvcnN9ID09PSAke2VycnNDb3VudCB8fCAwfWApXG4gIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZUtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQsIGdyb3VwOiBSdWxlR3JvdXApOiB2b2lkIHtcbiAgY29uc3Qge1xuICAgIGdlbixcbiAgICBzY2hlbWEsXG4gICAgb3B0czoge3VzZURlZmF1bHRzfSxcbiAgfSA9IGl0XG4gIGlmICh1c2VEZWZhdWx0cykgYXNzaWduRGVmYXVsdHMoaXQsIGdyb3VwLnR5cGUpXG4gIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIGdyb3VwLnJ1bGVzKSB7XG4gICAgICBpZiAoc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKSB7XG4gICAgICAgIGtleXdvcmRDb2RlKGl0LCBydWxlLmtleXdvcmQsIHJ1bGUuZGVmaW5pdGlvbiwgZ3JvdXAudHlwZSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGNoZWNrU3RyaWN0VHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgaWYgKGl0LnNjaGVtYUVudi5tZXRhIHx8ICFpdC5vcHRzLnN0cmljdFR5cGVzKSByZXR1cm5cbiAgY2hlY2tDb250ZXh0VHlwZXMoaXQsIHR5cGVzKVxuICBpZiAoIWl0Lm9wdHMuYWxsb3dVbmlvblR5cGVzKSBjaGVja011bHRpcGxlVHlwZXMoaXQsIHR5cGVzKVxuICBjaGVja0tleXdvcmRUeXBlcyhpdCwgaXQuZGF0YVR5cGVzKVxufVxuXG5mdW5jdGlvbiBjaGVja0NvbnRleHRUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAoIXR5cGVzLmxlbmd0aCkgcmV0dXJuXG4gIGlmICghaXQuZGF0YVR5cGVzLmxlbmd0aCkge1xuICAgIGl0LmRhdGFUeXBlcyA9IHR5cGVzXG4gICAgcmV0dXJuXG4gIH1cbiAgdHlwZXMuZm9yRWFjaCgodCkgPT4ge1xuICAgIGlmICghaW5jbHVkZXNUeXBlKGl0LmRhdGFUeXBlcywgdCkpIHtcbiAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGB0eXBlIFwiJHt0fVwiIG5vdCBhbGxvd2VkIGJ5IGNvbnRleHQgXCIke2l0LmRhdGFUeXBlcy5qb2luKFwiLFwiKX1cImApXG4gICAgfVxuICB9KVxuICBuYXJyb3dTY2hlbWFUeXBlcyhpdCwgdHlwZXMpXG59XG5cbmZ1bmN0aW9uIGNoZWNrTXVsdGlwbGVUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0czogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAodHMubGVuZ3RoID4gMSAmJiAhKHRzLmxlbmd0aCA9PT0gMiAmJiB0cy5pbmNsdWRlcyhcIm51bGxcIikpKSB7XG4gICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgXCJ1c2UgYWxsb3dVbmlvblR5cGVzIHRvIGFsbG93IHVuaW9uIHR5cGUga2V5d29yZFwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZFR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHRzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGNvbnN0IHJ1bGVzID0gaXQuc2VsZi5SVUxFUy5hbGxcbiAgZm9yIChjb25zdCBrZXl3b3JkIGluIHJ1bGVzKSB7XG4gICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleXdvcmRdXG4gICAgaWYgKHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgJiYgc2hvdWxkVXNlUnVsZShpdC5zY2hlbWEsIHJ1bGUpKSB7XG4gICAgICBjb25zdCB7dHlwZX0gPSBydWxlLmRlZmluaXRpb25cbiAgICAgIGlmICh0eXBlLmxlbmd0aCAmJiAhdHlwZS5zb21lKCh0KSA9PiBoYXNBcHBsaWNhYmxlVHlwZSh0cywgdCkpKSB7XG4gICAgICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIGBtaXNzaW5nIHR5cGUgXCIke3R5cGUuam9pbihcIixcIil9XCIgZm9yIGtleXdvcmQgXCIke2tleXdvcmR9XCJgKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNBcHBsaWNhYmxlVHlwZShzY2hUczogSlNPTlR5cGVbXSwga3dkVDogSlNPTlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHNjaFRzLmluY2x1ZGVzKGt3ZFQpIHx8IChrd2RUID09PSBcIm51bWJlclwiICYmIHNjaFRzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSlcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNUeXBlKHRzOiBKU09OVHlwZVtdLCB0OiBKU09OVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHMuaW5jbHVkZXModCkgfHwgKHQgPT09IFwiaW50ZWdlclwiICYmIHRzLmluY2x1ZGVzKFwibnVtYmVyXCIpKVxufVxuXG5mdW5jdGlvbiBuYXJyb3dTY2hlbWFUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB3aXRoVHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3QgdHM6IEpTT05UeXBlW10gPSBbXVxuICBmb3IgKGNvbnN0IHQgb2YgaXQuZGF0YVR5cGVzKSB7XG4gICAgaWYgKGluY2x1ZGVzVHlwZSh3aXRoVHlwZXMsIHQpKSB0cy5wdXNoKHQpXG4gICAgZWxzZSBpZiAod2l0aFR5cGVzLmluY2x1ZGVzKFwiaW50ZWdlclwiKSAmJiB0ID09PSBcIm51bWJlclwiKSB0cy5wdXNoKFwiaW50ZWdlclwiKVxuICB9XG4gIGl0LmRhdGFUeXBlcyA9IHRzXG59XG5cbmZ1bmN0aW9uIHN0cmljdFR5cGVzRXJyb3IoaXQ6IFNjaGVtYU9iakN4dCwgbXNnOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoXG4gIG1zZyArPSBgIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RUeXBlcylgXG4gIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFR5cGVzKVxufVxuXG5leHBvcnQgY2xhc3MgS2V5d29yZEN4dCBpbXBsZW1lbnRzIEtleXdvcmRFcnJvckN4dCB7XG4gIHJlYWRvbmx5IGdlbjogQ29kZUdlblxuICByZWFkb25seSBhbGxFcnJvcnM/OiBib29sZWFuXG4gIHJlYWRvbmx5IGtleXdvcmQ6IHN0cmluZ1xuICByZWFkb25seSBkYXRhOiBOYW1lIC8vIE5hbWUgcmVmZXJlbmNpbmcgdGhlIGN1cnJlbnQgbGV2ZWwgb2YgdGhlIGRhdGEgaW5zdGFuY2VcbiAgcmVhZG9ubHkgJGRhdGE/OiBzdHJpbmcgfCBmYWxzZVxuICBzY2hlbWE6IGFueSAvLyBrZXl3b3JkIHZhbHVlIGluIHRoZSBzY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hVmFsdWU6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIC8vIENvZGUgcmVmZXJlbmNlIHRvIGtleXdvcmQgc2NoZW1hIHZhbHVlIG9yIHByaW1pdGl2ZSB2YWx1ZVxuICByZWFkb25seSBzY2hlbWFDb2RlOiBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiAvLyBDb2RlIHJlZmVyZW5jZSB0byByZXNvbHZlZCBzY2hlbWEgdmFsdWUgKGRpZmZlcmVudCBpZiBzY2hlbWEgaXMgJGRhdGEpXG4gIHJlYWRvbmx5IHNjaGVtYVR5cGU6IEpTT05UeXBlW10gLy8gYWxsb3dlZCB0eXBlKHMpIG9mIGtleXdvcmQgdmFsdWUgaW4gdGhlIHNjaGVtYVxuICByZWFkb25seSBwYXJlbnRTY2hlbWE6IEFueVNjaGVtYU9iamVjdFxuICByZWFkb25seSBlcnJzQ291bnQ/OiBOYW1lIC8vIE5hbWUgcmVmZXJlbmNlIHRvIHRoZSBudW1iZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnMgY29sbGVjdGVkIGJlZm9yZSB0aGlzIGtleXdvcmQsXG4gIC8vIHJlcXVpcmVzIG9wdGlvbiB0cmFja0Vycm9ycyBpbiBrZXl3b3JkIGRlZmluaXRpb25cbiAgcGFyYW1zOiBLZXl3b3JkQ3h0UGFyYW1zIC8vIG9iamVjdCB0byBwYXNzIHBhcmFtZXRlcnMgdG8gZXJyb3IgbWVzc2FnZXMgZnJvbSBrZXl3b3JkIGNvZGVcbiAgcmVhZG9ubHkgaXQ6IFNjaGVtYU9iakN4dCAvLyBzY2hlbWEgY29tcGlsYXRpb24gY29udGV4dCAoc2NoZW1hIGlzIGd1YXJhbnRlZWQgdG8gYmUgYW4gb2JqZWN0LCBub3QgYm9vbGVhbilcbiAgcmVhZG9ubHkgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uXG5cbiAgY29uc3RydWN0b3IoaXQ6IFNjaGVtYU9iakN4dCwgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLCBrZXl3b3JkOiBzdHJpbmcpIHtcbiAgICB2YWxpZGF0ZUtleXdvcmRVc2FnZShpdCwgZGVmLCBrZXl3b3JkKVxuICAgIHRoaXMuZ2VuID0gaXQuZ2VuXG4gICAgdGhpcy5hbGxFcnJvcnMgPSBpdC5hbGxFcnJvcnNcbiAgICB0aGlzLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgdGhpcy5kYXRhID0gaXQuZGF0YVxuICAgIHRoaXMuc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gICAgdGhpcy4kZGF0YSA9IGRlZi4kZGF0YSAmJiBpdC5vcHRzLiRkYXRhICYmIHRoaXMuc2NoZW1hICYmIHRoaXMuc2NoZW1hLiRkYXRhXG4gICAgdGhpcy5zY2hlbWFWYWx1ZSA9IHNjaGVtYVJlZk9yVmFsKGl0LCB0aGlzLnNjaGVtYSwga2V5d29yZCwgdGhpcy4kZGF0YSlcbiAgICB0aGlzLnNjaGVtYVR5cGUgPSBkZWYuc2NoZW1hVHlwZVxuICAgIHRoaXMucGFyZW50U2NoZW1hID0gaXQuc2NoZW1hXG4gICAgdGhpcy5wYXJhbXMgPSB7fVxuICAgIHRoaXMuaXQgPSBpdFxuICAgIHRoaXMuZGVmID0gZGVmXG5cbiAgICBpZiAodGhpcy4kZGF0YSkge1xuICAgICAgdGhpcy5zY2hlbWFDb2RlID0gaXQuZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBnZXREYXRhKHRoaXMuJGRhdGEsIGl0KSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY2hlbWFDb2RlID0gdGhpcy5zY2hlbWFWYWx1ZVxuICAgICAgaWYgKCF2YWxpZFNjaGVtYVR5cGUodGhpcy5zY2hlbWEsIGRlZi5zY2hlbWFUeXBlLCBkZWYuYWxsb3dVbmRlZmluZWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtrZXl3b3JkfSB2YWx1ZSBtdXN0IGJlICR7SlNPTi5zdHJpbmdpZnkoZGVmLnNjaGVtYVR5cGUpfWApXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFwiY29kZVwiIGluIGRlZiA/IGRlZi50cmFja0Vycm9ycyA6IGRlZi5lcnJvcnMgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmVycnNDb3VudCA9IGl0Lmdlbi5jb25zdChcIl9lcnJzXCIsIE4uZXJyb3JzKVxuICAgIH1cbiAgfVxuXG4gIHJlc3VsdChjb25kaXRpb246IENvZGUsIHN1Y2Nlc3NBY3Rpb24/OiAoKSA9PiB2b2lkLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbFJlc3VsdChub3QoY29uZGl0aW9uKSwgc3VjY2Vzc0FjdGlvbiwgZmFpbEFjdGlvbilcbiAgfVxuXG4gIGZhaWxSZXN1bHQoY29uZGl0aW9uOiBDb2RlLCBzdWNjZXNzQWN0aW9uPzogKCkgPT4gdm9pZCwgZmFpbEFjdGlvbj86ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pXG4gICAgaWYgKGZhaWxBY3Rpb24pIGZhaWxBY3Rpb24oKVxuICAgIGVsc2UgdGhpcy5lcnJvcigpXG4gICAgaWYgKHN1Y2Nlc3NBY3Rpb24pIHtcbiAgICAgIHRoaXMuZ2VuLmVsc2UoKVxuICAgICAgc3VjY2Vzc0FjdGlvbigpXG4gICAgICBpZiAodGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmVuZElmKClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5lbmRJZigpXG4gICAgICBlbHNlIHRoaXMuZ2VuLmVsc2UoKVxuICAgIH1cbiAgfVxuXG4gIHBhc3MoY29uZGl0aW9uOiBDb2RlLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZmFpbFJlc3VsdChub3QoY29uZGl0aW9uKSwgdW5kZWZpbmVkLCBmYWlsQWN0aW9uKVxuICB9XG5cbiAgZmFpbChjb25kaXRpb24/OiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKGNvbmRpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLmVycm9yKClcbiAgICAgIGlmICghdGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmlmKGZhbHNlKSAvLyB0aGlzIGJyYW5jaCB3aWxsIGJlIHJlbW92ZWQgYnkgZ2VuLm9wdGltaXplXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKVxuICAgIHRoaXMuZXJyb3IoKVxuICAgIGlmICh0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uZW5kSWYoKVxuICAgIGVsc2UgdGhpcy5nZW4uZWxzZSgpXG4gIH1cblxuICBmYWlsJGRhdGEoY29uZGl0aW9uOiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLiRkYXRhKSByZXR1cm4gdGhpcy5mYWlsKGNvbmRpdGlvbilcbiAgICBjb25zdCB7c2NoZW1hQ29kZX0gPSB0aGlzXG4gICAgdGhpcy5mYWlsKF9gJHtzY2hlbWFDb2RlfSAhPT0gdW5kZWZpbmVkICYmICgke29yKHRoaXMuaW52YWxpZCRkYXRhKCksIGNvbmRpdGlvbil9KWApXG4gIH1cblxuICBlcnJvcihhcHBlbmQ/OiBib29sZWFuLCBlcnJvclBhcmFtcz86IEtleXdvcmRDeHRQYXJhbXMsIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzKTogdm9pZCB7XG4gICAgaWYgKGVycm9yUGFyYW1zKSB7XG4gICAgICB0aGlzLnNldFBhcmFtcyhlcnJvclBhcmFtcylcbiAgICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocylcbiAgICAgIHRoaXMuc2V0UGFyYW1zKHt9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuX2Vycm9yKGFwcGVuZCwgZXJyb3JQYXRocylcbiAgfVxuXG4gIHByaXZhdGUgX2Vycm9yKGFwcGVuZD86IGJvb2xlYW4sIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzKTogdm9pZCB7XG4gICAgOyhhcHBlbmQgPyByZXBvcnRFeHRyYUVycm9yIDogcmVwb3J0RXJyb3IpKHRoaXMsIHRoaXMuZGVmLmVycm9yLCBlcnJvclBhdGhzKVxuICB9XG5cbiAgJGRhdGFFcnJvcigpOiB2b2lkIHtcbiAgICByZXBvcnRFcnJvcih0aGlzLCB0aGlzLmRlZi4kZGF0YUVycm9yIHx8IGtleXdvcmQkRGF0YUVycm9yKVxuICB9XG5cbiAgcmVzZXQoKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuZXJyc0NvdW50ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignYWRkIFwidHJhY2tFcnJvcnNcIiB0byBrZXl3b3JkIGRlZmluaXRpb24nKVxuICAgIHJlc2V0RXJyb3JzQ291bnQodGhpcy5nZW4sIHRoaXMuZXJyc0NvdW50KVxuICB9XG5cbiAgb2soY29uZDogQ29kZSB8IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5pZihjb25kKVxuICB9XG5cbiAgc2V0UGFyYW1zKG9iajogS2V5d29yZEN4dFBhcmFtcywgYXNzaWduPzogdHJ1ZSk6IHZvaWQge1xuICAgIGlmIChhc3NpZ24pIE9iamVjdC5hc3NpZ24odGhpcy5wYXJhbXMsIG9iailcbiAgICBlbHNlIHRoaXMucGFyYW1zID0gb2JqXG4gIH1cblxuICBibG9jayRkYXRhKHZhbGlkOiBOYW1lLCBjb2RlQmxvY2s6ICgpID0+IHZvaWQsICRkYXRhVmFsaWQ6IENvZGUgPSBuaWwpOiB2b2lkIHtcbiAgICB0aGlzLmdlbi5ibG9jaygoKSA9PiB7XG4gICAgICB0aGlzLmNoZWNrJGRhdGEodmFsaWQsICRkYXRhVmFsaWQpXG4gICAgICBjb2RlQmxvY2soKVxuICAgIH0pXG4gIH1cblxuICBjaGVjayRkYXRhKHZhbGlkOiBOYW1lID0gbmlsLCAkZGF0YVZhbGlkOiBDb2RlID0gbmlsKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLiRkYXRhKSByZXR1cm5cbiAgICBjb25zdCB7Z2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWZ9ID0gdGhpc1xuICAgIGdlbi5pZihvcihfYCR7c2NoZW1hQ29kZX0gPT09IHVuZGVmaW5lZGAsICRkYXRhVmFsaWQpKVxuICAgIGlmICh2YWxpZCAhPT0gbmlsKSBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCB8fCBkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgIGdlbi5lbHNlSWYodGhpcy5pbnZhbGlkJGRhdGEoKSlcbiAgICAgIHRoaXMuJGRhdGFFcnJvcigpXG4gICAgICBpZiAodmFsaWQgIT09IG5pbCkgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgfVxuICAgIGdlbi5lbHNlKClcbiAgfVxuXG4gIGludmFsaWQkZGF0YSgpOiBDb2RlIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWFDb2RlLCBzY2hlbWFUeXBlLCBkZWYsIGl0fSA9IHRoaXNcbiAgICByZXR1cm4gb3Iod3JvbmckRGF0YVR5cGUoKSwgaW52YWxpZCREYXRhU2NoZW1hKCkpXG5cbiAgICBmdW5jdGlvbiB3cm9uZyREYXRhVHlwZSgpOiBDb2RlIHtcbiAgICAgIGlmIChzY2hlbWFUeXBlLmxlbmd0aCkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKCEoc2NoZW1hQ29kZSBpbnN0YW5jZW9mIE5hbWUpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICAgICAgY29uc3Qgc3QgPSBBcnJheS5pc0FycmF5KHNjaGVtYVR5cGUpID8gc2NoZW1hVHlwZSA6IFtzY2hlbWFUeXBlXVxuICAgICAgICByZXR1cm4gX2Ake2NoZWNrRGF0YVR5cGVzKHN0LCBzY2hlbWFDb2RlLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKX1gXG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW52YWxpZCREYXRhU2NoZW1hKCk6IENvZGUge1xuICAgICAgaWYgKGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZVNjaGVtYVJlZiA9IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGUkZGF0YVwiLCB7cmVmOiBkZWYudmFsaWRhdGVTY2hlbWF9KSAvLyBUT0RPIHZhbHVlLmNvZGUgZm9yIHN0YW5kYWxvbmVcbiAgICAgICAgcmV0dXJuIF9gISR7dmFsaWRhdGVTY2hlbWFSZWZ9KCR7c2NoZW1hQ29kZX0pYFxuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbFxuICAgIH1cbiAgfVxuXG4gIHN1YnNjaGVtYShhcHBsOiBTdWJzY2hlbWFBcmdzLCB2YWxpZDogTmFtZSk6IFNjaGVtYUN4dCB7XG4gICAgY29uc3Qgc3Vic2NoZW1hID0gZ2V0U3Vic2NoZW1hKHRoaXMuaXQsIGFwcGwpXG4gICAgZXh0ZW5kU3Vic2NoZW1hRGF0YShzdWJzY2hlbWEsIHRoaXMuaXQsIGFwcGwpXG4gICAgZXh0ZW5kU3Vic2NoZW1hTW9kZShzdWJzY2hlbWEsIGFwcGwpXG4gICAgY29uc3QgbmV4dENvbnRleHQgPSB7Li4udGhpcy5pdCwgLi4uc3Vic2NoZW1hLCBpdGVtczogdW5kZWZpbmVkLCBwcm9wczogdW5kZWZpbmVkfVxuICAgIHN1YnNjaGVtYUNvZGUobmV4dENvbnRleHQsIHZhbGlkKVxuICAgIHJldHVybiBuZXh0Q29udGV4dFxuICB9XG5cbiAgbWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0OiBTY2hlbWFDeHQsIHRvTmFtZT86IHR5cGVvZiBOYW1lKTogdm9pZCB7XG4gICAgY29uc3Qge2l0LCBnZW59ID0gdGhpc1xuICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZCkgcmV0dXJuXG4gICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmIHNjaGVtYUN4dC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoZW1hQ3h0LnByb3BzLCBpdC5wcm9wcywgdG9OYW1lKVxuICAgIH1cbiAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUgJiYgc2NoZW1hQ3h0Lml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hlbWFDeHQuaXRlbXMsIGl0Lml0ZW1zLCB0b05hbWUpXG4gICAgfVxuICB9XG5cbiAgbWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hlbWFDeHQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiBib29sZWFuIHwgdm9pZCB7XG4gICAgY29uc3Qge2l0LCBnZW59ID0gdGhpc1xuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIChpdC5wcm9wcyAhPT0gdHJ1ZSB8fCBpdC5pdGVtcyAhPT0gdHJ1ZSkpIHtcbiAgICAgIGdlbi5pZih2YWxpZCwgKCkgPT4gdGhpcy5tZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQsIE5hbWUpKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5d29yZENvZGUoXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgZGVmOiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBydWxlVHlwZT86IEpTT05UeXBlXG4pOiB2b2lkIHtcbiAgY29uc3QgY3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIGRlZiwga2V5d29yZClcbiAgaWYgKFwiY29kZVwiIGluIGRlZikge1xuICAgIGRlZi5jb2RlKGN4dCwgcnVsZVR5cGUpXG4gIH0gZWxzZSBpZiAoY3h0LiRkYXRhICYmIGRlZi52YWxpZGF0ZSkge1xuICAgIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfSBlbHNlIGlmIChcIm1hY3JvXCIgaW4gZGVmKSB7XG4gICAgbWFjcm9LZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfSBlbHNlIGlmIChkZWYuY29tcGlsZSB8fCBkZWYudmFsaWRhdGUpIHtcbiAgICBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpXG4gIH1cbn1cblxuY29uc3QgSlNPTl9QT0lOVEVSID0gL15cXC8oPzpbXn5dfH4wfH4xKSokL1xuY29uc3QgUkVMQVRJVkVfSlNPTl9QT0lOVEVSID0gL14oWzAtOV0rKSgjfFxcLyg/Oltefl18fjB8fjEpKik/JC9cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhKFxuICAkZGF0YTogc3RyaW5nLFxuICB7ZGF0YUxldmVsLCBkYXRhTmFtZXMsIGRhdGFQYXRoQXJyfTogU2NoZW1hQ3h0XG4pOiBDb2RlIHwgbnVtYmVyIHtcbiAgbGV0IGpzb25Qb2ludGVyXG4gIGxldCBkYXRhOiBDb2RlXG4gIGlmICgkZGF0YSA9PT0gXCJcIikgcmV0dXJuIE4ucm9vdERhdGFcbiAgaWYgKCRkYXRhWzBdID09PSBcIi9cIikge1xuICAgIGlmICghSlNPTl9QT0lOVEVSLnRlc3QoJGRhdGEpKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApXG4gICAganNvblBvaW50ZXIgPSAkZGF0YVxuICAgIGRhdGEgPSBOLnJvb3REYXRhXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgbWF0Y2hlcyA9IFJFTEFUSVZFX0pTT05fUE9JTlRFUi5leGVjKCRkYXRhKVxuICAgIGlmICghbWF0Y2hlcykgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKVxuICAgIGNvbnN0IHVwOiBudW1iZXIgPSArbWF0Y2hlc1sxXVxuICAgIGpzb25Qb2ludGVyID0gbWF0Y2hlc1syXVxuICAgIGlmIChqc29uUG9pbnRlciA9PT0gXCIjXCIpIHtcbiAgICAgIGlmICh1cCA+PSBkYXRhTGV2ZWwpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcInByb3BlcnR5L2luZGV4XCIsIHVwKSlcbiAgICAgIHJldHVybiBkYXRhUGF0aEFycltkYXRhTGV2ZWwgLSB1cF1cbiAgICB9XG4gICAgaWYgKHVwID4gZGF0YUxldmVsKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJkYXRhXCIsIHVwKSlcbiAgICBkYXRhID0gZGF0YU5hbWVzW2RhdGFMZXZlbCAtIHVwXVxuICAgIGlmICghanNvblBvaW50ZXIpIHJldHVybiBkYXRhXG4gIH1cblxuICBsZXQgZXhwciA9IGRhdGFcbiAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIilcbiAgZm9yIChjb25zdCBzZWdtZW50IG9mIHNlZ21lbnRzKSB7XG4gICAgaWYgKHNlZ21lbnQpIHtcbiAgICAgIGRhdGEgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHVuZXNjYXBlSnNvblBvaW50ZXIoc2VnbWVudCkpfWBcbiAgICAgIGV4cHIgPSBfYCR7ZXhwcn0gJiYgJHtkYXRhfWBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV4cHJcblxuICBmdW5jdGlvbiBlcnJvck1zZyhwb2ludGVyVHlwZTogc3RyaW5nLCB1cDogbnVtYmVyKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYENhbm5vdCBhY2Nlc3MgJHtwb2ludGVyVHlwZX0gJHt1cH0gbGV2ZWxzIHVwLCBjdXJyZW50IGxldmVsIGlzICR7ZGF0YUxldmVsfWBcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtFcnJvck9iamVjdH0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBlcnJvcnM6IFBhcnRpYWw8RXJyb3JPYmplY3Q+W11cbiAgcmVhZG9ubHkgYWp2OiB0cnVlXG4gIHJlYWRvbmx5IHZhbGlkYXRpb246IHRydWVcblxuICBjb25zdHJ1Y3RvcihlcnJvcnM6IFBhcnRpYWw8RXJyb3JPYmplY3Q+W10pIHtcbiAgICBzdXBlcihcInZhbGlkYXRpb24gZmFpbGVkXCIpXG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvcnNcbiAgICB0aGlzLmFqdiA9IHRoaXMudmFsaWRhdGlvbiA9IHRydWVcbiAgfVxufVxuIiwgImltcG9ydCB7cmVzb2x2ZVVybCwgbm9ybWFsaXplSWQsIGdldEZ1bGxQYXRofSBmcm9tIFwiLi9yZXNvbHZlXCJcbmltcG9ydCB0eXBlIHtVcmlSZXNvbHZlcn0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWlzc2luZ1JlZkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSBtaXNzaW5nUmVmOiBzdHJpbmdcbiAgcmVhZG9ubHkgbWlzc2luZ1NjaGVtYTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBiYXNlSWQ6IHN0cmluZywgcmVmOiBzdHJpbmcsIG1zZz86IHN0cmluZykge1xuICAgIHN1cGVyKG1zZyB8fCBgY2FuJ3QgcmVzb2x2ZSByZWZlcmVuY2UgJHtyZWZ9IGZyb20gaWQgJHtiYXNlSWR9YClcbiAgICB0aGlzLm1pc3NpbmdSZWYgPSByZXNvbHZlVXJsKHJlc29sdmVyLCBiYXNlSWQsIHJlZilcbiAgICB0aGlzLm1pc3NpbmdTY2hlbWEgPSBub3JtYWxpemVJZChnZXRGdWxsUGF0aChyZXNvbHZlciwgdGhpcy5taXNzaW5nUmVmKSlcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgRXZhbHVhdGVkUHJvcGVydGllcyxcbiAgRXZhbHVhdGVkSXRlbXMsXG59IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcIi4uL2NvcmVcIlxuaW1wb3J0IHR5cGUge0luc3RhbmNlT3B0aW9uc30gZnJvbSBcIi4uL2NvcmVcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBuaWwsIHN0cmluZ2lmeSwgTmFtZSwgQ29kZSwgVmFsdWVTY29wZU5hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IFZhbGlkYXRpb25FcnJvciBmcm9tIFwiLi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCJcbmltcG9ydCBOIGZyb20gXCIuL25hbWVzXCJcbmltcG9ydCB7TG9jYWxSZWZzLCBnZXRGdWxsUGF0aCwgX2dldEZ1bGxQYXRoLCBpbmxpbmVSZWYsIG5vcm1hbGl6ZUlkLCByZXNvbHZlVXJsfSBmcm9tIFwiLi9yZXNvbHZlXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNCdXRSZWYsIHVuZXNjYXBlRnJhZ21lbnR9IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0IHt2YWxpZGF0ZUZ1bmN0aW9uQ29kZX0gZnJvbSBcIi4vdmFsaWRhdGVcIlxuaW1wb3J0IHtVUklDb21wb25lbnR9IGZyb20gXCJmYXN0LXVyaVwiXG5pbXBvcnQge0pTT05UeXBlfSBmcm9tIFwiLi9ydWxlc1wiXG5cbmV4cG9ydCB0eXBlIFNjaGVtYVJlZnMgPSB7XG4gIFtSZWYgaW4gc3RyaW5nXT86IFNjaGVtYUVudiB8IEFueVNjaGVtYVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVtYUN4dCB7XG4gIHJlYWRvbmx5IGdlbjogQ29kZUdlblxuICByZWFkb25seSBhbGxFcnJvcnM/OiBib29sZWFuIC8vIHZhbGlkYXRpb24gbW9kZSAtIHdoZXRoZXIgdG8gY29sbGVjdCBhbGwgZXJyb3JzIG9yIGJyZWFrIG9uIGVycm9yXG4gIHJlYWRvbmx5IGRhdGE6IE5hbWUgLy8gTmFtZSB3aXRoIHJlZmVyZW5jZSB0byB0aGUgY3VycmVudCBwYXJ0IG9mIGRhdGEgaW5zdGFuY2VcbiAgcmVhZG9ubHkgcGFyZW50RGF0YTogTmFtZSAvLyBzaG91bGQgYmUgdXNlZCBpbiBrZXl3b3JkcyBtb2RpZnlpbmcgZGF0YVxuICByZWFkb25seSBwYXJlbnREYXRhUHJvcGVydHk6IENvZGUgfCBudW1iZXIgLy8gc2hvdWxkIGJlIHVzZWQgaW4ga2V5d29yZHMgbW9kaWZ5aW5nIGRhdGFcbiAgcmVhZG9ubHkgZGF0YU5hbWVzOiBOYW1lW11cbiAgcmVhZG9ubHkgZGF0YVBhdGhBcnI6IChDb2RlIHwgbnVtYmVyKVtdXG4gIHJlYWRvbmx5IGRhdGFMZXZlbDogbnVtYmVyIC8vIHRoZSBsZXZlbCBvZiB0aGUgY3VycmVudGx5IHZhbGlkYXRlZCBkYXRhLFxuICAvLyBpdCBjYW4gYmUgdXNlZCB0byBhY2Nlc3MgYm90aCB0aGUgcHJvcGVydHkgbmFtZXMgYW5kIHRoZSBkYXRhIG9uIGFsbCBsZXZlbHMgZnJvbSB0aGUgdG9wLlxuICBkYXRhVHlwZXM6IEpTT05UeXBlW10gLy8gZGF0YSB0eXBlcyBhcHBsaWVkIHRvIHRoZSBjdXJyZW50IHBhcnQgb2YgZGF0YSBpbnN0YW5jZVxuICBkZWZpbmVkUHJvcGVydGllczogU2V0PHN0cmluZz4gLy8gc2V0IG9mIHByb3BlcnRpZXMgdG8ga2VlcCB0cmFjayBvZiBmb3IgcmVxdWlyZWQgY2hlY2tzXG4gIHJlYWRvbmx5IHRvcFNjaGVtYVJlZjogQ29kZVxuICByZWFkb25seSB2YWxpZGF0ZU5hbWU6IE5hbWVcbiAgZXZhbHVhdGVkPzogTmFtZVxuICByZWFkb25seSBWYWxpZGF0aW9uRXJyb3I/OiBOYW1lXG4gIHJlYWRvbmx5IHNjaGVtYTogQW55U2NoZW1hIC8vIGN1cnJlbnQgc2NoZW1hIG9iamVjdCAtIGVxdWFsIHRvIHBhcmVudFNjaGVtYSBwYXNzZWQgdmlhIEtleXdvcmRDeHRcbiAgcmVhZG9ubHkgc2NoZW1hRW52OiBTY2hlbWFFbnZcbiAgcmVhZG9ubHkgcm9vdElkOiBzdHJpbmdcbiAgYmFzZUlkOiBzdHJpbmcgLy8gdGhlIGN1cnJlbnQgc2NoZW1hIGJhc2UgVVJJIHRoYXQgc2hvdWxkIGJlIHVzZWQgYXMgdGhlIGJhc2UgZm9yIHJlc29sdmluZyBVUklzIGluIHJlZmVyZW5jZXMgKFxcJHJlZilcbiAgcmVhZG9ubHkgc2NoZW1hUGF0aDogQ29kZSAvLyB0aGUgcnVuLXRpbWUgZXhwcmVzc2lvbiB0aGF0IGV2YWx1YXRlcyB0byB0aGUgcHJvcGVydHkgbmFtZSBvZiB0aGUgY3VycmVudCBzY2hlbWFcbiAgcmVhZG9ubHkgZXJyU2NoZW1hUGF0aDogc3RyaW5nIC8vIHRoaXMgaXMgYWN0dWFsIHN0cmluZywgc2hvdWxkIG5vdCBiZSBjaGFuZ2VkIHRvIENvZGVcbiAgcmVhZG9ubHkgZXJyb3JQYXRoOiBDb2RlXG4gIHJlYWRvbmx5IHByb3BlcnR5TmFtZT86IE5hbWVcbiAgcmVhZG9ubHkgY29tcG9zaXRlUnVsZT86IGJvb2xlYW4gLy8gdHJ1ZSBpbmRpY2F0ZXMgdGhhdCB0aGUgY3VycmVudCBzY2hlbWEgaXMgaW5zaWRlIHRoZSBjb21wb3VuZCBrZXl3b3JkLFxuICAvLyB3aGVyZSBmYWlsaW5nIHNvbWUgcnVsZSBkb2Vzbid0IG1lYW4gdmFsaWRhdGlvbiBmYWlsdXJlIChgYW55T2ZgLCBgb25lT2ZgLCBgbm90YCwgYGlmYCkuXG4gIC8vIFRoaXMgZmxhZyBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIHlvdSBjYW4gcmV0dXJuIHZhbGlkYXRpb24gcmVzdWx0IGltbWVkaWF0ZWx5IGFmdGVyIGFueSBlcnJvciBpbiBjYXNlIHRoZSBvcHRpb24gYGFsbEVycm9yc2AgaXMgbm90IGB0cnVlLlxuICAvLyBZb3Ugb25seSBuZWVkIHRvIHVzZSBpdCBpZiB5b3UgaGF2ZSBtYW55IHN0ZXBzIGluIHlvdXIga2V5d29yZHMgYW5kIHBvdGVudGlhbGx5IGNhbiBkZWZpbmUgbXVsdGlwbGUgZXJyb3JzLlxuICBwcm9wcz86IEV2YWx1YXRlZFByb3BlcnRpZXMgfCBOYW1lIC8vIHByb3BlcnRpZXMgZXZhbHVhdGVkIGJ5IHRoaXMgc2NoZW1hIC0gdXNlZCBieSBwYXJlbnQgc2NoZW1hIG9yIGFzc2lnbmVkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgaXRlbXM/OiBFdmFsdWF0ZWRJdGVtcyB8IE5hbWUgLy8gbGFzdCBpdGVtIGV2YWx1YXRlZCBieSB0aGlzIHNjaGVtYSAtIHVzZWQgYnkgcGFyZW50IHNjaGVtYSBvciBhc3NpZ25lZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGp0ZERpc2NyaW1pbmF0b3I/OiBzdHJpbmdcbiAganRkTWV0YWRhdGE/OiBib29sZWFuXG4gIHJlYWRvbmx5IGNyZWF0ZUVycm9ycz86IGJvb2xlYW5cbiAgcmVhZG9ubHkgb3B0czogSW5zdGFuY2VPcHRpb25zIC8vIEFqdiBpbnN0YW5jZSBvcHRpb24uXG4gIHJlYWRvbmx5IHNlbGY6IEFqdiAvLyBjdXJyZW50IEFqdiBpbnN0YW5jZVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNjaGVtYU9iakN4dCBleHRlbmRzIFNjaGVtYUN4dCB7XG4gIHJlYWRvbmx5IHNjaGVtYTogQW55U2NoZW1hT2JqZWN0XG59XG5pbnRlcmZhY2UgU2NoZW1hRW52QXJncyB7XG4gIHJlYWRvbmx5IHNjaGVtYTogQW55U2NoZW1hXG4gIHJlYWRvbmx5IHNjaGVtYUlkPzogXCIkaWRcIiB8IFwiaWRcIlxuICByZWFkb25seSByb290PzogU2NoZW1hRW52XG4gIHJlYWRvbmx5IGJhc2VJZD86IHN0cmluZ1xuICByZWFkb25seSBzY2hlbWFQYXRoPzogc3RyaW5nXG4gIHJlYWRvbmx5IGxvY2FsUmVmcz86IExvY2FsUmVmc1xuICByZWFkb25seSBtZXRhPzogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgU2NoZW1hRW52IGltcGxlbWVudHMgU2NoZW1hRW52QXJncyB7XG4gIHJlYWRvbmx5IHNjaGVtYTogQW55U2NoZW1hXG4gIHJlYWRvbmx5IHNjaGVtYUlkPzogXCIkaWRcIiB8IFwiaWRcIlxuICByZWFkb25seSByb290OiBTY2hlbWFFbnZcbiAgYmFzZUlkOiBzdHJpbmcgLy8gVE9ETyBwb3NzaWJseSwgaXQgc2hvdWxkIGJlIHJlYWRvbmx5XG4gIHNjaGVtYVBhdGg/OiBzdHJpbmdcbiAgbG9jYWxSZWZzPzogTG9jYWxSZWZzXG4gIHJlYWRvbmx5IG1ldGE/OiBib29sZWFuXG4gIHJlYWRvbmx5ICRhc3luYz86IGJvb2xlYW4gLy8gdHJ1ZSBpZiB0aGUgY3VycmVudCBzY2hlbWEgaXMgYXN5bmNocm9ub3VzLlxuICByZWFkb25seSByZWZzOiBTY2hlbWFSZWZzID0ge31cbiAgcmVhZG9ubHkgZHluYW1pY0FuY2hvcnM6IHtbUmVmIGluIHN0cmluZ10/OiB0cnVlfSA9IHt9XG4gIHZhbGlkYXRlPzogQW55VmFsaWRhdGVGdW5jdGlvblxuICB2YWxpZGF0ZU5hbWU/OiBWYWx1ZVNjb3BlTmFtZVxuICBzZXJpYWxpemU/OiAoZGF0YTogdW5rbm93bikgPT4gc3RyaW5nXG4gIHNlcmlhbGl6ZU5hbWU/OiBWYWx1ZVNjb3BlTmFtZVxuICBwYXJzZT86IChkYXRhOiBzdHJpbmcpID0+IHVua25vd25cbiAgcGFyc2VOYW1lPzogVmFsdWVTY29wZU5hbWVcblxuICBjb25zdHJ1Y3RvcihlbnY6IFNjaGVtYUVudkFyZ3MpIHtcbiAgICBsZXQgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QgfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIGVudi5zY2hlbWEgPT0gXCJvYmplY3RcIikgc2NoZW1hID0gZW52LnNjaGVtYVxuICAgIHRoaXMuc2NoZW1hID0gZW52LnNjaGVtYVxuICAgIHRoaXMuc2NoZW1hSWQgPSBlbnYuc2NoZW1hSWRcbiAgICB0aGlzLnJvb3QgPSBlbnYucm9vdCB8fCB0aGlzXG4gICAgdGhpcy5iYXNlSWQgPSBlbnYuYmFzZUlkID8/IG5vcm1hbGl6ZUlkKHNjaGVtYT8uW2Vudi5zY2hlbWFJZCB8fCBcIiRpZFwiXSlcbiAgICB0aGlzLnNjaGVtYVBhdGggPSBlbnYuc2NoZW1hUGF0aFxuICAgIHRoaXMubG9jYWxSZWZzID0gZW52LmxvY2FsUmVmc1xuICAgIHRoaXMubWV0YSA9IGVudi5tZXRhXG4gICAgdGhpcy4kYXN5bmMgPSBzY2hlbWE/LiRhc3luY1xuICAgIHRoaXMucmVmcyA9IHt9XG4gIH1cbn1cblxuLy8gbGV0IGNvZGVTaXplID0gMFxuLy8gbGV0IG5vZGVDb3VudCA9IDBcblxuLy8gQ29tcGlsZXMgc2NoZW1hIGluIFNjaGVtYUVudlxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBpbGVTY2hlbWEodGhpczogQWp2LCBzY2g6IFNjaGVtYUVudik6IFNjaGVtYUVudiB7XG4gIC8vIFRPRE8gcmVmYWN0b3IgLSByZW1vdmUgY29tcGlsYXRpb25zXG4gIGNvbnN0IF9zY2ggPSBnZXRDb21waWxpbmdTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG4gIGlmIChfc2NoKSByZXR1cm4gX3NjaFxuICBjb25zdCByb290SWQgPSBnZXRGdWxsUGF0aCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHNjaC5yb290LmJhc2VJZCkgLy8gVE9ETyBpZiBnZXRGdWxsUGF0aCByZW1vdmVkIDEgdGVzdHMgZmFpbHNcbiAgY29uc3Qge2VzNSwgbGluZXN9ID0gdGhpcy5vcHRzLmNvZGVcbiAgY29uc3Qge293blByb3BlcnRpZXN9ID0gdGhpcy5vcHRzXG4gIGNvbnN0IGdlbiA9IG5ldyBDb2RlR2VuKHRoaXMuc2NvcGUsIHtlczUsIGxpbmVzLCBvd25Qcm9wZXJ0aWVzfSlcbiAgbGV0IF9WYWxpZGF0aW9uRXJyb3JcbiAgaWYgKHNjaC4kYXN5bmMpIHtcbiAgICBfVmFsaWRhdGlvbkVycm9yID0gZ2VuLnNjb3BlVmFsdWUoXCJFcnJvclwiLCB7XG4gICAgICByZWY6IFZhbGlkYXRpb25FcnJvcixcbiAgICAgIGNvZGU6IF9gcmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiKS5kZWZhdWx0YCxcbiAgICB9KVxuICB9XG5cbiAgY29uc3QgdmFsaWRhdGVOYW1lID0gZ2VuLnNjb3BlTmFtZShcInZhbGlkYXRlXCIpXG4gIHNjaC52YWxpZGF0ZU5hbWUgPSB2YWxpZGF0ZU5hbWVcblxuICBjb25zdCBzY2hlbWFDeHQ6IFNjaGVtYUN4dCA9IHtcbiAgICBnZW4sXG4gICAgYWxsRXJyb3JzOiB0aGlzLm9wdHMuYWxsRXJyb3JzLFxuICAgIGRhdGE6IE4uZGF0YSxcbiAgICBwYXJlbnREYXRhOiBOLnBhcmVudERhdGEsXG4gICAgcGFyZW50RGF0YVByb3BlcnR5OiBOLnBhcmVudERhdGFQcm9wZXJ0eSxcbiAgICBkYXRhTmFtZXM6IFtOLmRhdGFdLFxuICAgIGRhdGFQYXRoQXJyOiBbbmlsXSwgLy8gVE9ETyBjYW4gaXRzIGxlbmd0aCBiZSB1c2VkIGFzIGRhdGFMZXZlbCBpZiBuaWwgaXMgcmVtb3ZlZD9cbiAgICBkYXRhTGV2ZWw6IDAsXG4gICAgZGF0YVR5cGVzOiBbXSxcbiAgICBkZWZpbmVkUHJvcGVydGllczogbmV3IFNldDxzdHJpbmc+KCksXG4gICAgdG9wU2NoZW1hUmVmOiBnZW4uc2NvcGVWYWx1ZShcbiAgICAgIFwic2NoZW1hXCIsXG4gICAgICB0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWVcbiAgICAgICAgPyB7cmVmOiBzY2guc2NoZW1hLCBjb2RlOiBzdHJpbmdpZnkoc2NoLnNjaGVtYSl9XG4gICAgICAgIDoge3JlZjogc2NoLnNjaGVtYX1cbiAgICApLFxuICAgIHZhbGlkYXRlTmFtZSxcbiAgICBWYWxpZGF0aW9uRXJyb3I6IF9WYWxpZGF0aW9uRXJyb3IsXG4gICAgc2NoZW1hOiBzY2guc2NoZW1hLFxuICAgIHNjaGVtYUVudjogc2NoLFxuICAgIHJvb3RJZCxcbiAgICBiYXNlSWQ6IHNjaC5iYXNlSWQgfHwgcm9vdElkLFxuICAgIHNjaGVtYVBhdGg6IG5pbCxcbiAgICBlcnJTY2hlbWFQYXRoOiBzY2guc2NoZW1hUGF0aCB8fCAodGhpcy5vcHRzLmp0ZCA/IFwiXCIgOiBcIiNcIiksXG4gICAgZXJyb3JQYXRoOiBfYFwiXCJgLFxuICAgIG9wdHM6IHRoaXMub3B0cyxcbiAgICBzZWxmOiB0aGlzLFxuICB9XG5cbiAgbGV0IHNvdXJjZUNvZGU6IHN0cmluZyB8IHVuZGVmaW5lZFxuICB0cnkge1xuICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5hZGQoc2NoKVxuICAgIHZhbGlkYXRlRnVuY3Rpb25Db2RlKHNjaGVtYUN4dClcbiAgICBnZW4ub3B0aW1pemUodGhpcy5vcHRzLmNvZGUub3B0aW1pemUpXG4gICAgLy8gZ2VuLm9wdGltaXplKDEpXG4gICAgY29uc3QgdmFsaWRhdGVDb2RlID0gZ2VuLnRvU3RyaW5nKClcbiAgICBzb3VyY2VDb2RlID0gYCR7Z2VuLnNjb3BlUmVmcyhOLnNjb3BlKX1yZXR1cm4gJHt2YWxpZGF0ZUNvZGV9YFxuICAgIC8vIGNvbnNvbGUubG9nKChjb2RlU2l6ZSArPSBzb3VyY2VDb2RlLmxlbmd0aCksIChub2RlQ291bnQgKz0gZ2VuLm5vZGVDb3VudCkpXG4gICAgaWYgKHRoaXMub3B0cy5jb2RlLnByb2Nlc3MpIHNvdXJjZUNvZGUgPSB0aGlzLm9wdHMuY29kZS5wcm9jZXNzKHNvdXJjZUNvZGUsIHNjaClcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUpXG4gICAgY29uc3QgbWFrZVZhbGlkYXRlID0gbmV3IEZ1bmN0aW9uKGAke04uc2VsZn1gLCBgJHtOLnNjb3BlfWAsIHNvdXJjZUNvZGUpXG4gICAgY29uc3QgdmFsaWRhdGU6IEFueVZhbGlkYXRlRnVuY3Rpb24gPSBtYWtlVmFsaWRhdGUodGhpcywgdGhpcy5zY29wZS5nZXQoKSlcbiAgICB0aGlzLnNjb3BlLnZhbHVlKHZhbGlkYXRlTmFtZSwge3JlZjogdmFsaWRhdGV9KVxuXG4gICAgdmFsaWRhdGUuZXJyb3JzID0gbnVsbFxuICAgIHZhbGlkYXRlLnNjaGVtYSA9IHNjaC5zY2hlbWFcbiAgICB2YWxpZGF0ZS5zY2hlbWFFbnYgPSBzY2hcbiAgICBpZiAoc2NoLiRhc3luYykgKHZhbGlkYXRlIGFzIEFzeW5jVmFsaWRhdGVGdW5jdGlvbikuJGFzeW5jID0gdHJ1ZVxuICAgIGlmICh0aGlzLm9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUpIHtcbiAgICAgIHZhbGlkYXRlLnNvdXJjZSA9IHt2YWxpZGF0ZU5hbWUsIHZhbGlkYXRlQ29kZSwgc2NvcGVWYWx1ZXM6IGdlbi5fdmFsdWVzfVxuICAgIH1cbiAgICBpZiAodGhpcy5vcHRzLnVuZXZhbHVhdGVkKSB7XG4gICAgICBjb25zdCB7cHJvcHMsIGl0ZW1zfSA9IHNjaGVtYUN4dFxuICAgICAgdmFsaWRhdGUuZXZhbHVhdGVkID0ge1xuICAgICAgICBwcm9wczogcHJvcHMgaW5zdGFuY2VvZiBOYW1lID8gdW5kZWZpbmVkIDogcHJvcHMsXG4gICAgICAgIGl0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIE5hbWUgPyB1bmRlZmluZWQgOiBpdGVtcyxcbiAgICAgICAgZHluYW1pY1Byb3BzOiBwcm9wcyBpbnN0YW5jZW9mIE5hbWUsXG4gICAgICAgIGR5bmFtaWNJdGVtczogaXRlbXMgaW5zdGFuY2VvZiBOYW1lLFxuICAgICAgfVxuICAgICAgaWYgKHZhbGlkYXRlLnNvdXJjZSkgdmFsaWRhdGUuc291cmNlLmV2YWx1YXRlZCA9IHN0cmluZ2lmeSh2YWxpZGF0ZS5ldmFsdWF0ZWQpXG4gICAgfVxuICAgIHNjaC52YWxpZGF0ZSA9IHZhbGlkYXRlXG4gICAgcmV0dXJuIHNjaFxuICB9IGNhdGNoIChlKSB7XG4gICAgZGVsZXRlIHNjaC52YWxpZGF0ZVxuICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVOYW1lXG4gICAgaWYgKHNvdXJjZUNvZGUpIHRoaXMubG9nZ2VyLmVycm9yKFwiRXJyb3IgY29tcGlsaW5nIHNjaGVtYSwgZnVuY3Rpb24gY29kZTpcIiwgc291cmNlQ29kZSlcbiAgICAvLyBjb25zb2xlLmxvZyhcIlxcblxcblxcbiAqKiogXFxuXCIsIHNvdXJjZUNvZGUsIHRoaXMub3B0cylcbiAgICB0aHJvdyBlXG4gIH0gZmluYWxseSB7XG4gICAgdGhpcy5fY29tcGlsYXRpb25zLmRlbGV0ZShzY2gpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVSZWYoXG4gIHRoaXM6IEFqdixcbiAgcm9vdDogU2NoZW1hRW52LFxuICBiYXNlSWQ6IHN0cmluZyxcbiAgcmVmOiBzdHJpbmdcbik6IEFueVNjaGVtYSB8IFNjaGVtYUVudiB8IHVuZGVmaW5lZCB7XG4gIHJlZiA9IHJlc29sdmVVcmwodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHJlZilcbiAgY29uc3Qgc2NoT3JGdW5jID0gcm9vdC5yZWZzW3JlZl1cbiAgaWYgKHNjaE9yRnVuYykgcmV0dXJuIHNjaE9yRnVuY1xuXG4gIGxldCBfc2NoID0gcmVzb2x2ZS5jYWxsKHRoaXMsIHJvb3QsIHJlZilcbiAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHNjaGVtYSA9IHJvb3QubG9jYWxSZWZzPy5bcmVmXSAvLyBUT0RPIG1heWJlIGxvY2FsUmVmcyBzaG91bGQgaG9sZCBTY2hlbWFFbnZcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHNjaGVtYSkgX3NjaCA9IG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZH0pXG4gIH1cblxuICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgcmV0dXJuIChyb290LnJlZnNbcmVmXSA9IGlubGluZU9yQ29tcGlsZS5jYWxsKHRoaXMsIF9zY2gpKVxufVxuXG5mdW5jdGlvbiBpbmxpbmVPckNvbXBpbGUodGhpczogQWp2LCBzY2g6IFNjaGVtYUVudik6IEFueVNjaGVtYSB8IFNjaGVtYUVudiB7XG4gIGlmIChpbmxpbmVSZWYoc2NoLnNjaGVtYSwgdGhpcy5vcHRzLmlubGluZVJlZnMpKSByZXR1cm4gc2NoLnNjaGVtYVxuICByZXR1cm4gc2NoLnZhbGlkYXRlID8gc2NoIDogY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaClcbn1cblxuLy8gSW5kZXggb2Ygc2NoZW1hIGNvbXBpbGF0aW9uIGluIHRoZSBjdXJyZW50bHkgY29tcGlsZWQgbGlzdFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbXBpbGluZ1NjaGVtYSh0aGlzOiBBanYsIHNjaEVudjogU2NoZW1hRW52KTogU2NoZW1hRW52IHwgdm9pZCB7XG4gIGZvciAoY29uc3Qgc2NoIG9mIHRoaXMuX2NvbXBpbGF0aW9ucykge1xuICAgIGlmIChzYW1lU2NoZW1hRW52KHNjaCwgc2NoRW52KSkgcmV0dXJuIHNjaFxuICB9XG59XG5cbmZ1bmN0aW9uIHNhbWVTY2hlbWFFbnYoczE6IFNjaGVtYUVudiwgczI6IFNjaGVtYUVudik6IGJvb2xlYW4ge1xuICByZXR1cm4gczEuc2NoZW1hID09PSBzMi5zY2hlbWEgJiYgczEucm9vdCA9PT0gczIucm9vdCAmJiBzMS5iYXNlSWQgPT09IHMyLmJhc2VJZFxufVxuXG4vLyByZXNvbHZlIGFuZCBjb21waWxlIHRoZSByZWZlcmVuY2VzICgkcmVmKVxuLy8gVE9ETyByZXR1cm5zIEFueVNjaGVtYU9iamVjdCAoaWYgdGhlIHNjaGVtYSBjYW4gYmUgaW5saW5lZCkgb3IgdmFsaWRhdGlvbiBmdW5jdGlvblxuZnVuY3Rpb24gcmVzb2x2ZShcbiAgdGhpczogQWp2LFxuICByb290OiBTY2hlbWFFbnYsIC8vIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb290IHNjaGVtYSBmb3IgdGhlIGN1cnJlbnQgc2NoZW1hXG4gIHJlZjogc3RyaW5nIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pOiBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICBsZXQgc2NoXG4gIHdoaWxlICh0eXBlb2YgKHNjaCA9IHRoaXMucmVmc1tyZWZdKSA9PSBcInN0cmluZ1wiKSByZWYgPSBzY2hcbiAgcmV0dXJuIHNjaCB8fCB0aGlzLnNjaGVtYXNbcmVmXSB8fCByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgcmVmKVxufVxuXG4vLyBSZXNvbHZlIHNjaGVtYSwgaXRzIHJvb3QgYW5kIGJhc2VJZFxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVTY2hlbWEoXG4gIHRoaXM6IEFqdixcbiAgcm9vdDogU2NoZW1hRW52LCAvLyByb290IG9iamVjdCB3aXRoIHByb3BlcnRpZXMgc2NoZW1hLCByZWZzIFRPRE8gYmVsb3cgU2NoZW1hRW52IGlzIGFzc2lnbmVkIHRvIGl0XG4gIHJlZjogc3RyaW5nIC8vIHJlZmVyZW5jZSB0byByZXNvbHZlXG4pOiBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICBjb25zdCBwID0gdGhpcy5vcHRzLnVyaVJlc29sdmVyLnBhcnNlKHJlZilcbiAgY29uc3QgcmVmUGF0aCA9IF9nZXRGdWxsUGF0aCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHApXG4gIGxldCBiYXNlSWQgPSBnZXRGdWxsUGF0aCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIHJvb3QuYmFzZUlkLCB1bmRlZmluZWQpXG4gIC8vIFRPRE8gYE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwYCBzaG91bGQgbm90IGJlIG5lZWRlZCAtIGJ1dCByZW1vdmluZyBicmVha3MgMiB0ZXN0c1xuICBpZiAoT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDAgJiYgcmVmUGF0aCA9PT0gYmFzZUlkKSB7XG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgcm9vdClcbiAgfVxuXG4gIGNvbnN0IGlkID0gbm9ybWFsaXplSWQocmVmUGF0aClcbiAgY29uc3Qgc2NoT3JSZWYgPSB0aGlzLnJlZnNbaWRdIHx8IHRoaXMuc2NoZW1hc1tpZF1cbiAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3Qgc2NoID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHNjaE9yUmVmKVxuICAgIGlmICh0eXBlb2Ygc2NoPy5zY2hlbWEgIT09IFwib2JqZWN0XCIpIHJldHVyblxuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaClcbiAgfVxuXG4gIGlmICh0eXBlb2Ygc2NoT3JSZWY/LnNjaGVtYSAhPT0gXCJvYmplY3RcIikgcmV0dXJuXG4gIGlmICghc2NoT3JSZWYudmFsaWRhdGUpIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2hPclJlZilcbiAgaWYgKGlkID09PSBub3JtYWxpemVJZChyZWYpKSB7XG4gICAgY29uc3Qge3NjaGVtYX0gPSBzY2hPclJlZlxuICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICBjb25zdCBzY2hJZCA9IHNjaGVtYVtzY2hlbWFJZF1cbiAgICBpZiAoc2NoSWQpIGJhc2VJZCA9IHJlc29sdmVVcmwodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaElkKVxuICAgIHJldHVybiBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICB9XG4gIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHNjaE9yUmVmKVxufVxuXG5jb25zdCBQUkVWRU5UX1NDT1BFX0NIQU5HRSA9IG5ldyBTZXQoW1xuICBcInByb3BlcnRpZXNcIixcbiAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICBcImVudW1cIixcbiAgXCJkZXBlbmRlbmNpZXNcIixcbiAgXCJkZWZpbml0aW9uc1wiLFxuXSlcblxuZnVuY3Rpb24gZ2V0SnNvblBvaW50ZXIoXG4gIHRoaXM6IEFqdixcbiAgcGFyc2VkUmVmOiBVUklDb21wb25lbnQsXG4gIHtiYXNlSWQsIHNjaGVtYSwgcm9vdH06IFNjaGVtYUVudlxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgaWYgKHBhcnNlZFJlZi5mcmFnbWVudD8uWzBdICE9PSBcIi9cIikgcmV0dXJuXG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJzZWRSZWYuZnJhZ21lbnQuc2xpY2UoMSkuc3BsaXQoXCIvXCIpKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSByZXR1cm5cbiAgICBjb25zdCBwYXJ0U2NoZW1hID0gc2NoZW1hW3VuZXNjYXBlRnJhZ21lbnQocGFydCldXG4gICAgaWYgKHBhcnRTY2hlbWEgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgc2NoZW1hID0gcGFydFNjaGVtYVxuICAgIC8vIFRPRE8gUFJFVkVOVF9TQ09QRV9DSEFOR0UgY291bGQgYmUgZGVmaW5lZCBpbiBrZXl3b3JkIGRlZj9cbiAgICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIgJiYgc2NoZW1hW3RoaXMub3B0cy5zY2hlbWFJZF1cbiAgICBpZiAoIVBSRVZFTlRfU0NPUEVfQ0hBTkdFLmhhcyhwYXJ0KSAmJiBzY2hJZCkge1xuICAgICAgYmFzZUlkID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpXG4gICAgfVxuICB9XG4gIGxldCBlbnY6IFNjaGVtYUVudiB8IHVuZGVmaW5lZFxuICBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIiAmJiBzY2hlbWEuJHJlZiAmJiAhc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCB0aGlzLlJVTEVTKSkge1xuICAgIGNvbnN0ICRyZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hlbWEuJHJlZilcbiAgICBlbnYgPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgJHJlZilcbiAgfVxuICAvLyBldmVuIHRob3VnaCByZXNvbHV0aW9uIGZhaWxlZCB3ZSBuZWVkIHRvIHJldHVybiBTY2hlbWFFbnYgdG8gdGhyb3cgZXhjZXB0aW9uXG4gIC8vIHNvIHRoYXQgY29tcGlsZUFzeW5jIGxvYWRzIG1pc3Npbmcgc2NoZW1hLlxuICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gIGVudiA9IGVudiB8fCBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICBpZiAoZW52LnNjaGVtYSAhPT0gZW52LnJvb3Quc2NoZW1hKSByZXR1cm4gZW52XG4gIHJldHVybiB1bmRlZmluZWRcbn1cbiIsICJ7XG4gIFwiJGlkXCI6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJNZXRhLXNjaGVtYSBmb3IgJGRhdGEgcmVmZXJlbmNlIChKU09OIEFueVNjaGVtYSBleHRlbnNpb24gcHJvcG9zYWwpXCIsXG4gIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICBcInJlcXVpcmVkXCI6IFtcIiRkYXRhXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGRhdGFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImFueU9mXCI6IFt7XCJmb3JtYXRcIjogXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIn0sIHtcImZvcm1hdFwiOiBcImpzb24tcG9pbnRlclwifV1cbiAgICB9XG4gIH0sXG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjogZmFsc2Vcbn1cbiIsICIndXNlIHN0cmljdCdcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzVVVJRCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eW1xcZGEtZl17OH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17NH0tW1xcZGEtZl17MTJ9JC9pdSlcblxuLyoqIEB0eXBlIHsodmFsdWU6IHN0cmluZykgPT4gYm9vbGVhbn0gKi9cbmNvbnN0IGlzSVB2NCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKSQvdSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGlucHV0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQgKGlucHV0KSB7XG4gIGxldCBhY2MgPSAnJ1xuICBsZXQgY29kZSA9IDBcbiAgbGV0IGkgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoY29kZSA9PT0gNDgpIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGlmICghKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gNzApIHx8IChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSkpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBhY2MgKz0gaW5wdXRbaV1cbiAgICBicmVha1xuICB9XG5cbiAgZm9yIChpICs9IDE7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBpbnB1dFtpXS5jaGFyQ29kZUF0KDApXG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICB9XG4gIHJldHVybiBhY2Ncbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBHZXRJUFY2UmVzdWx0XG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGVycm9yIC0gSW5kaWNhdGVzIGlmIHRoZXJlIHdhcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYWRkcmVzcyAtIFRoZSBwYXJzZWQgSVB2NiBhZGRyZXNzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFt6b25lXSAtIFRoZSB6b25lIGlkZW50aWZpZXIsIGlmIHByZXNlbnQuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5jb25zdCBub25TaW1wbGVEb21haW4gPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvW14hXCIkJicoKSorLFxcLS47PV9gYS16e31+XS91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYnVmZmVyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUlzWm9uZSAoYnVmZmVyKSB7XG4gIGJ1ZmZlci5sZW5ndGggPSAwXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYWRkcmVzc1xuICogQHBhcmFtIHtHZXRJUFY2UmVzdWx0fSBvdXRwdXRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSGV4dGV0cyAoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpIHtcbiAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBjb25zdCBoZXggPSBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKVxuICAgIGlmIChoZXggIT09ICcnKSB7XG4gICAgICBhZGRyZXNzLnB1c2goaGV4KVxuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dFxuICogQHJldHVybnMge0dldElQVjZSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIGdldElQVjYgKGlucHV0KSB7XG4gIGxldCB0b2tlbkNvdW50ID0gMFxuICBjb25zdCBvdXRwdXQgPSB7IGVycm9yOiBmYWxzZSwgYWRkcmVzczogJycsIHpvbmU6ICcnIH1cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBhZGRyZXNzID0gW11cbiAgLyoqIEB0eXBlIHtBcnJheTxzdHJpbmc+fSAqL1xuICBjb25zdCBidWZmZXIgPSBbXVxuICBsZXQgZW5kaXB2NkVuY291bnRlcmVkID0gZmFsc2VcbiAgbGV0IGVuZElwdjYgPSBmYWxzZVxuXG4gIGxldCBjb25zdW1lID0gY29uc3VtZUhleHRldHNcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY3Vyc29yID0gaW5wdXRbaV1cbiAgICBpZiAoY3Vyc29yID09PSAnWycgfHwgY3Vyc29yID09PSAnXScpIHsgY29udGludWUgfVxuICAgIGlmIChjdXJzb3IgPT09ICc6Jykge1xuICAgICAgaWYgKGVuZGlwdjZFbmNvdW50ZXJlZCA9PT0gdHJ1ZSkge1xuICAgICAgICBlbmRJcHY2ID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICBpZiAoKyt0b2tlbkNvdW50ID4gNykge1xuICAgICAgICAvLyBub3QgdmFsaWRcbiAgICAgICAgb3V0cHV0LmVycm9yID0gdHJ1ZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaWYgKGkgPiAwICYmIGlucHV0W2kgLSAxXSA9PT0gJzonKSB7XG4gICAgICAgIGVuZGlwdjZFbmNvdW50ZXJlZCA9IHRydWVcbiAgICAgIH1cbiAgICAgIGFkZHJlc3MucHVzaCgnOicpXG4gICAgICBjb250aW51ZVxuICAgIH0gZWxzZSBpZiAoY3Vyc29yID09PSAnJScpIHtcbiAgICAgIGlmICghY29uc3VtZShidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkpIHsgYnJlYWsgfVxuICAgICAgLy8gc3dpdGNoIHRvIHpvbmUgZGV0ZWN0aW9uXG4gICAgICBjb25zdW1lID0gY29uc3VtZUlzWm9uZVxuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIucHVzaChjdXJzb3IpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgfVxuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChjb25zdW1lID09PSBjb25zdW1lSXNab25lKSB7XG4gICAgICBvdXRwdXQuem9uZSA9IGJ1ZmZlci5qb2luKCcnKVxuICAgIH0gZWxzZSBpZiAoZW5kSXB2Nikge1xuICAgICAgYWRkcmVzcy5wdXNoKGJ1ZmZlci5qb2luKCcnKSlcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkcmVzcy5wdXNoKHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpKVxuICAgIH1cbiAgfVxuICBvdXRwdXQuYWRkcmVzcyA9IGFkZHJlc3Muam9pbignJylcbiAgcmV0dXJuIG91dHB1dFxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE5vcm1hbGl6ZUlQdjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob3N0IC0gVGhlIG5vcm1hbGl6ZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbZXNjYXBlZEhvc3RdIC0gVGhlIGVzY2FwZWQgaG9zdC5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gaXNJUFY2IC0gSW5kaWNhdGVzIGlmIHRoZSBob3N0IGlzIGFuIElQdjYgYWRkcmVzcy5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBob3N0XG4gKiBAcmV0dXJucyB7Tm9ybWFsaXplSVB2NlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSVB2NiAoaG9zdCkge1xuICBpZiAoZmluZFRva2VuKGhvc3QsICc6JykgPCAyKSB7IHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfSB9XG4gIGNvbnN0IGlwdjYgPSBnZXRJUFY2KGhvc3QpXG5cbiAgaWYgKCFpcHY2LmVycm9yKSB7XG4gICAgbGV0IG5ld0hvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBsZXQgZXNjYXBlZEhvc3QgPSBpcHY2LmFkZHJlc3NcbiAgICBpZiAoaXB2Ni56b25lKSB7XG4gICAgICBuZXdIb3N0ICs9ICclJyArIGlwdjYuem9uZVxuICAgICAgZXNjYXBlZEhvc3QgKz0gJyUyNScgKyBpcHY2LnpvbmVcbiAgICB9XG4gICAgcmV0dXJuIHsgaG9zdDogbmV3SG9zdCwgaXNJUFY2OiB0cnVlLCBlc2NhcGVkSG9zdCB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9rZW5cbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGZpbmRUb2tlbiAoc3RyLCB0b2tlbikge1xuICBsZXQgaW5kID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHJbaV0gPT09IHRva2VuKSBpbmQrK1xuICB9XG4gIHJldHVybiBpbmRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxuICogQHJldHVybnMge3N0cmluZ31cbiAqXG4gKiBAc2VlIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjMzk4NiNzZWN0aW9uLTUuMi40XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZURvdFNlZ21lbnRzIChwYXRoKSB7XG4gIGxldCBpbnB1dCA9IHBhdGhcbiAgY29uc3Qgb3V0cHV0ID0gW11cbiAgbGV0IG5leHRTbGFzaCA9IC0xXG4gIGxldCBsZW4gPSAwXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gIHdoaWxlIChsZW4gPSBpbnB1dC5sZW5ndGgpIHtcbiAgICBpZiAobGVuID09PSAxKSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcuJykge1xuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIGlmIChpbnB1dCA9PT0gJy8nKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dC5wdXNoKGlucHV0KVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICBpZiAoaW5wdXRbMF0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzBdID09PSAnLycpIHtcbiAgICAgICAgaWYgKGlucHV0WzFdID09PSAnLicgfHwgaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDMpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy8uLicpIHtcbiAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBvdXRwdXQucG9wKClcbiAgICAgICAgfVxuICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzJdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsyXSA9PT0gJy4nKSB7XG4gICAgICAgICAgaWYgKGlucHV0WzNdID09PSAnLycpIHtcbiAgICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMylcbiAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSdWxlIDJFOiBNb3ZlIG5vcm1hbCBwYXRoIHNlZ21lbnQgdG8gb3V0cHV0XG4gICAgaWYgKChuZXh0U2xhc2ggPSBpbnB1dC5pbmRleE9mKCcvJywgMSkpID09PSAtMSkge1xuICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICBicmVha1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dC5zbGljZSgwLCBuZXh0U2xhc2gpKVxuICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShuZXh0U2xhc2gpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVzY1xuICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nIChjb21wb25lbnQsIGVzYykge1xuICBjb25zdCBmdW5jID0gZXNjICE9PSB0cnVlID8gZXNjYXBlIDogdW5lc2NhcGVcbiAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5zY2hlbWUgPSBmdW5jKGNvbXBvbmVudC5zY2hlbWUpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnVzZXJpbmZvID0gZnVuYyhjb21wb25lbnQudXNlcmluZm8pXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuaG9zdCA9IGZ1bmMoY29tcG9uZW50Lmhvc3QpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucGF0aCA9IGZ1bmMoY29tcG9uZW50LnBhdGgpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnF1ZXJ5ID0gZnVuYyhjb21wb25lbnQucXVlcnkpXG4gIH1cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LmZyYWdtZW50ID0gZnVuYyhjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcmV0dXJucyB7c3RyaW5nfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gcmVjb21wb3NlQXV0aG9yaXR5IChjb21wb25lbnQpIHtcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQudXNlcmluZm8pXG4gICAgdXJpVG9rZW5zLnB1c2goJ0AnKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgaG9zdCA9IHVuZXNjYXBlKGNvbXBvbmVudC5ob3N0KVxuICAgIGlmICghaXNJUHY0KGhvc3QpKSB7XG4gICAgICBjb25zdCBpcFY2cmVzID0gbm9ybWFsaXplSVB2Nihob3N0KVxuICAgICAgaWYgKGlwVjZyZXMuaXNJUFY2ID09PSB0cnVlKSB7XG4gICAgICAgIGhvc3QgPSBgWyR7aXBWNnJlcy5lc2NhcGVkSG9zdH1dYFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaG9zdCA9IGNvbXBvbmVudC5ob3N0XG4gICAgICB9XG4gICAgfVxuICAgIHVyaVRva2Vucy5wdXNoKGhvc3QpXG4gIH1cblxuICBpZiAodHlwZW9mIGNvbXBvbmVudC5wb3J0ID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJzonKVxuICAgIHVyaVRva2Vucy5wdXNoKFN0cmluZyhjb21wb25lbnQucG9ydCkpXG4gIH1cblxuICByZXR1cm4gdXJpVG9rZW5zLmxlbmd0aCA/IHVyaVRva2Vucy5qb2luKCcnKSA6IHVuZGVmaW5lZFxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIG5vblNpbXBsZURvbWFpbixcbiAgcmVjb21wb3NlQXV0aG9yaXR5LFxuICBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyxcbiAgcmVtb3ZlRG90U2VnbWVudHMsXG4gIGlzSVB2NCxcbiAgaXNVVUlELFxuICBub3JtYWxpemVJUHY2LFxuICBzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWRcbn1cbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgeyBpc1VVSUQgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKVxuY29uc3QgVVJOX1JFRyA9IC8oW1xcZGEtel1bXFxkXFwtYS16XXswLDMxfSk6KCg/OltcXHchJCcoKSorLFxcLS46Oz1AXXwlW1xcZGEtZl17Mn0pKykvaXVcblxuY29uc3Qgc3VwcG9ydGVkU2NoZW1lTmFtZXMgPSAvKiogQHR5cGUge2NvbnN0fSAqLyAoWydodHRwJywgJ2h0dHBzJywgJ3dzJyxcbiAgJ3dzcycsICd1cm4nLCAndXJuOnV1aWQnXSlcblxuLyoqIEB0eXBlZGVmIHtzdXBwb3J0ZWRTY2hlbWVOYW1lc1tudW1iZXJdfSBTY2hlbWVOYW1lICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtuYW1lIGlzIFNjaGVtZU5hbWV9XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRTY2hlbWVOYW1lIChuYW1lKSB7XG4gIHJldHVybiBzdXBwb3J0ZWRTY2hlbWVOYW1lcy5pbmRleE9mKC8qKiBAdHlwZSB7Kn0gKi8gKG5hbWUpKSAhPT0gLTFcbn1cblxuLyoqXG4gKiBAY2FsbGJhY2sgU2NoZW1lRm5cbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gY29tcG9uZW50XG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFNjaGVtZUhhbmRsZXJcbiAqIEBwcm9wZXJ0eSB7U2NoZW1lTmFtZX0gc2NoZW1lIC0gVGhlIHNjaGVtZSBuYW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZG9tYWluSG9zdF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBkb21haW4gaG9zdHMuXG4gKiBAcHJvcGVydHkge1NjaGVtZUZufSBwYXJzZSAtIEZ1bmN0aW9uIHRvIHBhcnNlIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHNlcmlhbGl6ZSAtIEZ1bmN0aW9uIHRvIHNlcmlhbGl6ZSB0aGUgVVJJIGNvbXBvbmVudCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtza2lwTm9ybWFsaXplXSAtIEluZGljYXRlcyBpZiBub3JtYWxpemF0aW9uIHNob3VsZCBiZSBza2lwcGVkIGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2Fic29sdXRlUGF0aF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSB1c2VzIGFic29sdXRlIHBhdGhzLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbdW5pY29kZVN1cHBvcnRdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgc3VwcG9ydHMgVW5pY29kZS5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gd3NDb21wb25lbnRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiB3c0lzU2VjdXJlICh3c0NvbXBvbmVudCkge1xuICBpZiAod3NDb21wb25lbnQuc2VjdXJlID09PSB0cnVlKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAod3NDb21wb25lbnQuc2NoZW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHdzQ29tcG9uZW50LnNjaGVtZS5sZW5ndGggPT09IDMgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMF0gPT09ICd3JyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMF0gPT09ICdXJykgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMV0gPT09ICdzJyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMV0gPT09ICdTJykgJiZcbiAgICAgICh3c0NvbXBvbmVudC5zY2hlbWVbMl0gPT09ICdzJyB8fCB3c0NvbXBvbmVudC5zY2hlbWVbMl0gPT09ICdTJylcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIGh0dHBQYXJzZSAoY29tcG9uZW50KSB7XG4gIGlmICghY29tcG9uZW50Lmhvc3QpIHtcbiAgICBjb21wb25lbnQuZXJyb3IgPSBjb21wb25lbnQuZXJyb3IgfHwgJ0hUVFAgVVJJcyBtdXN0IGhhdmUgYSBob3N0LidcbiAgfVxuXG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIGh0dHBTZXJpYWxpemUgKGNvbXBvbmVudCkge1xuICBjb25zdCBzZWN1cmUgPSBTdHJpbmcoY29tcG9uZW50LnNjaGVtZSkudG9Mb3dlckNhc2UoKSA9PT0gJ2h0dHBzJ1xuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmIChjb21wb25lbnQucG9ydCA9PT0gKHNlY3VyZSA/IDQ0MyA6IDgwKSB8fCBjb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICBjb21wb25lbnQucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gbm9ybWFsaXplIHRoZSBlbXB0eSBwYXRoXG4gIGlmICghY29tcG9uZW50LnBhdGgpIHtcbiAgICBjb21wb25lbnQucGF0aCA9ICcvJ1xuICB9XG5cbiAgLy8gTk9URTogV2UgZG8gbm90IHBhcnNlIHF1ZXJ5IHN0cmluZ3MgZm9yIEhUVFAgVVJJc1xuICAvLyBhcyBXV1cgRm9ybSBVcmwgRW5jb2RlZCBxdWVyeSBzdHJpbmdzIGFyZSBwYXJ0IG9mIHRoZSBIVE1MNCsgc3BlYyxcbiAgLy8gYW5kIG5vdCB0aGUgSFRUUCBzcGVjLlxuXG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHdzUGFyc2UgKHdzQ29tcG9uZW50KSB7XG4vLyBpbmRpY2F0ZSBpZiB0aGUgc2VjdXJlIGZsYWcgaXMgc2V0XG4gIHdzQ29tcG9uZW50LnNlY3VyZSA9IHdzSXNTZWN1cmUod3NDb21wb25lbnQpXG5cbiAgLy8gY29uc3RydWN0IHJlc291Y2UgbmFtZVxuICB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUgPSAod3NDb21wb25lbnQucGF0aCB8fCAnLycpICsgKHdzQ29tcG9uZW50LnF1ZXJ5ID8gJz8nICsgd3NDb21wb25lbnQucXVlcnkgOiAnJylcbiAgd3NDb21wb25lbnQucGF0aCA9IHVuZGVmaW5lZFxuICB3c0NvbXBvbmVudC5xdWVyeSA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NTZXJpYWxpemUgKHdzQ29tcG9uZW50KSB7XG4vLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAod3NDb21wb25lbnQucG9ydCA9PT0gKHdzSXNTZWN1cmUod3NDb21wb25lbnQpID8gNDQzIDogODApIHx8IHdzQ29tcG9uZW50LnBvcnQgPT09ICcnKSB7XG4gICAgd3NDb21wb25lbnQucG9ydCA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZW5zdXJlIHNjaGVtZSBtYXRjaGVzIHNlY3VyZSBmbGFnXG4gIGlmICh0eXBlb2Ygd3NDb21wb25lbnQuc2VjdXJlID09PSAnYm9vbGVhbicpIHtcbiAgICB3c0NvbXBvbmVudC5zY2hlbWUgPSAod3NDb21wb25lbnQuc2VjdXJlID8gJ3dzcycgOiAnd3MnKVxuICAgIHdzQ29tcG9uZW50LnNlY3VyZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gcmVjb25zdHJ1Y3QgcGF0aCBmcm9tIHJlc291cmNlIG5hbWVcbiAgaWYgKHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSkge1xuICAgIGNvbnN0IFtwYXRoLCBxdWVyeV0gPSB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUuc3BsaXQoJz8nKVxuICAgIHdzQ29tcG9uZW50LnBhdGggPSAocGF0aCAmJiBwYXRoICE9PSAnLycgPyBwYXRoIDogdW5kZWZpbmVkKVxuICAgIHdzQ29tcG9uZW50LnF1ZXJ5ID0gcXVlcnlcbiAgICB3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGZvcmJpZCBmcmFnbWVudCBjb21wb25lbnRcbiAgd3NDb21wb25lbnQuZnJhZ21lbnQgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVyblBhcnNlICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKCF1cm5Db21wb25lbnQucGF0aCkge1xuICAgIHVybkNvbXBvbmVudC5lcnJvciA9ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQnXG4gICAgcmV0dXJuIHVybkNvbXBvbmVudFxuICB9XG4gIGNvbnN0IG1hdGNoZXMgPSB1cm5Db21wb25lbnQucGF0aC5tYXRjaChVUk5fUkVHKVxuICBpZiAobWF0Y2hlcykge1xuICAgIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudC5zY2hlbWUgfHwgJ3VybidcbiAgICB1cm5Db21wb25lbnQubmlkID0gbWF0Y2hlc1sxXS50b0xvd2VyQ2FzZSgpXG4gICAgdXJuQ29tcG9uZW50Lm5zcyA9IG1hdGNoZXNbMl1cbiAgICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgdXJuQ29tcG9uZW50Lm5pZH1gXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuICAgIHVybkNvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG5cbiAgICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5wYXJzZSh1cm5Db21wb25lbnQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHVybkNvbXBvbmVudC5lcnJvciA9IHVybkNvbXBvbmVudC5lcnJvciB8fCAnVVJOIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVyblNlcmlhbGl6ZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGlmICh1cm5Db21wb25lbnQubmlkID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VSTiB3aXRob3V0IG5pZCBjYW5ub3QgYmUgc2VyaWFsaXplZCcpXG4gIH1cbiAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICBjb25zdCBuaWQgPSB1cm5Db21wb25lbnQubmlkLnRvTG93ZXJDYXNlKClcbiAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IG5pZH1gXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKHVyblNjaGVtZSlcblxuICBpZiAoc2NoZW1lSGFuZGxlcikge1xuICAgIHVybkNvbXBvbmVudCA9IHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgfVxuXG4gIGNvbnN0IHVyaUNvbXBvbmVudCA9IHVybkNvbXBvbmVudFxuICBjb25zdCBuc3MgPSB1cm5Db21wb25lbnQubnNzXG4gIHVyaUNvbXBvbmVudC5wYXRoID0gYCR7bmlkIHx8IG9wdGlvbnMubmlkfToke25zc31gXG5cbiAgb3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gdXJpQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm51dWlkUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBjb25zdCB1dWlkQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIHV1aWRDb21wb25lbnQudXVpZCA9IHV1aWRDb21wb25lbnQubnNzXG4gIHV1aWRDb21wb25lbnQubnNzID0gdW5kZWZpbmVkXG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmICghdXVpZENvbXBvbmVudC51dWlkIHx8ICFpc1VVSUQodXVpZENvbXBvbmVudC51dWlkKSkpIHtcbiAgICB1dWlkQ29tcG9uZW50LmVycm9yID0gdXVpZENvbXBvbmVudC5lcnJvciB8fCAnVVVJRCBpcyBub3QgdmFsaWQuJ1xuICB9XG5cbiAgcmV0dXJuIHV1aWRDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRTZXJpYWxpemUgKHV1aWRDb21wb25lbnQpIHtcbiAgY29uc3QgdXJuQ29tcG9uZW50ID0gdXVpZENvbXBvbmVudFxuICAvLyBub3JtYWxpemUgVVVJRFxuICB1cm5Db21wb25lbnQubnNzID0gKHV1aWRDb21wb25lbnQudXVpZCB8fCAnJykudG9Mb3dlckNhc2UoKVxuICByZXR1cm4gdXJuQ29tcG9uZW50XG59XG5cbmNvbnN0IGh0dHAgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHAnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IGh0dHBzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICdodHRwcycsXG4gIGRvbWFpbkhvc3Q6IGh0dHAuZG9tYWluSG9zdCxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59KVxuXG5jb25zdCB3cyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnd3MnLFxuICBkb21haW5Ib3N0OiB0cnVlLFxuICBwYXJzZTogd3NQYXJzZSxcbiAgc2VyaWFsaXplOiB3c1NlcmlhbGl6ZVxufSlcblxuY29uc3Qgd3NzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3c3MnLFxuICBkb21haW5Ib3N0OiB3cy5kb21haW5Ib3N0LFxuICBwYXJzZTogd3MucGFyc2UsXG4gIHNlcmlhbGl6ZTogd3Muc2VyaWFsaXplXG59KVxuXG5jb25zdCB1cm4gPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3VybicsXG4gIHBhcnNlOiB1cm5QYXJzZSxcbiAgc2VyaWFsaXplOiB1cm5TZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IHVybnV1aWQgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3Vybjp1dWlkJyxcbiAgcGFyc2U6IHVybnV1aWRQYXJzZSxcbiAgc2VyaWFsaXplOiB1cm51dWlkU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59KVxuXG5jb25zdCBTQ0hFTUVTID0gLyoqIEB0eXBlIHtSZWNvcmQ8U2NoZW1lTmFtZSwgU2NoZW1lSGFuZGxlcj59ICovICh7XG4gIGh0dHAsXG4gIGh0dHBzLFxuICB3cyxcbiAgd3NzLFxuICB1cm4sXG4gICd1cm46dXVpZCc6IHVybnV1aWRcbn0pXG5cbk9iamVjdC5zZXRQcm90b3R5cGVPZihTQ0hFTUVTLCBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gc2NoZW1lXG4gKiBAcmV0dXJucyB7U2NoZW1lSGFuZGxlcnx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGdldFNjaGVtZUhhbmRsZXIgKHNjaGVtZSkge1xuICByZXR1cm4gKFxuICAgIHNjaGVtZSAmJiAoXG4gICAgICBTQ0hFTUVTWy8qKiBAdHlwZSB7U2NoZW1lTmFtZX0gKi8gKHNjaGVtZSldIHx8XG4gICAgICBTQ0hFTUVTWy8qKiBAdHlwZSB7U2NoZW1lTmFtZX0gKi8oc2NoZW1lLnRvTG93ZXJDYXNlKCkpXSlcbiAgKSB8fFxuICAgIHVuZGVmaW5lZFxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd3NJc1NlY3VyZSxcbiAgU0NIRU1FUyxcbiAgaXNWYWxpZFNjaGVtZU5hbWUsXG4gIGdldFNjaGVtZUhhbmRsZXIsXG59XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgbm9ybWFsaXplSVB2NiwgcmVtb3ZlRG90U2VnbWVudHMsIHJlY29tcG9zZUF1dGhvcml0eSwgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsIGlzSVB2NCwgbm9uU2ltcGxlRG9tYWluIH0gPSByZXF1aXJlKCcuL2xpYi91dGlscycpXG5jb25zdCB7IFNDSEVNRVMsIGdldFNjaGVtZUhhbmRsZXIgfSA9IHJlcXVpcmUoJy4vbGliL3NjaGVtZXMnKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gVFxuICogQHBhcmFtIHtUfSB1cmlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7VH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplICh1cmksIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmkgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpID0gLyoqIEB0eXBlIHtUfSAqLyAoc2VyaWFsaXplKHBhcnNlKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmkgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpID0gLyoqIEB0eXBlIHtUfSAqLyAocGFyc2Uoc2VyaWFsaXplKHVyaSwgb3B0aW9ucyksIG9wdGlvbnMpKVxuICB9XG4gIHJldHVybiB1cmlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSSVxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJJXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZSAoYmFzZVVSSSwgcmVsYXRpdmVVUkksIG9wdGlvbnMpIHtcbiAgY29uc3Qgc2NoZW1lbGVzc09wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7IHNjaGVtZTogJ251bGwnIH0sIG9wdGlvbnMpIDogeyBzY2hlbWU6ICdudWxsJyB9XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZUNvbXBvbmVudChwYXJzZShiYXNlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHBhcnNlKHJlbGF0aXZlVVJJLCBzY2hlbWVsZXNzT3B0aW9ucyksIHNjaGVtZWxlc3NPcHRpb25zLCB0cnVlKVxuICBzY2hlbWVsZXNzT3B0aW9ucy5za2lwRXNjYXBlID0gdHJ1ZVxuICByZXR1cm4gc2VyaWFsaXplKHJlc29sdmVkLCBzY2hlbWVsZXNzT3B0aW9ucylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGJhc2VcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gcmVsYXRpdmVcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtza2lwTm9ybWFsaXphdGlvbj1mYWxzZV1cbiAqIEByZXR1cm5zIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29tcG9uZW50IChiYXNlLCByZWxhdGl2ZSwgb3B0aW9ucywgc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9ICovXG4gIGNvbnN0IHRhcmdldCA9IHt9XG4gIGlmICghc2tpcE5vcm1hbGl6YXRpb24pIHtcbiAgICBiYXNlID0gcGFyc2Uoc2VyaWFsaXplKGJhc2UsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgYmFzZSBjb21wb25lbnRcbiAgICByZWxhdGl2ZSA9IHBhcnNlKHNlcmlhbGl6ZShyZWxhdGl2ZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSByZWxhdGl2ZSBjb21wb25lbnRcbiAgfVxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fVxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiByZWxhdGl2ZS5zY2hlbWUpIHtcbiAgICB0YXJnZXQuc2NoZW1lID0gcmVsYXRpdmUuc2NoZW1lXG4gICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICB9IGVsc2Uge1xuICAgIGlmIChyZWxhdGl2ZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5wb3J0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSByZWxhdGl2ZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aCB8fCAnJylcbiAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVsYXRpdmUucGF0aCkge1xuICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aFxuICAgICAgICBpZiAocmVsYXRpdmUucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gYmFzZS5xdWVyeVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocmVsYXRpdmUucGF0aFswXSA9PT0gJy8nKSB7XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICgoYmFzZS51c2VyaW5mbyAhPT0gdW5kZWZpbmVkIHx8IGJhc2UuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IGJhc2UucG9ydCAhPT0gdW5kZWZpbmVkKSAmJiAhYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9ICcvJyArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2UgaWYgKCFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IGJhc2UucGF0aC5zbGljZSgwLCBiYXNlLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHRhcmdldC5wYXRoKVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gICAgICB9XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gYmFzZS5hdXRob3JpdHk7XG4gICAgICB0YXJnZXQudXNlcmluZm8gPSBiYXNlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IGJhc2UuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSBiYXNlLnBvcnRcbiAgICB9XG4gICAgdGFyZ2V0LnNjaGVtZSA9IGJhc2Uuc2NoZW1lXG4gIH1cblxuICB0YXJnZXQuZnJhZ21lbnQgPSByZWxhdGl2ZS5mcmFnbWVudFxuXG4gIHJldHVybiB0YXJnZXRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSB1cmlBXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSB1cmlCXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBvcHRpb25zXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXF1YWwgKHVyaUEsIHVyaUIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiB1cmlBID09PSAnc3RyaW5nJykge1xuICAgIHVyaUEgPSB1bmVzY2FwZSh1cmlBKVxuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQSwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUEsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIGlmICh0eXBlb2YgdXJpQiA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlCID0gdW5lc2NhcGUodXJpQilcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUIsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUIgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlCLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICByZXR1cm4gdXJpQS50b0xvd2VyQ2FzZSgpID09PSB1cmlCLnRvTG93ZXJDYXNlKClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWRvbmx5PGltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudD59IGNtcHRzXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc2VyaWFsaXplIChjbXB0cywgb3B0cykge1xuICBjb25zdCBjb21wb25lbnQgPSB7XG4gICAgaG9zdDogY21wdHMuaG9zdCxcbiAgICBzY2hlbWU6IGNtcHRzLnNjaGVtZSxcbiAgICB1c2VyaW5mbzogY21wdHMudXNlcmluZm8sXG4gICAgcG9ydDogY21wdHMucG9ydCxcbiAgICBwYXRoOiBjbXB0cy5wYXRoLFxuICAgIHF1ZXJ5OiBjbXB0cy5xdWVyeSxcbiAgICBuaWQ6IGNtcHRzLm5pZCxcbiAgICBuc3M6IGNtcHRzLm5zcyxcbiAgICB1dWlkOiBjbXB0cy51dWlkLFxuICAgIGZyYWdtZW50OiBjbXB0cy5mcmFnbWVudCxcbiAgICByZWZlcmVuY2U6IGNtcHRzLnJlZmVyZW5jZSxcbiAgICByZXNvdXJjZU5hbWU6IGNtcHRzLnJlc291cmNlTmFtZSxcbiAgICBzZWN1cmU6IGNtcHRzLnNlY3VyZSxcbiAgICBlcnJvcjogJydcbiAgfVxuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgY29uc3QgdXJpVG9rZW5zID0gW11cblxuICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKG9wdGlvbnMuc2NoZW1lIHx8IGNvbXBvbmVudC5zY2hlbWUpXG5cbiAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgc2VyaWFsaXphdGlvblxuICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSkgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUoY29tcG9uZW50LCBvcHRpb25zKVxuXG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKCFvcHRpb25zLnNraXBFc2NhcGUpIHtcbiAgICAgIGNvbXBvbmVudC5wYXRoID0gZXNjYXBlKGNvbXBvbmVudC5wYXRoKVxuXG4gICAgICBpZiAoY29tcG9uZW50LnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbXBvbmVudC5wYXRoID0gY29tcG9uZW50LnBhdGguc3BsaXQoJyUzQScpLmpvaW4oJzonKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IHVuZXNjYXBlKGNvbXBvbmVudC5wYXRoKVxuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgY29tcG9uZW50LnNjaGVtZSkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudC5zY2hlbWUsICc6JylcbiAgfVxuXG4gIGNvbnN0IGF1dGhvcml0eSA9IHJlY29tcG9zZUF1dGhvcml0eShjb21wb25lbnQpXG4gIGlmIChhdXRob3JpdHkgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvLycpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2goYXV0aG9yaXR5KVxuXG4gICAgaWYgKGNvbXBvbmVudC5wYXRoICYmIGNvbXBvbmVudC5wYXRoWzBdICE9PSAnLycpIHtcbiAgICAgIHVyaVRva2Vucy5wdXNoKCcvJylcbiAgICB9XG4gIH1cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBsZXQgcyA9IGNvbXBvbmVudC5wYXRoXG5cbiAgICBpZiAoIW9wdGlvbnMuYWJzb2x1dGVQYXRoICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci5hYnNvbHV0ZVBhdGgpKSB7XG4gICAgICBzID0gcmVtb3ZlRG90U2VnbWVudHMocylcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBhdXRob3JpdHkgPT09IHVuZGVmaW5lZCAmJlxuICAgICAgc1swXSA9PT0gJy8nICYmXG4gICAgICBzWzFdID09PSAnLydcbiAgICApIHtcbiAgICAgIC8vIGRvbid0IGFsbG93IHRoZSBwYXRoIHRvIHN0YXJ0IHdpdGggXCIvL1wiXG4gICAgICBzID0gJy8lMkYnICsgcy5zbGljZSgyKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKHMpXG4gIH1cblxuICBpZiAoY29tcG9uZW50LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnPycsIGNvbXBvbmVudC5xdWVyeSlcbiAgfVxuXG4gIGlmIChjb21wb25lbnQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCcjJywgY29tcG9uZW50LmZyYWdtZW50KVxuICB9XG4gIHJldHVybiB1cmlUb2tlbnMuam9pbignJylcbn1cblxuY29uc3QgVVJJX1BBUlNFID0gL14oPzooW14jLzo/XSspOik/KD86XFwvXFwvKCg/OihbXiMvP0BdKilAKT8oXFxbW14jLz9cXF1dK1xcXXxbXiMvOj9dKikoPzo6KFxcZCopKT8pKT8oW14jP10qKSg/OlxcPyhbXiNdKikpPyg/OiMoKD86LnxbXFxuXFxyXSkqKSk/L3VcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRzXVxuICogQHJldHVybnNcbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHVyaSwgb3B0cykge1xuICBjb25zdCBvcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0cylcbiAgLyoqIEB0eXBlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9ICovXG4gIGNvbnN0IHBhcnNlZCA9IHtcbiAgICBzY2hlbWU6IHVuZGVmaW5lZCxcbiAgICB1c2VyaW5mbzogdW5kZWZpbmVkLFxuICAgIGhvc3Q6ICcnLFxuICAgIHBvcnQ6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiAnJyxcbiAgICBxdWVyeTogdW5kZWZpbmVkLFxuICAgIGZyYWdtZW50OiB1bmRlZmluZWRcbiAgfVxuXG4gIGxldCBpc0lQID0gZmFsc2VcbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlID09PSAnc3VmZml4Jykge1xuICAgIGlmIChvcHRpb25zLnNjaGVtZSkge1xuICAgICAgdXJpID0gb3B0aW9ucy5zY2hlbWUgKyAnOicgKyB1cmlcbiAgICB9IGVsc2Uge1xuICAgICAgdXJpID0gJy8vJyArIHVyaVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG1hdGNoZXMgPSB1cmkubWF0Y2goVVJJX1BBUlNFKVxuXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgLy8gc3RvcmUgZWFjaCBjb21wb25lbnRcbiAgICBwYXJzZWQuc2NoZW1lID0gbWF0Y2hlc1sxXVxuICAgIHBhcnNlZC51c2VyaW5mbyA9IG1hdGNoZXNbM11cbiAgICBwYXJzZWQuaG9zdCA9IG1hdGNoZXNbNF1cbiAgICBwYXJzZWQucG9ydCA9IHBhcnNlSW50KG1hdGNoZXNbNV0sIDEwKVxuICAgIHBhcnNlZC5wYXRoID0gbWF0Y2hlc1s2XSB8fCAnJ1xuICAgIHBhcnNlZC5xdWVyeSA9IG1hdGNoZXNbN11cbiAgICBwYXJzZWQuZnJhZ21lbnQgPSBtYXRjaGVzWzhdXG5cbiAgICAvLyBmaXggcG9ydCBudW1iZXJcbiAgICBpZiAoaXNOYU4ocGFyc2VkLnBvcnQpKSB7XG4gICAgICBwYXJzZWQucG9ydCA9IG1hdGNoZXNbNV1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5ob3N0KSB7XG4gICAgICBjb25zdCBpcHY0cmVzdWx0ID0gaXNJUHY0KHBhcnNlZC5ob3N0KVxuICAgICAgaWYgKGlwdjRyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGlwdjZyZXN1bHQgPSBub3JtYWxpemVJUHY2KHBhcnNlZC5ob3N0KVxuICAgICAgICBwYXJzZWQuaG9zdCA9IGlwdjZyZXN1bHQuaG9zdC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGlzSVAgPSBpcHY2cmVzdWx0LmlzSVBWNlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNJUCA9IHRydWVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQudXNlcmluZm8gPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQuaG9zdCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5wb3J0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnF1ZXJ5ID09PSB1bmRlZmluZWQgJiYgIXBhcnNlZC5wYXRoKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3NhbWUtZG9jdW1lbnQnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAncmVsYXRpdmUnXG4gICAgfSBlbHNlIGlmIChwYXJzZWQuZnJhZ21lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdhYnNvbHV0ZSdcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICd1cmknXG4gICAgfVxuXG4gICAgLy8gY2hlY2sgZm9yIHJlZmVyZW5jZSBlcnJvcnNcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSBwYXJzZWQucmVmZXJlbmNlKSB7XG4gICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBpcyBub3QgYSAnICsgb3B0aW9ucy5yZWZlcmVuY2UgKyAnIHJlZmVyZW5jZS4nXG4gICAgfVxuXG4gICAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKG9wdGlvbnMuc2NoZW1lIHx8IHBhcnNlZC5zY2hlbWUpXG5cbiAgICAvLyBjaGVjayBpZiBzY2hlbWUgY2FuJ3QgaGFuZGxlIElSSXNcbiAgICBpZiAoIW9wdGlvbnMudW5pY29kZVN1cHBvcnQgJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLnVuaWNvZGVTdXBwb3J0KSkge1xuICAgICAgLy8gaWYgaG9zdCBjb21wb25lbnQgaXMgYSBkb21haW4gbmFtZVxuICAgICAgaWYgKHBhcnNlZC5ob3N0ICYmIChvcHRpb25zLmRvbWFpbkhvc3QgfHwgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5kb21haW5Ib3N0KSkgJiYgaXNJUCA9PT0gZmFsc2UgJiYgbm9uU2ltcGxlRG9tYWluKHBhcnNlZC5ob3N0KSkge1xuICAgICAgICAvLyBjb252ZXJ0IFVuaWNvZGUgSUROIC0+IEFTQ0lJIElETlxuICAgICAgICB0cnkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gVVJMLmRvbWFpblRvQVNDSUkocGFyc2VkLmhvc3QudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCBcIkhvc3QncyBkb21haW4gbmFtZSBjYW4gbm90IGJlIGNvbnZlcnRlZCB0byBBU0NJSTogXCIgKyBlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIGNvbnZlcnQgSVJJIC0+IFVSSVxuICAgIH1cblxuICAgIGlmICghc2NoZW1lSGFuZGxlciB8fCAoc2NoZW1lSGFuZGxlciAmJiAhc2NoZW1lSGFuZGxlci5za2lwTm9ybWFsaXplKSkge1xuICAgICAgaWYgKHVyaS5pbmRleE9mKCclJykgIT09IC0xKSB7XG4gICAgICAgIGlmIChwYXJzZWQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJzZWQuc2NoZW1lID0gdW5lc2NhcGUocGFyc2VkLnNjaGVtZSlcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyc2VkLmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5ob3N0ID0gdW5lc2NhcGUocGFyc2VkLmhvc3QpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQucGF0aCkge1xuICAgICAgICBwYXJzZWQucGF0aCA9IGVzY2FwZSh1bmVzY2FwZShwYXJzZWQucGF0aCkpXG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLmZyYWdtZW50KSB7XG4gICAgICAgIHBhcnNlZC5mcmFnbWVudCA9IGVuY29kZVVSSShkZWNvZGVVUklDb21wb25lbnQocGFyc2VkLmZyYWdtZW50KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBwYXJzaW5nXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5wYXJzZSkge1xuICAgICAgc2NoZW1lSGFuZGxlci5wYXJzZShwYXJzZWQsIG9wdGlvbnMpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGNhbiBub3QgYmUgcGFyc2VkLidcbiAgfVxuICByZXR1cm4gcGFyc2VkXG59XG5cbmNvbnN0IGZhc3RVcmkgPSB7XG4gIFNDSEVNRVMsXG4gIG5vcm1hbGl6ZSxcbiAgcmVzb2x2ZSxcbiAgcmVzb2x2ZUNvbXBvbmVudCxcbiAgZXF1YWwsXG4gIHNlcmlhbGl6ZSxcbiAgcGFyc2Vcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZmFzdFVyaSA9IGZhc3RVcmlcbiIsICJpbXBvcnQgKiBhcyB1cmkgZnJvbSBcImZhc3QtdXJpXCJcblxudHlwZSBVUkkgPSB0eXBlb2YgdXJpICYge2NvZGU6IHN0cmluZ31cbjsodXJpIGFzIFVSSSkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91cmlcIikuZGVmYXVsdCdcblxuZXhwb3J0IGRlZmF1bHQgdXJpIGFzIFVSSVxuIiwgImV4cG9ydCB7XG4gIEZvcm1hdCxcbiAgRm9ybWF0RGVmaW5pdGlvbixcbiAgQXN5bmNGb3JtYXREZWZpbml0aW9uLFxuICBLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBNYWNyb0tleXdvcmREZWZpbml0aW9uLFxuICBGdW5jS2V5d29yZERlZmluaXRpb24sXG4gIFZvY2FidWxhcnksXG4gIFNjaGVtYSxcbiAgU2NoZW1hT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFzeW5jU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEVycm9yTm9QYXJhbXMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4vY29tcGlsZVwiXG5leHBvcnQgaW50ZXJmYWNlIFBsdWdpbjxPcHRzPiB7XG4gIChhanY6IEFqdiwgb3B0aW9ucz86IE9wdHMpOiBBanZcbiAgW3Byb3A6IHN0cmluZ106IGFueVxufVxuXG5leHBvcnQge0tleXdvcmRDeHR9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGVcIlxuZXhwb3J0IHtEZWZpbmVkRXJyb3J9IGZyb20gXCIuL3ZvY2FidWxhcmllcy9lcnJvcnNcIlxuZXhwb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5leHBvcnQge0pTT05TY2hlbWFUeXBlfSBmcm9tIFwiLi90eXBlcy9qc29uLXNjaGVtYVwiXG5leHBvcnQge0pURFNjaGVtYVR5cGUsIFNvbWVKVERTY2hlbWFUeXBlLCBKVEREYXRhVHlwZX0gZnJvbSBcIi4vdHlwZXMvanRkLXNjaGVtYVwiXG5leHBvcnQge18sIHN0ciwgc3RyaW5naWZ5LCBuaWwsIE5hbWUsIENvZGUsIENvZGVHZW4sIENvZGVHZW5PcHRpb25zfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuXG5pbXBvcnQgdHlwZSB7XG4gIFNjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIFNjaGVtYU9iamVjdCxcbiAgQXN5bmNTY2hlbWEsXG4gIFZvY2FidWxhcnksXG4gIEtleXdvcmREZWZpbml0aW9uLFxuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBGb3JtYXQsXG4gIEFkZGVkRm9ybWF0LFxuICBSZWdFeHBFbmdpbmUsXG4gIFVyaVJlc29sdmVyLFxufSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7SlNPTlNjaGVtYVR5cGV9IGZyb20gXCIuL3R5cGVzL2pzb24tc2NoZW1hXCJcbmltcG9ydCB0eXBlIHtKVERTY2hlbWFUeXBlLCBTb21lSlREU2NoZW1hVHlwZSwgSlRERGF0YVR5cGV9IGZyb20gXCIuL3R5cGVzL2p0ZC1zY2hlbWFcIlxuaW1wb3J0IFZhbGlkYXRpb25FcnJvciBmcm9tIFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIlxuaW1wb3J0IE1pc3NpbmdSZWZFcnJvciBmcm9tIFwiLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge2dldFJ1bGVzLCBWYWxpZGF0aW9uUnVsZXMsIFJ1bGUsIFJ1bGVHcm91cCwgSlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuaW1wb3J0IHtTY2hlbWFFbnYsIGNvbXBpbGVTY2hlbWEsIHJlc29sdmVTY2hlbWF9IGZyb20gXCIuL2NvbXBpbGVcIlxuaW1wb3J0IHtDb2RlLCBWYWx1ZVNjb3BlfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHtub3JtYWxpemVJZCwgZ2V0U2NoZW1hUmVmc30gZnJvbSBcIi4vY29tcGlsZS9yZXNvbHZlXCJcbmltcG9ydCB7Z2V0SlNPTlR5cGVzfSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCJcbmltcG9ydCB7ZWFjaEl0ZW19IGZyb20gXCIuL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgKiBhcyAkZGF0YVJlZlNjaGVtYSBmcm9tIFwiLi9yZWZzL2RhdGEuanNvblwiXG5cbmltcG9ydCBEZWZhdWx0VXJpUmVzb2x2ZXIgZnJvbSBcIi4vcnVudGltZS91cmlcIlxuXG5jb25zdCBkZWZhdWx0UmVnRXhwOiBSZWdFeHBFbmdpbmUgPSAoc3RyLCBmbGFncykgPT4gbmV3IFJlZ0V4cChzdHIsIGZsYWdzKVxuZGVmYXVsdFJlZ0V4cC5jb2RlID0gXCJuZXcgUmVnRXhwXCJcblxuY29uc3QgTUVUQV9JR05PUkVfT1BUSU9OUzogKGtleW9mIE9wdGlvbnMpW10gPSBbXCJyZW1vdmVBZGRpdGlvbmFsXCIsIFwidXNlRGVmYXVsdHNcIiwgXCJjb2VyY2VUeXBlc1wiXVxuY29uc3QgRVhUX1NDT1BFX05BTUVTID0gbmV3IFNldChbXG4gIFwidmFsaWRhdGVcIixcbiAgXCJzZXJpYWxpemVcIixcbiAgXCJwYXJzZVwiLFxuICBcIndyYXBwZXJcIixcbiAgXCJyb290XCIsXG4gIFwic2NoZW1hXCIsXG4gIFwia2V5d29yZFwiLFxuICBcInBhdHRlcm5cIixcbiAgXCJmb3JtYXRzXCIsXG4gIFwidmFsaWRhdGUkZGF0YVwiLFxuICBcImZ1bmNcIixcbiAgXCJvYmpcIixcbiAgXCJFcnJvclwiLFxuXSlcblxuZXhwb3J0IHR5cGUgT3B0aW9ucyA9IEN1cnJlbnRPcHRpb25zICYgRGVwcmVjYXRlZE9wdGlvbnNcblxuZXhwb3J0IGludGVyZmFjZSBDdXJyZW50T3B0aW9ucyB7XG4gIC8vIHN0cmljdCBtb2RlIG9wdGlvbnMgKE5FVylcbiAgc3RyaWN0PzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0U2NoZW1hPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0TnVtYmVycz86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdFR5cGVzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0VHVwbGVzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0UmVxdWlyZWQ/OiBib29sZWFuIHwgXCJsb2dcIlxuICBhbGxvd01hdGNoaW5nUHJvcGVydGllcz86IGJvb2xlYW4gLy8gZGlzYWJsZXMgYSBzdHJpY3QgbW9kZSByZXN0cmljdGlvblxuICBhbGxvd1VuaW9uVHlwZXM/OiBib29sZWFuXG4gIHZhbGlkYXRlRm9ybWF0cz86IGJvb2xlYW5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgcmVwb3J0aW5nIG9wdGlvbnM6XG4gICRkYXRhPzogYm9vbGVhblxuICBhbGxFcnJvcnM/OiBib29sZWFuXG4gIHZlcmJvc2U/OiBib29sZWFuXG4gIGRpc2NyaW1pbmF0b3I/OiBib29sZWFuXG4gIHVuaWNvZGVSZWdFeHA/OiBib29sZWFuXG4gIHRpbWVzdGFtcD86IFwic3RyaW5nXCIgfCBcImRhdGVcIiAvLyBKVEQgb25seVxuICBwYXJzZURhdGU/OiBib29sZWFuIC8vIEpURCBvbmx5XG4gIGFsbG93RGF0ZT86IGJvb2xlYW4gLy8gSlREIG9ubHlcbiAgJGNvbW1lbnQ/OlxuICAgIHwgdHJ1ZVxuICAgIHwgKChjb21tZW50OiBzdHJpbmcsIHNjaGVtYVBhdGg/OiBzdHJpbmcsIHJvb3RTY2hlbWE/OiBBbnlTY2hlbWFPYmplY3QpID0+IHVua25vd24pXG4gIGZvcm1hdHM/OiB7W05hbWUgaW4gc3RyaW5nXT86IEZvcm1hdH1cbiAga2V5d29yZHM/OiBWb2NhYnVsYXJ5XG4gIHNjaGVtYXM/OiBBbnlTY2hlbWFbXSB8IHtbS2V5IGluIHN0cmluZ10/OiBBbnlTY2hlbWF9XG4gIGxvZ2dlcj86IExvZ2dlciB8IGZhbHNlXG4gIGxvYWRTY2hlbWE/OiAodXJpOiBzdHJpbmcpID0+IFByb21pc2U8QW55U2NoZW1hT2JqZWN0PlxuICAvLyBvcHRpb25zIHRvIG1vZGlmeSB2YWxpZGF0ZWQgZGF0YTpcbiAgcmVtb3ZlQWRkaXRpb25hbD86IGJvb2xlYW4gfCBcImFsbFwiIHwgXCJmYWlsaW5nXCJcbiAgdXNlRGVmYXVsdHM/OiBib29sZWFuIHwgXCJlbXB0eVwiXG4gIGNvZXJjZVR5cGVzPzogYm9vbGVhbiB8IFwiYXJyYXlcIlxuICAvLyBhZHZhbmNlZCBvcHRpb25zOlxuICBuZXh0PzogYm9vbGVhbiAvLyBORVdcbiAgdW5ldmFsdWF0ZWQ/OiBib29sZWFuIC8vIE5FV1xuICBkeW5hbWljUmVmPzogYm9vbGVhbiAvLyBORVdcbiAgc2NoZW1hSWQ/OiBcImlkXCIgfCBcIiRpZFwiXG4gIGp0ZD86IGJvb2xlYW4gLy8gTkVXXG4gIG1ldGE/OiBTY2hlbWFPYmplY3QgfCBib29sZWFuXG4gIGRlZmF1bHRNZXRhPzogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0XG4gIHZhbGlkYXRlU2NoZW1hPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgYWRkVXNlZFNjaGVtYT86IGJvb2xlYW5cbiAgaW5saW5lUmVmcz86IGJvb2xlYW4gfCBudW1iZXJcbiAgcGFzc0NvbnRleHQ/OiBib29sZWFuXG4gIGxvb3BSZXF1aXJlZD86IG51bWJlclxuICBsb29wRW51bT86IG51bWJlciAvLyBORVdcbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbiAgbXVsdGlwbGVPZlByZWNpc2lvbj86IG51bWJlclxuICBpbnQzMnJhbmdlPzogYm9vbGVhbiAvLyBKVEQgb25seVxuICBtZXNzYWdlcz86IGJvb2xlYW5cbiAgY29kZT86IENvZGVPcHRpb25zIC8vIE5FV1xuICB1cmlSZXNvbHZlcj86IFVyaVJlc29sdmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZU9wdGlvbnMge1xuICBlczU/OiBib29sZWFuXG4gIGVzbT86IGJvb2xlYW5cbiAgbGluZXM/OiBib29sZWFuXG4gIG9wdGltaXplPzogYm9vbGVhbiB8IG51bWJlclxuICBmb3JtYXRzPzogQ29kZSAvLyBjb2RlIHRvIHJlcXVpcmUgKG9yIGNvbnN0cnVjdCkgbWFwIG9mIGF2YWlsYWJsZSBmb3JtYXRzIC0gZm9yIHN0YW5kYWxvbmUgY29kZVxuICBzb3VyY2U/OiBib29sZWFuXG4gIHByb2Nlc3M/OiAoY29kZTogc3RyaW5nLCBzY2hlbWE/OiBTY2hlbWFFbnYpID0+IHN0cmluZ1xuICByZWdFeHA/OiBSZWdFeHBFbmdpbmVcbn1cblxuaW50ZXJmYWNlIEluc3RhbmNlQ29kZU9wdGlvbnMgZXh0ZW5kcyBDb2RlT3B0aW9ucyB7XG4gIHJlZ0V4cDogUmVnRXhwRW5naW5lXG4gIG9wdGltaXplOiBudW1iZXJcbn1cblxuaW50ZXJmYWNlIERlcHJlY2F0ZWRPcHRpb25zIHtcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGlnbm9yZUtleXdvcmRzV2l0aFJlZj86IGJvb2xlYW5cbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIGpzUHJvcGVydHlTeW50YXg/OiBib29sZWFuIC8vIGFkZGVkIGluc3RlYWQgb2YganNvblBvaW50ZXJzXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICB1bmljb2RlPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgUmVtb3ZlZE9wdGlvbnMge1xuICBmb3JtYXQ/OiBib29sZWFuXG4gIGVycm9yRGF0YVBhdGg/OiBcIm9iamVjdFwiIHwgXCJwcm9wZXJ0eVwiXG4gIG51bGxhYmxlPzogYm9vbGVhbiAvLyBcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdFxuICBqc29uUG9pbnRlcnM/OiBib29sZWFuXG4gIGV4dGVuZFJlZnM/OiB0cnVlIHwgXCJpZ25vcmVcIiB8IFwiZmFpbFwiXG4gIG1pc3NpbmdSZWZzPzogdHJ1ZSB8IFwiaWdub3JlXCIgfCBcImZhaWxcIlxuICBwcm9jZXNzQ29kZT86IChjb2RlOiBzdHJpbmcsIHNjaGVtYT86IFNjaGVtYUVudikgPT4gc3RyaW5nXG4gIHNvdXJjZUNvZGU/OiBib29sZWFuXG4gIHN0cmljdERlZmF1bHRzPzogYm9vbGVhblxuICBzdHJpY3RLZXl3b3Jkcz86IGJvb2xlYW5cbiAgdW5pcXVlSXRlbXM/OiBib29sZWFuXG4gIHVua25vd25Gb3JtYXRzPzogdHJ1ZSB8IHN0cmluZ1tdIHwgXCJpZ25vcmVcIlxuICBjYWNoZT86IGFueVxuICBzZXJpYWxpemU/OiAoc2NoZW1hOiBBbnlTY2hlbWEpID0+IHVua25vd25cbiAgYWp2RXJyb3JzPzogYm9vbGVhblxufVxuXG50eXBlIE9wdGlvbnNJbmZvPFQgZXh0ZW5kcyBSZW1vdmVkT3B0aW9ucyB8IERlcHJlY2F0ZWRPcHRpb25zPiA9IHtcbiAgW0sgaW4ga2V5b2YgVF0tPzogc3RyaW5nIHwgdW5kZWZpbmVkXG59XG5cbmNvbnN0IHJlbW92ZWRPcHRpb25zOiBPcHRpb25zSW5mbzxSZW1vdmVkT3B0aW9ucz4gPSB7XG4gIGVycm9yRGF0YVBhdGg6IFwiXCIsXG4gIGZvcm1hdDogXCJgdmFsaWRhdGVGb3JtYXRzOiBmYWxzZWAgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgbnVsbGFibGU6ICdcIm51bGxhYmxlXCIga2V5d29yZCBpcyBzdXBwb3J0ZWQgYnkgZGVmYXVsdC4nLFxuICBqc29uUG9pbnRlcnM6IFwiRGVwcmVjYXRlZCBqc1Byb3BlcnR5U3ludGF4IGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gIGV4dGVuZFJlZnM6IFwiRGVwcmVjYXRlZCBpZ25vcmVLZXl3b3Jkc1dpdGhSZWYgY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgbWlzc2luZ1JlZnM6IFwiUGFzcyBlbXB0eSBzY2hlbWEgd2l0aCAkaWQgdGhhdCBzaG91bGQgYmUgaWdub3JlZCB0byBhanYuYWRkU2NoZW1hLlwiLFxuICBwcm9jZXNzQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7cHJvY2VzczogKGNvZGUsIHNjaGVtYUVudjogb2JqZWN0KSA9PiBzdHJpbmd9YFwiLFxuICBzb3VyY2VDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtzb3VyY2U6IHRydWV9YFwiLFxuICBzdHJpY3REZWZhdWx0czogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgc3RyaWN0S2V5d29yZHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gIHVuaXF1ZUl0ZW1zOiAnXCJ1bmlxdWVJdGVtc1wiIGtleXdvcmQgaXMgYWx3YXlzIHZhbGlkYXRlZC4nLFxuICB1bmtub3duRm9ybWF0czogXCJEaXNhYmxlIHN0cmljdCBtb2RlIG9yIHBhc3MgYHRydWVgIHRvIGBhanYuYWRkRm9ybWF0YCAob3IgYGZvcm1hdHNgIG9wdGlvbikuXCIsXG4gIGNhY2hlOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgc2VyaWFsaXplOiBcIk1hcCBpcyB1c2VkIGFzIGNhY2hlLCBzY2hlbWEgb2JqZWN0IGFzIGtleS5cIixcbiAgYWp2RXJyb3JzOiBcIkl0IGlzIGRlZmF1bHQgbm93LlwiLFxufVxuXG5jb25zdCBkZXByZWNhdGVkT3B0aW9uczogT3B0aW9uc0luZm88RGVwcmVjYXRlZE9wdGlvbnM+ID0ge1xuICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY6IFwiXCIsXG4gIGpzUHJvcGVydHlTeW50YXg6IFwiXCIsXG4gIHVuaWNvZGU6ICdcIm1pbkxlbmd0aFwiL1wibWF4TGVuZ3RoXCIgYWNjb3VudCBmb3IgdW5pY29kZSBjaGFyYWN0ZXJzIGJ5IGRlZmF1bHQuJyxcbn1cblxudHlwZSBSZXF1aXJlZEluc3RhbmNlT3B0aW9ucyA9IHtcbiAgW0sgaW5cbiAgICB8IFwic3RyaWN0U2NoZW1hXCJcbiAgICB8IFwic3RyaWN0TnVtYmVyc1wiXG4gICAgfCBcInN0cmljdFR5cGVzXCJcbiAgICB8IFwic3RyaWN0VHVwbGVzXCJcbiAgICB8IFwic3RyaWN0UmVxdWlyZWRcIlxuICAgIHwgXCJpbmxpbmVSZWZzXCJcbiAgICB8IFwibG9vcFJlcXVpcmVkXCJcbiAgICB8IFwibG9vcEVudW1cIlxuICAgIHwgXCJtZXRhXCJcbiAgICB8IFwibWVzc2FnZXNcIlxuICAgIHwgXCJzY2hlbWFJZFwiXG4gICAgfCBcImFkZFVzZWRTY2hlbWFcIlxuICAgIHwgXCJ2YWxpZGF0ZVNjaGVtYVwiXG4gICAgfCBcInZhbGlkYXRlRm9ybWF0c1wiXG4gICAgfCBcImludDMycmFuZ2VcIlxuICAgIHwgXCJ1bmljb2RlUmVnRXhwXCJcbiAgICB8IFwidXJpUmVzb2x2ZXJcIl06IE5vbk51bGxhYmxlPE9wdGlvbnNbS10+XG59ICYge2NvZGU6IEluc3RhbmNlQ29kZU9wdGlvbnN9XG5cbmV4cG9ydCB0eXBlIEluc3RhbmNlT3B0aW9ucyA9IE9wdGlvbnMgJiBSZXF1aXJlZEluc3RhbmNlT3B0aW9uc1xuXG5jb25zdCBNQVhfRVhQUkVTU0lPTiA9IDIwMFxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gcmVxdWlyZWRPcHRpb25zKG86IE9wdGlvbnMpOiBSZXF1aXJlZEluc3RhbmNlT3B0aW9ucyB7XG4gIGNvbnN0IHMgPSBvLnN0cmljdFxuICBjb25zdCBfb3B0eiA9IG8uY29kZT8ub3B0aW1pemVcbiAgY29uc3Qgb3B0aW1pemUgPSBfb3B0eiA9PT0gdHJ1ZSB8fCBfb3B0eiA9PT0gdW5kZWZpbmVkID8gMSA6IF9vcHR6IHx8IDBcbiAgY29uc3QgcmVnRXhwID0gby5jb2RlPy5yZWdFeHAgPz8gZGVmYXVsdFJlZ0V4cFxuICBjb25zdCB1cmlSZXNvbHZlciA9IG8udXJpUmVzb2x2ZXIgPz8gRGVmYXVsdFVyaVJlc29sdmVyXG4gIHJldHVybiB7XG4gICAgc3RyaWN0U2NoZW1hOiBvLnN0cmljdFNjaGVtYSA/PyBzID8/IHRydWUsXG4gICAgc3RyaWN0TnVtYmVyczogby5zdHJpY3ROdW1iZXJzID8/IHMgPz8gdHJ1ZSxcbiAgICBzdHJpY3RUeXBlczogby5zdHJpY3RUeXBlcyA/PyBzID8/IFwibG9nXCIsXG4gICAgc3RyaWN0VHVwbGVzOiBvLnN0cmljdFR1cGxlcyA/PyBzID8/IFwibG9nXCIsXG4gICAgc3RyaWN0UmVxdWlyZWQ6IG8uc3RyaWN0UmVxdWlyZWQgPz8gcyA/PyBmYWxzZSxcbiAgICBjb2RlOiBvLmNvZGUgPyB7Li4uby5jb2RlLCBvcHRpbWl6ZSwgcmVnRXhwfSA6IHtvcHRpbWl6ZSwgcmVnRXhwfSxcbiAgICBsb29wUmVxdWlyZWQ6IG8ubG9vcFJlcXVpcmVkID8/IE1BWF9FWFBSRVNTSU9OLFxuICAgIGxvb3BFbnVtOiBvLmxvb3BFbnVtID8/IE1BWF9FWFBSRVNTSU9OLFxuICAgIG1ldGE6IG8ubWV0YSA/PyB0cnVlLFxuICAgIG1lc3NhZ2VzOiBvLm1lc3NhZ2VzID8/IHRydWUsXG4gICAgaW5saW5lUmVmczogby5pbmxpbmVSZWZzID8/IHRydWUsXG4gICAgc2NoZW1hSWQ6IG8uc2NoZW1hSWQgPz8gXCIkaWRcIixcbiAgICBhZGRVc2VkU2NoZW1hOiBvLmFkZFVzZWRTY2hlbWEgPz8gdHJ1ZSxcbiAgICB2YWxpZGF0ZVNjaGVtYTogby52YWxpZGF0ZVNjaGVtYSA/PyB0cnVlLFxuICAgIHZhbGlkYXRlRm9ybWF0czogby52YWxpZGF0ZUZvcm1hdHMgPz8gdHJ1ZSxcbiAgICB1bmljb2RlUmVnRXhwOiBvLnVuaWNvZGVSZWdFeHAgPz8gdHJ1ZSxcbiAgICBpbnQzMnJhbmdlOiBvLmludDMycmFuZ2UgPz8gdHJ1ZSxcbiAgICB1cmlSZXNvbHZlcjogdXJpUmVzb2x2ZXIsXG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBMb2dnZXIge1xuICBsb2coLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxuICB3YXJuKC4uLmFyZ3M6IHVua25vd25bXSk6IHVua25vd25cbiAgZXJyb3IoLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBanYge1xuICBvcHRzOiBJbnN0YW5jZU9wdGlvbnNcbiAgZXJyb3JzPzogRXJyb3JPYmplY3RbXSB8IG51bGwgLy8gZXJyb3JzIGZyb20gdGhlIGxhc3QgdmFsaWRhdGlvblxuICBsb2dnZXI6IExvZ2dlclxuICAvLyBzaGFyZWQgZXh0ZXJuYWwgc2NvcGUgdmFsdWVzIGZvciBjb21waWxlZCBmdW5jdGlvbnNcbiAgcmVhZG9ubHkgc2NvcGU6IFZhbHVlU2NvcGVcbiAgcmVhZG9ubHkgc2NoZW1hczoge1tLZXkgaW4gc3RyaW5nXT86IFNjaGVtYUVudn0gPSB7fVxuICByZWFkb25seSByZWZzOiB7W1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgc3RyaW5nfSA9IHt9XG4gIHJlYWRvbmx5IGZvcm1hdHM6IHtbTmFtZSBpbiBzdHJpbmddPzogQWRkZWRGb3JtYXR9ID0ge31cbiAgcmVhZG9ubHkgUlVMRVM6IFZhbGlkYXRpb25SdWxlc1xuICByZWFkb25seSBfY29tcGlsYXRpb25zOiBTZXQ8U2NoZW1hRW52PiA9IG5ldyBTZXQoKVxuICBwcml2YXRlIHJlYWRvbmx5IF9sb2FkaW5nOiB7W1JlZiBpbiBzdHJpbmddPzogUHJvbWlzZTxBbnlTY2hlbWFPYmplY3Q+fSA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX2NhY2hlOiBNYXA8QW55U2NoZW1hLCBTY2hlbWFFbnY+ID0gbmV3IE1hcCgpXG4gIHByaXZhdGUgcmVhZG9ubHkgX21ldGFPcHRzOiBJbnN0YW5jZU9wdGlvbnNcblxuICBzdGF0aWMgVmFsaWRhdGlvbkVycm9yID0gVmFsaWRhdGlvbkVycm9yXG4gIHN0YXRpYyBNaXNzaW5nUmVmRXJyb3IgPSBNaXNzaW5nUmVmRXJyb3JcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBPcHRpb25zID0ge30pIHtcbiAgICBvcHRzID0gdGhpcy5vcHRzID0gey4uLm9wdHMsIC4uLnJlcXVpcmVkT3B0aW9ucyhvcHRzKX1cbiAgICBjb25zdCB7ZXM1LCBsaW5lc30gPSB0aGlzLm9wdHMuY29kZVxuXG4gICAgdGhpcy5zY29wZSA9IG5ldyBWYWx1ZVNjb3BlKHtzY29wZToge30sIHByZWZpeGVzOiBFWFRfU0NPUEVfTkFNRVMsIGVzNSwgbGluZXN9KVxuICAgIHRoaXMubG9nZ2VyID0gZ2V0TG9nZ2VyKG9wdHMubG9nZ2VyKVxuICAgIGNvbnN0IGZvcm1hdE9wdCA9IG9wdHMudmFsaWRhdGVGb3JtYXRzXG4gICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmYWxzZVxuXG4gICAgdGhpcy5SVUxFUyA9IGdldFJ1bGVzKClcbiAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCByZW1vdmVkT3B0aW9ucywgb3B0cywgXCJOT1QgU1VQUE9SVEVEXCIpXG4gICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgZGVwcmVjYXRlZE9wdGlvbnMsIG9wdHMsIFwiREVQUkVDQVRFRFwiLCBcIndhcm5cIilcbiAgICB0aGlzLl9tZXRhT3B0cyA9IGdldE1ldGFTY2hlbWFPcHRpb25zLmNhbGwodGhpcylcblxuICAgIGlmIChvcHRzLmZvcm1hdHMpIGFkZEluaXRpYWxGb3JtYXRzLmNhbGwodGhpcylcbiAgICB0aGlzLl9hZGRWb2NhYnVsYXJpZXMoKVxuICAgIHRoaXMuX2FkZERlZmF1bHRNZXRhU2NoZW1hKClcbiAgICBpZiAob3B0cy5rZXl3b3JkcykgYWRkSW5pdGlhbEtleXdvcmRzLmNhbGwodGhpcywgb3B0cy5rZXl3b3JkcylcbiAgICBpZiAodHlwZW9mIG9wdHMubWV0YSA9PSBcIm9iamVjdFwiKSB0aGlzLmFkZE1ldGFTY2hlbWEob3B0cy5tZXRhKVxuICAgIGFkZEluaXRpYWxTY2hlbWFzLmNhbGwodGhpcylcbiAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZvcm1hdE9wdFxuICB9XG5cbiAgX2FkZFZvY2FidWxhcmllcygpOiB2b2lkIHtcbiAgICB0aGlzLmFkZEtleXdvcmQoXCIkYXN5bmNcIilcbiAgfVxuXG4gIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpOiB2b2lkIHtcbiAgICBjb25zdCB7JGRhdGEsIG1ldGEsIHNjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGxldCBfZGF0YVJlZlNjaGVtYTogU2NoZW1hT2JqZWN0ID0gJGRhdGFSZWZTY2hlbWFcbiAgICBpZiAoc2NoZW1hSWQgPT09IFwiaWRcIikge1xuICAgICAgX2RhdGFSZWZTY2hlbWEgPSB7Li4uJGRhdGFSZWZTY2hlbWF9XG4gICAgICBfZGF0YVJlZlNjaGVtYS5pZCA9IF9kYXRhUmVmU2NoZW1hLiRpZFxuICAgICAgZGVsZXRlIF9kYXRhUmVmU2NoZW1hLiRpZFxuICAgIH1cbiAgICBpZiAobWV0YSAmJiAkZGF0YSkgdGhpcy5hZGRNZXRhU2NoZW1hKF9kYXRhUmVmU2NoZW1hLCBfZGF0YVJlZlNjaGVtYVtzY2hlbWFJZF0sIGZhbHNlKVxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB7bWV0YSwgc2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPSB0eXBlb2YgbWV0YSA9PSBcIm9iamVjdFwiID8gbWV0YVtzY2hlbWFJZF0gfHwgbWV0YSA6IHVuZGVmaW5lZClcbiAgfVxuXG4gIC8vIFZhbGlkYXRlIGRhdGEgdXNpbmcgc2NoZW1hXG4gIC8vIEFueVNjaGVtYSB3aWxsIGJlIGNvbXBpbGVkIGFuZCBjYWNoZWQgdXNpbmcgc2NoZW1hIGl0c2VsZiBhcyBhIGtleSBmb3IgTWFwXG4gIHZhbGlkYXRlKHNjaGVtYTogU2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogYm9vbGVhblxuICB2YWxpZGF0ZShzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGJvb2xlYW4gfCBQcm9taXNlPHVua25vd24+XG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogU2NoZW1hIHwgSlNPTlNjaGVtYVR5cGU8VD4gfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBkYXRhIGlzIFRcbiAgLy8gU2VwYXJhdGVkIGZvciB0eXBlIGluZmVyZW5jZSB0byB3b3JrXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogSlREU2NoZW1hVHlwZTxUPiwgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVFxuICAvLyBUaGlzIG92ZXJsb2FkIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHR5cGVzY3JpcHQgaW5mZXJlbmNlLCB0aGUgZmlyc3RcbiAgLy8gYXJndW1lbnQgcHJldmVudHMgbWFudWFsIHR5cGUgYW5ub3RhdGlvbiBmcm9tIG1hdGNoaW5nIHRoaXMgb3ZlcmxvYWRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICB2YWxpZGF0ZTxOIGV4dGVuZHMgbmV2ZXIsIFQgZXh0ZW5kcyBTb21lSlREU2NoZW1hVHlwZT4oXG4gICAgc2NoZW1hOiBULFxuICAgIGRhdGE6IHVua25vd25cbiAgKTogZGF0YSBpcyBKVEREYXRhVHlwZTxUPlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuICB2YWxpZGF0ZTxUPihzY2hlbWE6IEFzeW5jU2NoZW1hLCBkYXRhOiB1bmtub3duIHwgVCk6IFByb21pc2U8VD5cbiAgdmFsaWRhdGU8VD4oc2NoZW1hS2V5UmVmOiBBbnlTY2hlbWEgfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBkYXRhIGlzIFQgfCBQcm9taXNlPFQ+XG4gIHZhbGlkYXRlPFQ+KFxuICAgIHNjaGVtYUtleVJlZjogQW55U2NoZW1hIHwgc3RyaW5nLCAvLyBrZXksIHJlZiBvciBzY2hlbWEgb2JqZWN0XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbiAgICBkYXRhOiB1bmtub3duIHwgVCAvLyB0byBiZSB2YWxpZGF0ZWRcbiAgKTogYm9vbGVhbiB8IFByb21pc2U8VD4ge1xuICAgIGxldCB2OiBBbnlWYWxpZGF0ZUZ1bmN0aW9uIHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBzY2hlbWFLZXlSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAgdiA9IHRoaXMuZ2V0U2NoZW1hPFQ+KHNjaGVtYUtleVJlZilcbiAgICAgIGlmICghdikgdGhyb3cgbmV3IEVycm9yKGBubyBzY2hlbWEgd2l0aCBrZXkgb3IgcmVmIFwiJHtzY2hlbWFLZXlSZWZ9XCJgKVxuICAgIH0gZWxzZSB7XG4gICAgICB2ID0gdGhpcy5jb21waWxlPFQ+KHNjaGVtYUtleVJlZilcbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZCA9IHYoZGF0YSlcbiAgICBpZiAoIShcIiRhc3luY1wiIGluIHYpKSB0aGlzLmVycm9ycyA9IHYuZXJyb3JzXG4gICAgcmV0dXJuIHZhbGlkXG4gIH1cblxuICAvLyBDcmVhdGUgdmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYVxuICAvLyBfbWV0YTogdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5IHRvIGNvbXBpbGUgbWV0YSBzY2hlbWFzIG9mIHVzZXItZGVmaW5lZCBrZXl3b3Jkcy5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBTY2hlbWEgfCBKU09OU2NoZW1hVHlwZTxUPiwgX21ldGE/OiBib29sZWFuKTogVmFsaWRhdGVGdW5jdGlvbjxUPlxuICAvLyBTZXBhcmF0ZWQgZm9yIHR5cGUgaW5mZXJlbmNlIHRvIHdvcmtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBKVERTY2hlbWFUeXBlPFQ+LCBfbWV0YT86IGJvb2xlYW4pOiBWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIC8vIFRoaXMgb3ZlcmxvYWQgaXMgb25seSBpbnRlbmRlZCBmb3IgdHlwZXNjcmlwdCBpbmZlcmVuY2UsIHRoZSBmaXJzdFxuICAvLyBhcmd1bWVudCBwcmV2ZW50cyBtYW51YWwgdHlwZSBhbm5vdGF0aW9uIGZyb20gbWF0Y2hpbmcgdGhpcyBvdmVybG9hZFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGNvbXBpbGU8TiBleHRlbmRzIG5ldmVyLCBUIGV4dGVuZHMgU29tZUpURFNjaGVtYVR5cGU+KFxuICAgIHNjaGVtYTogVCxcbiAgICBfbWV0YT86IGJvb2xlYW5cbiAgKTogVmFsaWRhdGVGdW5jdGlvbjxKVEREYXRhVHlwZTxUPj5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBc3luY1NjaGVtYSwgX21ldGE/OiBib29sZWFuKTogQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQW55U2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQW55U2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHtcbiAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSlcbiAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpIGFzIEFueVZhbGlkYXRlRnVuY3Rpb248VD5cbiAgfVxuXG4gIC8vIENyZWF0ZXMgdmFsaWRhdGluZyBmdW5jdGlvbiBmb3IgcGFzc2VkIHNjaGVtYSB3aXRoIGFzeW5jaHJvbm91cyBsb2FkaW5nIG9mIG1pc3Npbmcgc2NoZW1hcy5cbiAgLy8gYGxvYWRTY2hlbWFgIG9wdGlvbiBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgc2NoZW1hIHVyaSBhbmQgcmV0dXJucyBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgc2NoZW1hLlxuICAvLyBUT0RPIGFsbG93IHBhc3Npbmcgc2NoZW1hIFVSSVxuICAvLyBtZXRhIC0gb3B0aW9uYWwgdHJ1ZSB0byBjb21waWxlIG1ldGEtc2NoZW1hXG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oXG4gICAgc2NoZW1hOiBTY2hlbWFPYmplY3QgfCBKU09OU2NoZW1hVHlwZTxUPixcbiAgICBfbWV0YT86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICAvLyBTZXBhcmF0ZWQgZm9yIHR5cGUgaW5mZXJlbmNlIHRvIHdvcmtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFByb21pc2U8VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihzY2hlbWE6IEFzeW5jU2NoZW1hLCBtZXRhPzogYm9vbGVhbik6IFByb21pc2U8QXN5bmNWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIG1ldGE/OiBib29sZWFuXG4gICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBtZXRhPzogYm9vbGVhblxuICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb248VD4+IHtcbiAgICBpZiAodHlwZW9mIHRoaXMub3B0cy5sb2FkU2NoZW1hICE9IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwib3B0aW9ucy5sb2FkU2NoZW1hIHNob3VsZCBiZSBhIGZ1bmN0aW9uXCIpXG4gICAgfVxuICAgIGNvbnN0IHtsb2FkU2NoZW1hfSA9IHRoaXMub3B0c1xuICAgIHJldHVybiBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2hlbWEsIG1ldGEpXG5cbiAgICBhc3luYyBmdW5jdGlvbiBydW5Db21waWxlQXN5bmMoXG4gICAgICB0aGlzOiBBanYsXG4gICAgICBfc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAgICBfbWV0YT86IGJvb2xlYW5cbiAgICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb24+IHtcbiAgICAgIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKVxuICAgICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKF9zY2hlbWEsIF9tZXRhKVxuICAgICAgcmV0dXJuIHNjaC52YWxpZGF0ZSB8fCBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNZXRhU2NoZW1hKHRoaXM6IEFqdiwgJHJlZj86IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgaWYgKCRyZWYgJiYgIXRoaXMuZ2V0U2NoZW1hKCRyZWYpKSB7XG4gICAgICAgIGF3YWl0IHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHskcmVmfSwgdHJ1ZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfY29tcGlsZUFzeW5jKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb24+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaClcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKCEoZSBpbnN0YW5jZW9mIE1pc3NpbmdSZWZFcnJvcikpIHRocm93IGVcbiAgICAgICAgY2hlY2tMb2FkZWQuY2FsbCh0aGlzLCBlKVxuICAgICAgICBhd2FpdCBsb2FkTWlzc2luZ1NjaGVtYS5jYWxsKHRoaXMsIGUubWlzc2luZ1NjaGVtYSlcbiAgICAgICAgcmV0dXJuIF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMb2FkZWQodGhpczogQWp2LCB7bWlzc2luZ1NjaGVtYTogcmVmLCBtaXNzaW5nUmVmfTogTWlzc2luZ1JlZkVycm9yKTogdm9pZCB7XG4gICAgICBpZiAodGhpcy5yZWZzW3JlZl0pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBbnlTY2hlbWEgJHtyZWZ9IGlzIGxvYWRlZCBidXQgJHttaXNzaW5nUmVmfSBjYW5ub3QgYmUgcmVzb2x2ZWRgKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIGxvYWRNaXNzaW5nU2NoZW1hKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGNvbnN0IF9zY2hlbWEgPSBhd2FpdCBfbG9hZFNjaGVtYS5jYWxsKHRoaXMsIHJlZilcbiAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pIGF3YWl0IGxvYWRNZXRhU2NoZW1hLmNhbGwodGhpcywgX3NjaGVtYS4kc2NoZW1hKVxuICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSkgdGhpcy5hZGRTY2hlbWEoX3NjaGVtYSwgcmVmLCBtZXRhKVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9sb2FkU2NoZW1hKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBQcm9taXNlPEFueVNjaGVtYU9iamVjdD4ge1xuICAgICAgY29uc3QgcCA9IHRoaXMuX2xvYWRpbmdbcmVmXVxuICAgICAgaWYgKHApIHJldHVybiBwXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgKHRoaXMuX2xvYWRpbmdbcmVmXSA9IGxvYWRTY2hlbWEocmVmKSlcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9sb2FkaW5nW3JlZl1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBBZGRzIHNjaGVtYSB0byB0aGUgaW5zdGFuY2VcbiAgYWRkU2NoZW1hKFxuICAgIHNjaGVtYTogQW55U2NoZW1hIHwgQW55U2NoZW1hW10sIC8vIElmIGFycmF5IGlzIHBhc3NlZCwgYGtleWAgd2lsbCBiZSBpZ25vcmVkXG4gICAga2V5Pzogc3RyaW5nLCAvLyBPcHRpb25hbCBzY2hlbWEga2V5LiBDYW4gYmUgcGFzc2VkIHRvIGB2YWxpZGF0ZWAgbWV0aG9kIGluc3RlYWQgb2Ygc2NoZW1hIG9iamVjdCBvciBpZC9yZWYuIE9uZSBzY2hlbWEgcGVyIGluc3RhbmNlIGNhbiBoYXZlIGVtcHR5IGBpZGAgYW5kIGBrZXlgLlxuICAgIF9tZXRhPzogYm9vbGVhbiwgLy8gdHJ1ZSBpZiBzY2hlbWEgaXMgYSBtZXRhLXNjaGVtYS4gVXNlZCBpbnRlcm5hbGx5LCBhZGRNZXRhU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24uIFVzZWQgaW50ZXJuYWxseSwgb3B0aW9uIHZhbGlkYXRlU2NoZW1hIHNob3VsZCBiZSB1c2VkIGluc3RlYWQuXG4gICk6IEFqdiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgICAgZm9yIChjb25zdCBzY2ggb2Ygc2NoZW1hKSB0aGlzLmFkZFNjaGVtYShzY2gsIHVuZGVmaW5lZCwgX21ldGEsIF92YWxpZGF0ZVNjaGVtYSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGxldCBpZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXVxuICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGlkICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgJHtzY2hlbWFJZH0gbXVzdCBiZSBzdHJpbmdgKVxuICAgICAgfVxuICAgIH1cbiAgICBrZXkgPSBub3JtYWxpemVJZChrZXkgfHwgaWQpXG4gICAgdGhpcy5fY2hlY2tVbmlxdWUoa2V5KVxuICAgIHRoaXMuc2NoZW1hc1trZXldID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEsIGtleSwgX3ZhbGlkYXRlU2NoZW1hLCB0cnVlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBBZGQgc2NoZW1hIHRoYXQgd2lsbCBiZSB1c2VkIHRvIHZhbGlkYXRlIG90aGVyIHNjaGVtYXNcbiAgLy8gb3B0aW9ucyBpbiBNRVRBX0lHTk9SRV9PUFRJT05TIGFyZSBhbHdheSBzZXQgdG8gZmFsc2VcbiAgYWRkTWV0YVNjaGVtYShcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBrZXk/OiBzdHJpbmcsIC8vIHNjaGVtYSBrZXlcbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbiwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdmFsaWRhdGVTY2hlbWEgb3B0aW9uIGZvciBtZXRhLXNjaGVtYVxuICApOiBBanYge1xuICAgIHRoaXMuYWRkU2NoZW1hKHNjaGVtYSwga2V5LCB0cnVlLCBfdmFsaWRhdGVTY2hlbWEpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vICBWYWxpZGF0ZSBzY2hlbWEgYWdhaW5zdCBpdHMgbWV0YS1zY2hlbWFcbiAgdmFsaWRhdGVTY2hlbWEoc2NoZW1hOiBBbnlTY2hlbWEsIHRocm93T3JMb2dFcnJvcj86IGJvb2xlYW4pOiBib29sZWFuIHwgUHJvbWlzZTx1bmtub3duPiB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB0cnVlXG4gICAgbGV0ICRzY2hlbWE6IHN0cmluZyB8IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYVxuICAgIGlmICgkc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mICRzY2hlbWEgIT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJHNjaGVtYSBtdXN0IGJlIGEgc3RyaW5nXCIpXG4gICAgfVxuICAgICRzY2hlbWEgPSAkc2NoZW1hIHx8IHRoaXMub3B0cy5kZWZhdWx0TWV0YSB8fCB0aGlzLmRlZmF1bHRNZXRhKClcbiAgICBpZiAoISRzY2hlbWEpIHtcbiAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJtZXRhLXNjaGVtYSBub3QgYXZhaWxhYmxlXCIpXG4gICAgICB0aGlzLmVycm9ycyA9IG51bGxcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGNvbnN0IHZhbGlkID0gdGhpcy52YWxpZGF0ZSgkc2NoZW1hLCBzY2hlbWEpXG4gICAgaWYgKCF2YWxpZCAmJiB0aHJvd09yTG9nRXJyb3IpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBcInNjaGVtYSBpcyBpbnZhbGlkOiBcIiArIHRoaXMuZXJyb3JzVGV4dCgpXG4gICAgICBpZiAodGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hID09PSBcImxvZ1wiKSB0aGlzLmxvZ2dlci5lcnJvcihtZXNzYWdlKVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkXG4gIH1cblxuICAvLyBHZXQgY29tcGlsZWQgc2NoZW1hIGJ5IGBrZXlgIG9yIGByZWZgLlxuICAvLyAoYGtleWAgdGhhdCB3YXMgcGFzc2VkIHRvIGBhZGRTY2hlbWFgIG9yIGZ1bGwgc2NoZW1hIHJlZmVyZW5jZSAtIGBzY2hlbWEuJGlkYCBvciByZXNvbHZlZCBpZClcbiAgZ2V0U2NoZW1hPFQgPSB1bmtub3duPihrZXlSZWY6IHN0cmluZyk6IEFueVZhbGlkYXRlRnVuY3Rpb248VD4gfCB1bmRlZmluZWQge1xuICAgIGxldCBzY2hcbiAgICB3aGlsZSAodHlwZW9mIChzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBrZXlSZWYpKSA9PSBcInN0cmluZ1wiKSBrZXlSZWYgPSBzY2hcbiAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICAgIGNvbnN0IHJvb3QgPSBuZXcgU2NoZW1hRW52KHtzY2hlbWE6IHt9LCBzY2hlbWFJZH0pXG4gICAgICBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwga2V5UmVmKVxuICAgICAgaWYgKCFzY2gpIHJldHVyblxuICAgICAgdGhpcy5yZWZzW2tleVJlZl0gPSBzY2hcbiAgICB9XG4gICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKSBhcyBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHwgdW5kZWZpbmVkXG4gIH1cblxuICAvLyBSZW1vdmUgY2FjaGVkIHNjaGVtYShzKS5cbiAgLy8gSWYgbm8gcGFyYW1ldGVyIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAvLyBJZiBSZWdFeHAgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIHdpdGgga2V5L2lkIG1hdGNoaW5nIHBhdHRlcm4gYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgLy8gRXZlbiBpZiBzY2hlbWEgaXMgcmVmZXJlbmNlZCBieSBvdGhlciBzY2hlbWFzIGl0IHN0aWxsIGNhbiBiZSByZW1vdmVkIGFzIG90aGVyIHNjaGVtYXMgaGF2ZSBsb2NhbCByZWZlcmVuY2VzLlxuICByZW1vdmVTY2hlbWEoc2NoZW1hS2V5UmVmPzogQW55U2NoZW1hIHwgc3RyaW5nIHwgUmVnRXhwKTogQWp2IHtcbiAgICBpZiAoc2NoZW1hS2V5UmVmIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcywgc2NoZW1hS2V5UmVmKVxuICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMsIHNjaGVtYUtleVJlZilcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIHN3aXRjaCAodHlwZW9mIHNjaGVtYUtleVJlZikge1xuICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMuc2NoZW1hcylcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnJlZnMpXG4gICAgICAgIHRoaXMuX2NhY2hlLmNsZWFyKClcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICBjb25zdCBzY2ggPSBnZXRTY2hFbnYuY2FsbCh0aGlzLCBzY2hlbWFLZXlSZWYpXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwib2JqZWN0XCIpIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKVxuICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW3NjaGVtYUtleVJlZl1cbiAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tzY2hlbWFLZXlSZWZdXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBzY2hlbWFLZXlSZWZcbiAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKGNhY2hlS2V5KVxuICAgICAgICBsZXQgaWQgPSBzY2hlbWFLZXlSZWZbdGhpcy5vcHRzLnNjaGVtYUlkXVxuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbaWRdXG4gICAgICAgICAgZGVsZXRlIHRoaXMucmVmc1tpZF1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2LnJlbW92ZVNjaGVtYTogaW52YWxpZCBwYXJhbWV0ZXJcIilcbiAgICB9XG4gIH1cblxuICAvLyBhZGQgXCJ2b2NhYnVsYXJ5XCIgLSBhIGNvbGxlY3Rpb24gb2Yga2V5d29yZHNcbiAgYWRkVm9jYWJ1bGFyeShkZWZpbml0aW9uczogVm9jYWJ1bGFyeSk6IEFqdiB7XG4gICAgZm9yIChjb25zdCBkZWYgb2YgZGVmaW5pdGlvbnMpIHRoaXMuYWRkS2V5d29yZChkZWYpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGFkZEtleXdvcmQoXG4gICAga3dkT3JEZWY6IHN0cmluZyB8IEtleXdvcmREZWZpbml0aW9uLFxuICAgIGRlZj86IEtleXdvcmREZWZpbml0aW9uIC8vIGRlcHJlY2F0ZWRcbiAgKTogQWp2IHtcbiAgICBsZXQga2V5d29yZDogc3RyaW5nIHwgc3RyaW5nW11cbiAgICBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgIGtleXdvcmQgPSBrd2RPckRlZlxuICAgICAgaWYgKHR5cGVvZiBkZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aGlzLmxvZ2dlci53YXJuKFwidGhlc2UgcGFyYW1ldGVycyBhcmUgZGVwcmVjYXRlZCwgc2VlIGRvY3MgZm9yIGFkZEtleXdvcmRcIilcbiAgICAgICAgZGVmLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJvYmplY3RcIiAmJiBkZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZGVmID0ga3dkT3JEZWZcbiAgICAgIGtleXdvcmQgPSBkZWYua2V5d29yZFxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoa2V5d29yZCkgJiYgIWtleXdvcmQubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEtleXdvcmRzOiBrZXl3b3JkIG11c3QgYmUgc3RyaW5nIG9yIG5vbi1lbXB0eSBhcnJheVwiKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGFkZEtleXdvcmRzIHBhcmFtZXRlcnNcIilcbiAgICB9XG5cbiAgICBjaGVja0tleXdvcmQuY2FsbCh0aGlzLCBrZXl3b3JkLCBkZWYpXG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIGVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrd2QpKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAga2V5d29yZE1ldGFzY2hlbWEuY2FsbCh0aGlzLCBkZWYpXG4gICAgY29uc3QgZGVmaW5pdGlvbjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAgICAgIC4uLmRlZixcbiAgICAgIHR5cGU6IGdldEpTT05UeXBlcyhkZWYudHlwZSksXG4gICAgICBzY2hlbWFUeXBlOiBnZXRKU09OVHlwZXMoZGVmLnNjaGVtYVR5cGUpLFxuICAgIH1cbiAgICBlYWNoSXRlbShcbiAgICAgIGtleXdvcmQsXG4gICAgICBkZWZpbml0aW9uLnR5cGUubGVuZ3RoID09PSAwXG4gICAgICAgID8gKGspID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uKVxuICAgICAgICA6IChrKSA9PiBkZWZpbml0aW9uLnR5cGUuZm9yRWFjaCgodCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24sIHQpKVxuICAgIClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0S2V5d29yZChrZXl3b3JkOiBzdHJpbmcpOiBBZGRlZEtleXdvcmREZWZpbml0aW9uIHwgYm9vbGVhbiB7XG4gICAgY29uc3QgcnVsZSA9IHRoaXMuUlVMRVMuYWxsW2tleXdvcmRdXG4gICAgcmV0dXJuIHR5cGVvZiBydWxlID09IFwib2JqZWN0XCIgPyBydWxlLmRlZmluaXRpb24gOiAhIXJ1bGVcbiAgfVxuXG4gIC8vIFJlbW92ZSBrZXl3b3JkXG4gIHJlbW92ZUtleXdvcmQoa2V5d29yZDogc3RyaW5nKTogQWp2IHtcbiAgICAvLyBUT0RPIHJldHVybiB0eXBlIHNob3VsZCBiZSBBanZcbiAgICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICAgIGRlbGV0ZSBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXVxuICAgIGRlbGV0ZSBSVUxFUy5hbGxba2V5d29yZF1cbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIFJVTEVTLnJ1bGVzKSB7XG4gICAgICBjb25zdCBpID0gZ3JvdXAucnVsZXMuZmluZEluZGV4KChydWxlKSA9PiBydWxlLmtleXdvcmQgPT09IGtleXdvcmQpXG4gICAgICBpZiAoaSA+PSAwKSBncm91cC5ydWxlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEFkZCBmb3JtYXRcbiAgYWRkRm9ybWF0KG5hbWU6IHN0cmluZywgZm9ybWF0OiBGb3JtYXQpOiBBanYge1xuICAgIGlmICh0eXBlb2YgZm9ybWF0ID09IFwic3RyaW5nXCIpIGZvcm1hdCA9IG5ldyBSZWdFeHAoZm9ybWF0KVxuICAgIHRoaXMuZm9ybWF0c1tuYW1lXSA9IGZvcm1hdFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlcnJvcnNUZXh0KFxuICAgIGVycm9yczogRXJyb3JPYmplY3RbXSB8IG51bGwgfCB1bmRlZmluZWQgPSB0aGlzLmVycm9ycywgLy8gb3B0aW9uYWwgYXJyYXkgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgICB7c2VwYXJhdG9yID0gXCIsIFwiLCBkYXRhVmFyID0gXCJkYXRhXCJ9OiBFcnJvcnNUZXh0T3B0aW9ucyA9IHt9IC8vIG9wdGlvbmFsIG9wdGlvbnMgd2l0aCBwcm9wZXJ0aWVzIGBzZXBhcmF0b3JgIGFuZCBgZGF0YVZhcmBcbiAgKTogc3RyaW5nIHtcbiAgICBpZiAoIWVycm9ycyB8fCBlcnJvcnMubGVuZ3RoID09PSAwKSByZXR1cm4gXCJObyBlcnJvcnNcIlxuICAgIHJldHVybiBlcnJvcnNcbiAgICAgIC5tYXAoKGUpID0+IGAke2RhdGFWYXJ9JHtlLmluc3RhbmNlUGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIC5yZWR1Y2UoKHRleHQsIG1zZykgPT4gdGV4dCArIHNlcGFyYXRvciArIG1zZylcbiAgfVxuXG4gICRkYXRhTWV0YVNjaGVtYShtZXRhU2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsIGtleXdvcmRzSnNvblBvaW50ZXJzOiBzdHJpbmdbXSk6IEFueVNjaGVtYU9iamVjdCB7XG4gICAgY29uc3QgcnVsZXMgPSB0aGlzLlJVTEVTLmFsbFxuICAgIG1ldGFTY2hlbWEgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG1ldGFTY2hlbWEpKVxuICAgIGZvciAoY29uc3QganNvblBvaW50ZXIgb2Yga2V5d29yZHNKc29uUG9pbnRlcnMpIHtcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpLnNsaWNlKDEpIC8vIGZpcnN0IHNlZ21lbnQgaXMgYW4gZW1wdHkgc3RyaW5nXG4gICAgICBsZXQga2V5d29yZHMgPSBtZXRhU2NoZW1hXG4gICAgICBmb3IgKGNvbnN0IHNlZyBvZiBzZWdtZW50cykga2V5d29yZHMgPSBrZXl3b3Jkc1tzZWddIGFzIEFueVNjaGVtYU9iamVjdFxuXG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBydWxlcykge1xuICAgICAgICBjb25zdCBydWxlID0gcnVsZXNba2V5XVxuICAgICAgICBpZiAodHlwZW9mIHJ1bGUgIT0gXCJvYmplY3RcIikgY29udGludWVcbiAgICAgICAgY29uc3QgeyRkYXRhfSA9IHJ1bGUuZGVmaW5pdGlvblxuICAgICAgICBjb25zdCBzY2hlbWEgPSBrZXl3b3Jkc1trZXldIGFzIEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAoJGRhdGEgJiYgc2NoZW1hKSBrZXl3b3Jkc1trZXldID0gc2NoZW1hT3JEYXRhKHNjaGVtYSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YVNjaGVtYVxuICB9XG5cbiAgcHJpdmF0ZSBfcmVtb3ZlQWxsU2NoZW1hcyhzY2hlbWFzOiB7W1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgc3RyaW5nfSwgcmVnZXg/OiBSZWdFeHApOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGtleVJlZiBpbiBzY2hlbWFzKSB7XG4gICAgICBjb25zdCBzY2ggPSBzY2hlbWFzW2tleVJlZl1cbiAgICAgIGlmICghcmVnZXggfHwgcmVnZXgudGVzdChrZXlSZWYpKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2NoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoICYmICFzY2gubWV0YSkge1xuICAgICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShzY2guc2NoZW1hKVxuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9hZGRTY2hlbWEoXG4gICAgc2NoZW1hOiBBbnlTY2hlbWEsXG4gICAgbWV0YT86IGJvb2xlYW4sXG4gICAgYmFzZUlkPzogc3RyaW5nLFxuICAgIHZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hLFxuICAgIGFkZFNjaGVtYSA9IHRoaXMub3B0cy5hZGRVc2VkU2NoZW1hXG4gICk6IFNjaGVtYUVudiB7XG4gICAgbGV0IGlkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikge1xuICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLm9wdHMuanRkKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3RcIilcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIpIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdCBvciBib29sZWFuXCIpXG4gICAgfVxuICAgIGxldCBzY2ggPSB0aGlzLl9jYWNoZS5nZXQoc2NoZW1hKVxuICAgIGlmIChzY2ggIT09IHVuZGVmaW5lZCkgcmV0dXJuIHNjaFxuXG4gICAgYmFzZUlkID0gbm9ybWFsaXplSWQoaWQgfHwgYmFzZUlkKVxuICAgIGNvbnN0IGxvY2FsUmVmcyA9IGdldFNjaGVtYVJlZnMuY2FsbCh0aGlzLCBzY2hlbWEsIGJhc2VJZClcbiAgICBzY2ggPSBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCBtZXRhLCBiYXNlSWQsIGxvY2FsUmVmc30pXG4gICAgdGhpcy5fY2FjaGUuc2V0KHNjaC5zY2hlbWEsIHNjaClcbiAgICBpZiAoYWRkU2NoZW1hICYmICFiYXNlSWQuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgIC8vIFRPRE8gYXRtIGl0IGlzIGFsbG93ZWQgdG8gb3ZlcndyaXRlIHNjaGVtYXMgd2l0aG91dCBpZCAoaW5zdGVhZCBvZiBub3QgYWRkaW5nIHRoZW0pXG4gICAgICBpZiAoYmFzZUlkKSB0aGlzLl9jaGVja1VuaXF1ZShiYXNlSWQpXG4gICAgICB0aGlzLnJlZnNbYmFzZUlkXSA9IHNjaFxuICAgIH1cbiAgICBpZiAodmFsaWRhdGVTY2hlbWEpIHRoaXMudmFsaWRhdGVTY2hlbWEoc2NoZW1hLCB0cnVlKVxuICAgIHJldHVybiBzY2hcbiAgfVxuXG4gIHByaXZhdGUgX2NoZWNrVW5pcXVlKGlkOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5zY2hlbWFzW2lkXSB8fCB0aGlzLnJlZnNbaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSB3aXRoIGtleSBvciBpZCBcIiR7aWR9XCIgYWxyZWFkeSBleGlzdHNgKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2NvbXBpbGVTY2hlbWFFbnYoc2NoOiBTY2hlbWFFbnYpOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uIHtcbiAgICBpZiAoc2NoLm1ldGEpIHRoaXMuX2NvbXBpbGVNZXRhU2NoZW1hKHNjaClcbiAgICBlbHNlIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXNjaC52YWxpZGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICB9XG5cbiAgcHJpdmF0ZSBfY29tcGlsZU1ldGFTY2hlbWEoc2NoOiBTY2hlbWFFbnYpOiB2b2lkIHtcbiAgICBjb25zdCBjdXJyZW50T3B0cyA9IHRoaXMub3B0c1xuICAgIHRoaXMub3B0cyA9IHRoaXMuX21ldGFPcHRzXG4gICAgdHJ5IHtcbiAgICAgIGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMub3B0cyA9IGN1cnJlbnRPcHRzXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JzVGV4dE9wdGlvbnMge1xuICBzZXBhcmF0b3I/OiBzdHJpbmdcbiAgZGF0YVZhcj86IHN0cmluZ1xufVxuXG5mdW5jdGlvbiBjaGVja09wdGlvbnMoXG4gIHRoaXM6IEFqdixcbiAgY2hlY2tPcHRzOiBPcHRpb25zSW5mbzxSZW1vdmVkT3B0aW9ucyB8IERlcHJlY2F0ZWRPcHRpb25zPixcbiAgb3B0aW9uczogT3B0aW9ucyAmIFJlbW92ZWRPcHRpb25zLFxuICBtc2c6IHN0cmluZyxcbiAgbG9nOiBcIndhcm5cIiB8IFwiZXJyb3JcIiA9IFwiZXJyb3JcIlxuKTogdm9pZCB7XG4gIGZvciAoY29uc3Qga2V5IGluIGNoZWNrT3B0cykge1xuICAgIGNvbnN0IG9wdCA9IGtleSBhcyBrZXlvZiB0eXBlb2YgY2hlY2tPcHRzXG4gICAgaWYgKG9wdCBpbiBvcHRpb25zKSB0aGlzLmxvZ2dlcltsb2ddKGAke21zZ306IG9wdGlvbiAke2tleX0uICR7Y2hlY2tPcHRzW29wdF19YClcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTY2hFbnYodGhpczogQWp2LCBrZXlSZWY6IHN0cmluZyk6IFNjaGVtYUVudiB8IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGtleVJlZiA9IG5vcm1hbGl6ZUlkKGtleVJlZikgLy8gVE9ETyB0ZXN0cyBmYWlsIHdpdGhvdXQgdGhpcyBsaW5lXG4gIHJldHVybiB0aGlzLnNjaGVtYXNba2V5UmVmXSB8fCB0aGlzLnJlZnNba2V5UmVmXVxufVxuXG5mdW5jdGlvbiBhZGRJbml0aWFsU2NoZW1hcyh0aGlzOiBBanYpOiB2b2lkIHtcbiAgY29uc3Qgb3B0c1NjaGVtYXMgPSB0aGlzLm9wdHMuc2NoZW1hc1xuICBpZiAoIW9wdHNTY2hlbWFzKSByZXR1cm5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0c1NjaGVtYXMpKSB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hcylcbiAgZWxzZSBmb3IgKGNvbnN0IGtleSBpbiBvcHRzU2NoZW1hcykgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXNba2V5XSBhcyBBbnlTY2hlbWEsIGtleSlcbn1cblxuZnVuY3Rpb24gYWRkSW5pdGlhbEZvcm1hdHModGhpczogQWp2KTogdm9pZCB7XG4gIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLm9wdHMuZm9ybWF0cykge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMub3B0cy5mb3JtYXRzW25hbWVdXG4gICAgaWYgKGZvcm1hdCkgdGhpcy5hZGRGb3JtYXQobmFtZSwgZm9ybWF0KVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxLZXl3b3JkcyhcbiAgdGhpczogQWp2LFxuICBkZWZzOiBWb2NhYnVsYXJ5IHwge1tLIGluIHN0cmluZ10/OiBLZXl3b3JkRGVmaW5pdGlvbn1cbik6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWZzKSkge1xuICAgIHRoaXMuYWRkVm9jYWJ1bGFyeShkZWZzKVxuICAgIHJldHVyblxuICB9XG4gIHRoaXMubG9nZ2VyLndhcm4oXCJrZXl3b3JkcyBvcHRpb24gYXMgbWFwIGlzIGRlcHJlY2F0ZWQsIHBhc3MgYXJyYXlcIilcbiAgZm9yIChjb25zdCBrZXl3b3JkIGluIGRlZnMpIHtcbiAgICBjb25zdCBkZWYgPSBkZWZzW2tleXdvcmRdIGFzIEtleXdvcmREZWZpbml0aW9uXG4gICAgaWYgKCFkZWYua2V5d29yZCkgZGVmLmtleXdvcmQgPSBrZXl3b3JkXG4gICAgdGhpcy5hZGRLZXl3b3JkKGRlZilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRNZXRhU2NoZW1hT3B0aW9ucyh0aGlzOiBBanYpOiBJbnN0YW5jZU9wdGlvbnMge1xuICBjb25zdCBtZXRhT3B0cyA9IHsuLi50aGlzLm9wdHN9XG4gIGZvciAoY29uc3Qgb3B0IG9mIE1FVEFfSUdOT1JFX09QVElPTlMpIGRlbGV0ZSBtZXRhT3B0c1tvcHRdXG4gIHJldHVybiBtZXRhT3B0c1xufVxuXG5jb25zdCBub0xvZ3MgPSB7bG9nKCkge30sIHdhcm4oKSB7fSwgZXJyb3IoKSB7fX1cblxuZnVuY3Rpb24gZ2V0TG9nZ2VyKGxvZ2dlcj86IFBhcnRpYWw8TG9nZ2VyPiB8IGZhbHNlKTogTG9nZ2VyIHtcbiAgaWYgKGxvZ2dlciA9PT0gZmFsc2UpIHJldHVybiBub0xvZ3NcbiAgaWYgKGxvZ2dlciA9PT0gdW5kZWZpbmVkKSByZXR1cm4gY29uc29sZVxuICBpZiAobG9nZ2VyLmxvZyAmJiBsb2dnZXIud2FybiAmJiBsb2dnZXIuZXJyb3IpIHJldHVybiBsb2dnZXIgYXMgTG9nZ2VyXG4gIHRocm93IG5ldyBFcnJvcihcImxvZ2dlciBtdXN0IGltcGxlbWVudCBsb2csIHdhcm4gYW5kIGVycm9yIG1ldGhvZHNcIilcbn1cblxuY29uc3QgS0VZV09SRF9OQU1FID0gL15bYS16XyRdW2EtejAtOV8kOi1dKiQvaVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmQodGhpczogQWp2LCBrZXl3b3JkOiBzdHJpbmcgfCBzdHJpbmdbXSwgZGVmPzogS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge1JVTEVTfSA9IHRoaXNcbiAgZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4ge1xuICAgIGlmIChSVUxFUy5rZXl3b3Jkc1trd2RdKSB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGlzIGFscmVhZHkgZGVmaW5lZGApXG4gICAgaWYgKCFLRVlXT1JEX05BTUUudGVzdChrd2QpKSB0aHJvdyBuZXcgRXJyb3IoYEtleXdvcmQgJHtrd2R9IGhhcyBpbnZhbGlkIG5hbWVgKVxuICB9KVxuICBpZiAoIWRlZikgcmV0dXJuXG4gIGlmIChkZWYuJGRhdGEgJiYgIShcImNvZGVcIiBpbiBkZWYgfHwgXCJ2YWxpZGF0ZVwiIGluIGRlZikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJyRkYXRhIGtleXdvcmQgbXVzdCBoYXZlIFwiY29kZVwiIG9yIFwidmFsaWRhdGVcIiBmdW5jdGlvbicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkUnVsZShcbiAgdGhpczogQWp2LFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gIGRlZmluaXRpb24/OiBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBkYXRhVHlwZT86IEpTT05UeXBlXG4pOiB2b2lkIHtcbiAgY29uc3QgcG9zdCA9IGRlZmluaXRpb24/LnBvc3RcbiAgaWYgKGRhdGFUeXBlICYmIHBvc3QpIHRocm93IG5ldyBFcnJvcigna2V5d29yZCB3aXRoIFwicG9zdFwiIGZsYWcgY2Fubm90IGhhdmUgXCJ0eXBlXCInKVxuICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICBsZXQgcnVsZUdyb3VwID0gcG9zdCA/IFJVTEVTLnBvc3QgOiBSVUxFUy5ydWxlcy5maW5kKCh7dHlwZTogdH0pID0+IHQgPT09IGRhdGFUeXBlKVxuICBpZiAoIXJ1bGVHcm91cCkge1xuICAgIHJ1bGVHcm91cCA9IHt0eXBlOiBkYXRhVHlwZSwgcnVsZXM6IFtdfVxuICAgIFJVTEVTLnJ1bGVzLnB1c2gocnVsZUdyb3VwKVxuICB9XG4gIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdID0gdHJ1ZVxuICBpZiAoIWRlZmluaXRpb24pIHJldHVyblxuXG4gIGNvbnN0IHJ1bGU6IFJ1bGUgPSB7XG4gICAga2V5d29yZCxcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAuLi5kZWZpbml0aW9uLFxuICAgICAgdHlwZTogZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24udHlwZSksXG4gICAgICBzY2hlbWFUeXBlOiBnZXRKU09OVHlwZXMoZGVmaW5pdGlvbi5zY2hlbWFUeXBlKSxcbiAgICB9LFxuICB9XG4gIGlmIChkZWZpbml0aW9uLmJlZm9yZSkgYWRkQmVmb3JlUnVsZS5jYWxsKHRoaXMsIHJ1bGVHcm91cCwgcnVsZSwgZGVmaW5pdGlvbi5iZWZvcmUpXG4gIGVsc2UgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSlcbiAgUlVMRVMuYWxsW2tleXdvcmRdID0gcnVsZVxuICBkZWZpbml0aW9uLmltcGxlbWVudHM/LmZvckVhY2goKGt3ZCkgPT4gdGhpcy5hZGRLZXl3b3JkKGt3ZCkpXG59XG5cbmZ1bmN0aW9uIGFkZEJlZm9yZVJ1bGUodGhpczogQWp2LCBydWxlR3JvdXA6IFJ1bGVHcm91cCwgcnVsZTogUnVsZSwgYmVmb3JlOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3QgaSA9IHJ1bGVHcm91cC5ydWxlcy5maW5kSW5kZXgoKF9ydWxlKSA9PiBfcnVsZS5rZXl3b3JkID09PSBiZWZvcmUpXG4gIGlmIChpID49IDApIHtcbiAgICBydWxlR3JvdXAucnVsZXMuc3BsaWNlKGksIDAsIHJ1bGUpXG4gIH0gZWxzZSB7XG4gICAgcnVsZUdyb3VwLnJ1bGVzLnB1c2gocnVsZSlcbiAgICB0aGlzLmxvZ2dlci53YXJuKGBydWxlICR7YmVmb3JlfSBpcyBub3QgZGVmaW5lZGApXG4gIH1cbn1cblxuZnVuY3Rpb24ga2V5d29yZE1ldGFzY2hlbWEodGhpczogQWp2LCBkZWY6IEtleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGxldCB7bWV0YVNjaGVtYX0gPSBkZWZcbiAgaWYgKG1ldGFTY2hlbWEgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGlmIChkZWYuJGRhdGEgJiYgdGhpcy5vcHRzLiRkYXRhKSBtZXRhU2NoZW1hID0gc2NoZW1hT3JEYXRhKG1ldGFTY2hlbWEpXG4gIGRlZi52YWxpZGF0ZVNjaGVtYSA9IHRoaXMuY29tcGlsZShtZXRhU2NoZW1hLCB0cnVlKVxufVxuXG5jb25zdCAkZGF0YVJlZiA9IHtcbiAgJHJlZjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbn1cblxuZnVuY3Rpb24gc2NoZW1hT3JEYXRhKHNjaGVtYTogQW55U2NoZW1hKTogQW55U2NoZW1hT2JqZWN0IHtcbiAgcmV0dXJuIHthbnlPZjogW3NjaGVtYSwgJGRhdGFSZWZdfVxufVxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImlkXCIsXG4gIGNvZGUoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOT1QgU1VQUE9SVEVEOiBrZXl3b3JkIFwiaWRcIiwgdXNlIFwiJGlkXCIgZm9yIHNjaGVtYSBJRCcpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQgTWlzc2luZ1JlZkVycm9yIGZyb20gXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge2NhbGxWYWxpZGF0ZUNvZGV9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7XywgbmlsLCBzdHJpbmdpZnksIENvZGUsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHtTY2hlbWFFbnYsIHJlc29sdmVSZWZ9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcbmltcG9ydCB7bWVyZ2VFdmFsdWF0ZWR9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCIkcmVmXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KTogdm9pZCB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hOiAkcmVmLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7YmFzZUlkLCBzY2hlbWFFbnY6IGVudiwgdmFsaWRhdGVOYW1lLCBvcHRzLCBzZWxmfSA9IGl0XG4gICAgY29uc3Qge3Jvb3R9ID0gZW52XG4gICAgaWYgKCgkcmVmID09PSBcIiNcIiB8fCAkcmVmID09PSBcIiMvXCIpICYmIGJhc2VJZCA9PT0gcm9vdC5iYXNlSWQpIHJldHVybiBjYWxsUm9vdFJlZigpXG4gICAgY29uc3Qgc2NoT3JFbnYgPSByZXNvbHZlUmVmLmNhbGwoc2VsZiwgcm9vdCwgYmFzZUlkLCAkcmVmKVxuICAgIGlmIChzY2hPckVudiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgTWlzc2luZ1JlZkVycm9yKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgJHJlZilcbiAgICBpZiAoc2NoT3JFbnYgaW5zdGFuY2VvZiBTY2hlbWFFbnYpIHJldHVybiBjYWxsVmFsaWRhdGUoc2NoT3JFbnYpXG4gICAgcmV0dXJuIGlubGluZVJlZlNjaGVtYShzY2hPckVudilcblxuICAgIGZ1bmN0aW9uIGNhbGxSb290UmVmKCk6IHZvaWQge1xuICAgICAgaWYgKGVudiA9PT0gcm9vdCkgcmV0dXJuIGNhbGxSZWYoY3h0LCB2YWxpZGF0ZU5hbWUsIGVudiwgZW52LiRhc3luYylcbiAgICAgIGNvbnN0IHJvb3ROYW1lID0gZ2VuLnNjb3BlVmFsdWUoXCJyb290XCIsIHtyZWY6IHJvb3R9KVxuICAgICAgcmV0dXJuIGNhbGxSZWYoY3h0LCBfYCR7cm9vdE5hbWV9LnZhbGlkYXRlYCwgcm9vdCwgcm9vdC4kYXN5bmMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbFZhbGlkYXRlKHNjaDogU2NoZW1hRW52KTogdm9pZCB7XG4gICAgICBjb25zdCB2ID0gZ2V0VmFsaWRhdGUoY3h0LCBzY2gpXG4gICAgICBjYWxsUmVmKGN4dCwgdiwgc2NoLCBzY2guJGFzeW5jKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlubGluZVJlZlNjaGVtYShzY2g6IEFueVNjaGVtYSk6IHZvaWQge1xuICAgICAgY29uc3Qgc2NoTmFtZSA9IGdlbi5zY29wZVZhbHVlKFxuICAgICAgICBcInNjaGVtYVwiLFxuICAgICAgICBvcHRzLmNvZGUuc291cmNlID09PSB0cnVlID8ge3JlZjogc2NoLCBjb2RlOiBzdHJpbmdpZnkoc2NoKX0gOiB7cmVmOiBzY2h9XG4gICAgICApXG4gICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICBkYXRhVHlwZXM6IFtdLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IG5pbCxcbiAgICAgICAgICB0b3BTY2hlbWFSZWY6IHNjaE5hbWUsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogJHJlZixcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmFsaWRhdGUoY3h0OiBLZXl3b3JkQ3h0LCBzY2g6IFNjaGVtYUVudik6IENvZGUge1xuICBjb25zdCB7Z2VufSA9IGN4dFxuICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gICAgPyBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlXCIsIHtyZWY6IHNjaC52YWxpZGF0ZX0pXG4gICAgOiBfYCR7Z2VuLnNjb3BlVmFsdWUoXCJ3cmFwcGVyXCIsIHtyZWY6IHNjaH0pfS52YWxpZGF0ZWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNhbGxSZWYoY3h0OiBLZXl3b3JkQ3h0LCB2OiBDb2RlLCBzY2g/OiBTY2hlbWFFbnYsICRhc3luYz86IGJvb2xlYW4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgaXR9ID0gY3h0XG4gIGNvbnN0IHthbGxFcnJvcnMsIHNjaGVtYUVudjogZW52LCBvcHRzfSA9IGl0XG4gIGNvbnN0IHBhc3NDeHQgPSBvcHRzLnBhc3NDb250ZXh0ID8gTi50aGlzIDogbmlsXG4gIGlmICgkYXN5bmMpIGNhbGxBc3luY1JlZigpXG4gIGVsc2UgY2FsbFN5bmNSZWYoKVxuXG4gIGZ1bmN0aW9uIGNhbGxBc3luY1JlZigpOiB2b2lkIHtcbiAgICBpZiAoIWVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSByZWZlcmVuY2VkIGJ5IHN5bmMgc2NoZW1hXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICBnZW4udHJ5KFxuICAgICAgKCkgPT4ge1xuICAgICAgICBnZW4uY29kZShfYGF3YWl0ICR7Y2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpfWApXG4gICAgICAgIGFkZEV2YWx1YXRlZEZyb20odikgLy8gVE9ETyB3aWxsIG5vdCB3b3JrIHdpdGggYXN5bmMsIGl0IGhhcyB0byBiZSByZXR1cm5lZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICB9LFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgZ2VuLmlmKF9gISgke2V9IGluc3RhbmNlb2YgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0pYCwgKCkgPT4gZ2VuLnRocm93KGUpKVxuICAgICAgICBhZGRFcnJvcnNGcm9tKGUpXG4gICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgIH1cbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG5cbiAgZnVuY3Rpb24gY2FsbFN5bmNSZWYoKTogdm9pZCB7XG4gICAgY3h0LnJlc3VsdChcbiAgICAgIGNhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KSxcbiAgICAgICgpID0+IGFkZEV2YWx1YXRlZEZyb20odiksXG4gICAgICAoKSA9PiBhZGRFcnJvcnNGcm9tKHYpXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXJyb3JzRnJvbShzb3VyY2U6IENvZGUpOiB2b2lkIHtcbiAgICBjb25zdCBlcnJzID0gX2Ake3NvdXJjZX0uZXJyb3JzYFxuICAgIGdlbi5hc3NpZ24oTi52RXJyb3JzLCBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke04udkVycm9yc30uY29uY2F0KCR7ZXJyc30pYCkgLy8gVE9ETyB0YWdnZWRcbiAgICBnZW4uYXNzaWduKE4uZXJyb3JzLCBfYCR7Ti52RXJyb3JzfS5sZW5ndGhgKVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkRXZhbHVhdGVkRnJvbShzb3VyY2U6IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuICAgIGNvbnN0IHNjaEV2YWx1YXRlZCA9IHNjaD8udmFsaWRhdGU/LmV2YWx1YXRlZFxuICAgIC8vIFRPRE8gcmVmYWN0b3JcbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljUHJvcHMpIHtcbiAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5wcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaEV2YWx1YXRlZC5wcm9wcywgaXQucHJvcHMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIF9gJHtzb3VyY2V9LmV2YWx1YXRlZC5wcm9wc2ApXG4gICAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBwcm9wcywgaXQucHJvcHMsIE5hbWUpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNJdGVtcykge1xuICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLml0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoRXZhbHVhdGVkLml0ZW1zLCBpdC5pdGVtcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBnZW4udmFyKFwiaXRlbXNcIiwgX2Ake3NvdXJjZX0uZXZhbHVhdGVkLml0ZW1zYClcbiAgICAgICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIGl0ZW1zLCBpdC5pdGVtcywgTmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgaWRLZXl3b3JkIGZyb20gXCIuL2lkXCJcbmltcG9ydCByZWZLZXl3b3JkIGZyb20gXCIuL3JlZlwiXG5cbmNvbnN0IGNvcmU6IFZvY2FidWxhcnkgPSBbXG4gIFwiJHNjaGVtYVwiLFxuICBcIiRpZFwiLFxuICBcIiRkZWZzXCIsXG4gIFwiJHZvY2FidWxhcnlcIixcbiAge2tleXdvcmQ6IFwiJGNvbW1lbnRcIn0sXG4gIFwiZGVmaW5pdGlvbnNcIixcbiAgaWRLZXl3b3JkLFxuICByZWZLZXl3b3JkLFxuXVxuXG5leHBvcnQgZGVmYXVsdCBjb3JlXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9ycywgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IG9wcyA9IG9wZXJhdG9yc1xuXG50eXBlIEt3ZCA9IFwibWF4aW11bVwiIHwgXCJtaW5pbXVtXCIgfCBcImV4Y2x1c2l2ZU1heGltdW1cIiB8IFwiZXhjbHVzaXZlTWluaW11bVwiXG5cbnR5cGUgQ29tcGFyaXNvbiA9IFwiPD1cIiB8IFwiPj1cIiB8IFwiPFwiIHwgXCI+XCJcblxuY29uc3QgS1dEczoge1tLIGluIEt3ZF06IHtva1N0cjogQ29tcGFyaXNvbjsgb2s6IENvZGU7IGZhaWw6IENvZGV9fSA9IHtcbiAgbWF4aW11bToge29rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1R9LFxuICBtaW5pbXVtOiB7b2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVH0sXG4gIGV4Y2x1c2l2ZU1heGltdW06IHtva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEV9LFxuICBleGNsdXNpdmVNaW5pbXVtOiB7b2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFfSxcbn1cblxuZXhwb3J0IHR5cGUgTGltaXROdW1iZXJFcnJvciA9IEVycm9yT2JqZWN0PFxuICBLd2QsXG4gIHtsaW1pdDogbnVtYmVyOyBjb21wYXJpc29uOiBDb21wYXJpc29ufSxcbiAgbnVtYmVyIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBiZSAke0tXRHNba2V5d29yZCBhcyBLd2RdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgcGFyYW1zOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PlxuICAgIF9ge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gIHR5cGU6IFwibnVtYmVyXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZX0gPSBjeHRcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtkYXRhfSAke0tXRHNba2V5d29yZCBhcyBLd2RdLmZhaWx9ICR7c2NoZW1hQ29kZX0gfHwgaXNOYU4oJHtkYXRhfSlgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB0eXBlIE11bHRpcGxlT2ZFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm11bHRpcGxlT2ZcIixcbiAge211bHRpcGxlT2Y6IG51bWJlcn0sXG4gIG51bWJlciB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgYmUgbXVsdGlwbGUgb2YgJHtzY2hlbWFDb2RlfWAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bXVsdGlwbGVPZjogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJtdWx0aXBsZU9mXCIsXG4gIHR5cGU6IFwibnVtYmVyXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICAvLyBjb25zdCBiZHQgPSBiYWQkRGF0YVR5cGUoc2NoZW1hQ29kZSwgPHN0cmluZz5kZWYuc2NoZW1hVHlwZSwgJGRhdGEpXG4gICAgY29uc3QgcHJlYyA9IGl0Lm9wdHMubXVsdGlwbGVPZlByZWNpc2lvblxuICAgIGNvbnN0IHJlcyA9IGdlbi5sZXQoXCJyZXNcIilcbiAgICBjb25zdCBpbnZhbGlkID0gcHJlY1xuICAgICAgPyBfYE1hdGguYWJzKE1hdGgucm91bmQoJHtyZXN9KSAtICR7cmVzfSkgPiAxZS0ke3ByZWN9YFxuICAgICAgOiBfYCR7cmVzfSAhPT0gcGFyc2VJbnQoJHtyZXN9KWBcbiAgICBjeHQuZmFpbCRkYXRhKF9gKCR7c2NoZW1hQ29kZX0gPT09IDAgfHwgKCR7cmVzfSA9ICR7ZGF0YX0vJHtzY2hlbWFDb2RlfSwgJHtpbnZhbGlkfSkpYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiLy8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmdcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iZXN0aWVqcy9wdW55Y29kZS5qcyAtIHB1bnljb2RlLnVjczIuZGVjb2RlXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1Y3MybGVuZ3RoKHN0cjogc3RyaW5nKTogbnVtYmVyIHtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aFxuICBsZXQgbGVuZ3RoID0gMFxuICBsZXQgcG9zID0gMFxuICBsZXQgdmFsdWU6IG51bWJlclxuICB3aGlsZSAocG9zIDwgbGVuKSB7XG4gICAgbGVuZ3RoKytcbiAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcysrKVxuICAgIGlmICh2YWx1ZSA+PSAweGQ4MDAgJiYgdmFsdWUgPD0gMHhkYmZmICYmIHBvcyA8IGxlbikge1xuICAgICAgLy8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG4gICAgICB2YWx1ZSA9IHN0ci5jaGFyQ29kZUF0KHBvcylcbiAgICAgIGlmICgodmFsdWUgJiAweGZjMDApID09PSAweGRjMDApIHBvcysrIC8vIGxvdyBzdXJyb2dhdGVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxlbmd0aFxufVxuXG51Y3MybGVuZ3RoLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdWNzMmxlbmd0aFwiKS5kZWZhdWx0J1xuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHVjczJsZW5ndGggZnJvbSBcIi4uLy4uL3J1bnRpbWUvdWNzMmxlbmd0aFwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gY2hhcmFjdGVyc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4TGVuZ3RoXCIsIFwibWluTGVuZ3RoXCJdLFxuICB0eXBlOiBcInN0cmluZ1wiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGNvbnN0IGxlbiA9XG4gICAgICBpdC5vcHRzLnVuaWNvZGUgPT09IGZhbHNlID8gX2Ake2RhdGF9Lmxlbmd0aGAgOiBfYCR7dXNlRnVuYyhjeHQuZ2VuLCB1Y3MybGVuZ3RoKX0oJHtkYXRhfSlgXG4gICAgY3h0LmZhaWwkZGF0YShfYCR7bGVufSAke29wfSAke3NjaGVtYUNvZGV9YClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHt1c2VQYXR0ZXJufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB0eXBlIFBhdHRlcm5FcnJvciA9IEVycm9yT2JqZWN0PFwicGF0dGVyblwiLCB7cGF0dGVybjogc3RyaW5nfSwgc3RyaW5nIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgbWF0Y2ggcGF0dGVybiBcIiR7c2NoZW1hQ29kZX1cImAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7cGF0dGVybjogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwYXR0ZXJuXCIsXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7ZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgLy8gVE9ETyByZWdleHAgc2hvdWxkIGJlIHdyYXBwZWQgaW4gdHJ5L2NhdGNoc1xuICAgIGNvbnN0IHUgPSBpdC5vcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCJcbiAgICBjb25zdCByZWdFeHAgPSAkZGF0YSA/IF9gKG5ldyBSZWdFeHAoJHtzY2hlbWFDb2RlfSwgJHt1fSkpYCA6IHVzZVBhdHRlcm4oY3h0LCBzY2hlbWEpXG4gICAgY3h0LmZhaWwkZGF0YShfYCEke3JlZ0V4cH0udGVzdCgke2RhdGF9KWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiXG4gICAgcmV0dXJuIHN0cmBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IHByb3BlcnRpZXNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heFByb3BlcnRpZXNcIiwgXCJtaW5Qcm9wZXJ0aWVzXCJdLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGV9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heFByb3BlcnRpZXNcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGN4dC5mYWlsJGRhdGEoX2BPYmplY3Qua2V5cygke2RhdGF9KS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7XG4gIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AsXG4gIGNoZWNrTWlzc2luZ1Byb3AsXG4gIHJlcG9ydE1pc3NpbmdQcm9wLFxuICBwcm9wZXJ0eUluRGF0YSxcbiAgbm9Qcm9wZXJ0eUluRGF0YSxcbn0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5pbCwgbm90LCBOYW1lLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgUmVxdWlyZWRFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcInJlcXVpcmVkXCIsXG4gIHttaXNzaW5nUHJvcGVydHk6IHN0cmluZ30sXG4gIHN0cmluZ1tdIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge21pc3NpbmdQcm9wZXJ0eX19KSA9PiBzdHJgbXVzdCBoYXZlIHJlcXVpcmVkIHByb3BlcnR5ICcke21pc3NpbmdQcm9wZXJ0eX0nYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge21pc3NpbmdQcm9wZXJ0eX19KSA9PiBfYHttaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJyZXF1aXJlZFwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGRhdGEsICRkYXRhLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0c30gPSBpdFxuICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gb3B0cy5sb29wUmVxdWlyZWRcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSBhbGxFcnJvcnNNb2RlKClcbiAgICBlbHNlIGV4aXRPbkVycm9yTW9kZSgpXG5cbiAgICBpZiAob3B0cy5zdHJpY3RSZXF1aXJlZCkge1xuICAgICAgY29uc3QgcHJvcHMgPSBjeHQucGFyZW50U2NoZW1hLnByb3BlcnRpZXNcbiAgICAgIGNvbnN0IHtkZWZpbmVkUHJvcGVydGllc30gPSBjeHQuaXRcbiAgICAgIGZvciAoY29uc3QgcmVxdWlyZWRLZXkgb2Ygc2NoZW1hKSB7XG4gICAgICAgIGlmIChwcm9wcz8uW3JlcXVpcmVkS2V5XSA9PT0gdW5kZWZpbmVkICYmICFkZWZpbmVkUHJvcGVydGllcy5oYXMocmVxdWlyZWRLZXkpKSB7XG4gICAgICAgICAgY29uc3Qgc2NoZW1hUGF0aCA9IGl0LnNjaGVtYUVudi5iYXNlSWQgKyBpdC5lcnJTY2hlbWFQYXRoXG4gICAgICAgICAgY29uc3QgbXNnID0gYHJlcXVpcmVkIHByb3BlcnR5IFwiJHtyZXF1aXJlZEtleX1cIiBpcyBub3QgZGVmaW5lZCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0UmVxdWlyZWQpYFxuICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBpdC5vcHRzLnN0cmljdFJlcXVpcmVkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWxsRXJyb3JzTW9kZSgpOiB2b2lkIHtcbiAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgIGN4dC5ibG9jayRkYXRhKG5pbCwgbG9vcEFsbFJlcXVpcmVkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBwcm9wIG9mIHNjaGVtYSkge1xuICAgICAgICAgIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBwcm9wKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhpdE9uRXJyb3JNb2RlKCk6IHZvaWQge1xuICAgICAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpXG4gICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKVxuICAgICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgKCkgPT4gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nLCB2YWxpZCkpXG4gICAgICAgIGN4dC5vayh2YWxpZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihjaGVja01pc3NpbmdQcm9wKGN4dCwgc2NoZW1hLCBtaXNzaW5nKSlcbiAgICAgICAgcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKVxuICAgICAgICBnZW4uZWxzZSgpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcEFsbFJlcXVpcmVkKCk6IHZvaWQge1xuICAgICAgZ2VuLmZvck9mKFwicHJvcFwiLCBzY2hlbWFDb2RlIGFzIENvZGUsIChwcm9wKSA9PiB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogcHJvcH0pXG4gICAgICAgIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4gY3h0LmVycm9yKCkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZzogTmFtZSwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogbWlzc2luZ30pXG4gICAgICBnZW4uZm9yT2YoXG4gICAgICAgIG1pc3NpbmcsXG4gICAgICAgIHNjaGVtYUNvZGUgYXMgQ29kZSxcbiAgICAgICAgKCkgPT4ge1xuICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgbWlzc2luZywgb3B0cy5vd25Qcm9wZXJ0aWVzKSlcbiAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5icmVhaygpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgbmlsXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBvcGVyYXRvcnN9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZSh7a2V5d29yZCwgc2NoZW1hQ29kZX0pIHtcbiAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gaXRlbXNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heEl0ZW1zXCIsIFwibWluSXRlbXNcIl0sXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlfSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhJdGVtc1wiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY3h0LmZhaWwkZGF0YShfYCR7ZGF0YX0ubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICIvLyBodHRwczovL2dpdGh1Yi5jb20vYWp2LXZhbGlkYXRvci9hanYvaXNzdWVzLzg4OVxuaW1wb3J0ICogYXMgZXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbFwiXG5cbnR5cGUgRXF1YWwgPSB0eXBlb2YgZXF1YWwgJiB7Y29kZTogc3RyaW5nfVxuOyhlcXVhbCBhcyBFcXVhbCkuY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS9lcXVhbFwiKS5kZWZhdWx0J1xuXG5leHBvcnQgZGVmYXVsdCBlcXVhbCBhcyBFcXVhbFxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Y2hlY2tEYXRhVHlwZXMsIGdldFNjaGVtYVR5cGVzLCBEYXRhVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIlxuaW1wb3J0IHtfLCBzdHIsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIFVuaXF1ZUl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJ1bmlxdWVJdGVtc1wiLFxuICB7aTogbnVtYmVyOyBqOiBudW1iZXJ9LFxuICBib29sZWFuIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2ksIGp9fSkgPT5cbiAgICBzdHJgbXVzdCBOT1QgaGF2ZSBkdXBsaWNhdGUgaXRlbXMgKGl0ZW1zICMjICR7an0gYW5kICR7aX0gYXJlIGlkZW50aWNhbClgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7aSwgan19KSA9PiBfYHtpOiAke2l9LCBqOiAke2p9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogXCJib29sZWFuXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGlmICghJGRhdGEgJiYgIXNjaGVtYSkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICBjb25zdCBpdGVtVHlwZXMgPSBwYXJlbnRTY2hlbWEuaXRlbXMgPyBnZXRTY2hlbWFUeXBlcyhwYXJlbnRTY2hlbWEuaXRlbXMpIDogW11cbiAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVVbmlxdWVJdGVtcywgX2Ake3NjaGVtYUNvZGV9ID09PSBmYWxzZWApXG4gICAgY3h0Lm9rKHZhbGlkKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVVbmlxdWVJdGVtcygpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGkgPSBnZW4ubGV0KFwiaVwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICAgIGNvbnN0IGogPSBnZW4ubGV0KFwialwiKVxuICAgICAgY3h0LnNldFBhcmFtcyh7aSwgan0pXG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgZ2VuLmlmKF9gJHtpfSA+IDFgLCAoKSA9PiAoY2FuT3B0aW1pemUoKSA/IGxvb3BOIDogbG9vcE4yKShpLCBqKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5PcHRpbWl6ZSgpOiBib29sZWFuIHtcbiAgICAgIHJldHVybiBpdGVtVHlwZXMubGVuZ3RoID4gMCAmJiAhaXRlbVR5cGVzLnNvbWUoKHQpID0+IHQgPT09IFwib2JqZWN0XCIgfHwgdCA9PT0gXCJhcnJheVwiKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BOKGk6IE5hbWUsIGo6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBnZW4ubmFtZShcIml0ZW1cIilcbiAgICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKGl0ZW1UeXBlcywgaXRlbSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZylcbiAgICAgIGNvbnN0IGluZGljZXMgPSBnZW4uY29uc3QoXCJpbmRpY2VzXCIsIF9ge31gKVxuICAgICAgZ2VuLmZvcihfYDske2l9LS07YCwgKCkgPT4ge1xuICAgICAgICBnZW4ubGV0KGl0ZW0sIF9gJHtkYXRhfVske2l9XWApXG4gICAgICAgIGdlbi5pZih3cm9uZ1R5cGUsIF9gY29udGludWVgKVxuICAgICAgICBpZiAoaXRlbVR5cGVzLmxlbmd0aCA+IDEpIGdlbi5pZihfYHR5cGVvZiAke2l0ZW19ID09IFwic3RyaW5nXCJgLCBfYCR7aXRlbX0gKz0gXCJfXCJgKVxuICAgICAgICBnZW5cbiAgICAgICAgICAuaWYoX2B0eXBlb2YgJHtpbmRpY2VzfVske2l0ZW19XSA9PSBcIm51bWJlclwiYCwgKCkgPT4ge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihqLCBfYCR7aW5kaWNlc31bJHtpdGVtfV1gKVxuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpXG4gICAgICAgICAgfSlcbiAgICAgICAgICAuY29kZShfYCR7aW5kaWNlc31bJHtpdGVtfV0gPSAke2l9YClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcE4yKGk6IE5hbWUsIGo6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGVxbCA9IHVzZUZ1bmMoZ2VuLCBlcXVhbClcbiAgICAgIGNvbnN0IG91dGVyID0gZ2VuLm5hbWUoXCJvdXRlclwiKVxuICAgICAgZ2VuLmxhYmVsKG91dGVyKS5mb3IoX2A7JHtpfS0tO2AsICgpID0+XG4gICAgICAgIGdlbi5mb3IoX2Ake2p9ID0gJHtpfTsgJHtqfS0tO2AsICgpID0+XG4gICAgICAgICAgZ2VuLmlmKF9gJHtlcWx9KCR7ZGF0YX1bJHtpfV0sICR7ZGF0YX1bJHtqfV0pYCwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhayhvdXRlcilcbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge199IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIENvbnN0RXJyb3IgPSBFcnJvck9iamVjdDxcImNvbnN0XCIsIHthbGxvd2VkVmFsdWU6IGFueX0+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gY29uc3RhbnRcIixcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHthbGxvd2VkVmFsdWU6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiY29uc3RcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWFDb2RlLCBzY2hlbWF9ID0gY3h0XG4gICAgaWYgKCRkYXRhIHx8IChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSkge1xuICAgICAgY3h0LmZhaWwkZGF0YShfYCEke3VzZUZ1bmMoZ2VuLCBlcXVhbCl9KCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pYClcbiAgICB9IGVsc2Uge1xuICAgICAgY3h0LmZhaWwoX2Ake3NjaGVtYX0gIT09ICR7ZGF0YX1gKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBvciwgTmFtZSwgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgRW51bUVycm9yID0gRXJyb3JPYmplY3Q8XCJlbnVtXCIsIHthbGxvd2VkVmFsdWVzOiBhbnlbXX0sIGFueVtdIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIG9uZSBvZiB0aGUgYWxsb3dlZCB2YWx1ZXNcIixcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHthbGxvd2VkVmFsdWVzOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImVudW1cIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJlbnVtIG11c3QgaGF2ZSBub24tZW1wdHkgYXJyYXlcIilcbiAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBpdC5vcHRzLmxvb3BFbnVtXG4gICAgbGV0IGVxbDogTmFtZSB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IGdldEVxbCA9ICgpOiBOYW1lID0+IChlcWwgPz89IHVzZUZ1bmMoZ2VuLCBlcXVhbCkpXG5cbiAgICBsZXQgdmFsaWQ6IENvZGVcbiAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCBsb29wRW51bSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgICBjb25zdCB2U2NoZW1hID0gZ2VuLmNvbnN0KFwidlNjaGVtYVwiLCBzY2hlbWFDb2RlKVxuICAgICAgdmFsaWQgPSBvciguLi5zY2hlbWEubWFwKChfeDogdW5rbm93biwgaTogbnVtYmVyKSA9PiBlcXVhbENvZGUodlNjaGVtYSwgaSkpKVxuICAgIH1cbiAgICBjeHQucGFzcyh2YWxpZClcblxuICAgIGZ1bmN0aW9uIGxvb3BFbnVtKCk6IHZvaWQge1xuICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICBnZW4uZm9yT2YoXCJ2XCIsIHNjaGVtYUNvZGUgYXMgQ29kZSwgKHYpID0+XG4gICAgICAgIGdlbi5pZihfYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dn0pYCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSlcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcXVhbENvZGUodlNjaGVtYTogTmFtZSwgaTogbnVtYmVyKTogQ29kZSB7XG4gICAgICBjb25zdCBzY2ggPSBzY2hlbWFbaV1cbiAgICAgIHJldHVybiB0eXBlb2Ygc2NoID09PSBcIm9iamVjdFwiICYmIHNjaCAhPT0gbnVsbFxuICAgICAgICA/IF9gJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2U2NoZW1hfVske2l9XSlgXG4gICAgICAgIDogX2Ake2RhdGF9ID09PSAke3NjaH1gXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JPYmplY3QsIFZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgbGltaXROdW1iZXIsIHtMaW1pdE51bWJlckVycm9yfSBmcm9tIFwiLi9saW1pdE51bWJlclwiXG5pbXBvcnQgbXVsdGlwbGVPZiwge011bHRpcGxlT2ZFcnJvcn0gZnJvbSBcIi4vbXVsdGlwbGVPZlwiXG5pbXBvcnQgbGltaXRMZW5ndGggZnJvbSBcIi4vbGltaXRMZW5ndGhcIlxuaW1wb3J0IHBhdHRlcm4sIHtQYXR0ZXJuRXJyb3J9IGZyb20gXCIuL3BhdHRlcm5cIlxuaW1wb3J0IGxpbWl0UHJvcGVydGllcyBmcm9tIFwiLi9saW1pdFByb3BlcnRpZXNcIlxuaW1wb3J0IHJlcXVpcmVkLCB7UmVxdWlyZWRFcnJvcn0gZnJvbSBcIi4vcmVxdWlyZWRcIlxuaW1wb3J0IGxpbWl0SXRlbXMgZnJvbSBcIi4vbGltaXRJdGVtc1wiXG5pbXBvcnQgdW5pcXVlSXRlbXMsIHtVbmlxdWVJdGVtc0Vycm9yfSBmcm9tIFwiLi91bmlxdWVJdGVtc1wiXG5pbXBvcnQgY29uc3RLZXl3b3JkLCB7Q29uc3RFcnJvcn0gZnJvbSBcIi4vY29uc3RcIlxuaW1wb3J0IGVudW1LZXl3b3JkLCB7RW51bUVycm9yfSBmcm9tIFwiLi9lbnVtXCJcblxuY29uc3QgdmFsaWRhdGlvbjogVm9jYWJ1bGFyeSA9IFtcbiAgLy8gbnVtYmVyXG4gIGxpbWl0TnVtYmVyLFxuICBtdWx0aXBsZU9mLFxuICAvLyBzdHJpbmdcbiAgbGltaXRMZW5ndGgsXG4gIHBhdHRlcm4sXG4gIC8vIG9iamVjdFxuICBsaW1pdFByb3BlcnRpZXMsXG4gIHJlcXVpcmVkLFxuICAvLyBhcnJheVxuICBsaW1pdEl0ZW1zLFxuICB1bmlxdWVJdGVtcyxcbiAgLy8gYW55XG4gIHtrZXl3b3JkOiBcInR5cGVcIiwgc2NoZW1hVHlwZTogW1wic3RyaW5nXCIsIFwiYXJyYXlcIl19LFxuICB7a2V5d29yZDogXCJudWxsYWJsZVwiLCBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIn0sXG4gIGNvbnN0S2V5d29yZCxcbiAgZW51bUtleXdvcmQsXG5dXG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRpb25cblxudHlwZSBMaW1pdEVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwibWF4SXRlbXNcIiB8IFwibWluSXRlbXNcIiB8IFwibWluUHJvcGVydGllc1wiIHwgXCJtYXhQcm9wZXJ0aWVzXCIgfCBcIm1pbkxlbmd0aFwiIHwgXCJtYXhMZW5ndGhcIixcbiAge2xpbWl0OiBudW1iZXJ9LFxuICBudW1iZXIgfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuZXhwb3J0IHR5cGUgVmFsaWRhdGlvbktleXdvcmRFcnJvciA9XG4gIHwgTGltaXRFcnJvclxuICB8IExpbWl0TnVtYmVyRXJyb3JcbiAgfCBNdWx0aXBsZU9mRXJyb3JcbiAgfCBQYXR0ZXJuRXJyb3JcbiAgfCBSZXF1aXJlZEVycm9yXG4gIHwgVW5pcXVlSXRlbXNFcnJvclxuICB8IENvbnN0RXJyb3JcbiAgfCBFbnVtRXJyb3JcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgbm90LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIEFkZGl0aW9uYWxJdGVtc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJhZGRpdGlvbmFsSXRlbXNcIiwge2xpbWl0OiBudW1iZXJ9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2xlbn19KSA9PiBzdHJgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2xlbn19KSA9PiBfYHtsaW1pdDogJHtsZW59fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFkZGl0aW9uYWxJdGVtc1wiIGFzIGNvbnN0LFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7cGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7aXRlbXN9ID0gcGFyZW50U2NoZW1hXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJhZGRpdGlvbmFsSXRlbXNcIiBpcyBpZ25vcmVkIHdoZW4gXCJpdGVtc1wiIGlzIG5vdCBhbiBhcnJheSBvZiBzY2hlbWFzJylcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIGl0ZW1zKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0OiBLZXl3b3JkQ3h0LCBpdGVtczogQW55U2NoZW1hW10pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgaXQuaXRlbXMgPSB0cnVlXG4gIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICBjeHQuc2V0UGFyYW1zKHtsZW46IGl0ZW1zLmxlbmd0aH0pXG4gICAgY3h0LnBhc3MoX2Ake2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgY29uc3QgdmFsaWQgPSBnZW4udmFyKFwidmFsaWRcIiwgX2Ake2xlbn0gPD0gJHtpdGVtcy5sZW5ndGh9YCkgLy8gVE9ETyB2YXJcbiAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gdmFsaWRhdGVJdGVtcyh2YWxpZCkpXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyh2YWxpZDogTmFtZSk6IHZvaWQge1xuICAgIGdlbi5mb3JSYW5nZShcImlcIiwgaXRlbXMubGVuZ3RoLCBsZW4sIChpKSA9PiB7XG4gICAgICBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkLCBkYXRhUHJvcDogaSwgZGF0YVByb3BUeXBlOiBUeXBlLk51bX0sIHZhbGlkKVxuICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYSwgQW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7X30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBtZXJnZUV2YWx1YXRlZCwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7dmFsaWRhdGVBcnJheX0gZnJvbSBcIi4uL2NvZGVcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImFycmF5XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge3NjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoZW1hKSkgcmV0dXJuIHZhbGlkYXRlVHVwbGUoY3h0LCBcImFkZGl0aW9uYWxJdGVtc1wiLCBzY2hlbWEpXG4gICAgaXQuaXRlbXMgPSB0cnVlXG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjeHQub2sodmFsaWRhdGVBcnJheShjeHQpKVxuICB9LFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVUdXBsZShcbiAgY3h0OiBLZXl3b3JkQ3h0LFxuICBleHRyYUl0ZW1zOiBzdHJpbmcsXG4gIHNjaEFycjogQW55U2NoZW1hW10gPSBjeHQuc2NoZW1hXG4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgcGFyZW50U2NoZW1hLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY2hlY2tTdHJpY3RUdXBsZShwYXJlbnRTY2hlbWEpXG4gIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHNjaEFyci5sZW5ndGggJiYgaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoQXJyLmxlbmd0aCwgaXQuaXRlbXMpXG4gIH1cbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgc2NoQXJyLmZvckVhY2goKHNjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHJldHVyblxuICAgIGdlbi5pZihfYCR7bGVufSA+ICR7aX1gLCAoKSA9PlxuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNoZWNrU3RyaWN0VHVwbGUoc2NoOiBBbnlTY2hlbWFPYmplY3QpOiB2b2lkIHtcbiAgICBjb25zdCB7b3B0cywgZXJyU2NoZW1hUGF0aH0gPSBpdFxuICAgIGNvbnN0IGwgPSBzY2hBcnIubGVuZ3RoXG4gICAgY29uc3QgZnVsbFR1cGxlID0gbCA9PT0gc2NoLm1pbkl0ZW1zICYmIChsID09PSBzY2gubWF4SXRlbXMgfHwgc2NoW2V4dHJhSXRlbXNdID09PSBmYWxzZSlcbiAgICBpZiAob3B0cy5zdHJpY3RUdXBsZXMgJiYgIWZ1bGxUdXBsZSkge1xuICAgICAgY29uc3QgbXNnID0gYFwiJHtrZXl3b3JkfVwiIGlzICR7bH0tdHVwbGUsIGJ1dCBtaW5JdGVtcyBvciBtYXhJdGVtcy8ke2V4dHJhSXRlbXN9IGFyZSBub3Qgc3BlY2lmaWVkIG9yIGRpZmZlcmVudCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYFxuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIG9wdHMuc3RyaWN0VHVwbGVzKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHt2YWxpZGF0ZVR1cGxlfSBmcm9tIFwiLi9pdGVtc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInByZWZpeEl0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wiYXJyYXlcIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBjb2RlOiAoY3h0KSA9PiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJpdGVtc1wiKSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge3ZhbGlkYXRlQXJyYXl9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7dmFsaWRhdGVBZGRpdGlvbmFsSXRlbXN9IGZyb20gXCIuL2FkZGl0aW9uYWxJdGVtc1wiXG5cbmV4cG9ydCB0eXBlIEl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcIml0ZW1zXCIsIHtsaW1pdDogbnVtYmVyfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtsZW59fSkgPT4gc3RyYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtsZW59fSkgPT4gX2B7bGltaXQ6ICR7bGVufX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7c2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtwcmVmaXhJdGVtc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpdC5pdGVtcyA9IHRydWVcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGlmIChwcmVmaXhJdGVtcykgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBwcmVmaXhJdGVtcylcbiAgICBlbHNlIGN4dC5vayh2YWxpZGF0ZUFycmF5KGN4dCkpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIENvbnRhaW5zRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJjb250YWluc1wiLFxuICB7bWluQ29udGFpbnM6IG51bWJlcjsgbWF4Q29udGFpbnM/OiBudW1iZXJ9LFxuICBBbnlTY2hlbWFcbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bWluLCBtYXh9fSkgPT5cbiAgICBtYXggPT09IHVuZGVmaW5lZFxuICAgICAgPyBzdHJgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSB2YWxpZCBpdGVtKHMpYFxuICAgICAgOiBzdHJgbXVzdCBjb250YWluIGF0IGxlYXN0ICR7bWlufSBhbmQgbm8gbW9yZSB0aGFuICR7bWF4fSB2YWxpZCBpdGVtKHMpYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge21pbiwgbWF4fX0pID0+XG4gICAgbWF4ID09PSB1bmRlZmluZWQgPyBfYHttaW5Db250YWluczogJHttaW59fWAgOiBfYHttaW5Db250YWluczogJHttaW59LCBtYXhDb250YWluczogJHttYXh9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgbGV0IG1pbjogbnVtYmVyXG4gICAgbGV0IG1heDogbnVtYmVyIHwgdW5kZWZpbmVkXG4gICAgY29uc3Qge21pbkNvbnRhaW5zLCBtYXhDb250YWluc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoaXQub3B0cy5uZXh0KSB7XG4gICAgICBtaW4gPSBtaW5Db250YWlucyA9PT0gdW5kZWZpbmVkID8gMSA6IG1pbkNvbnRhaW5zXG4gICAgICBtYXggPSBtYXhDb250YWluc1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW4gPSAxXG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICBjeHQuc2V0UGFyYW1zKHttaW4sIG1heH0pXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID09IDAgd2l0aG91dCBcIm1heENvbnRhaW5zXCI6IFwiY29udGFpbnNcIiBrZXl3b3JkIGlnbm9yZWRgKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCAmJiBtaW4gPiBtYXgpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwibWluQ29udGFpbnNcIiA+IFwibWF4Q29udGFpbnNcIiBpcyBhbHdheXMgaW52YWxpZGApXG4gICAgICBjeHQuZmFpbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICBsZXQgY29uZCA9IF9gJHtsZW59ID49ICR7bWlufWBcbiAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkgY29uZCA9IF9gJHtjb25kfSAmJiAke2xlbn0gPD0gJHttYXh9YFxuICAgICAgY3h0LnBhc3MoY29uZClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGl0Lml0ZW1zID0gdHJ1ZVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDEpIHtcbiAgICAgIHZhbGlkYXRlSXRlbXModmFsaWQsICgpID0+IGdlbi5pZih2YWxpZCwgKCkgPT4gZ2VuLmJyZWFrKCkpKVxuICAgIH0gZWxzZSBpZiAobWluID09PSAwKSB7XG4gICAgICBnZW4ubGV0KHZhbGlkLCB0cnVlKVxuICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSBnZW4uaWYoX2Ake2RhdGF9Lmxlbmd0aCA+IDBgLCB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KVxuICAgIH0gZWxzZSB7XG4gICAgICBnZW4ubGV0KHZhbGlkLCBmYWxzZSlcbiAgICAgIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKVxuICAgIH1cbiAgICBjeHQucmVzdWx0KHZhbGlkLCAoKSA9PiBjeHQucmVzZXQoKSlcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQoKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG4gICAgICBjb25zdCBjb3VudCA9IGdlbi5sZXQoXCJjb3VudFwiLCAwKVxuICAgICAgdmFsaWRhdGVJdGVtcyhzY2hWYWxpZCwgKCkgPT4gZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiBjaGVja0xpbWl0cyhjb3VudCkpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMoX3ZhbGlkOiBOYW1lLCBibG9jazogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAge1xuICAgICAgICAgICAga2V5d29yZDogXCJjb250YWluc1wiLFxuICAgICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtLFxuICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIF92YWxpZFxuICAgICAgICApXG4gICAgICAgIGJsb2NrKClcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tMaW1pdHMoY291bnQ6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGdlbi5jb2RlKF9gJHtjb3VudH0rK2ApXG4gICAgICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZ2VuLmlmKF9gJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkuYnJlYWsoKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihfYCR7Y291bnR9ID4gJHttYXh9YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKCkpXG4gICAgICAgIGlmIChtaW4gPT09IDEpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICAgIGVsc2UgZ2VuLmlmKF9gJHtjb3VudH0gPj0gJHttaW59YCwgKCkgPT4gZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSkpXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIFNjaGVtYU1hcCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtjaGVja1JlcG9ydE1pc3NpbmdQcm9wLCBjaGVja01pc3NpbmdQcm9wLCByZXBvcnRNaXNzaW5nUHJvcCwgcHJvcGVydHlJbkRhdGF9IGZyb20gXCIuLi9jb2RlXCJcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlEZXBlbmRlbmNpZXMgPSB7W0sgaW4gc3RyaW5nXT86IHN0cmluZ1tdfVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGVuZGVuY2llc0Vycm9yUGFyYW1zIHtcbiAgcHJvcGVydHk6IHN0cmluZ1xuICBtaXNzaW5nUHJvcGVydHk6IHN0cmluZ1xuICBkZXBzQ291bnQ6IG51bWJlclxuICBkZXBzOiBzdHJpbmcgLy8gVE9ETyBjaGFuZ2UgdG8gc3RyaW5nW11cbn1cblxudHlwZSBTY2hlbWFEZXBlbmRlbmNpZXMgPSBTY2hlbWFNYXBcblxuZXhwb3J0IHR5cGUgRGVwZW5kZW5jaWVzRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJkZXBlbmRlbmNpZXNcIixcbiAgRGVwZW5kZW5jaWVzRXJyb3JQYXJhbXMsXG4gIHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW10gfCBBbnlTY2hlbWF9XG4+XG5cbmV4cG9ydCBjb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzfX0pID0+IHtcbiAgICBjb25zdCBwcm9wZXJ0eV9pZXMgPSBkZXBzQ291bnQgPT09IDEgPyBcInByb3BlcnR5XCIgOiBcInByb3BlcnRpZXNcIlxuICAgIHJldHVybiBzdHJgbXVzdCBoYXZlICR7cHJvcGVydHlfaWVzfSAke2RlcHN9IHdoZW4gcHJvcGVydHkgJHtwcm9wZXJ0eX0gaXMgcHJlc2VudGBcbiAgfSxcbiAgcGFyYW1zOiAoe3BhcmFtczoge3Byb3BlcnR5LCBkZXBzQ291bnQsIGRlcHMsIG1pc3NpbmdQcm9wZXJ0eX19KSA9PlxuICAgIF9ge3Byb3BlcnR5OiAke3Byb3BlcnR5fSxcbiAgICBtaXNzaW5nUHJvcGVydHk6ICR7bWlzc2luZ1Byb3BlcnR5fSxcbiAgICBkZXBzQ291bnQ6ICR7ZGVwc0NvdW50fSxcbiAgICBkZXBzOiAke2RlcHN9fWAsIC8vIFRPRE8gY2hhbmdlIHRvIHJlZmVyZW5jZVxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJkZXBlbmRlbmNpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3QgW3Byb3BEZXBzLCBzY2hEZXBzXSA9IHNwbGl0RGVwZW5kZW5jaWVzKGN4dClcbiAgICB2YWxpZGF0ZVByb3BlcnR5RGVwcyhjeHQsIHByb3BEZXBzKVxuICAgIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQsIHNjaERlcHMpXG4gIH0sXG59XG5cbmZ1bmN0aW9uIHNwbGl0RGVwZW5kZW5jaWVzKHtzY2hlbWF9OiBLZXl3b3JkQ3h0KTogW1Byb3BlcnR5RGVwZW5kZW5jaWVzLCBTY2hlbWFEZXBlbmRlbmNpZXNdIHtcbiAgY29uc3QgcHJvcGVydHlEZXBzOiBQcm9wZXJ0eURlcGVuZGVuY2llcyA9IHt9XG4gIGNvbnN0IHNjaGVtYURlcHM6IFNjaGVtYURlcGVuZGVuY2llcyA9IHt9XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpIGNvbnRpbnVlXG4gICAgY29uc3QgZGVwcyA9IEFycmF5LmlzQXJyYXkoc2NoZW1hW2tleV0pID8gcHJvcGVydHlEZXBzIDogc2NoZW1hRGVwc1xuICAgIGRlcHNba2V5XSA9IHNjaGVtYVtrZXldXG4gIH1cbiAgcmV0dXJuIFtwcm9wZXJ0eURlcHMsIHNjaGVtYURlcHNdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5RGVwcyhcbiAgY3h0OiBLZXl3b3JkQ3h0LFxuICBwcm9wZXJ0eURlcHM6IHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW119ID0gY3h0LnNjaGVtYVxuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGl0fSA9IGN4dFxuICBpZiAoT2JqZWN0LmtleXMocHJvcGVydHlEZXBzKS5sZW5ndGggPT09IDApIHJldHVyblxuICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIilcbiAgZm9yIChjb25zdCBwcm9wIGluIHByb3BlcnR5RGVwcykge1xuICAgIGNvbnN0IGRlcHMgPSBwcm9wZXJ0eURlcHNbcHJvcF0gYXMgc3RyaW5nW11cbiAgICBpZiAoZGVwcy5sZW5ndGggPT09IDApIGNvbnRpbnVlXG4gICAgY29uc3QgaGFzUHJvcGVydHkgPSBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcylcbiAgICBjeHQuc2V0UGFyYW1zKHtcbiAgICAgIHByb3BlcnR5OiBwcm9wLFxuICAgICAgZGVwc0NvdW50OiBkZXBzLmxlbmd0aCxcbiAgICAgIGRlcHM6IGRlcHMuam9pbihcIiwgXCIpLFxuICAgIH0pXG4gICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgZ2VuLmlmKGhhc1Byb3BlcnR5LCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZGVwUHJvcCBvZiBkZXBzKSB7XG4gICAgICAgICAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIGRlcFByb3ApXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5pZihfYCR7aGFzUHJvcGVydHl9ICYmICgke2NoZWNrTWlzc2luZ1Byb3AoY3h0LCBkZXBzLCBtaXNzaW5nKX0pYClcbiAgICAgIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZylcbiAgICAgIGdlbi5lbHNlKClcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlU2NoZW1hRGVwcyhjeHQ6IEtleXdvcmRDeHQsIHNjaGVtYURlcHM6IFNjaGVtYU1hcCA9IGN4dC5zY2hlbWEpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICBmb3IgKGNvbnN0IHByb3AgaW4gc2NoZW1hRGVwcykge1xuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hRGVwc1twcm9wXSBhcyBBbnlTY2hlbWEpKSBjb250aW51ZVxuICAgIGdlbi5pZihcbiAgICAgIHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSxcbiAgICAgICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZCwgc2NoZW1hUHJvcDogcHJvcH0sIHZhbGlkKVxuICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKVxuICAgICAgfSxcbiAgICAgICgpID0+IGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIG5vdH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgUHJvcGVydHlOYW1lc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJwcm9wZXJ0eU5hbWVzXCIsIHtwcm9wZXJ0eU5hbWU6IHN0cmluZ30sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwicHJvcGVydHkgbmFtZSBtdXN0IGJlIHZhbGlkXCIsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtwcm9wZXJ0eU5hbWU6ICR7cGFyYW1zLnByb3BlcnR5TmFtZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG5cbiAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgY3h0LnNldFBhcmFtcyh7cHJvcGVydHlOYW1lOiBrZXl9KVxuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydHlOYW1lc1wiLFxuICAgICAgICAgIGRhdGE6IGtleSxcbiAgICAgICAgICBkYXRhVHlwZXM6IFtcInN0cmluZ1wiXSxcbiAgICAgICAgICBwcm9wZXJ0eU5hbWU6IGtleSxcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgY3h0LmVycm9yKHRydWUpXG4gICAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uYnJlYWsoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7YWxsU2NoZW1hUHJvcGVydGllcywgdXNlUGF0dGVybiwgaXNPd25Qcm9wZXJ0eX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBuaWwsIG9yLCBub3QsIENvZGUsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uLy4uL2NvbXBpbGUvbmFtZXNcIlxuaW1wb3J0IHR5cGUge1N1YnNjaGVtYUFyZ3N9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL3N1YnNjaGVtYVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBzY2hlbWFSZWZPclZhbCwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIEFkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICB7YWRkaXRpb25hbFByb3BlcnR5OiBzdHJpbmd9LFxuICBBbnlTY2hlbWFcbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBOT1QgaGF2ZSBhZGRpdGlvbmFsIHByb3BlcnRpZXNcIixcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge2FkZGl0aW9uYWxQcm9wZXJ0eTogJHtwYXJhbXMuYWRkaXRpb25hbFByb3BlcnR5fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiAmIEFkZGVkS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgdHlwZTogW1wib2JqZWN0XCJdLFxuICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICBhbGxvd1VuZGVmaW5lZDogdHJ1ZSxcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBlcnJzQ291bnQsIGl0fSA9IGN4dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghZXJyc0NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICBjb25zdCB7YWxsRXJyb3JzLCBvcHRzfSA9IGl0XG4gICAgaXQucHJvcHMgPSB0cnVlXG4gICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAhPT0gXCJhbGxcIiAmJiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY29uc3QgcHJvcHMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzKVxuICAgIGNvbnN0IHBhdFByb3BzID0gYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucGF0dGVyblByb3BlcnRpZXMpXG4gICAgY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpXG4gICAgY3h0Lm9rKF9gJHtlcnJzQ291bnR9ID09PSAke04uZXJyb3JzfWApXG5cbiAgICBmdW5jdGlvbiBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXk6IE5hbWUpID0+IHtcbiAgICAgICAgaWYgKCFwcm9wcy5sZW5ndGggJiYgIXBhdFByb3BzLmxlbmd0aCkgYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpXG4gICAgICAgIGVsc2UgZ2VuLmlmKGlzQWRkaXRpb25hbChrZXkpLCAoKSA9PiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQWRkaXRpb25hbChrZXk6IE5hbWUpOiBDb2RlIHtcbiAgICAgIGxldCBkZWZpbmVkUHJvcDogQ29kZVxuICAgICAgaWYgKHByb3BzLmxlbmd0aCA+IDgpIHtcbiAgICAgICAgLy8gVE9ETyBtYXliZSBhbiBvcHRpb24gaW5zdGVhZCBvZiBoYXJkLWNvZGVkIDg/XG4gICAgICAgIGNvbnN0IHByb3BzU2NoZW1hID0gc2NoZW1hUmVmT3JWYWwoaXQsIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzLCBcInByb3BlcnRpZXNcIilcbiAgICAgICAgZGVmaW5lZFByb3AgPSBpc093blByb3BlcnR5KGdlbiwgcHJvcHNTY2hlbWEgYXMgQ29kZSwga2V5KVxuICAgICAgfSBlbHNlIGlmIChwcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5lZFByb3AgPSBvciguLi5wcm9wcy5tYXAoKHApID0+IF9gJHtrZXl9ID09PSAke3B9YCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG5pbFxuICAgICAgfVxuICAgICAgaWYgKHBhdFByb3BzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG9yKGRlZmluZWRQcm9wLCAuLi5wYXRQcm9wcy5tYXAoKHApID0+IF9gJHt1c2VQYXR0ZXJuKGN4dCwgcCl9LnRlc3QoJHtrZXl9KWApKVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5vdChkZWZpbmVkUHJvcClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWxldGVBZGRpdGlvbmFsKGtleTogTmFtZSk6IHZvaWQge1xuICAgICAgZ2VuLmNvZGUoX2BkZWxldGUgJHtkYXRhfVske2tleX1dYClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleTogTmFtZSk6IHZvaWQge1xuICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiB8fCAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICYmIHNjaGVtYSA9PT0gZmFsc2UpKSB7XG4gICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7YWRkaXRpb25hbFByb3BlcnR5OiBrZXl9KVxuICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmJyZWFrKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImZhaWxpbmdcIikge1xuICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICAgICAgY3h0LnJlc2V0KClcbiAgICAgICAgICAgIGRlbGV0ZUFkZGl0aW9uYWwoa2V5KVxuICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQpXG4gICAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXk6IE5hbWUsIHZhbGlkOiBOYW1lLCBlcnJvcnM/OiBmYWxzZSk6IHZvaWQge1xuICAgICAgY29uc3Qgc3Vic2NoZW1hOiBTdWJzY2hlbWFBcmdzID0ge1xuICAgICAgICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5TdHIsXG4gICAgICB9XG4gICAgICBpZiAoZXJyb3JzID09PSBmYWxzZSkge1xuICAgICAgICBPYmplY3QuYXNzaWduKHN1YnNjaGVtYSwge1xuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgY3h0LnN1YnNjaGVtYShzdWJzY2hlbWEsIHZhbGlkKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtwcm9wZXJ0eUluRGF0YSwgYWxsU2NoZW1hUHJvcGVydGllc30gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgdG9IYXNoLCBtZXJnZUV2YWx1YXRlZH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgYXBEZWYgZnJvbSBcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGlmIChpdC5vcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgJiYgcGFyZW50U2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGFwRGVmLmNvZGUobmV3IEtleXdvcmRDeHQoaXQsIGFwRGVmLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIpKVxuICAgIH1cbiAgICBjb25zdCBhbGxQcm9wcyA9IGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKVxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBhbGxQcm9wcykge1xuICAgICAgaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgfVxuICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIGFsbFByb3BzLmxlbmd0aCAmJiBpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHRvSGFzaChhbGxQcm9wcyksIGl0LnByb3BzKVxuICAgIH1cbiAgICBjb25zdCBwcm9wZXJ0aWVzID0gYWxsUHJvcHMuZmlsdGVyKChwKSA9PiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSkpXG4gICAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcblxuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAoaGFzRGVmYXVsdChwcm9wKSkge1xuICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW4uaWYocHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpKVxuICAgICAgICBhcHBseVByb3BlcnR5U2NoZW1hKHByb3ApXG4gICAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uZWxzZSgpLnZhcih2YWxpZCwgdHJ1ZSlcbiAgICAgICAgZ2VuLmVuZElmKClcbiAgICAgIH1cbiAgICAgIGN4dC5pdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNEZWZhdWx0KHByb3A6IHN0cmluZyk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICAgICAgcmV0dXJuIGl0Lm9wdHMudXNlRGVmYXVsdHMgJiYgIWl0LmNvbXBvc2l0ZVJ1bGUgJiYgc2NoZW1hW3Byb3BdLmRlZmF1bHQgIT09IHVuZGVmaW5lZFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgc2NoZW1hUHJvcDogcHJvcCxcbiAgICAgICAgICBkYXRhUHJvcDogcHJvcCxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHthbGxTY2hlbWFQcm9wZXJ0aWVzLCB1c2VQYXR0ZXJufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIG5vdCwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtldmFsdWF0ZWRQcm9wc1RvTmFtZSwgVHlwZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge0FueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHN9ID0gaXRcbiAgICBjb25zdCBwYXR0ZXJucyA9IGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hKVxuICAgIGNvbnN0IGFsd2F5c1ZhbGlkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIoKHApID0+XG4gICAgICBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdIGFzIEFueVNjaGVtYSlcbiAgICApXG5cbiAgICBpZiAoXG4gICAgICBwYXR0ZXJucy5sZW5ndGggPT09IDAgfHxcbiAgICAgIChhbHdheXNWYWxpZFBhdHRlcm5zLmxlbmd0aCA9PT0gcGF0dGVybnMubGVuZ3RoICYmXG4gICAgICAgICghaXQub3B0cy51bmV2YWx1YXRlZCB8fCBpdC5wcm9wcyA9PT0gdHJ1ZSkpXG4gICAgKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjaGVja1Byb3BlcnRpZXMgPVxuICAgICAgb3B0cy5zdHJpY3RTY2hlbWEgJiYgIW9wdHMuYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMgJiYgcGFyZW50U2NoZW1hLnByb3BlcnRpZXNcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgIShpdC5wcm9wcyBpbnN0YW5jZW9mIE5hbWUpKSB7XG4gICAgICBpdC5wcm9wcyA9IGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbiwgaXQucHJvcHMpXG4gICAgfVxuICAgIGNvbnN0IHtwcm9wc30gPSBpdFxuICAgIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgcGF0IG9mIHBhdHRlcm5zKSB7XG4gICAgICAgIGlmIChjaGVja1Byb3BlcnRpZXMpIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdClcbiAgICAgICAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KVxuICAgICAgICAgIGdlbi5pZih2YWxpZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTWF0Y2hpbmdQcm9wZXJ0aWVzKHBhdDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gY2hlY2tQcm9wZXJ0aWVzKSB7XG4gICAgICAgIGlmIChuZXcgUmVnRXhwKHBhdCkudGVzdChwcm9wKSkge1xuICAgICAgICAgIGNoZWNrU3RyaWN0TW9kZShcbiAgICAgICAgICAgIGl0LFxuICAgICAgICAgICAgYHByb3BlcnR5ICR7cHJvcH0gbWF0Y2hlcyBwYXR0ZXJuICR7cGF0fSAodXNlIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzKWBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMocGF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICAgIGdlbi5pZihfYCR7dXNlUGF0dGVybihjeHQsIHBhdCl9LnRlc3QoJHtrZXl9KWAsICgpID0+IHtcbiAgICAgICAgICBjb25zdCBhbHdheXNWYWxpZCA9IGFsd2F5c1ZhbGlkUGF0dGVybnMuaW5jbHVkZXMocGF0KVxuICAgICAgICAgIGlmICghYWx3YXlzVmFsaWQpIHtcbiAgICAgICAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgICAgICAgICAgICAgc2NoZW1hUHJvcDogcGF0LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wOiBrZXksXG4gICAgICAgICAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLlN0cixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdmFsaWRcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBwcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgZ2VuLmFzc2lnbihfYCR7cHJvcHN9WyR7a2V5fV1gLCB0cnVlKVxuICAgICAgICAgIH0gZWxzZSBpZiAoIWFsd2F5c1ZhbGlkICYmICFpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICAgIC8vIGNhbiBzaG9ydC1jaXJjdWl0IGlmIGB1bmV2YWx1YXRlZFByb3BlcnRpZXNgIGlzIG5vdCBzdXBwb3J0ZWQgKG9wdHMubmV4dCA9PT0gZmFsc2UpXG4gICAgICAgICAgICAvLyBvciBpZiBhbGwgcHJvcGVydGllcyB3ZXJlIGV2YWx1YXRlZCAocHJvcHMgPT09IHRydWUpXG4gICAgICAgICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yTm9QYXJhbXMsIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgTm90S2V5d29yZEVycm9yID0gRXJyb3JOb1BhcmFtczxcIm5vdFwiLCBBbnlTY2hlbWE+XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm5vdFwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgY3h0LmZhaWwoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgY3h0LnN1YnNjaGVtYShcbiAgICAgIHtcbiAgICAgICAga2V5d29yZDogXCJub3RcIixcbiAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgIH0sXG4gICAgICB2YWxpZFxuICAgIClcblxuICAgIGN4dC5mYWlsUmVzdWx0KFxuICAgICAgdmFsaWQsXG4gICAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcigpXG4gICAgKVxuICB9LFxuICBlcnJvcjoge21lc3NhZ2U6IFwibXVzdCBOT1QgYmUgdmFsaWRcIn0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yTm9QYXJhbXMsIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7dmFsaWRhdGVVbmlvbn0gZnJvbSBcIi4uL2NvZGVcIlxuXG5leHBvcnQgdHlwZSBBbnlPZkVycm9yID0gRXJyb3JOb1BhcmFtczxcImFueU9mXCIsIEFueVNjaGVtYVtdPlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhbnlPZlwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBjb2RlOiB2YWxpZGF0ZVVuaW9uLFxuICBlcnJvcjoge21lc3NhZ2U6IFwibXVzdCBtYXRjaCBhIHNjaGVtYSBpbiBhbnlPZlwifSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtTY2hlbWFDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcblxuZXhwb3J0IHR5cGUgT25lT2ZFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm9uZU9mXCIsXG4gIHtwYXNzaW5nU2NoZW1hczogW251bWJlciwgbnVtYmVyXSB8IG51bGx9LFxuICBBbnlTY2hlbWFbXVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IG1hdGNoIGV4YWN0bHkgb25lIHNjaGVtYSBpbiBvbmVPZlwiLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7cGFzc2luZ1NjaGVtYXM6ICR7cGFyYW1zLnBhc3Npbmd9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgaWYgKGl0Lm9wdHMuZGlzY3JpbWluYXRvciAmJiBwYXJlbnRTY2hlbWEuZGlzY3JpbWluYXRvcikgcmV0dXJuXG4gICAgY29uc3Qgc2NoQXJyOiBBbnlTY2hlbWFbXSA9IHNjaGVtYVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICAgIGNvbnN0IHBhc3NpbmcgPSBnZW4ubGV0KFwicGFzc2luZ1wiLCBudWxsKVxuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcbiAgICBjeHQuc2V0UGFyYW1zKHtwYXNzaW5nfSlcbiAgICAvLyBUT0RPIHBvc3NpYmx5IGZhaWwgc3RyYWlnaHQgYXdheSAod2l0aCB3YXJuaW5nIG9yIGV4Y2VwdGlvbikgaWYgdGhlcmUgYXJlIHR3byBlbXB0eSBhbHdheXMgdmFsaWQgc2NoZW1hc1xuXG4gICAgZ2VuLmJsb2NrKHZhbGlkYXRlT25lT2YpXG5cbiAgICBjeHQucmVzdWx0KFxuICAgICAgdmFsaWQsXG4gICAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcih0cnVlKVxuICAgIClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlT25lT2YoKTogdm9pZCB7XG4gICAgICBzY2hBcnIuZm9yRWFjaCgoc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgICAgICBsZXQgc2NoQ3h0OiBTY2hlbWFDeHQgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKSB7XG4gICAgICAgICAgZ2VuLnZhcihzY2hWYWxpZCwgdHJ1ZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBrZXl3b3JkOiBcIm9uZU9mXCIsXG4gICAgICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2NoVmFsaWRcbiAgICAgICAgICApXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBnZW5cbiAgICAgICAgICAgIC5pZihfYCR7c2NoVmFsaWR9ICYmICR7dmFsaWR9YClcbiAgICAgICAgICAgIC5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgICAgICAgLmFzc2lnbihwYXNzaW5nLCBfYFske3Bhc3Npbmd9LCAke2l9XWApXG4gICAgICAgICAgICAuZWxzZSgpXG4gICAgICAgIH1cblxuICAgICAgICBnZW4uaWYoc2NoVmFsaWQsICgpID0+IHtcbiAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgICAgIGdlbi5hc3NpZ24ocGFzc2luZywgaSlcbiAgICAgICAgICBpZiAoc2NoQ3h0KSBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBOYW1lKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWxsT2ZcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgaXR9ID0gY3h0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIHNjaGVtYS5mb3JFYWNoKChzY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHJldHVyblxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZDogXCJhbGxPZlwiLCBzY2hlbWFQcm9wOiBpfSwgdmFsaWQpXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KVxuICAgIH0pXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBub3QsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgSWZLZXl3b3JkRXJyb3IgPSBFcnJvck9iamVjdDxcImlmXCIsIHtmYWlsaW5nS2V5d29yZDogc3RyaW5nfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXN9KSA9PiBzdHJgbXVzdCBtYXRjaCBcIiR7cGFyYW1zLmlmQ2xhdXNlfVwiIHNjaGVtYWAsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtmYWlsaW5nS2V5d29yZDogJHtwYXJhbXMuaWZDbGF1c2V9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImlmXCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChwYXJlbnRTY2hlbWEudGhlbiA9PT0gdW5kZWZpbmVkICYmIHBhcmVudFNjaGVtYS5lbHNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiaWZcIiB3aXRob3V0IFwidGhlblwiIGFuZCBcImVsc2VcIiBpcyBpZ25vcmVkJylcbiAgICB9XG4gICAgY29uc3QgaGFzVGhlbiA9IGhhc1NjaGVtYShpdCwgXCJ0aGVuXCIpXG4gICAgY29uc3QgaGFzRWxzZSA9IGhhc1NjaGVtYShpdCwgXCJlbHNlXCIpXG4gICAgaWYgKCFoYXNUaGVuICYmICFoYXNFbHNlKSByZXR1cm5cblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuICAgIHZhbGlkYXRlSWYoKVxuICAgIGN4dC5yZXNldCgpXG5cbiAgICBpZiAoaGFzVGhlbiAmJiBoYXNFbHNlKSB7XG4gICAgICBjb25zdCBpZkNsYXVzZSA9IGdlbi5sZXQoXCJpZkNsYXVzZVwiKVxuICAgICAgY3h0LnNldFBhcmFtcyh7aWZDbGF1c2V9KVxuICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIiwgaWZDbGF1c2UpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIiwgaWZDbGF1c2UpKVxuICAgIH0gZWxzZSBpZiAoaGFzVGhlbikge1xuICAgICAgZ2VuLmlmKHNjaFZhbGlkLCB2YWxpZGF0ZUNsYXVzZShcInRoZW5cIikpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5pZihub3Qoc2NoVmFsaWQpLCB2YWxpZGF0ZUNsYXVzZShcImVsc2VcIikpXG4gICAgfVxuXG4gICAgY3h0LnBhc3ModmFsaWQsICgpID0+IGN4dC5lcnJvcih0cnVlKSlcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlSWYoKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJpZlwiLFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgY3JlYXRlRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBzY2hWYWxpZFxuICAgICAgKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUNsYXVzZShrZXl3b3JkOiBzdHJpbmcsIGlmQ2xhdXNlPzogTmFtZSk6ICgpID0+IHZvaWQge1xuICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZH0sIHNjaFZhbGlkKVxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBzY2hWYWxpZClcbiAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZClcbiAgICAgICAgaWYgKGlmQ2xhdXNlKSBnZW4uYXNzaWduKGlmQ2xhdXNlLCBfYCR7a2V5d29yZH1gKVxuICAgICAgICBlbHNlIGN4dC5zZXRQYXJhbXMoe2lmQ2xhdXNlOiBrZXl3b3JkfSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmZ1bmN0aW9uIGhhc1NjaGVtYShpdDogU2NoZW1hT2JqQ3h0LCBrZXl3b3JkOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgY29uc3Qgc2NoZW1hID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gIHJldHVybiBzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSlcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2NoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJ0aGVuXCIsIFwiZWxzZVwiXSxcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgY29kZSh7a2V5d29yZCwgcGFyZW50U2NoZW1hLCBpdH06IEtleXdvcmRDeHQpIHtcbiAgICBpZiAocGFyZW50U2NoZW1hLmlmID09PSB1bmRlZmluZWQpIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwiJHtrZXl3b3JkfVwiIHdpdGhvdXQgXCJpZlwiIGlzIGlnbm9yZWRgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JOb1BhcmFtcywgVm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBhZGRpdGlvbmFsSXRlbXMsIHtBZGRpdGlvbmFsSXRlbXNFcnJvcn0gZnJvbSBcIi4vYWRkaXRpb25hbEl0ZW1zXCJcbmltcG9ydCBwcmVmaXhJdGVtcyBmcm9tIFwiLi9wcmVmaXhJdGVtc1wiXG5pbXBvcnQgaXRlbXMgZnJvbSBcIi4vaXRlbXNcIlxuaW1wb3J0IGl0ZW1zMjAyMCwge0l0ZW1zRXJyb3J9IGZyb20gXCIuL2l0ZW1zMjAyMFwiXG5pbXBvcnQgY29udGFpbnMsIHtDb250YWluc0Vycm9yfSBmcm9tIFwiLi9jb250YWluc1wiXG5pbXBvcnQgZGVwZW5kZW5jaWVzLCB7RGVwZW5kZW5jaWVzRXJyb3J9IGZyb20gXCIuL2RlcGVuZGVuY2llc1wiXG5pbXBvcnQgcHJvcGVydHlOYW1lcywge1Byb3BlcnR5TmFtZXNFcnJvcn0gZnJvbSBcIi4vcHJvcGVydHlOYW1lc1wiXG5pbXBvcnQgYWRkaXRpb25hbFByb3BlcnRpZXMsIHtBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yfSBmcm9tIFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiXG5pbXBvcnQgcHJvcGVydGllcyBmcm9tIFwiLi9wcm9wZXJ0aWVzXCJcbmltcG9ydCBwYXR0ZXJuUHJvcGVydGllcyBmcm9tIFwiLi9wYXR0ZXJuUHJvcGVydGllc1wiXG5pbXBvcnQgbm90S2V5d29yZCwge05vdEtleXdvcmRFcnJvcn0gZnJvbSBcIi4vbm90XCJcbmltcG9ydCBhbnlPZiwge0FueU9mRXJyb3J9IGZyb20gXCIuL2FueU9mXCJcbmltcG9ydCBvbmVPZiwge09uZU9mRXJyb3J9IGZyb20gXCIuL29uZU9mXCJcbmltcG9ydCBhbGxPZiBmcm9tIFwiLi9hbGxPZlwiXG5pbXBvcnQgaWZLZXl3b3JkLCB7SWZLZXl3b3JkRXJyb3J9IGZyb20gXCIuL2lmXCJcbmltcG9ydCB0aGVuRWxzZSBmcm9tIFwiLi90aGVuRWxzZVwiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldEFwcGxpY2F0b3IoZHJhZnQyMDIwID0gZmFsc2UpOiBWb2NhYnVsYXJ5IHtcbiAgY29uc3QgYXBwbGljYXRvciA9IFtcbiAgICAvLyBhbnlcbiAgICBub3RLZXl3b3JkLFxuICAgIGFueU9mLFxuICAgIG9uZU9mLFxuICAgIGFsbE9mLFxuICAgIGlmS2V5d29yZCxcbiAgICB0aGVuRWxzZSxcbiAgICAvLyBvYmplY3RcbiAgICBwcm9wZXJ0eU5hbWVzLFxuICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLFxuICAgIGRlcGVuZGVuY2llcyxcbiAgICBwcm9wZXJ0aWVzLFxuICAgIHBhdHRlcm5Qcm9wZXJ0aWVzLFxuICBdXG4gIC8vIGFycmF5XG4gIGlmIChkcmFmdDIwMjApIGFwcGxpY2F0b3IucHVzaChwcmVmaXhJdGVtcywgaXRlbXMyMDIwKVxuICBlbHNlIGFwcGxpY2F0b3IucHVzaChhZGRpdGlvbmFsSXRlbXMsIGl0ZW1zKVxuICBhcHBsaWNhdG9yLnB1c2goY29udGFpbnMpXG4gIHJldHVybiBhcHBsaWNhdG9yXG59XG5cbmV4cG9ydCB0eXBlIEFwcGxpY2F0b3JLZXl3b3JkRXJyb3IgPVxuICB8IEVycm9yTm9QYXJhbXM8XCJmYWxzZSBzY2hlbWFcIj5cbiAgfCBBZGRpdGlvbmFsSXRlbXNFcnJvclxuICB8IEl0ZW1zRXJyb3JcbiAgfCBDb250YWluc0Vycm9yXG4gIHwgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvclxuICB8IERlcGVuZGVuY2llc0Vycm9yXG4gIHwgSWZLZXl3b3JkRXJyb3JcbiAgfCBBbnlPZkVycm9yXG4gIHwgT25lT2ZFcnJvclxuICB8IE5vdEtleXdvcmRFcnJvclxuICB8IFByb3BlcnR5TmFtZXNFcnJvclxuIiwgImltcG9ydCB0eXBlIHtcbiAgQWRkZWRGb3JtYXQsXG4gIEZvcm1hdFZhbGlkYXRvcixcbiAgQXN5bmNGb3JtYXRWYWxpZGF0b3IsXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5pbCwgb3IsIENvZGUsIGdldFByb3BlcnR5LCByZWdleHBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxudHlwZSBGb3JtYXRWYWxpZGF0ZSA9XG4gIHwgRm9ybWF0VmFsaWRhdG9yPHN0cmluZz5cbiAgfCBGb3JtYXRWYWxpZGF0b3I8bnVtYmVyPlxuICB8IEFzeW5jRm9ybWF0VmFsaWRhdG9yPHN0cmluZz5cbiAgfCBBc3luY0Zvcm1hdFZhbGlkYXRvcjxudW1iZXI+XG4gIHwgUmVnRXhwXG4gIHwgc3RyaW5nXG4gIHwgdHJ1ZVxuXG5leHBvcnQgdHlwZSBGb3JtYXRFcnJvciA9IEVycm9yT2JqZWN0PFwiZm9ybWF0XCIsIHtmb3JtYXQ6IHN0cmluZ30sIHN0cmluZyB8IHskZGF0YTogc3RyaW5nfT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IG1hdGNoIGZvcm1hdCBcIiR7c2NoZW1hQ29kZX1cImAsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7Zm9ybWF0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImZvcm1hdFwiLFxuICB0eXBlOiBbXCJudW1iZXJcIiwgXCJzdHJpbmdcIl0sXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQsIHJ1bGVUeXBlPzogc3RyaW5nKSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHMsIGVyclNjaGVtYVBhdGgsIHNjaGVtYUVudiwgc2VsZn0gPSBpdFxuICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpIHJldHVyblxuXG4gICAgaWYgKCRkYXRhKSB2YWxpZGF0ZSREYXRhRm9ybWF0KClcbiAgICBlbHNlIHZhbGlkYXRlRm9ybWF0KClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKTogdm9pZCB7XG4gICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGZEZWYgPSBnZW4uY29uc3QoXCJmRGVmXCIsIF9gJHtmbXRzfVske3NjaGVtYUNvZGV9XWApXG4gICAgICBjb25zdCBmVHlwZSA9IGdlbi5sZXQoXCJmVHlwZVwiKVxuICAgICAgY29uc3QgZm9ybWF0ID0gZ2VuLmxldChcImZvcm1hdFwiKVxuICAgICAgLy8gVE9ETyBzaW1wbGlmeVxuICAgICAgZ2VuLmlmKFxuICAgICAgICBfYHR5cGVvZiAke2ZEZWZ9ID09IFwib2JqZWN0XCIgJiYgISgke2ZEZWZ9IGluc3RhbmNlb2YgUmVnRXhwKWAsXG4gICAgICAgICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIF9gJHtmRGVmfS50eXBlIHx8IFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBfYCR7ZkRlZn0udmFsaWRhdGVgKSxcbiAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgX2BcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgZkRlZilcbiAgICAgIClcbiAgICAgIGN4dC5mYWlsJGRhdGEob3IodW5rbm93bkZtdCgpLCBpbnZhbGlkRm10KCkpKVxuXG4gICAgICBmdW5jdGlvbiB1bmtub3duRm10KCk6IENvZGUge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSByZXR1cm4gbmlsXG4gICAgICAgIHJldHVybiBfYCR7c2NoZW1hQ29kZX0gJiYgISR7Zm9ybWF0fWBcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gaW52YWxpZEZtdCgpOiBDb2RlIHtcbiAgICAgICAgY29uc3QgY2FsbEZvcm1hdCA9IHNjaGVtYUVudi4kYXN5bmNcbiAgICAgICAgICA/IF9gKCR7ZkRlZn0uYXN5bmMgPyBhd2FpdCAke2Zvcm1hdH0oJHtkYXRhfSkgOiAke2Zvcm1hdH0oJHtkYXRhfSkpYFxuICAgICAgICAgIDogX2Ake2Zvcm1hdH0oJHtkYXRhfSlgXG4gICAgICAgIGNvbnN0IHZhbGlkRGF0YSA9IF9gKHR5cGVvZiAke2Zvcm1hdH0gPT0gXCJmdW5jdGlvblwiID8gJHtjYWxsRm9ybWF0fSA6ICR7Zm9ybWF0fS50ZXN0KCR7ZGF0YX0pKWBcbiAgICAgICAgcmV0dXJuIF9gJHtmb3JtYXR9ICYmICR7Zm9ybWF0fSAhPT0gdHJ1ZSAmJiAke2ZUeXBlfSA9PT0gJHtydWxlVHlwZX0gJiYgISR7dmFsaWREYXRhfWBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZvcm1hdERlZjogQWRkZWRGb3JtYXQgfCB1bmRlZmluZWQgPSBzZWxmLmZvcm1hdHNbc2NoZW1hXVxuICAgICAgaWYgKCFmb3JtYXREZWYpIHtcbiAgICAgICAgdW5rbm93bkZvcm1hdCgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgaWYgKGZvcm1hdERlZiA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICBjb25zdCBbZm10VHlwZSwgZm9ybWF0LCBmbXRSZWZdID0gZ2V0Rm9ybWF0KGZvcm1hdERlZilcbiAgICAgIGlmIChmbXRUeXBlID09PSBydWxlVHlwZSkgY3h0LnBhc3ModmFsaWRDb25kaXRpb24oKSlcblxuICAgICAgZnVuY3Rpb24gdW5rbm93bkZvcm1hdCgpOiB2b2lkIHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICAgIHNlbGYubG9nZ2VyLndhcm4odW5rbm93bk1zZygpKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcih1bmtub3duTXNnKCkpXG5cbiAgICAgICAgZnVuY3Rpb24gdW5rbm93bk1zZygpOiBzdHJpbmcge1xuICAgICAgICAgIHJldHVybiBgdW5rbm93biBmb3JtYXQgXCIke3NjaGVtYSBhcyBzdHJpbmd9XCIgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImBcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBnZXRGb3JtYXQoZm10RGVmOiBBZGRlZEZvcm1hdCk6IFtzdHJpbmcsIEZvcm1hdFZhbGlkYXRlLCBDb2RlXSB7XG4gICAgICAgIGNvbnN0IGNvZGUgPVxuICAgICAgICAgIGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cFxuICAgICAgICAgICAgPyByZWdleHBDb2RlKGZtdERlZilcbiAgICAgICAgICAgIDogb3B0cy5jb2RlLmZvcm1hdHNcbiAgICAgICAgICAgID8gX2Ake29wdHMuY29kZS5mb3JtYXRzfSR7Z2V0UHJvcGVydHkoc2NoZW1hKX1gXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge2tleTogc2NoZW1hLCByZWY6IGZtdERlZiwgY29kZX0pXG4gICAgICAgIGlmICh0eXBlb2YgZm10RGVmID09IFwib2JqZWN0XCIgJiYgIShmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHApKSB7XG4gICAgICAgICAgcmV0dXJuIFtmbXREZWYudHlwZSB8fCBcInN0cmluZ1wiLCBmbXREZWYudmFsaWRhdGUsIF9gJHtmbXR9LnZhbGlkYXRlYF1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBbXCJzdHJpbmdcIiwgZm10RGVmLCBmbXRdXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHZhbGlkQ29uZGl0aW9uKCk6IENvZGUge1xuICAgICAgICBpZiAodHlwZW9mIGZvcm1hdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm9ybWF0RGVmIGluc3RhbmNlb2YgUmVnRXhwKSAmJiBmb3JtYXREZWYuYXN5bmMpIHtcbiAgICAgICAgICBpZiAoIXNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGZvcm1hdCBpbiBzeW5jIHNjaGVtYVwiKVxuICAgICAgICAgIHJldHVybiBfYGF3YWl0ICR7Zm10UmVmfSgke2RhdGF9KWBcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZW9mIGZvcm1hdCA9PSBcImZ1bmN0aW9uXCIgPyBfYCR7Zm10UmVmfSgke2RhdGF9KWAgOiBfYCR7Zm10UmVmfS50ZXN0KCR7ZGF0YX0pYFxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgZm9ybWF0S2V5d29yZCBmcm9tIFwiLi9mb3JtYXRcIlxuXG5jb25zdCBmb3JtYXQ6IFZvY2FidWxhcnkgPSBbZm9ybWF0S2V5d29yZF1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0XG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi90eXBlc1wiXG5cbmV4cG9ydCBjb25zdCBtZXRhZGF0YVZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSBbXG4gIFwidGl0bGVcIixcbiAgXCJkZXNjcmlwdGlvblwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJkZXByZWNhdGVkXCIsXG4gIFwicmVhZE9ubHlcIixcbiAgXCJ3cml0ZU9ubHlcIixcbiAgXCJleGFtcGxlc1wiLFxuXVxuXG5leHBvcnQgY29uc3QgY29udGVudFZvY2FidWxhcnk6IFZvY2FidWxhcnkgPSBbXG4gIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICBcImNvbnRlbnRTY2hlbWFcIixcbl1cbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCBjb3JlVm9jYWJ1bGFyeSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCB2YWxpZGF0aW9uVm9jYWJ1bGFyeSBmcm9tIFwiLi92YWxpZGF0aW9uXCJcbmltcG9ydCBnZXRBcHBsaWNhdG9yVm9jYWJ1bGFyeSBmcm9tIFwiLi9hcHBsaWNhdG9yXCJcbmltcG9ydCBmb3JtYXRWb2NhYnVsYXJ5IGZyb20gXCIuL2Zvcm1hdFwiXG5pbXBvcnQge21ldGFkYXRhVm9jYWJ1bGFyeSwgY29udGVudFZvY2FidWxhcnl9IGZyb20gXCIuL21ldGFkYXRhXCJcblxuY29uc3QgZHJhZnQ3Vm9jYWJ1bGFyaWVzOiBWb2NhYnVsYXJ5W10gPSBbXG4gIGNvcmVWb2NhYnVsYXJ5LFxuICB2YWxpZGF0aW9uVm9jYWJ1bGFyeSxcbiAgZ2V0QXBwbGljYXRvclZvY2FidWxhcnkoKSxcbiAgZm9ybWF0Vm9jYWJ1bGFyeSxcbiAgbWV0YWRhdGFWb2NhYnVsYXJ5LFxuICBjb250ZW50Vm9jYWJ1bGFyeSxcbl1cblxuZXhwb3J0IGRlZmF1bHQgZHJhZnQ3Vm9jYWJ1bGFyaWVzXG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuXG5leHBvcnQgZW51bSBEaXNjckVycm9yIHtcbiAgVGFnID0gXCJ0YWdcIixcbiAgTWFwcGluZyA9IFwibWFwcGluZ1wiLFxufVxuXG5leHBvcnQgdHlwZSBEaXNjckVycm9yT2JqPEUgZXh0ZW5kcyBEaXNjckVycm9yPiA9IEVycm9yT2JqZWN0PFxuICBcImRpc2NyaW1pbmF0b3JcIixcbiAge2Vycm9yOiBFOyB0YWc6IHN0cmluZzsgdGFnVmFsdWU6IHVua25vd259LFxuICBzdHJpbmdcbj5cbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBBbnlTY2hlbWFPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBnZXRQcm9wZXJ0eSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge0Rpc2NyRXJyb3IsIERpc2NyRXJyb3JPYmp9IGZyb20gXCIuLi9kaXNjcmltaW5hdG9yL3R5cGVzXCJcbmltcG9ydCB7cmVzb2x2ZVJlZiwgU2NoZW1hRW52fSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5pbXBvcnQgTWlzc2luZ1JlZkVycm9yIGZyb20gXCIuLi8uLi9jb21waWxlL3JlZl9lcnJvclwiXG5pbXBvcnQge3NjaGVtYUhhc1J1bGVzQnV0UmVmfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgRGlzY3JpbWluYXRvckVycm9yID0gRGlzY3JFcnJvck9iajxEaXNjckVycm9yLlRhZz4gfCBEaXNjckVycm9yT2JqPERpc2NyRXJyb3IuTWFwcGluZz5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7ZGlzY3JFcnJvciwgdGFnTmFtZX19KSA9PlxuICAgIGRpc2NyRXJyb3IgPT09IERpc2NyRXJyb3IuVGFnXG4gICAgICA/IGB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBzdHJpbmdgXG4gICAgICA6IGB2YWx1ZSBvZiB0YWcgXCIke3RhZ05hbWV9XCIgbXVzdCBiZSBpbiBvbmVPZmAsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtkaXNjckVycm9yLCB0YWcsIHRhZ05hbWV9fSkgPT5cbiAgICBfYHtlcnJvcjogJHtkaXNjckVycm9yfSwgdGFnOiAke3RhZ05hbWV9LCB0YWdWYWx1ZTogJHt0YWd9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImRpc2NyaW1pbmF0b3JcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvbmVPZn0gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoIWl0Lm9wdHMuZGlzY3JpbWluYXRvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgZGlzY3JpbWluYXRvciBvcHRpb25cIilcbiAgICB9XG4gICAgY29uc3QgdGFnTmFtZSA9IHNjaGVtYS5wcm9wZXJ0eU5hbWVcbiAgICBpZiAodHlwZW9mIHRhZ05hbWUgIT0gXCJzdHJpbmdcIikgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgcHJvcGVydHlOYW1lXCIpXG4gICAgaWYgKHNjaGVtYS5tYXBwaW5nKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiBtYXBwaW5nIGlzIG5vdCBzdXBwb3J0ZWRcIilcbiAgICBpZiAoIW9uZU9mKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBvbmVPZiBrZXl3b3JkXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpXG4gICAgY29uc3QgdGFnID0gZ2VuLmNvbnN0KFwidGFnXCIsIF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkodGFnTmFtZSl9YClcbiAgICBnZW4uaWYoXG4gICAgICBfYHR5cGVvZiAke3RhZ30gPT0gXCJzdHJpbmdcImAsXG4gICAgICAoKSA9PiB2YWxpZGF0ZU1hcHBpbmcoKSxcbiAgICAgICgpID0+IGN4dC5lcnJvcihmYWxzZSwge2Rpc2NyRXJyb3I6IERpc2NyRXJyb3IuVGFnLCB0YWcsIHRhZ05hbWV9KVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU1hcHBpbmcoKTogdm9pZCB7XG4gICAgICBjb25zdCBtYXBwaW5nID0gZ2V0TWFwcGluZygpXG4gICAgICBnZW4uaWYoZmFsc2UpXG4gICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIGluIG1hcHBpbmcpIHtcbiAgICAgICAgZ2VuLmVsc2VJZihfYCR7dGFnfSA9PT0gJHt0YWdWYWx1ZX1gKVxuICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBhcHBseVRhZ1NjaGVtYShtYXBwaW5nW3RhZ1ZhbHVlXSkpXG4gICAgICB9XG4gICAgICBnZW4uZWxzZSgpXG4gICAgICBjeHQuZXJyb3IoZmFsc2UsIHtkaXNjckVycm9yOiBEaXNjckVycm9yLk1hcHBpbmcsIHRhZywgdGFnTmFtZX0pXG4gICAgICBnZW4uZW5kSWYoKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFwcGx5VGFnU2NoZW1hKHNjaGVtYVByb3A/OiBudW1iZXIpOiBOYW1lIHtcbiAgICAgIGNvbnN0IF92YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe2tleXdvcmQ6IFwib25lT2ZcIiwgc2NoZW1hUHJvcH0sIF92YWxpZClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIE5hbWUpXG4gICAgICByZXR1cm4gX3ZhbGlkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0TWFwcGluZygpOiB7W1QgaW4gc3RyaW5nXT86IG51bWJlcn0ge1xuICAgICAgY29uc3Qgb25lT2ZNYXBwaW5nOiB7W1QgaW4gc3RyaW5nXT86IG51bWJlcn0gPSB7fVxuICAgICAgY29uc3QgdG9wUmVxdWlyZWQgPSBoYXNSZXF1aXJlZChwYXJlbnRTY2hlbWEpXG4gICAgICBsZXQgdGFnUmVxdWlyZWQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9uZU9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzY2ggPSBvbmVPZltpXVxuICAgICAgICBpZiAoc2NoPy4kcmVmICYmICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2gsIGl0LnNlbGYuUlVMRVMpKSB7XG4gICAgICAgICAgY29uc3QgcmVmID0gc2NoLiRyZWZcbiAgICAgICAgICBzY2ggPSByZXNvbHZlUmVmLmNhbGwoaXQuc2VsZiwgaXQuc2NoZW1hRW52LnJvb3QsIGl0LmJhc2VJZCwgcmVmKVxuICAgICAgICAgIGlmIChzY2ggaW5zdGFuY2VvZiBTY2hlbWFFbnYpIHNjaCA9IHNjaC5zY2hlbWFcbiAgICAgICAgICBpZiAoc2NoID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBNaXNzaW5nUmVmRXJyb3IoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCByZWYpXG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvcFNjaCA9IHNjaD8ucHJvcGVydGllcz8uW3RhZ05hbWVdXG4gICAgICAgIGlmICh0eXBlb2YgcHJvcFNjaCAhPSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYGRpc2NyaW1pbmF0b3I6IG9uZU9mIHN1YnNjaGVtYXMgKG9yIHJlZmVyZW5jZWQgc2NoZW1hcykgbXVzdCBoYXZlIFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCJgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICAgIHRhZ1JlcXVpcmVkID0gdGFnUmVxdWlyZWQgJiYgKHRvcFJlcXVpcmVkIHx8IGhhc1JlcXVpcmVkKHNjaCkpXG4gICAgICAgIGFkZE1hcHBpbmdzKHByb3BTY2gsIGkpXG4gICAgICB9XG4gICAgICBpZiAoIXRhZ1JlcXVpcmVkKSB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgcmVxdWlyZWRgKVxuICAgICAgcmV0dXJuIG9uZU9mTWFwcGluZ1xuXG4gICAgICBmdW5jdGlvbiBoYXNSZXF1aXJlZCh7cmVxdWlyZWR9OiBBbnlTY2hlbWFPYmplY3QpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocmVxdWlyZWQpICYmIHJlcXVpcmVkLmluY2x1ZGVzKHRhZ05hbWUpXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmdzKHNjaDogQW55U2NoZW1hT2JqZWN0LCBpOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHNjaC5jb25zdCkge1xuICAgICAgICAgIGFkZE1hcHBpbmcoc2NoLmNvbnN0LCBpKVxuICAgICAgICB9IGVsc2UgaWYgKHNjaC5lbnVtKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBvZiBzY2guZW51bSkge1xuICAgICAgICAgICAgYWRkTWFwcGluZyh0YWdWYWx1ZSwgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiIG11c3QgaGF2ZSBcImNvbnN0XCIgb3IgXCJlbnVtXCJgKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGFkZE1hcHBpbmcodGFnVmFsdWU6IHVua25vd24sIGk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAodHlwZW9mIHRhZ1ZhbHVlICE9IFwic3RyaW5nXCIgfHwgdGFnVmFsdWUgaW4gb25lT2ZNYXBwaW5nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiB2YWx1ZXMgbXVzdCBiZSB1bmlxdWUgc3RyaW5nc2ApXG4gICAgICAgIH1cbiAgICAgICAgb25lT2ZNYXBwaW5nW3RhZ1ZhbHVlXSA9IGlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgIntcbiAgXCIkc2NoZW1hXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwiJGlkXCI6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gIFwidGl0bGVcIjogXCJDb3JlIHNjaGVtYSBtZXRhLXNjaGVtYVwiLFxuICBcImRlZmluaXRpb25zXCI6IHtcbiAgICBcInNjaGVtYUFycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlclwiOiB7XG4gICAgICBcInR5cGVcIjogXCJpbnRlZ2VyXCIsXG4gICAgICBcIm1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwiOiB7XG4gICAgICBcImFsbE9mXCI6IFt7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sIHtcImRlZmF1bHRcIjogMH1dXG4gICAgfSxcbiAgICBcInNpbXBsZVR5cGVzXCI6IHtcbiAgICAgIFwiZW51bVwiOiBbXCJhcnJheVwiLCBcImJvb2xlYW5cIiwgXCJpbnRlZ2VyXCIsIFwibnVsbFwiLCBcIm51bWJlclwiLCBcIm9iamVjdFwiLCBcInN0cmluZ1wiXVxuICAgIH0sXG4gICAgXCJzdHJpbmdBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlLFxuICAgICAgXCJkZWZhdWx0XCI6IFtdXG4gICAgfVxuICB9LFxuICBcInR5cGVcIjogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRpZFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRzY2hlbWFcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaVwiXG4gICAgfSxcbiAgICBcIiRyZWZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkY29tbWVudFwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJ0aXRsZVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZXNjcmlwdGlvblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIlxuICAgIH0sXG4gICAgXCJkZWZhdWx0XCI6IHRydWUsXG4gICAgXCJyZWFkT25seVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiZXhhbXBsZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtdWx0aXBsZU9mXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiLFxuICAgICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtYXhMZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluTGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicGF0dGVyblwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwicmVnZXhcIlxuICAgIH0sXG4gICAgXCJhZGRpdGlvbmFsSXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJpdGVtc1wiOiB7XG4gICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn1dLFxuICAgICAgXCJkZWZhdWx0XCI6IHRydWVcbiAgICB9LFxuICAgIFwibWF4SXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluSXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJ1bmlxdWVJdGVtc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJib29sZWFuXCIsXG4gICAgICBcImRlZmF1bHRcIjogZmFsc2VcbiAgICB9LFxuICAgIFwiY29udGFpbnNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pblByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJyZXF1aXJlZFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifSxcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCJmb3JtYXRcIjogXCJyZWdleFwifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcbiAgICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9XVxuICAgICAgfVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiY29uc3RcIjogdHJ1ZSxcbiAgICBcImVudW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJ0eXBlXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW1xuICAgICAgICB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAge1xuICAgICAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zaW1wbGVUeXBlc1wifSxcbiAgICAgICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9LFxuICAgIFwiZm9ybWF0XCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJjb250ZW50RW5jb2RpbmdcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImlmXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwidGhlblwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImVsc2VcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJhbGxPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcImFueU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwib25lT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJub3RcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgfSxcbiAgXCJkZWZhdWx0XCI6IHRydWVcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi90eXBlc1wiXG5pbXBvcnQgQWp2Q29yZSBmcm9tIFwiLi9jb3JlXCJcbmltcG9ydCBkcmFmdDdWb2NhYnVsYXJpZXMgZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2RyYWZ0N1wiXG5pbXBvcnQgZGlzY3JpbWluYXRvciBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvclwiXG5pbXBvcnQgKiBhcyBkcmFmdDdNZXRhU2NoZW1hIGZyb20gXCIuL3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvblwiXG5cbmNvbnN0IE1FVEFfU1VQUE9SVF9EQVRBID0gW1wiL3Byb3BlcnRpZXNcIl1cblxuY29uc3QgTUVUQV9TQ0hFTUFfSUQgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hXCJcblxuZXhwb3J0IGNsYXNzIEFqdiBleHRlbmRzIEFqdkNvcmUge1xuICBfYWRkVm9jYWJ1bGFyaWVzKCk6IHZvaWQge1xuICAgIHN1cGVyLl9hZGRWb2NhYnVsYXJpZXMoKVxuICAgIGRyYWZ0N1ZvY2FidWxhcmllcy5mb3JFYWNoKCh2KSA9PiB0aGlzLmFkZFZvY2FidWxhcnkodikpXG4gICAgaWYgKHRoaXMub3B0cy5kaXNjcmltaW5hdG9yKSB0aGlzLmFkZEtleXdvcmQoZGlzY3JpbWluYXRvcilcbiAgfVxuXG4gIF9hZGREZWZhdWx0TWV0YVNjaGVtYSgpOiB2b2lkIHtcbiAgICBzdXBlci5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKVxuICAgIGlmICghdGhpcy5vcHRzLm1ldGEpIHJldHVyblxuICAgIGNvbnN0IG1ldGFTY2hlbWEgPSB0aGlzLm9wdHMuJGRhdGFcbiAgICAgID8gdGhpcy4kZGF0YU1ldGFTY2hlbWEoZHJhZnQ3TWV0YVNjaGVtYSwgTUVUQV9TVVBQT1JUX0RBVEEpXG4gICAgICA6IGRyYWZ0N01ldGFTY2hlbWFcbiAgICB0aGlzLmFkZE1ldGFTY2hlbWEobWV0YVNjaGVtYSwgTUVUQV9TQ0hFTUFfSUQsIGZhbHNlKVxuICAgIHRoaXMucmVmc1tcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvc2NoZW1hXCJdID0gTUVUQV9TQ0hFTUFfSURcbiAgfVxuXG4gIGRlZmF1bHRNZXRhKCk6IHN0cmluZyB8IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuICh0aGlzLm9wdHMuZGVmYXVsdE1ldGEgPVxuICAgICAgc3VwZXIuZGVmYXVsdE1ldGEoKSB8fCAodGhpcy5nZXRTY2hlbWEoTUVUQV9TQ0hFTUFfSUQpID8gTUVUQV9TQ0hFTUFfSUQgOiB1bmRlZmluZWQpKVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IEFqdlxubW9kdWxlLmV4cG9ydHMuQWp2ID0gQWp2XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pXG5cbmV4cG9ydCBkZWZhdWx0IEFqdlxuXG5leHBvcnQge1xuICBGb3JtYXQsXG4gIEZvcm1hdERlZmluaXRpb24sXG4gIEFzeW5jRm9ybWF0RGVmaW5pdGlvbixcbiAgS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxuICBWb2NhYnVsYXJ5LFxuICBTY2hlbWEsXG4gIFNjaGVtYU9iamVjdCxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBBc3luY1NjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIFNjaGVtYVZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBFcnJvck5vUGFyYW1zLFxufSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCB7UGx1Z2luLCBPcHRpb25zLCBDb2RlT3B0aW9ucywgSW5zdGFuY2VPcHRpb25zLCBMb2dnZXIsIEVycm9yc1RleHRPcHRpb25zfSBmcm9tIFwiLi9jb3JlXCJcbmV4cG9ydCB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuL2NvbXBpbGVcIlxuZXhwb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlXCJcbmV4cG9ydCB7RGVmaW5lZEVycm9yfSBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZXJyb3JzXCJcbmV4cG9ydCB7SlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuZXhwb3J0IHtKU09OU2NoZW1hVHlwZX0gZnJvbSBcIi4vdHlwZXMvanNvbi1zY2hlbWFcIlxuZXhwb3J0IHtfLCBzdHIsIHN0cmluZ2lmeSwgbmlsLCBOYW1lLCBDb2RlLCBDb2RlR2VuLCBDb2RlR2VuT3B0aW9uc30gZnJvbSBcIi4vY29tcGlsZS9jb2RlZ2VuXCJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBWYWxpZGF0aW9uRXJyb3J9IGZyb20gXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiXG5leHBvcnQge2RlZmF1bHQgYXMgTWlzc2luZ1JlZkVycm9yfSBmcm9tIFwiLi9jb21waWxlL3JlZl9lcnJvclwiXG4iLCAiaW1wb3J0IHR5cGUge0Zvcm1hdCwgRm9ybWF0RGVmaW5pdGlvbn0gZnJvbSBcImFqdlwiXG5pbXBvcnQgdHlwZSB7Rm9ybWF0VmFsaWRhdG9yLCBGb3JtYXRDb21wYXJlfSBmcm9tIFwiYWp2L2Rpc3QvdHlwZXNcIlxuXG5leHBvcnQgdHlwZSBGb3JtYXRNb2RlID0gXCJmYXN0XCIgfCBcImZ1bGxcIlxuXG5leHBvcnQgdHlwZSBGb3JtYXROYW1lID1cbiAgfCBcImRhdGVcIlxuICB8IFwidGltZVwiXG4gIHwgXCJkYXRlLXRpbWVcIlxuICB8IFwiaXNvLXRpbWVcIlxuICB8IFwiaXNvLWRhdGUtdGltZVwiXG4gIHwgXCJkdXJhdGlvblwiXG4gIHwgXCJ1cmlcIlxuICB8IFwidXJpLXJlZmVyZW5jZVwiXG4gIHwgXCJ1cmktdGVtcGxhdGVcIlxuICB8IFwidXJsXCJcbiAgfCBcImVtYWlsXCJcbiAgfCBcImhvc3RuYW1lXCJcbiAgfCBcImlwdjRcIlxuICB8IFwiaXB2NlwiXG4gIHwgXCJyZWdleFwiXG4gIHwgXCJ1dWlkXCJcbiAgfCBcImpzb24tcG9pbnRlclwiXG4gIHwgXCJqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50XCJcbiAgfCBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiXG4gIHwgXCJieXRlXCJcbiAgfCBcImludDMyXCJcbiAgfCBcImludDY0XCJcbiAgfCBcImZsb2F0XCJcbiAgfCBcImRvdWJsZVwiXG4gIHwgXCJwYXNzd29yZFwiXG4gIHwgXCJiaW5hcnlcIlxuXG5leHBvcnQgdHlwZSBEZWZpbmVkRm9ybWF0cyA9IHtcbiAgW2tleSBpbiBGb3JtYXROYW1lXTogRm9ybWF0XG59XG5cbmZ1bmN0aW9uIGZtdERlZihcbiAgdmFsaWRhdGU6IFJlZ0V4cCB8IEZvcm1hdFZhbGlkYXRvcjxzdHJpbmc+LFxuICBjb21wYXJlOiBGb3JtYXRDb21wYXJlPHN0cmluZz5cbik6IEZvcm1hdERlZmluaXRpb248c3RyaW5nPiB7XG4gIHJldHVybiB7dmFsaWRhdGUsIGNvbXBhcmV9XG59XG5cbmV4cG9ydCBjb25zdCBmdWxsRm9ybWF0czogRGVmaW5lZEZvcm1hdHMgPSB7XG4gIC8vIGRhdGU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgZGF0ZTogZm10RGVmKGRhdGUsIGNvbXBhcmVEYXRlKSxcbiAgLy8gZGF0ZS10aW1lOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIHRpbWU6IGZtdERlZihnZXRUaW1lKHRydWUpLCBjb21wYXJlVGltZSksXG4gIFwiZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSh0cnVlKSwgY29tcGFyZURhdGVUaW1lKSxcbiAgXCJpc28tdGltZVwiOiBmbXREZWYoZ2V0VGltZSgpLCBjb21wYXJlSXNvVGltZSksXG4gIFwiaXNvLWRhdGUtdGltZVwiOiBmbXREZWYoZ2V0RGF0ZVRpbWUoKSwgY29tcGFyZUlzb0RhdGVUaW1lKSxcbiAgLy8gZHVyYXRpb246IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUFcbiAgZHVyYXRpb246IC9eUCg/ISQpKChcXGQrWSk/KFxcZCtNKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkK1MpPyk/fChcXGQrVyk/KSQvLFxuICB1cmksXG4gIFwidXJpLXJlZmVyZW5jZVwiOlxuICAgIC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopPyg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopPyg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2ksXG4gIC8vIHVyaS10ZW1wbGF0ZTogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY1NzBcbiAgXCJ1cmktdGVtcGxhdGVcIjpcbiAgICAvXig/Oig/OlteXFx4MDAtXFx4MjBcIic8PiVcXFxcXmB7fH1dfCVbMC05YS1mXXsyfSl8XFx7WysjLi87PyY9LCFAfF0/KD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPyg/OiwoPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KSpcXH0pKiQvaSxcbiAgLy8gRm9yIHRoZSBzb3VyY2U6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RwZXJpbmkvNzI5Mjk0XG4gIC8vIEZvciB0ZXN0IGNhc2VzOiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvZGVtby91cmwtcmVnZXhcbiAgdXJsOiAvXig/Omh0dHBzP3xmdHApOlxcL1xcLyg/OlxcUysoPzo6XFxTKik/QCk/KD86KD8hKD86MTB8MTI3KSg/OlxcLlxcZHsxLDN9KXszfSkoPyEoPzoxNjlcXC4yNTR8MTkyXFwuMTY4KSg/OlxcLlxcZHsxLDN9KXsyfSkoPyExNzJcXC4oPzoxWzYtOV18MlxcZHwzWzAtMV0pKD86XFwuXFxkezEsM30pezJ9KSg/OlsxLTldXFxkP3wxXFxkXFxkfDJbMDFdXFxkfDIyWzAtM10pKD86XFwuKD86MT9cXGR7MSwyfXwyWzAtNF1cXGR8MjVbMC01XSkpezJ9KD86XFwuKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNF0pKXwoPzooPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykoPzpcXC4oPzpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rLSkqW2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKykqKD86XFwuKD86W2EtelxcdXswMGExfS1cXHV7ZmZmZn1dezIsfSkpKSg/OjpcXGR7Miw1fSk/KD86XFwvW15cXHNdKik/JC9pdSxcbiAgZW1haWw6XG4gICAgL15bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqQCg/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT8kL2ksXG4gIGhvc3RuYW1lOlxuICAgIC9eKD89LnsxLDI1M31cXC4/JClbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlstMC05YS16XXswLDYxfVswLTlhLXpdKT8pKlxcLj8kL2ksXG4gIC8vIG9wdGltaXplZCBodHRwczovL3d3dy5zYWZhcmlib29rc29ubGluZS5jb20vbGlicmFyeS92aWV3L3JlZ3VsYXItZXhwcmVzc2lvbnMtY29va2Jvb2svOTc4MDU5NjgwMjgzNy9jaDA3czE2Lmh0bWxcbiAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZClcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpJC8sXG4gIGlwdjY6IC9eKCgoWzAtOWEtZl17MSw0fTopezd9KFswLTlhLWZdezEsNH18OikpfCgoWzAtOWEtZl17MSw0fTopezZ9KDpbMC05YS1mXXsxLDR9fCgoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NX0oKCg6WzAtOWEtZl17MSw0fSl7MSwyfSl8OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KXw6KSl8KChbMC05YS1mXXsxLDR9Oil7NH0oKCg6WzAtOWEtZl17MSw0fSl7MSwzfSl8KCg6WzAtOWEtZl17MSw0fSk/OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezN9KCgoOlswLTlhLWZdezEsNH0pezEsNH0pfCgoOlswLTlhLWZdezEsNH0pezAsMn06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Mn0oKCg6WzAtOWEtZl17MSw0fSl7MSw1fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwzfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsxfSgoKDpbMC05YS1mXXsxLDR9KXsxLDZ9KXwoKDpbMC05YS1mXXsxLDR9KXswLDR9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCg6KCgoOlswLTlhLWZdezEsNH0pezEsN30pfCgoOlswLTlhLWZdezEsNH0pezAsNX06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSkpJC9pLFxuICByZWdleCxcbiAgLy8gdXVpZDogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNDEyMlxuICB1dWlkOiAvXig/OnVybjp1dWlkOik/WzAtOWEtZl17OH0tKD86WzAtOWEtZl17NH0tKXszfVswLTlhLWZdezEyfSQvaSxcbiAgLy8gSlNPTi1wb2ludGVyOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjkwMVxuICAvLyB1cmkgZnJhZ21lbnQ6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I2FwcGVuZGl4LUFcbiAgXCJqc29uLXBvaW50ZXJcIjogL14oPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSokLyxcbiAgXCJqc29uLXBvaW50ZXItdXJpLWZyYWdtZW50XCI6IC9eIyg/OlxcLyg/OlthLXowLTlfXFwtLiEkJicoKSorLDs6PUBdfCVbMC05YS1mXXsyfXx+MHx+MSkqKSokL2ksXG4gIC8vIHJlbGF0aXZlIEpTT04tcG9pbnRlcjogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtbHVmZi1yZWxhdGl2ZS1qc29uLXBvaW50ZXItMDBcbiAgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIjogL14oPzowfFsxLTldWzAtOV0qKSg/OiN8KD86XFwvKD86W15+L118fjB8fjEpKikqKSQvLFxuICAvLyB0aGUgZm9sbG93aW5nIGZvcm1hdHMgYXJlIHVzZWQgYnkgdGhlIG9wZW5hcGkgc3BlY2lmaWNhdGlvbjogaHR0cHM6Ly9zcGVjLm9wZW5hcGlzLm9yZy9vYXMvdjMuMC4wI2RhdGEtdHlwZXNcbiAgLy8gYnl0ZTogaHR0cHM6Ly9naXRodWIuY29tL21pZ3VlbG1vdGEvaXMtYmFzZTY0XG4gIGJ5dGUsXG4gIC8vIHNpZ25lZCAzMiBiaXQgaW50ZWdlclxuICBpbnQzMjoge3R5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDMyfSxcbiAgLy8gc2lnbmVkIDY0IGJpdCBpbnRlZ2VyXG4gIGludDY0OiB7dHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50NjR9LFxuICAvLyBDLXR5cGUgZmxvYXRcbiAgZmxvYXQ6IHt0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXJ9LFxuICAvLyBDLXR5cGUgZG91YmxlXG4gIGRvdWJsZToge3R5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlcn0sXG4gIC8vIGhpbnQgdG8gdGhlIFVJIHRvIGhpZGUgaW5wdXQgc3RyaW5nc1xuICBwYXNzd29yZDogdHJ1ZSxcbiAgLy8gdW5jaGVja2VkIHN0cmluZyBwYXlsb2FkXG4gIGJpbmFyeTogdHJ1ZSxcbn1cblxuZXhwb3J0IGNvbnN0IGZhc3RGb3JtYXRzOiBEZWZpbmVkRm9ybWF0cyA9IHtcbiAgLi4uZnVsbEZvcm1hdHMsXG4gIGRhdGU6IGZtdERlZigvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZCQvLCBjb21wYXJlRGF0ZSksXG4gIHRpbWU6IGZtdERlZihcbiAgICAvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLFxuICAgIGNvbXBhcmVUaW1lXG4gICksXG4gIFwiZGF0ZS10aW1lXCI6IGZtdERlZihcbiAgICAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZHQoPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSxcbiAgICBjb21wYXJlRGF0ZVRpbWVcbiAgKSxcbiAgXCJpc28tdGltZVwiOiBmbXREZWYoXG4gICAgL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2ksXG4gICAgY29tcGFyZUlzb1RpbWVcbiAgKSxcbiAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZihcbiAgICAvXlxcZFxcZFxcZFxcZC1bMC0xXVxcZC1bMC0zXVxcZFt0XFxzXSg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSxcbiAgICBjb21wYXJlSXNvRGF0ZVRpbWVcbiAgKSxcbiAgLy8gdXJpOiBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2lzLW15LWpzb24tdmFsaWQvYmxvYi9tYXN0ZXIvZm9ybWF0cy5qc1xuICB1cmk6IC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyk/W15cXHNdKiQvaSxcbiAgXCJ1cmktcmVmZXJlbmNlXCI6IC9eKD86KD86W2Etel1bYS16MC05K1xcLS5dKjopP1xcLz9cXC8pPyg/OlteXFxcXFxccyNdW15cXHMjXSopPyg/OiNbXlxcXFxcXHNdKik/JC9pLFxuICAvLyBlbWFpbCAoc291cmNlcyBmcm9tIGpzZW4gdmFsaWRhdG9yKTpcbiAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yMDEzMjMvdXNpbmctYS1yZWd1bGFyLWV4cHJlc3Npb24tdG8tdmFsaWRhdGUtYW4tZW1haWwtYWRkcmVzcyNhbnN3ZXItODgyOTM2M1xuICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzIChzZWFyY2ggZm9yICd3aWxmdWwgdmlvbGF0aW9uJylcbiAgZW1haWw6XG4gICAgL15bYS16MC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8oPzpcXC5bYS16MC05XSg/OlthLXowLTktXXswLDYxfVthLXowLTldKT8pKiQvaSxcbn1cblxuZXhwb3J0IGNvbnN0IGZvcm1hdE5hbWVzID0gT2JqZWN0LmtleXMoZnVsbEZvcm1hdHMpIGFzIEZvcm1hdE5hbWVbXVxuXG5mdW5jdGlvbiBpc0xlYXBZZWFyKHllYXI6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1DXG4gIHJldHVybiB5ZWFyICUgNCA9PT0gMCAmJiAoeWVhciAlIDEwMCAhPT0gMCB8fCB5ZWFyICUgNDAwID09PSAwKVxufVxuXG5jb25zdCBEQVRFID0gL14oXFxkXFxkXFxkXFxkKS0oXFxkXFxkKS0oXFxkXFxkKSQvXG5jb25zdCBEQVlTID0gWzAsIDMxLCAyOCwgMzEsIDMwLCAzMSwgMzAsIDMxLCAzMSwgMzAsIDMxLCAzMCwgMzFdXG5cbmZ1bmN0aW9uIGRhdGUoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gZnVsbC1kYXRlIGZyb20gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICBjb25zdCBtYXRjaGVzOiBzdHJpbmdbXSB8IG51bGwgPSBEQVRFLmV4ZWMoc3RyKVxuICBpZiAoIW1hdGNoZXMpIHJldHVybiBmYWxzZVxuICBjb25zdCB5ZWFyOiBudW1iZXIgPSArbWF0Y2hlc1sxXVxuICBjb25zdCBtb250aDogbnVtYmVyID0gK21hdGNoZXNbMl1cbiAgY29uc3QgZGF5OiBudW1iZXIgPSArbWF0Y2hlc1szXVxuICByZXR1cm4gKFxuICAgIG1vbnRoID49IDEgJiZcbiAgICBtb250aCA8PSAxMiAmJlxuICAgIGRheSA+PSAxICYmXG4gICAgZGF5IDw9IChtb250aCA9PT0gMiAmJiBpc0xlYXBZZWFyKHllYXIpID8gMjkgOiBEQVlTW21vbnRoXSlcbiAgKVxufVxuXG5mdW5jdGlvbiBjb21wYXJlRGF0ZShkMTogc3RyaW5nLCBkMjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCEoZDEgJiYgZDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIGlmIChkMSA+IGQyKSByZXR1cm4gMVxuICBpZiAoZDEgPCBkMikgcmV0dXJuIC0xXG4gIHJldHVybiAwXG59XG5cbmNvbnN0IFRJTUUgPSAvXihcXGRcXGQpOihcXGRcXGQpOihcXGRcXGQoPzpcXC5cXGQrKT8pKHp8KFsrLV0pKFxcZFxcZCkoPzo6PyhcXGRcXGQpKT8pPyQvaVxuXG5mdW5jdGlvbiBnZXRUaW1lKHN0cmljdFRpbWVab25lPzogYm9vbGVhbik6IChzdHI6IHN0cmluZykgPT4gYm9vbGVhbiB7XG4gIHJldHVybiBmdW5jdGlvbiB0aW1lKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgbWF0Y2hlczogc3RyaW5nW10gfCBudWxsID0gVElNRS5leGVjKHN0cilcbiAgICBpZiAoIW1hdGNoZXMpIHJldHVybiBmYWxzZVxuICAgIGNvbnN0IGhyOiBudW1iZXIgPSArbWF0Y2hlc1sxXVxuICAgIGNvbnN0IG1pbjogbnVtYmVyID0gK21hdGNoZXNbMl1cbiAgICBjb25zdCBzZWM6IG51bWJlciA9ICttYXRjaGVzWzNdXG4gICAgY29uc3QgdHo6IHN0cmluZyB8IHVuZGVmaW5lZCA9IG1hdGNoZXNbNF1cbiAgICBjb25zdCB0elNpZ246IG51bWJlciA9IG1hdGNoZXNbNV0gPT09IFwiLVwiID8gLTEgOiAxXG4gICAgY29uc3QgdHpIOiBudW1iZXIgPSArKG1hdGNoZXNbNl0gfHwgMClcbiAgICBjb25zdCB0ek06IG51bWJlciA9ICsobWF0Y2hlc1s3XSB8fCAwKVxuICAgIGlmICh0ekggPiAyMyB8fCB0ek0gPiA1OSB8fCAoc3RyaWN0VGltZVpvbmUgJiYgIXR6KSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGhyIDw9IDIzICYmIG1pbiA8PSA1OSAmJiBzZWMgPCA2MCkgcmV0dXJuIHRydWVcbiAgICAvLyBsZWFwIHNlY29uZFxuICAgIGNvbnN0IHV0Y01pbiA9IG1pbiAtIHR6TSAqIHR6U2lnblxuICAgIGNvbnN0IHV0Y0hyID0gaHIgLSB0ekggKiB0elNpZ24gLSAodXRjTWluIDwgMCA/IDEgOiAwKVxuICAgIHJldHVybiAodXRjSHIgPT09IDIzIHx8IHV0Y0hyID09PSAtMSkgJiYgKHV0Y01pbiA9PT0gNTkgfHwgdXRjTWluID09PSAtMSkgJiYgc2VjIDwgNjFcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlVGltZShzMTogc3RyaW5nLCBzMjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCEoczEgJiYgczIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IHQxID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczEpLnZhbHVlT2YoKVxuICBjb25zdCB0MiA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMyKS52YWx1ZU9mKClcbiAgaWYgKCEodDEgJiYgdDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIHJldHVybiB0MSAtIHQyXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJc29UaW1lKHQxOiBzdHJpbmcsIHQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoISh0MSAmJiB0MikpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3QgYTEgPSBUSU1FLmV4ZWModDEpXG4gIGNvbnN0IGEyID0gVElNRS5leGVjKHQyKVxuICBpZiAoIShhMSAmJiBhMikpIHJldHVybiB1bmRlZmluZWRcbiAgdDEgPSBhMVsxXSArIGExWzJdICsgYTFbM11cbiAgdDIgPSBhMlsxXSArIGEyWzJdICsgYTJbM11cbiAgaWYgKHQxID4gdDIpIHJldHVybiAxXG4gIGlmICh0MSA8IHQyKSByZXR1cm4gLTFcbiAgcmV0dXJuIDBcbn1cblxuY29uc3QgREFURV9USU1FX1NFUEFSQVRPUiA9IC90fFxccy9pXG5mdW5jdGlvbiBnZXREYXRlVGltZShzdHJpY3RUaW1lWm9uZT86IGJvb2xlYW4pOiAoc3RyOiBzdHJpbmcpID0+IGJvb2xlYW4ge1xuICBjb25zdCB0aW1lID0gZ2V0VGltZShzdHJpY3RUaW1lWm9uZSlcblxuICByZXR1cm4gZnVuY3Rpb24gZGF0ZV90aW1lKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgLy8gaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICAgIGNvbnN0IGRhdGVUaW1lOiBzdHJpbmdbXSA9IHN0ci5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKVxuICAgIHJldHVybiBkYXRlVGltZS5sZW5ndGggPT09IDIgJiYgZGF0ZShkYXRlVGltZVswXSkgJiYgdGltZShkYXRlVGltZVsxXSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wYXJlRGF0ZVRpbWUoZHQxOiBzdHJpbmcsIGR0Mjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCEoZHQxICYmIGR0MikpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3QgZDEgPSBuZXcgRGF0ZShkdDEpLnZhbHVlT2YoKVxuICBjb25zdCBkMiA9IG5ldyBEYXRlKGR0MikudmFsdWVPZigpXG4gIGlmICghKGQxICYmIGQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICByZXR1cm4gZDEgLSBkMlxufVxuXG5mdW5jdGlvbiBjb21wYXJlSXNvRGF0ZVRpbWUoZHQxOiBzdHJpbmcsIGR0Mjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCEoZHQxICYmIGR0MikpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3QgW2QxLCB0MV0gPSBkdDEuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUilcbiAgY29uc3QgW2QyLCB0Ml0gPSBkdDIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUilcbiAgY29uc3QgcmVzID0gY29tcGFyZURhdGUoZDEsIGQyKVxuICBpZiAocmVzID09PSB1bmRlZmluZWQpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIHJlcyB8fCBjb21wYXJlVGltZSh0MSwgdDIpXG59XG5cbmNvbnN0IE5PVF9VUklfRlJBR01FTlQgPSAvXFwvfDovXG5jb25zdCBVUkkgPVxuICAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06XXwlWzAtOWEtZl17Mn0pKkApPyg/OlxcWyg/Oig/Oig/Oig/OlswLTlhLWZdezEsNH06KXs2fXw6Oig/OlswLTlhLWZdezEsNH06KXs1fXwoPzpbMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXs0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwxfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezN9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDJ9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7Mn18KD86KD86WzAtOWEtZl17MSw0fTopezAsM31bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH06fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDR9WzAtOWEtZl17MSw0fSk/OjopKD86WzAtOWEtZl17MSw0fTpbMC05YS1mXXsxLDR9fCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KSl8KD86KD86WzAtOWEtZl17MSw0fTopezAsNX1bMC05YS1mXXsxLDR9KT86OlswLTlhLWZdezEsNH18KD86KD86WzAtOWEtZl17MSw0fTopezAsNn1bMC05YS1mXXsxLDR9KT86Oil8W1Z2XVswLTlhLWZdK1xcLlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdKylcXF18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pfCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopKD86XFw/KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyg/OiMoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pXG5cbmZ1bmN0aW9uIHVyaShzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBodHRwOi8vam1yd2FyZS5jb20vYXJ0aWNsZXMvMjAwOS91cmlfcmVnZXhwL1VSSV9yZWdleC5odG1sICsgb3B0aW9uYWwgcHJvdG9jb2wgKyByZXF1aXJlZCBcIi5cIlxuICByZXR1cm4gTk9UX1VSSV9GUkFHTUVOVC50ZXN0KHN0cikgJiYgVVJJLnRlc3Qoc3RyKVxufVxuXG5jb25zdCBCWVRFID0gL14oPzpbQS1aYS16MC05Ky9dezR9KSooPzpbQS1aYS16MC05Ky9dezJ9PT18W0EtWmEtejAtOSsvXXszfT0pPyQvZ21cblxuZnVuY3Rpb24gYnl0ZShzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBCWVRFLmxhc3RJbmRleCA9IDBcbiAgcmV0dXJuIEJZVEUudGVzdChzdHIpXG59XG5cbmNvbnN0IE1JTl9JTlQzMiA9IC0oMiAqKiAzMSlcbmNvbnN0IE1BWF9JTlQzMiA9IDIgKiogMzEgLSAxXG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW50MzIodmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPD0gTUFYX0lOVDMyICYmIHZhbHVlID49IE1JTl9JTlQzMlxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUludDY0KHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gSlNPTiBhbmQgamF2YXNjcmlwdCBtYXggSW50IGlzIDIqKjUzLCBzbyBhbnkgaW50IHRoYXQgcGFzc2VzIGlzSW50ZWdlciBpcyB2YWxpZCBmb3IgSW50NjRcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyKCk6IGJvb2xlYW4ge1xuICByZXR1cm4gdHJ1ZVxufVxuXG5jb25zdCBaX0FOQ0hPUiA9IC9bXlxcXFxdXFxcXFovXG5mdW5jdGlvbiByZWdleChzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBpZiAoWl9BTkNIT1IudGVzdChzdHIpKSByZXR1cm4gZmFsc2VcbiAgdHJ5IHtcbiAgICBuZXcgUmVnRXhwKHN0cilcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSBBanYgZnJvbSBcImFqdlwiXG5pbXBvcnQgdHlwZSB7XG4gIFBsdWdpbixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBDb2RlLFxuICBOYW1lLFxuICBFcnJvck9iamVjdCxcbn0gZnJvbSBcImFqdlwiXG5pbXBvcnQgdHlwZSB7QWRkZWRGb3JtYXR9IGZyb20gXCJhanYvZGlzdC90eXBlc1wiXG5pbXBvcnQgdHlwZSB7UnVsZX0gZnJvbSBcImFqdi9kaXN0L2NvbXBpbGUvcnVsZXNcIlxuaW1wb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiYWp2XCJcbmltcG9ydCB7Xywgc3RyLCBvciwgZ2V0UHJvcGVydHksIG9wZXJhdG9yc30gZnJvbSBcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiXG5cbnR5cGUgS3dkID0gXCJmb3JtYXRNYXhpbXVtXCIgfCBcImZvcm1hdE1pbmltdW1cIiB8IFwiZm9ybWF0RXhjbHVzaXZlTWF4aW11bVwiIHwgXCJmb3JtYXRFeGNsdXNpdmVNaW5pbXVtXCJcblxudHlwZSBDb21wYXJpc29uID0gXCI8PVwiIHwgXCI+PVwiIHwgXCI8XCIgfCBcIj5cIlxuXG5jb25zdCBvcHMgPSBvcGVyYXRvcnNcblxuY29uc3QgS1dEczoge1tLIGluIEt3ZF06IHtva1N0cjogQ29tcGFyaXNvbjsgb2s6IENvZGU7IGZhaWw6IENvZGV9fSA9IHtcbiAgZm9ybWF0TWF4aW11bToge29rU3RyOiBcIjw9XCIsIG9rOiBvcHMuTFRFLCBmYWlsOiBvcHMuR1R9LFxuICBmb3JtYXRNaW5pbXVtOiB7b2tTdHI6IFwiPj1cIiwgb2s6IG9wcy5HVEUsIGZhaWw6IG9wcy5MVH0sXG4gIGZvcm1hdEV4Y2x1c2l2ZU1heGltdW06IHtva1N0cjogXCI8XCIsIG9rOiBvcHMuTFQsIGZhaWw6IG9wcy5HVEV9LFxuICBmb3JtYXRFeGNsdXNpdmVNaW5pbXVtOiB7b2tTdHI6IFwiPlwiLCBvazogb3BzLkdULCBmYWlsOiBvcHMuTFRFfSxcbn1cblxuZXhwb3J0IHR5cGUgTGltaXRGb3JtYXRFcnJvciA9IEVycm9yT2JqZWN0PEt3ZCwge2xpbWl0OiBzdHJpbmc7IGNvbXBhcmlzb246IENvbXBhcmlzb259PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkgPT4gc3RyYHNob3VsZCBiZSAke0tXRHNba2V5d29yZCBhcyBLd2RdLm9rU3RyfSAke3NjaGVtYUNvZGV9YCxcbiAgcGFyYW1zOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PlxuICAgIF9ge2NvbXBhcmlzb246ICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9LCBsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0TGltaXREZWZpbml0aW9uOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICB0eXBlOiBcInN0cmluZ1wiLFxuICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hQ29kZSwga2V5d29yZCwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHMsIHNlbGZ9ID0gaXRcbiAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKSByZXR1cm5cblxuICAgIGNvbnN0IGZDeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgKHNlbGYuUlVMRVMuYWxsLmZvcm1hdCBhcyBSdWxlKS5kZWZpbml0aW9uLCBcImZvcm1hdFwiKVxuICAgIGlmIChmQ3h0LiRkYXRhKSB2YWxpZGF0ZSREYXRhRm9ybWF0KClcbiAgICBlbHNlIHZhbGlkYXRlRm9ybWF0KClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlJERhdGFGb3JtYXQoKTogdm9pZCB7XG4gICAgICBjb25zdCBmbXRzID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAgcmVmOiBzZWxmLmZvcm1hdHMsXG4gICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzLFxuICAgICAgfSlcbiAgICAgIGNvbnN0IGZtdCA9IGdlbi5jb25zdChcImZtdFwiLCBfYCR7Zm10c31bJHtmQ3h0LnNjaGVtYUNvZGV9XWApXG4gICAgICBjeHQuZmFpbCRkYXRhKFxuICAgICAgICBvcihcbiAgICAgICAgICBfYHR5cGVvZiAke2ZtdH0gIT0gXCJvYmplY3RcImAsXG4gICAgICAgICAgX2Ake2ZtdH0gaW5zdGFuY2VvZiBSZWdFeHBgLFxuICAgICAgICAgIF9gdHlwZW9mICR7Zm10fS5jb21wYXJlICE9IFwiZnVuY3Rpb25cImAsXG4gICAgICAgICAgY29tcGFyZUNvZGUoZm10KVxuICAgICAgICApXG4gICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKTogdm9pZCB7XG4gICAgICBjb25zdCBmb3JtYXQgPSBmQ3h0LnNjaGVtYSBhcyBzdHJpbmdcbiAgICAgIGNvbnN0IGZtdERlZjogQWRkZWRGb3JtYXQgfCB1bmRlZmluZWQgPSBzZWxmLmZvcm1hdHNbZm9ybWF0XVxuICAgICAgaWYgKCFmbXREZWYgfHwgZm10RGVmID09PSB0cnVlKSByZXR1cm5cbiAgICAgIGlmIChcbiAgICAgICAgdHlwZW9mIGZtdERlZiAhPSBcIm9iamVjdFwiIHx8XG4gICAgICAgIGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCB8fFxuICAgICAgICB0eXBlb2YgZm10RGVmLmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiXG4gICAgICApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7a2V5d29yZH1cIjogZm9ybWF0IFwiJHtmb3JtYXR9XCIgZG9lcyBub3QgZGVmaW5lIFwiY29tcGFyZVwiIGZ1bmN0aW9uYClcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgIGtleTogZm9ybWF0LFxuICAgICAgICByZWY6IGZtdERlZixcbiAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMgPyBfYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtnZXRQcm9wZXJ0eShmb3JtYXQpfWAgOiB1bmRlZmluZWQsXG4gICAgICB9KVxuXG4gICAgICBjeHQuZmFpbCRkYXRhKGNvbXBhcmVDb2RlKGZtdCkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcGFyZUNvZGUoZm10OiBOYW1lKTogQ29kZSB7XG4gICAgICByZXR1cm4gX2Ake2ZtdH0uY29tcGFyZSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KSAke0tXRHNba2V5d29yZCBhcyBLd2RdLmZhaWx9IDBgXG4gICAgfVxuICB9LFxuICBkZXBlbmRlbmNpZXM6IFtcImZvcm1hdFwiXSxcbn1cblxuY29uc3QgZm9ybWF0TGltaXRQbHVnaW46IFBsdWdpbjx1bmRlZmluZWQ+ID0gKGFqdjogQWp2KTogQWp2ID0+IHtcbiAgYWp2LmFkZEtleXdvcmQoZm9ybWF0TGltaXREZWZpbml0aW9uKVxuICByZXR1cm4gYWp2XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdExpbWl0UGx1Z2luXG4iLCAiaW1wb3J0IHtcbiAgRGVmaW5lZEZvcm1hdHMsXG4gIEZvcm1hdE1vZGUsXG4gIEZvcm1hdE5hbWUsXG4gIGZvcm1hdE5hbWVzLFxuICBmYXN0Rm9ybWF0cyxcbiAgZnVsbEZvcm1hdHMsXG59IGZyb20gXCIuL2Zvcm1hdHNcIlxuaW1wb3J0IGZvcm1hdExpbWl0IGZyb20gXCIuL2xpbWl0XCJcbmltcG9ydCB0eXBlIEFqdiBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtQbHVnaW4sIEZvcm1hdH0gZnJvbSBcImFqdlwiXG5pbXBvcnQge18sIE5hbWV9IGZyb20gXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIlxuXG5leHBvcnQge0Zvcm1hdE1vZGUsIEZvcm1hdE5hbWV9IGZyb20gXCIuL2Zvcm1hdHNcIlxuZXhwb3J0IHtMaW1pdEZvcm1hdEVycm9yfSBmcm9tIFwiLi9saW1pdFwiXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdE9wdGlvbnMge1xuICBtb2RlPzogRm9ybWF0TW9kZVxuICBmb3JtYXRzPzogRm9ybWF0TmFtZVtdXG4gIGtleXdvcmRzPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBGb3JtYXRzUGx1Z2luT3B0aW9ucyA9IEZvcm1hdE5hbWVbXSB8IEZvcm1hdE9wdGlvbnNcblxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRzUGx1Z2luIGV4dGVuZHMgUGx1Z2luPEZvcm1hdHNQbHVnaW5PcHRpb25zPiB7XG4gIGdldDogKGZvcm1hdDogRm9ybWF0TmFtZSwgbW9kZT86IEZvcm1hdE1vZGUpID0+IEZvcm1hdFxufVxuXG5jb25zdCBmdWxsTmFtZSA9IG5ldyBOYW1lKFwiZnVsbEZvcm1hdHNcIilcbmNvbnN0IGZhc3ROYW1lID0gbmV3IE5hbWUoXCJmYXN0Rm9ybWF0c1wiKVxuXG5jb25zdCBmb3JtYXRzUGx1Z2luOiBGb3JtYXRzUGx1Z2luID0gKFxuICBhanY6IEFqdixcbiAgb3B0czogRm9ybWF0c1BsdWdpbk9wdGlvbnMgPSB7a2V5d29yZHM6IHRydWV9XG4pOiBBanYgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzKSkge1xuICAgIGFkZEZvcm1hdHMoYWp2LCBvcHRzLCBmdWxsRm9ybWF0cywgZnVsbE5hbWUpXG4gICAgcmV0dXJuIGFqdlxuICB9XG4gIGNvbnN0IFtmb3JtYXRzLCBleHBvcnROYW1lXSA9XG4gICAgb3B0cy5tb2RlID09PSBcImZhc3RcIiA/IFtmYXN0Rm9ybWF0cywgZmFzdE5hbWVdIDogW2Z1bGxGb3JtYXRzLCBmdWxsTmFtZV1cbiAgY29uc3QgbGlzdCA9IG9wdHMuZm9ybWF0cyB8fCBmb3JtYXROYW1lc1xuICBhZGRGb3JtYXRzKGFqdiwgbGlzdCwgZm9ybWF0cywgZXhwb3J0TmFtZSlcbiAgaWYgKG9wdHMua2V5d29yZHMpIGZvcm1hdExpbWl0KGFqdilcbiAgcmV0dXJuIGFqdlxufVxuXG5mb3JtYXRzUGx1Z2luLmdldCA9IChuYW1lOiBGb3JtYXROYW1lLCBtb2RlOiBGb3JtYXRNb2RlID0gXCJmdWxsXCIpOiBGb3JtYXQgPT4ge1xuICBjb25zdCBmb3JtYXRzID0gbW9kZSA9PT0gXCJmYXN0XCIgPyBmYXN0Rm9ybWF0cyA6IGZ1bGxGb3JtYXRzXG4gIGNvbnN0IGYgPSBmb3JtYXRzW25hbWVdXG4gIGlmICghZikgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGZvcm1hdCBcIiR7bmFtZX1cImApXG4gIHJldHVybiBmXG59XG5cbmZ1bmN0aW9uIGFkZEZvcm1hdHMoYWp2OiBBanYsIGxpc3Q6IEZvcm1hdE5hbWVbXSwgZnM6IERlZmluZWRGb3JtYXRzLCBleHBvcnROYW1lOiBOYW1lKTogdm9pZCB7XG4gIGFqdi5vcHRzLmNvZGUuZm9ybWF0cyA/Pz0gX2ByZXF1aXJlKFwiYWp2LWZvcm1hdHMvZGlzdC9mb3JtYXRzXCIpLiR7ZXhwb3J0TmFtZX1gXG4gIGZvciAoY29uc3QgZiBvZiBsaXN0KSBhanYuYWRkRm9ybWF0KGYsIGZzW2ZdKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmb3JtYXRzUGx1Z2luXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHt2YWx1ZTogdHJ1ZX0pXG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdHNQbHVnaW5cbiIsICJleHBvcnQgdmFyIHV0aWw7XG4oZnVuY3Rpb24gKHV0aWwpIHtcbiAgICB1dGlsLmFzc2VydEVxdWFsID0gKF8pID0+IHsgfTtcbiAgICBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbiAgICB1dGlsLmFzc2VydElzID0gYXNzZXJ0SXM7XG4gICAgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIHV0aWwuYXNzZXJ0TmV2ZXIgPSBhc3NlcnROZXZlcjtcbiAgICB1dGlsLmFycmF5VG9FbnVtID0gKGl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIG9ialtpdGVtXSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9O1xuICAgIHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICBjb25zdCB2YWxpZEtleXMgPSB1dGlsLm9iamVjdEtleXMob2JqKS5maWx0ZXIoKGspID0+IHR5cGVvZiBvYmpbb2JqW2tdXSAhPT0gXCJudW1iZXJcIik7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkID0ge307XG4gICAgICAgIGZvciAoY29uc3QgayBvZiB2YWxpZEtleXMpIHtcbiAgICAgICAgICAgIGZpbHRlcmVkW2tdID0gb2JqW2tdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyhmaWx0ZXJlZCk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdFZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0S2V5cyhvYmopLm1hcChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialtlXTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICB1dGlsLm9iamVjdEtleXMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09IFwiZnVuY3Rpb25cIiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgPyAob2JqKSA9PiBPYmplY3Qua2V5cyhvYmopIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6IChvYmplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBrZXlzO1xuICAgICAgICB9O1xuICAgIHV0aWwuZmluZCA9IChhcnIsIGNoZWNrZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIoaXRlbSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIHV0aWwuaXNJbnRlZ2VyID0gdHlwZW9mIE51bWJlci5pc0ludGVnZXIgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/ICh2YWwpID0+IE51bWJlci5pc0ludGVnZXIodmFsKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICYmIE51bWJlci5pc0Zpbml0ZSh2YWwpICYmIE1hdGguZmxvb3IodmFsKSA9PT0gdmFsO1xuICAgIGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwiIHwgXCIpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIiA/IGAnJHt2YWx9J2AgOiB2YWwpKS5qb2luKHNlcGFyYXRvcik7XG4gICAgfVxuICAgIHV0aWwuam9pblZhbHVlcyA9IGpvaW5WYWx1ZXM7XG4gICAgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIgPSAoXywgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59KSh1dGlsIHx8ICh1dGlsID0ge30pKTtcbmV4cG9ydCB2YXIgb2JqZWN0VXRpbDtcbihmdW5jdGlvbiAob2JqZWN0VXRpbCkge1xuICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXMgPSAoZmlyc3QsIHNlY29uZCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZmlyc3QsXG4gICAgICAgICAgICAuLi5zZWNvbmQsIC8vIHNlY29uZCBvdmVyd3JpdGVzIGZpcnN0XG4gICAgICAgIH07XG4gICAgfTtcbn0pKG9iamVjdFV0aWwgfHwgKG9iamVjdFV0aWwgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IFpvZFBhcnNlZFR5cGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcInN0cmluZ1wiLFxuICAgIFwibmFuXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImludGVnZXJcIixcbiAgICBcImZsb2F0XCIsXG4gICAgXCJib29sZWFuXCIsXG4gICAgXCJkYXRlXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwiZnVuY3Rpb25cIixcbiAgICBcInVuZGVmaW5lZFwiLFxuICAgIFwibnVsbFwiLFxuICAgIFwiYXJyYXlcIixcbiAgICBcIm9iamVjdFwiLFxuICAgIFwidW5rbm93blwiLFxuICAgIFwicHJvbWlzZVwiLFxuICAgIFwidm9pZFwiLFxuICAgIFwibmV2ZXJcIixcbiAgICBcIm1hcFwiLFxuICAgIFwic2V0XCIsXG5dKTtcbmV4cG9ydCBjb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZDtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3RyaW5nO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gWm9kUGFyc2VkVHlwZS5uYW4gOiBab2RQYXJzZWRUeXBlLm51bWJlcjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJvb2xlYW47XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZnVuY3Rpb247XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmJpZ2ludDtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc3ltYm9sO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5udWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUucHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5tYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm9iamVjdDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnVua25vd247XG4gICAgfVxufTtcbiIsICJpbXBvcnQgeyB1dGlsIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgWm9kSXNzdWVDb2RlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJpbnZhbGlkX3R5cGVcIixcbiAgICBcImludmFsaWRfbGl0ZXJhbFwiLFxuICAgIFwiY3VzdG9tXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgXCJpbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3JcIixcbiAgICBcImludmFsaWRfZW51bV92YWx1ZVwiLFxuICAgIFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBcImludmFsaWRfYXJndW1lbnRzXCIsXG4gICAgXCJpbnZhbGlkX3JldHVybl90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2RhdGVcIixcbiAgICBcImludmFsaWRfc3RyaW5nXCIsXG4gICAgXCJ0b29fc21hbGxcIixcbiAgICBcInRvb19iaWdcIixcbiAgICBcImludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzXCIsXG4gICAgXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICBcIm5vdF9maW5pdGVcIixcbl0pO1xuZXhwb3J0IGNvbnN0IHF1b3RlbGVzc0pzb24gPSAob2JqKSA9PiB7XG4gICAgY29uc3QganNvbiA9IEpTT04uc3RyaW5naWZ5KG9iaiwgbnVsbCwgMik7XG4gICAgcmV0dXJuIGpzb24ucmVwbGFjZSgvXCIoW15cIl0rKVwiOi9nLCBcIiQxOlwiKTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcihpc3N1ZXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZSA9IChzdWIpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCBzdWJdO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFkZElzc3VlcyA9IChzdWJzID0gW10pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNzdWVzID0gWy4uLnRoaXMuaXNzdWVzLCAuLi5zdWJzXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYWN0dWFsUHJvdG8gPSBuZXcudGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBhY3R1YWxQcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IGFjdHVhbFByb3RvO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICAgICAgdGhpcy5pc3N1ZXMgPSBpc3N1ZXM7XG4gICAgfVxuICAgIGZvcm1hdChfbWFwcGVyKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlciA9IF9tYXBwZXIgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChpc3N1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc3N1ZS5tZXNzYWdlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWUudW5pb25FcnJvcnMubWFwKHByb2Nlc3NFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5yZXR1cm5UeXBlRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfYXJndW1lbnRzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLmFyZ3VtZW50c0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9IGVsc2UgaWYgKHR5cGVvZiBlbCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY29uc3QgZXJyb3JBcnJheTogYW55ID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBlcnJvckFycmF5Ll9lcnJvcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgZXJyb3JBcnJheTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHByb2Nlc3NFcnJvcih0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xuICAgIH1cbiAgICBzdGF0aWMgYXNzZXJ0KHZhbHVlKSB7XG4gICAgICAgIGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kRXJyb3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhIFpvZEVycm9yOiAke3ZhbHVlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgbWVzc2FnZSgpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgfVxuICAgIGdldCBpc0VtcHR5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICBmbGF0dGVuKG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzdWIgb2YgdGhpcy5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFbCA9IHN1Yi5wYXRoWzBdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdID0gZmllbGRFcnJvcnNbZmlyc3RFbF0gfHwgW107XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG4gICAgfVxuICAgIGdldCBmb3JtRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGF0dGVuKCk7XG4gICAgfVxufVxuWm9kRXJyb3IuY3JlYXRlID0gKGlzc3VlcykgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGlzc3Vlcyk7XG4gICAgcmV0dXJuIGVycm9yO1xufTtcbiIsICJpbXBvcnQgeyBab2RJc3N1ZUNvZGUgfSBmcm9tIFwiLi4vWm9kRXJyb3IuanNcIjtcbmltcG9ydCB7IHV0aWwsIFpvZFBhcnNlZFR5cGUgfSBmcm9tIFwiLi4vaGVscGVycy91dGlsLmpzXCI7XG5jb25zdCBlcnJvck1hcCA9IChpc3N1ZSwgX2N0eCkgPT4ge1xuICAgIGxldCBtZXNzYWdlO1xuICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGU6XG4gICAgICAgICAgICBpZiAoaXNzdWUucmVjZWl2ZWQgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiUmVxdWlyZWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRXhwZWN0ZWQgJHtpc3N1ZS5leHBlY3RlZH0sIHJlY2VpdmVkICR7aXNzdWUucmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWw6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgbGl0ZXJhbCB2YWx1ZSwgZXhwZWN0ZWQgJHtKU09OLnN0cmluZ2lmeShpc3N1ZS5leHBlY3RlZCwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYFVucmVjb2duaXplZCBrZXkocykgaW4gb2JqZWN0OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGVudW0gdmFsdWUuIEV4cGVjdGVkICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLm9wdGlvbnMpfSwgcmVjZWl2ZWQgJyR7aXNzdWUucmVjZWl2ZWR9J2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gYXJndW1lbnRzYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIHJldHVybiB0eXBlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0ZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmc6XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoXCJpbmNsdWRlc1wiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGluY2x1ZGUgXCIke2lzc3VlLnZhbGlkYXRpb24uaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlLnZhbGlkYXRpb24ucG9zaXRpb24gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgJHttZXNzYWdlfSBhdCBvbmUgb3IgbW9yZSBwb3NpdGlvbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvICR7aXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbn1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwic3RhcnRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IHN0YXJ0IHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uc3RhcnRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKFwiZW5kc1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBlbmQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5lbmRzV2l0aH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlLnZhbGlkYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnZhbGlkYXRpb24gIT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCAke2lzc3VlLnZhbGlkYXRpb259YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fc21hbGw6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgbW9yZSB0aGFuYH0gJHtpc3N1ZS5taW5pbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBcImV4YWN0bHlcIiA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBsZWFzdGAgOiBgb3ZlcmB9ICR7aXNzdWUubWluaW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke2lzc3VlLm1pbmltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1pbmltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS50b29fYmlnOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IG1vc3RgIDogYHVuZGVyYH0gJHtpc3N1ZS5tYXhpbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBCaWdJbnQgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYHNtYWxsZXIgdGhhbiBvciBlcXVhbCB0b2AgOiBgc21hbGxlciB0aGFuYH0gJHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWF4aW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmN1c3RvbTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXM6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludGVyc2VjdGlvbiByZXN1bHRzIGNvdWxkIG5vdCBiZSBtZXJnZWRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLm11bHRpcGxlT2Z9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfZmluaXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IFwiTnVtYmVyIG11c3QgYmUgZmluaXRlXCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBfY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUpO1xuICAgIH1cbiAgICByZXR1cm4geyBtZXNzYWdlIH07XG59O1xuZXhwb3J0IGRlZmF1bHQgZXJyb3JNYXA7XG4iLCAiaW1wb3J0IGRlZmF1bHRFcnJvck1hcCBmcm9tIFwiLi9sb2NhbGVzL2VuLmpzXCI7XG5sZXQgb3ZlcnJpZGVFcnJvck1hcCA9IGRlZmF1bHRFcnJvck1hcDtcbmV4cG9ydCB7IGRlZmF1bHRFcnJvck1hcCB9O1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIG92ZXJyaWRlRXJyb3JNYXAgPSBtYXA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlRXJyb3JNYXA7XG59XG4iLCAiaW1wb3J0IHsgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgZGVmYXVsdEVycm9yTWFwIGZyb20gXCIuLi9sb2NhbGVzL2VuLmpzXCI7XG5leHBvcnQgY29uc3QgbWFrZUlzc3VlID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgZGF0YSwgcGF0aCwgZXJyb3JNYXBzLCBpc3N1ZURhdGEgfSA9IHBhcmFtcztcbiAgICBjb25zdCBmdWxsUGF0aCA9IFsuLi5wYXRoLCAuLi4oaXNzdWVEYXRhLnBhdGggfHwgW10pXTtcbiAgICBjb25zdCBmdWxsSXNzdWUgPSB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgfTtcbiAgICBpZiAoaXNzdWVEYXRhLm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgICAgICBtZXNzYWdlOiBpc3N1ZURhdGEubWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGVycm9yTWVzc2FnZSA9IFwiXCI7XG4gICAgY29uc3QgbWFwcyA9IGVycm9yTWFwc1xuICAgICAgICAuZmlsdGVyKChtKSA9PiAhIW0pXG4gICAgICAgIC5zbGljZSgpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgZm9yIChjb25zdCBtYXAgb2YgbWFwcykge1xuICAgICAgICBlcnJvck1lc3NhZ2UgPSBtYXAoZnVsbElzc3VlLCB7IGRhdGEsIGRlZmF1bHRFcnJvcjogZXJyb3JNZXNzYWdlIH0pLm1lc3NhZ2U7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgcGF0aDogZnVsbFBhdGgsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9yTWVzc2FnZSxcbiAgICB9O1xufTtcbmV4cG9ydCBjb25zdCBFTVBUWV9QQVRIID0gW107XG5leHBvcnQgZnVuY3Rpb24gYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBpc3N1ZURhdGEpIHtcbiAgICBjb25zdCBvdmVycmlkZU1hcCA9IGdldEVycm9yTWFwKCk7XG4gICAgY29uc3QgaXNzdWUgPSBtYWtlSXNzdWUoe1xuICAgICAgICBpc3N1ZURhdGE6IGlzc3VlRGF0YSxcbiAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICBlcnJvck1hcHM6IFtcbiAgICAgICAgICAgIGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCAvLyBjb250ZXh0dWFsIGVycm9yIG1hcCBpcyBmaXJzdCBwcmlvcml0eVxuICAgICAgICAgICAgY3R4LnNjaGVtYUVycm9yTWFwLCAvLyB0aGVuIHNjaGVtYS1ib3VuZCBtYXAgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBvdmVycmlkZU1hcCwgLy8gdGhlbiBnbG9iYWwgb3ZlcnJpZGUgbWFwXG4gICAgICAgICAgICBvdmVycmlkZU1hcCA9PT0gZGVmYXVsdEVycm9yTWFwID8gdW5kZWZpbmVkIDogZGVmYXVsdEVycm9yTWFwLCAvLyB0aGVuIGdsb2JhbCBkZWZhdWx0IG1hcFxuICAgICAgICBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICB9KTtcbiAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKGlzc3VlKTtcbn1cbmV4cG9ydCBjbGFzcyBQYXJzZVN0YXR1cyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudmFsdWUgPSBcInZhbGlkXCI7XG4gICAgfVxuICAgIGRpcnR5KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSA9PT0gXCJ2YWxpZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiZGlydHlcIjtcbiAgICB9XG4gICAgYWJvcnQoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlICE9PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKSB7XG4gICAgICAgIGNvbnN0IGFycmF5VmFsdWUgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGFycmF5VmFsdWUucHVzaChzLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGFycmF5VmFsdWUgfTtcbiAgICB9XG4gICAgc3RhdGljIGFzeW5jIG1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICB9XG4gICAgc3RhdGljIG1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IGZpbmFsT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHZhbHVlIH0gPSBwYWlyO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgaWYgKGtleS52YWx1ZSAhPT0gXCJfX3Byb3RvX19cIiAmJiAodHlwZW9mIHZhbHVlLnZhbHVlICE9PSBcInVuZGVmaW5lZFwiIHx8IHBhaXIuYWx3YXlzU2V0KSkge1xuICAgICAgICAgICAgICAgIGZpbmFsT2JqZWN0W2tleS52YWx1ZV0gPSB2YWx1ZS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsT2JqZWN0IH07XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IElOVkFMSUQgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5leHBvcnQgY29uc3QgRElSVFkgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJkaXJ0eVwiLCB2YWx1ZSB9KTtcbmV4cG9ydCBjb25zdCBPSyA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlIH0pO1xuZXhwb3J0IGNvbnN0IGlzQWJvcnRlZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCI7XG5leHBvcnQgY29uc3QgaXNEaXJ0eSA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJkaXJ0eVwiO1xuZXhwb3J0IGNvbnN0IGlzVmFsaWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwidmFsaWRcIjtcbmV4cG9ydCBjb25zdCBpc0FzeW5jID0gKHgpID0+IHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHggaW5zdGFuY2VvZiBQcm9taXNlO1xuIiwgImV4cG9ydCB2YXIgZXJyb3JVdGlsO1xuKGZ1bmN0aW9uIChlcnJvclV0aWwpIHtcbiAgICBlcnJvclV0aWwuZXJyVG9PYmogPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2UgfSA6IG1lc3NhZ2UgfHwge307XG4gICAgLy8gYmlvbWUtaWdub3JlIGxpbnQ6XG4gICAgZXJyb3JVdGlsLnRvU3RyaW5nID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2U/Lm1lc3NhZ2U7XG59KShlcnJvclV0aWwgfHwgKGVycm9yVXRpbCA9IHt9KSk7XG4iLCAiaW1wb3J0IHsgWm9kRXJyb3IsIFpvZElzc3VlQ29kZSwgfSBmcm9tIFwiLi9ab2RFcnJvci5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEVycm9yTWFwLCBnZXRFcnJvck1hcCB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0IHsgZXJyb3JVdGlsIH0gZnJvbSBcIi4vaGVscGVycy9lcnJvclV0aWwuanNcIjtcbmltcG9ydCB7IERJUlRZLCBJTlZBTElELCBPSywgUGFyc2VTdGF0dXMsIGFkZElzc3VlVG9Db250ZXh0LCBpc0Fib3J0ZWQsIGlzQXN5bmMsIGlzRGlydHksIGlzVmFsaWQsIG1ha2VJc3N1ZSwgfSBmcm9tIFwiLi9oZWxwZXJzL3BhcnNlVXRpbC5qc1wiO1xuaW1wb3J0IHsgdXRpbCwgWm9kUGFyc2VkVHlwZSwgZ2V0UGFyc2VkVHlwZSB9IGZyb20gXCIuL2hlbHBlcnMvdXRpbC5qc1wiO1xuY2xhc3MgUGFyc2VJbnB1dExhenlQYXRoIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJlbnQsIHZhbHVlLCBwYXRoLCBrZXkpIHtcbiAgICAgICAgdGhpcy5fY2FjaGVkUGF0aCA9IFtdO1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5kYXRhID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX3BhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG4gICAgfVxuICAgIGdldCBwYXRoKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlZFBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLl9rZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIC4uLnRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgdGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkUGF0aDtcbiAgICB9XG59XG5jb25zdCBoYW5kbGVSZXN1bHQgPSAoY3R4LCByZXN1bHQpID0+IHtcbiAgICBpZiAoaXNWYWxpZChyZXN1bHQpKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCFjdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbGlkYXRpb24gZmFpbGVkIGJ1dCBubyBpc3N1ZXMgZGV0ZWN0ZWQuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihjdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbn07XG5mdW5jdGlvbiBwcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcykge1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgY29uc3QgeyBlcnJvck1hcCwgaW52YWxpZF90eXBlX2Vycm9yLCByZXF1aXJlZF9lcnJvciwgZGVzY3JpcHRpb24gfSA9IHBhcmFtcztcbiAgICBpZiAoZXJyb3JNYXAgJiYgKGludmFsaWRfdHlwZV9lcnJvciB8fCByZXF1aXJlZF9lcnJvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCB1c2UgXCJpbnZhbGlkX3R5cGVfZXJyb3JcIiBvciBcInJlcXVpcmVkX2Vycm9yXCIgaW4gY29uanVuY3Rpb24gd2l0aCBjdXN0b20gZXJyb3IgbWFwLmApO1xuICAgIH1cbiAgICBpZiAoZXJyb3JNYXApXG4gICAgICAgIHJldHVybiB7IGVycm9yTWFwOiBlcnJvck1hcCwgZGVzY3JpcHRpb24gfTtcbiAgICBjb25zdCBjdXN0b21NYXAgPSAoaXNzLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgeyBtZXNzYWdlIH0gPSBwYXJhbXM7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJpbnZhbGlkX2VudW1fdmFsdWVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjdHguZGF0YSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyByZXF1aXJlZF9lcnJvciA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzcy5jb2RlICE9PSBcImludmFsaWRfdHlwZVwiKVxuICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IGludmFsaWRfdHlwZV9lcnJvciA/PyBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgfTtcbiAgICByZXR1cm4geyBlcnJvck1hcDogY3VzdG9tTWFwLCBkZXNjcmlwdGlvbiB9O1xufVxuZXhwb3J0IGNsYXNzIFpvZFR5cGUge1xuICAgIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgX2dldFR5cGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIF9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KSB7XG4gICAgICAgIHJldHVybiAoY3R4IHx8IHtcbiAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogbmV3IFBhcnNlU3RhdHVzKCksXG4gICAgICAgICAgICBjdHg6IHtcbiAgICAgICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpLFxuICAgICAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGlucHV0LnBhcmVudCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9wYXJzZVN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW5jaHJvbm91cyBwYXJzZSBlbmNvdW50ZXJlZCBwcm9taXNlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBfcGFyc2VBc3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICB9XG4gICAgcGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2FmZVBhcnNlKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBzYWZlUGFyc2UoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6IHBhcmFtcz8uYXN5bmMgPz8gZmFsc2UsXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXM/LmVycm9yTWFwLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IHBhcmFtcz8ucGF0aCB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgXCJ+dmFsaWRhdGVcIihkYXRhKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgYXN5bmM6ICEhdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycj8ubWVzc2FnZT8udG9Mb3dlckNhc2UoKT8uaW5jbHVkZXMoXCJlbmNvdW50ZXJlZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VBc3luYyh7IGRhdGEsIHBhdGg6IFtdLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChyZXN1bHQpID0+IGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogY3R4LmNvbW1vbi5pc3N1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgcGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgYXN5bmMgc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgY29udGV4dHVhbEVycm9yTWFwOiBwYXJhbXM/LmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IHBhcmFtcz8ucGF0aCB8fCBbXSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgbWF5YmVBc3luY1Jlc3VsdCA9IHRoaXMuX3BhcnNlKHsgZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoaXNBc3luYyhtYXliZUFzeW5jUmVzdWx0KSA/IG1heWJlQXN5bmNSZXN1bHQgOiBQcm9taXNlLnJlc29sdmUobWF5YmVBc3luY1Jlc3VsdCkpO1xuICAgICAgICByZXR1cm4gaGFuZGxlUmVzdWx0KGN0eCwgcmVzdWx0KTtcbiAgICB9XG4gICAgcmVmaW5lKGNoZWNrLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGdldElzc3VlUHJvcGVydGllcyA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgbWVzc2FnZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZSh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gY2hlY2sodmFsKTtcbiAgICAgICAgICAgIGNvbnN0IHNldEVycm9yID0gKCkgPT4gY3R4LmFkZElzc3VlKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuY3VzdG9tLFxuICAgICAgICAgICAgICAgIC4uLmdldElzc3VlUHJvcGVydGllcyh2YWwpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgcmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVmaW5lbWVudChjaGVjaywgcmVmaW5lbWVudERhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNoZWNrKHZhbCkpIHtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUodHlwZW9mIHJlZmluZW1lbnREYXRhID09PSBcImZ1bmN0aW9uXCIgPyByZWZpbmVtZW50RGF0YSh2YWwsIGN0eCkgOiByZWZpbmVtZW50RGF0YSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcmVmaW5lbWVudChyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJyZWZpbmVtZW50XCIsIHJlZmluZW1lbnQgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQocmVmaW5lbWVudCk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRlZikge1xuICAgICAgICAvKiogQWxpYXMgb2Ygc2FmZVBhcnNlQXN5bmMgKi9cbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNhZmVQYXJzZUFzeW5jO1xuICAgICAgICB0aGlzLl9kZWYgPSBkZWY7XG4gICAgICAgIHRoaXMucGFyc2UgPSB0aGlzLnBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlID0gdGhpcy5zYWZlUGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wYXJzZUFzeW5jID0gdGhpcy5wYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2FmZVBhcnNlQXN5bmMgPSB0aGlzLnNhZmVQYXJzZUFzeW5jLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zcGEuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmUgPSB0aGlzLnJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZW1lbnQgPSB0aGlzLnJlZmluZW1lbnQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zdXBlclJlZmluZSA9IHRoaXMuc3VwZXJSZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vcHRpb25hbCA9IHRoaXMub3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsYWJsZSA9IHRoaXMubnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5udWxsaXNoID0gdGhpcy5udWxsaXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYXJyYXkgPSB0aGlzLmFycmF5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJvbWlzZSA9IHRoaXMucHJvbWlzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9yID0gdGhpcy5vci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFuZCA9IHRoaXMuYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtID0gdGhpcy50cmFuc2Zvcm0uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5icmFuZCA9IHRoaXMuYnJhbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZWZhdWx0ID0gdGhpcy5kZWZhdWx0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuY2F0Y2ggPSB0aGlzLmNhdGNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVzY3JpYmUgPSB0aGlzLmRlc2NyaWJlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGlwZSA9IHRoaXMucGlwZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlYWRvbmx5ID0gdGhpcy5yZWFkb25seS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzTnVsbGFibGUgPSB0aGlzLmlzTnVsbGFibGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc09wdGlvbmFsID0gdGhpcy5pc09wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0gPSB7XG4gICAgICAgICAgICB2ZXJzaW9uOiAxLFxuICAgICAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IChkYXRhKSA9PiB0aGlzW1wifnZhbGlkYXRlXCJdKGRhdGEpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBvcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBudWxsaXNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5udWxsYWJsZSgpLm9wdGlvbmFsKCk7XG4gICAgfVxuICAgIGFycmF5KCkge1xuICAgICAgICByZXR1cm4gWm9kQXJyYXkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gWm9kUHJvbWlzZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgb3Iob3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBab2RVbmlvbi5jcmVhdGUoW3RoaXMsIG9wdGlvbl0sIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIGFuZChpbmNvbWluZykge1xuICAgICAgICByZXR1cm4gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSh0aGlzLCBpbmNvbWluZywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgdHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwidHJhbnNmb3JtXCIsIHRyYW5zZm9ybSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVmYXVsdChkZWYpIHtcbiAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGRlZmF1bHRWYWx1ZTogZGVmYXVsdFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGJyYW5kKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJyYW5kZWQoe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCcmFuZGVkLFxuICAgICAgICAgICAgdHlwZTogdGhpcyxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNhdGNoKGRlZikge1xuICAgICAgICBjb25zdCBjYXRjaFZhbHVlRnVuYyA9IHR5cGVvZiBkZWYgPT09IFwiZnVuY3Rpb25cIiA/IGRlZiA6ICgpID0+IGRlZjtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBjYXRjaFZhbHVlOiBjYXRjaFZhbHVlRnVuYyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgICAgICBjb25zdCBUaGlzID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBUaGlzKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGlwZSh0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuIFpvZFBpcGVsaW5lLmNyZWF0ZSh0aGlzLCB0YXJnZXQpO1xuICAgIH1cbiAgICByZWFkb25seSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFJlYWRvbmx5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgaXNPcHRpb25hbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICB9XG4gICAgaXNOdWxsYWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgfVxufVxuY29uc3QgY3VpZFJlZ2V4ID0gL15jW15cXHMtXXs4LH0kL2k7XG5jb25zdCBjdWlkMlJlZ2V4ID0gL15bMC05YS16XSskLztcbmNvbnN0IHVsaWRSZWdleCA9IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvaTtcbi8vIGNvbnN0IHV1aWRSZWdleCA9XG4vLyAgIC9eKFthLWYwLTldezh9LVthLWYwLTldezR9LVsxLTVdW2EtZjAtOV17M30tW2EtZjAtOV17NH0tW2EtZjAtOV17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7XG5jb25zdCB1dWlkUmVnZXggPSAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvaTtcbmNvbnN0IG5hbm9pZFJlZ2V4ID0gL15bYS16MC05Xy1dezIxfSQvaTtcbmNvbnN0IGp3dFJlZ2V4ID0gL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLztcbmNvbnN0IGR1cmF0aW9uUmVnZXggPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLy8gZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNDYxODEvMTU1MDE1NVxuLy8gb2xkIHZlcnNpb246IHRvbyBzbG93LCBkaWRuJ3Qgc3VwcG9ydCB1bmljb2RlXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKChbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKFxcLihbYS16XXxcXGR8WyEjXFwkJSYnXFwqXFwrXFwtXFwvPVxcP1xcXl9ge1xcfH1+XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkrKSopfCgoXFx4MjIpKCgoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oKFtcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDdmXXxcXHgyMXxbXFx4MjMtXFx4NWJdfFtcXHg1ZC1cXHg3ZV18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfChcXFxcKFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZC1cXHg3Zl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkpKigoKFxceDIwfFxceDA5KSooXFx4MGRcXHgwYSkpPyhcXHgyMHxcXHgwOSkrKT8oXFx4MjIpKSlAKCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLikrKChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkqKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpJC9pO1xuLy9vbGQgZW1haWwgcmVnZXhcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoW148PigpW1xcXS4sOzpcXHNAXCJdKyhcXC5bXjw+KClbXFxdLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKD8hLSkoW148PigpW1xcXS4sOzpcXHNAXCJdK1xcLikrW148PigpW1xcXS4sOzpcXHNAXCJdezEsfSlbXi08PigpW1xcXS4sOzpcXHNAXCJdJC9pO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oKFtePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSsoXFwuW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKykqKXwoXFxcIi4rXFxcIikpQCgoXFxbKCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFxdKXwoXFxbSVB2NjooKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpXFxdKXwoW0EtWmEtejAtOV0oW0EtWmEtejAtOS1dKltBLVphLXowLTldKSooXFwuW0EtWmEtel17Mix9KSspKSQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtekEtWjAtOVxcLlxcIVxcI1xcJFxcJVxcJlxcJ1xcKlxcK1xcL1xcPVxcP1xcXlxcX1xcYFxce1xcfFxcfVxcflxcLV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL14oPzpbYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKD86XFwuW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKykqfFwiKD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjFcXHgyMy1cXHg1YlxceDVkLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkqXCIpQCg/Oig/OlthLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT9cXC4pK1thLXowLTldKD86W2EtejAtOS1dKlthLXowLTldKT98XFxbKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT98W2EtejAtOS1dKlthLXowLTldOig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxLVxceDVhXFx4NTMtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSspXFxdKSQvaTtcbmNvbnN0IGVtYWlsUmVnZXggPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWjAtOV8nK1xcLVxcLl0qKVtBLVowLTlfKy1dQChbQS1aMC05XVtBLVowLTlcXC1dKlxcLikrW0EtWl17Mix9JC9pO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eW2EtejAtOS4hIyQlJlx1MjAxOSorLz0/Xl9ge3x9fi1dK0BbYS16MC05LV0rKD86XFwuW2EtejAtOVxcLV0rKSokL2k7XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaVJlZ2V4ID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmxldCBlbW9qaVJlZ2V4O1xuLy8gZmFzdGVyLCBzaW1wbGVyLCBzYWZlclxuY29uc3QgaXB2NFJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmNvbnN0IGlwdjRDaWRyUmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLztcbi8vIGNvbnN0IGlwdjZSZWdleCA9XG4vLyAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLztcbmNvbnN0IGlwdjZSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKSQvO1xuY29uc3QgaXB2NkNpZHJSZWdleCA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmNvbnN0IGJhc2U2NFJlZ2V4ID0gL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuLy8gaHR0cHM6Ly9iYXNlNjQuZ3VydS9zdGFuZGFyZHMvYmFzZTY0dXJsXG5jb25zdCBiYXNlNjR1cmxSZWdleCA9IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLztcbi8vIHNpbXBsZVxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9YDtcbi8vIG5vIGxlYXAgeWVhciB2YWxpZGF0aW9uXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tKCgwWzEzNTc4XXwxMHwxMiktMzF8KDBbMTMtOV18MVswLTJdKS0zMHwoMFsxLTldfDFbMC0yXSktKDBbMS05XXwxXFxcXGR8MlxcXFxkKSlgO1xuLy8gd2l0aCBsZWFwIHllYXIgdmFsaWRhdGlvblxuY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlUmVnZXggPSBuZXcgUmVnRXhwKGBeJHtkYXRlUmVnZXhTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVJlZ2V4U291cmNlKGFyZ3MpIHtcbiAgICBsZXQgc2Vjb25kc1JlZ2V4U291cmNlID0gYFswLTVdXFxcXGRgO1xuICAgIGlmIChhcmdzLnByZWNpc2lvbikge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9XFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX0oXFxcXC5cXFxcZCspP2A7XG4gICAgfVxuICAgIGNvbnN0IHNlY29uZHNRdWFudGlmaWVyID0gYXJncy5wcmVjaXNpb24gPyBcIitcIiA6IFwiP1wiOyAvLyByZXF1aXJlIHNlY29uZHMgaWYgcHJlY2lzaW9uIGlzIG5vbnplcm9cbiAgICByZXR1cm4gYChbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKDoke3NlY29uZHNSZWdleFNvdXJjZX0pJHtzZWNvbmRzUXVhbnRpZmllcn1gO1xufVxuZnVuY3Rpb24gdGltZVJlZ2V4KGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZXhwb3J0IGZ1bmN0aW9uIGRhdGV0aW1lUmVnZXgoYXJncykge1xuICAgIGxldCByZWdleCA9IGAke2RhdGVSZWdleFNvdXJjZX1UJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9YDtcbiAgICBjb25zdCBvcHRzID0gW107XG4gICAgb3B0cy5wdXNoKGFyZ3MubG9jYWwgPyBgWj9gIDogYFpgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTo/XFxcXGR7Mn0pYCk7XG4gICAgcmVnZXggPSBgJHtyZWdleH0oJHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSVAoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NFJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NlJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc1ZhbGlkSldUKGp3dCwgYWxnKSB7XG4gICAgaWYgKCFqd3RSZWdleC50ZXN0KGp3dCkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IGp3dC5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICghaGVhZGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBDb252ZXJ0IGJhc2U2NHVybCB0byBiYXNlNjRcbiAgICAgICAgY29uc3QgYmFzZTY0ID0gaGVhZGVyXG4gICAgICAgICAgICAucmVwbGFjZSgvLS9nLCBcIitcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9fL2csIFwiL1wiKVxuICAgICAgICAgICAgLnBhZEVuZChoZWFkZXIubGVuZ3RoICsgKCg0IC0gKGhlYWRlci5sZW5ndGggJSA0KSkgJSA0KSwgXCI9XCIpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBKU09OLnBhcnNlKGF0b2IoYmFzZTY0KSk7XG4gICAgICAgIGlmICh0eXBlb2YgZGVjb2RlZCAhPT0gXCJvYmplY3RcIiB8fCBkZWNvZGVkID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoXCJ0eXBcIiBpbiBkZWNvZGVkICYmIGRlY29kZWQ/LnR5cCAhPT0gXCJKV1RcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFkZWNvZGVkLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZyAmJiBkZWNvZGVkLmFsZyAhPT0gYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNWYWxpZENpZHIoaXAsIHZlcnNpb24pIHtcbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjRcIiB8fCAhdmVyc2lvbikgJiYgaXB2NENpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBjbGFzcyBab2RTdHJpbmcgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBTdHJpbmcoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3RyaW5nLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImxlbmd0aFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQuZGF0YS5sZW5ndGggPiBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtYWlsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtYWlsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4KSB7XG4gICAgICAgICAgICAgICAgICAgIGVtb2ppUmVnZXggPSBuZXcgUmVnRXhwKF9lbW9qaVJlZ2V4LCBcInVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1vamlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInV1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXVpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1dWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghbmFub2lkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcIm5hbm9pZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWQyUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImN1aWQyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVsaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXJsXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIG5ldyBVUkwoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBjaGVjay5yZWdleC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlc3RSZXN1bHQgPSBjaGVjay5yZWdleC50ZXN0KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGlmICghdGVzdFJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0cmltXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImluY2x1ZGVzXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuaW5jbHVkZXMoY2hlY2sudmFsdWUsIGNoZWNrLnBvc2l0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGluY2x1ZGVzOiBjaGVjay52YWx1ZSwgcG9zaXRpb246IGNoZWNrLnBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b0xvd2VyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9VcHBlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInN0YXJ0c1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5zdGFydHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IHN0YXJ0c1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbmRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmVuZHNXaXRoKGNoZWNrLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiB7IGVuZHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZXRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZXRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gZGF0ZVJlZ2V4O1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZ2V4ID0gdGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFkdXJhdGlvblJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkdXJhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaXBcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZElQKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiaXBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSldUKGlucHV0LmRhdGEsIGNoZWNrLmFsZykpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJqd3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENpZHIoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjaWRyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0UmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NHVybFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX3JlZ2V4KHJlZ2V4LCB2YWxpZGF0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlZmluZW1lbnQoKGRhdGEpID0+IHJlZ2V4LnRlc3QoZGF0YSksIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb24sXG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW1haWwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtYWlsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1cmxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBlbW9qaShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1vamlcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1dWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1dWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgbmFub2lkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJuYW5vaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZDIobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWQyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdWxpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidWxpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiYmFzZTY0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0dXJsKG1lc3NhZ2UpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBqd3Qob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImp3dFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGlwKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJpcFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGNpZHIob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImNpZHJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBkYXRldGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIG9mZnNldDogb3B0aW9ucz8ub2Zmc2V0ID8/IGZhbHNlLFxuICAgICAgICAgICAgbG9jYWw6IG9wdGlvbnM/LmxvY2FsID8/IGZhbHNlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGF0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZGF0ZVwiLCBtZXNzYWdlIH0pO1xuICAgIH1cbiAgICB0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwidGltZVwiLFxuICAgICAgICAgICAgcHJlY2lzaW9uOiB0eXBlb2Ygb3B0aW9ucz8ucHJlY2lzaW9uID09PSBcInVuZGVmaW5lZFwiID8gbnVsbCA6IG9wdGlvbnM/LnByZWNpc2lvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGR1cmF0aW9uKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkdXJhdGlvblwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHJlZ2V4KHJlZ2V4LCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInJlZ2V4XCIsXG4gICAgICAgICAgICByZWdleDogcmVnZXgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbmNsdWRlcyh2YWx1ZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgcG9zaXRpb246IG9wdGlvbnM/LnBvc2l0aW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhcnRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJzdGFydHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmRzV2l0aCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJlbmRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5MZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heExlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibGVuZ3RoXCIsXG4gICAgICAgICAgICB2YWx1ZTogbGVuLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXF1aXZhbGVudCB0byBgLm1pbigxKWBcbiAgICAgKi9cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkpO1xuICAgIH1cbiAgICB0cmltKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidHJpbVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9Mb3dlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b0xvd2VyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9VcHBlckNhc2UoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0b1VwcGVyQ2FzZVwiIH1dLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZXRpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZXRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0RhdGUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZGF0ZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEdXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkdXJhdGlvblwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1haWwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1haWxcIik7XG4gICAgfVxuICAgIGdldCBpc1VSTCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1cmxcIik7XG4gICAgfVxuICAgIGdldCBpc0Vtb2ppKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtb2ppXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInV1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc05BTk9JRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJuYW5vaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRDIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY3VpZDJcIik7XG4gICAgfVxuICAgIGdldCBpc1VMSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidWxpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzSVAoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaXBcIik7XG4gICAgfVxuICAgIGdldCBpc0NJRFIoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiY2lkclwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQmFzZTY0dXJsKCkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImJhc2U2NHVybFwiKTtcbiAgICB9XG4gICAgZ2V0IG1pbkxlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4TGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kU3RyaW5nLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3RyaW5nLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMzk2NjQ4NC93aHktZG9lcy1tb2R1bHVzLW9wZXJhdG9yLXJldHVybi1mcmFjdGlvbmFsLW51bWJlci1pbi1qYXZhc2NyaXB0LzMxNzExMDM0IzMxNzExMDM0XG5mdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwRGVjQ291bnQgPSAoc3RlcC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIDEwICoqIGRlY0NvdW50O1xufVxuZXhwb3J0IGNsYXNzIFpvZE51bWJlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgICAgICB0aGlzLnN0ZXAgPSB0aGlzLm11bHRpcGxlT2Y7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IE51bWJlcihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udW1iZXIsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJpbnRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdXRpbC5pc0ludGVnZXIoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImludGVnZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBcImZsb2F0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChmbG9hdFNhZmVSZW1haW5kZXIoaW5wdXQuZGF0YSwgY2hlY2sudmFsdWUpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImZpbml0ZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9maW5pdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGludChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImludFwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZpbml0ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImZpbml0ZVwiLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2FmZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KS5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG4gICAgZ2V0IGlzSW50KCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImludFwiIHx8IChjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIiAmJiB1dGlsLmlzSW50ZWdlcihjaC52YWx1ZSkpKTtcbiAgICB9XG4gICAgZ2V0IGlzRmluaXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwiZmluaXRlXCIgfHwgY2gua2luZCA9PT0gXCJpbnRcIiB8fCBjaC5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNGaW5pdGUobWluKSAmJiBOdW1iZXIuaXNGaW5pdGUobWF4KTtcbiAgICB9XG59XG5ab2ROdW1iZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdW1iZXIsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQmlnSW50IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gQmlnSW50KGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYmlnaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA8IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA8PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhID4gY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhID49IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm11bHRpcGxlT2ZcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhICUgY2hlY2sudmFsdWUgIT09IEJpZ0ludCgwKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5iaWdpbnQsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25uZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxufVxuWm9kQmlnSW50LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQmlnSW50LFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlID8/IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEJvb2xlYW4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCb29sZWFuKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYm9vbGVhbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5ib29sZWFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEJvb2xlYW4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQm9vbGVhbih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQm9vbGVhbixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REYXRlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gbmV3IERhdGUoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5kYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmRhdGUsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKGlucHV0LmRhdGEuZ2V0VGltZSgpKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPCBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0ZShpbnB1dC5kYXRhLmdldFRpbWUoKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWluKG1pbkRhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluRGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4RGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhEYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5EYXRlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW4gIT0gbnVsbCA/IG5ldyBEYXRlKG1pbikgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgbWF4RGF0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4ICE9IG51bGwgPyBuZXcgRGF0ZShtYXgpIDogbnVsbDtcbiAgICB9XG59XG5ab2REYXRlLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERhdGUoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERhdGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU3ltYm9sIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3ltYm9sKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN5bWJvbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RTeW1ib2wuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3ltYm9sKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTeW1ib2wsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5kZWZpbmVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmRlZmluZWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5kZWZpbmVkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmRlZmluZWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVsbCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2ROdWxsLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGwoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQW55IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHRvIHByZXZlbnQgaW5zdGFuY2VzIG9mIG90aGVyIGNsYXNzZXMgZnJvbSBleHRlbmRpbmcgWm9kQW55LiB0aGlzIGNhdXNlcyBpc3N1ZXMgd2l0aCBjYXRjaGFsbCBpbiBab2RPYmplY3QuXG4gICAgICAgIHRoaXMuX2FueSA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQW55LmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFueSh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQW55LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVua25vd24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gcmVxdWlyZWRcbiAgICAgICAgdGhpcy5fdW5rbm93biA9IHRydWU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5rbm93bi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmtub3duKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmtub3duLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE5ldmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmV2ZXIsXG4gICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICB9XG59XG5ab2ROZXZlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROZXZlcih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmV2ZXIsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVm9pZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS52b2lkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFZvaWQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVm9pZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVm9pZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBcnJheSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCwgc3RhdHVzIH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYuZXhhY3RMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gY3R4LmRhdGEubGVuZ3RoIDwgZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiB0b29CaWcgPyBab2RJc3N1ZUNvZGUudG9vX2JpZyA6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06ICh0b29TbWFsbCA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06ICh0b29CaWcgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5leGFjdExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWluTGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgZGVmLm1pbkxlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluTGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluTGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhMZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPiBkZWYubWF4TGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4TGVuZ3RoLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VBc3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgICAgIH0pKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbLi4uY3R4LmRhdGFdLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZVN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5MZW5ndGg6IHsgdmFsdWU6IG1pbkxlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4TGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4TGVuZ3RoOiB7IHZhbHVlOiBtYXhMZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGV4YWN0TGVuZ3RoOiB7IHZhbHVlOiBsZW4sIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kQXJyYXkuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgbWluTGVuZ3RoOiBudWxsLFxuICAgICAgICBtYXhMZW5ndGg6IG51bGwsXG4gICAgICAgIGV4YWN0TGVuZ3RoOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFycmF5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gZGVlcFBhcnRpYWxpZnkoc2NoZW1hKSB7XG4gICAgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9iamVjdCkge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEuc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gc2NoZW1hLnNoYXBlW2tleV07XG4gICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KGZpZWxkU2NoZW1hKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RBcnJheSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgdHlwZTogZGVlcFBhcnRpYWxpZnkoc2NoZW1hLmVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZE51bGxhYmxlLmNyZWF0ZShkZWVwUGFydGlhbGlmeShzY2hlbWEudW53cmFwKCkpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kVHVwbGUpIHtcbiAgICAgICAgcmV0dXJuIFpvZFR1cGxlLmNyZWF0ZShzY2hlbWEuaXRlbXMubWFwKChpdGVtKSA9PiBkZWVwUGFydGlhbGlmeShpdGVtKSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kT2JqZWN0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBJbiBtb3N0IGNhc2VzLCB0aGlzIGlzIG5vIGxvbmdlciBuZWVkZWQgLSB1bmtub3duIHByb3BlcnRpZXMgYXJlIG5vdyBzaWxlbnRseSBzdHJpcHBlZC5cbiAgICAgICAgICogSWYgeW91IHdhbnQgdG8gcGFzcyB0aHJvdWdoIHVua25vd24gcHJvcGVydGllcywgdXNlIGAucGFzc3Rocm91Z2goKWAgaW5zdGVhZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm9uc3RyaWN0ID0gdGhpcy5wYXNzdGhyb3VnaDtcbiAgICAgICAgLy8gZXh0ZW5kPFxuICAgICAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlLFxuICAgICAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAgICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PixcbiAgICAgICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHV0aWwuZmxhdHRlbjx7XG4gICAgICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAgICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+XG4gICAgICAgIC8vID4oXG4gICAgICAgIC8vICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gKTogWm9kT2JqZWN0PFxuICAgICAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIEF1Z21lbnRhdGlvbj4sXG4gICAgICAgIC8vICAgVW5rbm93bktleXMsXG4gICAgICAgIC8vICAgQ2F0Y2hhbGwsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0LFxuICAgICAgICAvLyAgIE5ld0lucHV0XG4gICAgICAgIC8vID4ge1xuICAgICAgICAvLyAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgLy8gICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgLy8gICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAvLyAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgLy8gICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAvLyAgICAgfSksXG4gICAgICAgIC8vICAgfSkgYXMgYW55O1xuICAgICAgICAvLyB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZGVwcmVjYXRlZCBVc2UgYC5leHRlbmRgIGluc3RlYWRcbiAgICAgICAgICogICovXG4gICAgICAgIHRoaXMuYXVnbWVudCA9IHRoaXMuZXh0ZW5kO1xuICAgIH1cbiAgICBfZ2V0Q2FjaGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fY2FjaGVkICE9PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICAgICAgY29uc3Qga2V5cyA9IHV0aWwub2JqZWN0S2V5cyhzaGFwZSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZCA9IHsgc2hhcGUsIGtleXMgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IHsgc2hhcGUsIGtleXM6IHNoYXBlS2V5cyB9ID0gdGhpcy5fZ2V0Q2FjaGVkKCk7XG4gICAgICAgIGNvbnN0IGV4dHJhS2V5cyA9IFtdO1xuICAgICAgICBpZiAoISh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlciAmJiB0aGlzLl9kZWYudW5rbm93bktleXMgPT09IFwic3RyaXBcIikpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzaGFwZUtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBleHRyYUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFwZUtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVZhbGlkYXRvciA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICB2YWx1ZToga2V5VmFsaWRhdG9yLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY2F0Y2hhbGwgaW5zdGFuY2VvZiBab2ROZXZlcikge1xuICAgICAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB0aGlzLl9kZWYudW5rbm93bktleXM7XG4gICAgICAgICAgICBpZiAodW5rbm93bktleXMgPT09IFwicGFzc3Rocm91Z2hcIikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBjdHguZGF0YVtrZXldIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmljdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4dHJhS2V5cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5czogZXh0cmFLZXlzLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaXBcIikge1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnRlcm5hbCBab2RPYmplY3QgZXJyb3I6IGludmFsaWQgdW5rbm93bktleXMgdmFsdWUuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBydW4gY2F0Y2hhbGwgdmFsaWRhdGlvblxuICAgICAgICAgICAgY29uc3QgY2F0Y2hhbGwgPSB0aGlzLl9kZWYuY2F0Y2hhbGw7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGN0eC5kYXRhW2tleV07XG4gICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogY2F0Y2hhbGwuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkgLy8sIGN0eC5jaGlsZChrZXkpLCB2YWx1ZSwgZ2V0UGFyc2VkVHlwZSh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKVxuICAgICAgICAgICAgICAgIC50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzeW5jUGFpcnMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IHBhaXIuYWx3YXlzU2V0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN5bmNQYWlycztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKHN5bmNQYWlycykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgIH1cbiAgICBzdHJpY3QobWVzc2FnZSkge1xuICAgICAgICBlcnJvclV0aWwuZXJyVG9PYmo7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1hcDogKGlzc3VlLCBjdHgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRFcnJvciA9IHRoaXMuX2RlZi5lcnJvck1hcD8uKGlzc3VlLCBjdHgpLm1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLm1lc3NhZ2UgPz8gZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RyaXAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXNzdGhyb3VnaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwicGFzc3Rocm91Z2hcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbnN0IEF1Z21lbnRGYWN0b3J5ID1cbiAgICAvLyAgIDxEZWYgZXh0ZW5kcyBab2RPYmplY3REZWY+KGRlZjogRGVmKSA9PlxuICAgIC8vICAgPEF1Z21lbnRhdGlvbiBleHRlbmRzIFpvZFJhd1NoYXBlPihcbiAgICAvLyAgICAgYXVnbWVudGF0aW9uOiBBdWdtZW50YXRpb25cbiAgICAvLyAgICk6IFpvZE9iamVjdDxcbiAgICAvLyAgICAgZXh0ZW5kU2hhcGU8UmV0dXJuVHlwZTxEZWZbXCJzaGFwZVwiXT4sIEF1Z21lbnRhdGlvbj4sXG4gICAgLy8gICAgIERlZltcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgICBEZWZbXCJjYXRjaGFsbFwiXVxuICAgIC8vICAgPiA9PiB7XG4gICAgLy8gICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgICAuLi5kZWYsXG4gICAgLy8gICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgLy8gICAgICAgICAuLi5kZWYuc2hhcGUoKSxcbiAgICAvLyAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAvLyAgICAgICB9KSxcbiAgICAvLyAgICAgfSkgYXMgYW55O1xuICAgIC8vICAgfTtcbiAgICBleHRlbmQoYXVnbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgICAgIH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJpb3IgdG8gem9kQDEuMC4xMiB0aGVyZSB3YXMgYSBidWcgaW4gdGhlXG4gICAgICogaW5mZXJyZWQgdHlwZSBvZiBtZXJnZWQgb2JqZWN0cy4gUGxlYXNlXG4gICAgICogdXBncmFkZSBpZiB5b3UgYXJlIGV4cGVyaWVuY2luZyBpc3N1ZXMuXG4gICAgICovXG4gICAgbWVyZ2UobWVyZ2luZykge1xuICAgICAgICBjb25zdCBtZXJnZWQgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgICAgICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4ubWVyZ2luZy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9XG4gICAgLy8gbWVyZ2U8XG4gICAgLy8gICBJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdCxcbiAgICAvLyAgIEF1Z21lbnRhdGlvbiBleHRlbmRzIEluY29taW5nW1wic2hhcGVcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBPdXRwdXRcbiAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9LFxuICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB7XG4gICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgSW5wdXRcbiAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH1cbiAgICAvLyA+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0LFxuICAgIC8vICAgTmV3SW5wdXRcbiAgICAvLyA+IHtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBzZXRLZXkoa2V5LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXVnbWVudCh7IFtrZXldOiBzY2hlbWEgfSk7XG4gICAgfVxuICAgIC8vIG1lcmdlPEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0PihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogLy9ab2RPYmplY3Q8VCAmIEluY29taW5nW1wiX3NoYXBlXCJdLCBVbmtub3duS2V5cywgQ2F0Y2hhbGw+ID0gKG1lcmdpbmcpID0+IHtcbiAgICAvLyBab2RPYmplY3Q8XG4gICAgLy8gICBleHRlbmRTaGFwZTxULCBSZXR1cm5UeXBlPEluY29taW5nW1wiX2RlZlwiXVtcInNoYXBlXCJdPj4sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcImNhdGNoYWxsXCJdXG4gICAgLy8gPiB7XG4gICAgLy8gICAvLyBjb25zdCBtZXJnZWRTaGFwZSA9IG9iamVjdFV0aWwubWVyZ2VTaGFwZXMoXG4gICAgLy8gICAvLyAgIHRoaXMuX2RlZi5zaGFwZSgpLFxuICAgIC8vICAgLy8gICBtZXJnaW5nLl9kZWYuc2hhcGUoKVxuICAgIC8vICAgLy8gKTtcbiAgICAvLyAgIGNvbnN0IG1lcmdlZDogYW55ID0gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgIHVua25vd25LZXlzOiBtZXJnaW5nLl9kZWYudW5rbm93bktleXMsXG4gICAgLy8gICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgLy8gICAgIHNoYXBlOiAoKSA9PlxuICAgIC8vICAgICAgIG9iamVjdFV0aWwubWVyZ2VTaGFwZXModGhpcy5fZGVmLnNoYXBlKCksIG1lcmdpbmcuX2RlZi5zaGFwZSgpKSxcbiAgICAvLyAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgLy8gICB9KSBhcyBhbnk7XG4gICAgLy8gICByZXR1cm4gbWVyZ2VkO1xuICAgIC8vIH1cbiAgICBjYXRjaGFsbChpbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjYXRjaGFsbDogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaWNrKG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKG1hc2spKSB7XG4gICAgICAgICAgICBpZiAobWFza1trZXldICYmIHRoaXMuc2hhcGVba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgb21pdChtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgZGVlcFBhcnRpYWwoKSB7XG4gICAgICAgIHJldHVybiBkZWVwUGFydGlhbGlmeSh0aGlzKTtcbiAgICB9XG4gICAgcGFydGlhbChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGZpZWxkU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVxdWlyZWQobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgbGV0IG5ld0ZpZWxkID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld0ZpZWxkIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RmllbGQgPSBuZXdGaWVsZC5fZGVmLmlubmVyVHlwZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IG5ld0ZpZWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGtleW9mKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlWm9kRW51bSh1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpO1xuICAgIH1cbn1cblpvZE9iamVjdC5jcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LnN0cmljdENyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmljdFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kT2JqZWN0LmxhenljcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9kZWYub3B0aW9ucztcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVzdWx0cyhyZXN1bHRzKSB7XG4gICAgICAgICAgICAvLyByZXR1cm4gZmlyc3QgaXNzdWUtZnJlZSB2YWxpZGF0aW9uIGlmIGl0IGV4aXN0c1xuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBhZGQgaXNzdWVzIGZyb20gZGlydHkgb3B0aW9uXG4gICAgICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4ucmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmV0dXJuIGludmFsaWRcbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gbmV3IFpvZEVycm9yKHJlc3VsdC5jdHguY29tbW9uLmlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwob3B0aW9ucy5tYXAoYXN5bmMgKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgY3R4OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSkpLnRoZW4oaGFuZGxlUmVzdWx0cyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgZGlydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBpc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIiAmJiAhZGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlydHkgPSB7IHJlc3VsdCwgY3R4OiBjaGlsZEN0eCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRDdHguY29tbW9uLmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzLnB1c2goY2hpbGRDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpcnR5KSB7XG4gICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5kaXJ0eS5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpcnR5LnJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHVuaW9uRXJyb3JzID0gaXNzdWVzLm1hcCgoaXNzdWVzKSA9PiBuZXcgWm9kRXJyb3IoaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG59XG5ab2RVbmlvbi5jcmVhdGUgPSAodHlwZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICBvcHRpb25zOiB0eXBlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RVbmlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICBab2REaXNjcmltaW5hdGVkVW5pb24gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBnZXREaXNjcmltaW5hdG9yID0gKHR5cGUpID0+IHtcbiAgICBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExhenkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5zY2hlbWEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRWZmZWN0cykge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLmlubmVyVHlwZSgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZExpdGVyYWwpIHtcbiAgICAgICAgcmV0dXJuIFt0eXBlLnZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVudW0pIHtcbiAgICAgICAgcmV0dXJuIHR5cGUub3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE5hdGl2ZUVudW0pIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGJhbi9iYW5cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKHR5cGUuZW51bSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2REZWZhdWx0KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kVW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBbdW5kZWZpbmVkLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBbbnVsbCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RCcmFuZGVkKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kUmVhZG9ubHkpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RDYXRjaCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59O1xuZXhwb3J0IGNsYXNzIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWUgPSBjdHguZGF0YVtkaXNjcmltaW5hdG9yXTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gdGhpcy5vcHRpb25zTWFwLmdldChkaXNjcmltaW5hdG9yVmFsdWUpO1xuICAgICAgICBpZiAoIW9wdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBBcnJheS5mcm9tKHRoaXMub3B0aW9uc01hcC5rZXlzKCkpLFxuICAgICAgICAgICAgICAgIHBhdGg6IFtkaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGRpc2NyaW1pbmF0b3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGlzY3JpbWluYXRvcjtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnNNYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYub3B0aW9uc01hcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSBkaXNjcmltaW5hdGVkIHVuaW9uIHNjaGVtYS4gSXRzIGJlaGF2aW91ciBpcyB2ZXJ5IHNpbWlsYXIgdG8gdGhhdCBvZiB0aGUgbm9ybWFsIHoudW5pb24oKSBjb25zdHJ1Y3Rvci5cbiAgICAgKiBIb3dldmVyLCBpdCBvbmx5IGFsbG93cyBhIHVuaW9uIG9mIG9iamVjdHMsIGFsbCBvZiB3aGljaCBuZWVkIHRvIHNoYXJlIGEgZGlzY3JpbWluYXRvciBwcm9wZXJ0eS4gVGhpcyBwcm9wZXJ0eSBtdXN0XG4gICAgICogaGF2ZSBhIGRpZmZlcmVudCB2YWx1ZSBmb3IgZWFjaCBvYmplY3QgaW4gdGhlIHVuaW9uLlxuICAgICAqIEBwYXJhbSBkaXNjcmltaW5hdG9yIHRoZSBuYW1lIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5XG4gICAgICogQHBhcmFtIHR5cGVzIGFuIGFycmF5IG9mIG9iamVjdCBzY2hlbWFzXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUoZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgICAgIC8vIEdldCBhbGwgdGhlIHZhbGlkIGRpc2NyaW1pbmF0b3IgdmFsdWVzXG4gICAgICAgIGNvbnN0IG9wdGlvbnNNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIHRyeSB7XG4gICAgICAgIGZvciAoY29uc3QgdHlwZSBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yVmFsdWVzID0gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNoYXBlW2Rpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgICAgIGlmICghZGlzY3JpbWluYXRvclZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZGlzY3JpbWluYXRvciB2YWx1ZSBmb3Iga2V5IFxcYCR7ZGlzY3JpbWluYXRvcn1cXGAgY291bGQgbm90IGJlIGV4dHJhY3RlZCBmcm9tIGFsbCBzY2hlbWEgb3B0aW9uc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBkaXNjcmltaW5hdG9yVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9wdGlvbnNNYXAuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpc2NyaW1pbmF0b3IgcHJvcGVydHkgJHtTdHJpbmcoZGlzY3JpbWluYXRvcil9IGhhcyBkdXBsaWNhdGUgdmFsdWUgJHtTdHJpbmcodmFsdWUpfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvcHRpb25zTWFwLnNldCh2YWx1ZSwgdHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REaXNjcmltaW5hdGVkVW5pb24sXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICAgIG9wdGlvbnNNYXAsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICBjb25zdCBhVHlwZSA9IGdldFBhcnNlZFR5cGUoYSk7XG4gICAgY29uc3QgYlR5cGUgPSBnZXRQYXJzZWRUeXBlKGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSB1dGlsLm9iamVjdEtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSB1dGlsLm9iamVjdEtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiBiVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZEludGVyc2VjdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBoYW5kbGVQYXJzZWQgPSAocGFyc2VkTGVmdCwgcGFyc2VkUmlnaHQpID0+IHtcbiAgICAgICAgICAgIGlmIChpc0Fib3J0ZWQocGFyc2VkTGVmdCkgfHwgaXNBYm9ydGVkKHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMocGFyc2VkTGVmdC52YWx1ZSwgcGFyc2VkUmlnaHQudmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzRGlydHkocGFyc2VkTGVmdCkgfHwgaXNEaXJ0eShwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogbWVyZ2VkLmRhdGEgfTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLmxlZnQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiBoYW5kbGVQYXJzZWQobGVmdCwgcmlnaHQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQYXJzZWQodGhpcy5fZGVmLmxlZnQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSwgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZSA9IChsZWZ0LCByaWdodCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kSW50ZXJzZWN0aW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8gdHlwZSBab2RUdXBsZUl0ZW1zID0gW1pvZFR5cGVBbnksIC4uLlpvZFR5cGVBbnlbXV07XG5leHBvcnQgY2xhc3MgWm9kVHVwbGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgbWluaW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdCA9IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICBpZiAoIXJlc3QgJiYgY3R4LmRhdGEubGVuZ3RoID4gdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBbLi4uY3R4LmRhdGFdXG4gICAgICAgICAgICAubWFwKChpdGVtLCBpdGVtSW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuX2RlZi5pdGVtc1tpdGVtSW5kZXhdIHx8IHRoaXMuX2RlZi5yZXN0O1xuICAgICAgICAgICAgaWYgKCFzY2hlbWEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGl0ZW1JbmRleCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeCkgPT4gISF4KTsgLy8gZmlsdGVyIG51bGxzXG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoaXRlbXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VBcnJheShzdGF0dXMsIGl0ZW1zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaXRlbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaXRlbXM7XG4gICAgfVxuICAgIHJlc3QocmVzdCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJlc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZFR1cGxlLmNyZWF0ZSA9IChzY2hlbWFzLCBwYXJhbXMpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiWW91IG11c3QgcGFzcyBhbiBhcnJheSBvZiBzY2hlbWFzIHRvIHoudHVwbGUoWyAuLi4gXSlcIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICBpdGVtczogc2NoZW1hcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RUdXBsZSxcbiAgICAgICAgcmVzdDogbnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RSZWNvcmQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBjdHguZGF0YVtrZXldLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0QXN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShmaXJzdCwgc2Vjb25kLCB0aGlyZCkge1xuICAgICAgICBpZiAoc2Vjb25kIGluc3RhbmNlb2YgWm9kVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAgICAgIGtleVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgICAgIHZhbHVlVHlwZTogc2Vjb25kLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcmQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICAgICAga2V5VHlwZTogWm9kU3RyaW5nLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdmFsdWVUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVjb3JkLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhzZWNvbmQpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kTWFwIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm1hcCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5tYXAsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGNvbnN0IHBhaXJzID0gWy4uLmN0eC5kYXRhLmVudHJpZXMoKV0ubWFwKChba2V5LCB2YWx1ZV0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGtleToga2V5VHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGtleSwgY3R4LnBhdGgsIFtpbmRleCwgXCJrZXlcIl0pKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBbaW5kZXgsIFwidmFsdWVcIl0pKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZmluYWxNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxNYXAgfTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZE1hcC5jcmVhdGUgPSAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RNYXAsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kU2V0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zZXQpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc2V0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoZGVmLm1pblNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplIDwgZGVmLm1pblNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pblNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWluU2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4U2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPiBkZWYubWF4U2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heFNpemUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYubWF4U2l6ZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZ1bmN0aW9uIGZpbmFsaXplU2V0KGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRTZXQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcGFyc2VkU2V0LmFkZChlbGVtZW50LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcGFyc2VkU2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbLi4uY3R4LmRhdGEudmFsdWVzKCldLm1hcCgoaXRlbSwgaSkgPT4gdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoZWxlbWVudHMpLnRoZW4oKGVsZW1lbnRzKSA9PiBmaW5hbGl6ZVNldChlbGVtZW50cykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsaXplU2V0KGVsZW1lbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtaW4obWluU2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtaW5TaXplOiB7IHZhbHVlOiBtaW5TaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhTaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heFNpemU6IHsgdmFsdWU6IG1heFNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2l6ZShzaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbihzaXplLCBtZXNzYWdlKS5tYXgoc2l6ZSwgbWVzc2FnZSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZFNldC5jcmVhdGUgPSAodmFsdWVUeXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgbWluU2l6ZTogbnVsbCxcbiAgICAgICAgbWF4U2l6ZTogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTZXQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRnVuY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSA9IHRoaXMuaW1wbGVtZW50O1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbikge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5mdW5jdGlvbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VBcmdzSXNzdWUoYXJncywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50cyxcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlUmV0dXJuc0lzc3VlKHJldHVybnMsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiByZXR1cm5zLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVHlwZUVycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAgfTtcbiAgICAgICAgY29uc3QgZm4gPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5yZXR1cm5zIGluc3RhbmNlb2YgWm9kUHJvbWlzZSkge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoW10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBhd2FpdCBtZS5fZGVmLmFyZ3MucGFyc2VBc3luYyhhcmdzLCBwYXJhbXMpLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VBcmdzSXNzdWUoYXJncywgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gYXdhaXQgbWUuX2RlZi5yZXR1cm5zLl9kZWYudHlwZVxuICAgICAgICAgICAgICAgICAgICAucGFyc2VBc3luYyhyZXN1bHQsIHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZElzc3VlKG1ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gbWUuX2RlZi5hcmdzLnNhZmVQYXJzZShhcmdzLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkQXJncy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZUFyZ3NJc3N1ZShhcmdzLCBwYXJzZWRBcmdzLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZuLCB0aGlzLCBwYXJzZWRBcmdzLmRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBtZS5fZGVmLnJldHVybnMuc2FmZVBhcnNlKHJlc3VsdCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJldHVybnMuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VSZXR1cm5zSXNzdWUocmVzdWx0LCBwYXJzZWRSZXR1cm5zLmVycm9yKV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucy5kYXRhO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5hcmdzO1xuICAgIH1cbiAgICByZXR1cm5UeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnJldHVybnM7XG4gICAgfVxuICAgIGFyZ3MoLi4uaXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBhcmdzOiBab2RUdXBsZS5jcmVhdGUoaXRlbXMpLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm5zKHJldHVyblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5UeXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdHJpY3RJbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYXJncywgcmV0dXJucywgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgYXJnczogKGFyZ3MgPyBhcmdzIDogWm9kVHVwbGUuY3JlYXRlKFtdKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpKSxcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVybnMgfHwgWm9kVW5rbm93bi5jcmVhdGUoKSxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRnVuY3Rpb24sXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RMYXp5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBsYXp5U2NoZW1hID0gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgICAgICByZXR1cm4gbGF6eVNjaGVtYS5fcGFyc2UoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pO1xuICAgIH1cbn1cblpvZExhenkuY3JlYXRlID0gKGdldHRlciwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGF6eSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RMaXRlcmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmIChpbnB1dC5kYXRhICE9PSB0aGlzLl9kZWYudmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0aGlzLl9kZWYudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWU7XG4gICAgfVxufVxuWm9kTGl0ZXJhbC5jcmVhdGUgPSAodmFsdWUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMaXRlcmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZnVuY3Rpb24gY3JlYXRlWm9kRW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY2xhc3MgWm9kRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmRhdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdGhpcy5fZGVmLnZhbHVlcztcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgVmFsdWVzKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IEVudW0oKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBleHRyYWN0KHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh2YWx1ZXMsIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGV4Y2x1ZGUodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHRoaXMub3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gIXZhbHVlcy5pbmNsdWRlcyhvcHQpKSwge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RFbnVtLmNyZWF0ZSA9IGNyZWF0ZVpvZEVudW07XG5leHBvcnQgY2xhc3MgWm9kTmF0aXZlRW51bSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBuYXRpdmVFbnVtVmFsdWVzID0gdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZyAmJiBjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9lbnVtX3ZhbHVlLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IGV4cGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlcztcbiAgICB9XG59XG5ab2ROYXRpdmVFbnVtLmNyZWF0ZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmF0aXZlRW51bSh7XG4gICAgICAgIHZhbHVlczogdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hdGl2ZUVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kUHJvbWlzZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlICYmIGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnByb21pc2UsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9taXNpZmllZCA9IGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnByb21pc2UgPyBjdHguZGF0YSA6IFByb21pc2UucmVzb2x2ZShjdHguZGF0YSk7XG4gICAgICAgIHJldHVybiBPSyhwcm9taXNpZmllZC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUucGFyc2VBc3luYyhkYXRhLCB7XG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5ab2RQcm9taXNlLmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQcm9taXNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEVmZmVjdHMgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBpbm5lclR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBzb3VyY2VUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fZGVmLnR5cGVOYW1lID09PSBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0c1xuICAgICAgICAgICAgPyB0aGlzLl9kZWYuc2NoZW1hLnNvdXJjZVR5cGUoKVxuICAgICAgICAgICAgOiB0aGlzLl9kZWYuc2NoZW1hO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZWZmZWN0ID0gdGhpcy5fZGVmLmVmZmVjdCB8fCBudWxsO1xuICAgICAgICBjb25zdCBjaGVja0N0eCA9IHtcbiAgICAgICAgICAgIGFkZElzc3VlOiAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCBhcmcpO1xuICAgICAgICAgICAgICAgIGlmIChhcmcuZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5wYXRoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY2hlY2tDdHguYWRkSXNzdWUgPSBjaGVja0N0eC5hZGRJc3N1ZS5iaW5kKGNoZWNrQ3R4KTtcbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInByZXByb2Nlc3NcIikge1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gZWZmZWN0LnRyYW5zZm9ybShjdHguZGF0YSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHByb2Nlc3NlZCkudGhlbihhc3luYyAocHJvY2Vzc2VkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJyZWZpbmVtZW50XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4ZWN1dGVSZWZpbmVtZW50ID0gKGFjYykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC5yZWZpbmVtZW50KGFjYywgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgcmVmaW5lbWVudCBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5uZXIgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIC8vIHJldHVybiB2YWx1ZSBpcyBpZ25vcmVkXG4gICAgICAgICAgICAgICAgZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChpbm5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5uZXIudmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInRyYW5zZm9ybVwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQXN5bmNocm9ub3VzIHRyYW5zZm9ybSBlbmNvdW50ZXJlZCBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2Ugb3BlcmF0aW9uLiBVc2UgLnBhcnNlQXN5bmMgaW5zdGVhZC5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiByZXN1bHQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KS50aGVuKChiYXNlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVmZmVjdC50cmFuc2Zvcm0oYmFzZS52YWx1ZSwgY2hlY2tDdHgpKS50aGVuKChyZXN1bHQpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IHN0YXR1cy52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGVmZmVjdCk7XG4gICAgfVxufVxuWm9kRWZmZWN0cy5jcmVhdGUgPSAoc2NoZW1hLCBlZmZlY3QsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICBlZmZlY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzID0gKHByZXByb2Nlc3MsIHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJwcmVwcm9jZXNzXCIsIHRyYW5zZm9ybTogcHJlcHJvY2VzcyB9LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgeyBab2RFZmZlY3RzIGFzIFpvZFRyYW5zZm9ybWVyIH07XG5leHBvcnQgY2xhc3MgWm9kT3B0aW9uYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyh1bmRlZmluZWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kT3B0aW9uYWwuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT3B0aW9uYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTnVsbGFibGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2ROdWxsYWJsZS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsYWJsZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2REZWZhdWx0IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBsZXQgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkYXRhID0gdGhpcy5fZGVmLmRlZmF1bHRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlbW92ZURlZmF1bHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZERlZmF1bHQuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICBkZWZhdWx0VmFsdWU6IHR5cGVvZiBwYXJhbXMuZGVmYXVsdCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmRlZmF1bHQgOiAoKSA9PiBwYXJhbXMuZGVmYXVsdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RDYXRjaCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgLy8gbmV3Q3R4IGlzIHVzZWQgdG8gbm90IGNvbGxlY3QgaXNzdWVzIGZyb20gaW5uZXIgdHlwZXMgaW4gY3R4XG4gICAgICAgIGNvbnN0IG5ld0N0eCA9IHtcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGE6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgcGF0aDogbmV3Q3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IHtcbiAgICAgICAgICAgICAgICAuLi5uZXdDdHgsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgPyByZXN1bHQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBab2RFcnJvcihuZXdDdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlQ2F0Y2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZENhdGNoLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICBjYXRjaFZhbHVlOiB0eXBlb2YgcGFyYW1zLmNhdGNoID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuY2F0Y2ggOiAoKSA9PiBwYXJhbXMuY2F0Y2gsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmFOIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubmFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5hbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbn1cblpvZE5hTi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYU4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5hTixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCBCUkFORCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmV4cG9ydCBjbGFzcyBab2RCcmFuZGVkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kUGlwZWxpbmUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLmluLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkoaW5SZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUFzeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IHRoaXMuX2RlZi5pbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXM6IFwiZGlydHlcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RQaXBlbGluZSh7XG4gICAgICAgICAgICBpbjogYSxcbiAgICAgICAgICAgIG91dDogYixcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUGlwZWxpbmUsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RSZWFkb25seSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGNvbnN0IGZyZWV6ZSA9IChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZChkYXRhKSkge1xuICAgICAgICAgICAgICAgIGRhdGEudmFsdWUgPSBPYmplY3QuZnJlZXplKGRhdGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc0FzeW5jKHJlc3VsdCkgPyByZXN1bHQudGhlbigoZGF0YSkgPT4gZnJlZXplKGRhdGEpKSA6IGZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZFJlYWRvbmx5LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlYWRvbmx5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIHouY3VzdG9tICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gY2xlYW5QYXJhbXMocGFyYW1zLCBkYXRhKSB7XG4gICAgY29uc3QgcCA9IHR5cGVvZiBwYXJhbXMgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhkYXRhKSA6IHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHBhcmFtcyB9IDogcGFyYW1zO1xuICAgIGNvbnN0IHAyID0gdHlwZW9mIHAgPT09IFwic3RyaW5nXCIgPyB7IG1lc3NhZ2U6IHAgfSA6IHA7XG4gICAgcmV0dXJuIHAyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbShjaGVjaywgX3BhcmFtcyA9IHt9LCBcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBQYXNzIGBmYXRhbGAgaW50byB0aGUgcGFyYW1zIG9iamVjdCBpbnN0ZWFkOlxuICpcbiAqIGBgYHRzXG4gKiB6LnN0cmluZygpLmN1c3RvbSgodmFsKSA9PiB2YWwubGVuZ3RoID4gNSwgeyBmYXRhbDogZmFsc2UgfSlcbiAqIGBgYFxuICpcbiAqL1xuZmF0YWwpIHtcbiAgICBpZiAoY2hlY2spXG4gICAgICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCkuc3VwZXJSZWZpbmUoKGRhdGEsIGN0eCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgciA9IGNoZWNrKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IGNsZWFuUGFyYW1zKF9wYXJhbXMsIGRhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKTtcbn1cbmV4cG9ydCB7IFpvZFR5cGUgYXMgU2NoZW1hLCBab2RUeXBlIGFzIFpvZFNjaGVtYSB9O1xuZXhwb3J0IGNvbnN0IGxhdGUgPSB7XG4gICAgb2JqZWN0OiBab2RPYmplY3QubGF6eWNyZWF0ZSxcbn07XG5leHBvcnQgdmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3RyaW5nXCJdID0gXCJab2RTdHJpbmdcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdW1iZXJcIl0gPSBcIlpvZE51bWJlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hTlwiXSA9IFwiWm9kTmFOXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQmlnSW50XCJdID0gXCJab2RCaWdJbnRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCb29sZWFuXCJdID0gXCJab2RCb29sZWFuXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGF0ZVwiXSA9IFwiWm9kRGF0ZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN5bWJvbFwiXSA9IFwiWm9kU3ltYm9sXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5kZWZpbmVkXCJdID0gXCJab2RVbmRlZmluZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsXCJdID0gXCJab2ROdWxsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQW55XCJdID0gXCJab2RBbnlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmtub3duXCJdID0gXCJab2RVbmtub3duXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmV2ZXJcIl0gPSBcIlpvZE5ldmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVm9pZFwiXSA9IFwiWm9kVm9pZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFycmF5XCJdID0gXCJab2RBcnJheVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9iamVjdFwiXSA9IFwiWm9kT2JqZWN0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5pb25cIl0gPSBcIlpvZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCJdID0gXCJab2REaXNjcmltaW5hdGVkVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RJbnRlcnNlY3Rpb25cIl0gPSBcIlpvZEludGVyc2VjdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFR1cGxlXCJdID0gXCJab2RUdXBsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlY29yZFwiXSA9IFwiWm9kUmVjb3JkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTWFwXCJdID0gXCJab2RNYXBcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTZXRcIl0gPSBcIlpvZFNldFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEZ1bmN0aW9uXCJdID0gXCJab2RGdW5jdGlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExhenlcIl0gPSBcIlpvZExhenlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMaXRlcmFsXCJdID0gXCJab2RMaXRlcmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRW51bVwiXSA9IFwiWm9kRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVmZmVjdHNcIl0gPSBcIlpvZEVmZmVjdHNcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYXRpdmVFbnVtXCJdID0gXCJab2ROYXRpdmVFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT3B0aW9uYWxcIl0gPSBcIlpvZE9wdGlvbmFsXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbGFibGVcIl0gPSBcIlpvZE51bGxhYmxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRGVmYXVsdFwiXSA9IFwiWm9kRGVmYXVsdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZENhdGNoXCJdID0gXCJab2RDYXRjaFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFByb21pc2VcIl0gPSBcIlpvZFByb21pc2VcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCcmFuZGVkXCJdID0gXCJab2RCcmFuZGVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUGlwZWxpbmVcIl0gPSBcIlpvZFBpcGVsaW5lXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVhZG9ubHlcIl0gPSBcIlpvZFJlYWRvbmx5XCI7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG4vLyByZXF1aXJlcyBUUyA0LjQrXG5jbGFzcyBDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoLi4uXykgeyB9XG59XG5jb25zdCBpbnN0YW5jZU9mVHlwZSA9IChcbi8vIGNvbnN0IGluc3RhbmNlT2ZUeXBlID0gPFQgZXh0ZW5kcyBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBhbnk+KFxuY2xzLCBwYXJhbXMgPSB7XG4gICAgbWVzc2FnZTogYElucHV0IG5vdCBpbnN0YW5jZSBvZiAke2Nscy5uYW1lfWAsXG59KSA9PiBjdXN0b20oKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsIHBhcmFtcyk7XG5jb25zdCBzdHJpbmdUeXBlID0gWm9kU3RyaW5nLmNyZWF0ZTtcbmNvbnN0IG51bWJlclR5cGUgPSBab2ROdW1iZXIuY3JlYXRlO1xuY29uc3QgbmFuVHlwZSA9IFpvZE5hTi5jcmVhdGU7XG5jb25zdCBiaWdJbnRUeXBlID0gWm9kQmlnSW50LmNyZWF0ZTtcbmNvbnN0IGJvb2xlYW5UeXBlID0gWm9kQm9vbGVhbi5jcmVhdGU7XG5jb25zdCBkYXRlVHlwZSA9IFpvZERhdGUuY3JlYXRlO1xuY29uc3Qgc3ltYm9sVHlwZSA9IFpvZFN5bWJvbC5jcmVhdGU7XG5jb25zdCB1bmRlZmluZWRUeXBlID0gWm9kVW5kZWZpbmVkLmNyZWF0ZTtcbmNvbnN0IG51bGxUeXBlID0gWm9kTnVsbC5jcmVhdGU7XG5jb25zdCBhbnlUeXBlID0gWm9kQW55LmNyZWF0ZTtcbmNvbnN0IHVua25vd25UeXBlID0gWm9kVW5rbm93bi5jcmVhdGU7XG5jb25zdCBuZXZlclR5cGUgPSBab2ROZXZlci5jcmVhdGU7XG5jb25zdCB2b2lkVHlwZSA9IFpvZFZvaWQuY3JlYXRlO1xuY29uc3QgYXJyYXlUeXBlID0gWm9kQXJyYXkuY3JlYXRlO1xuY29uc3Qgb2JqZWN0VHlwZSA9IFpvZE9iamVjdC5jcmVhdGU7XG5jb25zdCBzdHJpY3RPYmplY3RUeXBlID0gWm9kT2JqZWN0LnN0cmljdENyZWF0ZTtcbmNvbnN0IHVuaW9uVHlwZSA9IFpvZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgPSBab2REaXNjcmltaW5hdGVkVW5pb24uY3JlYXRlO1xuY29uc3QgaW50ZXJzZWN0aW9uVHlwZSA9IFpvZEludGVyc2VjdGlvbi5jcmVhdGU7XG5jb25zdCB0dXBsZVR5cGUgPSBab2RUdXBsZS5jcmVhdGU7XG5jb25zdCByZWNvcmRUeXBlID0gWm9kUmVjb3JkLmNyZWF0ZTtcbmNvbnN0IG1hcFR5cGUgPSBab2RNYXAuY3JlYXRlO1xuY29uc3Qgc2V0VHlwZSA9IFpvZFNldC5jcmVhdGU7XG5jb25zdCBmdW5jdGlvblR5cGUgPSBab2RGdW5jdGlvbi5jcmVhdGU7XG5jb25zdCBsYXp5VHlwZSA9IFpvZExhenkuY3JlYXRlO1xuY29uc3QgbGl0ZXJhbFR5cGUgPSBab2RMaXRlcmFsLmNyZWF0ZTtcbmNvbnN0IGVudW1UeXBlID0gWm9kRW51bS5jcmVhdGU7XG5jb25zdCBuYXRpdmVFbnVtVHlwZSA9IFpvZE5hdGl2ZUVudW0uY3JlYXRlO1xuY29uc3QgcHJvbWlzZVR5cGUgPSBab2RQcm9taXNlLmNyZWF0ZTtcbmNvbnN0IGVmZmVjdHNUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGU7XG5jb25zdCBvcHRpb25hbFR5cGUgPSBab2RPcHRpb25hbC5jcmVhdGU7XG5jb25zdCBudWxsYWJsZVR5cGUgPSBab2ROdWxsYWJsZS5jcmVhdGU7XG5jb25zdCBwcmVwcm9jZXNzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3M7XG5jb25zdCBwaXBlbGluZVR5cGUgPSBab2RQaXBlbGluZS5jcmVhdGU7XG5jb25zdCBvc3RyaW5nID0gKCkgPT4gc3RyaW5nVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvbnVtYmVyID0gKCkgPT4gbnVtYmVyVHlwZSgpLm9wdGlvbmFsKCk7XG5jb25zdCBvYm9vbGVhbiA9ICgpID0+IGJvb2xlYW5UeXBlKCkub3B0aW9uYWwoKTtcbmV4cG9ydCBjb25zdCBjb2VyY2UgPSB7XG4gICAgc3RyaW5nOiAoKGFyZykgPT4gWm9kU3RyaW5nLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBudW1iZXI6ICgoYXJnKSA9PiBab2ROdW1iZXIuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGJvb2xlYW46ICgoYXJnKSA9PiBab2RCb29sZWFuLmNyZWF0ZSh7XG4gICAgICAgIC4uLmFyZyxcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgIH0pKSxcbiAgICBiaWdpbnQ6ICgoYXJnKSA9PiBab2RCaWdJbnQuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIGRhdGU6ICgoYXJnKSA9PiBab2REYXRlLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbn07XG5leHBvcnQgeyBhbnlUeXBlIGFzIGFueSwgYXJyYXlUeXBlIGFzIGFycmF5LCBiaWdJbnRUeXBlIGFzIGJpZ2ludCwgYm9vbGVhblR5cGUgYXMgYm9vbGVhbiwgZGF0ZVR5cGUgYXMgZGF0ZSwgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSBhcyBkaXNjcmltaW5hdGVkVW5pb24sIGVmZmVjdHNUeXBlIGFzIGVmZmVjdCwgZW51bVR5cGUgYXMgZW51bSwgZnVuY3Rpb25UeXBlIGFzIGZ1bmN0aW9uLCBpbnN0YW5jZU9mVHlwZSBhcyBpbnN0YW5jZW9mLCBpbnRlcnNlY3Rpb25UeXBlIGFzIGludGVyc2VjdGlvbiwgbGF6eVR5cGUgYXMgbGF6eSwgbGl0ZXJhbFR5cGUgYXMgbGl0ZXJhbCwgbWFwVHlwZSBhcyBtYXAsIG5hblR5cGUgYXMgbmFuLCBuYXRpdmVFbnVtVHlwZSBhcyBuYXRpdmVFbnVtLCBuZXZlclR5cGUgYXMgbmV2ZXIsIG51bGxUeXBlIGFzIG51bGwsIG51bGxhYmxlVHlwZSBhcyBudWxsYWJsZSwgbnVtYmVyVHlwZSBhcyBudW1iZXIsIG9iamVjdFR5cGUgYXMgb2JqZWN0LCBvYm9vbGVhbiwgb251bWJlciwgb3B0aW9uYWxUeXBlIGFzIG9wdGlvbmFsLCBvc3RyaW5nLCBwaXBlbGluZVR5cGUgYXMgcGlwZWxpbmUsIHByZXByb2Nlc3NUeXBlIGFzIHByZXByb2Nlc3MsIHByb21pc2VUeXBlIGFzIHByb21pc2UsIHJlY29yZFR5cGUgYXMgcmVjb3JkLCBzZXRUeXBlIGFzIHNldCwgc3RyaWN0T2JqZWN0VHlwZSBhcyBzdHJpY3RPYmplY3QsIHN0cmluZ1R5cGUgYXMgc3RyaW5nLCBzeW1ib2xUeXBlIGFzIHN5bWJvbCwgZWZmZWN0c1R5cGUgYXMgdHJhbnNmb3JtZXIsIHR1cGxlVHlwZSBhcyB0dXBsZSwgdW5kZWZpbmVkVHlwZSBhcyB1bmRlZmluZWQsIHVuaW9uVHlwZSBhcyB1bmlvbiwgdW5rbm93blR5cGUgYXMgdW5rbm93biwgdm9pZFR5cGUgYXMgdm9pZCwgfTtcbmV4cG9ydCBjb25zdCBORVZFUiA9IElOVkFMSUQ7XG4iLCAiLyoqIEEgc3BlY2lhbCBjb25zdGFudCB3aXRoIHR5cGUgYG5ldmVyYCAqL1xuZXhwb3J0IGNvbnN0IE5FVkVSID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuZXhwb3J0IC8qQF9fTk9fU0lERV9FRkZFQ1RTX18qLyBmdW5jdGlvbiAkY29uc3RydWN0b3IobmFtZSwgaW5pdGlhbGl6ZXIsIHBhcmFtcykge1xuICAgIGZ1bmN0aW9uIGluaXQoaW5zdCwgZGVmKSB7XG4gICAgICAgIGlmICghaW5zdC5fem9kKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfem9kXCIsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgICBkZWYsXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0cjogXyxcbiAgICAgICAgICAgICAgICAgICAgdHJhaXRzOiBuZXcgU2V0KCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnN0Ll96b2QudHJhaXRzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGluc3QuX3pvZC50cmFpdHMuYWRkKG5hbWUpO1xuICAgICAgICBpbml0aWFsaXplcihpbnN0LCBkZWYpO1xuICAgICAgICAvLyBzdXBwb3J0IHByb3RvdHlwZSBtb2RpZmljYXRpb25zXG4gICAgICAgIGNvbnN0IHByb3RvID0gXy5wcm90b3R5cGU7XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm90byk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgayA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoIShrIGluIGluc3QpKSB7XG4gICAgICAgICAgICAgICAgaW5zdFtrXSA9IHByb3RvW2tdLmJpbmQoaW5zdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZG9lc24ndCB3b3JrIGlmIFBhcmVudCBoYXMgYSBjb25zdHJ1Y3RvciB3aXRoIGFyZ3VtZW50c1xuICAgIGNvbnN0IFBhcmVudCA9IHBhcmFtcz8uUGFyZW50ID8/IE9iamVjdDtcbiAgICBjbGFzcyBEZWZpbml0aW9uIGV4dGVuZHMgUGFyZW50IHtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmluaXRpb24sIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pO1xuICAgIGZ1bmN0aW9uIF8oZGVmKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgaW5zdCA9IHBhcmFtcz8uUGFyZW50ID8gbmV3IERlZmluaXRpb24oKSA6IHRoaXM7XG4gICAgICAgIGluaXQoaW5zdCwgZGVmKTtcbiAgICAgICAgKF9hID0gaW5zdC5fem9kKS5kZWZlcnJlZCA/PyAoX2EuZGVmZXJyZWQgPSBbXSk7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgaW5zdC5fem9kLmRlZmVycmVkKSB7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnN0O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgXCJpbml0XCIsIHsgdmFsdWU6IGluaXQgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgICAgICB2YWx1ZTogKGluc3QpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbXM/LlBhcmVudCAmJiBpbnN0IGluc3RhbmNlb2YgcGFyYW1zLlBhcmVudClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBpbnN0Py5fem9kPy50cmFpdHM/LmhhcyhuYW1lKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG4gICAgcmV0dXJuIF87XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICBVVElMSVRJRVMgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBjb25zdCAkYnJhbmQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5leHBvcnQgY2xhc3MgJFpvZEFzeW5jRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKGBFbmNvdW50ZXJlZCBQcm9taXNlIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZS4gVXNlIC5wYXJzZUFzeW5jKCkgaW5zdGVhZC5gKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgJFpvZEVuY29kZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICAgICAgc3VwZXIoYEVuY291bnRlcmVkIHVuaWRpcmVjdGlvbmFsIHRyYW5zZm9ybSBkdXJpbmcgZW5jb2RlOiAke25hbWV9YCk7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiWm9kRW5jb2RlRXJyb3JcIjtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZ2xvYmFsQ29uZmlnID0ge307XG5leHBvcnQgZnVuY3Rpb24gY29uZmlnKG5ld0NvbmZpZykge1xuICAgIGlmIChuZXdDb25maWcpXG4gICAgICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsQ29uZmlnLCBuZXdDb25maWcpO1xuICAgIHJldHVybiBnbG9iYWxDb25maWc7XG59XG4iLCAiLy8gZnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0RXF1YWwodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROb3RFcXVhbCh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCB2YWx1ZSBpbiBleGhhdXN0aXZlIGNoZWNrXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydChfKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbnVtVmFsdWVzKGVudHJpZXMpIHtcbiAgICBjb25zdCBudW1lcmljVmFsdWVzID0gT2JqZWN0LnZhbHVlcyhlbnRyaWVzKS5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKTtcbiAgICBjb25zdCB2YWx1ZXMgPSBPYmplY3QuZW50cmllcyhlbnRyaWVzKVxuICAgICAgICAuZmlsdGVyKChbaywgX10pID0+IG51bWVyaWNWYWx1ZXMuaW5kZXhPZigraykgPT09IC0xKVxuICAgICAgICAubWFwKChbXywgdl0pID0+IHYpO1xuICAgIHJldHVybiB2YWx1ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCJ8XCIpIHtcbiAgICByZXR1cm4gYXJyYXkubWFwKCh2YWwpID0+IHN0cmluZ2lmeVByaW1pdGl2ZSh2YWwpKS5qb2luKHNlcGFyYXRvcik7XG59XG5leHBvcnQgZnVuY3Rpb24ganNvblN0cmluZ2lmeVJlcGxhY2VyKF8sIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNhY2hlZChnZXR0ZXIpIHtcbiAgICBjb25zdCBzZXQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgdmFsdWUoKSB7XG4gICAgICAgICAgICBpZiAoIXNldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwidmFsdWVcIiwgeyB2YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWQgdmFsdWUgYWxyZWFkeSBzZXRcIik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudWxsaXNoKGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYW5SZWdleChzb3VyY2UpIHtcbiAgICBjb25zdCBzdGFydCA9IHNvdXJjZS5zdGFydHNXaXRoKFwiXlwiKSA/IDEgOiAwO1xuICAgIGNvbnN0IGVuZCA9IHNvdXJjZS5lbmRzV2l0aChcIiRcIikgPyBzb3VyY2UubGVuZ3RoIC0gMSA6IHNvdXJjZS5sZW5ndGg7XG4gICAgcmV0dXJuIHNvdXJjZS5zbGljZShzdGFydCwgZW5kKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmbG9hdFNhZmVSZW1haW5kZXIodmFsLCBzdGVwKSB7XG4gICAgY29uc3QgdmFsRGVjQ291bnQgPSAodmFsLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBzdGVwU3RyaW5nID0gc3RlcC50b1N0cmluZygpO1xuICAgIGxldCBzdGVwRGVjQ291bnQgPSAoc3RlcFN0cmluZy5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGlmIChzdGVwRGVjQ291bnQgPT09IDAgJiYgL1xcZD9lLVxcZD8vLnRlc3Qoc3RlcFN0cmluZykpIHtcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBzdGVwU3RyaW5nLm1hdGNoKC9cXGQ/ZS0oXFxkPykvKTtcbiAgICAgICAgaWYgKG1hdGNoPy5bMV0pIHtcbiAgICAgICAgICAgIHN0ZXBEZWNDb3VudCA9IE51bWJlci5wYXJzZUludChtYXRjaFsxXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVjQ291bnQgPSB2YWxEZWNDb3VudCA+IHN0ZXBEZWNDb3VudCA/IHZhbERlY0NvdW50IDogc3RlcERlY0NvdW50O1xuICAgIGNvbnN0IHZhbEludCA9IE51bWJlci5wYXJzZUludCh2YWwudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIGNvbnN0IHN0ZXBJbnQgPSBOdW1iZXIucGFyc2VJbnQoc3RlcC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgcmV0dXJuICh2YWxJbnQgJSBzdGVwSW50KSAvIDEwICoqIGRlY0NvdW50O1xufVxuY29uc3QgRVZBTFVBVElORyA9IFN5bWJvbChcImV2YWx1YXRpbmdcIik7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lTGF6eShvYmplY3QsIGtleSwgZ2V0dGVyKSB7XG4gICAgbGV0IHZhbHVlID0gdW5kZWZpbmVkO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IEVWQUxVQVRJTkcpIHtcbiAgICAgICAgICAgICAgICAvLyBDaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0ZWQsIHJldHVybiB1bmRlZmluZWQgdG8gYnJlYWsgdGhlIGN5Y2xlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBFVkFMVUFUSU5HO1xuICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0dGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH0sXG4gICAgICAgIHNldCh2KSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdixcbiAgICAgICAgICAgICAgICAvLyBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIG9iamVjdFtrZXldID0gdjtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdENsb25lKG9iaikge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmopKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25Qcm9wKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlRGVmcyguLi5kZWZzKSB7XG4gICAgY29uc3QgbWVyZ2VkRGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZzKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3JzID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoZGVmKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihtZXJnZWREZXNjcmlwdG9ycywgZGVzY3JpcHRvcnMpO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoe30sIG1lcmdlZERlc2NyaXB0b3JzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZURlZihzY2hlbWEpIHtcbiAgICByZXR1cm4gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RWxlbWVudEF0UGF0aChvYmosIHBhdGgpIHtcbiAgICBpZiAoIXBhdGgpXG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIHBhdGgucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjPy5ba2V5XSwgb2JqKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlQWxsT2JqZWN0KHByb21pc2VzT2JqKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb21pc2VzT2JqKTtcbiAgICBjb25zdCBwcm9taXNlcyA9IGtleXMubWFwKChrZXkpID0+IHByb21pc2VzT2JqW2tleV0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICBjb25zdCByZXNvbHZlZE9iaiA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc29sdmVkT2JqW2tleXNbaV1dID0gcmVzdWx0c1tpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzb2x2ZWRPYmo7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tU3RyaW5nKGxlbmd0aCA9IDEwKSB7XG4gICAgY29uc3QgY2hhcnMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCI7XG4gICAgbGV0IHN0ciA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBzdHIgKz0gY2hhcnNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKV07XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5leHBvcnQgZnVuY3Rpb24gZXNjKHN0cikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNsdWdpZnkoaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXRcbiAgICAgICAgLnRvTG93ZXJDYXNlKClcbiAgICAgICAgLnRyaW0oKVxuICAgICAgICAucmVwbGFjZSgvW15cXHdcXHMtXS9nLCBcIlwiKVxuICAgICAgICAucmVwbGFjZSgvW1xcc18tXSsvZywgXCItXCIpXG4gICAgICAgIC5yZXBsYWNlKC9eLSt8LSskL2csIFwiXCIpO1xufVxuZXhwb3J0IGNvbnN0IGNhcHR1cmVTdGFja1RyYWNlID0gKFwiY2FwdHVyZVN0YWNrVHJhY2VcIiBpbiBFcnJvciA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlIDogKC4uLl9hcmdzKSA9PiB7IH0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KGRhdGEpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgZGF0YSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShkYXRhKTtcbn1cbmV4cG9ydCBjb25zdCBhbGxvd3NFdmFsID0gY2FjaGVkKCgpID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluY2x1ZGVzKFwiQ2xvdWRmbGFyZVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IEYgPSBGdW5jdGlvbjtcbiAgICAgICAgbmV3IEYoXCJcIik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoXykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSk7XG5leHBvcnQgZnVuY3Rpb24gaXNQbGFpbk9iamVjdChvKSB7XG4gICAgaWYgKGlzT2JqZWN0KG8pID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIG1vZGlmaWVkIGNvbnN0cnVjdG9yXG4gICAgY29uc3QgY3RvciA9IG8uY29uc3RydWN0b3I7XG4gICAgaWYgKGN0b3IgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiBjdG9yICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIC8vIG1vZGlmaWVkIHByb3RvdHlwZVxuICAgIGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcbiAgICBpZiAoaXNPYmplY3QocHJvdCkgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gY3RvciBkb2Vzbid0IGhhdmUgc3RhdGljIGBpc1Byb3RvdHlwZU9mYFxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvdCwgXCJpc1Byb3RvdHlwZU9mXCIpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvKSB7XG4gICAgaWYgKGlzUGxhaW5PYmplY3QobykpXG4gICAgICAgIHJldHVybiB7IC4uLm8gfTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSlcbiAgICAgICAgcmV0dXJuIFsuLi5vXTtcbiAgICByZXR1cm4gbztcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1LZXlzKGRhdGEpIHtcbiAgICBsZXQga2V5Q291bnQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBrZXkpKSB7XG4gICAgICAgICAgICBrZXlDb3VudCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlDb3VudDtcbn1cbmV4cG9ydCBjb25zdCBnZXRQYXJzZWRUeXBlID0gKGRhdGEpID0+IHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICAgIHJldHVybiBcInVuZGVmaW5lZFwiO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFwibmFuXCIgOiBcIm51bWJlclwiO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBcImZ1bmN0aW9uXCI7XG4gICAgICAgIGNhc2UgXCJiaWdpbnRcIjpcbiAgICAgICAgICAgIHJldHVybiBcImJpZ2ludFwiO1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJzeW1ib2xcIjtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJwcm9taXNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibWFwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIFNldCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwic2V0XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJkYXRlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBpZiAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIEZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJmaWxlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gXCJvYmplY3RcIjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBkYXRhIHR5cGU6ICR7dH1gKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHByb3BlcnR5S2V5VHlwZXMgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcInN5bWJvbFwiXSk7XG5leHBvcnQgY29uc3QgcHJpbWl0aXZlVHlwZXMgPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImJpZ2ludFwiLCBcImJvb2xlYW5cIiwgXCJzeW1ib2xcIiwgXCJ1bmRlZmluZWRcIl0pO1xuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuLy8gem9kLXNwZWNpZmljIHV0aWxzXG5leHBvcnQgZnVuY3Rpb24gY2xvbmUoaW5zdCwgZGVmLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjbCA9IG5ldyBpbnN0Ll96b2QuY29uc3RyKGRlZiA/PyBpbnN0Ll96b2QuZGVmKTtcbiAgICBpZiAoIWRlZiB8fCBwYXJhbXM/LnBhcmVudClcbiAgICAgICAgY2wuX3pvZC5wYXJlbnQgPSBpbnN0O1xuICAgIHJldHVybiBjbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVQYXJhbXMoX3BhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IF9wYXJhbXM7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHsgZXJyb3I6ICgpID0+IHBhcmFtcyB9O1xuICAgIGlmIChwYXJhbXM/Lm1lc3NhZ2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAocGFyYW1zPy5lcnJvciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHNwZWNpZnkgYm90aCBgbWVzc2FnZWAgYW5kIGBlcnJvcmAgcGFyYW1zXCIpO1xuICAgICAgICBwYXJhbXMuZXJyb3IgPSBwYXJhbXMubWVzc2FnZTtcbiAgICB9XG4gICAgZGVsZXRlIHBhcmFtcy5tZXNzYWdlO1xuICAgIGlmICh0eXBlb2YgcGFyYW1zLmVycm9yID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4geyAuLi5wYXJhbXMsIGVycm9yOiAoKSA9PiBwYXJhbXMuZXJyb3IgfTtcbiAgICByZXR1cm4gcGFyYW1zO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRyYW5zcGFyZW50UHJveHkoZ2V0dGVyKSB7XG4gICAgbGV0IHRhcmdldDtcbiAgICByZXR1cm4gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgIGdldChfLCBwcm9wLCByZWNlaXZlcikge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXQodGFyZ2V0LCBwcm9wLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIHNldChfLCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Quc2V0KHRhcmdldCwgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgaGFzKF8sIHByb3ApIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuaGFzKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVByb3BlcnR5KF8sIHByb3ApIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgb3duS2V5cyhfKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lm93bktleXModGFyZ2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKF8sIHByb3ApIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZVByb3BlcnR5KF8sIHByb3AsIGRlc2NyaXB0b3IpIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCBkZXNjcmlwdG9yKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdpZnlQcmltaXRpdmUodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKSArIFwiblwiO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBgXCIke3ZhbHVlfVwiYDtcbiAgICByZXR1cm4gYCR7dmFsdWV9YDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbEtleXMoc2hhcGUpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXMoc2hhcGUpLmZpbHRlcigoaykgPT4ge1xuICAgICAgICByZXR1cm4gc2hhcGVba10uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiICYmIHNoYXBlW2tdLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgTlVNQkVSX0ZPUk1BVF9SQU5HRVMgPSB7XG4gICAgc2FmZWludDogW051bWJlci5NSU5fU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUl0sXG4gICAgaW50MzI6IFstMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0N10sXG4gICAgdWludDMyOiBbMCwgNDI5NDk2NzI5NV0sXG4gICAgZmxvYXQzMjogWy0zLjQwMjgyMzQ2NjM4NTI4ODZlMzgsIDMuNDAyODIzNDY2Mzg1Mjg4NmUzOF0sXG4gICAgZmxvYXQ2NDogWy1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFXSxcbn07XG5leHBvcnQgY29uc3QgQklHSU5UX0ZPUk1BVF9SQU5HRVMgPSB7XG4gICAgaW50NjQ6IFsvKiBAX19QVVJFX18qLyBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSwgLyogQF9fUFVSRV9fKi8gQmlnSW50KFwiOTIyMzM3MjAzNjg1NDc3NTgwN1wiKV0sXG4gICAgdWludDY0OiBbLyogQF9fUFVSRV9fKi8gQmlnSW50KDApLCAvKiBAX19QVVJFX18qLyBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKV0sXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2soc2NoZW1hLCBtYXNrKSB7XG4gICAgY29uc3QgY3VyckRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBjaGVja3MgPSBjdXJyRGVmLmNoZWNrcztcbiAgICBjb25zdCBoYXNDaGVja3MgPSBjaGVja3MgJiYgY2hlY2tzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGhhc0NoZWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIucGljaygpIGNhbm5vdCBiZSB1c2VkIG9uIG9iamVjdCBzY2hlbWFzIGNvbnRhaW5pbmcgcmVmaW5lbWVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gY3VyckRlZi5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIG5ld1NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gbmV3U2hhcGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvbWl0KHNjaGVtYSwgbWFzaykge1xuICAgIGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgY2hlY2tzID0gY3VyckRlZi5jaGVja3M7XG4gICAgY29uc3QgaGFzQ2hlY2tzID0gY2hlY2tzICYmIGNoZWNrcy5sZW5ndGggPiAwO1xuICAgIGlmIChoYXNDaGVja3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiLm9taXQoKSBjYW5ub3QgYmUgdXNlZCBvbiBvYmplY3Qgc2NoZW1hcyBjb250YWluaW5nIHJlZmluZW1lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3U2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBuZXdTaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NoYXBlO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja3M6IFtdLFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kKHNjaGVtYSwgc2hhcGUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc2hhcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gZXh0ZW5kOiBleHBlY3RlZCBhIHBsYWluIG9iamVjdFwiKTtcbiAgICB9XG4gICAgY29uc3QgY2hlY2tzID0gc2NoZW1hLl96b2QuZGVmLmNoZWNrcztcbiAgICBjb25zdCBoYXNDaGVja3MgPSBjaGVja3MgJiYgY2hlY2tzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGhhc0NoZWNrcykge1xuICAgICAgICAvLyBPbmx5IHRocm93IGlmIG5ldyBzaGFwZSBvdmVybGFwcyB3aXRoIGV4aXN0aW5nIHNoYXBlXG4gICAgICAgIC8vIFVzZSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgdG8gY2hlY2sga2V5IGV4aXN0ZW5jZSB3aXRob3V0IGFjY2Vzc2luZyB2YWx1ZXNcbiAgICAgICAgY29uc3QgZXhpc3RpbmdTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGV4aXN0aW5nU2hhcGUsIGtleSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBvdmVyd3JpdGUga2V5cyBvbiBvYmplY3Qgc2NoZW1hcyBjb250YWluaW5nIHJlZmluZW1lbnRzLiBVc2UgYC5zYWZlRXh0ZW5kKClgIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUsIC4uLnNoYXBlIH07XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gX3NoYXBlO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2FmZUV4dGVuZChzY2hlbWEsIHNoYXBlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHNoYXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIHNhZmVFeHRlbmQ6IGV4cGVjdGVkIGEgcGxhaW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlLCAuLi5zaGFwZSB9O1xuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIF9zaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIF9zaGFwZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlKGEsIGIpIHtcbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBfc2hhcGUgPSB7IC4uLmEuX3pvZC5kZWYuc2hhcGUsIC4uLmIuX3pvZC5kZWYuc2hhcGUgfTtcbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgICAgIH0sXG4gICAgICAgIGdldCBjYXRjaGFsbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBiLl96b2QuZGVmLmNhdGNoYWxsO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja3M6IFtdLCAvLyBkZWxldGUgZXhpc3RpbmcgY2hlY2tzXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKGEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbChDbGFzcywgc2NoZW1hLCBtYXNrKSB7XG4gICAgY29uc3QgY3VyckRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBjaGVja3MgPSBjdXJyRGVmLmNoZWNrcztcbiAgICBjb25zdCBoYXNDaGVja3MgPSBjaGVja3MgJiYgY2hlY2tzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGhhc0NoZWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIucGFydGlhbCgpIGNhbm5vdCBiZSB1c2VkIG9uIG9iamVjdCBzY2hlbWFzIGNvbnRhaW5pbmcgcmVmaW5lbWVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkU2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcbiAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gb2xkU2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAob2xkU2hhcGVba2V5XSEuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IENsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkU2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKG9sZFNoYXBlW2tleV0hLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBDbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRTaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBzaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja3M6IFtdLFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZWQoQ2xhc3MsIHNjaGVtYSwgbWFzaykge1xuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkU2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcbiAgICAgICAgICAgIGlmIChtYXNrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBvdmVyd3JpdGUgd2l0aCBub24tb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IG5ldyBDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSB3aXRoIG5vbi1vcHRpb25hbFxuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gbmV3IENsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIHNoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbi8vIGludmFsaWRfdHlwZSB8IHRvb19iaWcgfCB0b29fc21hbGwgfCBpbnZhbGlkX2Zvcm1hdCB8IG5vdF9tdWx0aXBsZV9vZiB8IHVucmVjb2duaXplZF9rZXlzIHwgaW52YWxpZF91bmlvbiB8IGludmFsaWRfa2V5IHwgaW52YWxpZF9lbGVtZW50IHwgaW52YWxpZF92YWx1ZSB8IGN1c3RvbVxuZXhwb3J0IGZ1bmN0aW9uIGFib3J0ZWQoeCwgc3RhcnRJbmRleCA9IDApIHtcbiAgICBpZiAoeC5hYm9ydGVkID09PSB0cnVlKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSA8IHguaXNzdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICh4Lmlzc3Vlc1tpXT8uY29udGludWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmVmaXhJc3N1ZXMocGF0aCwgaXNzdWVzKSB7XG4gICAgcmV0dXJuIGlzc3Vlcy5tYXAoKGlzcykgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGlzcykucGF0aCA/PyAoX2EucGF0aCA9IFtdKTtcbiAgICAgICAgaXNzLnBhdGgudW5zaGlmdChwYXRoKTtcbiAgICAgICAgcmV0dXJuIGlzcztcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bndyYXBNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcpIHtcbiAgICBjb25zdCBmdWxsID0geyAuLi5pc3MsIHBhdGg6IGlzcy5wYXRoID8/IFtdIH07XG4gICAgLy8gZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgaWYgKCFpc3MubWVzc2FnZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdW53cmFwTWVzc2FnZShpc3MuaW5zdD8uX3pvZC5kZWY/LmVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIHVud3JhcE1lc3NhZ2UoY3R4Py5lcnJvcj8uKGlzcykpID8/XG4gICAgICAgICAgICB1bndyYXBNZXNzYWdlKGNvbmZpZy5jdXN0b21FcnJvcj8uKGlzcykpID8/XG4gICAgICAgICAgICB1bndyYXBNZXNzYWdlKGNvbmZpZy5sb2NhbGVFcnJvcj8uKGlzcykpID8/XG4gICAgICAgICAgICBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgZnVsbC5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgLy8gZGVsZXRlIChmdWxsIGFzIGFueSkuZGVmO1xuICAgIGRlbGV0ZSBmdWxsLmluc3Q7XG4gICAgZGVsZXRlIGZ1bGwuY29udGludWU7XG4gICAgaWYgKCFjdHg/LnJlcG9ydElucHV0KSB7XG4gICAgICAgIGRlbGV0ZSBmdWxsLmlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gZnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRTaXphYmxlT3JpZ2luKGlucHV0KSB7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgU2V0KVxuICAgICAgICByZXR1cm4gXCJzZXRcIjtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBNYXApXG4gICAgICAgIHJldHVybiBcIm1hcFwiO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICByZXR1cm4gXCJmaWxlXCI7XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpXG4gICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgcmV0dXJuIFwidW5rbm93blwiO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlZFR5cGUoZGF0YSkge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOiB7XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gXCJuYW5cIiA6IFwibnVtYmVyXCI7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9iaiA9IGRhdGE7XG4gICAgICAgICAgICBpZiAob2JqICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihvYmopICE9PSBPYmplY3QucHJvdG90eXBlICYmIFwiY29uc3RydWN0b3JcIiBpbiBvYmogJiYgb2JqLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iai5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzc3VlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbaXNzLCBpbnB1dCwgaW5zdF0gPSBhcmdzO1xuICAgIGlmICh0eXBlb2YgaXNzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBpc3MsXG4gICAgICAgICAgICBjb2RlOiBcImN1c3RvbVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyAuLi5pc3MgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhbkVudW0ob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iailcbiAgICAgICAgLmZpbHRlcigoW2ssIF9dKSA9PiB7XG4gICAgICAgIC8vIHJldHVybiB0cnVlIGlmIE5hTiwgbWVhbmluZyBpdCdzIG5vdCBhIG51bWJlciwgdGh1cyBhIHN0cmluZyBrZXlcbiAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihOdW1iZXIucGFyc2VJbnQoaywgMTApKTtcbiAgICB9KVxuICAgICAgICAubWFwKChlbCkgPT4gZWxbMV0pO1xufVxuLy8gQ29kZWMgdXRpbGl0eSBmdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0KSB7XG4gICAgY29uc3QgYmluYXJ5U3RyaW5nID0gYXRvYihiYXNlNjQpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5U3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiaW5hcnlTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYnl0ZXNbaV0gPSBiaW5hcnlTdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0Jhc2U2NChieXRlcykge1xuICAgIGxldCBiaW5hcnlTdHJpbmcgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmluYXJ5U3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gYnRvYShiaW5hcnlTdHJpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NHVybFRvVWludDhBcnJheShiYXNlNjR1cmwpIHtcbiAgICBjb25zdCBiYXNlNjQgPSBiYXNlNjR1cmwucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gICAgY29uc3QgcGFkZGluZyA9IFwiPVwiLnJlcGVhdCgoNCAtIChiYXNlNjQubGVuZ3RoICUgNCkpICUgNCk7XG4gICAgcmV0dXJuIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjQgKyBwYWRkaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9CYXNlNjR1cmwoYnl0ZXMpIHtcbiAgICByZXR1cm4gdWludDhBcnJheVRvQmFzZTY0KGJ5dGVzKS5yZXBsYWNlKC9cXCsvZywgXCItXCIpLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvPS9nLCBcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb1VpbnQ4QXJyYXkoaGV4KSB7XG4gICAgY29uc3QgY2xlYW5IZXggPSBoZXgucmVwbGFjZSgvXjB4LywgXCJcIik7XG4gICAgaWYgKGNsZWFuSGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBoZXggc3RyaW5nIGxlbmd0aFwiKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjbGVhbkhleC5sZW5ndGggLyAyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNsZWFuSGV4Lmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIGJ5dGVzW2kgLyAyXSA9IE51bWJlci5wYXJzZUludChjbGVhbkhleC5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0hleChieXRlcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGJ5dGVzKVxuICAgICAgICAubWFwKChiKSA9PiBiLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpXG4gICAgICAgIC5qb2luKFwiXCIpO1xufVxuLy8gaW5zdGFuY2VvZlxuZXhwb3J0IGNsYXNzIENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciguLi5fYXJncykgeyB9XG59XG4iLCAiaW1wb3J0IHsgJGNvbnN0cnVjdG9yIH0gZnJvbSBcIi4vY29yZS5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG5jb25zdCBpbml0aWFsaXplciA9IChpbnN0LCBkZWYpID0+IHtcbiAgICBpbnN0Lm5hbWUgPSBcIiRab2RFcnJvclwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgICAgICB2YWx1ZTogaW5zdC5fem9kLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJpc3N1ZXNcIiwge1xuICAgICAgICB2YWx1ZTogZGVmLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICBpbnN0Lm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShkZWYsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJ0b1N0cmluZ1wiLCB7XG4gICAgICAgIHZhbHVlOiAoKSA9PiBpbnN0Lm1lc3NhZ2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjb25zdCAkWm9kRXJyb3IgPSAkY29uc3RydWN0b3IoXCIkWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIpO1xuZXhwb3J0IGNvbnN0ICRab2RSZWFsRXJyb3IgPSAkY29uc3RydWN0b3IoXCIkWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIsIHsgUGFyZW50OiBFcnJvciB9KTtcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuRXJyb3IoZXJyb3IsIG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0ge307XG4gICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc3ViIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dID0gZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dIHx8IFtdO1xuICAgICAgICAgICAgZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEVycm9yKGVycm9yLCBtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIiAmJiBpc3N1ZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaXNzdWUuZXJyb3JzLm1hcCgoaXNzdWVzKSA9PiBwcm9jZXNzRXJyb3IoeyBpc3N1ZXMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2tleVwiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZS5pc3N1ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfZWxlbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZS5pc3N1ZXMgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGlzc3VlLnBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3VycltlbF07XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHByb2Nlc3NFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIGZpZWxkRXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRyZWVpZnlFcnJvcihlcnJvciwgbWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0geyBlcnJvcnM6IFtdIH07XG4gICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yLCBwYXRoID0gW10pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgZm9yIChjb25zdCBpc3N1ZSBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIiAmJiBpc3N1ZS5lcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVndWxhciB1bmlvbiBlcnJvclxuICAgICAgICAgICAgICAgIGlzc3VlLmVycm9ycy5tYXAoKGlzc3VlcykgPT4gcHJvY2Vzc0Vycm9yKHsgaXNzdWVzIH0sIGlzc3VlLnBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9rZXlcIikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUuaXNzdWVzIH0sIGlzc3VlLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2VsZW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUuaXNzdWVzIH0sIGlzc3VlLnBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnVsbHBhdGggPSBbLi4ucGF0aCwgLi4uaXNzdWUucGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQuZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBmdWxscGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBmdWxscGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBmdWxscGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyLnByb3BlcnRpZXMgPz8gKGN1cnIucHJvcGVydGllcyA9IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGN1cnIucHJvcGVydGllcylbZWxdID8/IChfYVtlbF0gPSB7IGVycm9yczogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3Vyci5wcm9wZXJ0aWVzW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIuaXRlbXMgPz8gKGN1cnIuaXRlbXMgPSBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2IgPSBjdXJyLml0ZW1zKVtlbF0gPz8gKF9iW2VsXSA9IHsgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLml0ZW1zW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIuZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcHJvY2Vzc0Vycm9yKGVycm9yKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqIEZvcm1hdCBhIFpvZEVycm9yIGFzIGEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGluIHRoZSBmb2xsb3dpbmcgZm9ybS5cbiAqXG4gKiBGcm9tXG4gKlxuICogYGBgdHNcbiAqIFpvZEVycm9yIHtcbiAqICAgaXNzdWVzOiBbXG4gKiAgICAge1xuICogICAgICAgZXhwZWN0ZWQ6ICdzdHJpbmcnLFxuICogICAgICAgY29kZTogJ2ludmFsaWRfdHlwZScsXG4gKiAgICAgICBwYXRoOiBbICd1c2VybmFtZScgXSxcbiAqICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGlucHV0OiBleHBlY3RlZCBzdHJpbmcnXG4gKiAgICAgfSxcbiAqICAgICB7XG4gKiAgICAgICBleHBlY3RlZDogJ251bWJlcicsXG4gKiAgICAgICBjb2RlOiAnaW52YWxpZF90eXBlJyxcbiAqICAgICAgIHBhdGg6IFsgJ2Zhdm9yaXRlTnVtYmVycycsIDEgXSxcbiAqICAgICAgIG1lc3NhZ2U6ICdJbnZhbGlkIGlucHV0OiBleHBlY3RlZCBudW1iZXInXG4gKiAgICAgfVxuICogICBdO1xuICogfVxuICogYGBgXG4gKlxuICogdG9cbiAqXG4gKiBgYGBcbiAqIHVzZXJuYW1lXG4gKiAgIFx1MjcxNiBFeHBlY3RlZCBudW1iZXIsIHJlY2VpdmVkIHN0cmluZyBhdCBcInVzZXJuYW1lXG4gKiBmYXZvcml0ZU51bWJlcnNbMF1cbiAqICAgXHUyNzE2IEludmFsaWQgaW5wdXQ6IGV4cGVjdGVkIG51bWJlclxuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RvdFBhdGgoX3BhdGgpIHtcbiAgICBjb25zdCBzZWdzID0gW107XG4gICAgY29uc3QgcGF0aCA9IF9wYXRoLm1hcCgoc2VnKSA9PiAodHlwZW9mIHNlZyA9PT0gXCJvYmplY3RcIiA/IHNlZy5rZXkgOiBzZWcpKTtcbiAgICBmb3IgKGNvbnN0IHNlZyBvZiBwYXRoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2VnID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgc2Vncy5wdXNoKGBbJHtzZWd9XWApO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2VnID09PSBcInN5bWJvbFwiKVxuICAgICAgICAgICAgc2Vncy5wdXNoKGBbJHtKU09OLnN0cmluZ2lmeShTdHJpbmcoc2VnKSl9XWApO1xuICAgICAgICBlbHNlIGlmICgvW15cXHckXS8udGVzdChzZWcpKVxuICAgICAgICAgICAgc2Vncy5wdXNoKGBbJHtKU09OLnN0cmluZ2lmeShzZWcpfV1gKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoc2Vncy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgc2Vncy5wdXNoKFwiLlwiKTtcbiAgICAgICAgICAgIHNlZ3MucHVzaChzZWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZWdzLmpvaW4oXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJldHRpZnlFcnJvcihlcnJvcikge1xuICAgIGNvbnN0IGxpbmVzID0gW107XG4gICAgLy8gc29ydCBieSBwYXRoIGxlbmd0aFxuICAgIGNvbnN0IGlzc3VlcyA9IFsuLi5lcnJvci5pc3N1ZXNdLnNvcnQoKGEsIGIpID0+IChhLnBhdGggPz8gW10pLmxlbmd0aCAtIChiLnBhdGggPz8gW10pLmxlbmd0aCk7XG4gICAgLy8gUHJvY2VzcyBlYWNoIGlzc3VlXG4gICAgZm9yIChjb25zdCBpc3N1ZSBvZiBpc3N1ZXMpIHtcbiAgICAgICAgbGluZXMucHVzaChgXHUyNzE2ICR7aXNzdWUubWVzc2FnZX1gKTtcbiAgICAgICAgaWYgKGlzc3VlLnBhdGg/Lmxlbmd0aClcbiAgICAgICAgICAgIGxpbmVzLnB1c2goYCAgXHUyMTkyIGF0ICR7dG9Eb3RQYXRoKGlzc3VlLnBhdGgpfWApO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IE1hcCB0byBmb3JtYXR0ZWQgc3RyaW5nXG4gICAgcmV0dXJuIGxpbmVzLmpvaW4oXCJcXG5cIik7XG59XG4iLCAiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQgKiBhcyBlcnJvcnMgZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCBfcGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgsIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiBmYWxzZSB9KSA6IHsgYXN5bmM6IGZhbHNlIH07XG4gICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyAoX3BhcmFtcz8uRXJyID8/IF9FcnIpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKTtcbiAgICAgICAgdXRpbC5jYXB0dXJlU3RhY2tUcmFjZShlLCBfcGFyYW1zPy5jYWxsZWUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBwYXJzZSA9IC8qIEBfX1BVUkVfXyovIF9wYXJzZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3BhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgsIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IHRydWUgfSkgOiB7IGFzeW5jOiB0cnVlIH07XG4gICAgbGV0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZSA9IG5ldyAocGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpO1xuICAgICAgICB1dGlsLmNhcHR1cmVTdGFja1RyYWNlKGUsIHBhcmFtcz8uY2FsbGVlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9wYXJzZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZVBhcnNlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IHsgLi4uX2N0eCwgYXN5bmM6IGZhbHNlIH0gOiB7IGFzeW5jOiBmYWxzZSB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMubGVuZ3RoXG4gICAgICAgID8ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IChfRXJyID8/IGVycm9ycy4kWm9kRXJyb3IpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKSxcbiAgICAgICAgfVxuICAgICAgICA6IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVQYXJzZSA9IC8qIEBfX1BVUkVfXyovIF9zYWZlUGFyc2UoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlUGFyc2VBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IHRydWUgfSkgOiB7IGFzeW5jOiB0cnVlIH07XG4gICAgbGV0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgIHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcbiAgICByZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGhcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgX0VycihyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSksXG4gICAgICAgIH1cbiAgICAgICAgOiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xufTtcbmV4cG9ydCBjb25zdCBzYWZlUGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9zYWZlUGFyc2VBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX2VuY29kZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfSkgOiB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH07XG4gICAgcmV0dXJuIF9wYXJzZShfRXJyKShzY2hlbWEsIHZhbHVlLCBjdHgpO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAvKiBAX19QVVJFX18qLyBfZW5jb2RlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfZGVjb2RlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgcmV0dXJuIF9wYXJzZShfRXJyKShzY2hlbWEsIHZhbHVlLCBfY3R4KTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlID0gLyogQF9fUFVSRV9fKi8gX2RlY29kZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX2VuY29kZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9KSA6IHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfTtcbiAgICByZXR1cm4gX3BhcnNlQXN5bmMoX0Vycikoc2NoZW1hLCB2YWx1ZSwgY3R4KTtcbn07XG5leHBvcnQgY29uc3QgZW5jb2RlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfZW5jb2RlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9kZWNvZGVBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIHJldHVybiBfcGFyc2VBc3luYyhfRXJyKShzY2hlbWEsIHZhbHVlLCBfY3R4KTtcbn07XG5leHBvcnQgY29uc3QgZGVjb2RlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfZGVjb2RlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlRW5jb2RlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9KSA6IHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfTtcbiAgICByZXR1cm4gX3NhZmVQYXJzZShfRXJyKShzY2hlbWEsIHZhbHVlLCBjdHgpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlRW5jb2RlID0gLyogQF9fUFVSRV9fKi8gX3NhZmVFbmNvZGUoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlRGVjb2RlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgcmV0dXJuIF9zYWZlUGFyc2UoX0Vycikoc2NoZW1hLCB2YWx1ZSwgX2N0eCk7XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVEZWNvZGUgPSAvKiBAX19QVVJFX18qLyBfc2FmZURlY29kZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVFbmNvZGVBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfSkgOiB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH07XG4gICAgcmV0dXJuIF9zYWZlUGFyc2VBc3luYyhfRXJyKShzY2hlbWEsIHZhbHVlLCBjdHgpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlRW5jb2RlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfc2FmZUVuY29kZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZURlY29kZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgcmV0dXJuIF9zYWZlUGFyc2VBc3luYyhfRXJyKShzY2hlbWEsIHZhbHVlLCBfY3R4KTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZURlY29kZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX3NhZmVEZWNvZGVBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG4iLCAiaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgY3VpZCA9IC9eW2NDXVteXFxzLV17OCx9JC87XG5leHBvcnQgY29uc3QgY3VpZDIgPSAvXlswLTlhLXpdKyQvO1xuZXhwb3J0IGNvbnN0IHVsaWQgPSAvXlswLTlBLUhKS01OUC1UVi1aYS1oamttbnAtdHYtel17MjZ9JC87XG5leHBvcnQgY29uc3QgeGlkID0gL15bMC05YS12QS1WXXsyMH0kLztcbmV4cG9ydCBjb25zdCBrc3VpZCA9IC9eW0EtWmEtejAtOV17Mjd9JC87XG5leHBvcnQgY29uc3QgbmFub2lkID0gL15bYS16QS1aMC05Xy1dezIxfSQvO1xuLyoqIElTTyA4NjAxLTEgZHVyYXRpb24gcmVnZXguIERvZXMgbm90IHN1cHBvcnQgdGhlIDg2MDEtMiBleHRlbnNpb25zIGxpa2UgbmVnYXRpdmUgZHVyYXRpb25zIG9yIGZyYWN0aW9uYWwvbmVnYXRpdmUgY29tcG9uZW50cy4gKi9cbmV4cG9ydCBjb25zdCBkdXJhdGlvbiA9IC9eUCg/OihcXGQrVyl8KD8hLipXKSg/PVxcZHxUXFxkKShcXGQrWSk/KFxcZCtNKT8oXFxkK0QpPyhUKD89XFxkKShcXGQrSCk/KFxcZCtNKT8oXFxkKyhbLixdXFxkKyk/Uyk/KT8pJC87XG4vKiogSW1wbGVtZW50cyBJU08gODYwMS0yIGV4dGVuc2lvbnMgbGlrZSBleHBsaWNpdCArLSBwcmVmaXhlcywgbWl4aW5nIHdlZWtzIHdpdGggb3RoZXIgdW5pdHMsIGFuZCBmcmFjdGlvbmFsL25lZ2F0aXZlIGNvbXBvbmVudHMuICovXG5leHBvcnQgY29uc3QgZXh0ZW5kZWREdXJhdGlvbiA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG4vKiogQSByZWdleCBmb3IgYW55IFVVSUQtbGlrZSBpZGVudGlmaWVyOiA4LTQtNC00LTEyIGhleCBwYXR0ZXJuICovXG5leHBvcnQgY29uc3QgZ3VpZCA9IC9eKFswLTlhLWZBLUZdezh9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezR9LVswLTlhLWZBLUZdezEyfSkkLztcbi8qKiBSZXR1cm5zIGEgcmVnZXggZm9yIHZhbGlkYXRpbmcgYW4gUkZDIDk1NjIvNDEyMiBVVUlELlxuICpcbiAqIEBwYXJhbSB2ZXJzaW9uIE9wdGlvbmFsbHkgc3BlY2lmeSBhIHZlcnNpb24gMS04LiBJZiBubyB2ZXJzaW9uIGlzIHNwZWNpZmllZCwgYWxsIHZlcnNpb25zIGFyZSBzdXBwb3J0ZWQuICovXG5leHBvcnQgY29uc3QgdXVpZCA9ICh2ZXJzaW9uKSA9PiB7XG4gICAgaWYgKCF2ZXJzaW9uKVxuICAgICAgICByZXR1cm4gL14oWzAtOWEtZkEtRl17OH0tWzAtOWEtZkEtRl17NH0tWzEtOF1bMC05YS1mQS1GXXszfS1bODlhYkFCXVswLTlhLWZBLUZdezN9LVswLTlhLWZBLUZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDB8ZmZmZmZmZmYtZmZmZi1mZmZmLWZmZmYtZmZmZmZmZmZmZmZmKSQvO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeKFswLTlhLWZBLUZdezh9LVswLTlhLWZBLUZdezR9LSR7dmVyc2lvbn1bMC05YS1mQS1GXXszfS1bODlhYkFCXVswLTlhLWZBLUZdezN9LVswLTlhLWZBLUZdezEyfSkkYCk7XG59O1xuZXhwb3J0IGNvbnN0IHV1aWQ0ID0gLypAX19QVVJFX18qLyB1dWlkKDQpO1xuZXhwb3J0IGNvbnN0IHV1aWQ2ID0gLypAX19QVVJFX18qLyB1dWlkKDYpO1xuZXhwb3J0IGNvbnN0IHV1aWQ3ID0gLypAX19QVVJFX18qLyB1dWlkKDcpO1xuLyoqIFByYWN0aWNhbCBlbWFpbCB2YWxpZGF0aW9uICovXG5leHBvcnQgY29uc3QgZW1haWwgPSAvXig/IVxcLikoPyEuKlxcLlxcLikoW0EtWmEtejAtOV8nK1xcLVxcLl0qKVtBLVphLXowLTlfKy1dQChbQS1aYS16MC05XVtBLVphLXowLTlcXC1dKlxcLikrW0EtWmEtel17Mix9JC87XG4vKiogRXF1aXZhbGVudCB0byB0aGUgSFRNTDUgaW5wdXRbdHlwZT1lbWFpbF0gdmFsaWRhdGlvbiBpbXBsZW1lbnRlZCBieSBicm93c2Vycy4gU291cmNlOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvaW5wdXQvZW1haWwgKi9cbmV4cG9ydCBjb25zdCBodG1sNUVtYWlsID0gL15bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLyoqIFRoZSBjbGFzc2ljIGVtYWlscmVnZXguY29tIHJlZ2V4IGZvciBSRkMgNTMyMi1jb21wbGlhbnQgZW1haWxzICovXG5leHBvcnQgY29uc3QgcmZjNTMyMkVtYWlsID0gL14oKFtePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSsoXFwuW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKChcXFtbMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XSl8KChbYS16QS1aXFwtMC05XStcXC4pK1thLXpBLVpdezIsfSkpJC87XG4vKiogQSBsb29zZSByZWdleCB0aGF0IGFsbG93cyBVbmljb2RlIGNoYXJhY3RlcnMsIGVuZm9yY2VzIGxlbmd0aCBsaW1pdHMsIGFuZCB0aGF0J3MgYWJvdXQgaXQuICovXG5leHBvcnQgY29uc3QgdW5pY29kZUVtYWlsID0gL15bXlxcc0BcIl17MSw2NH1AW15cXHNAXXsxLDI1NX0kL3U7XG5leHBvcnQgY29uc3QgaWRuRW1haWwgPSB1bmljb2RlRW1haWw7XG5leHBvcnQgY29uc3QgYnJvd3NlckVtYWlsID0gL15bYS16QS1aMC05LiEjJCUmJyorLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamkgPSBgXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRgO1xuZXhwb3J0IGZ1bmN0aW9uIGVtb2ppKCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKF9lbW9qaSwgXCJ1XCIpO1xufVxuZXhwb3J0IGNvbnN0IGlwdjQgPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xuZXhwb3J0IGNvbnN0IGlwdjYgPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopKSQvO1xuZXhwb3J0IGNvbnN0IG1hYyA9IChkZWxpbWl0ZXIpID0+IHtcbiAgICBjb25zdCBlc2NhcGVkRGVsaW0gPSB1dGlsLmVzY2FwZVJlZ2V4KGRlbGltaXRlciA/PyBcIjpcIik7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oPzpbMC05QS1GXXsyfSR7ZXNjYXBlZERlbGltfSl7NX1bMC05QS1GXXsyfSR8Xig/OlswLTlhLWZdezJ9JHtlc2NhcGVkRGVsaW19KXs1fVswLTlhLWZdezJ9JGApO1xufTtcbmV4cG9ydCBjb25zdCBjaWRydjQgPSAvXigoMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oMjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLyhbMC05XXxbMS0yXVswLTldfDNbMC0yXSkkLztcbmV4cG9ydCBjb25zdCBjaWRydjYgPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezd9WzAtOWEtZkEtRl17MSw0fXw6OnwoWzAtOWEtZkEtRl17MSw0fSk/OjooWzAtOWEtZkEtRl17MSw0fTo/KXswLDZ9KVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC87XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83ODYwMzkyL2RldGVybWluZS1pZi1zdHJpbmctaXMtaW4tYmFzZTY0LXVzaW5nLWphdmFzY3JpcHRcbmV4cG9ydCBjb25zdCBiYXNlNjQgPSAvXiR8Xig/OlswLTlhLXpBLVorL117NH0pKig/Oig/OlswLTlhLXpBLVorL117Mn09PSl8KD86WzAtOWEtekEtWisvXXszfT0pKT8kLztcbmV4cG9ydCBjb25zdCBiYXNlNjR1cmwgPSAvXltBLVphLXowLTlfLV0qJC87XG4vLyBiYXNlZCBvbiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDYxNzkvcmVndWxhci1leHByZXNzaW9uLXRvLW1hdGNoLWRucy1ob3N0bmFtZS1vci1pcC1hZGRyZXNzXG4vLyBleHBvcnQgY29uc3QgaG9zdG5hbWU6IFJlZ0V4cCA9IC9eKFthLXpBLVowLTktXStcXC4pKlthLXpBLVowLTktXSskLztcbmV4cG9ydCBjb25zdCBob3N0bmFtZSA9IC9eKD89LnsxLDI1M31cXC4/JClbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlstMC05YS16QS1aXXswLDYxfVswLTlhLXpBLVpdKT8pKlxcLj8kLztcbmV4cG9ydCBjb25zdCBkb21haW4gPSAvXihbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT9cXC4pK1thLXpBLVpdezIsfSQvO1xuLy8gaHR0cHM6Ly9ibG9nLnN0ZXZlbmxldml0aGFuLmNvbS9hcmNoaXZlcy92YWxpZGF0ZS1waG9uZS1udW1iZXIjcjQtMyAocmVnZXggc2FucyBzcGFjZXMpXG4vLyBFLjE2NDogbGVhZGluZyBkaWdpdCBtdXN0IGJlIDEtOTsgdG90YWwgZGlnaXRzIChleGNsdWRpbmcgJysnKSBiZXR3ZWVuIDctMTVcbmV4cG9ydCBjb25zdCBlMTY0ID0gL15cXCtbMS05XVxcZHs2LDE0fSQvO1xuLy8gY29uc3QgZGF0ZVNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVNvdXJjZSA9IGAoPzooPzpcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oPzooPzowWzEzNTc4XXwxWzAyXSktKD86MFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KD86MFs0NjldfDExKS0oPzowWzEtOV18WzEyXVxcXFxkfDMwKXwoPzowMiktKD86MFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuZXhwb3J0IGNvbnN0IGRhdGUgPSAvKkBfX1BVUkVfXyovIG5ldyBSZWdFeHAoYF4ke2RhdGVTb3VyY2V9JGApO1xuZnVuY3Rpb24gdGltZVNvdXJjZShhcmdzKSB7XG4gICAgY29uc3QgaGhtbSA9IGAoPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkYDtcbiAgICBjb25zdCByZWdleCA9IHR5cGVvZiBhcmdzLnByZWNpc2lvbiA9PT0gXCJudW1iZXJcIlxuICAgICAgICA/IGFyZ3MucHJlY2lzaW9uID09PSAtMVxuICAgICAgICAgICAgPyBgJHtoaG1tfWBcbiAgICAgICAgICAgIDogYXJncy5wcmVjaXNpb24gPT09IDBcbiAgICAgICAgICAgICAgICA/IGAke2hobW19OlswLTVdXFxcXGRgXG4gICAgICAgICAgICAgICAgOiBgJHtoaG1tfTpbMC01XVxcXFxkXFxcXC5cXFxcZHske2FyZ3MucHJlY2lzaW9ufX1gXG4gICAgICAgIDogYCR7aGhtbX0oPzo6WzAtNV1cXFxcZCg/OlxcXFwuXFxcXGQrKT8pP2A7XG4gICAgcmV0dXJuIHJlZ2V4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRpbWUoYXJncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aW1lU291cmNlKGFyZ3MpfSRgKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzE0MzIzMVxuZXhwb3J0IGZ1bmN0aW9uIGRhdGV0aW1lKGFyZ3MpIHtcbiAgICBjb25zdCB0aW1lID0gdGltZVNvdXJjZSh7IHByZWNpc2lvbjogYXJncy5wcmVjaXNpb24gfSk7XG4gICAgY29uc3Qgb3B0cyA9IFtcIlpcIl07XG4gICAgaWYgKGFyZ3MubG9jYWwpXG4gICAgICAgIG9wdHMucHVzaChcIlwiKTtcbiAgICAvLyBpZiAoYXJncy5vZmZzZXQpIG9wdHMucHVzaChgKFsrLV1cXFxcZHsyfTpcXFxcZHsyfSlgKTtcbiAgICBpZiAoYXJncy5vZmZzZXQpXG4gICAgICAgIG9wdHMucHVzaChgKFsrLV0oPzpbMDFdXFxcXGR8MlswLTNdKTpbMC01XVxcXFxkKWApO1xuICAgIGNvbnN0IHRpbWVSZWdleCA9IGAke3RpbWV9KD86JHtvcHRzLmpvaW4oXCJ8XCIpfSlgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtkYXRlU291cmNlfVQoPzoke3RpbWVSZWdleH0pJGApO1xufVxuZXhwb3J0IGNvbnN0IHN0cmluZyA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCByZWdleCA9IHBhcmFtcyA/IGBbXFxcXHNcXFxcU117JHtwYXJhbXM/Lm1pbmltdW0gPz8gMH0sJHtwYXJhbXM/Lm1heGltdW0gPz8gXCJcIn19YCA6IGBbXFxcXHNcXFxcU10qYDtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufTtcbmV4cG9ydCBjb25zdCBiaWdpbnQgPSAvXi0/XFxkK24/JC87XG5leHBvcnQgY29uc3QgaW50ZWdlciA9IC9eLT9cXGQrJC87XG5leHBvcnQgY29uc3QgbnVtYmVyID0gL14tP1xcZCsoPzpcXC5cXGQrKT8kLztcbmV4cG9ydCBjb25zdCBib29sZWFuID0gL14oPzp0cnVlfGZhbHNlKSQvaTtcbmNvbnN0IF9udWxsID0gL15udWxsJC9pO1xuZXhwb3J0IHsgX251bGwgYXMgbnVsbCB9O1xuY29uc3QgX3VuZGVmaW5lZCA9IC9edW5kZWZpbmVkJC9pO1xuZXhwb3J0IHsgX3VuZGVmaW5lZCBhcyB1bmRlZmluZWQgfTtcbi8vIHJlZ2V4IGZvciBzdHJpbmcgd2l0aCBubyB1cHBlcmNhc2UgbGV0dGVyc1xuZXhwb3J0IGNvbnN0IGxvd2VyY2FzZSA9IC9eW15BLVpdKiQvO1xuLy8gcmVnZXggZm9yIHN0cmluZyB3aXRoIG5vIGxvd2VyY2FzZSBsZXR0ZXJzXG5leHBvcnQgY29uc3QgdXBwZXJjYXNlID0gL15bXmEtel0qJC87XG4vLyByZWdleCBmb3IgaGV4YWRlY2ltYWwgc3RyaW5ncyAoYW55IGxlbmd0aClcbmV4cG9ydCBjb25zdCBoZXggPSAvXlswLTlhLWZBLUZdKiQvO1xuLy8gSGFzaCByZWdleGVzIGZvciBkaWZmZXJlbnQgYWxnb3JpdGhtcyBhbmQgZW5jb2RpbmdzXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGJhc2U2NCByZWdleCB3aXRoIGV4YWN0IGxlbmd0aCBhbmQgcGFkZGluZ1xuZnVuY3Rpb24gZml4ZWRCYXNlNjQoYm9keUxlbmd0aCwgcGFkZGluZykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeW0EtWmEtejAtOSsvXXske2JvZHlMZW5ndGh9fSR7cGFkZGluZ30kYCk7XG59XG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGJhc2U2NHVybCByZWdleCB3aXRoIGV4YWN0IGxlbmd0aCAobm8gcGFkZGluZylcbmZ1bmN0aW9uIGZpeGVkQmFzZTY0dXJsKGxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeW0EtWmEtejAtOV8tXXske2xlbmd0aH19JGApO1xufVxuLy8gTUQ1ICgxNiBieXRlcyk6IGJhc2U2NCA9IDI0IGNoYXJzIHRvdGFsICgyMiArIFwiPT1cIilcbmV4cG9ydCBjb25zdCBtZDVfaGV4ID0gL15bMC05YS1mQS1GXXszMn0kLztcbmV4cG9ydCBjb25zdCBtZDVfYmFzZTY0ID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NCgyMiwgXCI9PVwiKTtcbmV4cG9ydCBjb25zdCBtZDVfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCgyMik7XG4vLyBTSEExICgyMCBieXRlcyk6IGJhc2U2NCA9IDI4IGNoYXJzIHRvdGFsICgyNyArIFwiPVwiKVxuZXhwb3J0IGNvbnN0IHNoYTFfaGV4ID0gL15bMC05YS1mQS1GXXs0MH0kLztcbmV4cG9ydCBjb25zdCBzaGExX2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoMjcsIFwiPVwiKTtcbmV4cG9ydCBjb25zdCBzaGExX2Jhc2U2NHVybCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjR1cmwoMjcpO1xuLy8gU0hBMjU2ICgzMiBieXRlcyk6IGJhc2U2NCA9IDQ0IGNoYXJzIHRvdGFsICg0MyArIFwiPVwiKVxuZXhwb3J0IGNvbnN0IHNoYTI1Nl9oZXggPSAvXlswLTlhLWZBLUZdezY0fSQvO1xuZXhwb3J0IGNvbnN0IHNoYTI1Nl9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDQzLCBcIj1cIik7XG5leHBvcnQgY29uc3Qgc2hhMjU2X2Jhc2U2NHVybCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjR1cmwoNDMpO1xuLy8gU0hBMzg0ICg0OCBieXRlcyk6IGJhc2U2NCA9IDY0IGNoYXJzIHRvdGFsIChubyBwYWRkaW5nKVxuZXhwb3J0IGNvbnN0IHNoYTM4NF9oZXggPSAvXlswLTlhLWZBLUZdezk2fSQvO1xuZXhwb3J0IGNvbnN0IHNoYTM4NF9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDY0LCBcIlwiKTtcbmV4cG9ydCBjb25zdCBzaGEzODRfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCg2NCk7XG4vLyBTSEE1MTIgKDY0IGJ5dGVzKTogYmFzZTY0ID0gODggY2hhcnMgdG90YWwgKDg2ICsgXCI9PVwiKVxuZXhwb3J0IGNvbnN0IHNoYTUxMl9oZXggPSAvXlswLTlhLWZBLUZdezEyOH0kLztcbmV4cG9ydCBjb25zdCBzaGE1MTJfYmFzZTY0ID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NCg4NiwgXCI9PVwiKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCg4Nik7XG4iLCAiLy8gaW1wb3J0IHsgJFpvZFR5cGUgfSBmcm9tIFwiLi9zY2hlbWFzLmpzXCI7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuL2NvcmUuanNcIjtcbmltcG9ydCAqIGFzIHJlZ2V4ZXMgZnJvbSBcIi4vcmVnZXhlcy5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGluc3QuX3pvZCA/PyAoaW5zdC5fem9kID0ge30pO1xuICAgIGluc3QuX3pvZC5kZWYgPSBkZWY7XG4gICAgKF9hID0gaW5zdC5fem9kKS5vbmF0dGFjaCA/PyAoX2Eub25hdHRhY2ggPSBbXSk7XG59KTtcbmNvbnN0IG51bWVyaWNPcmlnaW5NYXAgPSB7XG4gICAgbnVtYmVyOiBcIm51bWJlclwiLFxuICAgIGJpZ2ludDogXCJiaWdpbnRcIixcbiAgICBvYmplY3Q6IFwiZGF0ZVwiLFxufTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tMZXNzVGhhbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tMZXNzVGhhblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBvcmlnaW4gPSBudW1lcmljT3JpZ2luTWFwW3R5cGVvZiBkZWYudmFsdWVdO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoZGVmLmluY2x1c2l2ZSA/IGJhZy5tYXhpbXVtIDogYmFnLmV4Y2x1c2l2ZU1heGltdW0pID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgaWYgKGRlZi52YWx1ZSA8IGN1cnIpIHtcbiAgICAgICAgICAgIGlmIChkZWYuaW5jbHVzaXZlKVxuICAgICAgICAgICAgICAgIGJhZy5tYXhpbXVtID0gZGVmLnZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJhZy5leGNsdXNpdmVNYXhpbXVtID0gZGVmLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGRlZi5pbmNsdXNpdmUgPyBwYXlsb2FkLnZhbHVlIDw9IGRlZi52YWx1ZSA6IHBheWxvYWQudmFsdWUgPCBkZWYudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgbWF4aW11bTogdHlwZW9mIGRlZi52YWx1ZSA9PT0gXCJvYmplY3RcIiA/IGRlZi52YWx1ZS5nZXRUaW1lKCkgOiBkZWYudmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZGVmLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0dyZWF0ZXJUaGFuID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0dyZWF0ZXJUaGFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG51bWVyaWNPcmlnaW5NYXBbdHlwZW9mIGRlZi52YWx1ZV07XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgY29uc3QgY3VyciA9IChkZWYuaW5jbHVzaXZlID8gYmFnLm1pbmltdW0gOiBiYWcuZXhjbHVzaXZlTWluaW11bSkgPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuICAgICAgICBpZiAoZGVmLnZhbHVlID4gY3Vycikge1xuICAgICAgICAgICAgaWYgKGRlZi5pbmNsdXNpdmUpXG4gICAgICAgICAgICAgICAgYmFnLm1pbmltdW0gPSBkZWYudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmFnLmV4Y2x1c2l2ZU1pbmltdW0gPSBkZWYudmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmluY2x1c2l2ZSA/IHBheWxvYWQudmFsdWUgPj0gZGVmLnZhbHVlIDogcGF5bG9hZC52YWx1ZSA+IGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgIG1pbmltdW06IHR5cGVvZiBkZWYudmFsdWUgPT09IFwib2JqZWN0XCIgPyBkZWYudmFsdWUuZ2V0VGltZSgpIDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGRlZi5pbmNsdXNpdmUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNdWx0aXBsZU9mID0gXG4vKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTXVsdGlwbGVPZlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIChfYSA9IGluc3QuX3pvZC5iYWcpLm11bHRpcGxlT2YgPz8gKF9hLm11bHRpcGxlT2YgPSBkZWYudmFsdWUpO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC52YWx1ZSAhPT0gdHlwZW9mIGRlZi52YWx1ZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtaXggbnVtYmVyIGFuZCBiaWdpbnQgaW4gbXVsdGlwbGVfb2YgY2hlY2suXCIpO1xuICAgICAgICBjb25zdCBpc011bHRpcGxlID0gdHlwZW9mIHBheWxvYWQudmFsdWUgPT09IFwiYmlnaW50XCJcbiAgICAgICAgICAgID8gcGF5bG9hZC52YWx1ZSAlIGRlZi52YWx1ZSA9PT0gQmlnSW50KDApXG4gICAgICAgICAgICA6IHV0aWwuZmxvYXRTYWZlUmVtYWluZGVyKHBheWxvYWQudmFsdWUsIGRlZi52YWx1ZSkgPT09IDA7XG4gICAgICAgIGlmIChpc011bHRpcGxlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogdHlwZW9mIHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBjb2RlOiBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgICAgICAgICAgZGl2aXNvcjogZGVmLnZhbHVlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tOdW1iZXJGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTnVtYmVyRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpOyAvLyBubyBmb3JtYXQgY2hlY2tzXG4gICAgZGVmLmZvcm1hdCA9IGRlZi5mb3JtYXQgfHwgXCJmbG9hdDY0XCI7XG4gICAgY29uc3QgaXNJbnQgPSBkZWYuZm9ybWF0Py5pbmNsdWRlcyhcImludFwiKTtcbiAgICBjb25zdCBvcmlnaW4gPSBpc0ludCA/IFwiaW50XCIgOiBcIm51bWJlclwiO1xuICAgIGNvbnN0IFttaW5pbXVtLCBtYXhpbXVtXSA9IHV0aWwuTlVNQkVSX0ZPUk1BVF9SQU5HRVNbZGVmLmZvcm1hdF07XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLmZvcm1hdCA9IGRlZi5mb3JtYXQ7XG4gICAgICAgIGJhZy5taW5pbXVtID0gbWluaW11bTtcbiAgICAgICAgYmFnLm1heGltdW0gPSBtYXhpbXVtO1xuICAgICAgICBpZiAoaXNJbnQpXG4gICAgICAgICAgICBiYWcucGF0dGVybiA9IHJlZ2V4ZXMuaW50ZWdlcjtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmIChpc0ludCkge1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIC8vIGludmFsaWRfZm9ybWF0IGlzc3VlXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLy8gICBleHBlY3RlZDogZGVmLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAvLyAgIGZvcm1hdDogZGVmLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAvLyAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICAvLyAgIGlucHV0LFxuICAgICAgICAgICAgICAgIC8vICAgaW5zdCxcbiAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICAvLyBpbnZhbGlkX3R5cGUgaXNzdWVcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBub3RfbXVsdGlwbGVfb2YgaXNzdWVcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAvLyAgIGNvZGU6IFwibm90X211bHRpcGxlX29mXCIsXG4gICAgICAgICAgICAgICAgLy8gICBvcmlnaW46IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgLy8gICBpbnB1dCxcbiAgICAgICAgICAgICAgICAvLyAgIGluc3QsXG4gICAgICAgICAgICAgICAgLy8gICBkaXZpc29yOiAxLFxuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvb19iaWdcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlOiBcIkludGVnZXJzIG11c3QgYmUgd2l0aGluIHRoZSBzYWZlIGludGVnZXIgcmFuZ2UuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9vX3NtYWxsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlOiBcIkludGVnZXJzIG11c3QgYmUgd2l0aGluIHRoZSBzYWZlIGludGVnZXIgcmFuZ2UuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0IDwgbWluaW11bSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICAgICAgbWluaW11bSxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA+IG1heGltdW0pIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgICAgICBtYXhpbXVtLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrQmlnSW50Rm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0JpZ0ludEZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTsgLy8gbm8gZm9ybWF0IGNoZWNrc1xuICAgIGNvbnN0IFttaW5pbXVtLCBtYXhpbXVtXSA9IHV0aWwuQklHSU5UX0ZPUk1BVF9SQU5HRVNbZGVmLmZvcm1hdF07XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLmZvcm1hdCA9IGRlZi5mb3JtYXQ7XG4gICAgICAgIGJhZy5taW5pbXVtID0gbWluaW11bTtcbiAgICAgICAgYmFnLm1heGltdW0gPSBtYXhpbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKGlucHV0IDwgbWluaW11bSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICAgICAgbWluaW11bTogbWluaW11bSxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA+IG1heGltdW0pIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgICAgICBtYXhpbXVtLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWF4U2l6ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNYXhTaXplXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwuc2l6ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoaW5zdC5fem9kLmJhZy5tYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGlmIChkZWYubWF4aW11bSA8IGN1cnIpXG4gICAgICAgICAgICBpbnN0Ll96b2QuYmFnLm1heGltdW0gPSBkZWYubWF4aW11bTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNpemUgPSBpbnB1dC5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA8PSBkZWYubWF4aW11bSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IHV0aWwuZ2V0U2l6YWJsZU9yaWdpbihpbnB1dCksXG4gICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhpbXVtLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNaW5TaXplID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01pblNpemVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5zaXplICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyciA9IChpbnN0Ll96b2QuYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgICAgaWYgKGRlZi5taW5pbXVtID4gY3VycilcbiAgICAgICAgICAgIGluc3QuX3pvZC5iYWcubWluaW11bSA9IGRlZi5taW5pbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGlucHV0LnNpemU7XG4gICAgICAgIGlmIChzaXplID49IGRlZi5taW5pbXVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogdXRpbC5nZXRTaXphYmxlT3JpZ2luKGlucHV0KSxcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluaW11bSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrU2l6ZUVxdWFscyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tTaXplRXF1YWxzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwuc2l6ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5taW5pbXVtID0gZGVmLnNpemU7XG4gICAgICAgIGJhZy5tYXhpbXVtID0gZGVmLnNpemU7XG4gICAgICAgIGJhZy5zaXplID0gZGVmLnNpemU7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBzaXplID0gaW5wdXQuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPT09IGRlZi5zaXplKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0b29CaWcgPSBzaXplID4gZGVmLnNpemU7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiB1dGlsLmdldFNpemFibGVPcmlnaW4oaW5wdXQpLFxuICAgICAgICAgICAgLi4uKHRvb0JpZyA/IHsgY29kZTogXCJ0b29fYmlnXCIsIG1heGltdW06IGRlZi5zaXplIH0gOiB7IGNvZGU6IFwidG9vX3NtYWxsXCIsIG1pbmltdW06IGRlZi5zaXplIH0pLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja01heExlbmd0aCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNYXhMZW5ndGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyID0gKGluc3QuX3pvZC5iYWcubWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBpZiAoZGVmLm1heGltdW0gPCBjdXJyKVxuICAgICAgICAgICAgaW5zdC5fem9kLmJhZy5tYXhpbXVtID0gZGVmLm1heGltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPD0gZGVmLm1heGltdW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHV0aWwuZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4aW11bSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWluTGVuZ3RoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01pbkxlbmd0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoaW5zdC5fem9kLmJhZy5taW5pbXVtID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGlmIChkZWYubWluaW11bSA+IGN1cnIpXG4gICAgICAgICAgICBpbnN0Ll96b2QuYmFnLm1pbmltdW0gPSBkZWYubWluaW11bTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA+PSBkZWYubWluaW11bSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdXRpbC5nZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbmltdW0sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0xlbmd0aEVxdWFscyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tMZW5ndGhFcXVhbHNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcubWluaW11bSA9IGRlZi5sZW5ndGg7XG4gICAgICAgIGJhZy5tYXhpbXVtID0gZGVmLmxlbmd0aDtcbiAgICAgICAgYmFnLmxlbmd0aCA9IGRlZi5sZW5ndGg7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPT09IGRlZi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHV0aWwuZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IGxlbmd0aCA+IGRlZi5sZW5ndGg7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgLi4uKHRvb0JpZyA/IHsgY29kZTogXCJ0b29fYmlnXCIsIG1heGltdW06IGRlZi5sZW5ndGggfSA6IHsgY29kZTogXCJ0b29fc21hbGxcIiwgbWluaW11bTogZGVmLmxlbmd0aCB9KSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tTdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLmZvcm1hdCA9IGRlZi5mb3JtYXQ7XG4gICAgICAgIGlmIChkZWYucGF0dGVybikge1xuICAgICAgICAgICAgYmFnLnBhdHRlcm5zID8/IChiYWcucGF0dGVybnMgPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgYmFnLnBhdHRlcm5zLmFkZChkZWYucGF0dGVybik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGVmLnBhdHRlcm4pXG4gICAgICAgIChfYSA9IGluc3QuX3pvZCkuY2hlY2sgPz8gKF9hLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGRlZi5wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICBpZiAoZGVmLnBhdHRlcm4udGVzdChwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZGVmLmZvcm1hdCxcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAuLi4oZGVmLnBhdHRlcm4gPyB7IHBhdHRlcm46IGRlZi5wYXR0ZXJuLnRvU3RyaW5nKCkgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIGVsc2VcbiAgICAgICAgKF9iID0gaW5zdC5fem9kKS5jaGVjayA/PyAoX2IuY2hlY2sgPSAoKSA9PiB7IH0pO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrUmVnZXggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrUmVnZXhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVja1N0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgZGVmLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKGRlZi5wYXR0ZXJuLnRlc3QocGF5bG9hZC52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcInJlZ2V4XCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIHBhdHRlcm46IGRlZi5wYXR0ZXJuLnRvU3RyaW5nKCksXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tMb3dlckNhc2UgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTG93ZXJDYXNlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmxvd2VyY2FzZSk7XG4gICAgJFpvZENoZWNrU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja1VwcGVyQ2FzZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tVcHBlckNhc2VcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMudXBwZXJjYXNlKTtcbiAgICAkWm9kQ2hlY2tTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrSW5jbHVkZXMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrSW5jbHVkZXNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgZXNjYXBlZFJlZ2V4ID0gdXRpbC5lc2NhcGVSZWdleChkZWYuaW5jbHVkZXMpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKHR5cGVvZiBkZWYucG9zaXRpb24gPT09IFwibnVtYmVyXCIgPyBgXi57JHtkZWYucG9zaXRpb259fSR7ZXNjYXBlZFJlZ2V4fWAgOiBlc2NhcGVkUmVnZXgpO1xuICAgIGRlZi5wYXR0ZXJuID0gcGF0dGVybjtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgIGJhZy5wYXR0ZXJucy5hZGQocGF0dGVybik7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUuaW5jbHVkZXMoZGVmLmluY2x1ZGVzLCBkZWYucG9zaXRpb24pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAgICAgaW5jbHVkZXM6IGRlZi5pbmNsdWRlcyxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrU3RhcnRzV2l0aCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tTdGFydHNXaXRoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeJHt1dGlsLmVzY2FwZVJlZ2V4KGRlZi5wcmVmaXgpfS4qYCk7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcGF0dGVybik7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLnBhdHRlcm5zID8/IChiYWcucGF0dGVybnMgPSBuZXcgU2V0KCkpO1xuICAgICAgICBiYWcucGF0dGVybnMuYWRkKHBhdHRlcm4pO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlLnN0YXJ0c1dpdGgoZGVmLnByZWZpeCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcInN0YXJ0c193aXRoXCIsXG4gICAgICAgICAgICBwcmVmaXg6IGRlZi5wcmVmaXgsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0VuZHNXaXRoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0VuZHNXaXRoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGAuKiR7dXRpbC5lc2NhcGVSZWdleChkZWYuc3VmZml4KX0kYCk7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcGF0dGVybik7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLnBhdHRlcm5zID8/IChiYWcucGF0dGVybnMgPSBuZXcgU2V0KCkpO1xuICAgICAgICBiYWcucGF0dGVybnMuYWRkKHBhdHRlcm4pO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlLmVuZHNXaXRoKGRlZi5zdWZmaXgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJlbmRzX3dpdGhcIixcbiAgICAgICAgICAgIHN1ZmZpeDogZGVmLnN1ZmZpeCxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8gICAgJFpvZENoZWNrUHJvcGVydHkgICAgLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBoYW5kbGVDaGVja1Byb3BlcnR5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgcHJvcGVydHkpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3Vlcyhwcm9wZXJ0eSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tQcm9wZXJ0eSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tQcm9wZXJ0eVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuc2NoZW1hLl96b2QucnVuKHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXlsb2FkLnZhbHVlW2RlZi5wcm9wZXJ0eV0sXG4gICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICB9LCB7fSk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlQ2hlY2tQcm9wZXJ0eVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGRlZi5wcm9wZXJ0eSkpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZUNoZWNrUHJvcGVydHlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBkZWYucHJvcGVydHkpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja01pbWVUeXBlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01pbWVUeXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IG1pbWVTZXQgPSBuZXcgU2V0KGRlZi5taW1lKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBpbnN0Ll96b2QuYmFnLm1pbWUgPSBkZWYubWltZTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAobWltZVNldC5oYXMocGF5bG9hZC52YWx1ZS50eXBlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICAgICAgICAgIHZhbHVlczogZGVmLm1pbWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZS50eXBlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrT3ZlcndyaXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja092ZXJ3cml0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLnR4KHBheWxvYWQudmFsdWUpO1xuICAgIH07XG59KTtcbiIsICJleHBvcnQgY2xhc3MgRG9jIHtcbiAgICBjb25zdHJ1Y3RvcihhcmdzID0gW10pIHtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gW107XG4gICAgICAgIHRoaXMuaW5kZW50ID0gMDtcbiAgICAgICAgaWYgKHRoaXMpXG4gICAgICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgIH1cbiAgICBpbmRlbnRlZChmbikge1xuICAgICAgICB0aGlzLmluZGVudCArPSAxO1xuICAgICAgICBmbih0aGlzKTtcbiAgICAgICAgdGhpcy5pbmRlbnQgLT0gMTtcbiAgICB9XG4gICAgd3JpdGUoYXJnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFyZyh0aGlzLCB7IGV4ZWN1dGlvbjogXCJzeW5jXCIgfSk7XG4gICAgICAgICAgICBhcmcodGhpcywgeyBleGVjdXRpb246IFwiYXN5bmNcIiB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZW50ID0gYXJnO1xuICAgICAgICBjb25zdCBsaW5lcyA9IGNvbnRlbnQuc3BsaXQoXCJcXG5cIikuZmlsdGVyKCh4KSA9PiB4KTtcbiAgICAgICAgY29uc3QgbWluSW5kZW50ID0gTWF0aC5taW4oLi4ubGluZXMubWFwKCh4KSA9PiB4Lmxlbmd0aCAtIHgudHJpbVN0YXJ0KCkubGVuZ3RoKSk7XG4gICAgICAgIGNvbnN0IGRlZGVudGVkID0gbGluZXMubWFwKCh4KSA9PiB4LnNsaWNlKG1pbkluZGVudCkpLm1hcCgoeCkgPT4gXCIgXCIucmVwZWF0KHRoaXMuaW5kZW50ICogMikgKyB4KTtcbiAgICAgICAgZm9yIChjb25zdCBsaW5lIG9mIGRlZGVudGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb21waWxlKCkge1xuICAgICAgICBjb25zdCBGID0gRnVuY3Rpb247XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzPy5hcmdzO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcz8uY29udGVudCA/PyBbYGBdO1xuICAgICAgICBjb25zdCBsaW5lcyA9IFsuLi5jb250ZW50Lm1hcCgoeCkgPT4gYCAgJHt4fWApXTtcbiAgICAgICAgLy8gY29uc29sZS5sb2cobGluZXMuam9pbihcIlxcblwiKSk7XG4gICAgICAgIHJldHVybiBuZXcgRiguLi5hcmdzLCBsaW5lcy5qb2luKFwiXFxuXCIpKTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSB7XG4gICAgbWFqb3I6IDQsXG4gICAgbWlub3I6IDMsXG4gICAgcGF0Y2g6IDYsXG59O1xuIiwgImltcG9ydCAqIGFzIGNoZWNrcyBmcm9tIFwiLi9jaGVja3MuanNcIjtcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vY29yZS5qc1wiO1xuaW1wb3J0IHsgRG9jIH0gZnJvbSBcIi4vZG9jLmpzXCI7XG5pbXBvcnQgeyBwYXJzZSwgcGFyc2VBc3luYywgc2FmZVBhcnNlLCBzYWZlUGFyc2VBc3luYyB9IGZyb20gXCIuL3BhcnNlLmpzXCI7XG5pbXBvcnQgKiBhcyByZWdleGVzIGZyb20gXCIuL3JlZ2V4ZXMuanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL3ZlcnNpb25zLmpzXCI7XG5leHBvcnQgY29uc3QgJFpvZFR5cGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpbnN0ID8/IChpbnN0ID0ge30pO1xuICAgIGluc3QuX3pvZC5kZWYgPSBkZWY7IC8vIHNldCBfZGVmIHByb3BlcnR5XG4gICAgaW5zdC5fem9kLmJhZyA9IGluc3QuX3pvZC5iYWcgfHwge307IC8vIGluaXRpYWxpemUgX2JhZyBvYmplY3RcbiAgICBpbnN0Ll96b2QudmVyc2lvbiA9IHZlcnNpb247XG4gICAgY29uc3QgY2hlY2tzID0gWy4uLihpbnN0Ll96b2QuZGVmLmNoZWNrcyA/PyBbXSldO1xuICAgIC8vIGlmIGluc3QgaXMgaXRzZWxmIGEgY2hlY2tzLiRab2RDaGVjaywgcnVuIGl0IGFzIGEgY2hlY2tcbiAgICBpZiAoaW5zdC5fem9kLnRyYWl0cy5oYXMoXCIkWm9kQ2hlY2tcIikpIHtcbiAgICAgICAgY2hlY2tzLnVuc2hpZnQoaW5zdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2ggb2YgY2hlY2tzKSB7XG4gICAgICAgIGZvciAoY29uc3QgZm4gb2YgY2guX3pvZC5vbmF0dGFjaCkge1xuICAgICAgICAgICAgZm4oaW5zdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNoZWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gZGVmZXJyZWQgaW5pdGlhbGl6ZXJcbiAgICAgICAgLy8gaW5zdC5fem9kLnBhcnNlIGlzIG5vdCB5ZXQgZGVmaW5lZFxuICAgICAgICAoX2EgPSBpbnN0Ll96b2QpLmRlZmVycmVkID8/IChfYS5kZWZlcnJlZCA9IFtdKTtcbiAgICAgICAgaW5zdC5fem9kLmRlZmVycmVkPy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgIGluc3QuX3pvZC5ydW4gPSBpbnN0Ll96b2QucGFyc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcnVuQ2hlY2tzID0gKHBheWxvYWQsIGNoZWNrcywgY3R4KSA9PiB7XG4gICAgICAgICAgICBsZXQgaXNBYm9ydGVkID0gdXRpbC5hYm9ydGVkKHBheWxvYWQpO1xuICAgICAgICAgICAgbGV0IGFzeW5jUmVzdWx0O1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2guX3pvZC5kZWYud2hlbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRSdW4gPSBjaC5fem9kLmRlZi53aGVuKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3VsZFJ1bilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0Fib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGNoLl96b2QuY2hlY2socGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgaWYgKF8gaW5zdGFuY2VvZiBQcm9taXNlICYmIGN0eD8uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhc3luY1Jlc3VsdCB8fCBfIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBhc3luY1Jlc3VsdCA9IChhc3luY1Jlc3VsdCA/PyBQcm9taXNlLnJlc29sdmUoKSkudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhd2FpdCBfO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dExlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghaXNBYm9ydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJvcnRlZCA9IHV0aWwuYWJvcnRlZChwYXlsb2FkLCBjdXJyTGVuKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExlbiA9PT0gY3VyckxlbilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQWJvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWJvcnRlZCA9IHV0aWwuYWJvcnRlZChwYXlsb2FkLCBjdXJyTGVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYXN5bmNSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXN5bmNSZXN1bHQudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZUNhbmFyeVJlc3VsdCA9IChjYW5hcnksIHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgLy8gYWJvcnQgaWYgdGhlIGNhbmFyeSBpcyBhYm9ydGVkXG4gICAgICAgICAgICBpZiAodXRpbC5hYm9ydGVkKGNhbmFyeSkpIHtcbiAgICAgICAgICAgICAgICBjYW5hcnkuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbmFyeTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJ1biBjaGVja3MgZmlyc3QsIHRoZW5cbiAgICAgICAgICAgIGNvbnN0IGNoZWNrUmVzdWx0ID0gcnVuQ2hlY2tzKHBheWxvYWQsIGNoZWNrcywgY3R4KTtcbiAgICAgICAgICAgIGlmIChjaGVja1Jlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmFzeW5jID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tSZXN1bHQudGhlbigoY2hlY2tSZXN1bHQpID0+IGluc3QuX3pvZC5wYXJzZShjaGVja1Jlc3VsdCwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaW5zdC5fem9kLnBhcnNlKGNoZWNrUmVzdWx0LCBjdHgpO1xuICAgICAgICB9O1xuICAgICAgICBpbnN0Ll96b2QucnVuID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKGN0eC5za2lwQ2hlY2tzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3QuX3pvZC5wYXJzZShwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgICAgIC8vIHJ1biBjYW5hcnlcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHBhc3MgKG5vIGNoZWNrcylcbiAgICAgICAgICAgICAgICBjb25zdCBjYW5hcnkgPSBpbnN0Ll96b2QucGFyc2UoeyB2YWx1ZTogcGF5bG9hZC52YWx1ZSwgaXNzdWVzOiBbXSB9LCB7IC4uLmN0eCwgc2tpcENoZWNrczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoY2FuYXJ5IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FuYXJ5LnRoZW4oKGNhbmFyeSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbmFyeVJlc3VsdChjYW5hcnksIHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2FuYXJ5UmVzdWx0KGNhbmFyeSwgcGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZvcndhcmRcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGluc3QuX3pvZC5wYXJzZShwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmFzeW5jID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gcnVuQ2hlY2tzKHJlc3VsdCwgY2hlY2tzLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5DaGVja3MocmVzdWx0LCBjaGVja3MsIGN0eCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIExhenkgaW5pdGlhbGl6ZSB+c3RhbmRhcmQgdG8gYXZvaWQgY3JlYXRpbmcgb2JqZWN0cyBmb3IgZXZlcnkgc2NoZW1hXG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QsIFwifnN0YW5kYXJkXCIsICgpID0+ICh7XG4gICAgICAgIHZhbGlkYXRlOiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgciA9IHNhZmVQYXJzZShpbnN0LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2FmZVBhcnNlQXN5bmMoaW5zdCwgdmFsdWUpLnRoZW4oKHIpID0+IChyLnN1Y2Nlc3MgPyB7IHZhbHVlOiByLmRhdGEgfSA6IHsgaXNzdWVzOiByLmVycm9yPy5pc3N1ZXMgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICAgIHZlcnNpb246IDEsXG4gICAgfSkpO1xufSk7XG5leHBvcnQgeyBjbG9uZSB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCAkWm9kU3RyaW5nID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RTdHJpbmdcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IFsuLi4oaW5zdD8uX3pvZC5iYWc/LnBhdHRlcm5zID8/IFtdKV0ucG9wKCkgPz8gcmVnZXhlcy5zdHJpbmcoaW5zdC5fem9kLmJhZyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF8pID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBTdHJpbmcocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC52YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kU3RyaW5nRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RTdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIGNoZWNrIGluaXRpYWxpemF0aW9uIG11c3QgY29tZSBmaXJzdFxuICAgIGNoZWNrcy4kWm9kQ2hlY2tTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgICRab2RTdHJpbmcuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEdVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEdVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZ3VpZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVVVJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVVVJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgaWYgKGRlZi52ZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb25NYXAgPSB7XG4gICAgICAgICAgICB2MTogMSxcbiAgICAgICAgICAgIHYyOiAyLFxuICAgICAgICAgICAgdjM6IDMsXG4gICAgICAgICAgICB2NDogNCxcbiAgICAgICAgICAgIHY1OiA1LFxuICAgICAgICAgICAgdjY6IDYsXG4gICAgICAgICAgICB2NzogNyxcbiAgICAgICAgICAgIHY4OiA4LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2ID0gdmVyc2lvbk1hcFtkZWYudmVyc2lvbl07XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVVJRCB2ZXJzaW9uOiBcIiR7ZGVmLnZlcnNpb259XCJgKTtcbiAgICAgICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy51dWlkKHYpKTtcbiAgICB9XG4gICAgZWxzZVxuICAgICAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnV1aWQoKSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRW1haWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEVtYWlsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmVtYWlsKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVUkwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVSTFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFRyaW0gd2hpdGVzcGFjZSBmcm9tIGlucHV0XG4gICAgICAgICAgICBjb25zdCB0cmltbWVkID0gcGF5bG9hZC52YWx1ZS50cmltKCk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHRyaW1tZWQpO1xuICAgICAgICAgICAgaWYgKGRlZi5ob3N0bmFtZSkge1xuICAgICAgICAgICAgICAgIGRlZi5ob3N0bmFtZS5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGlmICghZGVmLmhvc3RuYW1lLnRlc3QodXJsLmhvc3RuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW52YWxpZCBob3N0bmFtZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZGVmLmhvc3RuYW1lLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVmLnByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgZGVmLnByb3RvY29sLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWYucHJvdG9jb2wudGVzdCh1cmwucHJvdG9jb2wuZW5kc1dpdGgoXCI6XCIpID8gdXJsLnByb3RvY29sLnNsaWNlKDAsIC0xKSA6IHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlOiBcIkludmFsaWQgcHJvdG9jb2xcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGRlZi5wcm90b2NvbC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2V0IHRoZSBvdXRwdXQgdmFsdWUgYmFzZWQgb24gbm9ybWFsaXplIGZsYWdcbiAgICAgICAgICAgIGlmIChkZWYubm9ybWFsaXplKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIG5vcm1hbGl6ZWQgVVJMXG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHVybC5ocmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlc2VydmUgdGhlIG9yaWdpbmFsIGlucHV0ICh0cmltbWVkKVxuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSB0cmltbWVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcInVybFwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRW1vamkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEVtb2ppXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmVtb2ppKCkpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE5hbm9JRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTmFub0lEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLm5hbm9pZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5jdWlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDVUlEMiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ1VJRDJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuY3VpZDIpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVMSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVMSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMudWxpZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kWElEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RYSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMueGlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RLU1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kS1NVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMua3N1aWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElTT0RhdGVUaW1lID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJU09EYXRlVGltZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5kYXRldGltZShkZWYpKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJU09EYXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJU09EYXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmRhdGUpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElTT1RpbWUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElTT1RpbWVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMudGltZShkZWYpKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJU09EdXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVNPRHVyYXRpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZHVyYXRpb24pO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElQdjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElQdjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuaXB2NCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmJhZy5mb3JtYXQgPSBgaXB2NGA7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVB2NiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVB2NlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5pcHY2KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuYmFnLmZvcm1hdCA9IGBpcHY2YDtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbmV3IFVSTChgaHR0cDovL1ske3BheWxvYWQudmFsdWV9XWApO1xuICAgICAgICAgICAgLy8gcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiaXB2NlwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTUFDID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RNQUNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMubWFjKGRlZi5kZWxpbWl0ZXIpKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuYmFnLmZvcm1hdCA9IGBtYWNgO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENJRFJ2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ0lEUnY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmNpZHJ2NCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ0lEUnY2ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDSURSdjZcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuY2lkcnY2KTsgLy8gbm90IHVzZWQgZm9yIHZhbGlkYXRpb25cbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0cyA9IHBheWxvYWQudmFsdWUuc3BsaXQoXCIvXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IFthZGRyZXNzLCBwcmVmaXhdID0gcGFydHM7XG4gICAgICAgICAgICBpZiAoIXByZWZpeClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeE51bSA9IE51bWJlcihwcmVmaXgpO1xuICAgICAgICAgICAgaWYgKGAke3ByZWZpeE51bX1gICE9PSBwcmVmaXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBpZiAocHJlZml4TnVtIDwgMCB8fCBwcmVmaXhOdW0gPiAxMjgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBuZXcgVVJMKGBodHRwOi8vWyR7YWRkcmVzc31dYCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJjaWRydjZcIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICBab2RCYXNlNjQgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQmFzZTY0KGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gXCJcIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGRhdGEubGVuZ3RoICUgNCAhPT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgYXRvYihkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCAkWm9kQmFzZTY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCYXNlNjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuYmFzZTY0KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuYmFnLmNvbnRlbnRFbmNvZGluZyA9IFwiYmFzZTY0XCI7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGlzVmFsaWRCYXNlNjQocGF5bG9hZC52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImJhc2U2NFwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFpvZEJhc2U2NCAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCYXNlNjRVUkwoZGF0YSkge1xuICAgIGlmICghcmVnZXhlcy5iYXNlNjR1cmwudGVzdChkYXRhKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGJhc2U2NCA9IGRhdGEucmVwbGFjZSgvWy1fXS9nLCAoYykgPT4gKGMgPT09IFwiLVwiID8gXCIrXCIgOiBcIi9cIikpO1xuICAgIGNvbnN0IHBhZGRlZCA9IGJhc2U2NC5wYWRFbmQoTWF0aC5jZWlsKGJhc2U2NC5sZW5ndGggLyA0KSAqIDQsIFwiPVwiKTtcbiAgICByZXR1cm4gaXNWYWxpZEJhc2U2NChwYWRkZWQpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RCYXNlNjRVUkwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEJhc2U2NFVSTFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5iYXNlNjR1cmwpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuY29udGVudEVuY29kaW5nID0gXCJiYXNlNjR1cmxcIjtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoaXNWYWxpZEJhc2U2NFVSTChwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RFMTY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RFMTY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmUxNjQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICBab2RKV1QgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkSldUKHRva2VuLCBhbGdvcml0aG0gPSBudWxsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdG9rZW5zUGFydHMgPSB0b2tlbi5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmICh0b2tlbnNQYXJ0cy5sZW5ndGggIT09IDMpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gdG9rZW5zUGFydHM7XG4gICAgICAgIGlmICghaGVhZGVyKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHBhcnNlZEhlYWRlciA9IEpTT04ucGFyc2UoYXRvYihoZWFkZXIpKTtcbiAgICAgICAgaWYgKFwidHlwXCIgaW4gcGFyc2VkSGVhZGVyICYmIHBhcnNlZEhlYWRlcj8udHlwICE9PSBcIkpXVFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcnNlZEhlYWRlci5hbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChhbGdvcml0aG0gJiYgKCEoXCJhbGdcIiBpbiBwYXJzZWRIZWFkZXIpIHx8IHBhcnNlZEhlYWRlci5hbGcgIT09IGFsZ29yaXRobSkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgJFpvZEpXVCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSldUXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoaXNWYWxpZEpXVChwYXlsb2FkLnZhbHVlLCBkZWYuYWxnKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiand0XCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDdXN0b21TdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEN1c3RvbVN0cmluZ0Zvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGRlZi5mbihwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IGRlZi5mb3JtYXQsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROdW1iZXIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE51bWJlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gaW5zdC5fem9kLmJhZy5wYXR0ZXJuID8/IHJlZ2V4ZXMubnVtYmVyO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gTnVtYmVyKHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCIgJiYgIU51bWJlci5pc05hTihpbnB1dCkgJiYgTnVtYmVyLmlzRmluaXRlKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVjZWl2ZWQgPSB0eXBlb2YgaW5wdXQgPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgID8gTnVtYmVyLmlzTmFOKGlucHV0KVxuICAgICAgICAgICAgICAgID8gXCJOYU5cIlxuICAgICAgICAgICAgICAgIDogIU51bWJlci5pc0Zpbml0ZShpbnB1dClcbiAgICAgICAgICAgICAgICAgICAgPyBcIkluZmluaXR5XCJcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIC4uLihyZWNlaXZlZCA/IHsgcmVjZWl2ZWQgfSA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTnVtYmVyRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROdW1iZXJGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNoZWNrcy4kWm9kQ2hlY2tOdW1iZXJGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgICRab2ROdW1iZXIuaW5pdChpbnN0LCBkZWYpOyAvLyBubyBmb3JtYXQgY2hlY2tzXG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQm9vbGVhbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQm9vbGVhblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gcmVnZXhlcy5ib29sZWFuO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gQm9vbGVhbihwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcImJvb2xlYW5cIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEJpZ0ludCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQmlnSW50XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSByZWdleGVzLmJpZ2ludDtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmNvZXJjZSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IEJpZ0ludChwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RCaWdJbnRGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEJpZ0ludEZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY2hlY2tzLiRab2RDaGVja0JpZ0ludEZvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgJFpvZEJpZ0ludC5pbml0KGluc3QsIGRlZik7IC8vIG5vIGZvcm1hdCBjaGVja3Ncbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RTeW1ib2wgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN5bWJvbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzeW1ib2xcIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcInN5bWJvbFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVW5kZWZpbmVkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVbmRlZmluZWRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IHJlZ2V4ZXMudW5kZWZpbmVkO1xuICAgIGluc3QuX3pvZC52YWx1ZXMgPSBuZXcgU2V0KFt1bmRlZmluZWRdKTtcbiAgICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gICAgaW5zdC5fem9kLm9wdG91dCA9IFwib3B0aW9uYWxcIjtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE51bGwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE51bGxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IHJlZ2V4ZXMubnVsbDtcbiAgICBpbnN0Ll96b2QudmFsdWVzID0gbmV3IFNldChbbnVsbF0pO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKGlucHV0ID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibnVsbFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQW55ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RBbnlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCkgPT4gcGF5bG9hZDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVbmtub3duID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQpID0+IHBheWxvYWQ7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTmV2ZXIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJuZXZlclwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVm9pZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVm9pZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcInZvaWRcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZERhdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZERhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gbmV3IERhdGUocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2VycikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBpc0RhdGUgPSBpbnB1dCBpbnN0YW5jZW9mIERhdGU7XG4gICAgICAgIGNvbnN0IGlzVmFsaWREYXRlID0gaXNEYXRlICYmICFOdW1iZXIuaXNOYU4oaW5wdXQuZ2V0VGltZSgpKTtcbiAgICAgICAgaWYgKGlzVmFsaWREYXRlKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgLi4uKGlzRGF0ZSA/IHsgcmVjZWl2ZWQ6IFwiSW52YWxpZCBEYXRlXCIgfSA6IHt9KSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQsIGZpbmFsLCBpbmRleCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhpbmRleCwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbiAgICBmaW5hbC52YWx1ZVtpbmRleF0gPSByZXN1bHQudmFsdWU7XG59XG5leHBvcnQgY29uc3QgJFpvZEFycmF5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RBcnJheVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IEFycmF5KGlucHV0Lmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBpbnB1dFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5lbGVtZW50Ll96b2QucnVuKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaXRlbSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDsgLy9oYW5kbGVBcnJheVJlc3VsdHNBc3luYyhwYXJzZVJlc3VsdHMsIGZpbmFsKTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyZXN1bHQsIGZpbmFsLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZvciBvcHRpb25hbC1vdXQgc2NoZW1hcywgaWdub3JlIGVycm9ycyBvbiBhYnNlbnQga2V5c1xuICAgICAgICBpZiAoaXNPcHRpb25hbE91dCAmJiAhKGtleSBpbiBpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIGZpbmFsLnZhbHVlW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZpbmFsLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gbm9ybWFsaXplRGVmKGRlZikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZWYuc2hhcGUpO1xuICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgIGlmICghZGVmLnNoYXBlPy5ba10/Ll96b2Q/LnRyYWl0cz8uaGFzKFwiJFpvZFR5cGVcIikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGF0IGtleSBcIiR7a31cIjogZXhwZWN0ZWQgYSBab2Qgc2NoZW1hYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgb2tleXMgPSB1dGlsLm9wdGlvbmFsS2V5cyhkZWYuc2hhcGUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZixcbiAgICAgICAga2V5cyxcbiAgICAgICAga2V5U2V0OiBuZXcgU2V0KGtleXMpLFxuICAgICAgICBudW1LZXlzOiBrZXlzLmxlbmd0aCxcbiAgICAgICAgb3B0aW9uYWxLZXlzOiBuZXcgU2V0KG9rZXlzKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gaGFuZGxlQ2F0Y2hhbGwocHJvbXMsIGlucHV0LCBwYXlsb2FkLCBjdHgsIGRlZiwgaW5zdCkge1xuICAgIGNvbnN0IHVucmVjb2duaXplZCA9IFtdO1xuICAgIC8vIGl0ZXJhdGUgb3ZlciBpbnB1dCBrZXlzXG4gICAgY29uc3Qga2V5U2V0ID0gZGVmLmtleVNldDtcbiAgICBjb25zdCBfY2F0Y2hhbGwgPSBkZWYuY2F0Y2hhbGwuX3pvZDtcbiAgICBjb25zdCB0ID0gX2NhdGNoYWxsLmRlZi50eXBlO1xuICAgIGNvbnN0IGlzT3B0aW9uYWxPdXQgPSBfY2F0Y2hhbGwub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgaWYgKGtleVNldC5oYXMoa2V5KSlcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBpZiAodCA9PT0gXCJuZXZlclwiKSB7XG4gICAgICAgICAgICB1bnJlY29nbml6ZWQucHVzaChrZXkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgciA9IF9jYXRjaGFsbC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHByb21zLnB1c2goci50aGVuKChyKSA9PiBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGFuZGxlUHJvcGVydHlSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaXNPcHRpb25hbE91dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVucmVjb2duaXplZC5sZW5ndGgpIHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgICAgICAgICBrZXlzOiB1bnJlY29nbml6ZWQsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoIXByb21zLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgJFpvZE9iamVjdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kT2JqZWN0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyByZXF1aXJlcyBjYXN0IGJlY2F1c2UgdGVjaG5pY2FsbHkgJFpvZE9iamVjdCBkb2Vzbid0IGV4dGVuZFxuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICAvLyBjb25zdCBzaCA9IGRlZi5zaGFwZTtcbiAgICBjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihkZWYsIFwic2hhcGVcIik7XG4gICAgaWYgKCFkZXNjPy5nZXQpIHtcbiAgICAgICAgY29uc3Qgc2ggPSBkZWYuc2hhcGU7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWYsIFwic2hhcGVcIiwge1xuICAgICAgICAgICAgZ2V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U2ggPSB7IC4uLnNoIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlZiwgXCJzaGFwZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXdTaCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3U2g7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgX25vcm1hbGl6ZWQgPSB1dGlsLmNhY2hlZCgoKSA9PiBub3JtYWxpemVEZWYoZGVmKSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSBkZWYuc2hhcGU7XG4gICAgICAgIGNvbnN0IHByb3BWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2hhcGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gc2hhcGVba2V5XS5fem9kO1xuICAgICAgICAgICAgaWYgKGZpZWxkLnZhbHVlcykge1xuICAgICAgICAgICAgICAgIHByb3BWYWx1ZXNba2V5XSA/PyAocHJvcFZhbHVlc1trZXldID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgZmllbGQudmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWVzW2tleV0uYWRkKHYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWVzO1xuICAgIH0pO1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICBjb25zdCBjYXRjaGFsbCA9IGRlZi5jYXRjaGFsbDtcbiAgICBsZXQgdmFsdWU7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICB2YWx1ZSA/PyAodmFsdWUgPSBfbm9ybWFsaXplZC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHt9O1xuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHZhbHVlLnNoYXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZS5rZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBlbCA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsT3V0ID0gZWwuX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBlbC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHIudGhlbigocikgPT4gaGFuZGxlUHJvcGVydHlSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaXNPcHRpb25hbE91dCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZVByb3BlcnR5UmVzdWx0KHIsIHBheWxvYWQsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY2F0Y2hhbGwpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm9tcy5sZW5ndGggPyBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUNhdGNoYWxsKHByb21zLCBpbnB1dCwgcGF5bG9hZCwgY3R4LCBfbm9ybWFsaXplZC52YWx1ZSwgaW5zdCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RPYmplY3RKSVQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE9iamVjdEpJVFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gcmVxdWlyZXMgY2FzdCBiZWNhdXNlIHRlY2huaWNhbGx5ICRab2RPYmplY3QgZG9lc24ndCBleHRlbmRcbiAgICAkWm9kT2JqZWN0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBzdXBlclBhcnNlID0gaW5zdC5fem9kLnBhcnNlO1xuICAgIGNvbnN0IF9ub3JtYWxpemVkID0gdXRpbC5jYWNoZWQoKCkgPT4gbm9ybWFsaXplRGVmKGRlZikpO1xuICAgIGNvbnN0IGdlbmVyYXRlRmFzdHBhc3MgPSAoc2hhcGUpID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gbmV3IERvYyhbXCJzaGFwZVwiLCBcInBheWxvYWRcIiwgXCJjdHhcIl0pO1xuICAgICAgICBjb25zdCBub3JtYWxpemVkID0gX25vcm1hbGl6ZWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHBhcnNlU3RyID0gKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgayA9IHV0aWwuZXNjKGtleSk7XG4gICAgICAgICAgICByZXR1cm4gYHNoYXBlWyR7a31dLl96b2QucnVuKHsgdmFsdWU6IGlucHV0WyR7a31dLCBpc3N1ZXM6IFtdIH0sIGN0eClgO1xuICAgICAgICB9O1xuICAgICAgICBkb2Mud3JpdGUoYGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtgKTtcbiAgICAgICAgY29uc3QgaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBub3JtYWxpemVkLmtleXMpIHtcbiAgICAgICAgICAgIGlkc1trZXldID0gYGtleV8ke2NvdW50ZXIrK31gO1xuICAgICAgICB9XG4gICAgICAgIC8vIEE6IHByZXNlcnZlIGtleSBvcmRlciB7XG4gICAgICAgIGRvYy53cml0ZShgY29uc3QgbmV3UmVzdWx0ID0ge307YCk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG5vcm1hbGl6ZWQua2V5cykge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBpZHNba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB1dGlsLmVzYyhrZXkpO1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWxPdXQgPSBzY2hlbWE/Ll96b2Q/Lm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgICAgICAgICAgZG9jLndyaXRlKGBjb25zdCAke2lkfSA9ICR7cGFyc2VTdHIoa2V5KX07YCk7XG4gICAgICAgICAgICBpZiAoaXNPcHRpb25hbE91dCkge1xuICAgICAgICAgICAgICAgIC8vIEZvciBvcHRpb25hbC1vdXQgc2NoZW1hcywgaWdub3JlIGVycm9ycyBvbiBhYnNlbnQga2V5c1xuICAgICAgICAgICAgICAgIGRvYy53cml0ZShgXG4gICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCR7a30gaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gcGF5bG9hZC5pc3N1ZXMuY29uY2F0KCR7aWR9Lmlzc3Vlcy5tYXAoaXNzID0+ICh7XG4gICAgICAgICAgICAgIC4uLmlzcyxcbiAgICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtrfSwgLi4uaXNzLnBhdGhdIDogWyR7a31dXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCR7aWR9LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgbmV3UmVzdWx0WyR7a31dID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSAke2lkfS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZG9jLndyaXRlKGBcbiAgICAgICAgaWYgKCR7aWR9Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IHBheWxvYWQuaXNzdWVzLmNvbmNhdCgke2lkfS5pc3N1ZXMubWFwKGlzcyA9PiAoe1xuICAgICAgICAgICAgLi4uaXNzLFxuICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtrfSwgLi4uaXNzLnBhdGhdIDogWyR7a31dXG4gICAgICAgICAgfSkpKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKCR7aWR9LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgbmV3UmVzdWx0WyR7a31dID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSAke2lkfS52YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgIGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRvYy53cml0ZShgcGF5bG9hZC52YWx1ZSA9IG5ld1Jlc3VsdDtgKTtcbiAgICAgICAgZG9jLndyaXRlKGByZXR1cm4gcGF5bG9hZDtgKTtcbiAgICAgICAgY29uc3QgZm4gPSBkb2MuY29tcGlsZSgpO1xuICAgICAgICByZXR1cm4gKHBheWxvYWQsIGN0eCkgPT4gZm4oc2hhcGUsIHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbiAgICBsZXQgZmFzdHBhc3M7XG4gICAgY29uc3QgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuICAgIGNvbnN0IGppdCA9ICFjb3JlLmdsb2JhbENvbmZpZy5qaXRsZXNzO1xuICAgIGNvbnN0IGFsbG93c0V2YWwgPSB1dGlsLmFsbG93c0V2YWw7XG4gICAgY29uc3QgZmFzdEVuYWJsZWQgPSBqaXQgJiYgYWxsb3dzRXZhbC52YWx1ZTsgLy8gJiYgIWRlZi5jYXRjaGFsbDtcbiAgICBjb25zdCBjYXRjaGFsbCA9IGRlZi5jYXRjaGFsbDtcbiAgICBsZXQgdmFsdWU7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICB2YWx1ZSA/PyAodmFsdWUgPSBfbm9ybWFsaXplZC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCFpc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGppdCAmJiBmYXN0RW5hYmxlZCAmJiBjdHg/LmFzeW5jID09PSBmYWxzZSAmJiBjdHguaml0bGVzcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gYWx3YXlzIHN5bmNocm9ub3VzXG4gICAgICAgICAgICBpZiAoIWZhc3RwYXNzKVxuICAgICAgICAgICAgICAgIGZhc3RwYXNzID0gZ2VuZXJhdGVGYXN0cGFzcyhkZWYuc2hhcGUpO1xuICAgICAgICAgICAgcGF5bG9hZCA9IGZhc3RwYXNzKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAoIWNhdGNoYWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhdGNoYWxsKFtdLCBpbnB1dCwgcGF5bG9hZCwgY3R4LCB2YWx1ZSwgaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyUGFyc2UocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0cywgZmluYWwsIGluc3QsIGN0eCkge1xuICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmaW5hbC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub25hYm9ydGVkID0gcmVzdWx0cy5maWx0ZXIoKHIpID0+ICF1dGlsLmFib3J0ZWQocikpO1xuICAgIGlmIChub25hYm9ydGVkLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBmaW5hbC52YWx1ZSA9IG5vbmFib3J0ZWRbMF0udmFsdWU7XG4gICAgICAgIHJldHVybiBub25hYm9ydGVkWzBdO1xuICAgIH1cbiAgICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgICAgICBpbnB1dDogZmluYWwudmFsdWUsXG4gICAgICAgIGluc3QsXG4gICAgICAgIGVycm9yczogcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpLFxuICAgIH0pO1xuICAgIHJldHVybiBmaW5hbDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kVW5pb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYub3B0aW9ucy5zb21lKChvKSA9PiBvLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikgPyBcIm9wdGlvbmFsXCIgOiB1bmRlZmluZWQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIikgPyBcIm9wdGlvbmFsXCIgOiB1bmRlZmluZWQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5vcHRpb25zLmV2ZXJ5KChvKSA9PiBvLl96b2QudmFsdWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoZGVmLm9wdGlvbnMuZmxhdE1hcCgob3B0aW9uKSA9PiBBcnJheS5mcm9tKG9wdGlvbi5fem9kLnZhbHVlcykpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgICAgIGlmIChkZWYub3B0aW9ucy5ldmVyeSgobykgPT4gby5fem9kLnBhdHRlcm4pKSB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJucyA9IGRlZi5vcHRpb25zLm1hcCgobykgPT4gby5fem9kLnBhdHRlcm4pO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oJHtwYXR0ZXJucy5tYXAoKHApID0+IHV0aWwuY2xlYW5SZWdleChwLnNvdXJjZSkpLmpvaW4oXCJ8XCIpfSkkYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBjb25zdCBzaW5nbGUgPSBkZWYub3B0aW9ucy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgZmlyc3QgPSBkZWYub3B0aW9uc1swXS5fem9kLnJ1bjtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdChwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhc3luYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZi5vcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlRXhjbHVzaXZlVW5pb25SZXN1bHRzKHJlc3VsdHMsIGZpbmFsLCBpbnN0LCBjdHgpIHtcbiAgICBjb25zdCBzdWNjZXNzZXMgPSByZXN1bHRzLmZpbHRlcigocikgPT4gci5pc3N1ZXMubGVuZ3RoID09PSAwKTtcbiAgICBpZiAoc3VjY2Vzc2VzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBmaW5hbC52YWx1ZSA9IHN1Y2Nlc3Nlc1swXS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgIH1cbiAgICBpZiAoc3VjY2Vzc2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBObyBtYXRjaGVzIC0gc2FtZSBhcyByZWd1bGFyIHVuaW9uXG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgICAgICAgICAgaW5wdXQ6IGZpbmFsLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGVycm9yczogcmVzdWx0cy5tYXAoKHJlc3VsdCkgPT4gcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE11bHRpcGxlIG1hdGNoZXMgLSBleGNsdXNpdmUgdW5pb24gZmFpbHVyZVxuICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdW5pb25cIixcbiAgICAgICAgICAgIGlucHV0OiBmaW5hbC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaW5hbDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kWG9yID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RYb3JcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgZGVmLmluY2x1c2l2ZSA9IGZhbHNlO1xuICAgIGNvbnN0IHNpbmdsZSA9IGRlZi5vcHRpb25zLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBmaXJzdCA9IGRlZi5vcHRpb25zWzBdLl96b2QucnVuO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0KHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzeW5jID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fem9kLnJ1bih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXN5bmMpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXhjbHVzaXZlVW5pb25SZXN1bHRzKHJlc3VsdHMsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlRXhjbHVzaXZlVW5pb25SZXN1bHRzKHJlc3VsdHMsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gXG4vKkBfX1BVUkVfXyovXG5jb3JlLiRjb25zdHJ1Y3RvcihcIiRab2REaXNjcmltaW5hdGVkVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5pbmNsdXNpdmUgPSBmYWxzZTtcbiAgICAkWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IF9zdXBlciA9IGluc3QuX3pvZC5wYXJzZTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBwcm9wVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZi5vcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBwdiA9IG9wdGlvbi5fem9kLnByb3BWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoIXB2IHx8IE9iamVjdC5rZXlzKHB2KS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpc2NyaW1pbmF0ZWQgdW5pb24gb3B0aW9uIGF0IGluZGV4IFwiJHtkZWYub3B0aW9ucy5pbmRleE9mKG9wdGlvbil9XCJgKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHB2KSkge1xuICAgICAgICAgICAgICAgIGlmICghcHJvcFZhbHVlc1trXSlcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlc1trXSA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB2KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZXNba10uYWRkKHZhbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wVmFsdWVzO1xuICAgIH0pO1xuICAgIGNvbnN0IGRpc2MgPSB1dGlsLmNhY2hlZCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBkZWYub3B0aW9ucztcbiAgICAgICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IG8gb2Ygb3B0cykge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gby5fem9kLnByb3BWYWx1ZXM/LltkZWYuZGlzY3JpbWluYXRvcl07XG4gICAgICAgICAgICBpZiAoIXZhbHVlcyB8fCB2YWx1ZXMuc2l6ZSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGlzY3JpbWluYXRlZCB1bmlvbiBvcHRpb24gYXQgaW5kZXggXCIke2RlZi5vcHRpb25zLmluZGV4T2Yobyl9XCJgKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobWFwLmhhcyh2KSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBkaXNjcmltaW5hdG9yIHZhbHVlIFwiJHtTdHJpbmcodil9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFwLnNldCh2LCBvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIXV0aWwuaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdCA9IGRpc2MudmFsdWUuZ2V0KGlucHV0Py5bZGVmLmRpc2NyaW1pbmF0b3JdKTtcbiAgICAgICAgaWYgKG9wdCkge1xuICAgICAgICAgICAgcmV0dXJuIG9wdC5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYudW5pb25GYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIF9zdXBlcihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIG1hdGNoaW5nIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdW5pb25cIixcbiAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICBub3RlOiBcIk5vIG1hdGNoaW5nIGRpc2NyaW1pbmF0b3JcIixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3I6IGRlZi5kaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBwYXRoOiBbZGVmLmRpc2NyaW1pbmF0b3JdLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSW50ZXJzZWN0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVmdCA9IGRlZi5sZWZ0Ll96b2QucnVuKHsgdmFsdWU6IGlucHV0LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gZGVmLnJpZ2h0Ll96b2QucnVuKHsgdmFsdWU6IGlucHV0LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgIGNvbnN0IGFzeW5jID0gbGVmdCBpbnN0YW5jZW9mIFByb21pc2UgfHwgcmlnaHQgaW5zdGFuY2VvZiBQcm9taXNlO1xuICAgICAgICBpZiAoYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbbGVmdCwgcmlnaHRdKS50aGVuKChbbGVmdCwgcmlnaHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocGF5bG9hZCwgbGVmdCwgcmlnaHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocGF5bG9hZCwgbGVmdCwgcmlnaHQpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcbiAgICAvLyBjb25zdCBhVHlwZSA9IHBhcnNlLnQoYSk7XG4gICAgLy8gY29uc3QgYlR5cGUgPSBwYXJzZS50KGIpO1xuICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGlmIChhIGluc3RhbmNlb2YgRGF0ZSAmJiBiIGluc3RhbmNlb2YgRGF0ZSAmJiArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgaWYgKHV0aWwuaXNQbGFpbk9iamVjdChhKSAmJiB1dGlsLmlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgICAgY29uc3QgYktleXMgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IE9iamVjdC5rZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VFcnJvclBhdGg6IFtrZXksIC4uLnNoYXJlZFZhbHVlLm1lcmdlRXJyb3JQYXRoXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lcmdlRXJyb3JQYXRoOiBbXSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZUVycm9yUGF0aDogW2luZGV4LCAuLi5zaGFyZWRWYWx1ZS5tZXJnZUVycm9yUGF0aF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVyZ2VFcnJvclBhdGg6IFtdIH07XG59XG5mdW5jdGlvbiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHJlc3VsdCwgbGVmdCwgcmlnaHQpIHtcbiAgICAvLyBUcmFjayB3aGljaCBzaWRlKHMpIHJlcG9ydCBlYWNoIGtleSBhcyB1bnJlY29nbml6ZWRcbiAgICBjb25zdCB1bnJlY0tleXMgPSBuZXcgTWFwKCk7XG4gICAgbGV0IHVucmVjSXNzdWU7XG4gICAgZm9yIChjb25zdCBpc3Mgb2YgbGVmdC5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpIHtcbiAgICAgICAgICAgIHVucmVjSXNzdWUgPz8gKHVucmVjSXNzdWUgPSBpc3MpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGlzcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bnJlY0tleXMuaGFzKGspKVxuICAgICAgICAgICAgICAgICAgICB1bnJlY0tleXMuc2V0KGssIHt9KTtcbiAgICAgICAgICAgICAgICB1bnJlY0tleXMuZ2V0KGspLmwgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKGlzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBpc3Mgb2YgcmlnaHQuaXNzdWVzKSB7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgaXNzLmtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVucmVjS2V5cy5oYXMoaykpXG4gICAgICAgICAgICAgICAgICAgIHVucmVjS2V5cy5zZXQoaywge30pO1xuICAgICAgICAgICAgICAgIHVucmVjS2V5cy5nZXQoaykuciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaXNzdWVzLnB1c2goaXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBSZXBvcnQgb25seSBrZXlzIHVucmVjb2duaXplZCBieSBCT1RIIHNpZGVzXG4gICAgY29uc3QgYm90aEtleXMgPSBbLi4udW5yZWNLZXlzXS5maWx0ZXIoKFssIGZdKSA9PiBmLmwgJiYgZi5yKS5tYXAoKFtrXSkgPT4gayk7XG4gICAgaWYgKGJvdGhLZXlzLmxlbmd0aCAmJiB1bnJlY0lzc3VlKSB7XG4gICAgICAgIHJlc3VsdC5pc3N1ZXMucHVzaCh7IC4uLnVucmVjSXNzdWUsIGtleXM6IGJvdGhLZXlzIH0pO1xuICAgIH1cbiAgICBpZiAodXRpbC5hYm9ydGVkKHJlc3VsdCkpXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xuICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5tZXJnYWJsZSBpbnRlcnNlY3Rpb24uIEVycm9yIHBhdGg6IGAgKyBgJHtKU09OLnN0cmluZ2lmeShtZXJnZWQubWVyZ2VFcnJvclBhdGgpfWApO1xuICAgIH1cbiAgICByZXN1bHQudmFsdWUgPSBtZXJnZWQuZGF0YTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNvbnN0ICRab2RUdXBsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVHVwbGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBpdGVtcyA9IGRlZi5pdGVtcztcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBbXTtcbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWRJbmRleCA9IFsuLi5pdGVtc10ucmV2ZXJzZSgpLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS5fem9kLm9wdGluICE9PSBcIm9wdGlvbmFsXCIpO1xuICAgICAgICBjb25zdCBvcHRTdGFydCA9IHJldmVyc2VkSW5kZXggPT09IC0xID8gMCA6IGl0ZW1zLmxlbmd0aCAtIHJldmVyc2VkSW5kZXg7XG4gICAgICAgIGlmICghZGVmLnJlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0Lmxlbmd0aCA+IGl0ZW1zLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQubGVuZ3RoIDwgb3B0U3RhcnQgLSAxO1xuICAgICAgICAgICAgaWYgKHRvb0JpZyB8fCB0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAuLi4odG9vQmlnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgY29kZTogXCJ0b29fYmlnXCIsIG1heGltdW06IGl0ZW1zLmxlbmd0aCwgaW5jbHVzaXZlOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyBjb2RlOiBcInRvb19zbWFsbFwiLCBtaW5pbXVtOiBpdGVtcy5sZW5ndGggfSksXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaSA9IC0xO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaXRlbXMpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGlmIChpID49IGlucHV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSBvcHRTdGFydClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVtLl96b2QucnVuKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogaW5wdXRbaV0sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlVHVwbGVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVHVwbGVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnJlc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBpbnB1dC5zbGljZShpdGVtcy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiByZXN0KSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5yZXN0Ll96b2QucnVuKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGVsLFxuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIH0sIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIGZpbmFsLCBpbmRleCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhpbmRleCwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbiAgICBmaW5hbC52YWx1ZVtpbmRleF0gPSByZXN1bHQudmFsdWU7XG59XG5leHBvcnQgY29uc3QgJFpvZFJlY29yZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kUmVjb3JkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghdXRpbC5pc1BsYWluT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBkZWYua2V5VHlwZS5fem9kLnZhbHVlcztcbiAgICAgICAgaWYgKHZhbHVlcykge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVjb3JkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJzeW1ib2xcIikge1xuICAgICAgICAgICAgICAgICAgICByZWNvcmRLZXlzLmFkZCh0eXBlb2Yga2V5ID09PSBcIm51bWJlclwiID8ga2V5LnRvU3RyaW5nKCkgOiBrZXkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYudmFsdWVUeXBlLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHVucmVjb2duaXplZDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWNvcmRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHVucmVjb2duaXplZCA9IHVucmVjb2duaXplZCA/PyBbXTtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWNvZ25pemVkLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5yZWNvZ25pemVkICYmIHVucmVjb2duaXplZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgIGtleXM6IHVucmVjb2duaXplZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIFJlZmxlY3Qub3duS2V5cyhpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBsZXQga2V5UmVzdWx0ID0gZGVmLmtleVR5cGUuX3pvZC5ydW4oeyB2YWx1ZToga2V5LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGtleVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgc2NoZW1hcyBub3Qgc3VwcG9ydGVkIGluIG9iamVjdCBrZXlzIGN1cnJlbnRseVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTnVtZXJpYyBzdHJpbmcgZmFsbGJhY2s6IGlmIGtleSBpcyBhIG51bWVyaWMgc3RyaW5nIGFuZCBmYWlsZWQsIHJldHJ5IHdpdGggTnVtYmVyKGtleSlcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGhhbmRsZXMgei5udW1iZXIoKSwgei5saXRlcmFsKFsxLCAyLCAzXSksIGFuZCB1bmlvbnMgY29udGFpbmluZyBudW1lcmljIGxpdGVyYWxzXG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tOdW1lcmljS2V5ID0gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiByZWdleGVzLm51bWJlci50ZXN0KGtleSkgJiYga2V5UmVzdWx0Lmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrTnVtZXJpY0tleSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeVJlc3VsdCA9IGRlZi5rZXlUeXBlLl96b2QucnVuKHsgdmFsdWU6IE51bWJlcihrZXkpLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHNjaGVtYXMgbm90IHN1cHBvcnRlZCBpbiBvYmplY3Qga2V5cyBjdXJyZW50bHlcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5UmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleVJlc3VsdCA9IHJldHJ5UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChrZXlSZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGVmLm1vZGUgPT09IFwibG9vc2VcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyB0aHJvdWdoIHVuY2hhbmdlZFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZVtrZXldID0gaW5wdXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgXCJzdHJpY3RcIiBiZWhhdmlvcjogZXJyb3Igb24gaW52YWxpZCBrZXlcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9rZXlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW46IFwicmVjb3JkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBrZXlSZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDoga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IFtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLnZhbHVlVHlwZS5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZVtrZXlSZXN1bHQudmFsdWVdID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZVtrZXlSZXN1bHQudmFsdWVdID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RNYXAgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE1hcFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIE1hcCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcIm1hcFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleVJlc3VsdCA9IGRlZi5rZXlUeXBlLl96b2QucnVuKHsgdmFsdWU6IGtleSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVSZXN1bHQgPSBkZWYudmFsdWVUeXBlLl96b2QucnVuKHsgdmFsdWU6IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAoa2V5UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCB2YWx1ZVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKFByb21pc2UuYWxsKFtrZXlSZXN1bHQsIHZhbHVlUmVzdWx0XSkudGhlbigoW2tleVJlc3VsdCwgdmFsdWVSZXN1bHRdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU1hcFJlc3VsdChrZXlSZXN1bHQsIHZhbHVlUmVzdWx0LCBwYXlsb2FkLCBrZXksIGlucHV0LCBpbnN0LCBjdHgpO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZU1hcFJlc3VsdChrZXlSZXN1bHQsIHZhbHVlUmVzdWx0LCBwYXlsb2FkLCBrZXksIGlucHV0LCBpbnN0LCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU1hcFJlc3VsdChrZXlSZXN1bHQsIHZhbHVlUmVzdWx0LCBmaW5hbCwga2V5LCBpbnB1dCwgaW5zdCwgY3R4KSB7XG4gICAgaWYgKGtleVJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1dGlsLnByb3BlcnR5S2V5VHlwZXMuaGFzKHR5cGVvZiBrZXkpKSB7XG4gICAgICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIGtleVJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfa2V5XCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm1hcFwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBrZXlSZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWx1ZVJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh1dGlsLnByb3BlcnR5S2V5VHlwZXMuaGFzKHR5cGVvZiBrZXkpKSB7XG4gICAgICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHZhbHVlUmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJtYXBcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZWxlbWVudFwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgaXNzdWVzOiB2YWx1ZVJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluYWwudmFsdWUuc2V0KGtleVJlc3VsdC52YWx1ZSwgdmFsdWVSZXN1bHQudmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RTZXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFNldFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIShpbnB1dCBpbnN0YW5jZW9mIFNldCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic2V0XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG5ldyBTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYudmFsdWVUeXBlLl96b2QucnVuKHsgdmFsdWU6IGl0ZW0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVTZXRSZXN1bHQocmVzdWx0LCBwYXlsb2FkKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGhhbmRsZVNldFJlc3VsdChyZXN1bHQsIHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVNldFJlc3VsdChyZXN1bHQsIGZpbmFsKSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5pc3N1ZXMpO1xuICAgIH1cbiAgICBmaW5hbC52YWx1ZS5hZGQocmVzdWx0LnZhbHVlKTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kRW51bSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRW51bVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IHZhbHVlcyA9IHV0aWwuZ2V0RW51bVZhbHVlcyhkZWYuZW50cmllcyk7XG4gICAgY29uc3QgdmFsdWVzU2V0ID0gbmV3IFNldCh2YWx1ZXMpO1xuICAgIGluc3QuX3pvZC52YWx1ZXMgPSB2YWx1ZXNTZXQ7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeKCR7dmFsdWVzXG4gICAgICAgIC5maWx0ZXIoKGspID0+IHV0aWwucHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGspKVxuICAgICAgICAubWFwKChvKSA9PiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyB1dGlsLmVzY2FwZVJlZ2V4KG8pIDogby50b1N0cmluZygpKSlcbiAgICAgICAgLmpvaW4oXCJ8XCIpfSkkYCk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodmFsdWVzU2V0LmhhcyhpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZExpdGVyYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZExpdGVyYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpZiAoZGVmLnZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGNyZWF0ZSBsaXRlcmFsIHNjaGVtYSB3aXRoIG5vIHZhbGlkIHZhbHVlc1wiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gbmV3IFNldChkZWYudmFsdWVzKTtcbiAgICBpbnN0Ll96b2QudmFsdWVzID0gdmFsdWVzO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gbmV3IFJlZ0V4cChgXigke2RlZi52YWx1ZXNcbiAgICAgICAgLm1hcCgobykgPT4gKHR5cGVvZiBvID09PSBcInN0cmluZ1wiID8gdXRpbC5lc2NhcGVSZWdleChvKSA6IG8gPyB1dGlsLmVzY2FwZVJlZ2V4KG8udG9TdHJpbmcoKSkgOiBTdHJpbmcobykpKVxuICAgICAgICAuam9pbihcInxcIil9KSRgKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZXMuaGFzKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICAgICAgICAgIHZhbHVlczogZGVmLnZhbHVlcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRmlsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRmlsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBGaWxlKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiZmlsZVwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVHJhbnNmb3JtID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RUcmFuc2Zvcm1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RFbmNvZGVFcnJvcihpbnN0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF9vdXQgPSBkZWYudHJhbnNmb3JtKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICAgICAgICBpZiAoY3R4LmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSA/IF9vdXQgOiBQcm9taXNlLnJlc29sdmUoX291dCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX291dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IF9vdXQ7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgaW5wdXQpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggJiYgaW5wdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4geyBpc3N1ZXM6IFtdLCB2YWx1ZTogdW5kZWZpbmVkIH07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgJFpvZE9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgICBpbnN0Ll96b2Qub3B0b3V0ID0gXCJvcHRpb25hbFwiO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyBuZXcgU2V0KFsuLi5kZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzLCB1bmRlZmluZWRdKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm47XG4gICAgICAgIHJldHVybiBwYXR0ZXJuID8gbmV3IFJlZ0V4cChgXigke3V0aWwuY2xlYW5SZWdleChwYXR0ZXJuLnNvdXJjZSl9KT8kYCkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmlubmVyVHlwZS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocikgPT4gaGFuZGxlT3B0aW9uYWxSZXN1bHQociwgcGF5bG9hZC52YWx1ZSkpO1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgcGF5bG9hZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEV4YWN0T3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEV4YWN0T3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIENhbGwgcGFyZW50IGluaXQgLSBpbmhlcml0cyBvcHRpbi9vcHRvdXQgPSBcIm9wdGlvbmFsXCJcbiAgICAkWm9kT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIC8vIE92ZXJyaWRlIHZhbHVlcy9wYXR0ZXJuIHRvIE5PVCBhZGQgdW5kZWZpbmVkXG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuKTtcbiAgICAvLyBPdmVycmlkZSBwYXJzZSB0byBqdXN0IGRlbGVnYXRlIChubyB1bmRlZmluZWQgaGFuZGxpbmcpXG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTnVsbGFibGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE51bGxhYmxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBkZWYuaW5uZXJUeXBlLl96b2QucGF0dGVybjtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPyBuZXcgUmVnRXhwKGBeKCR7dXRpbC5jbGVhblJlZ2V4KHBhdHRlcm4uc291cmNlKX18bnVsbCkkYCkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyA/IG5ldyBTZXQoWy4uLmRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMsIG51bGxdKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIC8vIEZvcndhcmQgZGlyZWN0aW9uIChkZWNvZGUpOiBhbGxvdyBudWxsIHRvIHBhc3MgdGhyb3VnaFxuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRGVmYXVsdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRGVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIC8vIGluc3QuX3pvZC5xaW4gPSBcInRydWVcIjtcbiAgICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcndhcmQgZGlyZWN0aW9uIChkZWNvZGUpOiBhcHBseSBkZWZhdWx0cyBmb3IgdW5kZWZpbmVkIGlucHV0XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAkWm9kRGVmYXVsdCByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGltbWVkaWF0ZWx5IGluIGZvcndhcmQgZGlyZWN0aW9uLlxuICAgICAgICAgICAgICogSXQgZG9lc24ndCBwYXNzIHRoZSBkZWZhdWx0IHZhbHVlIGludG8gdGhlIHZhbGlkYXRvciAoXCJwcmVmYXVsdFwiKS4gVGhlcmUncyBubyByZWFzb24gdG8gcGFzcyB0aGUgZGVmYXVsdCB2YWx1ZSB0aHJvdWdoIHZhbGlkYXRpb24uIFRoZSB2YWxpZGl0eSBvZiB0aGUgZGVmYXVsdCBpcyBlbmZvcmNlZCBieSBUeXBlU2NyaXB0IHN0YXRpY2FsbHkuIE90aGVyd2lzZSwgaXQncyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgdGhlIHVzZXIgdG8gZW5zdXJlIHRoZSBkZWZhdWx0IGlzIHZhbGlkLiBJbiB0aGUgY2FzZSBvZiBwaXBlcyB3aXRoIGRpdmVyZ2VudCBpbi9vdXQgdHlwZXMsIHlvdSBjYW4gc3BlY2lmeSB0aGUgZGVmYXVsdCBvbiB0aGUgYGluYCBzY2hlbWEgb2YgeW91ciBab2RQaXBlIHRvIHNldCBhIFwicHJlZmF1bHRcIiBmb3IgdGhlIHBpcGUuICAgKi9cbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcndhcmQgZGlyZWN0aW9uOiBjb250aW51ZSB3aXRoIGRlZmF1bHQgaGFuZGxpbmdcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZURlZmF1bHRSZXN1bHQocmVzdWx0LCBkZWYpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQsIGRlZik7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlRGVmYXVsdFJlc3VsdChwYXlsb2FkLCBkZWYpIHtcbiAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kUHJlZmF1bHQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3J3YXJkIGRpcmVjdGlvbiAoZGVjb2RlKTogYXBwbHkgcHJlZmF1bHQgZm9yIHVuZGVmaW5lZCBpbnB1dFxuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTm9uT3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE5vbk9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcztcbiAgICAgICAgcmV0dXJuIHYgPyBuZXcgU2V0KFsuLi52XS5maWx0ZXIoKHgpID0+IHggIT09IHVuZGVmaW5lZCkpIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgaW5zdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVOb25PcHRpb25hbFJlc3VsdChyZXN1bHQsIGluc3QpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHBheWxvYWQsIGluc3QpIHtcbiAgICBpZiAoIXBheWxvYWQuaXNzdWVzLmxlbmd0aCAmJiBwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xufVxuZXhwb3J0IGNvbnN0ICRab2RTdWNjZXNzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RTdWNjZXNzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kRW5jb2RlRXJyb3IoXCJab2RTdWNjZXNzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENhdGNoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDYXRjaFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdGluKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb24gKGRlY29kZSk6IGFwcGx5IGNhdGNoIGxvZ2ljXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE5hTiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTmFOXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlICE9PSBcIm51bWJlclwiIHx8ICFOdW1iZXIuaXNOYU4ocGF5bG9hZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmFuXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RQaXBlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RQaXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmluLl96b2QudmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbi5fem9kLm9wdGluKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3V0Ll96b2Qub3B0b3V0KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gZGVmLmluLl96b2QucHJvcFZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGRlZi5vdXQuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQudGhlbigocmlnaHQpID0+IGhhbmRsZVBpcGVSZXN1bHQocmlnaHQsIGRlZi5pbiwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGlwZVJlc3VsdChyaWdodCwgZGVmLmluLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkZWYuaW4uX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdC50aGVuKChsZWZ0KSA9PiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIGRlZi5vdXQsIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIGRlZi5vdXQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUGlwZVJlc3VsdChsZWZ0LCBuZXh0LCBjdHgpIHtcbiAgICBpZiAobGVmdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByZXZlbnQgZnVydGhlciBjaGVja3NcbiAgICAgICAgbGVmdC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0Ll96b2QucnVuKHsgdmFsdWU6IGxlZnQudmFsdWUsIGlzc3VlczogbGVmdC5pc3N1ZXMgfSwgY3R4KTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kQ29kZWMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENvZGVjXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmluLl96b2QudmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbi5fem9kLm9wdGluKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3V0Ll96b2Qub3B0b3V0KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gZGVmLmluLl96b2QucHJvcFZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBjdHguZGlyZWN0aW9uIHx8IFwiZm9yd2FyZFwiO1xuICAgICAgICBpZiAoZGlyZWN0aW9uID09PSBcImZvcndhcmRcIikge1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IGRlZi5pbi5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxlZnQudGhlbigobGVmdCkgPT4gaGFuZGxlQ29kZWNBUmVzdWx0KGxlZnQsIGRlZiwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ29kZWNBUmVzdWx0KGxlZnQsIGRlZiwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZGVmLm91dC5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodC50aGVuKChyaWdodCkgPT4gaGFuZGxlQ29kZWNBUmVzdWx0KHJpZ2h0LCBkZWYsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNvZGVjQVJlc3VsdChyaWdodCwgZGVmLCBjdHgpO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlQ29kZWNBUmVzdWx0KHJlc3VsdCwgZGVmLCBjdHgpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcHJldmVudCBmdXJ0aGVyIGNoZWNrc1xuICAgICAgICByZXN1bHQuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGN0eC5kaXJlY3Rpb24gfHwgXCJmb3J3YXJkXCI7XG4gICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBkZWYudHJhbnNmb3JtKHJlc3VsdC52YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkLnRoZW4oKHZhbHVlKSA9PiBoYW5kbGVDb2RlY1R4UmVzdWx0KHJlc3VsdCwgdmFsdWUsIGRlZi5vdXQsIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVDb2RlY1R4UmVzdWx0KHJlc3VsdCwgdHJhbnNmb3JtZWQsIGRlZi5vdXQsIGN0eCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IGRlZi5yZXZlcnNlVHJhbnNmb3JtKHJlc3VsdC52YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybWVkIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVkLnRoZW4oKHZhbHVlKSA9PiBoYW5kbGVDb2RlY1R4UmVzdWx0KHJlc3VsdCwgdmFsdWUsIGRlZi5pbiwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB0cmFuc2Zvcm1lZCwgZGVmLmluLCBjdHgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGhhbmRsZUNvZGVjVHhSZXN1bHQobGVmdCwgdmFsdWUsIG5leHRTY2hlbWEsIGN0eCkge1xuICAgIC8vIENoZWNrIGlmIHRyYW5zZm9ybSBhZGRlZCBhbnkgaXNzdWVzXG4gICAgaWYgKGxlZnQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBsZWZ0LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHRTY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBsZWZ0Lmlzc3VlcyB9LCBjdHgpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RSZWFkb25seSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kUmVhZG9ubHlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnByb3BWYWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZT8uX3pvZD8ub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGU/Ll96b2Q/Lm9wdG91dCk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbihoYW5kbGVSZWFkb25seVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlYWRvbmx5UmVzdWx0KHJlc3VsdCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUmVhZG9ubHlSZXN1bHQocGF5bG9hZCkge1xuICAgIHBheWxvYWQudmFsdWUgPSBPYmplY3QuZnJlZXplKHBheWxvYWQudmFsdWUpO1xuICAgIHJldHVybiBwYXlsb2FkO1xufVxuZXhwb3J0IGNvbnN0ICRab2RUZW1wbGF0ZUxpdGVyYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFRlbXBsYXRlTGl0ZXJhbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IHJlZ2V4UGFydHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhcnQgb2YgZGVmLnBhcnRzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFydCA9PT0gXCJvYmplY3RcIiAmJiBwYXJ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBpcyBab2Qgc2NoZW1hXG4gICAgICAgICAgICBpZiAoIXBhcnQuX3pvZC5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlIGxpdGVyYWwgcGFydCwgbm8gcGF0dGVybiBmb3VuZDogJHtbLi4ucGFydC5fem9kLnRyYWl0c10uc2hpZnQoKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IHBhcnQuX3pvZC5wYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwID8gcGFydC5fem9kLnBhdHRlcm4uc291cmNlIDogcGFydC5fem9kLnBhdHRlcm47XG4gICAgICAgICAgICBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVtcGxhdGUgbGl0ZXJhbCBwYXJ0OiAke3BhcnQuX3pvZC50cmFpdHN9YCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHNvdXJjZS5zdGFydHNXaXRoKFwiXlwiKSA/IDEgOiAwO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gc291cmNlLmVuZHNXaXRoKFwiJFwiKSA/IHNvdXJjZS5sZW5ndGggLSAxIDogc291cmNlLmxlbmd0aDtcbiAgICAgICAgICAgIHJlZ2V4UGFydHMucHVzaChzb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHBhcnQgPT09IG51bGwgfHwgdXRpbC5wcmltaXRpdmVUeXBlcy5oYXModHlwZW9mIHBhcnQpKSB7XG4gICAgICAgICAgICByZWdleFBhcnRzLnB1c2godXRpbC5lc2NhcGVSZWdleChgJHtwYXJ0fWApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZW1wbGF0ZSBsaXRlcmFsIHBhcnQ6ICR7cGFydH1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IG5ldyBSZWdFeHAoYF4ke3JlZ2V4UGFydHMuam9pbihcIlwiKX0kYCk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGluc3QuX3pvZC5wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmICghaW5zdC5fem9kLnBhdHRlcm4udGVzdChwYXlsb2FkLnZhbHVlKSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBkZWYuZm9ybWF0ID8/IFwidGVtcGxhdGVfbGl0ZXJhbFwiLFxuICAgICAgICAgICAgICAgIHBhdHRlcm46IGluc3QuX3pvZC5wYXR0ZXJuLnNvdXJjZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RGdW5jdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRnVuY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll9kZWYgPSBkZWY7XG4gICAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgICBpbnN0LmltcGxlbWVudCA9IChmdW5jKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnQoKSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gaW5zdC5fZGVmLmlucHV0ID8gcGFyc2UoaW5zdC5fZGVmLmlucHV0LCBhcmdzKSA6IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBSZWZsZWN0LmFwcGx5KGZ1bmMsIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgaWYgKGluc3QuX2RlZi5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2UoaW5zdC5fZGVmLm91dHB1dCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpbnN0LmltcGxlbWVudEFzeW5jID0gKGZ1bmMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcGxlbWVudEFzeW5jKCkgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGluc3QuX2RlZi5pbnB1dCA/IGF3YWl0IHBhcnNlQXN5bmMoaW5zdC5fZGVmLmlucHV0LCBhcmdzKSA6IGFyZ3M7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBSZWZsZWN0LmFwcGx5KGZ1bmMsIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgaWYgKGluc3QuX2RlZi5vdXRwdXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgcGFyc2VBc3luYyhpbnN0Ll9kZWYub3V0cHV0LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC52YWx1ZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgb3V0cHV0IGlzIGEgcHJvbWlzZSB0eXBlIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGQgdXNlIGFzeW5jIGltcGxlbWVudGF0aW9uXG4gICAgICAgIGNvbnN0IGhhc1Byb21pc2VPdXRwdXQgPSBpbnN0Ll9kZWYub3V0cHV0ICYmIGluc3QuX2RlZi5vdXRwdXQuX3pvZC5kZWYudHlwZSA9PT0gXCJwcm9taXNlXCI7XG4gICAgICAgIGlmIChoYXNQcm9taXNlT3V0cHV0KSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gaW5zdC5pbXBsZW1lbnRBc3luYyhwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBpbnN0LmltcGxlbWVudChwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xuICAgIGluc3QuaW5wdXQgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCBGID0gaW5zdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnc1swXSkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRih7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBuZXcgJFpvZFR1cGxlKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICAgICAgICAgICAgICBpdGVtczogYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgcmVzdDogYXJnc1sxXSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IGluc3QuX2RlZi5vdXRwdXQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEYoe1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgaW5wdXQ6IGFyZ3NbMF0sXG4gICAgICAgICAgICBvdXRwdXQ6IGluc3QuX2RlZi5vdXRwdXQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaW5zdC5vdXRwdXQgPSAob3V0cHV0KSA9PiB7XG4gICAgICAgIGNvbnN0IEYgPSBpbnN0LmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IEYoe1xuICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgaW5wdXQ6IGluc3QuX2RlZi5pbnB1dCxcbiAgICAgICAgICAgIG91dHB1dCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RQcm9taXNlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RQcm9taXNlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBheWxvYWQudmFsdWUpLnRoZW4oKGlubmVyKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHsgdmFsdWU6IGlubmVyLCBpc3N1ZXM6IFtdIH0sIGN0eCkpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTGF6eSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTGF6eVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIC8vIGxldCBfaW5uZXJUeXBlITogYW55O1xuICAgIC8vIHV0aWwuZGVmaW5lTGF6eShkZWYsIFwiZ2V0dGVyXCIsICgpID0+IHtcbiAgICAvLyAgIGlmICghX2lubmVyVHlwZSkge1xuICAgIC8vICAgICBfaW5uZXJUeXBlID0gZGVmLmdldHRlcigpO1xuICAgIC8vICAgfVxuICAgIC8vICAgcmV0dXJuICgpID0+IF9pbm5lclR5cGU7XG4gICAgLy8gfSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJpbm5lclR5cGVcIiwgKCkgPT4gZGVmLmdldHRlcigpKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4gaW5zdC5fem9kLmlubmVyVHlwZT8uX3pvZD8ucGF0dGVybik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IGluc3QuX3pvZC5pbm5lclR5cGU/Ll96b2Q/LnByb3BWYWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gaW5zdC5fem9kLmlubmVyVHlwZT8uX3pvZD8ub3B0aW4gPz8gdW5kZWZpbmVkKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBpbnN0Ll96b2QuaW5uZXJUeXBlPy5fem9kPy5vcHRvdXQgPz8gdW5kZWZpbmVkKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlubmVyID0gaW5zdC5fem9kLmlubmVyVHlwZTtcbiAgICAgICAgcmV0dXJuIGlubmVyLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDdXN0b20gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEN1c3RvbVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY2hlY2tzLiRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfKSA9PiB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCByID0gZGVmLmZuKGlucHV0KTtcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiBoYW5kbGVSZWZpbmVSZXN1bHQociwgcGF5bG9hZCwgaW5wdXQsIGluc3QpKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVSZWZpbmVSZXN1bHQociwgcGF5bG9hZCwgaW5wdXQsIGluc3QpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUmVmaW5lUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaW5wdXQsIGluc3QpIHtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICBjb25zdCBfaXNzID0ge1xuICAgICAgICAgICAgY29kZTogXCJjdXN0b21cIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCwgLy8gaW5jb3Jwb3JhdGVzIHBhcmFtcy5lcnJvciBpbnRvIGlzc3VlIHJlcG9ydGluZ1xuICAgICAgICAgICAgcGF0aDogWy4uLihpbnN0Ll96b2QuZGVmLnBhdGggPz8gW10pXSwgLy8gaW5jb3Jwb3JhdGVzIHBhcmFtcy5lcnJvciBpbnRvIGlzc3VlIHJlcG9ydGluZ1xuICAgICAgICAgICAgY29udGludWU6ICFpbnN0Ll96b2QuZGVmLmFib3J0LFxuICAgICAgICAgICAgLy8gcGFyYW1zOiBpbnN0Ll96b2QuZGVmLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGluc3QuX3pvZC5kZWYucGFyYW1zKVxuICAgICAgICAgICAgX2lzcy5wYXJhbXMgPSBpbnN0Ll96b2QuZGVmLnBhcmFtcztcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKF9pc3MpKTtcbiAgICB9XG59XG4iLCAiaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi4vY29yZS91dGlsLmpzXCI7XG5jb25zdCBlcnJvciA9ICgpID0+IHtcbiAgICBjb25zdCBTaXphYmxlID0ge1xuICAgICAgICBzdHJpbmc6IHsgdW5pdDogXCJjaGFyYWN0ZXJzXCIsIHZlcmI6IFwidG8gaGF2ZVwiIH0sXG4gICAgICAgIGZpbGU6IHsgdW5pdDogXCJieXRlc1wiLCB2ZXJiOiBcInRvIGhhdmVcIiB9LFxuICAgICAgICBhcnJheTogeyB1bml0OiBcIml0ZW1zXCIsIHZlcmI6IFwidG8gaGF2ZVwiIH0sXG4gICAgICAgIHNldDogeyB1bml0OiBcIml0ZW1zXCIsIHZlcmI6IFwidG8gaGF2ZVwiIH0sXG4gICAgICAgIG1hcDogeyB1bml0OiBcImVudHJpZXNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFNpemluZyhvcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuIFNpemFibGVbb3JpZ2luXSA/PyBudWxsO1xuICAgIH1cbiAgICBjb25zdCBGb3JtYXREaWN0aW9uYXJ5ID0ge1xuICAgICAgICByZWdleDogXCJpbnB1dFwiLFxuICAgICAgICBlbWFpbDogXCJlbWFpbCBhZGRyZXNzXCIsXG4gICAgICAgIHVybDogXCJVUkxcIixcbiAgICAgICAgZW1vamk6IFwiZW1vamlcIixcbiAgICAgICAgdXVpZDogXCJVVUlEXCIsXG4gICAgICAgIHV1aWR2NDogXCJVVUlEdjRcIixcbiAgICAgICAgdXVpZHY2OiBcIlVVSUR2NlwiLFxuICAgICAgICBuYW5vaWQ6IFwibmFub2lkXCIsXG4gICAgICAgIGd1aWQ6IFwiR1VJRFwiLFxuICAgICAgICBjdWlkOiBcImN1aWRcIixcbiAgICAgICAgY3VpZDI6IFwiY3VpZDJcIixcbiAgICAgICAgdWxpZDogXCJVTElEXCIsXG4gICAgICAgIHhpZDogXCJYSURcIixcbiAgICAgICAga3N1aWQ6IFwiS1NVSURcIixcbiAgICAgICAgZGF0ZXRpbWU6IFwiSVNPIGRhdGV0aW1lXCIsXG4gICAgICAgIGRhdGU6IFwiSVNPIGRhdGVcIixcbiAgICAgICAgdGltZTogXCJJU08gdGltZVwiLFxuICAgICAgICBkdXJhdGlvbjogXCJJU08gZHVyYXRpb25cIixcbiAgICAgICAgaXB2NDogXCJJUHY0IGFkZHJlc3NcIixcbiAgICAgICAgaXB2NjogXCJJUHY2IGFkZHJlc3NcIixcbiAgICAgICAgbWFjOiBcIk1BQyBhZGRyZXNzXCIsXG4gICAgICAgIGNpZHJ2NDogXCJJUHY0IHJhbmdlXCIsXG4gICAgICAgIGNpZHJ2NjogXCJJUHY2IHJhbmdlXCIsXG4gICAgICAgIGJhc2U2NDogXCJiYXNlNjQtZW5jb2RlZCBzdHJpbmdcIixcbiAgICAgICAgYmFzZTY0dXJsOiBcImJhc2U2NHVybC1lbmNvZGVkIHN0cmluZ1wiLFxuICAgICAgICBqc29uX3N0cmluZzogXCJKU09OIHN0cmluZ1wiLFxuICAgICAgICBlMTY0OiBcIkUuMTY0IG51bWJlclwiLFxuICAgICAgICBqd3Q6IFwiSldUXCIsXG4gICAgICAgIHRlbXBsYXRlX2xpdGVyYWw6IFwiaW5wdXRcIixcbiAgICB9O1xuICAgIC8vIHR5cGUgbmFtZXM6IG1pc3Npbmcga2V5cyA9IGRvIG5vdCB0cmFuc2xhdGUgKHVzZSByYXcgdmFsdWUgdmlhID8/IGZhbGxiYWNrKVxuICAgIGNvbnN0IFR5cGVEaWN0aW9uYXJ5ID0ge1xuICAgICAgICAvLyBDb21wYXRpYmlsaXR5OiBcIm5hblwiIC0+IFwiTmFOXCIgZm9yIGRpc3BsYXlcbiAgICAgICAgbmFuOiBcIk5hTlwiLFxuICAgICAgICAvLyBBbGwgb3RoZXIgdHlwZSBuYW1lcyBvbWl0dGVkIC0gdGhleSBmYWxsIGJhY2sgdG8gcmF3IHZhbHVlcyB2aWEgPz8gb3BlcmF0b3JcbiAgICB9O1xuICAgIHJldHVybiAoaXNzdWUpID0+IHtcbiAgICAgICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF90eXBlXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZCA9IFR5cGVEaWN0aW9uYXJ5W2lzc3VlLmV4cGVjdGVkXSA/PyBpc3N1ZS5leHBlY3RlZDtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXZlZFR5cGUgPSB1dGlsLnBhcnNlZFR5cGUoaXNzdWUuaW5wdXQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkID0gVHlwZURpY3Rpb25hcnlbcmVjZWl2ZWRUeXBlXSA/PyByZWNlaXZlZFR5cGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGlucHV0OiBleHBlY3RlZCAke2V4cGVjdGVkfSwgcmVjZWl2ZWQgJHtyZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfdmFsdWVcIjpcbiAgICAgICAgICAgICAgICBpZiAoaXNzdWUudmFsdWVzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGlucHV0OiBleHBlY3RlZCAke3V0aWwuc3RyaW5naWZ5UHJpbWl0aXZlKGlzc3VlLnZhbHVlc1swXSl9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgb3B0aW9uOiBleHBlY3RlZCBvbmUgb2YgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUudmFsdWVzLCBcInxcIil9YDtcbiAgICAgICAgICAgIGNhc2UgXCJ0b29fYmlnXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGogPSBpc3N1ZS5pbmNsdXNpdmUgPyBcIjw9XCIgOiBcIjxcIjtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXppbmcgPSBnZXRTaXppbmcoaXNzdWUub3JpZ2luKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6aW5nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFRvbyBiaWc6IGV4cGVjdGVkICR7aXNzdWUub3JpZ2luID8/IFwidmFsdWVcIn0gdG8gaGF2ZSAke2Fkan0ke2lzc3VlLm1heGltdW0udG9TdHJpbmcoKX0gJHtzaXppbmcudW5pdCA/PyBcImVsZW1lbnRzXCJ9YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYFRvbyBiaWc6IGV4cGVjdGVkICR7aXNzdWUub3JpZ2luID8/IFwidmFsdWVcIn0gdG8gYmUgJHthZGp9JHtpc3N1ZS5tYXhpbXVtLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0b29fc21hbGxcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkaiA9IGlzc3VlLmluY2x1c2l2ZSA/IFwiPj1cIiA6IFwiPlwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemluZyA9IGdldFNpemluZyhpc3N1ZS5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChzaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBUb28gc21hbGw6IGV4cGVjdGVkICR7aXNzdWUub3JpZ2lufSB0byBoYXZlICR7YWRqfSR7aXNzdWUubWluaW11bS50b1N0cmluZygpfSAke3NpemluZy51bml0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBgVG9vIHNtYWxsOiBleHBlY3RlZCAke2lzc3VlLm9yaWdpbn0gdG8gYmUgJHthZGp9JHtpc3N1ZS5taW5pbXVtLnRvU3RyaW5nKCl9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2Zvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWU7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mb3JtYXQgPT09IFwic3RhcnRzX3dpdGhcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgc3RyaW5nOiBtdXN0IHN0YXJ0IHdpdGggXCIke19pc3N1ZS5wcmVmaXh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZvcm1hdCA9PT0gXCJlbmRzX3dpdGhcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHN0cmluZzogbXVzdCBlbmQgd2l0aCBcIiR7X2lzc3VlLnN1ZmZpeH1cImA7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mb3JtYXQgPT09IFwiaW5jbHVkZXNcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHN0cmluZzogbXVzdCBpbmNsdWRlIFwiJHtfaXNzdWUuaW5jbHVkZXN9XCJgO1xuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZm9ybWF0ID09PSBcInJlZ2V4XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBzdHJpbmc6IG11c3QgbWF0Y2ggcGF0dGVybiAke19pc3N1ZS5wYXR0ZXJufWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkICR7Rm9ybWF0RGljdGlvbmFyeVtfaXNzdWUuZm9ybWF0XSA/PyBpc3N1ZS5mb3JtYXR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJub3RfbXVsdGlwbGVfb2ZcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgbnVtYmVyOiBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5kaXZpc29yfWA7XG4gICAgICAgICAgICBjYXNlIFwidW5yZWNvZ25pemVkX2tleXNcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYFVucmVjb2duaXplZCBrZXkke2lzc3VlLmtleXMubGVuZ3RoID4gMSA/IFwic1wiIDogXCJcIn06ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2tleVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBrZXkgaW4gJHtpc3N1ZS5vcmlnaW59YDtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3VuaW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfZWxlbWVudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCB2YWx1ZSBpbiAke2lzc3VlLm9yaWdpbn1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbG9jYWxlRXJyb3I6IGVycm9yKCksXG4gICAgfTtcbn1cbiIsICJ2YXIgX2E7XG5leHBvcnQgY29uc3QgJG91dHB1dCA9IFN5bWJvbChcIlpvZE91dHB1dFwiKTtcbmV4cG9ydCBjb25zdCAkaW5wdXQgPSBTeW1ib2woXCJab2RJbnB1dFwiKTtcbmV4cG9ydCBjbGFzcyAkWm9kUmVnaXN0cnkge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9pZG1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgYWRkKHNjaGVtYSwgLi4uX21ldGEpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IF9tZXRhWzBdO1xuICAgICAgICB0aGlzLl9tYXAuc2V0KHNjaGVtYSwgbWV0YSk7XG4gICAgICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pZG1hcC5zZXQobWV0YS5pZCwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX2lkbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlKHNjaGVtYSkge1xuICAgICAgICBjb25zdCBtZXRhID0gdGhpcy5fbWFwLmdldChzY2hlbWEpO1xuICAgICAgICBpZiAobWV0YSAmJiB0eXBlb2YgbWV0YSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gbWV0YSkge1xuICAgICAgICAgICAgdGhpcy5faWRtYXAuZGVsZXRlKG1ldGEuaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21hcC5kZWxldGUoc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGdldChzY2hlbWEpIHtcbiAgICAgICAgLy8gcmV0dXJuIHRoaXMuX21hcC5nZXQoc2NoZW1hKSBhcyBhbnk7XG4gICAgICAgIC8vIGluaGVyaXQgbWV0YWRhdGFcbiAgICAgICAgY29uc3QgcCA9IHNjaGVtYS5fem9kLnBhcmVudDtcbiAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHBtID0geyAuLi4odGhpcy5nZXQocCkgPz8ge30pIH07XG4gICAgICAgICAgICBkZWxldGUgcG0uaWQ7IC8vIGRvIG5vdCBpbmhlcml0IGlkXG4gICAgICAgICAgICBjb25zdCBmID0geyAuLi5wbSwgLi4udGhpcy5fbWFwLmdldChzY2hlbWEpIH07XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZikubGVuZ3RoID8gZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmdldChzY2hlbWEpO1xuICAgIH1cbiAgICBoYXMoc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuaGFzKHNjaGVtYSk7XG4gICAgfVxufVxuLy8gcmVnaXN0cmllc1xuZXhwb3J0IGZ1bmN0aW9uIHJlZ2lzdHJ5KCkge1xuICAgIHJldHVybiBuZXcgJFpvZFJlZ2lzdHJ5KCk7XG59XG4oX2EgPSBnbG9iYWxUaGlzKS5fX3pvZF9nbG9iYWxSZWdpc3RyeSA/PyAoX2EuX196b2RfZ2xvYmFsUmVnaXN0cnkgPSByZWdpc3RyeSgpKTtcbmV4cG9ydCBjb25zdCBnbG9iYWxSZWdpc3RyeSA9IGdsb2JhbFRoaXMuX196b2RfZ2xvYmFsUmVnaXN0cnk7XG4iLCAiaW1wb3J0ICogYXMgY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgcmVnaXN0cmllcyBmcm9tIFwiLi9yZWdpc3RyaWVzLmpzXCI7XG5pbXBvcnQgKiBhcyBzY2hlbWFzIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3RyaW5nKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWRTdHJpbmcoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lbWFpbChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJlbWFpbFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2d1aWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZ3VpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3V1aWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidXVpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3V1aWR2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1dWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uOiBcInY0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91dWlkdjYoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidXVpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgdmVyc2lvbjogXCJ2NlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXVpZHY3KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInV1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IFwidjdcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VybChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1cmxcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lbW9qaShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJlbW9qaVwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25hbm9pZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJuYW5vaWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jdWlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImN1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jdWlkMihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJjdWlkMlwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VsaWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidWxpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3hpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ4aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9rc3VpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJrc3VpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lwdjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiaXB2NFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lwdjYoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiaXB2NlwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21hYyhDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJtYWNcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jaWRydjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiY2lkcnY0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY2lkcnY2KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImNpZHJ2NlwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Jhc2U2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJiYXNlNjRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlNjR1cmwoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZTE2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJlMTY0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfand0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImp3dFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBUaW1lUHJlY2lzaW9uID0ge1xuICAgIEFueTogbnVsbCxcbiAgICBNaW51dGU6IC0xLFxuICAgIFNlY29uZDogMCxcbiAgICBNaWxsaXNlY29uZDogMyxcbiAgICBNaWNyb3NlY29uZDogNixcbn07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pc29EYXRlVGltZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJkYXRldGltZVwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIG9mZnNldDogZmFsc2UsXG4gICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXNvRGF0ZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJkYXRlXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lzb1RpbWUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidGltZVwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lzb0R1cmF0aW9uKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImR1cmF0aW9uXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX251bWJlcihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VkTnVtYmVyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaW50KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJzYWZlaW50XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9mbG9hdDMyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJmbG9hdDMyXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9mbG9hdDY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJmbG9hdDY0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQzMihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNoZWNrOiBcIm51bWJlcl9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwiaW50MzJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VpbnQzMihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNoZWNrOiBcIm51bWJlcl9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwidWludDMyXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ib29sZWFuKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VkQm9vbGVhbihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9iaWdpbnQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlZEJpZ2ludChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2ludDY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgY2hlY2s6IFwiYmlnaW50X2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJpbnQ2NFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdWludDY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgY2hlY2s6IFwiYmlnaW50X2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJ1aW50NjRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N5bWJvbChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3ltYm9sXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91bmRlZmluZWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbnVsbChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVsbFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYW55KENsYXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYW55XCIsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91bmtub3duKENsYXNzKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidW5rbm93blwiLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbmV2ZXIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm5ldmVyXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF92b2lkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ2b2lkXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9kYXRlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VkRGF0ZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9uYW4oQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm5hblwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbHQodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0xlc3NUaGFuKHtcbiAgICAgICAgY2hlY2s6IFwibGVzc190aGFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbHRlKHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tMZXNzVGhhbih7XG4gICAgICAgIGNoZWNrOiBcImxlc3NfdGhhblwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0IHsgXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGB6Lmx0ZSgpYCBpbnN0ZWFkLiAqL1xuX2x0ZSBhcyBfbWF4LCB9O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZ3QodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0dyZWF0ZXJUaGFuKHtcbiAgICAgICAgY2hlY2s6IFwiZ3JlYXRlcl90aGFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZ3RlKHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tHcmVhdGVyVGhhbih7XG4gICAgICAgIGNoZWNrOiBcImdyZWF0ZXJfdGhhblwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgIH0pO1xufVxuZXhwb3J0IHsgXG4vKiogQGRlcHJlY2F0ZWQgVXNlIGB6Lmd0ZSgpYCBpbnN0ZWFkLiAqL1xuX2d0ZSBhcyBfbWluLCB9O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcG9zaXRpdmUocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9ndCgwLCBwYXJhbXMpO1xufVxuLy8gbmVnYXRpdmVcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25lZ2F0aXZlKHBhcmFtcykge1xuICAgIHJldHVybiBfbHQoMCwgcGFyYW1zKTtcbn1cbi8vIG5vbnBvc2l0aXZlXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ub25wb3NpdGl2ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gX2x0ZSgwLCBwYXJhbXMpO1xufVxuLy8gbm9ubmVnYXRpdmVcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25vbm5lZ2F0aXZlKHBhcmFtcykge1xuICAgIHJldHVybiBfZ3RlKDAsIHBhcmFtcyk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9tdWx0aXBsZU9mKHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNdWx0aXBsZU9mKHtcbiAgICAgICAgY2hlY2s6IFwibXVsdGlwbGVfb2ZcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9tYXhTaXplKG1heGltdW0sIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja01heFNpemUoe1xuICAgICAgICBjaGVjazogXCJtYXhfc2l6ZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBtYXhpbXVtLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWluU2l6ZShtaW5pbXVtLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNaW5TaXplKHtcbiAgICAgICAgY2hlY2s6IFwibWluX3NpemVcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgbWluaW11bSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3NpemUoc2l6ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrU2l6ZUVxdWFscyh7XG4gICAgICAgIGNoZWNrOiBcInNpemVfZXF1YWxzXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHNpemUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9tYXhMZW5ndGgobWF4aW11bSwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2ggPSBuZXcgY2hlY2tzLiRab2RDaGVja01heExlbmd0aCh7XG4gICAgICAgIGNoZWNrOiBcIm1heF9sZW5ndGhcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgbWF4aW11bSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2g7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9taW5MZW5ndGgobWluaW11bSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTWluTGVuZ3RoKHtcbiAgICAgICAgY2hlY2s6IFwibWluX2xlbmd0aFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBtaW5pbXVtLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbGVuZ3RoKGxlbmd0aCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTGVuZ3RoRXF1YWxzKHtcbiAgICAgICAgY2hlY2s6IFwibGVuZ3RoX2VxdWFsc1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBsZW5ndGgsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWdleChwYXR0ZXJuLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tSZWdleCh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcInJlZ2V4XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHBhdHRlcm4sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sb3dlcmNhc2UocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTG93ZXJDYXNlKHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwibG93ZXJjYXNlXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91cHBlcmNhc2UocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrVXBwZXJDYXNlKHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwidXBwZXJjYXNlXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbmNsdWRlcyhpbmNsdWRlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrSW5jbHVkZXMoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJpbmNsdWRlc1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBpbmNsdWRlcyxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N0YXJ0c1dpdGgocHJlZml4LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tTdGFydHNXaXRoKHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwic3RhcnRzX3dpdGhcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgcHJlZml4LFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZW5kc1dpdGgoc3VmZml4LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tFbmRzV2l0aCh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcImVuZHNfd2l0aFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBzdWZmaXgsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9wcm9wZXJ0eShwcm9wZXJ0eSwgc2NoZW1hLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tQcm9wZXJ0eSh7XG4gICAgICAgIGNoZWNrOiBcInByb3BlcnR5XCIsXG4gICAgICAgIHByb3BlcnR5LFxuICAgICAgICBzY2hlbWEsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9taW1lKHR5cGVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNaW1lVHlwZSh7XG4gICAgICAgIGNoZWNrOiBcIm1pbWVfdHlwZVwiLFxuICAgICAgICBtaW1lOiB0eXBlcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX292ZXJ3cml0ZSh0eCkge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja092ZXJ3cml0ZSh7XG4gICAgICAgIGNoZWNrOiBcIm92ZXJ3cml0ZVwiLFxuICAgICAgICB0eCxcbiAgICB9KTtcbn1cbi8vIG5vcm1hbGl6ZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbm9ybWFsaXplKGZvcm0pIHtcbiAgICByZXR1cm4gX292ZXJ3cml0ZSgoaW5wdXQpID0+IGlucHV0Lm5vcm1hbGl6ZShmb3JtKSk7XG59XG4vLyB0cmltXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90cmltKCkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gaW5wdXQudHJpbSgpKTtcbn1cbi8vIHRvTG93ZXJDYXNlXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90b0xvd2VyQ2FzZSgpIHtcbiAgICByZXR1cm4gX292ZXJ3cml0ZSgoaW5wdXQpID0+IGlucHV0LnRvTG93ZXJDYXNlKCkpO1xufVxuLy8gdG9VcHBlckNhc2Vcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RvVXBwZXJDYXNlKCkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gaW5wdXQudG9VcHBlckNhc2UoKSk7XG59XG4vLyBzbHVnaWZ5XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zbHVnaWZ5KCkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gdXRpbC5zbHVnaWZ5KGlucHV0KSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9hcnJheShDbGFzcywgZWxlbWVudCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgZWxlbWVudCxcbiAgICAgICAgLy8gZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIC8vICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIC8vIH0sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91bmlvbihDbGFzcywgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfeG9yKENsYXNzLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZGlzY3JpbWluYXRlZFVuaW9uKENsYXNzLCBkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaW50ZXJzZWN0aW9uKENsYXNzLCBsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImludGVyc2VjdGlvblwiLFxuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodCxcbiAgICB9KTtcbn1cbi8vIGV4cG9ydCBmdW5jdGlvbiBfdHVwbGUoXG4vLyAgIENsYXNzOiB1dGlsLlNjaGVtYUNsYXNzPHNjaGVtYXMuJFpvZFR1cGxlPixcbi8vICAgaXRlbXM6IFtdLFxuLy8gICBwYXJhbXM/OiBzdHJpbmcgfCAkWm9kVHVwbGVQYXJhbXNcbi8vICk6IHNjaGVtYXMuJFpvZFR1cGxlPFtdLCBudWxsPjtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3R1cGxlKENsYXNzLCBpdGVtcywgX3BhcmFtc09yUmVzdCwgX3BhcmFtcykge1xuICAgIGNvbnN0IGhhc1Jlc3QgPSBfcGFyYW1zT3JSZXN0IGluc3RhbmNlb2Ygc2NoZW1hcy4kWm9kVHlwZTtcbiAgICBjb25zdCBwYXJhbXMgPSBoYXNSZXN0ID8gX3BhcmFtcyA6IF9wYXJhbXNPclJlc3Q7XG4gICAgY29uc3QgcmVzdCA9IGhhc1Jlc3QgPyBfcGFyYW1zT3JSZXN0IDogbnVsbDtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICBpdGVtcyxcbiAgICAgICAgcmVzdCxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3JlY29yZChDbGFzcywga2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWFwKENsYXNzLCBrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zZXQoQ2xhc3MsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2VudW0oQ2xhc3MsIHZhbHVlcywgcGFyYW1zKSB7XG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IE9iamVjdC5mcm9tRW50cmllcyh2YWx1ZXMubWFwKCh2KSA9PiBbdiwgdl0pKSA6IHZhbHVlcztcbiAgICAvLyBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgLy8gICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIC8vICAgICBlbnRyaWVzW3ZhbHVlXSA9IHZhbHVlO1xuICAgIC8vICAgfVxuICAgIC8vIH0gZWxzZSB7XG4gICAgLy8gICBPYmplY3QuYXNzaWduKGVudHJpZXMsIHZhbHVlcyk7XG4gICAgLy8gfVxuICAgIC8vIGNvbnN0IGVudHJpZXM6IHV0aWwuRW51bUxpa2UgPSB7fTtcbiAgICAvLyBmb3IgKGNvbnN0IHZhbCBvZiB2YWx1ZXMpIHtcbiAgICAvLyAgIGVudHJpZXNbdmFsXSA9IHZhbDtcbiAgICAvLyB9XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbi8qKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBtZXJnZWQgaW50byBgei5lbnVtKClgLiBVc2UgYHouZW51bSgpYCBpbnN0ZWFkLlxuICpcbiAqIGBgYHRzXG4gKiBlbnVtIENvbG9ycyB7IHJlZCwgZ3JlZW4sIGJsdWUgfVxuICogei5lbnVtKENvbG9ycyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIF9uYXRpdmVFbnVtKENsYXNzLCBlbnRyaWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9saXRlcmFsKENsYXNzLCB2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZXM6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZmlsZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdHJhbnNmb3JtKENsYXNzLCBmbikge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm06IGZuLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfb3B0aW9uYWwoQ2xhc3MsIGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX251bGxhYmxlKENsYXNzLCBpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWZhdWx0KENsYXNzLCBpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogdXRpbC5zaGFsbG93Q2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25vbm9wdGlvbmFsKENsYXNzLCBpbm5lclR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N1Y2Nlc3MoQ2xhc3MsIGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY2F0Y2goQ2xhc3MsIGlubmVyVHlwZSwgY2F0Y2hWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImNhdGNoXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICAgICAgY2F0Y2hWYWx1ZTogKHR5cGVvZiBjYXRjaFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYXRjaFZhbHVlIDogKCkgPT4gY2F0Y2hWYWx1ZSksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9waXBlKENsYXNzLCBpbl8sIG91dCkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInBpcGVcIixcbiAgICAgICAgaW46IGluXyxcbiAgICAgICAgb3V0LFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcmVhZG9ubHkoQ2xhc3MsIGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInJlYWRvbmx5XCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RlbXBsYXRlTGl0ZXJhbChDbGFzcywgcGFydHMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInRlbXBsYXRlX2xpdGVyYWxcIixcbiAgICAgICAgcGFydHMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sYXp5KENsYXNzLCBnZXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJsYXp5XCIsXG4gICAgICAgIGdldHRlcixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3Byb21pc2UoQ2xhc3MsIGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInByb21pc2VcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY3VzdG9tKENsYXNzLCBmbiwgX3BhcmFtcykge1xuICAgIGNvbnN0IG5vcm0gPSB1dGlsLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKTtcbiAgICBub3JtLmFib3J0ID8/IChub3JtLmFib3J0ID0gdHJ1ZSk7IC8vIGRlZmF1bHQgdG8gYWJvcnQ6ZmFsc2VcbiAgICBjb25zdCBzY2hlbWEgPSBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgZm46IGZuLFxuICAgICAgICAuLi5ub3JtLFxuICAgIH0pO1xuICAgIHJldHVybiBzY2hlbWE7XG59XG4vLyBzYW1lIGFzIF9jdXN0b20gYnV0IGRlZmF1bHRzIHRvIGFib3J0OmZhbHNlXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWZpbmUoQ2xhc3MsIGZuLCBfcGFyYW1zKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgICAgIGZuOiBmbixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyksXG4gICAgfSk7XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N1cGVyUmVmaW5lKGZuKSB7XG4gICAgY29uc3QgY2ggPSBfY2hlY2soKHBheWxvYWQpID0+IHtcbiAgICAgICAgcGF5bG9hZC5hZGRJc3N1ZSA9IChpc3N1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbC5pc3N1ZShpc3N1ZSwgcGF5bG9hZC52YWx1ZSwgY2guX3pvZC5kZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvciBab2QgMyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIGNvbnN0IF9pc3N1ZSA9IGlzc3VlO1xuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZmF0YWwpXG4gICAgICAgICAgICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5jb2RlID8/IChfaXNzdWUuY29kZSA9IFwiY3VzdG9tXCIpO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5pbnB1dCA/PyAoX2lzc3VlLmlucHV0ID0gcGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gY2gpO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA/PyAoX2lzc3VlLmNvbnRpbnVlID0gIWNoLl96b2QuZGVmLmFib3J0KTsgLy8gYWJvcnQgaXMgYWx3YXlzIHVuZGVmaW5lZCwgc28gdGhpcyBpcyBhbHdheXMgdHJ1ZS4uLlxuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbC5pc3N1ZShfaXNzdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZuKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NoZWNrKGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjaCA9IG5ldyBjaGVja3MuJFpvZENoZWNrKHtcbiAgICAgICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG4gICAgY2guX3pvZC5jaGVjayA9IGZuO1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICBjb25zdCBjaCA9IG5ldyBjaGVja3MuJFpvZENoZWNrKHsgY2hlY2s6IFwiZGVzY3JpYmVcIiB9KTtcbiAgICBjaC5fem9kLm9uYXR0YWNoID0gW1xuICAgICAgICAoaW5zdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZWdpc3RyaWVzLmdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KSA/PyB7fTtcbiAgICAgICAgICAgIHJlZ2lzdHJpZXMuZ2xvYmFsUmVnaXN0cnkuYWRkKGluc3QsIHsgLi4uZXhpc3RpbmcsIGRlc2NyaXB0aW9uIH0pO1xuICAgICAgICB9LFxuICAgIF07XG4gICAgY2guX3pvZC5jaGVjayA9ICgpID0+IHsgfTsgLy8gbm8tb3AgY2hlY2tcbiAgICByZXR1cm4gY2g7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIG1ldGEobWV0YWRhdGEpIHtcbiAgICBjb25zdCBjaCA9IG5ldyBjaGVja3MuJFpvZENoZWNrKHsgY2hlY2s6IFwibWV0YVwiIH0pO1xuICAgIGNoLl96b2Qub25hdHRhY2ggPSBbXG4gICAgICAgIChpbnN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlZ2lzdHJpZXMuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpID8/IHt9O1xuICAgICAgICAgICAgcmVnaXN0cmllcy5nbG9iYWxSZWdpc3RyeS5hZGQoaW5zdCwgeyAuLi5leGlzdGluZywgLi4ubWV0YWRhdGEgfSk7XG4gICAgICAgIH0sXG4gICAgXTtcbiAgICBjaC5fem9kLmNoZWNrID0gKCkgPT4geyB9OyAvLyBuby1vcCBjaGVja1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N0cmluZ2Jvb2woQ2xhc3NlcywgX3BhcmFtcykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpO1xuICAgIGxldCB0cnV0aHlBcnJheSA9IHBhcmFtcy50cnV0aHkgPz8gW1widHJ1ZVwiLCBcIjFcIiwgXCJ5ZXNcIiwgXCJvblwiLCBcInlcIiwgXCJlbmFibGVkXCJdO1xuICAgIGxldCBmYWxzeUFycmF5ID0gcGFyYW1zLmZhbHN5ID8/IFtcImZhbHNlXCIsIFwiMFwiLCBcIm5vXCIsIFwib2ZmXCIsIFwiblwiLCBcImRpc2FibGVkXCJdO1xuICAgIGlmIChwYXJhbXMuY2FzZSAhPT0gXCJzZW5zaXRpdmVcIikge1xuICAgICAgICB0cnV0aHlBcnJheSA9IHRydXRoeUFycmF5Lm1hcCgodikgPT4gKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdi50b0xvd2VyQ2FzZSgpIDogdikpO1xuICAgICAgICBmYWxzeUFycmF5ID0gZmFsc3lBcnJheS5tYXAoKHYpID0+ICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYudG9Mb3dlckNhc2UoKSA6IHYpKTtcbiAgICB9XG4gICAgY29uc3QgdHJ1dGh5U2V0ID0gbmV3IFNldCh0cnV0aHlBcnJheSk7XG4gICAgY29uc3QgZmFsc3lTZXQgPSBuZXcgU2V0KGZhbHN5QXJyYXkpO1xuICAgIGNvbnN0IF9Db2RlYyA9IENsYXNzZXMuQ29kZWMgPz8gc2NoZW1hcy4kWm9kQ29kZWM7XG4gICAgY29uc3QgX0Jvb2xlYW4gPSBDbGFzc2VzLkJvb2xlYW4gPz8gc2NoZW1hcy4kWm9kQm9vbGVhbjtcbiAgICBjb25zdCBfU3RyaW5nID0gQ2xhc3Nlcy5TdHJpbmcgPz8gc2NoZW1hcy4kWm9kU3RyaW5nO1xuICAgIGNvbnN0IHN0cmluZ1NjaGVtYSA9IG5ldyBfU3RyaW5nKHsgdHlwZTogXCJzdHJpbmdcIiwgZXJyb3I6IHBhcmFtcy5lcnJvciB9KTtcbiAgICBjb25zdCBib29sZWFuU2NoZW1hID0gbmV3IF9Cb29sZWFuKHsgdHlwZTogXCJib29sZWFuXCIsIGVycm9yOiBwYXJhbXMuZXJyb3IgfSk7XG4gICAgY29uc3QgY29kZWMgPSBuZXcgX0NvZGVjKHtcbiAgICAgICAgdHlwZTogXCJwaXBlXCIsXG4gICAgICAgIGluOiBzdHJpbmdTY2hlbWEsXG4gICAgICAgIG91dDogYm9vbGVhblNjaGVtYSxcbiAgICAgICAgdHJhbnNmb3JtOiAoKGlucHV0LCBwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IGlucHV0O1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5jYXNlICE9PSBcInNlbnNpdGl2ZVwiKVxuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAodHJ1dGh5U2V0LmhhcyhkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmFsc3lTZXQuaGFzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJzdHJpbmdib29sXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogWy4uLnRydXRoeVNldCwgLi4uZmFsc3lTZXRdLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5zdDogY29kZWMsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICByZXZlcnNlVHJhbnNmb3JtOiAoKGlucHV0LCBfcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlucHV0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydXRoeUFycmF5WzBdIHx8IFwidHJ1ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHN5QXJyYXlbMF0gfHwgXCJmYWxzZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IHBhcmFtcy5lcnJvcixcbiAgICB9KTtcbiAgICByZXR1cm4gY29kZWM7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdHJpbmdGb3JtYXQoQ2xhc3MsIGZvcm1hdCwgZm5PclJlZ2V4LCBfcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBwYXJhbXMgPSB1dGlsLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKTtcbiAgICBjb25zdCBkZWYgPSB7XG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdCxcbiAgICAgICAgZm46IHR5cGVvZiBmbk9yUmVnZXggPT09IFwiZnVuY3Rpb25cIiA/IGZuT3JSZWdleCA6ICh2YWwpID0+IGZuT3JSZWdleC50ZXN0KHZhbCksXG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICB9O1xuICAgIGlmIChmbk9yUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgZGVmLnBhdHRlcm4gPSBmbk9yUmVnZXg7XG4gICAgfVxuICAgIGNvbnN0IGluc3QgPSBuZXcgQ2xhc3MoZGVmKTtcbiAgICByZXR1cm4gaW5zdDtcbn1cbiIsICJpbXBvcnQgeyBnbG9iYWxSZWdpc3RyeSB9IGZyb20gXCIuL3JlZ2lzdHJpZXMuanNcIjtcbi8vIGZ1bmN0aW9uIGluaXRpYWxpemVDb250ZXh0PFQgZXh0ZW5kcyBzY2hlbWFzLiRab2RUeXBlPihpbnB1dHM6IEpTT05TY2hlbWFHZW5lcmF0b3JQYXJhbXM8VD4pOiBUb0pTT05TY2hlbWFDb250ZXh0PFQ+IHtcbi8vICAgcmV0dXJuIHtcbi8vICAgICBwcm9jZXNzb3I6IGlucHV0cy5wcm9jZXNzb3IsXG4vLyAgICAgbWV0YWRhdGFSZWdpc3RyeTogaW5wdXRzLm1ldGFkYXRhID8/IGdsb2JhbFJlZ2lzdHJ5LFxuLy8gICAgIHRhcmdldDogaW5wdXRzLnRhcmdldCA/PyBcImRyYWZ0LTIwMjAtMTJcIixcbi8vICAgICB1bnJlcHJlc2VudGFibGU6IGlucHV0cy51bnJlcHJlc2VudGFibGUgPz8gXCJ0aHJvd1wiLFxuLy8gICB9O1xuLy8gfVxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemVDb250ZXh0KHBhcmFtcykge1xuICAgIC8vIE5vcm1hbGl6ZSB0YXJnZXQ6IGNvbnZlcnQgb2xkIG5vbi1oeXBoZW5hdGVkIHZlcnNpb25zIHRvIGh5cGhlbmF0ZWQgdmVyc2lvbnNcbiAgICBsZXQgdGFyZ2V0ID0gcGFyYW1zPy50YXJnZXQgPz8gXCJkcmFmdC0yMDIwLTEyXCI7XG4gICAgaWYgKHRhcmdldCA9PT0gXCJkcmFmdC00XCIpXG4gICAgICAgIHRhcmdldCA9IFwiZHJhZnQtMDRcIjtcbiAgICBpZiAodGFyZ2V0ID09PSBcImRyYWZ0LTdcIilcbiAgICAgICAgdGFyZ2V0ID0gXCJkcmFmdC0wN1wiO1xuICAgIHJldHVybiB7XG4gICAgICAgIHByb2Nlc3NvcnM6IHBhcmFtcy5wcm9jZXNzb3JzID8/IHt9LFxuICAgICAgICBtZXRhZGF0YVJlZ2lzdHJ5OiBwYXJhbXM/Lm1ldGFkYXRhID8/IGdsb2JhbFJlZ2lzdHJ5LFxuICAgICAgICB0YXJnZXQsXG4gICAgICAgIHVucmVwcmVzZW50YWJsZTogcGFyYW1zPy51bnJlcHJlc2VudGFibGUgPz8gXCJ0aHJvd1wiLFxuICAgICAgICBvdmVycmlkZTogcGFyYW1zPy5vdmVycmlkZSA/PyAoKCkgPT4geyB9KSxcbiAgICAgICAgaW86IHBhcmFtcz8uaW8gPz8gXCJvdXRwdXRcIixcbiAgICAgICAgY291bnRlcjogMCxcbiAgICAgICAgc2VlbjogbmV3IE1hcCgpLFxuICAgICAgICBjeWNsZXM6IHBhcmFtcz8uY3ljbGVzID8/IFwicmVmXCIsXG4gICAgICAgIHJldXNlZDogcGFyYW1zPy5yZXVzZWQgPz8gXCJpbmxpbmVcIixcbiAgICAgICAgZXh0ZXJuYWw6IHBhcmFtcz8uZXh0ZXJuYWwgPz8gdW5kZWZpbmVkLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvY2VzcyhzY2hlbWEsIGN0eCwgX3BhcmFtcyA9IHsgcGF0aDogW10sIHNjaGVtYVBhdGg6IFtdIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIC8vIGNoZWNrIGZvciBzY2hlbWEgaW4gc2VlbnNcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgaWYgKHNlZW4pIHtcbiAgICAgICAgc2Vlbi5jb3VudCsrO1xuICAgICAgICAvLyBjaGVjayBpZiBjeWNsZVxuICAgICAgICBjb25zdCBpc0N5Y2xlID0gX3BhcmFtcy5zY2hlbWFQYXRoLmluY2x1ZGVzKHNjaGVtYSk7XG4gICAgICAgIGlmIChpc0N5Y2xlKSB7XG4gICAgICAgICAgICBzZWVuLmN5Y2xlID0gX3BhcmFtcy5wYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWVuLnNjaGVtYTtcbiAgICB9XG4gICAgLy8gaW5pdGlhbGl6ZVxuICAgIGNvbnN0IHJlc3VsdCA9IHsgc2NoZW1hOiB7fSwgY291bnQ6IDEsIGN5Y2xlOiB1bmRlZmluZWQsIHBhdGg6IF9wYXJhbXMucGF0aCB9O1xuICAgIGN0eC5zZWVuLnNldChzY2hlbWEsIHJlc3VsdCk7XG4gICAgLy8gY3VzdG9tIG1ldGhvZCBvdmVycmlkZXMgZGVmYXVsdCBiZWhhdmlvclxuICAgIGNvbnN0IG92ZXJyaWRlU2NoZW1hID0gc2NoZW1hLl96b2QudG9KU09OU2NoZW1hPy4oKTtcbiAgICBpZiAob3ZlcnJpZGVTY2hlbWEpIHtcbiAgICAgICAgcmVzdWx0LnNjaGVtYSA9IG92ZXJyaWRlU2NoZW1hO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgLi4uX3BhcmFtcyxcbiAgICAgICAgICAgIHNjaGVtYVBhdGg6IFsuLi5fcGFyYW1zLnNjaGVtYVBhdGgsIHNjaGVtYV0sXG4gICAgICAgICAgICBwYXRoOiBfcGFyYW1zLnBhdGgsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChzY2hlbWEuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSkge1xuICAgICAgICAgICAgc2NoZW1hLl96b2QucHJvY2Vzc0pTT05TY2hlbWEoY3R4LCByZXN1bHQuc2NoZW1hLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgX2pzb24gPSByZXN1bHQuc2NoZW1hO1xuICAgICAgICAgICAgY29uc3QgcHJvY2Vzc29yID0gY3R4LnByb2Nlc3NvcnNbZGVmLnR5cGVdO1xuICAgICAgICAgICAgaWYgKCFwcm9jZXNzb3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFt0b0pTT05TY2hlbWFdOiBOb24tcmVwcmVzZW50YWJsZSB0eXBlIGVuY291bnRlcmVkOiAke2RlZi50eXBlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc29yKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnQgPSBzY2hlbWEuX3pvZC5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIC8vIEFsc28gc2V0IHJlZiBpZiBwcm9jZXNzb3IgZGlkbid0IChmb3IgaW5oZXJpdGFuY2UpXG4gICAgICAgICAgICBpZiAoIXJlc3VsdC5yZWYpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlZiA9IHBhcmVudDtcbiAgICAgICAgICAgIHByb2Nlc3MocGFyZW50LCBjdHgsIHBhcmFtcyk7XG4gICAgICAgICAgICBjdHguc2Vlbi5nZXQocGFyZW50KS5pc1BhcmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbWV0YWRhdGFcbiAgICBjb25zdCBtZXRhID0gY3R4Lm1ldGFkYXRhUmVnaXN0cnkuZ2V0KHNjaGVtYSk7XG4gICAgaWYgKG1ldGEpXG4gICAgICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LnNjaGVtYSwgbWV0YSk7XG4gICAgaWYgKGN0eC5pbyA9PT0gXCJpbnB1dFwiICYmIGlzVHJhbnNmb3JtaW5nKHNjaGVtYSkpIHtcbiAgICAgICAgLy8gZXhhbXBsZXMvZGVmYXVsdHMgb25seSBhcHBseSB0byBvdXRwdXQgdHlwZSBvZiBwaXBlXG4gICAgICAgIGRlbGV0ZSByZXN1bHQuc2NoZW1hLmV4YW1wbGVzO1xuICAgICAgICBkZWxldGUgcmVzdWx0LnNjaGVtYS5kZWZhdWx0O1xuICAgIH1cbiAgICAvLyBzZXQgcHJlZmF1bHQgYXMgZGVmYXVsdFxuICAgIGlmIChjdHguaW8gPT09IFwiaW5wdXRcIiAmJiByZXN1bHQuc2NoZW1hLl9wcmVmYXVsdClcbiAgICAgICAgKF9hID0gcmVzdWx0LnNjaGVtYSkuZGVmYXVsdCA/PyAoX2EuZGVmYXVsdCA9IHJlc3VsdC5zY2hlbWEuX3ByZWZhdWx0KTtcbiAgICBkZWxldGUgcmVzdWx0LnNjaGVtYS5fcHJlZmF1bHQ7XG4gICAgLy8gcHVsbGluZyBmcmVzaCBmcm9tIGN0eC5zZWVuIGluIGNhc2UgaXQgd2FzIG92ZXJ3cml0dGVuXG4gICAgY29uc3QgX3Jlc3VsdCA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHJldHVybiBfcmVzdWx0LnNjaGVtYTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0RGVmcyhjdHgsIHNjaGVtYVxuLy8gcGFyYW1zOiBFbWl0UGFyYW1zXG4pIHtcbiAgICAvLyBpdGVyYXRlIG92ZXIgc2VlbiBtYXA7XG4gICAgY29uc3Qgcm9vdCA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIGlmICghcm9vdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5wcm9jZXNzZWQgc2NoZW1hLiBUaGlzIGlzIGEgYnVnIGluIFpvZC5cIik7XG4gICAgLy8gVHJhY2sgaWRzIHRvIGRldGVjdCBkdXBsaWNhdGVzIGFjcm9zcyBkaWZmZXJlbnQgc2NoZW1hc1xuICAgIGNvbnN0IGlkVG9TY2hlbWEgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdHguc2Vlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBjdHgubWV0YWRhdGFSZWdpc3RyeS5nZXQoZW50cnlbMF0pPy5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IGlkVG9TY2hlbWEuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZyAmJiBleGlzdGluZyAhPT0gZW50cnlbMF0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSBzY2hlbWEgaWQgXCIke2lkfVwiIGRldGVjdGVkIGR1cmluZyBKU09OIFNjaGVtYSBjb252ZXJzaW9uLiBUd28gZGlmZmVyZW50IHNjaGVtYXMgY2Fubm90IHNoYXJlIHRoZSBzYW1lIGlkIHdoZW4gY29udmVydGVkIHRvZ2V0aGVyLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWRUb1NjaGVtYS5zZXQoaWQsIGVudHJ5WzBdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm5zIGEgcmVmIHRvIHRoZSBzY2hlbWFcbiAgICAvLyBkZWZJZCB3aWxsIGJlIGVtcHR5IGlmIHRoZSByZWYgcG9pbnRzIHRvIGFuIGV4dGVybmFsIHNjaGVtYSAob3IgIylcbiAgICBjb25zdCBtYWtlVVJJID0gKGVudHJ5KSA9PiB7XG4gICAgICAgIC8vIGNvbXBhcmluZyB0aGUgc2VlbiBvYmplY3RzIGJlY2F1c2Ugc29tZXRpbWVzXG4gICAgICAgIC8vIG11bHRpcGxlIHNjaGVtYXMgbWFwIHRvIHRoZSBzYW1lIHNlZW4gb2JqZWN0LlxuICAgICAgICAvLyBlLmcuIGxhenlcbiAgICAgICAgLy8gZXh0ZXJuYWwgaXMgY29uZmlndXJlZFxuICAgICAgICBjb25zdCBkZWZzU2VnbWVudCA9IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiID8gXCIkZGVmc1wiIDogXCJkZWZpbml0aW9uc1wiO1xuICAgICAgICBpZiAoY3R4LmV4dGVybmFsKSB7XG4gICAgICAgICAgICBjb25zdCBleHRlcm5hbElkID0gY3R4LmV4dGVybmFsLnJlZ2lzdHJ5LmdldChlbnRyeVswXSk/LmlkOyAvLyA/PyBcIl9fc2hhcmVkXCI7Ly8gYF9fc2NoZW1hJHtjdHguY291bnRlcisrfWA7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBzY2hlbWEgaXMgaW4gdGhlIGV4dGVybmFsIHJlZ2lzdHJ5XG4gICAgICAgICAgICBjb25zdCB1cmlHZW5lcmF0b3IgPSBjdHguZXh0ZXJuYWwudXJpID8/ICgoaWQpID0+IGlkKTtcbiAgICAgICAgICAgIGlmIChleHRlcm5hbElkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcmVmOiB1cmlHZW5lcmF0b3IoZXh0ZXJuYWxJZCkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgYWRkIHRvIF9fc2hhcmVkXG4gICAgICAgICAgICBjb25zdCBpZCA9IGVudHJ5WzFdLmRlZklkID8/IGVudHJ5WzFdLnNjaGVtYS5pZCA/PyBgc2NoZW1hJHtjdHguY291bnRlcisrfWA7XG4gICAgICAgICAgICBlbnRyeVsxXS5kZWZJZCA9IGlkOyAvLyBzZXQgZGVmSWQgc28gaXQgd2lsbCBiZSByZXVzZWQgaWYgbmVlZGVkXG4gICAgICAgICAgICByZXR1cm4geyBkZWZJZDogaWQsIHJlZjogYCR7dXJpR2VuZXJhdG9yKFwiX19zaGFyZWRcIil9Iy8ke2RlZnNTZWdtZW50fS8ke2lkfWAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW50cnlbMV0gPT09IHJvb3QpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHJlZjogXCIjXCIgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzZWxmLWNvbnRhaW5lZCBzY2hlbWFcbiAgICAgICAgY29uc3QgdXJpUHJlZml4ID0gYCNgO1xuICAgICAgICBjb25zdCBkZWZVcmlQcmVmaXggPSBgJHt1cmlQcmVmaXh9LyR7ZGVmc1NlZ21lbnR9L2A7XG4gICAgICAgIGNvbnN0IGRlZklkID0gZW50cnlbMV0uc2NoZW1hLmlkID8/IGBfX3NjaGVtYSR7Y3R4LmNvdW50ZXIrK31gO1xuICAgICAgICByZXR1cm4geyBkZWZJZCwgcmVmOiBkZWZVcmlQcmVmaXggKyBkZWZJZCB9O1xuICAgIH07XG4gICAgLy8gc3RvcmVkIGNhY2hlZCB2ZXJzaW9uIGluIGBkZWZgIHByb3BlcnR5XG4gICAgLy8gcmVtb3ZlIGFsbCBwcm9wZXJ0aWVzLCBzZXQgJHJlZlxuICAgIGNvbnN0IGV4dHJhY3RUb0RlZiA9IChlbnRyeSkgPT4ge1xuICAgICAgICAvLyBpZiB0aGUgc2NoZW1hIGlzIGFscmVhZHkgYSByZWZlcmVuY2UsIGRvIG5vdCBleHRyYWN0IGl0XG4gICAgICAgIGlmIChlbnRyeVsxXS5zY2hlbWEuJHJlZikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZW4gPSBlbnRyeVsxXTtcbiAgICAgICAgY29uc3QgeyByZWYsIGRlZklkIH0gPSBtYWtlVVJJKGVudHJ5KTtcbiAgICAgICAgc2Vlbi5kZWYgPSB7IC4uLnNlZW4uc2NoZW1hIH07XG4gICAgICAgIC8vIGRlZklkIHdvbid0IGJlIHNldCBpZiB0aGUgc2NoZW1hIGlzIGEgcmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIHNjaGVtYVxuICAgICAgICAvLyBvciBpZiB0aGUgc2NoZW1hIGlzIHRoZSByb290IHNjaGVtYVxuICAgICAgICBpZiAoZGVmSWQpXG4gICAgICAgICAgICBzZWVuLmRlZklkID0gZGVmSWQ7XG4gICAgICAgIC8vIHdpcGUgYXdheSBhbGwgcHJvcGVydGllcyBleGNlcHQgJHJlZlxuICAgICAgICBjb25zdCBzY2hlbWEgPSBzZWVuLnNjaGVtYTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBkZWxldGUgc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgc2NoZW1hLiRyZWYgPSByZWY7XG4gICAgfTtcbiAgICAvLyB0aHJvdyBvbiBjeWNsZXNcbiAgICAvLyBicmVhayBjeWNsZXNcbiAgICBpZiAoY3R4LmN5Y2xlcyA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgY3R4LnNlZW4uZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBzZWVuID0gZW50cnlbMV07XG4gICAgICAgICAgICBpZiAoc2Vlbi5jeWNsZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN5Y2xlIGRldGVjdGVkOiBcIiArXG4gICAgICAgICAgICAgICAgICAgIGAjLyR7c2Vlbi5jeWNsZT8uam9pbihcIi9cIil9Lzxyb290PmAgK1xuICAgICAgICAgICAgICAgICAgICAnXFxuXFxuU2V0IHRoZSBgY3ljbGVzYCBwYXJhbWV0ZXIgdG8gYFwicmVmXCJgIHRvIHJlc29sdmUgY3ljbGljYWwgc2NoZW1hcyB3aXRoIGRlZnMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXh0cmFjdCBzY2hlbWFzIGludG8gJGRlZnNcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGN0eC5zZWVuLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBzZWVuID0gZW50cnlbMV07XG4gICAgICAgIC8vIGNvbnZlcnQgcm9vdCBzY2hlbWEgdG8gIyAkcmVmXG4gICAgICAgIGlmIChzY2hlbWEgPT09IGVudHJ5WzBdKSB7XG4gICAgICAgICAgICBleHRyYWN0VG9EZWYoZW50cnkpOyAvLyB0aGlzIGhhcyBzcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgcm9vdCBzY2hlbWFcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4dHJhY3Qgc2NoZW1hcyB0aGF0IGFyZSBpbiB0aGUgZXh0ZXJuYWwgcmVnaXN0cnlcbiAgICAgICAgaWYgKGN0eC5leHRlcm5hbCkge1xuICAgICAgICAgICAgY29uc3QgZXh0ID0gY3R4LmV4dGVybmFsLnJlZ2lzdHJ5LmdldChlbnRyeVswXSk/LmlkO1xuICAgICAgICAgICAgaWYgKHNjaGVtYSAhPT0gZW50cnlbMF0gJiYgZXh0KSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdFRvRGVmKGVudHJ5KTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleHRyYWN0IHNjaGVtYXMgd2l0aCBgaWRgIG1ldGFcbiAgICAgICAgY29uc3QgaWQgPSBjdHgubWV0YWRhdGFSZWdpc3RyeS5nZXQoZW50cnlbMF0pPy5pZDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBleHRyYWN0VG9EZWYoZW50cnkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnJlYWsgY3ljbGVzXG4gICAgICAgIGlmIChzZWVuLmN5Y2xlKSB7XG4gICAgICAgICAgICAvLyBhbnlcbiAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHRyYWN0IHJldXNlZCBzY2hlbWFzXG4gICAgICAgIGlmIChzZWVuLmNvdW50ID4gMSkge1xuICAgICAgICAgICAgaWYgKGN0eC5yZXVzZWQgPT09IFwicmVmXCIpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0VG9EZWYoZW50cnkpO1xuICAgICAgICAgICAgICAgIC8vIGJpb21lLWlnbm9yZSBsaW50OlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplKGN0eCwgc2NoZW1hKSB7XG4gICAgY29uc3Qgcm9vdCA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIGlmICghcm9vdClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5wcm9jZXNzZWQgc2NoZW1hLiBUaGlzIGlzIGEgYnVnIGluIFpvZC5cIik7XG4gICAgLy8gZmxhdHRlbiByZWZzIC0gaW5oZXJpdCBwcm9wZXJ0aWVzIGZyb20gcGFyZW50IHNjaGVtYXNcbiAgICBjb25zdCBmbGF0dGVuUmVmID0gKHpvZFNjaGVtYSkgPT4ge1xuICAgICAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHpvZFNjaGVtYSk7XG4gICAgICAgIC8vIGFscmVhZHkgcHJvY2Vzc2VkXG4gICAgICAgIGlmIChzZWVuLnJlZiA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2Vlbi5kZWYgPz8gc2Vlbi5zY2hlbWE7XG4gICAgICAgIGNvbnN0IF9jYWNoZWQgPSB7IC4uLnNjaGVtYSB9O1xuICAgICAgICBjb25zdCByZWYgPSBzZWVuLnJlZjtcbiAgICAgICAgc2Vlbi5yZWYgPSBudWxsOyAvLyBwcmV2ZW50IGluZmluaXRlIHJlY3Vyc2lvblxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgICBmbGF0dGVuUmVmKHJlZik7XG4gICAgICAgICAgICBjb25zdCByZWZTZWVuID0gY3R4LnNlZW4uZ2V0KHJlZik7XG4gICAgICAgICAgICBjb25zdCByZWZTY2hlbWEgPSByZWZTZWVuLnNjaGVtYTtcbiAgICAgICAgICAgIC8vIG1lcmdlIHJlZmVyZW5jZWQgc2NoZW1hIGludG8gY3VycmVudFxuICAgICAgICAgICAgaWYgKHJlZlNjaGVtYS4kcmVmICYmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA3XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiIHx8IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBvbGRlciBkcmFmdHMgY2FuJ3QgY29tYmluZSAkcmVmIHdpdGggb3RoZXIgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIHNjaGVtYS5hbGxPZiA9IHNjaGVtYS5hbGxPZiA/PyBbXTtcbiAgICAgICAgICAgICAgICBzY2hlbWEuYWxsT2YucHVzaChyZWZTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIHJlZlNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXN0b3JlIGNoaWxkJ3Mgb3duIHByb3BlcnRpZXMgKGNoaWxkIHdpbnMpXG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHNjaGVtYSwgX2NhY2hlZCk7XG4gICAgICAgICAgICBjb25zdCBpc1BhcmVudFJlZiA9IHpvZFNjaGVtYS5fem9kLnBhcmVudCA9PT0gcmVmO1xuICAgICAgICAgICAgLy8gRm9yIHBhcmVudCBjaGFpbiwgY2hpbGQgaXMgYSByZWZpbmVtZW50IC0gcmVtb3ZlIHBhcmVudC1vbmx5IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChpc1BhcmVudFJlZikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIiB8fCBrZXkgPT09IFwiYWxsT2ZcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gX2NhY2hlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdoZW4gcmVmIHdhcyBleHRyYWN0ZWQgdG8gJGRlZnMsIHJlbW92ZSBwcm9wZXJ0aWVzIHRoYXQgbWF0Y2ggdGhlIGRlZmluaXRpb25cbiAgICAgICAgICAgIGlmIChyZWZTY2hlbWEuJHJlZiAmJiByZWZTZWVuLmRlZikge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIiB8fCBrZXkgPT09IFwiYWxsT2ZcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHJlZlNlZW4uZGVmICYmIEpTT04uc3RyaW5naWZ5KHNjaGVtYVtrZXldKSA9PT0gSlNPTi5zdHJpbmdpZnkocmVmU2Vlbi5kZWZba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBwYXJlbnQgd2FzIGV4dHJhY3RlZCAoaGFzICRyZWYpLCBwcm9wYWdhdGUgJHJlZiB0byB0aGlzIHNjaGVtYVxuICAgICAgICAvLyBUaGlzIGhhbmRsZXMgY2FzZXMgbGlrZTogcmVhZG9ubHkoKS5tZXRhKHtpZH0pLmRlc2NyaWJlKClcbiAgICAgICAgLy8gd2hlcmUgcHJvY2Vzc29yIHNldHMgcmVmIHRvIGlubmVyVHlwZSBidXQgcGFyZW50IHNob3VsZCBiZSByZWZlcmVuY2VkXG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHpvZFNjaGVtYS5fem9kLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCAmJiBwYXJlbnQgIT09IHJlZikge1xuICAgICAgICAgICAgLy8gRW5zdXJlIHBhcmVudCBpcyBwcm9jZXNzZWQgZmlyc3Qgc28gaXRzIGRlZiBoYXMgaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgICAgICAgIGZsYXR0ZW5SZWYocGFyZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudFNlZW4gPSBjdHguc2Vlbi5nZXQocGFyZW50KTtcbiAgICAgICAgICAgIGlmIChwYXJlbnRTZWVuPy5zY2hlbWEuJHJlZikge1xuICAgICAgICAgICAgICAgIHNjaGVtYS4kcmVmID0gcGFyZW50U2Vlbi5zY2hlbWEuJHJlZjtcbiAgICAgICAgICAgICAgICAvLyBEZS1kdXBsaWNhdGUgd2l0aCBwYXJlbnQncyBkZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudFNlZW4uZGVmKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIgfHwga2V5ID09PSBcImFsbE9mXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5IGluIHBhcmVudFNlZW4uZGVmICYmIEpTT04uc3RyaW5naWZ5KHNjaGVtYVtrZXldKSA9PT0gSlNPTi5zdHJpbmdpZnkocGFyZW50U2Vlbi5kZWZba2V5XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhlY3V0ZSBvdmVycmlkZXNcbiAgICAgICAgY3R4Lm92ZXJyaWRlKHtcbiAgICAgICAgICAgIHpvZFNjaGVtYTogem9kU2NoZW1hLFxuICAgICAgICAgICAganNvblNjaGVtYTogc2NoZW1hLFxuICAgICAgICAgICAgcGF0aDogc2Vlbi5wYXRoID8/IFtdLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgWy4uLmN0eC5zZWVuLmVudHJpZXMoKV0ucmV2ZXJzZSgpKSB7XG4gICAgICAgIGZsYXR0ZW5SZWYoZW50cnlbMF0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIpIHtcbiAgICAgICAgcmVzdWx0LiRzY2hlbWEgPSBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDdcIikge1xuICAgICAgICByZXN1bHQuJHNjaGVtYSA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIikge1xuICAgICAgICByZXN1bHQuJHNjaGVtYSA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICAvLyBPcGVuQVBJIDMuMCBzY2hlbWEgb2JqZWN0cyBzaG91bGQgbm90IGluY2x1ZGUgYSAkc2NoZW1hIHByb3BlcnR5XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBBcmJpdHJhcnkgc3RyaW5nIHZhbHVlcyBhcmUgYWxsb3dlZCBidXQgd29uJ3QgaGF2ZSBhICRzY2hlbWEgcHJvcGVydHkgc2V0XG4gICAgfVxuICAgIGlmIChjdHguZXh0ZXJuYWw/LnVyaSkge1xuICAgICAgICBjb25zdCBpZCA9IGN0eC5leHRlcm5hbC5yZWdpc3RyeS5nZXQoc2NoZW1hKT8uaWQ7XG4gICAgICAgIGlmICghaWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTY2hlbWEgaXMgbWlzc2luZyBhbiBgaWRgIHByb3BlcnR5XCIpO1xuICAgICAgICByZXN1bHQuJGlkID0gY3R4LmV4dGVybmFsLnVyaShpZCk7XG4gICAgfVxuICAgIE9iamVjdC5hc3NpZ24ocmVzdWx0LCByb290LmRlZiA/PyByb290LnNjaGVtYSk7XG4gICAgLy8gYnVpbGQgZGVmcyBvYmplY3RcbiAgICBjb25zdCBkZWZzID0gY3R4LmV4dGVybmFsPy5kZWZzID8/IHt9O1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgY3R4LnNlZW4uZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBlbnRyeVsxXTtcbiAgICAgICAgaWYgKHNlZW4uZGVmICYmIHNlZW4uZGVmSWQpIHtcbiAgICAgICAgICAgIGRlZnNbc2Vlbi5kZWZJZF0gPSBzZWVuLmRlZjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBzZXQgZGVmaW5pdGlvbnMgaW4gcmVzdWx0XG4gICAgaWYgKGN0eC5leHRlcm5hbCkge1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlZnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC4kZGVmcyA9IGRlZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuZGVmaW5pdGlvbnMgPSBkZWZzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHRoaXMgXCJmaW5hbGl6ZXNcIiB0aGlzIHNjaGVtYSBhbmQgZW5zdXJlcyBhbGwgY3ljbGVzIGFyZSByZW1vdmVkXG4gICAgICAgIC8vIGVhY2ggY2FsbCB0byBmaW5hbGl6ZSgpIGlzIGZ1bmN0aW9uYWxseSBpbmRlcGVuZGVudFxuICAgICAgICAvLyB0aG91Z2ggdGhlIHNlZW4gbWFwIGlzIHNoYXJlZFxuICAgICAgICBjb25zdCBmaW5hbGl6ZWQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3VsdCkpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZmluYWxpemVkLCBcIn5zdGFuZGFyZFwiLCB7XG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIC4uLnNjaGVtYVtcIn5zdGFuZGFyZFwiXSxcbiAgICAgICAgICAgICAgICBqc29uU2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBjcmVhdGVTdGFuZGFyZEpTT05TY2hlbWFNZXRob2Qoc2NoZW1hLCBcImlucHV0XCIsIGN0eC5wcm9jZXNzb3JzKSxcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiBjcmVhdGVTdGFuZGFyZEpTT05TY2hlbWFNZXRob2Qoc2NoZW1hLCBcIm91dHB1dFwiLCBjdHgucHJvY2Vzc29ycyksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmaW5hbGl6ZWQ7XG4gICAgfVxuICAgIGNhdGNoIChfZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkVycm9yIGNvbnZlcnRpbmcgc2NoZW1hIHRvIEpTT04uXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVHJhbnNmb3JtaW5nKF9zY2hlbWEsIF9jdHgpIHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8/IHsgc2VlbjogbmV3IFNldCgpIH07XG4gICAgaWYgKGN0eC5zZWVuLmhhcyhfc2NoZW1hKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGN0eC5zZWVuLmFkZChfc2NoZW1hKTtcbiAgICBjb25zdCBkZWYgPSBfc2NoZW1hLl96b2QuZGVmO1xuICAgIGlmIChkZWYudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKGRlZi50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYuZWxlbWVudCwgY3R4KTtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwic2V0XCIpXG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYudmFsdWVUeXBlLCBjdHgpO1xuICAgIGlmIChkZWYudHlwZSA9PT0gXCJsYXp5XCIpXG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYuZ2V0dGVyKCksIGN0eCk7XG4gICAgaWYgKGRlZi50eXBlID09PSBcInByb21pc2VcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJvcHRpb25hbFwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcIm5vbm9wdGlvbmFsXCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwibnVsbGFibGVcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJyZWFkb25seVwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcImRlZmF1bHRcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJwcmVmYXVsdFwiKSB7XG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYuaW5uZXJUeXBlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwiaW50ZXJzZWN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5sZWZ0LCBjdHgpIHx8IGlzVHJhbnNmb3JtaW5nKGRlZi5yaWdodCwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGRlZi50eXBlID09PSBcInJlY29yZFwiIHx8IGRlZi50eXBlID09PSBcIm1hcFwiKSB7XG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYua2V5VHlwZSwgY3R4KSB8fCBpc1RyYW5zZm9ybWluZyhkZWYudmFsdWVUeXBlLCBjdHgpO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwicGlwZVwiKSB7XG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYuaW4sIGN0eCkgfHwgaXNUcmFuc2Zvcm1pbmcoZGVmLm91dCwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGRlZi50eXBlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlZi5zaGFwZSkge1xuICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtaW5nKGRlZi5zaGFwZVtrZXldLCBjdHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlZi50eXBlID09PSBcInVuaW9uXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybWluZyhvcHRpb24sIGN0eCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgZGVmLml0ZW1zKSB7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1pbmcoaXRlbSwgY3R4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnJlc3QgJiYgaXNUcmFuc2Zvcm1pbmcoZGVmLnJlc3QsIGN0eCkpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vKipcbiAqIENyZWF0ZXMgYSB0b0pTT05TY2hlbWEgbWV0aG9kIGZvciBhIHNjaGVtYSBpbnN0YW5jZS5cbiAqIFRoaXMgZW5jYXBzdWxhdGVzIHRoZSBsb2dpYyBvZiBpbml0aWFsaXppbmcgY29udGV4dCwgcHJvY2Vzc2luZywgZXh0cmFjdGluZyBkZWZzLCBhbmQgZmluYWxpemluZy5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVRvSlNPTlNjaGVtYU1ldGhvZCA9IChzY2hlbWEsIHByb2Nlc3NvcnMgPSB7fSkgPT4gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGN0eCA9IGluaXRpYWxpemVDb250ZXh0KHsgLi4ucGFyYW1zLCBwcm9jZXNzb3JzIH0pO1xuICAgIHByb2Nlc3Moc2NoZW1hLCBjdHgpO1xuICAgIGV4dHJhY3REZWZzKGN0eCwgc2NoZW1hKTtcbiAgICByZXR1cm4gZmluYWxpemUoY3R4LCBzY2hlbWEpO1xufTtcbmV4cG9ydCBjb25zdCBjcmVhdGVTdGFuZGFyZEpTT05TY2hlbWFNZXRob2QgPSAoc2NoZW1hLCBpbywgcHJvY2Vzc29ycyA9IHt9KSA9PiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBsaWJyYXJ5T3B0aW9ucywgdGFyZ2V0IH0gPSBwYXJhbXMgPz8ge307XG4gICAgY29uc3QgY3R4ID0gaW5pdGlhbGl6ZUNvbnRleHQoeyAuLi4obGlicmFyeU9wdGlvbnMgPz8ge30pLCB0YXJnZXQsIGlvLCBwcm9jZXNzb3JzIH0pO1xuICAgIHByb2Nlc3Moc2NoZW1hLCBjdHgpO1xuICAgIGV4dHJhY3REZWZzKGN0eCwgc2NoZW1hKTtcbiAgICByZXR1cm4gZmluYWxpemUoY3R4LCBzY2hlbWEpO1xufTtcbiIsICJpbXBvcnQgeyBleHRyYWN0RGVmcywgZmluYWxpemUsIGluaXRpYWxpemVDb250ZXh0LCBwcm9jZXNzLCB9IGZyb20gXCIuL3RvLWpzb24tc2NoZW1hLmpzXCI7XG5pbXBvcnQgeyBnZXRFbnVtVmFsdWVzIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuY29uc3QgZm9ybWF0TWFwID0ge1xuICAgIGd1aWQ6IFwidXVpZFwiLFxuICAgIHVybDogXCJ1cmlcIixcbiAgICBkYXRldGltZTogXCJkYXRlLXRpbWVcIixcbiAgICBqc29uX3N0cmluZzogXCJqc29uLXN0cmluZ1wiLFxuICAgIHJlZ2V4OiBcIlwiLCAvLyBkbyBub3Qgc2V0XG59O1xuLy8gPT09PT09PT09PT09PT09PT09PT0gU0lNUExFIFRZUEUgUFJPQ0VTU09SUyA9PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0IGNvbnN0IHN0cmluZ1Byb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAganNvbi50eXBlID0gXCJzdHJpbmdcIjtcbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0sIGZvcm1hdCwgcGF0dGVybnMsIGNvbnRlbnRFbmNvZGluZyB9ID0gc2NoZW1hLl96b2RcbiAgICAgICAgLmJhZztcbiAgICBpZiAodHlwZW9mIG1pbmltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWluTGVuZ3RoID0gbWluaW11bTtcbiAgICBpZiAodHlwZW9mIG1heGltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWF4TGVuZ3RoID0gbWF4aW11bTtcbiAgICAvLyBjdXN0b20gcGF0dGVybiBvdmVycmlkZXMgZm9ybWF0XG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICBqc29uLmZvcm1hdCA9IGZvcm1hdE1hcFtmb3JtYXRdID8/IGZvcm1hdDtcbiAgICAgICAgaWYgKGpzb24uZm9ybWF0ID09PSBcIlwiKVxuICAgICAgICAgICAgZGVsZXRlIGpzb24uZm9ybWF0OyAvLyBlbXB0eSBmb3JtYXQgaXMgbm90IHZhbGlkXG4gICAgICAgIC8vIEpTT04gU2NoZW1hIGZvcm1hdDogXCJ0aW1lXCIgcmVxdWlyZXMgYSBmdWxsIHRpbWUgd2l0aCBvZmZzZXQgb3IgWlxuICAgICAgICAvLyB6Lmlzby50aW1lKCkgZG9lcyBub3QgaW5jbHVkZSB0aW1lem9uZSBpbmZvcm1hdGlvbiwgc28gZm9ybWF0OiBcInRpbWVcIiBzaG91bGQgbmV2ZXIgYmUgdXNlZFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgZGVsZXRlIGpzb24uZm9ybWF0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjb250ZW50RW5jb2RpbmcpXG4gICAgICAgIGpzb24uY29udGVudEVuY29kaW5nID0gY29udGVudEVuY29kaW5nO1xuICAgIGlmIChwYXR0ZXJucyAmJiBwYXR0ZXJucy5zaXplID4gMCkge1xuICAgICAgICBjb25zdCByZWdleGVzID0gWy4uLnBhdHRlcm5zXTtcbiAgICAgICAgaWYgKHJlZ2V4ZXMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAganNvbi5wYXR0ZXJuID0gcmVnZXhlc1swXS5zb3VyY2U7XG4gICAgICAgIGVsc2UgaWYgKHJlZ2V4ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAganNvbi5hbGxPZiA9IFtcbiAgICAgICAgICAgICAgICAuLi5yZWdleGVzLm1hcCgocmVnZXgpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC4uLihjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA3XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiIHx8IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHR5cGU6IFwic3RyaW5nXCIgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IHJlZ2V4LnNvdXJjZSxcbiAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICBdO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBudW1iZXJQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGNvbnN0IHsgbWluaW11bSwgbWF4aW11bSwgZm9ybWF0LCBtdWx0aXBsZU9mLCBleGNsdXNpdmVNYXhpbXVtLCBleGNsdXNpdmVNaW5pbXVtIH0gPSBzY2hlbWEuX3pvZC5iYWc7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT09IFwic3RyaW5nXCIgJiYgZm9ybWF0LmluY2x1ZGVzKFwiaW50XCIpKVxuICAgICAgICBqc29uLnR5cGUgPSBcImludGVnZXJcIjtcbiAgICBlbHNlXG4gICAgICAgIGpzb24udHlwZSA9IFwibnVtYmVyXCI7XG4gICAgaWYgKHR5cGVvZiBleGNsdXNpdmVNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgICAgICBqc29uLm1pbmltdW0gPSBleGNsdXNpdmVNaW5pbXVtO1xuICAgICAgICAgICAganNvbi5leGNsdXNpdmVNaW5pbXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGpzb24uZXhjbHVzaXZlTWluaW11bSA9IGV4Y2x1c2l2ZU1pbmltdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGpzb24ubWluaW11bSA9IG1pbmltdW07XG4gICAgICAgIGlmICh0eXBlb2YgZXhjbHVzaXZlTWluaW11bSA9PT0gXCJudW1iZXJcIiAmJiBjdHgudGFyZ2V0ICE9PSBcImRyYWZ0LTA0XCIpIHtcbiAgICAgICAgICAgIGlmIChleGNsdXNpdmVNaW5pbXVtID49IG1pbmltdW0pXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpzb24ubWluaW11bTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUganNvbi5leGNsdXNpdmVNaW5pbXVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZXhjbHVzaXZlTWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiIHx8IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICAgICAganNvbi5tYXhpbXVtID0gZXhjbHVzaXZlTWF4aW11bTtcbiAgICAgICAgICAgIGpzb24uZXhjbHVzaXZlTWF4aW11bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqc29uLmV4Y2x1c2l2ZU1heGltdW0gPSBleGNsdXNpdmVNYXhpbXVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBqc29uLm1heGltdW0gPSBtYXhpbXVtO1xuICAgICAgICBpZiAodHlwZW9mIGV4Y2x1c2l2ZU1heGltdW0gPT09IFwibnVtYmVyXCIgJiYgY3R4LnRhcmdldCAhPT0gXCJkcmFmdC0wNFwiKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVzaXZlTWF4aW11bSA8PSBtYXhpbXVtKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLm1heGltdW07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXhjbHVzaXZlTWF4aW11bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG11bHRpcGxlT2YgPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubXVsdGlwbGVPZiA9IG11bHRpcGxlT2Y7XG59O1xuZXhwb3J0IGNvbnN0IGJvb2xlYW5Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgX2N0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGpzb24udHlwZSA9IFwiYm9vbGVhblwiO1xufTtcbmV4cG9ydCBjb25zdCBiaWdpbnRQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHN5bWJvbFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTeW1ib2xzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG51bGxQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICBqc29uLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICBqc29uLm51bGxhYmxlID0gdHJ1ZTtcbiAgICAgICAganNvbi5lbnVtID0gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbi50eXBlID0gXCJudWxsXCI7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB1bmRlZmluZWRQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5kZWZpbmVkIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHZvaWRQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVm9pZCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBuZXZlclByb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAganNvbi5ub3QgPSB7fTtcbn07XG5leHBvcnQgY29uc3QgYW55UHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgLy8gZW1wdHkgc2NoZW1hIGFjY2VwdHMgYW55dGhpbmdcbn07XG5leHBvcnQgY29uc3QgdW5rbm93blByb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIC8vIGVtcHR5IHNjaGVtYSBhY2NlcHRzIGFueXRoaW5nXG59O1xuZXhwb3J0IGNvbnN0IGRhdGVQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0ZSBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBlbnVtUHJvY2Vzc29yID0gKHNjaGVtYSwgX2N0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCB2YWx1ZXMgPSBnZXRFbnVtVmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgICAvLyBOdW1iZXIgZW51bXMgY2FuIGhhdmUgYm90aCBzdHJpbmcgYW5kIG51bWJlciB2YWx1ZXNcbiAgICBpZiAodmFsdWVzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikpXG4gICAgICAgIGpzb24udHlwZSA9IFwibnVtYmVyXCI7XG4gICAgaWYgKHZhbHVlcy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIpKVxuICAgICAgICBqc29uLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgIGpzb24uZW51bSA9IHZhbHVlcztcbn07XG5leHBvcnQgY29uc3QgbGl0ZXJhbFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCB2YWxzID0gW107XG4gICAgZm9yIChjb25zdCB2YWwgb2YgZGVmLnZhbHVlcykge1xuICAgICAgICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaXRlcmFsIGB1bmRlZmluZWRgIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBhZGQgdG8gdmFsc1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaWdJbnQgbGl0ZXJhbHMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFscy5wdXNoKE51bWJlcih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbHMucHVzaCh2YWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh2YWxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBkbyBub3RoaW5nIChhbiB1bmRlZmluZWQgbGl0ZXJhbCB3YXMgc3RyaXBwZWQpXG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHZhbHNbMF07XG4gICAgICAgIGpzb24udHlwZSA9IHZhbCA9PT0gbnVsbCA/IFwibnVsbFwiIDogdHlwZW9mIHZhbDtcbiAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIiB8fCBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgICAgIGpzb24uZW51bSA9IFt2YWxdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAganNvbi5jb25zdCA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHZhbHMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSlcbiAgICAgICAgICAgIGpzb24udHlwZSA9IFwibnVtYmVyXCI7XG4gICAgICAgIGlmICh2YWxzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikpXG4gICAgICAgICAgICBqc29uLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgICAgICBpZiAodmFscy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwiYm9vbGVhblwiKSlcbiAgICAgICAgICAgIGpzb24udHlwZSA9IFwiYm9vbGVhblwiO1xuICAgICAgICBpZiAodmFscy5ldmVyeSgodikgPT4gdiA9PT0gbnVsbCkpXG4gICAgICAgICAgICBqc29uLnR5cGUgPSBcIm51bGxcIjtcbiAgICAgICAganNvbi5lbnVtID0gdmFscztcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG5hblByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOYU4gY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdGVtcGxhdGVMaXRlcmFsUHJvY2Vzc29yID0gKHNjaGVtYSwgX2N0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IF9qc29uID0ganNvbjtcbiAgICBjb25zdCBwYXR0ZXJuID0gc2NoZW1hLl96b2QucGF0dGVybjtcbiAgICBpZiAoIXBhdHRlcm4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhdHRlcm4gbm90IGZvdW5kIGluIHRlbXBsYXRlIGxpdGVyYWxcIik7XG4gICAgX2pzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAgX2pzb24ucGF0dGVybiA9IHBhdHRlcm4uc291cmNlO1xufTtcbmV4cG9ydCBjb25zdCBmaWxlUHJvY2Vzc29yID0gKHNjaGVtYSwgX2N0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IF9qc29uID0ganNvbjtcbiAgICBjb25zdCBmaWxlID0ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiYmluYXJ5XCIsXG4gICAgICAgIGNvbnRlbnRFbmNvZGluZzogXCJiaW5hcnlcIixcbiAgICB9O1xuICAgIGNvbnN0IHsgbWluaW11bSwgbWF4aW11bSwgbWltZSB9ID0gc2NoZW1hLl96b2QuYmFnO1xuICAgIGlmIChtaW5pbXVtICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGZpbGUubWluTGVuZ3RoID0gbWluaW11bTtcbiAgICBpZiAobWF4aW11bSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBmaWxlLm1heExlbmd0aCA9IG1heGltdW07XG4gICAgaWYgKG1pbWUpIHtcbiAgICAgICAgaWYgKG1pbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICBmaWxlLmNvbnRlbnRNZWRpYVR5cGUgPSBtaW1lWzBdO1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihfanNvbiwgZmlsZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF9qc29uLCBmaWxlKTsgLy8gc2hhcmVkIHByb3BzIGF0IHJvb3RcbiAgICAgICAgICAgIF9qc29uLmFueU9mID0gbWltZS5tYXAoKG0pID0+ICh7IGNvbnRlbnRNZWRpYVR5cGU6IG0gfSkpOyAvLyBvbmx5IGNvbnRlbnRNZWRpYVR5cGUgZGlmZmVyc1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBPYmplY3QuYXNzaWduKF9qc29uLCBmaWxlKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHN1Y2Nlc3NQcm9jZXNzb3IgPSAoX3NjaGVtYSwgX2N0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGpzb24udHlwZSA9IFwiYm9vbGVhblwiO1xufTtcbmV4cG9ydCBjb25zdCBjdXN0b21Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3VzdG9tIHR5cGVzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGZ1bmN0aW9uUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZ1bmN0aW9uIHR5cGVzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHRyYW5zZm9ybVByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc2Zvcm1zIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG1hcFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXAgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc2V0UHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNldCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbi8vID09PT09PT09PT09PT09PT09PT09IENPTVBPU0lURSBUWVBFIFBST0NFU1NPUlMgPT09PT09PT09PT09PT09PT09PT1cbmV4cG9ydCBjb25zdCBhcnJheVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtIH0gPSBzY2hlbWEuX3pvZC5iYWc7XG4gICAgaWYgKHR5cGVvZiBtaW5pbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1pbkl0ZW1zID0gbWluaW11bTtcbiAgICBpZiAodHlwZW9mIG1heGltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWF4SXRlbXMgPSBtYXhpbXVtO1xuICAgIGpzb24udHlwZSA9IFwiYXJyYXlcIjtcbiAgICBqc29uLml0ZW1zID0gcHJvY2VzcyhkZWYuZWxlbWVudCwgY3R4LCB7IC4uLnBhcmFtcywgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcIml0ZW1zXCJdIH0pO1xufTtcbmV4cG9ydCBjb25zdCBvYmplY3RQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGpzb24udHlwZSA9IFwib2JqZWN0XCI7XG4gICAganNvbi5wcm9wZXJ0aWVzID0ge307XG4gICAgY29uc3Qgc2hhcGUgPSBkZWYuc2hhcGU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2hhcGUpIHtcbiAgICAgICAganNvbi5wcm9wZXJ0aWVzW2tleV0gPSBwcm9jZXNzKHNoYXBlW2tleV0sIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcInByb3BlcnRpZXNcIiwga2V5XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHJlcXVpcmVkIGtleXNcbiAgICBjb25zdCBhbGxLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhzaGFwZSkpO1xuICAgIGNvbnN0IHJlcXVpcmVkS2V5cyA9IG5ldyBTZXQoWy4uLmFsbEtleXNdLmZpbHRlcigoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBkZWYuc2hhcGVba2V5XS5fem9kO1xuICAgICAgICBpZiAoY3R4LmlvID09PSBcImlucHV0XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2Lm9wdGluID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdi5vcHRvdXQgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH0pKTtcbiAgICBpZiAocmVxdWlyZWRLZXlzLnNpemUgPiAwKSB7XG4gICAgICAgIGpzb24ucmVxdWlyZWQgPSBBcnJheS5mcm9tKHJlcXVpcmVkS2V5cyk7XG4gICAgfVxuICAgIC8vIGNhdGNoYWxsXG4gICAgaWYgKGRlZi5jYXRjaGFsbD8uX3pvZC5kZWYudHlwZSA9PT0gXCJuZXZlclwiKSB7XG4gICAgICAgIC8vIHN0cmljdFxuICAgICAgICBqc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFkZWYuY2F0Y2hhbGwpIHtcbiAgICAgICAgLy8gcmVndWxhclxuICAgICAgICBpZiAoY3R4LmlvID09PSBcIm91dHB1dFwiKVxuICAgICAgICAgICAganNvbi5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZWYuY2F0Y2hhbGwpIHtcbiAgICAgICAganNvbi5hZGRpdGlvbmFsUHJvcGVydGllcyA9IHByb2Nlc3MoZGVmLmNhdGNoYWxsLCBjdHgsIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSxcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB1bmlvblByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIC8vIEV4Y2x1c2l2ZSB1bmlvbnMgKGluY2x1c2l2ZSA9PT0gZmFsc2UpIHVzZSBvbmVPZiAoZXhhY3RseSBvbmUgbWF0Y2gpIGluc3RlYWQgb2YgYW55T2YgKG9uZSBvciBtb3JlIG1hdGNoZXMpXG4gICAgLy8gVGhpcyBpbmNsdWRlcyBib3RoIHoueG9yKCkgYW5kIGRpc2NyaW1pbmF0ZWQgdW5pb25zXG4gICAgY29uc3QgaXNFeGNsdXNpdmUgPSBkZWYuaW5jbHVzaXZlID09PSBmYWxzZTtcbiAgICBjb25zdCBvcHRpb25zID0gZGVmLm9wdGlvbnMubWFwKCh4LCBpKSA9PiBwcm9jZXNzKHgsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgaXNFeGNsdXNpdmUgPyBcIm9uZU9mXCIgOiBcImFueU9mXCIsIGldLFxuICAgIH0pKTtcbiAgICBpZiAoaXNFeGNsdXNpdmUpIHtcbiAgICAgICAganNvbi5vbmVPZiA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uLmFueU9mID0gb3B0aW9ucztcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGludGVyc2VjdGlvblByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGEgPSBwcm9jZXNzKGRlZi5sZWZ0LCBjdHgsIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwiYWxsT2ZcIiwgMF0sXG4gICAgfSk7XG4gICAgY29uc3QgYiA9IHByb2Nlc3MoZGVmLnJpZ2h0LCBjdHgsIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwiYWxsT2ZcIiwgMV0sXG4gICAgfSk7XG4gICAgY29uc3QgaXNTaW1wbGVJbnRlcnNlY3Rpb24gPSAodmFsKSA9PiBcImFsbE9mXCIgaW4gdmFsICYmIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IGFsbE9mID0gW1xuICAgICAgICAuLi4oaXNTaW1wbGVJbnRlcnNlY3Rpb24oYSkgPyBhLmFsbE9mIDogW2FdKSxcbiAgICAgICAgLi4uKGlzU2ltcGxlSW50ZXJzZWN0aW9uKGIpID8gYi5hbGxPZiA6IFtiXSksXG4gICAgXTtcbiAgICBqc29uLmFsbE9mID0gYWxsT2Y7XG59O1xuZXhwb3J0IGNvbnN0IHR1cGxlUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBqc29uLnR5cGUgPSBcImFycmF5XCI7XG4gICAgY29uc3QgcHJlZml4UGF0aCA9IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiID8gXCJwcmVmaXhJdGVtc1wiIDogXCJpdGVtc1wiO1xuICAgIGNvbnN0IHJlc3RQYXRoID0gY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcIml0ZW1zXCIgOiBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIgPyBcIml0ZW1zXCIgOiBcImFkZGl0aW9uYWxJdGVtc1wiO1xuICAgIGNvbnN0IHByZWZpeEl0ZW1zID0gZGVmLml0ZW1zLm1hcCgoeCwgaSkgPT4gcHJvY2Vzcyh4LCBjdHgsIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIHByZWZpeFBhdGgsIGldLFxuICAgIH0pKTtcbiAgICBjb25zdCByZXN0ID0gZGVmLnJlc3RcbiAgICAgICAgPyBwcm9jZXNzKGRlZi5yZXN0LCBjdHgsIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgcmVzdFBhdGgsIC4uLihjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIgPyBbZGVmLml0ZW1zLmxlbmd0aF0gOiBbXSldLFxuICAgICAgICB9KVxuICAgICAgICA6IG51bGw7XG4gICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiKSB7XG4gICAgICAgIGpzb24ucHJlZml4SXRlbXMgPSBwcmVmaXhJdGVtcztcbiAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgIGpzb24uaXRlbXMgPSByZXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICBqc29uLml0ZW1zID0ge1xuICAgICAgICAgICAgYW55T2Y6IHByZWZpeEl0ZW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAganNvbi5pdGVtcy5hbnlPZi5wdXNoKHJlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGpzb24ubWluSXRlbXMgPSBwcmVmaXhJdGVtcy5sZW5ndGg7XG4gICAgICAgIGlmICghcmVzdCkge1xuICAgICAgICAgICAganNvbi5tYXhJdGVtcyA9IHByZWZpeEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbi5pdGVtcyA9IHByZWZpeEl0ZW1zO1xuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAganNvbi5hZGRpdGlvbmFsSXRlbXMgPSByZXN0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGxlbmd0aFxuICAgIGNvbnN0IHsgbWluaW11bSwgbWF4aW11bSB9ID0gc2NoZW1hLl96b2QuYmFnO1xuICAgIGlmICh0eXBlb2YgbWluaW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5taW5JdGVtcyA9IG1pbmltdW07XG4gICAgaWYgKHR5cGVvZiBtYXhpbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1heEl0ZW1zID0gbWF4aW11bTtcbn07XG5leHBvcnQgY29uc3QgcmVjb3JkUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBqc29uLnR5cGUgPSBcIm9iamVjdFwiO1xuICAgIC8vIEZvciBsb29zZVJlY29yZCB3aXRoIHJlZ2V4IHBhdHRlcm5zLCB1c2UgcGF0dGVyblByb3BlcnRpZXNcbiAgICAvLyBUaGlzIGNvcnJlY3RseSByZXByZXNlbnRzIFwib25seSB2YWxpZGF0ZSBrZXlzIG1hdGNoaW5nIHRoZSBwYXR0ZXJuXCIgc2VtYW50aWNzXG4gICAgLy8gYW5kIGNvbXBvc2VzIHdlbGwgd2l0aCBhbGxPZiAoaW50ZXJzZWN0aW9ucylcbiAgICBjb25zdCBrZXlUeXBlID0gZGVmLmtleVR5cGU7XG4gICAgY29uc3Qga2V5QmFnID0ga2V5VHlwZS5fem9kLmJhZztcbiAgICBjb25zdCBwYXR0ZXJucyA9IGtleUJhZz8ucGF0dGVybnM7XG4gICAgaWYgKGRlZi5tb2RlID09PSBcImxvb3NlXCIgJiYgcGF0dGVybnMgJiYgcGF0dGVybnMuc2l6ZSA+IDApIHtcbiAgICAgICAgLy8gVXNlIHBhdHRlcm5Qcm9wZXJ0aWVzIGZvciBsb29zZVJlY29yZCB3aXRoIHJlZ2V4IHBhdHRlcm5zXG4gICAgICAgIGNvbnN0IHZhbHVlU2NoZW1hID0gcHJvY2VzcyhkZWYudmFsdWVUeXBlLCBjdHgsIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJwYXR0ZXJuUHJvcGVydGllc1wiLCBcIipcIl0sXG4gICAgICAgIH0pO1xuICAgICAgICBqc29uLnBhdHRlcm5Qcm9wZXJ0aWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgICAgICAganNvbi5wYXR0ZXJuUHJvcGVydGllc1twYXR0ZXJuLnNvdXJjZV0gPSB2YWx1ZVNjaGVtYTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvcjogdXNlIHByb3BlcnR5TmFtZXMgKyBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgICAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wN1wiIHx8IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiKSB7XG4gICAgICAgICAgICBqc29uLnByb3BlcnR5TmFtZXMgPSBwcm9jZXNzKGRlZi5rZXlUeXBlLCBjdHgsIHtcbiAgICAgICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcInByb3BlcnR5TmFtZXNcIl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBqc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcHJvY2VzcyhkZWYudmFsdWVUeXBlLCBjdHgsIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFkZCByZXF1aXJlZCBmb3Iga2V5cyB3aXRoIGRpc2NyZXRlIHZhbHVlcyAoZW51bSwgbGl0ZXJhbCwgZXRjLilcbiAgICBjb25zdCBrZXlWYWx1ZXMgPSBrZXlUeXBlLl96b2QudmFsdWVzO1xuICAgIGlmIChrZXlWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlWYWx1ZXMgPSBbLi4ua2V5VmFsdWVzXS5maWx0ZXIoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKTtcbiAgICAgICAgaWYgKHZhbGlkS2V5VmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGpzb24ucmVxdWlyZWQgPSB2YWxpZEtleVZhbHVlcztcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbnVsbGFibGVQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBpbm5lciA9IHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbiAgICAgICAganNvbi5udWxsYWJsZSA9IHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uLmFueU9mID0gW2lubmVyLCB7IHR5cGU6IFwibnVsbFwiIH1dO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgbm9ub3B0aW9uYWxQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbn07XG5leHBvcnQgY29uc3QgZGVmYXVsdFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG4gICAganNvbi5kZWZhdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWYuZGVmYXVsdFZhbHVlKSk7XG59O1xuZXhwb3J0IGNvbnN0IHByZWZhdWx0UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbiAgICBpZiAoY3R4LmlvID09PSBcImlucHV0XCIpXG4gICAgICAgIGpzb24uX3ByZWZhdWx0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkZWYuZGVmYXVsdFZhbHVlKSk7XG59O1xuZXhwb3J0IGNvbnN0IGNhdGNoUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbiAgICBsZXQgY2F0Y2hWYWx1ZTtcbiAgICB0cnkge1xuICAgICAgICBjYXRjaFZhbHVlID0gZGVmLmNhdGNoVmFsdWUodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEeW5hbWljIGNhdGNoIHZhbHVlcyBhcmUgbm90IHN1cHBvcnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG4gICAganNvbi5kZWZhdWx0ID0gY2F0Y2hWYWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcGlwZVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBpbm5lclR5cGUgPSBjdHguaW8gPT09IFwiaW5wdXRcIiA/IChkZWYuaW4uX3pvZC5kZWYudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIiA/IGRlZi5vdXQgOiBkZWYuaW4pIDogZGVmLm91dDtcbiAgICBwcm9jZXNzKGlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGlubmVyVHlwZTtcbn07XG5leHBvcnQgY29uc3QgcmVhZG9ubHlQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgIGpzb24ucmVhZE9ubHkgPSB0cnVlO1xufTtcbmV4cG9ydCBjb25zdCBwcm9taXNlUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG59O1xuZXhwb3J0IGNvbnN0IG9wdGlvbmFsUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG59O1xuZXhwb3J0IGNvbnN0IGxhenlQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBpbm5lclR5cGUgPSBzY2hlbWEuX3pvZC5pbm5lclR5cGU7XG4gICAgcHJvY2Vzcyhpbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBpbm5lclR5cGU7XG59O1xuLy8gPT09PT09PT09PT09PT09PT09PT0gQUxMIFBST0NFU1NPUlMgPT09PT09PT09PT09PT09PT09PT1cbmV4cG9ydCBjb25zdCBhbGxQcm9jZXNzb3JzID0ge1xuICAgIHN0cmluZzogc3RyaW5nUHJvY2Vzc29yLFxuICAgIG51bWJlcjogbnVtYmVyUHJvY2Vzc29yLFxuICAgIGJvb2xlYW46IGJvb2xlYW5Qcm9jZXNzb3IsXG4gICAgYmlnaW50OiBiaWdpbnRQcm9jZXNzb3IsXG4gICAgc3ltYm9sOiBzeW1ib2xQcm9jZXNzb3IsXG4gICAgbnVsbDogbnVsbFByb2Nlc3NvcixcbiAgICB1bmRlZmluZWQ6IHVuZGVmaW5lZFByb2Nlc3NvcixcbiAgICB2b2lkOiB2b2lkUHJvY2Vzc29yLFxuICAgIG5ldmVyOiBuZXZlclByb2Nlc3NvcixcbiAgICBhbnk6IGFueVByb2Nlc3NvcixcbiAgICB1bmtub3duOiB1bmtub3duUHJvY2Vzc29yLFxuICAgIGRhdGU6IGRhdGVQcm9jZXNzb3IsXG4gICAgZW51bTogZW51bVByb2Nlc3NvcixcbiAgICBsaXRlcmFsOiBsaXRlcmFsUHJvY2Vzc29yLFxuICAgIG5hbjogbmFuUHJvY2Vzc29yLFxuICAgIHRlbXBsYXRlX2xpdGVyYWw6IHRlbXBsYXRlTGl0ZXJhbFByb2Nlc3NvcixcbiAgICBmaWxlOiBmaWxlUHJvY2Vzc29yLFxuICAgIHN1Y2Nlc3M6IHN1Y2Nlc3NQcm9jZXNzb3IsXG4gICAgY3VzdG9tOiBjdXN0b21Qcm9jZXNzb3IsXG4gICAgZnVuY3Rpb246IGZ1bmN0aW9uUHJvY2Vzc29yLFxuICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtUHJvY2Vzc29yLFxuICAgIG1hcDogbWFwUHJvY2Vzc29yLFxuICAgIHNldDogc2V0UHJvY2Vzc29yLFxuICAgIGFycmF5OiBhcnJheVByb2Nlc3NvcixcbiAgICBvYmplY3Q6IG9iamVjdFByb2Nlc3NvcixcbiAgICB1bmlvbjogdW5pb25Qcm9jZXNzb3IsXG4gICAgaW50ZXJzZWN0aW9uOiBpbnRlcnNlY3Rpb25Qcm9jZXNzb3IsXG4gICAgdHVwbGU6IHR1cGxlUHJvY2Vzc29yLFxuICAgIHJlY29yZDogcmVjb3JkUHJvY2Vzc29yLFxuICAgIG51bGxhYmxlOiBudWxsYWJsZVByb2Nlc3NvcixcbiAgICBub25vcHRpb25hbDogbm9ub3B0aW9uYWxQcm9jZXNzb3IsXG4gICAgZGVmYXVsdDogZGVmYXVsdFByb2Nlc3NvcixcbiAgICBwcmVmYXVsdDogcHJlZmF1bHRQcm9jZXNzb3IsXG4gICAgY2F0Y2g6IGNhdGNoUHJvY2Vzc29yLFxuICAgIHBpcGU6IHBpcGVQcm9jZXNzb3IsXG4gICAgcmVhZG9ubHk6IHJlYWRvbmx5UHJvY2Vzc29yLFxuICAgIHByb21pc2U6IHByb21pc2VQcm9jZXNzb3IsXG4gICAgb3B0aW9uYWw6IG9wdGlvbmFsUHJvY2Vzc29yLFxuICAgIGxhenk6IGxhenlQcm9jZXNzb3IsXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHRvSlNPTlNjaGVtYShpbnB1dCwgcGFyYW1zKSB7XG4gICAgaWYgKFwiX2lkbWFwXCIgaW4gaW5wdXQpIHtcbiAgICAgICAgLy8gUmVnaXN0cnkgY2FzZVxuICAgICAgICBjb25zdCByZWdpc3RyeSA9IGlucHV0O1xuICAgICAgICBjb25zdCBjdHggPSBpbml0aWFsaXplQ29udGV4dCh7IC4uLnBhcmFtcywgcHJvY2Vzc29yczogYWxsUHJvY2Vzc29ycyB9KTtcbiAgICAgICAgY29uc3QgZGVmcyA9IHt9O1xuICAgICAgICAvLyBGaXJzdCBwYXNzOiBwcm9jZXNzIGFsbCBzY2hlbWFzIHRvIGJ1aWxkIHRoZSBzZWVuIG1hcFxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlZ2lzdHJ5Ll9pZG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtfLCBzY2hlbWFdID0gZW50cnk7XG4gICAgICAgICAgICBwcm9jZXNzKHNjaGVtYSwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY2hlbWFzID0ge307XG4gICAgICAgIGNvbnN0IGV4dGVybmFsID0ge1xuICAgICAgICAgICAgcmVnaXN0cnksXG4gICAgICAgICAgICB1cmk6IHBhcmFtcz8udXJpLFxuICAgICAgICAgICAgZGVmcyxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBjb250ZXh0IHdpdGggZXh0ZXJuYWwgY29uZmlndXJhdGlvblxuICAgICAgICBjdHguZXh0ZXJuYWwgPSBleHRlcm5hbDtcbiAgICAgICAgLy8gU2Vjb25kIHBhc3M6IGVtaXQgZWFjaCBzY2hlbWFcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZWdpc3RyeS5faWRtYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBba2V5LCBzY2hlbWFdID0gZW50cnk7XG4gICAgICAgICAgICBleHRyYWN0RGVmcyhjdHgsIHNjaGVtYSk7XG4gICAgICAgICAgICBzY2hlbWFzW2tleV0gPSBmaW5hbGl6ZShjdHgsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRlZnMpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZnNTZWdtZW50ID0gY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcIiRkZWZzXCIgOiBcImRlZmluaXRpb25zXCI7XG4gICAgICAgICAgICBzY2hlbWFzLl9fc2hhcmVkID0ge1xuICAgICAgICAgICAgICAgIFtkZWZzU2VnbWVudF06IGRlZnMsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNjaGVtYXMgfTtcbiAgICB9XG4gICAgLy8gU2luZ2xlIHNjaGVtYSBjYXNlXG4gICAgY29uc3QgY3R4ID0gaW5pdGlhbGl6ZUNvbnRleHQoeyAuLi5wYXJhbXMsIHByb2Nlc3NvcnM6IGFsbFByb2Nlc3NvcnMgfSk7XG4gICAgcHJvY2VzcyhpbnB1dCwgY3R4KTtcbiAgICBleHRyYWN0RGVmcyhjdHgsIGlucHV0KTtcbiAgICByZXR1cm4gZmluYWxpemUoY3R4LCBpbnB1dCk7XG59XG4iLCBudWxsLCAiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgdXRpbCB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgKiBhcyBwcm9jZXNzb3JzIGZyb20gXCIuLi9jb3JlL2pzb24tc2NoZW1hLXByb2Nlc3NvcnMuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZCwgY3JlYXRlVG9KU09OU2NoZW1hTWV0aG9kIH0gZnJvbSBcIi4uL2NvcmUvdG8tanNvbi1zY2hlbWEuanNcIjtcbmltcG9ydCAqIGFzIGNoZWNrcyBmcm9tIFwiLi9jaGVja3MuanNcIjtcbmltcG9ydCAqIGFzIGlzbyBmcm9tIFwiLi9pc28uanNcIjtcbmltcG9ydCAqIGFzIHBhcnNlIGZyb20gXCIuL3BhcnNlLmpzXCI7XG5leHBvcnQgY29uc3QgWm9kVHlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RUeXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBPYmplY3QuYXNzaWduKGluc3RbXCJ+c3RhbmRhcmRcIl0sIHtcbiAgICAgICAganNvblNjaGVtYToge1xuICAgICAgICAgICAgaW5wdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChpbnN0LCBcImlucHV0XCIpLFxuICAgICAgICAgICAgb3V0cHV0OiBjcmVhdGVTdGFuZGFyZEpTT05TY2hlbWFNZXRob2QoaW5zdCwgXCJvdXRwdXRcIiksXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgaW5zdC50b0pTT05TY2hlbWEgPSBjcmVhdGVUb0pTT05TY2hlbWFNZXRob2QoaW5zdCwge30pO1xuICAgIGluc3QuZGVmID0gZGVmO1xuICAgIGluc3QudHlwZSA9IGRlZi50eXBlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl9kZWZcIiwgeyB2YWx1ZTogZGVmIH0pO1xuICAgIC8vIGJhc2UgbWV0aG9kc1xuICAgIGluc3QuY2hlY2sgPSAoLi4uY2hlY2tzKSA9PiB7XG4gICAgICAgIHJldHVybiBpbnN0LmNsb25lKHV0aWwubWVyZ2VEZWZzKGRlZiwge1xuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4uKGRlZi5jaGVja3MgPz8gW10pLFxuICAgICAgICAgICAgICAgIC4uLmNoZWNrcy5tYXAoKGNoKSA9PiB0eXBlb2YgY2ggPT09IFwiZnVuY3Rpb25cIiA/IHsgX3pvZDogeyBjaGVjazogY2gsIGRlZjogeyBjaGVjazogXCJjdXN0b21cIiB9LCBvbmF0dGFjaDogW10gfSB9IDogY2gpLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSksIHtcbiAgICAgICAgICAgIHBhcmVudDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpbnN0LndpdGggPSBpbnN0LmNoZWNrO1xuICAgIGluc3QuY2xvbmUgPSAoZGVmLCBwYXJhbXMpID0+IGNvcmUuY2xvbmUoaW5zdCwgZGVmLCBwYXJhbXMpO1xuICAgIGluc3QuYnJhbmQgPSAoKSA9PiBpbnN0O1xuICAgIGluc3QucmVnaXN0ZXIgPSAoKHJlZywgbWV0YSkgPT4ge1xuICAgICAgICByZWcuYWRkKGluc3QsIG1ldGEpO1xuICAgICAgICByZXR1cm4gaW5zdDtcbiAgICB9KTtcbiAgICAvLyBwYXJzaW5nXG4gICAgaW5zdC5wYXJzZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnBhcnNlKGluc3QsIGRhdGEsIHBhcmFtcywgeyBjYWxsZWU6IGluc3QucGFyc2UgfSk7XG4gICAgaW5zdC5zYWZlUGFyc2UgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlUGFyc2UoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnBhcnNlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5wYXJzZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcywgeyBjYWxsZWU6IGluc3QucGFyc2VBc3luYyB9KTtcbiAgICBpbnN0LnNhZmVQYXJzZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZVBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnNwYSA9IGluc3Quc2FmZVBhcnNlQXN5bmM7XG4gICAgLy8gZW5jb2RpbmcvZGVjb2RpbmdcbiAgICBpbnN0LmVuY29kZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLmVuY29kZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3QuZGVjb2RlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZGVjb2RlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5lbmNvZGVBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLmVuY29kZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5kZWNvZGVBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLmRlY29kZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zYWZlRW5jb2RlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZUVuY29kZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc2FmZURlY29kZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVEZWNvZGUoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnNhZmVFbmNvZGVBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVFbmNvZGVBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc2FmZURlY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZURlY29kZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgLy8gcmVmaW5lbWVudHNcbiAgICBpbnN0LnJlZmluZSA9IChjaGVjaywgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKHJlZmluZShjaGVjaywgcGFyYW1zKSk7XG4gICAgaW5zdC5zdXBlclJlZmluZSA9IChyZWZpbmVtZW50KSA9PiBpbnN0LmNoZWNrKHN1cGVyUmVmaW5lKHJlZmluZW1lbnQpKTtcbiAgICBpbnN0Lm92ZXJ3cml0ZSA9IChmbikgPT4gaW5zdC5jaGVjayhjaGVja3Mub3ZlcndyaXRlKGZuKSk7XG4gICAgLy8gd3JhcHBlcnNcbiAgICBpbnN0Lm9wdGlvbmFsID0gKCkgPT4gb3B0aW9uYWwoaW5zdCk7XG4gICAgaW5zdC5leGFjdE9wdGlvbmFsID0gKCkgPT4gZXhhY3RPcHRpb25hbChpbnN0KTtcbiAgICBpbnN0Lm51bGxhYmxlID0gKCkgPT4gbnVsbGFibGUoaW5zdCk7XG4gICAgaW5zdC5udWxsaXNoID0gKCkgPT4gb3B0aW9uYWwobnVsbGFibGUoaW5zdCkpO1xuICAgIGluc3Qubm9ub3B0aW9uYWwgPSAocGFyYW1zKSA9PiBub25vcHRpb25hbChpbnN0LCBwYXJhbXMpO1xuICAgIGluc3QuYXJyYXkgPSAoKSA9PiBhcnJheShpbnN0KTtcbiAgICBpbnN0Lm9yID0gKGFyZykgPT4gdW5pb24oW2luc3QsIGFyZ10pO1xuICAgIGluc3QuYW5kID0gKGFyZykgPT4gaW50ZXJzZWN0aW9uKGluc3QsIGFyZyk7XG4gICAgaW5zdC50cmFuc2Zvcm0gPSAodHgpID0+IHBpcGUoaW5zdCwgdHJhbnNmb3JtKHR4KSk7XG4gICAgaW5zdC5kZWZhdWx0ID0gKGRlZikgPT4gX2RlZmF1bHQoaW5zdCwgZGVmKTtcbiAgICBpbnN0LnByZWZhdWx0ID0gKGRlZikgPT4gcHJlZmF1bHQoaW5zdCwgZGVmKTtcbiAgICAvLyBpbnN0LmNvYWxlc2NlID0gKGRlZiwgcGFyYW1zKSA9PiBjb2FsZXNjZShpbnN0LCBkZWYsIHBhcmFtcyk7XG4gICAgaW5zdC5jYXRjaCA9IChwYXJhbXMpID0+IF9jYXRjaChpbnN0LCBwYXJhbXMpO1xuICAgIGluc3QucGlwZSA9ICh0YXJnZXQpID0+IHBpcGUoaW5zdCwgdGFyZ2V0KTtcbiAgICBpbnN0LnJlYWRvbmx5ID0gKCkgPT4gcmVhZG9ubHkoaW5zdCk7XG4gICAgLy8gbWV0YVxuICAgIGluc3QuZGVzY3JpYmUgPSAoZGVzY3JpcHRpb24pID0+IHtcbiAgICAgICAgY29uc3QgY2wgPSBpbnN0LmNsb25lKCk7XG4gICAgICAgIGNvcmUuZ2xvYmFsUmVnaXN0cnkuYWRkKGNsLCB7IGRlc2NyaXB0aW9uIH0pO1xuICAgICAgICByZXR1cm4gY2w7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJkZXNjcmlwdGlvblwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLmdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KT8uZGVzY3JpcHRpb247XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBpbnN0Lm1ldGEgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBjb3JlLmdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjbCA9IGluc3QuY2xvbmUoKTtcbiAgICAgICAgY29yZS5nbG9iYWxSZWdpc3RyeS5hZGQoY2wsIGFyZ3NbMF0pO1xuICAgICAgICByZXR1cm4gY2w7XG4gICAgfTtcbiAgICAvLyBoZWxwZXJzXG4gICAgaW5zdC5pc09wdGlvbmFsID0gKCkgPT4gaW5zdC5zYWZlUGFyc2UodW5kZWZpbmVkKS5zdWNjZXNzO1xuICAgIGluc3QuaXNOdWxsYWJsZSA9ICgpID0+IGluc3Quc2FmZVBhcnNlKG51bGwpLnN1Y2Nlc3M7XG4gICAgaW5zdC5hcHBseSA9IChmbikgPT4gZm4oaW5zdCk7XG4gICAgcmV0dXJuIGluc3Q7XG59KTtcbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBjb25zdCBfWm9kU3RyaW5nID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIl9ab2RTdHJpbmdcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnN0cmluZ1Byb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICBpbnN0LmZvcm1hdCA9IGJhZy5mb3JtYXQgPz8gbnVsbDtcbiAgICBpbnN0Lm1pbkxlbmd0aCA9IGJhZy5taW5pbXVtID8/IG51bGw7XG4gICAgaW5zdC5tYXhMZW5ndGggPSBiYWcubWF4aW11bSA/PyBudWxsO1xuICAgIC8vIHZhbGlkYXRpb25zXG4gICAgaW5zdC5yZWdleCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5yZWdleCguLi5hcmdzKSk7XG4gICAgaW5zdC5pbmNsdWRlcyA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5pbmNsdWRlcyguLi5hcmdzKSk7XG4gICAgaW5zdC5zdGFydHNXaXRoID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLnN0YXJ0c1dpdGgoLi4uYXJncykpO1xuICAgIGluc3QuZW5kc1dpdGggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MuZW5kc1dpdGgoLi4uYXJncykpO1xuICAgIGluc3QubWluID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLm1pbkxlbmd0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5tYXggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MubWF4TGVuZ3RoKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lmxlbmd0aCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sZW5ndGgoLi4uYXJncykpO1xuICAgIGluc3Qubm9uZW1wdHkgPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MubWluTGVuZ3RoKDEsIC4uLmFyZ3MpKTtcbiAgICBpbnN0Lmxvd2VyY2FzZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmxvd2VyY2FzZShwYXJhbXMpKTtcbiAgICBpbnN0LnVwcGVyY2FzZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLnVwcGVyY2FzZShwYXJhbXMpKTtcbiAgICAvLyB0cmFuc2Zvcm1zXG4gICAgaW5zdC50cmltID0gKCkgPT4gaW5zdC5jaGVjayhjaGVja3MudHJpbSgpKTtcbiAgICBpbnN0Lm5vcm1hbGl6ZSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ub3JtYWxpemUoLi4uYXJncykpO1xuICAgIGluc3QudG9Mb3dlckNhc2UgPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy50b0xvd2VyQ2FzZSgpKTtcbiAgICBpbnN0LnRvVXBwZXJDYXNlID0gKCkgPT4gaW5zdC5jaGVjayhjaGVja3MudG9VcHBlckNhc2UoKSk7XG4gICAgaW5zdC5zbHVnaWZ5ID0gKCkgPT4gaW5zdC5jaGVjayhjaGVja3Muc2x1Z2lmeSgpKTtcbn0pO1xuZXhwb3J0IGNvbnN0IFpvZFN0cmluZyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTdHJpbmdcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG4gICAgX1pvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5lbWFpbCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fZW1haWwoWm9kRW1haWwsIHBhcmFtcykpO1xuICAgIGluc3QudXJsID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91cmwoWm9kVVJMLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmp3dCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fand0KFpvZEpXVCwgcGFyYW1zKSk7XG4gICAgaW5zdC5lbW9qaSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fZW1vamkoWm9kRW1vamksIHBhcmFtcykpO1xuICAgIGluc3QuZ3VpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fZ3VpZChab2RHVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LnV1aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3V1aWQoWm9kVVVJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC51dWlkdjQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3V1aWR2NChab2RVVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LnV1aWR2NiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXVpZHY2KFpvZFVVSUQsIHBhcmFtcykpO1xuICAgIGluc3QudXVpZHY3ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91dWlkdjcoWm9kVVVJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5uYW5vaWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX25hbm9pZChab2ROYW5vSUQsIHBhcmFtcykpO1xuICAgIGluc3QuZ3VpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fZ3VpZChab2RHVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LmN1aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2N1aWQoWm9kQ1VJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5jdWlkMiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fY3VpZDIoWm9kQ1VJRDIsIHBhcmFtcykpO1xuICAgIGluc3QudWxpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdWxpZChab2RVTElELCBwYXJhbXMpKTtcbiAgICBpbnN0LmJhc2U2NCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fYmFzZTY0KFpvZEJhc2U2NCwgcGFyYW1zKSk7XG4gICAgaW5zdC5iYXNlNjR1cmwgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2Jhc2U2NHVybChab2RCYXNlNjRVUkwsIHBhcmFtcykpO1xuICAgIGluc3QueGlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl94aWQoWm9kWElELCBwYXJhbXMpKTtcbiAgICBpbnN0LmtzdWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9rc3VpZChab2RLU1VJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5pcHY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9pcHY0KFpvZElQdjQsIHBhcmFtcykpO1xuICAgIGluc3QuaXB2NiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5faXB2Nihab2RJUHY2LCBwYXJhbXMpKTtcbiAgICBpbnN0LmNpZHJ2NCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fY2lkcnY0KFpvZENJRFJ2NCwgcGFyYW1zKSk7XG4gICAgaW5zdC5jaWRydjYgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2NpZHJ2Nihab2RDSURSdjYsIHBhcmFtcykpO1xuICAgIGluc3QuZTE2NCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fZTE2NChab2RFMTY0LCBwYXJhbXMpKTtcbiAgICAvLyBpc29cbiAgICBpbnN0LmRhdGV0aW1lID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpc28uZGF0ZXRpbWUocGFyYW1zKSk7XG4gICAgaW5zdC5kYXRlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpc28uZGF0ZShwYXJhbXMpKTtcbiAgICBpbnN0LnRpbWUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGlzby50aW1lKHBhcmFtcykpO1xuICAgIGluc3QuZHVyYXRpb24gPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGlzby5kdXJhdGlvbihwYXJhbXMpKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZyhwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fc3RyaW5nKFpvZFN0cmluZywgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RTdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIF9ab2RTdHJpbmcuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgWm9kRW1haWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRW1haWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kRW1haWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBlbWFpbChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZW1haWwoWm9kRW1haWwsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kR1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RHVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEdVSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBndWlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9ndWlkKFpvZEdVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVVVJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZFVVSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1dWlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91dWlkKFpvZFVVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdXVpZHY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91dWlkdjQoWm9kVVVJRCwgcGFyYW1zKTtcbn1cbi8vIFpvZFVVSUR2NlxuZXhwb3J0IGZ1bmN0aW9uIHV1aWR2NihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXVpZHY2KFpvZFVVSUQsIHBhcmFtcyk7XG59XG4vLyBab2RVVUlEdjdcbmV4cG9ydCBmdW5jdGlvbiB1dWlkdjcocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3V1aWR2Nyhab2RVVUlELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFVSTCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVUkxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kVVJMLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdXJsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91cmwoWm9kVVJMLCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGh0dHBVcmwocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VybChab2RVUkwsIHtcbiAgICAgICAgcHJvdG9jb2w6IC9eaHR0cHM/JC8sXG4gICAgICAgIGhvc3RuYW1lOiBjb3JlLnJlZ2V4ZXMuZG9tYWluLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEVtb2ppID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEVtb2ppXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEVtb2ppLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZW1vamkocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2Vtb2ppKFpvZEVtb2ppLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZE5hbm9JRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROYW5vSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kTmFub0lELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbmFub2lkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9uYW5vaWQoWm9kTmFub0lELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZENVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RDVUlELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gY3VpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY3VpZChab2RDVUlELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZENVSUQyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENVSUQyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZENVSUQyLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gY3VpZDIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2N1aWQyKFpvZENVSUQyLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFVMSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVUxJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RVTElELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdWxpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdWxpZChab2RVTElELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFhJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RYSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kWElELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24geGlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl94aWQoWm9kWElELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEtTVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEtTVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEtTVUlELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24ga3N1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2tzdWlkKFpvZEtTVUlELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZElQdjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSVB2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RJUHY0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gaXB2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faXB2NChab2RJUHY0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZE1BQyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RNQUNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kTUFDLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbWFjKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9tYWMoWm9kTUFDLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZElQdjYgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSVB2NlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RJUHY2LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gaXB2NihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faXB2Nihab2RJUHY2LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZENJRFJ2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDSURSdjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZENJRFJ2NC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGNpZHJ2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY2lkcnY0KFpvZENJRFJ2NCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RDSURSdjYgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ0lEUnY2XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RDSURSdjYuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjaWRydjYocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2NpZHJ2Nihab2RDSURSdjYsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQmFzZTY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEJhc2U2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RCYXNlNjQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2Jhc2U2NChab2RCYXNlNjQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQmFzZTY0VVJMID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEJhc2U2NFVSTFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RCYXNlNjRVUkwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjR1cmwocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2Jhc2U2NHVybChab2RCYXNlNjRVUkwsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kRTE2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RFMTY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEUxNjQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBlMTY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9lMTY0KFpvZEUxNjQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSldUID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEpXVFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RKV1QuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBqd3QocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2p3dChab2RKV1QsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ3VzdG9tU3RyaW5nRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEN1c3RvbVN0cmluZ0Zvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RDdXN0b21TdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdGb3JtYXQoZm9ybWF0LCBmbk9yUmVnZXgsIF9wYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmdGb3JtYXQoWm9kQ3VzdG9tU3RyaW5nRm9ybWF0LCBmb3JtYXQsIGZuT3JSZWdleCwgX3BhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaG9zdG5hbWUoX3BhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmdGb3JtYXQoWm9kQ3VzdG9tU3RyaW5nRm9ybWF0LCBcImhvc3RuYW1lXCIsIGNvcmUucmVnZXhlcy5ob3N0bmFtZSwgX3BhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4KF9wYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fc3RyaW5nRm9ybWF0KFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCwgXCJoZXhcIiwgY29yZS5yZWdleGVzLmhleCwgX3BhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzaChhbGcsIHBhcmFtcykge1xuICAgIGNvbnN0IGVuYyA9IHBhcmFtcz8uZW5jID8/IFwiaGV4XCI7XG4gICAgY29uc3QgZm9ybWF0ID0gYCR7YWxnfV8ke2VuY31gO1xuICAgIGNvbnN0IHJlZ2V4ID0gY29yZS5yZWdleGVzW2Zvcm1hdF07XG4gICAgaWYgKCFyZWdleClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQgaGFzaCBmb3JtYXQ6ICR7Zm9ybWF0fWApO1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmdGb3JtYXQoWm9kQ3VzdG9tU3RyaW5nRm9ybWF0LCBmb3JtYXQsIHJlZ2V4LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZE51bWJlciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROdW1iZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE51bWJlci5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm51bWJlclByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5ndCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndCh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1pbiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubHQgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHQodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubHRlID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0LmludCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaW50KHBhcmFtcykpO1xuICAgIGluc3Quc2FmZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaW50KHBhcmFtcykpO1xuICAgIGluc3QucG9zaXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndCgwLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbm5lZ2F0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKDAsIHBhcmFtcykpO1xuICAgIGluc3QubmVnYXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdCgwLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbnBvc2l0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKDAsIHBhcmFtcykpO1xuICAgIGluc3QubXVsdGlwbGVPZiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tdWx0aXBsZU9mKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0LnN0ZXAgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubXVsdGlwbGVPZih2YWx1ZSwgcGFyYW1zKSk7XG4gICAgLy8gaW5zdC5maW5pdGUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuZmluaXRlKHBhcmFtcykpO1xuICAgIGluc3QuZmluaXRlID0gKCkgPT4gaW5zdDtcbiAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgIGluc3QubWluVmFsdWUgPVxuICAgICAgICBNYXRoLm1heChiYWcubWluaW11bSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIGJhZy5leGNsdXNpdmVNaW5pbXVtID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSkgPz8gbnVsbDtcbiAgICBpbnN0Lm1heFZhbHVlID1cbiAgICAgICAgTWF0aC5taW4oYmFnLm1heGltdW0gPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLCBiYWcuZXhjbHVzaXZlTWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpID8/IG51bGw7XG4gICAgaW5zdC5pc0ludCA9IChiYWcuZm9ybWF0ID8/IFwiXCIpLmluY2x1ZGVzKFwiaW50XCIpIHx8IE51bWJlci5pc1NhZmVJbnRlZ2VyKGJhZy5tdWx0aXBsZU9mID8/IDAuNSk7XG4gICAgaW5zdC5pc0Zpbml0ZSA9IHRydWU7XG4gICAgaW5zdC5mb3JtYXQgPSBiYWcuZm9ybWF0ID8/IG51bGw7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBudW1iZXIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX251bWJlcihab2ROdW1iZXIsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTnVtYmVyRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE51bWJlckZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTnVtYmVyRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2ROdW1iZXIuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gaW50KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pbnQoWm9kTnVtYmVyRm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0MzIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2Zsb2F0MzIoWm9kTnVtYmVyRm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0NjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2Zsb2F0NjQoWm9kTnVtYmVyRm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGludDMyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pbnQzMihab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdWludDMyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91aW50MzIoWm9kTnVtYmVyRm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEJvb2xlYW4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQm9vbGVhblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQm9vbGVhbi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmJvb2xlYW5Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYm9vbGVhbihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYm9vbGVhbihab2RCb29sZWFuLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEJpZ0ludCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCaWdJbnRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEJpZ0ludC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmJpZ2ludFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5ndGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1pbiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QuZ3QgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3QodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QuZ3RlID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5taW4gPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmx0ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0KHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmx0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5wb3NpdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0KEJpZ0ludCgwKSwgcGFyYW1zKSk7XG4gICAgaW5zdC5uZWdhdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0KEJpZ0ludCgwKSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ub25wb3NpdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZShCaWdJbnQoMCksIHBhcmFtcykpO1xuICAgIGluc3Qubm9ubmVnYXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUoQmlnSW50KDApLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm11bHRpcGxlT2YgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubXVsdGlwbGVPZih2YWx1ZSwgcGFyYW1zKSk7XG4gICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICBpbnN0Lm1pblZhbHVlID0gYmFnLm1pbmltdW0gPz8gbnVsbDtcbiAgICBpbnN0Lm1heFZhbHVlID0gYmFnLm1heGltdW0gPz8gbnVsbDtcbiAgICBpbnN0LmZvcm1hdCA9IGJhZy5mb3JtYXQgPz8gbnVsbDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGJpZ2ludChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYmlnaW50KFpvZEJpZ0ludCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCaWdJbnRGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQmlnSW50Rm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RCaWdJbnRGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZEJpZ0ludC5pbml0KGluc3QsIGRlZik7XG59KTtcbi8vIGludDY0XG5leHBvcnQgZnVuY3Rpb24gaW50NjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ludDY0KFpvZEJpZ0ludEZvcm1hdCwgcGFyYW1zKTtcbn1cbi8vIHVpbnQ2NFxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdWludDY0KFpvZEJpZ0ludEZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RTeW1ib2wgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kU3ltYm9sXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTeW1ib2wuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5zeW1ib2xQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc3ltYm9sKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9zeW1ib2woWm9kU3ltYm9sLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFVuZGVmaW5lZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVbmRlZmluZWRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFVuZGVmaW5lZC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnVuZGVmaW5lZFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmZ1bmN0aW9uIF91bmRlZmluZWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VuZGVmaW5lZChab2RVbmRlZmluZWQsIHBhcmFtcyk7XG59XG5leHBvcnQgeyBfdW5kZWZpbmVkIGFzIHVuZGVmaW5lZCB9O1xuZXhwb3J0IGNvbnN0IFpvZE51bGwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTnVsbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTnVsbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm51bGxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5mdW5jdGlvbiBfbnVsbChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbnVsbChab2ROdWxsLCBwYXJhbXMpO1xufVxuZXhwb3J0IHsgX251bGwgYXMgbnVsbCB9O1xuZXhwb3J0IGNvbnN0IFpvZEFueSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RBbnlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEFueS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmFueVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBhbnkoKSB7XG4gICAgcmV0dXJuIGNvcmUuX2FueShab2RBbnkpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFVua25vd24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVW5rbm93blwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVW5rbm93bi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnVua25vd25Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgICByZXR1cm4gY29yZS5fdW5rbm93bihab2RVbmtub3duKTtcbn1cbmV4cG9ydCBjb25zdCBab2ROZXZlciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROZXZlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTmV2ZXIuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5uZXZlclByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBuZXZlcihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbmV2ZXIoWm9kTmV2ZXIsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVm9pZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RWb2lkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RWb2lkLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudm9pZFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmZ1bmN0aW9uIF92b2lkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl92b2lkKFpvZFZvaWQsIHBhcmFtcyk7XG59XG5leHBvcnQgeyBfdm9pZCBhcyB2b2lkIH07XG5leHBvcnQgY29uc3QgWm9kRGF0ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2REYXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2REYXRlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuZGF0ZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5taW4gPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGNvbnN0IGMgPSBpbnN0Ll96b2QuYmFnO1xuICAgIGluc3QubWluRGF0ZSA9IGMubWluaW11bSA/IG5ldyBEYXRlKGMubWluaW11bSkgOiBudWxsO1xuICAgIGluc3QubWF4RGF0ZSA9IGMubWF4aW11bSA/IG5ldyBEYXRlKGMubWF4aW11bSkgOiBudWxsO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZGF0ZShab2REYXRlLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEFycmF5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEFycmF5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RBcnJheS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmFycmF5UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LmVsZW1lbnQgPSBkZWYuZWxlbWVudDtcbiAgICBpbnN0Lm1pbiA9IChtaW5MZW5ndGgsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubWluTGVuZ3RoKG1pbkxlbmd0aCwgcGFyYW1zKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm1pbkxlbmd0aCgxLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9IChtYXhMZW5ndGgsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubWF4TGVuZ3RoKG1heExlbmd0aCwgcGFyYW1zKSk7XG4gICAgaW5zdC5sZW5ndGggPSAobGVuLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmxlbmd0aChsZW4sIHBhcmFtcykpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5lbGVtZW50O1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYXJyYXkoZWxlbWVudCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2FycmF5KFpvZEFycmF5LCBlbGVtZW50LCBwYXJhbXMpO1xufVxuLy8gLmtleW9mXG5leHBvcnQgZnVuY3Rpb24ga2V5b2Yoc2NoZW1hKSB7XG4gICAgY29uc3Qgc2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgcmV0dXJuIF9lbnVtKE9iamVjdC5rZXlzKHNoYXBlKSk7XG59XG5leHBvcnQgY29uc3QgWm9kT2JqZWN0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kT2JqZWN0SklULmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMub2JqZWN0UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdCwgXCJzaGFwZVwiLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYuc2hhcGU7XG4gICAgfSk7XG4gICAgaW5zdC5rZXlvZiA9ICgpID0+IF9lbnVtKE9iamVjdC5rZXlzKGluc3QuX3pvZC5kZWYuc2hhcGUpKTtcbiAgICBpbnN0LmNhdGNoYWxsID0gKGNhdGNoYWxsKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IGNhdGNoYWxsIH0pO1xuICAgIGluc3QucGFzc3Rocm91Z2ggPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVua25vd24oKSB9KTtcbiAgICBpbnN0Lmxvb3NlID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB1bmtub3duKCkgfSk7XG4gICAgaW5zdC5zdHJpY3QgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IG5ldmVyKCkgfSk7XG4gICAgaW5zdC5zdHJpcCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5kZWZpbmVkIH0pO1xuICAgIGluc3QuZXh0ZW5kID0gKGluY29taW5nKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLmV4dGVuZChpbnN0LCBpbmNvbWluZyk7XG4gICAgfTtcbiAgICBpbnN0LnNhZmVFeHRlbmQgPSAoaW5jb21pbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuc2FmZUV4dGVuZChpbnN0LCBpbmNvbWluZyk7XG4gICAgfTtcbiAgICBpbnN0Lm1lcmdlID0gKG90aGVyKSA9PiB1dGlsLm1lcmdlKGluc3QsIG90aGVyKTtcbiAgICBpbnN0LnBpY2sgPSAobWFzaykgPT4gdXRpbC5waWNrKGluc3QsIG1hc2spO1xuICAgIGluc3Qub21pdCA9IChtYXNrKSA9PiB1dGlsLm9taXQoaW5zdCwgbWFzayk7XG4gICAgaW5zdC5wYXJ0aWFsID0gKC4uLmFyZ3MpID0+IHV0aWwucGFydGlhbChab2RPcHRpb25hbCwgaW5zdCwgYXJnc1swXSk7XG4gICAgaW5zdC5yZXF1aXJlZCA9ICguLi5hcmdzKSA9PiB1dGlsLnJlcXVpcmVkKFpvZE5vbk9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG9iamVjdChzaGFwZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgZGVmID0ge1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBzaGFwZTogc2hhcGUgPz8ge30sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdChkZWYpO1xufVxuLy8gc3RyaWN0T2JqZWN0XG5leHBvcnQgZnVuY3Rpb24gc3RyaWN0T2JqZWN0KHNoYXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHNoYXBlLFxuICAgICAgICBjYXRjaGFsbDogbmV2ZXIoKSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIGxvb3NlT2JqZWN0XG5leHBvcnQgZnVuY3Rpb24gbG9vc2VPYmplY3Qoc2hhcGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIGNhdGNoYWxsOiB1bmtub3duKCksXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kVW5pb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudW5pb25Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3Qub3B0aW9ucyA9IGRlZi5vcHRpb25zO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdW5pb24ob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RYb3IgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kWG9yXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kWG9yLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudW5pb25Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3Qub3B0aW9ucyA9IGRlZi5vcHRpb25zO1xufSk7XG4vKiogQ3JlYXRlcyBhbiBleGNsdXNpdmUgdW5pb24gKFhPUikgd2hlcmUgZXhhY3RseSBvbmUgb3B0aW9uIG11c3QgbWF0Y2guXG4gKiBVbmxpa2UgcmVndWxhciB1bmlvbnMgdGhhdCBzdWNjZWVkIHdoZW4gYW55IG9wdGlvbiBtYXRjaGVzLCB4b3IgZmFpbHMgaWZcbiAqIHplcm8gb3IgbW9yZSB0aGFuIG9uZSBvcHRpb24gbWF0Y2hlcyB0aGUgaW5wdXQuICovXG5leHBvcnQgZnVuY3Rpb24geG9yKG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kWG9yKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2REaXNjcmltaW5hdGVkVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2REaXNjcmltaW5hdGVkVW5pb24uaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZGlzY3JpbWluYXRlZFVuaW9uKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIC8vIGNvbnN0IFtvcHRpb25zLCBwYXJhbXNdID0gYXJncztcbiAgICByZXR1cm4gbmV3IFpvZERpc2NyaW1pbmF0ZWRVbmlvbih7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RJbnRlcnNlY3Rpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSW50ZXJzZWN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RJbnRlcnNlY3Rpb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5pbnRlcnNlY3Rpb25Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gaW50ZXJzZWN0aW9uKGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuICAgICAgICB0eXBlOiBcImludGVyc2VjdGlvblwiLFxuICAgICAgICBsZWZ0OiBsZWZ0LFxuICAgICAgICByaWdodDogcmlnaHQsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kVHVwbGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVHVwbGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFR1cGxlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudHVwbGVQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QucmVzdCA9IChyZXN0KSA9PiBpbnN0LmNsb25lKHtcbiAgICAgICAgLi4uaW5zdC5fem9kLmRlZixcbiAgICAgICAgcmVzdDogcmVzdCxcbiAgICB9KTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHR1cGxlKGl0ZW1zLCBfcGFyYW1zT3JSZXN0LCBfcGFyYW1zKSB7XG4gICAgY29uc3QgaGFzUmVzdCA9IF9wYXJhbXNPclJlc3QgaW5zdGFuY2VvZiBjb3JlLiRab2RUeXBlO1xuICAgIGNvbnN0IHBhcmFtcyA9IGhhc1Jlc3QgPyBfcGFyYW1zIDogX3BhcmFtc09yUmVzdDtcbiAgICBjb25zdCByZXN0ID0gaGFzUmVzdCA/IF9wYXJhbXNPclJlc3QgOiBudWxsO1xuICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgIGl0ZW1zOiBpdGVtcyxcbiAgICAgICAgcmVzdCxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RSZWNvcmQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kUmVjb3JkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RSZWNvcmQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5yZWNvcmRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3Qua2V5VHlwZSA9IGRlZi5rZXlUeXBlO1xuICAgIGluc3QudmFsdWVUeXBlID0gZGVmLnZhbHVlVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHJlY29yZChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyB0eXBlIGFsa3NqZiA9IGNvcmUub3V0cHV0PGNvcmUuJFpvZFJlY29yZEtleT47XG5leHBvcnQgZnVuY3Rpb24gcGFydGlhbFJlY29yZChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIGNvbnN0IGsgPSBjb3JlLmNsb25lKGtleVR5cGUpO1xuICAgIGsuX3pvZC52YWx1ZXMgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlOiBrLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb29zZVJlY29yZChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgIG1vZGU6IFwibG9vc2VcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RNYXAgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTWFwXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RNYXAuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5tYXBQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3Qua2V5VHlwZSA9IGRlZi5rZXlUeXBlO1xuICAgIGluc3QudmFsdWVUeXBlID0gZGVmLnZhbHVlVHlwZTtcbiAgICBpbnN0Lm1pbiA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21pblNpemUoLi4uYXJncykpO1xuICAgIGluc3Qubm9uZW1wdHkgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21pblNpemUoMSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjb3JlLl9tYXhTaXplKC4uLmFyZ3MpKTtcbiAgICBpbnN0LnNpemUgPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjb3JlLl9zaXplKC4uLmFyZ3MpKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG1hcChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAga2V5VHlwZToga2V5VHlwZSxcbiAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kU2V0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFNldFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU2V0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuc2V0UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm1pbiA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21pblNpemUoLi4uYXJncykpO1xuICAgIGluc3Qubm9uZW1wdHkgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21pblNpemUoMSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjb3JlLl9tYXhTaXplKC4uLmFyZ3MpKTtcbiAgICBpbnN0LnNpemUgPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjb3JlLl9zaXplKC4uLmFyZ3MpKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHNldCh2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRW51bSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RFbnVtLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuZW51bVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5lbnVtID0gZGVmLmVudHJpZXM7XG4gICAgaW5zdC5vcHRpb25zID0gT2JqZWN0LnZhbHVlcyhkZWYuZW50cmllcyk7XG4gICAgY29uc3Qga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZGVmLmVudHJpZXMpKTtcbiAgICBpbnN0LmV4dHJhY3QgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RW50cmllcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtleXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIG5ld0VudHJpZXNbdmFsdWVdID0gZGVmLmVudHJpZXNbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7dmFsdWV9IG5vdCBmb3VuZCBpbiBlbnVtYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIGNoZWNrczogW10sXG4gICAgICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICAgICAgZW50cmllczogbmV3RW50cmllcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpbnN0LmV4Y2x1ZGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICAgICAgY29uc3QgbmV3RW50cmllcyA9IHsgLi4uZGVmLmVudHJpZXMgfTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmV3RW50cmllc1t2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHt2YWx1ZX0gbm90IGZvdW5kIGluIGVudW1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgICAgICBlbnRyaWVzOiBuZXdFbnRyaWVzLFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBfZW51bSh2YWx1ZXMsIHBhcmFtcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBPYmplY3QuZnJvbUVudHJpZXModmFsdWVzLm1hcCgodikgPT4gW3YsIHZdKSkgOiB2YWx1ZXM7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgeyBfZW51bSBhcyBlbnVtIH07XG4vKiogQGRlcHJlY2F0ZWQgVGhpcyBBUEkgaGFzIGJlZW4gbWVyZ2VkIGludG8gYHouZW51bSgpYC4gVXNlIGB6LmVudW0oKWAgaW5zdGVhZC5cbiAqXG4gKiBgYGB0c1xuICogZW51bSBDb2xvcnMgeyByZWQsIGdyZWVuLCBibHVlIH1cbiAqIHouZW51bShDb2xvcnMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYXRpdmVFbnVtKGVudHJpZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZExpdGVyYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTGl0ZXJhbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTGl0ZXJhbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmxpdGVyYWxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudmFsdWVzID0gbmV3IFNldChkZWYudmFsdWVzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJ2YWx1ZVwiLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGlmIChkZWYudmFsdWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIHNjaGVtYSBjb250YWlucyBtdWx0aXBsZSB2YWxpZCBsaXRlcmFsIHZhbHVlcy4gVXNlIGAudmFsdWVzYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWYudmFsdWVzWzBdO1xuICAgICAgICB9LFxuICAgIH0pO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbGl0ZXJhbCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gICAgICAgIHZhbHVlczogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRmlsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RGaWxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RGaWxlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuZmlsZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5taW4gPSAoc2l6ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21pblNpemUoc2l6ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAoc2l6ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21heFNpemUoc2l6ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5taW1lID0gKHR5cGVzLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWltZShBcnJheS5pc0FycmF5KHR5cGVzKSA/IHR5cGVzIDogW3R5cGVzXSwgcGFyYW1zKSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBmaWxlKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9maWxlKFpvZEZpbGUsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVHJhbnNmb3JtID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFRyYW5zZm9ybVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVHJhbnNmb3JtLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudHJhbnNmb3JtUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAoX2N0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEVuY29kZUVycm9yKGluc3QuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5hZGRJc3N1ZSA9IChpc3N1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbC5pc3N1ZShpc3N1ZSwgcGF5bG9hZC52YWx1ZSwgZGVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgWm9kIDMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBjb25zdCBfaXNzdWUgPSBpc3N1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZhdGFsKVxuICAgICAgICAgICAgICAgICAgICBfaXNzdWUuY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuY29kZSA/PyAoX2lzc3VlLmNvZGUgPSBcImN1c3RvbVwiKTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuaW5wdXQgPz8gKF9pc3N1ZS5pbnB1dCA9IHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5pbnN0ID8/IChfaXNzdWUuaW5zdCA9IGluc3QpO1xuICAgICAgICAgICAgICAgIC8vIF9pc3N1ZS5jb250aW51ZSA/Pz0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWwuaXNzdWUoX2lzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgICAgIGlmIChvdXRwdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LnRoZW4oKG91dHB1dCkgPT4ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0O1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgcmV0dXJuIG5ldyBab2RUcmFuc2Zvcm0oe1xuICAgICAgICB0eXBlOiBcInRyYW5zZm9ybVwiLFxuICAgICAgICB0cmFuc2Zvcm06IGZuLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RPcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm9wdGlvbmFsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWwoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRXhhY3RPcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RFeGFjdE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RFeGFjdE9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMub3B0aW9uYWxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBleGFjdE9wdGlvbmFsKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kRXhhY3RPcHRpb25hbCh7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTnVsbGFibGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTnVsbGFibGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE51bGxhYmxlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubnVsbGFibGVQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBudWxsYWJsZShpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgdHlwZTogXCJudWxsYWJsZVwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIG51bGxpc2hcbmV4cG9ydCBmdW5jdGlvbiBudWxsaXNoKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBvcHRpb25hbChudWxsYWJsZShpbm5lclR5cGUpKTtcbn1cbmV4cG9ydCBjb25zdCBab2REZWZhdWx0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZERlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZERlZmF1bHQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5kZWZhdWx0UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuICAgIGluc3QucmVtb3ZlRGVmYXVsdCA9IGluc3QudW53cmFwO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gX2RlZmF1bHQoaW5uZXJUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICB0eXBlOiBcImRlZmF1bHRcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiB1dGlsLnNoYWxsb3dDbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFByZWZhdWx0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RQcmVmYXVsdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnByZWZhdWx0UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcHJlZmF1bHQoaW5uZXJUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFpvZFByZWZhdWx0KHtcbiAgICAgICAgdHlwZTogXCJwcmVmYXVsdFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IHV0aWwuc2hhbGxvd0Nsb25lKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTm9uT3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTm9uT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE5vbk9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubm9ub3B0aW9uYWxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBub25vcHRpb25hbChpbm5lclR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kTm9uT3B0aW9uYWwoe1xuICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFN1Y2Nlc3MgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kU3VjY2Vzc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3VjY2Vzcy5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnN1Y2Nlc3NQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBzdWNjZXNzKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kU3VjY2Vzcyh7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RDYXRjaCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDYXRjaFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQ2F0Y2guaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5jYXRjaFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbiAgICBpbnN0LnJlbW92ZUNhdGNoID0gaW5zdC51bndyYXA7XG59KTtcbmZ1bmN0aW9uIF9jYXRjaChpbm5lclR5cGUsIGNhdGNoVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgdHlwZTogXCJjYXRjaFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICAgICAgY2F0Y2hWYWx1ZTogKHR5cGVvZiBjYXRjaFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBjYXRjaFZhbHVlIDogKCkgPT4gY2F0Y2hWYWx1ZSksXG4gICAgfSk7XG59XG5leHBvcnQgeyBfY2F0Y2ggYXMgY2F0Y2ggfTtcbmV4cG9ydCBjb25zdCBab2ROYU4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTmFOXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROYU4uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5uYW5Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbmFuKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9uYW4oWm9kTmFOLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFBpcGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kUGlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kUGlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnBpcGVQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuaW4gPSBkZWYuaW47XG4gICAgaW5zdC5vdXQgPSBkZWYub3V0O1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcGlwZShpbl8sIG91dCkge1xuICAgIHJldHVybiBuZXcgWm9kUGlwZSh7XG4gICAgICAgIHR5cGU6IFwicGlwZVwiLFxuICAgICAgICBpbjogaW5fLFxuICAgICAgICBvdXQ6IG91dCxcbiAgICAgICAgLy8gLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RDb2RlYyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDb2RlY1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgWm9kUGlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQ29kZWMuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gY29kZWMoaW5fLCBvdXQsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kQ29kZWMoe1xuICAgICAgICB0eXBlOiBcInBpcGVcIixcbiAgICAgICAgaW46IGluXyxcbiAgICAgICAgb3V0OiBvdXQsXG4gICAgICAgIHRyYW5zZm9ybTogcGFyYW1zLmRlY29kZSxcbiAgICAgICAgcmV2ZXJzZVRyYW5zZm9ybTogcGFyYW1zLmVuY29kZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RSZWFkb25seSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RSZWFkb25seVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kUmVhZG9ubHkuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5yZWFkb25seVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHJlYWRvbmx5KGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgICAgICB0eXBlOiBcInJlYWRvbmx5XCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFRlbXBsYXRlTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RUZW1wbGF0ZUxpdGVyYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFRlbXBsYXRlTGl0ZXJhbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnRlbXBsYXRlTGl0ZXJhbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB0ZW1wbGF0ZUxpdGVyYWwocGFydHMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kVGVtcGxhdGVMaXRlcmFsKHtcbiAgICAgICAgdHlwZTogXCJ0ZW1wbGF0ZV9saXRlcmFsXCIsXG4gICAgICAgIHBhcnRzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZExhenkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTGF6eVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTGF6eS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmxhenlQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5nZXR0ZXIoKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGxhenkoZ2V0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBab2RMYXp5KHtcbiAgICAgICAgdHlwZTogXCJsYXp5XCIsXG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFByb21pc2UgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kUHJvbWlzZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kUHJvbWlzZS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnByb21pc2VQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBwcm9taXNlKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kUHJvbWlzZSh7XG4gICAgICAgIHR5cGU6IFwicHJvbWlzZVwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RGdW5jdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RGdW5jdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRnVuY3Rpb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5mdW5jdGlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBfZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgaW5wdXQ6IEFycmF5LmlzQXJyYXkocGFyYW1zPy5pbnB1dCkgPyB0dXBsZShwYXJhbXM/LmlucHV0KSA6IChwYXJhbXM/LmlucHV0ID8/IGFycmF5KHVua25vd24oKSkpLFxuICAgICAgICBvdXRwdXQ6IHBhcmFtcz8ub3V0cHV0ID8/IHVua25vd24oKSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IF9mdW5jdGlvbiBhcyBmdW5jdGlvbiB9O1xuZXhwb3J0IGNvbnN0IFpvZEN1c3RvbSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEN1c3RvbS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmN1c3RvbVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbi8vIGN1c3RvbSBjaGVja3NcbmV4cG9ydCBmdW5jdGlvbiBjaGVjayhmbikge1xuICAgIGNvbnN0IGNoID0gbmV3IGNvcmUuJFpvZENoZWNrKHtcbiAgICAgICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgICAgIC8vIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG4gICAgY2guX3pvZC5jaGVjayA9IGZuO1xuICAgIHJldHVybiBjaDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b20oZm4sIF9wYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY3VzdG9tKFpvZEN1c3RvbSwgZm4gPz8gKCgpID0+IHRydWUpLCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZWZpbmUoZm4sIF9wYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiBjb3JlLl9yZWZpbmUoWm9kQ3VzdG9tLCBmbiwgX3BhcmFtcyk7XG59XG4vLyBzdXBlclJlZmluZVxuZXhwb3J0IGZ1bmN0aW9uIHN1cGVyUmVmaW5lKGZuKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N1cGVyUmVmaW5lKGZuKTtcbn1cbi8vIFJlLWV4cG9ydCBkZXNjcmliZSBhbmQgbWV0YSBmcm9tIGNvcmVcbmV4cG9ydCBjb25zdCBkZXNjcmliZSA9IGNvcmUuZGVzY3JpYmU7XG5leHBvcnQgY29uc3QgbWV0YSA9IGNvcmUubWV0YTtcbmZ1bmN0aW9uIF9pbnN0YW5jZW9mKGNscywgcGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBpbnN0ID0gbmV3IFpvZEN1c3RvbSh7XG4gICAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgICAgICBmbjogKGRhdGEpID0+IGRhdGEgaW5zdGFuY2VvZiBjbHMsXG4gICAgICAgIGFib3J0OiB0cnVlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xuICAgIGluc3QuX3pvZC5iYWcuQ2xhc3MgPSBjbHM7XG4gICAgLy8gT3ZlcnJpZGUgY2hlY2sgdG8gZW1pdCBpbnZhbGlkX3R5cGUgaW5zdGVhZCBvZiBjdXN0b21cbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoIShwYXlsb2FkLnZhbHVlIGluc3RhbmNlb2YgY2xzKSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogY2xzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBwYXRoOiBbLi4uKGluc3QuX3pvZC5kZWYucGF0aCA/PyBbXSldLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBpbnN0O1xufVxuZXhwb3J0IHsgX2luc3RhbmNlb2YgYXMgaW5zdGFuY2VvZiB9O1xuLy8gc3RyaW5nYm9vbFxuZXhwb3J0IGNvbnN0IHN0cmluZ2Jvb2wgPSAoLi4uYXJncykgPT4gY29yZS5fc3RyaW5nYm9vbCh7XG4gICAgQ29kZWM6IFpvZENvZGVjLFxuICAgIEJvb2xlYW46IFpvZEJvb2xlYW4sXG4gICAgU3RyaW5nOiBab2RTdHJpbmcsXG59LCAuLi5hcmdzKTtcbmV4cG9ydCBmdW5jdGlvbiBqc29uKHBhcmFtcykge1xuICAgIGNvbnN0IGpzb25TY2hlbWEgPSBsYXp5KCgpID0+IHtcbiAgICAgICAgcmV0dXJuIHVuaW9uKFtzdHJpbmcocGFyYW1zKSwgbnVtYmVyKCksIGJvb2xlYW4oKSwgX251bGwoKSwgYXJyYXkoanNvblNjaGVtYSksIHJlY29yZChzdHJpbmcoKSwganNvblNjaGVtYSldKTtcbiAgICB9KTtcbiAgICByZXR1cm4ganNvblNjaGVtYTtcbn1cbi8vIHByZXByb2Nlc3Ncbi8vIC8qKiBAZGVwcmVjYXRlZCBVc2UgYHoucGlwZSgpYCBhbmQgYHoudHJhbnNmb3JtKClgIGluc3RlYWQuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2Vzcyhmbiwgc2NoZW1hKSB7XG4gICAgcmV0dXJuIHBpcGUodHJhbnNmb3JtKGZuKSwgc2NoZW1hKTtcbn1cbiIsICJleHBvcnQgeyBfbHQgYXMgbHQsIF9sdGUgYXMgbHRlLCBfZ3QgYXMgZ3QsIF9ndGUgYXMgZ3RlLCBfcG9zaXRpdmUgYXMgcG9zaXRpdmUsIF9uZWdhdGl2ZSBhcyBuZWdhdGl2ZSwgX25vbnBvc2l0aXZlIGFzIG5vbnBvc2l0aXZlLCBfbm9ubmVnYXRpdmUgYXMgbm9ubmVnYXRpdmUsIF9tdWx0aXBsZU9mIGFzIG11bHRpcGxlT2YsIF9tYXhTaXplIGFzIG1heFNpemUsIF9taW5TaXplIGFzIG1pblNpemUsIF9zaXplIGFzIHNpemUsIF9tYXhMZW5ndGggYXMgbWF4TGVuZ3RoLCBfbWluTGVuZ3RoIGFzIG1pbkxlbmd0aCwgX2xlbmd0aCBhcyBsZW5ndGgsIF9yZWdleCBhcyByZWdleCwgX2xvd2VyY2FzZSBhcyBsb3dlcmNhc2UsIF91cHBlcmNhc2UgYXMgdXBwZXJjYXNlLCBfaW5jbHVkZXMgYXMgaW5jbHVkZXMsIF9zdGFydHNXaXRoIGFzIHN0YXJ0c1dpdGgsIF9lbmRzV2l0aCBhcyBlbmRzV2l0aCwgX3Byb3BlcnR5IGFzIHByb3BlcnR5LCBfbWltZSBhcyBtaW1lLCBfb3ZlcndyaXRlIGFzIG92ZXJ3cml0ZSwgX25vcm1hbGl6ZSBhcyBub3JtYWxpemUsIF90cmltIGFzIHRyaW0sIF90b0xvd2VyQ2FzZSBhcyB0b0xvd2VyQ2FzZSwgX3RvVXBwZXJDYXNlIGFzIHRvVXBwZXJDYXNlLCBfc2x1Z2lmeSBhcyBzbHVnaWZ5LCB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG4iLCAiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0ICogYXMgc2NoZW1hcyBmcm9tIFwiLi9zY2hlbWFzLmpzXCI7XG5leHBvcnQgY29uc3QgWm9kSVNPRGF0ZVRpbWUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSVNPRGF0ZVRpbWVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZElTT0RhdGVUaW1lLmluaXQoaW5zdCwgZGVmKTtcbiAgICBzY2hlbWFzLlpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faXNvRGF0ZVRpbWUoWm9kSVNPRGF0ZVRpbWUsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVNPRGF0ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJU09EYXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RJU09EYXRlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBzY2hlbWFzLlpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkYXRlKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pc29EYXRlKFpvZElTT0RhdGUsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVNPVGltZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJU09UaW1lXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RJU09UaW1lLmluaXQoaW5zdCwgZGVmKTtcbiAgICBzY2hlbWFzLlpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pc29UaW1lKFpvZElTT1RpbWUsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVNPRHVyYXRpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSVNPRHVyYXRpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZElTT0R1cmF0aW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBzY2hlbWFzLlpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkdXJhdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faXNvRHVyYXRpb24oWm9kSVNPRHVyYXRpb24sIHBhcmFtcyk7XG59XG4iLCAiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgJFpvZEVycm9yIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4uL2NvcmUvdXRpbC5qc1wiO1xuY29uc3QgaW5pdGlhbGl6ZXIgPSAoaW5zdCwgaXNzdWVzKSA9PiB7XG4gICAgJFpvZEVycm9yLmluaXQoaW5zdCwgaXNzdWVzKTtcbiAgICBpbnN0Lm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW5zdCwge1xuICAgICAgICBmb3JtYXQ6IHtcbiAgICAgICAgICAgIHZhbHVlOiAobWFwcGVyKSA9PiBjb3JlLmZvcm1hdEVycm9yKGluc3QsIG1hcHBlciksXG4gICAgICAgICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgZmxhdHRlbjoge1xuICAgICAgICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGNvcmUuZmxhdHRlbkVycm9yKGluc3QsIG1hcHBlciksXG4gICAgICAgICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkSXNzdWU6IHtcbiAgICAgICAgICAgIHZhbHVlOiAoaXNzdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0Lmlzc3Vlcy5wdXNoKGlzc3VlKTtcbiAgICAgICAgICAgICAgICBpbnN0Lm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShpbnN0Lmlzc3VlcywgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBhZGRJc3N1ZXM6IHtcbiAgICAgICAgICAgIHZhbHVlOiAoaXNzdWVzKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5zdC5pc3N1ZXMucHVzaCguLi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIGluc3QubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGluc3QuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGlzRW1wdHk6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdC5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIC8vIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImlzRW1wdHlcIiwge1xuICAgIC8vICAgZ2V0KCkge1xuICAgIC8vICAgICByZXR1cm4gaW5zdC5pc3N1ZXMubGVuZ3RoID09PSAwO1xuICAgIC8vICAgfSxcbiAgICAvLyB9KTtcbn07XG5leHBvcnQgY29uc3QgWm9kRXJyb3IgPSBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEVycm9yXCIsIGluaXRpYWxpemVyKTtcbmV4cG9ydCBjb25zdCBab2RSZWFsRXJyb3IgPSBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEVycm9yXCIsIGluaXRpYWxpemVyLCB7XG4gICAgUGFyZW50OiBFcnJvcixcbn0pO1xuLy8gLyoqIEBkZXByZWNhdGVkIFVzZSBgei5jb3JlLiRab2RFcnJvck1hcEN0eGAgaW5zdGVhZC4gKi9cbi8vIGV4cG9ydCB0eXBlIEVycm9yTWFwQ3R4ID0gY29yZS4kWm9kRXJyb3JNYXBDdHg7XG4iLCAiaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IHsgWm9kUmVhbEVycm9yIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgY29uc3QgcGFyc2UgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fcGFyc2UoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBwYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3BhcnNlQXN5bmMoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlUGFyc2UgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fc2FmZVBhcnNlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZVBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fc2FmZVBhcnNlQXN5bmMoWm9kUmVhbEVycm9yKTtcbi8vIENvZGVjIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9lbmNvZGUoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fZGVjb2RlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgZW5jb2RlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fZW5jb2RlQXN5bmMoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBkZWNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9kZWNvZGVBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVFbmNvZGUgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fc2FmZUVuY29kZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVEZWNvZGUgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fc2FmZURlY29kZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVFbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRW5jb2RlQXN5bmMoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlRGVjb2RlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fc2FmZURlY29kZUFzeW5jKFpvZFJlYWxFcnJvcik7XG4iLCAiLy8gWm9kIDMgY29tcGF0IGxheWVyXG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIHRoZSByYXcgc3RyaW5nIGxpdGVyYWwgY29kZXMgaW5zdGVhZCwgZS5nLiBcImludmFsaWRfdHlwZVwiLiAqL1xuZXhwb3J0IGNvbnN0IFpvZElzc3VlQ29kZSA9IHtcbiAgICBpbnZhbGlkX3R5cGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgdG9vX2JpZzogXCJ0b29fYmlnXCIsXG4gICAgdG9vX3NtYWxsOiBcInRvb19zbWFsbFwiLFxuICAgIGludmFsaWRfZm9ybWF0OiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgbm90X211bHRpcGxlX29mOiBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIHVucmVjb2duaXplZF9rZXlzOiBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgaW52YWxpZF91bmlvbjogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgaW52YWxpZF9rZXk6IFwiaW52YWxpZF9rZXlcIixcbiAgICBpbnZhbGlkX2VsZW1lbnQ6IFwiaW52YWxpZF9lbGVtZW50XCIsXG4gICAgaW52YWxpZF92YWx1ZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgY3VzdG9tOiBcImN1c3RvbVwiLFxufTtcbmV4cG9ydCB7ICRicmFuZCwgY29uZmlnIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHouY29uZmlnKHBhcmFtcylgIGluc3RlYWQuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XG4gICAgY29yZS5jb25maWcoe1xuICAgICAgICBjdXN0b21FcnJvcjogbWFwLFxuICAgIH0pO1xufVxuLyoqIEBkZXByZWNhdGVkIFVzZSBgei5jb25maWcoKWAgaW5zdGVhZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gY29yZS5jb25maWcoKS5jdXN0b21FcnJvcjtcbn1cbi8qKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlLiBTdHViIGRlZmluaXRpb24sIG9ubHkgaW5jbHVkZWQgZm9yIHpvZC10by1qc29uLXNjaGVtYSBjb21wYXRpYmlsaXR5LiAqL1xuZXhwb3J0IHZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24gKFpvZEZpcnN0UGFydHlUeXBlS2luZCkge1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuIiwgImltcG9ydCB7IGdsb2JhbFJlZ2lzdHJ5IH0gZnJvbSBcIi4uL2NvcmUvcmVnaXN0cmllcy5qc1wiO1xuaW1wb3J0ICogYXMgX2NoZWNrcyBmcm9tIFwiLi9jaGVja3MuanNcIjtcbmltcG9ydCAqIGFzIF9pc28gZnJvbSBcIi4vaXNvLmpzXCI7XG5pbXBvcnQgKiBhcyBfc2NoZW1hcyBmcm9tIFwiLi9zY2hlbWFzLmpzXCI7XG4vLyBMb2NhbCB6IG9iamVjdCB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHdpdGggLi4vaW5kZXguanNcbmNvbnN0IHogPSB7XG4gICAgLi4uX3NjaGVtYXMsXG4gICAgLi4uX2NoZWNrcyxcbiAgICBpc286IF9pc28sXG59O1xuLy8gS2V5cyB0aGF0IGFyZSByZWNvZ25pemVkIGFuZCBoYW5kbGVkIGJ5IHRoZSBjb252ZXJzaW9uIGxvZ2ljXG5jb25zdCBSRUNPR05JWkVEX0tFWVMgPSBuZXcgU2V0KFtcbiAgICAvLyBTY2hlbWEgaWRlbnRpZmljYXRpb25cbiAgICBcIiRzY2hlbWFcIixcbiAgICBcIiRyZWZcIixcbiAgICBcIiRkZWZzXCIsXG4gICAgXCJkZWZpbml0aW9uc1wiLFxuICAgIC8vIENvcmUgc2NoZW1hIGtleXdvcmRzXG4gICAgXCIkaWRcIixcbiAgICBcImlkXCIsXG4gICAgXCIkY29tbWVudFwiLFxuICAgIFwiJGFuY2hvclwiLFxuICAgIFwiJHZvY2FidWxhcnlcIixcbiAgICBcIiRkeW5hbWljUmVmXCIsXG4gICAgXCIkZHluYW1pY0FuY2hvclwiLFxuICAgIC8vIFR5cGVcbiAgICBcInR5cGVcIixcbiAgICBcImVudW1cIixcbiAgICBcImNvbnN0XCIsXG4gICAgLy8gQ29tcG9zaXRpb25cbiAgICBcImFueU9mXCIsXG4gICAgXCJvbmVPZlwiLFxuICAgIFwiYWxsT2ZcIixcbiAgICBcIm5vdFwiLFxuICAgIC8vIE9iamVjdFxuICAgIFwicHJvcGVydGllc1wiLFxuICAgIFwicmVxdWlyZWRcIixcbiAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgIFwicHJvcGVydHlOYW1lc1wiLFxuICAgIFwibWluUHJvcGVydGllc1wiLFxuICAgIFwibWF4UHJvcGVydGllc1wiLFxuICAgIC8vIEFycmF5XG4gICAgXCJpdGVtc1wiLFxuICAgIFwicHJlZml4SXRlbXNcIixcbiAgICBcImFkZGl0aW9uYWxJdGVtc1wiLFxuICAgIFwibWluSXRlbXNcIixcbiAgICBcIm1heEl0ZW1zXCIsXG4gICAgXCJ1bmlxdWVJdGVtc1wiLFxuICAgIFwiY29udGFpbnNcIixcbiAgICBcIm1pbkNvbnRhaW5zXCIsXG4gICAgXCJtYXhDb250YWluc1wiLFxuICAgIC8vIFN0cmluZ1xuICAgIFwibWluTGVuZ3RoXCIsXG4gICAgXCJtYXhMZW5ndGhcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcImZvcm1hdFwiLFxuICAgIC8vIE51bWJlclxuICAgIFwibWluaW11bVwiLFxuICAgIFwibWF4aW11bVwiLFxuICAgIFwiZXhjbHVzaXZlTWluaW11bVwiLFxuICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiLFxuICAgIFwibXVsdGlwbGVPZlwiLFxuICAgIC8vIEFscmVhZHkgaGFuZGxlZCBtZXRhZGF0YVxuICAgIFwiZGVzY3JpcHRpb25cIixcbiAgICBcImRlZmF1bHRcIixcbiAgICAvLyBDb250ZW50XG4gICAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIixcbiAgICBcImNvbnRlbnRTY2hlbWFcIixcbiAgICAvLyBVbnN1cHBvcnRlZCAoZXJyb3ItdGhyb3dpbmcpXG4gICAgXCJ1bmV2YWx1YXRlZEl0ZW1zXCIsXG4gICAgXCJ1bmV2YWx1YXRlZFByb3BlcnRpZXNcIixcbiAgICBcImlmXCIsXG4gICAgXCJ0aGVuXCIsXG4gICAgXCJlbHNlXCIsXG4gICAgXCJkZXBlbmRlbnRTY2hlbWFzXCIsXG4gICAgXCJkZXBlbmRlbnRSZXF1aXJlZFwiLFxuICAgIC8vIE9wZW5BUElcbiAgICBcIm51bGxhYmxlXCIsXG4gICAgXCJyZWFkT25seVwiLFxuXSk7XG5mdW5jdGlvbiBkZXRlY3RWZXJzaW9uKHNjaGVtYSwgZGVmYXVsdFRhcmdldCkge1xuICAgIGNvbnN0ICRzY2hlbWEgPSBzY2hlbWEuJHNjaGVtYTtcbiAgICBpZiAoJHNjaGVtYSA9PT0gXCJodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDIwLTEyL3NjaGVtYVwiKSB7XG4gICAgICAgIHJldHVybiBcImRyYWZ0LTIwMjAtMTJcIjtcbiAgICB9XG4gICAgaWYgKCRzY2hlbWEgPT09IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZHJhZnQtN1wiO1xuICAgIH1cbiAgICBpZiAoJHNjaGVtYSA9PT0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIikge1xuICAgICAgICByZXR1cm4gXCJkcmFmdC00XCI7XG4gICAgfVxuICAgIC8vIFVzZSBkZWZhdWx0VGFyZ2V0IGlmIHByb3ZpZGVkLCBvdGhlcndpc2UgZGVmYXVsdCB0byBkcmFmdC0yMDIwLTEyXG4gICAgcmV0dXJuIGRlZmF1bHRUYXJnZXQgPz8gXCJkcmFmdC0yMDIwLTEyXCI7XG59XG5mdW5jdGlvbiByZXNvbHZlUmVmKHJlZiwgY3R4KSB7XG4gICAgaWYgKCFyZWYuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXh0ZXJuYWwgJHJlZiBpcyBub3Qgc3VwcG9ydGVkLCBvbmx5IGxvY2FsIHJlZnMgKCMvLi4uKSBhcmUgYWxsb3dlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcGF0aCA9IHJlZi5zbGljZSgxKS5zcGxpdChcIi9cIikuZmlsdGVyKEJvb2xlYW4pO1xuICAgIC8vIEhhbmRsZSByb290IHJlZmVyZW5jZSBcIiNcIlxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gY3R4LnJvb3RTY2hlbWE7XG4gICAgfVxuICAgIGNvbnN0IGRlZnNLZXkgPSBjdHgudmVyc2lvbiA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcIiRkZWZzXCIgOiBcImRlZmluaXRpb25zXCI7XG4gICAgaWYgKHBhdGhbMF0gPT09IGRlZnNLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGF0aFsxXTtcbiAgICAgICAgaWYgKCFrZXkgfHwgIWN0eC5kZWZzW2tleV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVmZXJlbmNlIG5vdCBmb3VuZDogJHtyZWZ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN0eC5kZWZzW2tleV07XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgUmVmZXJlbmNlIG5vdCBmb3VuZDogJHtyZWZ9YCk7XG59XG5mdW5jdGlvbiBjb252ZXJ0QmFzZVNjaGVtYShzY2hlbWEsIGN0eCkge1xuICAgIC8vIEhhbmRsZSB1bnN1cHBvcnRlZCBmZWF0dXJlc1xuICAgIGlmIChzY2hlbWEubm90ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiB7IG5vdDoge30gfSByZXByZXNlbnRzIG5ldmVyXG4gICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm5vdCA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3Qua2V5cyhzY2hlbWEubm90KS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB6Lm5ldmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGlzIG5vdCBzdXBwb3J0ZWQgaW4gWm9kIChleGNlcHQgeyBub3Q6IHt9IH0gZm9yIG5ldmVyKVwiKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS51bmV2YWx1YXRlZEl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5ldmFsdWF0ZWRJdGVtcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLnVuZXZhbHVhdGVkUHJvcGVydGllcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXZhbHVhdGVkUHJvcGVydGllcyBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmlmICE9PSB1bmRlZmluZWQgfHwgc2NoZW1hLnRoZW4gIT09IHVuZGVmaW5lZCB8fCBzY2hlbWEuZWxzZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbmRpdGlvbmFsIHNjaGVtYXMgKGlmL3RoZW4vZWxzZSkgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuZGVwZW5kZW50U2NoZW1hcyAhPT0gdW5kZWZpbmVkIHx8IHNjaGVtYS5kZXBlbmRlbnRSZXF1aXJlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImRlcGVuZGVudFNjaGVtYXMgYW5kIGRlcGVuZGVudFJlcXVpcmVkIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgJHJlZlxuICAgIGlmIChzY2hlbWEuJHJlZikge1xuICAgICAgICBjb25zdCByZWZQYXRoID0gc2NoZW1hLiRyZWY7XG4gICAgICAgIGlmIChjdHgucmVmcy5oYXMocmVmUGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBjdHgucmVmcy5nZXQocmVmUGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5wcm9jZXNzaW5nLmhhcyhyZWZQYXRoKSkge1xuICAgICAgICAgICAgLy8gQ2lyY3VsYXIgcmVmZXJlbmNlIC0gdXNlIGxhenlcbiAgICAgICAgICAgIHJldHVybiB6LmxhenkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghY3R4LnJlZnMuaGFzKHJlZlBhdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2lyY3VsYXIgcmVmZXJlbmNlIG5vdCByZXNvbHZlZDogJHtyZWZQYXRofWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnJlZnMuZ2V0KHJlZlBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LnByb2Nlc3NpbmcuYWRkKHJlZlBhdGgpO1xuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVSZWYocmVmUGF0aCwgY3R4KTtcbiAgICAgICAgY29uc3Qgem9kU2NoZW1hID0gY29udmVydFNjaGVtYShyZXNvbHZlZCwgY3R4KTtcbiAgICAgICAgY3R4LnJlZnMuc2V0KHJlZlBhdGgsIHpvZFNjaGVtYSk7XG4gICAgICAgIGN0eC5wcm9jZXNzaW5nLmRlbGV0ZShyZWZQYXRoKTtcbiAgICAgICAgcmV0dXJuIHpvZFNjaGVtYTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGVudW1cbiAgICBpZiAoc2NoZW1hLmVudW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0gc2NoZW1hLmVudW07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogT3BlbkFQSSAzLjAgbnVsbCByZXByZXNlbnRhdGlvbiB7IHR5cGU6IFwic3RyaW5nXCIsIG51bGxhYmxlOiB0cnVlLCBlbnVtOiBbbnVsbF0gfVxuICAgICAgICBpZiAoY3R4LnZlcnNpb24gPT09IFwib3BlbmFwaS0zLjBcIiAmJlxuICAgICAgICAgICAgc2NoZW1hLm51bGxhYmxlID09PSB0cnVlICYmXG4gICAgICAgICAgICBlbnVtVmFsdWVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgZW51bVZhbHVlc1swXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHoubnVsbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnVtVmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHoubmV2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW51bVZhbHVlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB6LmxpdGVyYWwoZW51bVZhbHVlc1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgaWYgYWxsIHZhbHVlcyBhcmUgc3RyaW5nc1xuICAgICAgICBpZiAoZW51bVZhbHVlcy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gei5lbnVtKGVudW1WYWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1peGVkIHR5cGVzIC0gdXNlIHVuaW9uIG9mIGxpdGVyYWxzXG4gICAgICAgIGNvbnN0IGxpdGVyYWxTY2hlbWFzID0gZW51bVZhbHVlcy5tYXAoKHYpID0+IHoubGl0ZXJhbCh2KSk7XG4gICAgICAgIGlmIChsaXRlcmFsU2NoZW1hcy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICByZXR1cm4gbGl0ZXJhbFNjaGVtYXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoudW5pb24oW2xpdGVyYWxTY2hlbWFzWzBdLCBsaXRlcmFsU2NoZW1hc1sxXSwgLi4ubGl0ZXJhbFNjaGVtYXMuc2xpY2UoMildKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGNvbnN0XG4gICAgaWYgKHNjaGVtYS5jb25zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB6LmxpdGVyYWwoc2NoZW1hLmNvbnN0KTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHR5cGVcbiAgICBjb25zdCB0eXBlID0gc2NoZW1hLnR5cGU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgLy8gRXhwYW5kIHR5cGUgYXJyYXkgaW50byBhbnlPZiB1bmlvblxuICAgICAgICBjb25zdCB0eXBlU2NoZW1hcyA9IHR5cGUubWFwKCh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0eXBlU2NoZW1hID0geyAuLi5zY2hlbWEsIHR5cGU6IHQgfTtcbiAgICAgICAgICAgIHJldHVybiBjb252ZXJ0QmFzZVNjaGVtYSh0eXBlU2NoZW1hLCBjdHgpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVTY2hlbWFzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHoubmV2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZVNjaGVtYXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZVNjaGVtYXNbMF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHoudW5pb24odHlwZVNjaGVtYXMpO1xuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgLy8gTm8gdHlwZSBzcGVjaWZpZWQgLSBlbXB0eSBzY2hlbWEgKGFueSlcbiAgICAgICAgcmV0dXJuIHouYW55KCk7XG4gICAgfVxuICAgIGxldCB6b2RTY2hlbWE7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjoge1xuICAgICAgICAgICAgbGV0IHN0cmluZ1NjaGVtYSA9IHouc3RyaW5nKCk7XG4gICAgICAgICAgICAvLyBBcHBseSBmb3JtYXQgdXNpbmcgLmNoZWNrKCkgd2l0aCBab2QgZm9ybWF0IGZ1bmN0aW9uc1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmb3JtYXQgPSBzY2hlbWEuZm9ybWF0O1xuICAgICAgICAgICAgICAgIC8vIE1hcCBjb21tb24gZm9ybWF0cyB0byBab2QgY2hlY2sgZnVuY3Rpb25zXG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmVtYWlsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwidXJpXCIgfHwgZm9ybWF0ID09PSBcInVyaS1yZWZlcmVuY2VcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei51cmwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ1dWlkXCIgfHwgZm9ybWF0ID09PSBcImd1aWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei51dWlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiZGF0ZS10aW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXNvLmRhdGV0aW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lmlzby5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lmlzby50aW1lKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pc28uZHVyYXRpb24oKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJpcHY0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXB2NCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImlwdjZcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pcHY2KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwibWFjXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoubWFjKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiY2lkclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmNpZHJ2NCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImNpZHItdjZcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5jaWRydjYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJiYXNlNjRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5iYXNlNjQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJiYXNlNjR1cmxcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5iYXNlNjR1cmwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJlMTY0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouZTE2NCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImp3dFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lmp3dCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouZW1vamkoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJuYW5vaWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5uYW5vaWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouY3VpZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImN1aWQyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouY3VpZDIoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ1bGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoudWxpZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInhpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LnhpZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImtzdWlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoua3N1aWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE5vdGU6IGpzb24tc3RyaW5nIGZvcm1hdCBpcyBub3QgY3VycmVudGx5IHN1cHBvcnRlZCBieSBab2RcbiAgICAgICAgICAgICAgICAvLyBDdXN0b20gZm9ybWF0cyBhcmUgaWdub3JlZCAtIGtlZXAgYXMgcGxhaW4gc3RyaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBcHBseSBjb25zdHJhaW50c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluTGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLm1pbihzY2hlbWEubWluTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heExlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5tYXgoc2NoZW1hLm1heExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NoZW1hLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBKU09OIFNjaGVtYSBwYXR0ZXJucyBhcmUgbm90IGltcGxpY2l0bHkgYW5jaG9yZWQgKG1hdGNoIGFueXdoZXJlIGluIHN0cmluZylcbiAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEucmVnZXgobmV3IFJlZ0V4cChzY2hlbWEucGF0dGVybikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9kU2NoZW1hID0gc3RyaW5nU2NoZW1hO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICBjYXNlIFwiaW50ZWdlclwiOiB7XG4gICAgICAgICAgICBsZXQgbnVtYmVyU2NoZW1hID0gdHlwZSA9PT0gXCJpbnRlZ2VyXCIgPyB6Lm51bWJlcigpLmludCgpIDogei5udW1iZXIoKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLm1pbihzY2hlbWEubWluaW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLm1heChzY2hlbWEubWF4aW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLmd0KHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5leGNsdXNpdmVNaW5pbXVtID09PSB0cnVlICYmIHR5cGVvZiBzY2hlbWEubWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5ndChzY2hlbWEubWluaW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLmx0KHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYS5leGNsdXNpdmVNYXhpbXVtID09PSB0cnVlICYmIHR5cGVvZiBzY2hlbWEubWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5sdChzY2hlbWEubWF4aW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tdWx0aXBsZU9mID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLm11bHRpcGxlT2Yoc2NoZW1hLm11bHRpcGxlT2YpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9kU2NoZW1hID0gbnVtYmVyU2NoZW1hO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjoge1xuICAgICAgICAgICAgem9kU2NoZW1hID0gei5ib29sZWFuKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibnVsbFwiOiB7XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSB6Lm51bGwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBzY2hlbWEucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVpcmVkU2V0ID0gbmV3IFNldChzY2hlbWEucmVxdWlyZWQgfHwgW10pO1xuICAgICAgICAgICAgLy8gQ29udmVydCBwcm9wZXJ0aWVzIC0gbWFyayBvcHRpb25hbCBvbmVzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHByb3BTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcFpvZFNjaGVtYSA9IGNvbnZlcnRTY2hlbWEocHJvcFNjaGVtYSwgY3R4KTtcbiAgICAgICAgICAgICAgICAvLyBJZiBub3QgaW4gcmVxdWlyZWQgYXJyYXksIG1ha2UgaXQgb3B0aW9uYWxcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gcmVxdWlyZWRTZXQuaGFzKGtleSkgPyBwcm9wWm9kU2NoZW1hIDogcHJvcFpvZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHByb3BlcnR5TmFtZXNcbiAgICAgICAgICAgIGlmIChzY2hlbWEucHJvcGVydHlOYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleVNjaGVtYSA9IGNvbnZlcnRTY2hlbWEoc2NoZW1hLnByb3BlcnR5TmFtZXMsIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgJiYgdHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogei5hbnkoKTtcbiAgICAgICAgICAgICAgICAvLyBDYXNlIEE6IE5vIHByb3BlcnRpZXMgKHB1cmUgcmVjb3JkKVxuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzaGFwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoucmVjb3JkKGtleVNjaGVtYSwgdmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSBCOiBXaXRoIHByb3BlcnRpZXMgKGludGVyc2VjdGlvbiBvZiBvYmplY3QgYW5kIGxvb3NlUmVjb3JkKVxuICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdFNjaGVtYSA9IHoub2JqZWN0KHNoYXBlKS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY29yZFNjaGVtYSA9IHoubG9vc2VSZWNvcmQoa2V5U2NoZW1hLCB2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei5pbnRlcnNlY3Rpb24ob2JqZWN0U2NoZW1hLCByZWNvcmRTY2hlbWEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgLy8gcGF0dGVyblByb3BlcnRpZXM6IGtleXMgbWF0Y2hpbmcgcGF0dGVybiBtdXN0IHNhdGlzZnkgY29ycmVzcG9uZGluZyBzY2hlbWFcbiAgICAgICAgICAgICAgICAvLyBVc2UgbG9vc2UgcmVjb3JkcyBzbyBub24tbWF0Y2hpbmcga2V5cyBwYXNzIHRocm91Z2hcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuUHJvcHMgPSBzY2hlbWEucGF0dGVyblByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybktleXMgPSBPYmplY3Qua2V5cyhwYXR0ZXJuUHJvcHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvb3NlUmVjb3JkcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJuS2V5cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuVmFsdWUgPSBjb252ZXJ0U2NoZW1hKHBhdHRlcm5Qcm9wc1twYXR0ZXJuXSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5U2NoZW1hID0gei5zdHJpbmcoKS5yZWdleChuZXcgUmVnRXhwKHBhdHRlcm4pKTtcbiAgICAgICAgICAgICAgICAgICAgbG9vc2VSZWNvcmRzLnB1c2goei5sb29zZVJlY29yZChrZXlTY2hlbWEsIHBhdHRlcm5WYWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBCdWlsZCBpbnRlcnNlY3Rpb246IG9iamVjdCBzY2hlbWEgKyBhbGwgcGF0dGVybiBwcm9wZXJ0eSByZWNvcmRzXG4gICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hc1RvSW50ZXJzZWN0ID0gW107XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNoYXBlKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVzZSBwYXNzdGhyb3VnaCBzbyBwYXR0ZXJuUHJvcGVydGllcyBjYW4gdmFsaWRhdGUgYWRkaXRpb25hbCBrZXlzXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYXNUb0ludGVyc2VjdC5wdXNoKHoub2JqZWN0KHNoYXBlKS5wYXNzdGhyb3VnaCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2NoZW1hc1RvSW50ZXJzZWN0LnB1c2goLi4ubG9vc2VSZWNvcmRzKTtcbiAgICAgICAgICAgICAgICBpZiAoc2NoZW1hc1RvSW50ZXJzZWN0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6Lm9iamVjdCh7fSkucGFzc3Rocm91Z2goKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hc1RvSW50ZXJzZWN0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBzY2hlbWFzVG9JbnRlcnNlY3RbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDaGFpbiBpbnRlcnNlY3Rpb25zOiAoQSAmIEIpICYgQyAmIEQgLi4uXG4gICAgICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB6LmludGVyc2VjdGlvbihzY2hlbWFzVG9JbnRlcnNlY3RbMF0sIHNjaGVtYXNUb0ludGVyc2VjdFsxXSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAyOyBpIDwgc2NoZW1hc1RvSW50ZXJzZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB6LmludGVyc2VjdGlvbihyZXN1bHQsIHNjaGVtYXNUb0ludGVyc2VjdFtpXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBhZGRpdGlvbmFsUHJvcGVydGllc1xuICAgICAgICAgICAgLy8gSW4gSlNPTiBTY2hlbWEsIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGRlZmF1bHRzIHRvIHRydWUgKGFsbG93IGFueSBleHRyYSBwcm9wZXJ0aWVzKVxuICAgICAgICAgICAgLy8gSW4gWm9kLCBvYmplY3RzIHN0cmlwIHVua25vd24ga2V5cyBieSBkZWZhdWx0LCBzbyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGlzIGV4cGxpY2l0bHlcbiAgICAgICAgICAgIGNvbnN0IG9iamVjdFNjaGVtYSA9IHoub2JqZWN0KHNoYXBlKTtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RyaWN0IG1vZGUgLSBubyBleHRyYSBwcm9wZXJ0aWVzIGFsbG93ZWRcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBvYmplY3RTY2hlbWEuc3RyaWN0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmEgcHJvcGVydGllcyBtdXN0IG1hdGNoIHRoZSBzcGVjaWZpZWQgc2NoZW1hXG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gb2JqZWN0U2NoZW1hLmNhdGNoYWxsKGNvbnZlcnRTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGFkZGl0aW9uYWxQcm9wZXJ0aWVzIGlzIHRydWUgb3IgdW5kZWZpbmVkIC0gYWxsb3cgYW55IGV4dHJhIHByb3BlcnRpZXMgKHBhc3N0aHJvdWdoKVxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IG9iamVjdFNjaGVtYS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImFycmF5XCI6IHtcbiAgICAgICAgICAgIC8vIFRPRE86IHVuaXF1ZUl0ZW1zIGlzIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIFRPRE86IGNvbnRhaW5zL21pbkNvbnRhaW5zL21heENvbnRhaW5zIGFyZSBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgdHVwbGUgKHByZWZpeEl0ZW1zIG9yIGl0ZW1zIGFzIGFycmF5KVxuICAgICAgICAgICAgY29uc3QgcHJlZml4SXRlbXMgPSBzY2hlbWEucHJlZml4SXRlbXM7XG4gICAgICAgICAgICBjb25zdCBpdGVtcyA9IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGlmIChwcmVmaXhJdGVtcyAmJiBBcnJheS5pc0FycmF5KHByZWZpeEl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlIHdpdGggcHJlZml4SXRlbXMgKGRyYWZ0LTIwMjAtMTIpXG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGVJdGVtcyA9IHByZWZpeEl0ZW1zLm1hcCgoaXRlbSkgPT4gY29udmVydFNjaGVtYShpdGVtLCBjdHgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gaXRlbXMgJiYgdHlwZW9mIGl0ZW1zID09PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KGl0ZW1zKVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRTY2hlbWEoaXRlbXMsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei50dXBsZSh0dXBsZUl0ZW1zKS5yZXN0KHJlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei50dXBsZSh0dXBsZUl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbWluSXRlbXMvbWF4SXRlbXMgY29uc3RyYWludHMgdG8gdHVwbGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluSXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmNoZWNrKHoubWluTGVuZ3RoKHNjaGVtYS5taW5JdGVtcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhJdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuY2hlY2soei5tYXhMZW5ndGgoc2NoZW1hLm1heEl0ZW1zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZSB3aXRoIGl0ZW1zIGFycmF5IChkcmFmdC03KVxuICAgICAgICAgICAgICAgIGNvbnN0IHR1cGxlSXRlbXMgPSBpdGVtcy5tYXAoKGl0ZW0pID0+IGNvbnZlcnRTY2hlbWEoaXRlbSwgY3R4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgJiYgdHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0U2NoZW1hKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7IC8vIGFkZGl0aW9uYWxJdGVtczogZmFsc2UgbWVhbnMgbm8gcmVzdCwgaGFuZGxlZCBieSBkZWZhdWx0IHR1cGxlIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei50dXBsZSh0dXBsZUl0ZW1zKS5yZXN0KHJlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei50dXBsZSh0dXBsZUl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgbWluSXRlbXMvbWF4SXRlbXMgY29uc3RyYWludHMgdG8gdHVwbGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluSXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmNoZWNrKHoubWluTGVuZ3RoKHNjaGVtYS5taW5JdGVtcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhJdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuY2hlY2soei5tYXhMZW5ndGgoc2NoZW1hLm1heEl0ZW1zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIC8vIFJlZ3VsYXIgYXJyYXlcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gY29udmVydFNjaGVtYShpdGVtcywgY3R4KTtcbiAgICAgICAgICAgICAgICBsZXQgYXJyYXlTY2hlbWEgPSB6LmFycmF5KGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIC8vIEFwcGx5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluSXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlTY2hlbWEgPSBhcnJheVNjaGVtYS5taW4oc2NoZW1hLm1pbkl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4SXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyYXlTY2hlbWEgPSBhcnJheVNjaGVtYS5tYXgoc2NoZW1hLm1heEl0ZW1zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gYXJyYXlTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBObyBpdGVtcyBzcGVjaWZpZWQgLSBhcnJheSBvZiBhbnlcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LmFycmF5KHouYW55KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgdHlwZTogJHt0eXBlfWApO1xuICAgIH1cbiAgICAvLyBBcHBseSBtZXRhZGF0YVxuICAgIGlmIChzY2hlbWEuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmRlc2NyaWJlKHNjaGVtYS5kZXNjcmlwdGlvbik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5kZWZhdWx0KHNjaGVtYS5kZWZhdWx0KTtcbiAgICB9XG4gICAgcmV0dXJuIHpvZFNjaGVtYTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRTY2hlbWEoc2NoZW1hLCBjdHgpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYSA/IHouYW55KCkgOiB6Lm5ldmVyKCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYmFzZSBzY2hlbWEgZmlyc3QgKGlnbm9yaW5nIGNvbXBvc2l0aW9uIGtleXdvcmRzKVxuICAgIGxldCBiYXNlU2NoZW1hID0gY29udmVydEJhc2VTY2hlbWEoc2NoZW1hLCBjdHgpO1xuICAgIGNvbnN0IGhhc0V4cGxpY2l0VHlwZSA9IHNjaGVtYS50eXBlIHx8IHNjaGVtYS5lbnVtICE9PSB1bmRlZmluZWQgfHwgc2NoZW1hLmNvbnN0ICE9PSB1bmRlZmluZWQ7XG4gICAgLy8gUHJvY2VzcyBjb21wb3NpdGlvbiBrZXl3b3JkcyBMQVNUICh0aGV5IGNhbiBhcHBlYXIgdG9nZXRoZXIpXG4gICAgLy8gSGFuZGxlIGFueU9mIC0gd3JhcCBiYXNlIHNjaGVtYSB3aXRoIHVuaW9uXG4gICAgaWYgKHNjaGVtYS5hbnlPZiAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5hbnlPZikpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNjaGVtYS5hbnlPZi5tYXAoKHMpID0+IGNvbnZlcnRTY2hlbWEocywgY3R4KSk7XG4gICAgICAgIGNvbnN0IGFueU9mVW5pb24gPSB6LnVuaW9uKG9wdGlvbnMpO1xuICAgICAgICBiYXNlU2NoZW1hID0gaGFzRXhwbGljaXRUeXBlID8gei5pbnRlcnNlY3Rpb24oYmFzZVNjaGVtYSwgYW55T2ZVbmlvbikgOiBhbnlPZlVuaW9uO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgb25lT2YgLSBleGNsdXNpdmUgdW5pb24gKGV4YWN0bHkgb25lIG11c3QgbWF0Y2gpXG4gICAgaWYgKHNjaGVtYS5vbmVPZiAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5vbmVPZikpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHNjaGVtYS5vbmVPZi5tYXAoKHMpID0+IGNvbnZlcnRTY2hlbWEocywgY3R4KSk7XG4gICAgICAgIGNvbnN0IG9uZU9mVW5pb24gPSB6LnhvcihvcHRpb25zKTtcbiAgICAgICAgYmFzZVNjaGVtYSA9IGhhc0V4cGxpY2l0VHlwZSA/IHouaW50ZXJzZWN0aW9uKGJhc2VTY2hlbWEsIG9uZU9mVW5pb24pIDogb25lT2ZVbmlvbjtcbiAgICB9XG4gICAgLy8gSGFuZGxlIGFsbE9mIC0gd3JhcCBiYXNlIHNjaGVtYSB3aXRoIGludGVyc2VjdGlvblxuICAgIGlmIChzY2hlbWEuYWxsT2YgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYWxsT2YpKSB7XG4gICAgICAgIGlmIChzY2hlbWEuYWxsT2YubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBiYXNlU2NoZW1hID0gaGFzRXhwbGljaXRUeXBlID8gYmFzZVNjaGVtYSA6IHouYW55KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gaGFzRXhwbGljaXRUeXBlID8gYmFzZVNjaGVtYSA6IGNvbnZlcnRTY2hlbWEoc2NoZW1hLmFsbE9mWzBdLCBjdHgpO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRJZHggPSBoYXNFeHBsaWNpdFR5cGUgPyAwIDogMTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydElkeDsgaSA8IHNjaGVtYS5hbGxPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHouaW50ZXJzZWN0aW9uKHJlc3VsdCwgY29udmVydFNjaGVtYShzY2hlbWEuYWxsT2ZbaV0sIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmFzZVNjaGVtYSA9IHJlc3VsdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgbnVsbGFibGUgKE9wZW5BUEkgMy4wKVxuICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUgJiYgY3R4LnZlcnNpb24gPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICBiYXNlU2NoZW1hID0gei5udWxsYWJsZShiYXNlU2NoZW1hKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlIHJlYWRPbmx5XG4gICAgaWYgKHNjaGVtYS5yZWFkT25seSA9PT0gdHJ1ZSkge1xuICAgICAgICBiYXNlU2NoZW1hID0gei5yZWFkb25seShiYXNlU2NoZW1hKTtcbiAgICB9XG4gICAgLy8gQ29sbGVjdCBtZXRhZGF0YTogY29yZSBzY2hlbWEga2V5d29yZHMgYW5kIHVucmVjb2duaXplZCBrZXlzXG4gICAgY29uc3QgZXh0cmFNZXRhID0ge307XG4gICAgLy8gQ29yZSBzY2hlbWEga2V5d29yZHMgdGhhdCBzaG91bGQgYmUgY2FwdHVyZWQgYXMgbWV0YWRhdGFcbiAgICBjb25zdCBjb3JlTWV0YWRhdGFLZXlzID0gW1wiJGlkXCIsIFwiaWRcIiwgXCIkY29tbWVudFwiLCBcIiRhbmNob3JcIiwgXCIkdm9jYWJ1bGFyeVwiLCBcIiRkeW5hbWljUmVmXCIsIFwiJGR5bmFtaWNBbmNob3JcIl07XG4gICAgZm9yIChjb25zdCBrZXkgb2YgY29yZU1ldGFkYXRhS2V5cykge1xuICAgICAgICBpZiAoa2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgZXh0cmFNZXRhW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBDb250ZW50IGtleXdvcmRzIC0gc3RvcmUgYXMgbWV0YWRhdGFcbiAgICBjb25zdCBjb250ZW50TWV0YWRhdGFLZXlzID0gW1wiY29udGVudEVuY29kaW5nXCIsIFwiY29udGVudE1lZGlhVHlwZVwiLCBcImNvbnRlbnRTY2hlbWFcIl07XG4gICAgZm9yIChjb25zdCBrZXkgb2YgY29udGVudE1ldGFkYXRhS2V5cykge1xuICAgICAgICBpZiAoa2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgZXh0cmFNZXRhW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVbnJlY29nbml6ZWQga2V5cyAoY3VzdG9tIG1ldGFkYXRhKVxuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKHNjaGVtYSkpIHtcbiAgICAgICAgaWYgKCFSRUNPR05JWkVEX0tFWVMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGV4dHJhTWV0YVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKGV4dHJhTWV0YSkubGVuZ3RoID4gMCkge1xuICAgICAgICBjdHgucmVnaXN0cnkuYWRkKGJhc2VTY2hlbWEsIGV4dHJhTWV0YSk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlU2NoZW1hO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBhIEpTT04gU2NoZW1hIHRvIGEgWm9kIHNjaGVtYS4gVGhpcyBmdW5jdGlvbiBzaG91bGQgYmUgY29uc2lkZXJlZCBzZW1pLWV4cGVyaW1lbnRhbC4gSXQncyBiZWhhdmlvciBpcyBsaWFibGUgdG8gY2hhbmdlLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZyb21KU09OU2NoZW1hKHNjaGVtYSwgcGFyYW1zKSB7XG4gICAgLy8gSGFuZGxlIGJvb2xlYW4gc2NoZW1hc1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hID8gei5hbnkoKSA6IHoubmV2ZXIoKTtcbiAgICB9XG4gICAgY29uc3QgdmVyc2lvbiA9IGRldGVjdFZlcnNpb24oc2NoZW1hLCBwYXJhbXM/LmRlZmF1bHRUYXJnZXQpO1xuICAgIGNvbnN0IGRlZnMgPSAoc2NoZW1hLiRkZWZzIHx8IHNjaGVtYS5kZWZpbml0aW9ucyB8fCB7fSk7XG4gICAgY29uc3QgY3R4ID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBkZWZzLFxuICAgICAgICByZWZzOiBuZXcgTWFwKCksXG4gICAgICAgIHByb2Nlc3Npbmc6IG5ldyBTZXQoKSxcbiAgICAgICAgcm9vdFNjaGVtYTogc2NoZW1hLFxuICAgICAgICByZWdpc3RyeTogcGFyYW1zPy5yZWdpc3RyeSA/PyBnbG9iYWxSZWdpc3RyeSxcbiAgICB9O1xuICAgIHJldHVybiBjb252ZXJ0U2NoZW1hKHNjaGVtYSwgY3R4KTtcbn1cbiIsICJleHBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9zY2hlbWFzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jaGVja3MuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vcGFyc2UuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NvbXBhdC5qc1wiO1xuLy8gem9kLXNwZWNpZmllZFxuaW1wb3J0IHsgY29uZmlnIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCBlbiBmcm9tIFwiLi4vbG9jYWxlcy9lbi5qc1wiO1xuY29uZmlnKGVuKCkpO1xuZXhwb3J0IHsgZ2xvYmFsUmVnaXN0cnksIHJlZ2lzdHJ5LCBjb25maWcsICRvdXRwdXQsICRpbnB1dCwgJGJyYW5kLCBjbG9uZSwgcmVnZXhlcywgdHJlZWlmeUVycm9yLCBwcmV0dGlmeUVycm9yLCBmb3JtYXRFcnJvciwgZmxhdHRlbkVycm9yLCBUaW1lUHJlY2lzaW9uLCB1dGlsLCBORVZFUiwgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuZXhwb3J0IHsgdG9KU09OU2NoZW1hIH0gZnJvbSBcIi4uL2NvcmUvanNvbi1zY2hlbWEtcHJvY2Vzc29ycy5qc1wiO1xuZXhwb3J0IHsgZnJvbUpTT05TY2hlbWEgfSBmcm9tIFwiLi9mcm9tLWpzb24tc2NoZW1hLmpzXCI7XG5leHBvcnQgKiBhcyBsb2NhbGVzIGZyb20gXCIuLi9sb2NhbGVzL2luZGV4LmpzXCI7XG4vLyBpc29cbi8vIG11c3QgYmUgZXhwb3J0ZWQgZnJvbSB0b3AtbGV2ZWxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9pc3N1ZXMvNDQ5MVxuZXhwb3J0IHsgWm9kSVNPRGF0ZVRpbWUsIFpvZElTT0RhdGUsIFpvZElTT1RpbWUsIFpvZElTT0R1cmF0aW9uIH0gZnJvbSBcIi4vaXNvLmpzXCI7XG5leHBvcnQgKiBhcyBpc28gZnJvbSBcIi4vaXNvLmpzXCI7XG5leHBvcnQgKiBhcyBjb2VyY2UgZnJvbSBcIi4vY29lcmNlLmpzXCI7XG4iLCBudWxsLCBudWxsLCAiZXhwb3J0IGNvbnN0IGlnbm9yZU92ZXJyaWRlID0gU3ltYm9sKFwiTGV0IHpvZFRvSnNvblNjaGVtYSBkZWNpZGUgb24gd2hpY2ggcGFyc2VyIHRvIHVzZVwiKTtcbmV4cG9ydCBjb25zdCBqc29uRGVzY3JpcHRpb24gPSAoanNvblNjaGVtYSwgZGVmKSA9PiB7XG4gICAgaWYgKGRlZi5kZXNjcmlwdGlvbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgIC4uLkpTT04ucGFyc2UoZGVmLmRlc2NyaXB0aW9uKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggeyB9XG4gICAgfVxuICAgIHJldHVybiBqc29uU2NoZW1hO1xufTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBuYW1lOiB1bmRlZmluZWQsXG4gICAgJHJlZlN0cmF0ZWd5OiBcInJvb3RcIixcbiAgICBiYXNlUGF0aDogW1wiI1wiXSxcbiAgICBlZmZlY3RTdHJhdGVneTogXCJpbnB1dFwiLFxuICAgIHBpcGVTdHJhdGVneTogXCJhbGxcIixcbiAgICBkYXRlU3RyYXRlZ3k6IFwiZm9ybWF0OmRhdGUtdGltZVwiLFxuICAgIG1hcFN0cmF0ZWd5OiBcImVudHJpZXNcIixcbiAgICByZW1vdmVBZGRpdGlvbmFsU3RyYXRlZ3k6IFwicGFzc3Rocm91Z2hcIixcbiAgICBhbGxvd2VkQWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gICAgcmVqZWN0ZWRBZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2UsXG4gICAgZGVmaW5pdGlvblBhdGg6IFwiZGVmaW5pdGlvbnNcIixcbiAgICB0YXJnZXQ6IFwianNvblNjaGVtYTdcIixcbiAgICBzdHJpY3RVbmlvbnM6IGZhbHNlLFxuICAgIGRlZmluaXRpb25zOiB7fSxcbiAgICBlcnJvck1lc3NhZ2VzOiBmYWxzZSxcbiAgICBtYXJrZG93bkRlc2NyaXB0aW9uOiBmYWxzZSxcbiAgICBwYXR0ZXJuU3RyYXRlZ3k6IFwiZXNjYXBlXCIsXG4gICAgYXBwbHlSZWdleEZsYWdzOiBmYWxzZSxcbiAgICBlbWFpbFN0cmF0ZWd5OiBcImZvcm1hdDplbWFpbFwiLFxuICAgIGJhc2U2NFN0cmF0ZWd5OiBcImNvbnRlbnRFbmNvZGluZzpiYXNlNjRcIixcbiAgICBuYW1lU3RyYXRlZ3k6IFwicmVmXCIsXG4gICAgb3BlbkFpQW55VHlwZU5hbWU6IFwiT3BlbkFpQW55VHlwZVwiXG59O1xuZXhwb3J0IGNvbnN0IGdldERlZmF1bHRPcHRpb25zID0gKG9wdGlvbnMpID0+ICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIlxuICAgID8ge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgbmFtZTogb3B0aW9ucyxcbiAgICB9XG4gICAgOiB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5vcHRpb25zLFxuICAgIH0pO1xuIiwgImltcG9ydCB7IHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMgfSBmcm9tIFwiLi4vZXJyb3JNZXNzYWdlcy5qc1wiO1xubGV0IGVtb2ppUmVnZXggPSB1bmRlZmluZWQ7XG4vKipcbiAqIEdlbmVyYXRlZCBmcm9tIHRoZSByZWd1bGFyIGV4cHJlc3Npb25zIGZvdW5kIGhlcmUgYXMgb2YgMjAyNC0wNS0yMjpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9ibG9iL21hc3Rlci9zcmMvdHlwZXMudHMuXG4gKlxuICogRXhwcmVzc2lvbnMgd2l0aCAvaSBmbGFnIGhhdmUgYmVlbiBjaGFuZ2VkIGFjY29yZGluZ2x5LlxuICovXG5leHBvcnQgY29uc3Qgem9kUGF0dGVybnMgPSB7XG4gICAgLyoqXG4gICAgICogYGNgIHdhcyBjaGFuZ2VkIHRvIGBbY0NdYCB0byByZXBsaWNhdGUgL2kgZmxhZ1xuICAgICAqL1xuICAgIGN1aWQ6IC9eW2NDXVteXFxzLV17OCx9JC8sXG4gICAgY3VpZDI6IC9eWzAtOWEtel0rJC8sXG4gICAgdWxpZDogL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC8sXG4gICAgLyoqXG4gICAgICogYGEtemAgd2FzIGFkZGVkIHRvIHJlcGxpY2F0ZSAvaSBmbGFnXG4gICAgICovXG4gICAgZW1haWw6IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbYS16QS1aMC05XycrXFwtXFwuXSopW2EtekEtWjAtOV8rLV1AKFthLXpBLVowLTldW2EtekEtWjAtOVxcLV0qXFwuKStbYS16QS1aXXsyLH0kLyxcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RlZCBhIHZhbGlkIFVuaWNvZGUgUmVnRXhwXG4gICAgICpcbiAgICAgKiBMYXppbHkgaW5zdGFudGlhdGUgc2luY2UgdGhpcyB0eXBlIG9mIHJlZ2V4IGlzbid0IHN1cHBvcnRlZFxuICAgICAqIGluIGFsbCBlbnZzIChlLmcuIFJlYWN0IE5hdGl2ZSkuXG4gICAgICpcbiAgICAgKiBTZWU6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2lzc3Vlcy8yNDMzXG4gICAgICogRml4IGluIFpvZDpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvY29tbWl0LzkzNDBmZDUxZTQ4NTc2YTc1YWRjOTE5YmZmNjVkYmM0YTVkNGM5OWJcbiAgICAgKi9cbiAgICBlbW9qaTogKCkgPT4ge1xuICAgICAgICBpZiAoZW1vamlSZWdleCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbW9qaVJlZ2V4ID0gUmVnRXhwKFwiXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRcIiwgXCJ1XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbW9qaVJlZ2V4O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogVW51c2VkXG4gICAgICovXG4gICAgdXVpZDogL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kLyxcbiAgICAvKipcbiAgICAgKiBVbnVzZWRcbiAgICAgKi9cbiAgICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvLFxuICAgIGlwdjRDaWRyOiAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLygzWzAtMl18WzEyXT9bMC05XSkkLyxcbiAgICAvKipcbiAgICAgKiBVbnVzZWRcbiAgICAgKi9cbiAgICBpcHY2OiAvXigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSkkLyxcbiAgICBpcHY2Q2lkcjogL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLyxcbiAgICBiYXNlNjQ6IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLyxcbiAgICBiYXNlNjR1cmw6IC9eKFswLTlhLXpBLVotX117NH0pKigoWzAtOWEtekEtWi1fXXsyfSg9PSk/KXwoWzAtOWEtekEtWi1fXXszfSg9KT8pKT8kLyxcbiAgICBuYW5vaWQ6IC9eW2EtekEtWjAtOV8tXXsyMX0kLyxcbiAgICBqd3Q6IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC8sXG59O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU3RyaW5nRGVmKGRlZiwgcmVmcykge1xuICAgIGNvbnN0IHJlcyA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICB9O1xuICAgIGlmIChkZWYuY2hlY2tzKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgc3dpdGNoIChjaGVjay5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1pblwiOlxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5MZW5ndGhcIiwgdHlwZW9mIHJlcy5taW5MZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1heFwiOlxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhMZW5ndGhcIiwgdHlwZW9mIHJlcy5tYXhMZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVtYWlsXCI6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVmcy5lbWFpbFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybWF0OmVtYWlsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJlbWFpbFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6aWRuLWVtYWlsXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpZG4tZW1haWxcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGF0dGVybjp6b2RcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuZW1haWwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1cmxcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ1cmlcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1dWlkXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwidXVpZFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlZ2V4XCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBjaGVjay5yZWdleCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjdWlkXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5jdWlkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImN1aWQyXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5jdWlkMiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzdGFydHNXaXRoXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoYF4ke2VzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKX1gKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRzV2l0aFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgUmVnRXhwKGAke2VzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKX0kYCksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGF0ZXRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkYXRlLXRpbWVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRlXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZGF0ZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRpbWVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ0aW1lXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZHVyYXRpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkdXJhdGlvblwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxlbmd0aFwiOlxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtaW5MZW5ndGhcIiwgdHlwZW9mIHJlcy5taW5MZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5tYXgocmVzLm1pbkxlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4TGVuZ3RoXCIsIHR5cGVvZiByZXMubWF4TGVuZ3RoID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWluKHJlcy5tYXhMZW5ndGgsIGNoZWNrLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpbmNsdWRlc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiaXBcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlwdjRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpcHY2XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0dXJsXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjR1cmwsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiand0XCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5qd3QsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY2lkclwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5pcHY0Q2lkciwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmlwdjZDaWRyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImVtb2ppXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5lbW9qaSgpLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVsaWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMudWxpZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiYmFzZTY0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWZzLmJhc2U2NFN0cmF0ZWd5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybWF0OmJpbmFyeVwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJiaW5hcnlcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwiY29udGVudEVuY29kaW5nXCIsIFwiYmFzZTY0XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdHRlcm46em9kXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuYmFzZTY0LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcIm5hbm9pZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5uYW5vaWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9Mb3dlckNhc2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9VcHBlckNhc2VcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidHJpbVwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAoKF8pID0+IHsgfSkoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShsaXRlcmFsLCByZWZzKSB7XG4gICAgcmV0dXJuIHJlZnMucGF0dGVyblN0cmF0ZWd5ID09PSBcImVzY2FwZVwiXG4gICAgICAgID8gZXNjYXBlTm9uQWxwaGFOdW1lcmljKGxpdGVyYWwpXG4gICAgICAgIDogbGl0ZXJhbDtcbn1cbmNvbnN0IEFMUEhBX05VTUVSSUMgPSBuZXcgU2V0KFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVlhZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ4eXowMTIzNDU2Nzg5XCIpO1xuZnVuY3Rpb24gZXNjYXBlTm9uQWxwaGFOdW1lcmljKHNvdXJjZSkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghQUxQSEFfTlVNRVJJQy5oYXMoc291cmNlW2ldKSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFxcXFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSBzb3VyY2VbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBBZGRzIGEgXCJmb3JtYXRcIiBrZXl3b3JkIHRvIHRoZSBzY2hlbWEuIElmIGEgZm9ybWF0IGV4aXN0cywgYm90aCBmb3JtYXRzIHdpbGwgYmUgam9pbmVkIGluIGFuIGFsbE9mLW5vZGUsIGFsb25nIHdpdGggc3Vic2VxdWVudCBvbmVzLlxuZnVuY3Rpb24gYWRkRm9ybWF0KHNjaGVtYSwgdmFsdWUsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgICBpZiAoc2NoZW1hLmZvcm1hdCB8fCBzY2hlbWEuYW55T2Y/LnNvbWUoKHgpID0+IHguZm9ybWF0KSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5hbnlPZikge1xuICAgICAgICAgICAgc2NoZW1hLmFueU9mID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5mb3JtYXQpIHtcbiAgICAgICAgICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IHNjaGVtYS5mb3JtYXQsXG4gICAgICAgICAgICAgICAgLi4uKHNjaGVtYS5lcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB7IGZvcm1hdDogc2NoZW1hLmVycm9yTWVzc2FnZS5mb3JtYXQgfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5mb3JtYXQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlLmZvcm1hdDtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hLmVycm9yTWVzc2FnZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuYW55T2YucHVzaCh7XG4gICAgICAgICAgICBmb3JtYXQ6IHZhbHVlLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgZm9ybWF0OiBtZXNzYWdlIH0gfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwiZm9ybWF0XCIsIHZhbHVlLCBtZXNzYWdlLCByZWZzKTtcbiAgICB9XG59XG4vLyBBZGRzIGEgXCJwYXR0ZXJuXCIga2V5d29yZCB0byB0aGUgc2NoZW1hLiBJZiBhIHBhdHRlcm4gZXhpc3RzLCBib3RoIHBhdHRlcm5zIHdpbGwgYmUgam9pbmVkIGluIGFuIGFsbE9mLW5vZGUsIGFsb25nIHdpdGggc3Vic2VxdWVudCBvbmVzLlxuZnVuY3Rpb24gYWRkUGF0dGVybihzY2hlbWEsIHJlZ2V4LCBtZXNzYWdlLCByZWZzKSB7XG4gICAgaWYgKHNjaGVtYS5wYXR0ZXJuIHx8IHNjaGVtYS5hbGxPZj8uc29tZSgoeCkgPT4geC5wYXR0ZXJuKSkge1xuICAgICAgICBpZiAoIXNjaGVtYS5hbGxPZikge1xuICAgICAgICAgICAgc2NoZW1hLmFsbE9mID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogc2NoZW1hLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgLi4uKHNjaGVtYS5lcnJvck1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB7IHBhdHRlcm46IHNjaGVtYS5lcnJvck1lc3NhZ2UucGF0dGVybiB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgc2NoZW1hLnBhdHRlcm47XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlLnBhdHRlcm47XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYS5lcnJvck1lc3NhZ2UpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLmVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NoZW1hLmFsbE9mLnB1c2goe1xuICAgICAgICAgICAgcGF0dGVybjogc3RyaW5naWZ5UmVnRXhwV2l0aEZsYWdzKHJlZ2V4LCByZWZzKSxcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHsgZXJyb3JNZXNzYWdlOiB7IHBhdHRlcm46IG1lc3NhZ2UgfSB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHNjaGVtYSwgXCJwYXR0ZXJuXCIsIHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcyksIG1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbn1cbi8vIE11dGF0ZSB6LnN0cmluZy5yZWdleCgpIGluIGEgYmVzdCBhdHRlbXB0IHRvIGFjY29tbW9kYXRlIGZvciByZWdleCBmbGFncyB3aGVuIGFwcGx5UmVnZXhGbGFncyBpcyB0cnVlXG5mdW5jdGlvbiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpIHtcbiAgICBpZiAoIXJlZnMuYXBwbHlSZWdleEZsYWdzIHx8ICFyZWdleC5mbGFncykge1xuICAgICAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICAgIH1cbiAgICAvLyBDdXJyZW50bHkgaGFuZGxlZCBmbGFnc1xuICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICBpOiByZWdleC5mbGFncy5pbmNsdWRlcyhcImlcIiksXG4gICAgICAgIG06IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwibVwiKSxcbiAgICAgICAgczogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJzXCIpLCAvLyBgLmAgbWF0Y2hlcyBuZXdsaW5lc1xuICAgIH07XG4gICAgLy8gVGhlIGdlbmVyYWwgcHJpbmNpcGxlIGhlcmUgaXMgdG8gc3RlcCB0aHJvdWdoIGVhY2ggY2hhcmFjdGVyLCBvbmUgYXQgYSB0aW1lLCBhcHBseWluZyBtdXRhdGlvbnMgYXMgZmxhZ3MgcmVxdWlyZS4gV2Uga2VlcCB0cmFjayB3aGVuIHRoZSBjdXJyZW50IGNoYXJhY3RlciBpcyBlc2NhcGVkLCBhbmQgd2hlbiBpdCdzIGluc2lkZSBhIGdyb3VwIC9saWtlIFt0aGlzXS8gb3IgKGFsc28pIGEgcmFuZ2UgbGlrZSAvW2Etel0vLiBUaGUgZm9sbG93aW5nIGlzIGZhaXJseSBicml0dGxlIGltcGVyYXRpdmUgY29kZTsgZWRpdCBhdCB5b3VyIHBlcmlsIVxuICAgIGNvbnN0IHNvdXJjZSA9IGZsYWdzLmkgPyByZWdleC5zb3VyY2UudG9Mb3dlckNhc2UoKSA6IHJlZ2V4LnNvdXJjZTtcbiAgICBsZXQgcGF0dGVybiA9IFwiXCI7XG4gICAgbGV0IGlzRXNjYXBlZCA9IGZhbHNlO1xuICAgIGxldCBpbkNoYXJHcm91cCA9IGZhbHNlO1xuICAgIGxldCBpbkNoYXJSYW5nZSA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpc0VzY2FwZWQpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MuaSkge1xuICAgICAgICAgICAgaWYgKGluQ2hhckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpXS5tYXRjaCgvW2Etel0vKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5DaGFyUmFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBgJHtzb3VyY2VbaSAtIDJdfS0ke3NvdXJjZVtpXX1gLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkNoYXJSYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVtpICsgMV0gPT09IFwiLVwiICYmIHNvdXJjZVtpICsgMl0/Lm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ2hhclJhbmdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYCR7c291cmNlW2ldfSR7c291cmNlW2ldLnRvVXBwZXJDYXNlKCl9YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VbaV0ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGBbJHtzb3VyY2VbaV19JHtzb3VyY2VbaV0udG9VcHBlckNhc2UoKX1dYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MubSkge1xuICAgICAgICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAoXnwoPzw9W1xcclxcbl0pKWA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VbaV0gPT09IFwiJFwiKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBgKCR8KD89W1xcclxcbl0pKWA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzLnMgJiYgc291cmNlW2ldID09PSBcIi5cIikge1xuICAgICAgICAgICAgcGF0dGVybiArPSBpbkNoYXJHcm91cCA/IGAke3NvdXJjZVtpXX1cXHJcXG5gIDogYFske3NvdXJjZVtpXX1cXHJcXG5dYDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICBpZiAoc291cmNlW2ldID09PSBcIlxcXFxcIikge1xuICAgICAgICAgICAgaXNFc2NhcGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbkNoYXJHcm91cCAmJiBzb3VyY2VbaV0gPT09IFwiXVwiKSB7XG4gICAgICAgICAgICBpbkNoYXJHcm91cCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFpbkNoYXJHcm91cCAmJiBzb3VyY2VbaV0gPT09IFwiW1wiKSB7XG4gICAgICAgICAgICBpbkNoYXJHcm91cCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgbmV3IFJlZ0V4cChwYXR0ZXJuKTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICBjb25zb2xlLndhcm4oYENvdWxkIG5vdCBjb252ZXJ0IHJlZ2V4IHBhdHRlcm4gYXQgJHtyZWZzLmN1cnJlbnRQYXRoLmpvaW4oXCIvXCIpfSB0byBhIGZsYWctaW5kZXBlbmRlbnQgZm9ybSEgRmFsbGluZyBiYWNrIHRvIHRoZSBmbGFnLWlnbm9yYW50IHNvdXJjZWApO1xuICAgICAgICByZXR1cm4gcmVnZXguc291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbn1cbiIsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsIG51bGwsICIvKipcbiAqIENpdGF0aW9uIHZhbGlkYXRpb24gZW5naW5lIGZvciBTd2lzcyBsZWdhbCBjaXRhdGlvbnNcbiAqIFZhbGlkYXRlcyBCR0UvQVRGL0RURiwgZmVkZXJhbCBzdGF0dXRlcywgYW5kIGNhbnRvbmFsIGNpdGF0aW9uc1xuICovXG5cbmltcG9ydCB0eXBlIHsgVmFsaWRhdGlvblJlc3VsdCwgQ2l0YXRpb25UeXBlLCBDaXRhdGlvbkNvbXBvbmVudHMgfSBmcm9tICcuLi90eXBlcy5qcyc7XG5cbmV4cG9ydCBjbGFzcyBDaXRhdGlvblZhbGlkYXRvciB7XG4gIC8vIEJHRS9BVEYvRFRGIGNpdGF0aW9uIHBhdHRlcm5zXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEJHRV9QQVRURVJOID0gL15CR0VcXHMrKFxcZHsxLDN9KVxccysoW0lWWF0rKVxccysoXFxkKykkL2k7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IEFURl9QQVRURVJOID0gL15BVEZcXHMrKFxcZHsxLDN9KVxccysoW0lWWF0rKVxccysoXFxkKykkL2k7XG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IERURl9QQVRURVJOID0gL15EVEZcXHMrKFxcZHsxLDN9KVxccysoW0lWWF0rKVxccysoXFxkKykkL2k7XG5cbiAgLy8gU3RhdHV0b3J5IGNpdGF0aW9uIHBhdHRlcm5zIChzaW1wbGlmaWVkKVxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVEFUVVRFX1BBVFRFUk4gPSAvXkFydFxcLlxccyooXFxkK1thLXpdPykoPzpcXHMrQWJzXFwuXFxzKihcXGQrKSk/KD86XFxzK2xpdFxcLlxccyooW2Etel0pKT8oPzpcXHMrWmlmZlxcLlxccyooXFxkKykpP1xccysoWkdCfE9SfFN0R0J8U3RQT3xaUE98QlZ8U2NoS0d8RFNHfFVSR3xNU2NoR3xQYXRHKS9pO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVEFUVVRFX1BBVFRFUk5fRlIgPSAvXmFydFxcLlxccyooXFxkK1thLXpdPykoPzpcXHMrYWxcXC5cXHMqKFxcZCspKT8oPzpcXHMrbGV0XFwuXFxzKihbYS16XSkpPyg/OlxccytjaFxcLlxccyooXFxkKykpP1xccysoQ0N8Q098Q1B8Q1BQfENQQ3xDc3R8TFB8TFBEfExEQXxMUE18TEJJKS9pO1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVEFUVVRFX1BBVFRFUk5fSVQgPSAvXmFydFxcLlxccyooXFxkK1thLXpdPykoPzpcXHMrY3B2XFwuXFxzKihcXGQrKSk/KD86XFxzK2xldHRcXC5cXHMqKFthLXpdKSk/KD86XFxzK25cXC5cXHMqKFxcZCspKT9cXHMrKENDfENPfENQfENQUHxDUEN8Q29zdHxMRUZ8TFBEfExEQXxMUE18TEJJKS9pO1xuXG4gIC8vIFZhbGlkIFN3aXNzIGZlZGVyYWwgc3RhdHV0ZXNcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVkFMSURfU1RBVFVURVNfREUgPSBuZXcgU2V0KFtcbiAgICAnWkdCJywgJ09SJywgJ1N0R0InLCAnU3RQTycsICdaUE8nLCAnQlYnLCAnU2NoS0cnLCAnRFNHJywgJ1VSRycsICdNU2NoRycsICdQYXRHJyxcbiAgICAnS0cnLCAnVlZHJywgJ0FUU0cnLCAnQUhWRycsICdJVkcnLCAnVVZHJywgJ0JWRycsICdFTEcnLCAnRlpHJywgJ0FWSUcnXG4gIF0pO1xuXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFZBTElEX1NUQVRVVEVTX0ZSID0gbmV3IFNldChbXG4gICAgJ0NDJywgJ0NPJywgJ0NQJywgJ0NQUCcsICdDUEMnLCAnQ3N0JywgJ0xQJywgJ0xQRCcsICdMREEnLCAnTFBNJywgJ0xCSScsXG4gICAgJ0xDYXJ0JywgJ0xDQScsICdMUEdBJywgJ0xBVlMnLCAnTEFJJywgJ0xBQScsICdMUFAnLCAnTFBDJywgJ0xBQ0knLCAnTFBHQSdcbiAgXSk7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgVkFMSURfU1RBVFVURVNfSVQgPSBuZXcgU2V0KFtcbiAgICAnQ0MnLCAnQ08nLCAnQ1AnLCAnQ1BQJywgJ0NQQycsICdDb3N0JywgJ0xFRicsICdMUEQnLCAnTERBJywgJ0xQTScsICdMQkknLFxuICAgICdMQ2FydCcsICdMQ0EnLCAnTFBHQScsICdMQVZTJywgJ0xBSScsICdMQUlORicsICdMUFAnLCAnTFBDJywgJ0xBREknXG4gIF0pO1xuXG4gIC8vIFZhbGlkIEJHRSBjaGFtYmVycyAoUm9tYW4gbnVtZXJhbHMpXG4gIHByaXZhdGUgc3RhdGljIHJlYWRvbmx5IFZBTElEX0NIQU1CRVJTID0gbmV3IFNldChbXG4gICAgJ0knLCAnSUknLCAnSUlJJywgJ0lWJywgJ1YnLCAnVkknLCAnVklJJywgJ1ZJSUknLCAnSVgnLCAnWCdcbiAgXSk7XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgQkdFIChCdW5kZXNnZXJpY2h0KSBjaXRhdGlvblxuICAgKi9cbiAgdmFsaWRhdGVCR0UoY2l0YXRpb246IHN0cmluZyk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBjaXRhdGlvbi50cmltKCk7XG4gICAgY29uc3QgbWF0Y2ggPSBDaXRhdGlvblZhbGlkYXRvci5CR0VfUEFUVEVSTi5leGVjKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiAnYmdlJyxcbiAgICAgICAgZXJyb3JzOiBbJ0ludmFsaWQgQkdFIGNpdGF0aW9uIGZvcm1hdC4gRXhwZWN0ZWQ6IEJHRSBbdm9sdW1lXSBbY2hhbWJlcl0gW3BhZ2VdJ11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgWywgdm9sdW1lLCBjaGFtYmVyLCBwYWdlXSA9IG1hdGNoO1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcblxuICAgIC8vIFZhbGlkYXRlIHZvbHVtZSAodHlwaWNhbGx5IDEtMTUwKVxuICAgIGNvbnN0IHZvbHVtZU51bSA9IHBhcnNlSW50KHZvbHVtZSwgMTApO1xuICAgIGlmICh2b2x1bWVOdW0gPCAxIHx8IHZvbHVtZU51bSA+IDIwMCkge1xuICAgICAgd2FybmluZ3MucHVzaChgVW51c3VhbCBCR0Ugdm9sdW1lIG51bWJlcjogJHt2b2x1bWV9YCk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgY2hhbWJlciAoUm9tYW4gbnVtZXJhbHMgSS1YKVxuICAgIGlmICghQ2l0YXRpb25WYWxpZGF0b3IuVkFMSURfQ0hBTUJFUlMuaGFzKGNoYW1iZXIudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBJbnZhbGlkIEJHRSBjaGFtYmVyOiAke2NoYW1iZXJ9LiBNdXN0IGJlIFJvbWFuIG51bWVyYWwgSS1YYCk7XG4gICAgfVxuXG4gICAgLy8gVmFsaWRhdGUgcGFnZSBudW1iZXJcbiAgICBjb25zdCBwYWdlTnVtID0gcGFyc2VJbnQocGFnZSwgMTApO1xuICAgIGlmIChwYWdlTnVtIDwgMSkge1xuICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgcGFnZSBudW1iZXI6ICR7cGFnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzOiBDaXRhdGlvbkNvbXBvbmVudHMgPSB7XG4gICAgICB2b2x1bWUsXG4gICAgICBjaGFtYmVyOiBjaGFtYmVyLnRvVXBwZXJDYXNlKCksXG4gICAgICBwYWdlXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHR5cGU6ICdiZ2UnLFxuICAgICAgbm9ybWFsaXplZDogYEJHRSAke3ZvbHVtZX0gJHtjaGFtYmVyLnRvVXBwZXJDYXNlKCl9ICR7cGFnZX1gLFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIGVycm9yczogZXJyb3JzLmxlbmd0aCA+IDAgPyBlcnJvcnMgOiB1bmRlZmluZWQsXG4gICAgICB3YXJuaW5nczogd2FybmluZ3MubGVuZ3RoID4gMCA/IHdhcm5pbmdzIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhbiBBVEYgKEFyclx1MDBFQXRzIGR1IFRyaWJ1bmFsIGZcdTAwRTlkXHUwMEU5cmFsKSBjaXRhdGlvblxuICAgKi9cbiAgdmFsaWRhdGVBVEYoY2l0YXRpb246IHN0cmluZyk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBjaXRhdGlvbi50cmltKCk7XG4gICAgY29uc3QgbWF0Y2ggPSBDaXRhdGlvblZhbGlkYXRvci5BVEZfUEFUVEVSTi5leGVjKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiAnYXRmJyxcbiAgICAgICAgZXJyb3JzOiBbJ0ludmFsaWQgQVRGIGNpdGF0aW9uIGZvcm1hdC4gRXhwZWN0ZWQ6IEFURiBbdm9sdW1lXSBbY2hhbWJlcl0gW3BhZ2VdJ11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgWywgdm9sdW1lLCBjaGFtYmVyLCBwYWdlXSA9IG1hdGNoO1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcbiAgICBjb25zdCB3YXJuaW5nczogc3RyaW5nW10gPSBbXTtcblxuICAgIGNvbnN0IHZvbHVtZU51bSA9IHBhcnNlSW50KHZvbHVtZSwgMTApO1xuICAgIGlmICh2b2x1bWVOdW0gPCAxIHx8IHZvbHVtZU51bSA+IDIwMCkge1xuICAgICAgd2FybmluZ3MucHVzaChgVW51c3VhbCBBVEYgdm9sdW1lIG51bWJlcjogJHt2b2x1bWV9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFDaXRhdGlvblZhbGlkYXRvci5WQUxJRF9DSEFNQkVSUy5oYXMoY2hhbWJlci50b1VwcGVyQ2FzZSgpKSkge1xuICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgQVRGIGNoYW1iZXI6ICR7Y2hhbWJlcn0uIE11c3QgYmUgUm9tYW4gbnVtZXJhbCBJLVhgKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYWdlTnVtID0gcGFyc2VJbnQocGFnZSwgMTApO1xuICAgIGlmIChwYWdlTnVtIDwgMSkge1xuICAgICAgZXJyb3JzLnB1c2goYEludmFsaWQgcGFnZSBudW1iZXI6ICR7cGFnZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzOiBDaXRhdGlvbkNvbXBvbmVudHMgPSB7XG4gICAgICB2b2x1bWUsXG4gICAgICBjaGFtYmVyOiBjaGFtYmVyLnRvVXBwZXJDYXNlKCksXG4gICAgICBwYWdlXG4gICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHR5cGU6ICdhdGYnLFxuICAgICAgbm9ybWFsaXplZDogYEFURiAke3ZvbHVtZX0gJHtjaGFtYmVyLnRvVXBwZXJDYXNlKCl9ICR7cGFnZX1gLFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIGVycm9yczogZXJyb3JzLmxlbmd0aCA+IDAgPyBlcnJvcnMgOiB1bmRlZmluZWQsXG4gICAgICB3YXJuaW5nczogd2FybmluZ3MubGVuZ3RoID4gMCA/IHdhcm5pbmdzIDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIERURiAoRGVjaXNpb25pIGRlbCBUcmlidW5hbGUgZmVkZXJhbGUpIGNpdGF0aW9uXG4gICAqL1xuICB2YWxpZGF0ZURURihjaXRhdGlvbjogc3RyaW5nKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGNpdGF0aW9uLnRyaW0oKTtcbiAgICBjb25zdCBtYXRjaCA9IENpdGF0aW9uVmFsaWRhdG9yLkRURl9QQVRURVJOLmV4ZWMobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgIHR5cGU6ICdkdGYnLFxuICAgICAgICBlcnJvcnM6IFsnSW52YWxpZCBEVEYgY2l0YXRpb24gZm9ybWF0LiBFeHBlY3RlZDogRFRGIFt2b2x1bWVdIFtjaGFtYmVyXSBbcGFnZV0nXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBbLCB2b2x1bWUsIGNoYW1iZXIsIHBhZ2VdID0gbWF0Y2g7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3Qgdm9sdW1lTnVtID0gcGFyc2VJbnQodm9sdW1lLCAxMCk7XG4gICAgaWYgKHZvbHVtZU51bSA8IDEgfHwgdm9sdW1lTnVtID4gMjAwKSB7XG4gICAgICB3YXJuaW5ncy5wdXNoKGBVbnVzdWFsIERURiB2b2x1bWUgbnVtYmVyOiAke3ZvbHVtZX1gKTtcbiAgICB9XG5cbiAgICBpZiAoIUNpdGF0aW9uVmFsaWRhdG9yLlZBTElEX0NIQU1CRVJTLmhhcyhjaGFtYmVyLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICBlcnJvcnMucHVzaChgSW52YWxpZCBEVEYgY2hhbWJlcjogJHtjaGFtYmVyfS4gTXVzdCBiZSBSb21hbiBudW1lcmFsIEktWGApO1xuICAgIH1cblxuICAgIGNvbnN0IHBhZ2VOdW0gPSBwYXJzZUludChwYWdlLCAxMCk7XG4gICAgaWYgKHBhZ2VOdW0gPCAxKSB7XG4gICAgICBlcnJvcnMucHVzaChgSW52YWxpZCBwYWdlIG51bWJlcjogJHtwYWdlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudHM6IENpdGF0aW9uQ29tcG9uZW50cyA9IHtcbiAgICAgIHZvbHVtZSxcbiAgICAgIGNoYW1iZXI6IGNoYW1iZXIudG9VcHBlckNhc2UoKSxcbiAgICAgIHBhZ2VcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbGlkOiBlcnJvcnMubGVuZ3RoID09PSAwLFxuICAgICAgdHlwZTogJ2R0ZicsXG4gICAgICBub3JtYWxpemVkOiBgRFRGICR7dm9sdW1lfSAke2NoYW1iZXIudG9VcHBlckNhc2UoKX0gJHtwYWdlfWAsXG4gICAgICBjb21wb25lbnRzLFxuICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycyA6IHVuZGVmaW5lZCxcbiAgICAgIHdhcm5pbmdzOiB3YXJuaW5ncy5sZW5ndGggPiAwID8gd2FybmluZ3MgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgc3RhdHV0b3J5IGNpdGF0aW9uIChHZXJtYW4pXG4gICAqL1xuICB2YWxpZGF0ZVN0YXR1dGVERShjaXRhdGlvbjogc3RyaW5nKTogVmFsaWRhdGlvblJlc3VsdCB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGNpdGF0aW9uLnRyaW0oKTtcbiAgICBjb25zdCBtYXRjaCA9IENpdGF0aW9uVmFsaWRhdG9yLlNUQVRVVEVfUEFUVEVSTi5leGVjKG5vcm1hbGl6ZWQpO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICB0eXBlOiAnc3RhdHV0ZScsXG4gICAgICAgIGVycm9yczogWydJbnZhbGlkIHN0YXR1dGUgY2l0YXRpb24gZm9ybWF0IChERSkuIEV4cGVjdGVkOiBBcnQuIFtudW1iZXJdIFtBYnMuIFhdIFtsaXQuIGFdIFtzdGF0dXRlXSddXG4gICAgICB9O1xuICAgIH1cblxuICAgIGNvbnN0IFssIGFydGljbGUsIHBhcmFncmFwaCwgbGV0dGVyLCBudW1iZXIsIHN0YXR1dGVdID0gbWF0Y2g7XG4gICAgY29uc3QgZXJyb3JzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGNvbnN0IHdhcm5pbmdzOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgLy8gVmFsaWRhdGUgc3RhdHV0ZSBjb2RlXG4gICAgY29uc3Qgc3RhdHV0ZVVwcGVyID0gc3RhdHV0ZS50b1VwcGVyQ2FzZSgpO1xuICAgIGlmICghQ2l0YXRpb25WYWxpZGF0b3IuVkFMSURfU1RBVFVURVNfREUuaGFzKHN0YXR1dGVVcHBlcikpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBVbmtub3duIHN0YXR1dGUgY29kZTogJHtzdGF0dXRlfS4gVmFsaWQgY29kZXM6ICR7QXJyYXkuZnJvbShDaXRhdGlvblZhbGlkYXRvci5WQUxJRF9TVEFUVVRFU19ERSkuam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzOiBDaXRhdGlvbkNvbXBvbmVudHMgPSB7XG4gICAgICBzdGF0dXRlOiBzdGF0dXRlLnRvVXBwZXJDYXNlKCksXG4gICAgICBhcnRpY2xlLFxuICAgICAgcGFyYWdyYXBoOiBwYXJhZ3JhcGggfHwgdW5kZWZpbmVkLFxuICAgICAgbGV0dGVyOiBsZXR0ZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgbnVtYmVyOiBudW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIC8vIEJ1aWxkIG5vcm1hbGl6ZWQgY2l0YXRpb25cbiAgICBsZXQgbm9ybSA9IGBBcnQuICR7YXJ0aWNsZX1gO1xuICAgIGlmIChwYXJhZ3JhcGgpIG5vcm0gKz0gYCBBYnMuICR7cGFyYWdyYXBofWA7XG4gICAgaWYgKGxldHRlcikgbm9ybSArPSBgIGxpdC4gJHtsZXR0ZXJ9YDtcbiAgICBpZiAobnVtYmVyKSBub3JtICs9IGAgWmlmZi4gJHtudW1iZXJ9YDtcbiAgICBub3JtICs9IGAgJHtzdGF0dXRlLnRvVXBwZXJDYXNlKCl9YDtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHR5cGU6ICdzdGF0dXRlJyxcbiAgICAgIG5vcm1hbGl6ZWQ6IG5vcm0sXG4gICAgICBjb21wb25lbnRzLFxuICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgYSBzdGF0dXRvcnkgY2l0YXRpb24gKEZyZW5jaClcbiAgICovXG4gIHZhbGlkYXRlU3RhdHV0ZUZSKGNpdGF0aW9uOiBzdHJpbmcpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gY2l0YXRpb24udHJpbSgpO1xuICAgIGNvbnN0IG1hdGNoID0gQ2l0YXRpb25WYWxpZGF0b3IuU1RBVFVURV9QQVRURVJOX0ZSLmV4ZWMobm9ybWFsaXplZCk7XG5cbiAgICBpZiAoIW1hdGNoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgIHR5cGU6ICdzdGF0dXRlJyxcbiAgICAgICAgZXJyb3JzOiBbJ0ludmFsaWQgc3RhdHV0ZSBjaXRhdGlvbiBmb3JtYXQgKEZSKS4gRXhwZWN0ZWQ6IGFydC4gW251bWJlcl0gW2FsLiBYXSBbbGV0LiBhXSBbc3RhdHV0ZV0nXVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBbLCBhcnRpY2xlLCBwYXJhZ3JhcGgsIGxldHRlciwgbnVtYmVyLCBzdGF0dXRlXSA9IG1hdGNoO1xuICAgIGNvbnN0IGVycm9yczogc3RyaW5nW10gPSBbXTtcblxuICAgIGlmICghQ2l0YXRpb25WYWxpZGF0b3IuVkFMSURfU1RBVFVURVNfRlIuaGFzKHN0YXR1dGUudG9VcHBlckNhc2UoKSkpIHtcbiAgICAgIGVycm9ycy5wdXNoKGBVbmtub3duIHN0YXR1dGUgY29kZTogJHtzdGF0dXRlfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXBvbmVudHM6IENpdGF0aW9uQ29tcG9uZW50cyA9IHtcbiAgICAgIHN0YXR1dGU6IHN0YXR1dGUudG9VcHBlckNhc2UoKSxcbiAgICAgIGFydGljbGUsXG4gICAgICBwYXJhZ3JhcGg6IHBhcmFncmFwaCB8fCB1bmRlZmluZWQsXG4gICAgICBsZXR0ZXI6IGxldHRlciB8fCB1bmRlZmluZWQsXG4gICAgICBudW1iZXI6IG51bWJlciB8fCB1bmRlZmluZWRcbiAgICB9O1xuXG4gICAgbGV0IG5vcm0gPSBgYXJ0LiAke2FydGljbGV9YDtcbiAgICBpZiAocGFyYWdyYXBoKSBub3JtICs9IGAgYWwuICR7cGFyYWdyYXBofWA7XG4gICAgaWYgKGxldHRlcikgbm9ybSArPSBgIGxldC4gJHtsZXR0ZXJ9YDtcbiAgICBpZiAobnVtYmVyKSBub3JtICs9IGAgY2guICR7bnVtYmVyfWA7XG4gICAgbm9ybSArPSBgICR7c3RhdHV0ZS50b1VwcGVyQ2FzZSgpfWA7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGVycm9ycy5sZW5ndGggPT09IDAsXG4gICAgICB0eXBlOiAnc3RhdHV0ZScsXG4gICAgICBub3JtYWxpemVkOiBub3JtLFxuICAgICAgY29tcG9uZW50cyxcbiAgICAgIGVycm9yczogZXJyb3JzLmxlbmd0aCA+IDAgPyBlcnJvcnMgOiB1bmRlZmluZWRcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFZhbGlkYXRlIGEgc3RhdHV0b3J5IGNpdGF0aW9uIChJdGFsaWFuKVxuICAgKi9cbiAgdmFsaWRhdGVTdGF0dXRlSVQoY2l0YXRpb246IHN0cmluZyk6IFZhbGlkYXRpb25SZXN1bHQge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBjaXRhdGlvbi50cmltKCk7XG4gICAgY29uc3QgbWF0Y2ggPSBDaXRhdGlvblZhbGlkYXRvci5TVEFUVVRFX1BBVFRFUk5fSVQuZXhlYyhub3JtYWxpemVkKTtcblxuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgdHlwZTogJ3N0YXR1dGUnLFxuICAgICAgICBlcnJvcnM6IFsnSW52YWxpZCBzdGF0dXRlIGNpdGF0aW9uIGZvcm1hdCAoSVQpLiBFeHBlY3RlZDogYXJ0LiBbbnVtYmVyXSBbY3B2LiBYXSBbbGV0dC4gYV0gW3N0YXR1dGVdJ11cbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgWywgYXJ0aWNsZSwgcGFyYWdyYXBoLCBsZXR0ZXIsIG51bWJlciwgc3RhdHV0ZV0gPSBtYXRjaDtcbiAgICBjb25zdCBlcnJvcnM6IHN0cmluZ1tdID0gW107XG5cbiAgICBpZiAoIUNpdGF0aW9uVmFsaWRhdG9yLlZBTElEX1NUQVRVVEVTX0lULmhhcyhzdGF0dXRlLnRvVXBwZXJDYXNlKCkpKSB7XG4gICAgICBlcnJvcnMucHVzaChgVW5rbm93biBzdGF0dXRlIGNvZGU6ICR7c3RhdHV0ZX1gKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wb25lbnRzOiBDaXRhdGlvbkNvbXBvbmVudHMgPSB7XG4gICAgICBzdGF0dXRlOiBzdGF0dXRlLnRvVXBwZXJDYXNlKCksXG4gICAgICBhcnRpY2xlLFxuICAgICAgcGFyYWdyYXBoOiBwYXJhZ3JhcGggfHwgdW5kZWZpbmVkLFxuICAgICAgbGV0dGVyOiBsZXR0ZXIgfHwgdW5kZWZpbmVkLFxuICAgICAgbnVtYmVyOiBudW1iZXIgfHwgdW5kZWZpbmVkXG4gICAgfTtcblxuICAgIGxldCBub3JtID0gYGFydC4gJHthcnRpY2xlfWA7XG4gICAgaWYgKHBhcmFncmFwaCkgbm9ybSArPSBgIGNwdi4gJHtwYXJhZ3JhcGh9YDtcbiAgICBpZiAobGV0dGVyKSBub3JtICs9IGAgbGV0dC4gJHtsZXR0ZXJ9YDtcbiAgICBpZiAobnVtYmVyKSBub3JtICs9IGAgbi4gJHtudW1iZXJ9YDtcbiAgICBub3JtICs9IGAgJHtzdGF0dXRlLnRvVXBwZXJDYXNlKCl9YDtcblxuICAgIHJldHVybiB7XG4gICAgICB2YWxpZDogZXJyb3JzLmxlbmd0aCA9PT0gMCxcbiAgICAgIHR5cGU6ICdzdGF0dXRlJyxcbiAgICAgIG5vcm1hbGl6ZWQ6IG5vcm0sXG4gICAgICBjb21wb25lbnRzLFxuICAgICAgZXJyb3JzOiBlcnJvcnMubGVuZ3RoID4gMCA/IGVycm9ycyA6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQXV0by1kZXRlY3QgY2l0YXRpb24gdHlwZSBhbmQgdmFsaWRhdGVcbiAgICovXG4gIHZhbGlkYXRlKGNpdGF0aW9uOiBzdHJpbmcpOiBWYWxpZGF0aW9uUmVzdWx0IHtcbiAgICBjb25zdCBub3JtYWxpemVkID0gY2l0YXRpb24udHJpbSgpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAvLyBUcnkgQkdFL0FURi9EVEYgZmlyc3RcbiAgICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKCdCR0UnKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVCR0UoY2l0YXRpb24pO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKCdBVEYnKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVBVEYoY2l0YXRpb24pO1xuICAgIH1cbiAgICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKCdEVEYnKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsaWRhdGVEVEYoY2l0YXRpb24pO1xuICAgIH1cblxuICAgIC8vIFRyeSBzdGF0dXRvcnkgY2l0YXRpb25zXG4gICAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnQVJULicpKSB7XG4gICAgICAvLyBUcnkgR2VybWFuIGZpcnN0LCB0aGVuIEZyZW5jaCwgdGhlbiBJdGFsaWFuXG4gICAgICBjb25zdCByZXN1bHRERSA9IHRoaXMudmFsaWRhdGVTdGF0dXRlREUoY2l0YXRpb24pO1xuICAgICAgaWYgKHJlc3VsdERFLnZhbGlkKSByZXR1cm4gcmVzdWx0REU7XG5cbiAgICAgIGNvbnN0IHJlc3VsdEZSID0gdGhpcy52YWxpZGF0ZVN0YXR1dGVGUihjaXRhdGlvbik7XG4gICAgICBpZiAocmVzdWx0RlIudmFsaWQpIHJldHVybiByZXN1bHRGUjtcblxuICAgICAgY29uc3QgcmVzdWx0SVQgPSB0aGlzLnZhbGlkYXRlU3RhdHV0ZUlUKGNpdGF0aW9uKTtcbiAgICAgIGlmIChyZXN1bHRJVC52YWxpZCkgcmV0dXJuIHJlc3VsdElUO1xuXG4gICAgICAvLyBSZXR1cm4gdGhlIGZpcnN0IGF0dGVtcHQncyBlcnJvcnNcbiAgICAgIHJldHVybiByZXN1bHRERTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgdHlwZTogJ3Vua25vd24nLFxuICAgICAgZXJyb3JzOiBbJ1VuYWJsZSB0byBkZXRlY3QgY2l0YXRpb24gdHlwZS4gU3VwcG9ydGVkOiBCR0UvQVRGL0RURiwgQXJ0LiBbc3RhdHV0ZV0nXVxuICAgIH07XG4gIH1cbn1cbiIsICIvKipcbiAqIE11bHRpLWxpbmd1YWwgY2l0YXRpb24gZm9ybWF0dGVyIGZvciBTd2lzcyBsZWdhbCBjaXRhdGlvbnNcbiAqIENvbnZlcnRzIGJldHdlZW4gREUvRlIvSVQvRU4gZm9ybWF0cyB3aGlsZSBwcmVzZXJ2aW5nIG1lYW5pbmdcbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIExhbmd1YWdlLFxuICBGb3JtYXRPcHRpb25zLFxuICBGb3JtYXR0ZWRDaXRhdGlvbixcbiAgQ2l0YXRpb25Db21wb25lbnRzLFxuICBDaXRhdGlvblR5cGVcbn0gZnJvbSAnLi4vdHlwZXMuanMnO1xuXG5leHBvcnQgY2xhc3MgQ2l0YXRpb25Gb3JtYXR0ZXIge1xuICAvLyBTdGF0dXRlIG5hbWUgbWFwcGluZ3MgYWNyb3NzIGxhbmd1YWdlc1xuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBTVEFUVVRFX05BTUVTOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8TGFuZ3VhZ2UsIHN0cmluZz4+ID0ge1xuICAgICdaR0InOiB7XG4gICAgICBkZTogJ1pHQicsXG4gICAgICBmcjogJ0NDJyxcbiAgICAgIGl0OiAnQ0MnLFxuICAgICAgZW46ICdDQycgLy8gU3dpc3MgQ2l2aWwgQ29kZVxuICAgIH0sXG4gICAgJ0NDJzoge1xuICAgICAgZGU6ICdaR0InLFxuICAgICAgZnI6ICdDQycsXG4gICAgICBpdDogJ0NDJyxcbiAgICAgIGVuOiAnQ0MnXG4gICAgfSxcbiAgICAnT1InOiB7XG4gICAgICBkZTogJ09SJyxcbiAgICAgIGZyOiAnQ08nLFxuICAgICAgaXQ6ICdDTycsXG4gICAgICBlbjogJ0NPJyAvLyBDb2RlIG9mIE9ibGlnYXRpb25zXG4gICAgfSxcbiAgICAnQ08nOiB7XG4gICAgICBkZTogJ09SJyxcbiAgICAgIGZyOiAnQ08nLFxuICAgICAgaXQ6ICdDTycsXG4gICAgICBlbjogJ0NPJ1xuICAgIH0sXG4gICAgJ1NUR0InOiB7XG4gICAgICBkZTogJ1N0R0InLFxuICAgICAgZnI6ICdDUCcsXG4gICAgICBpdDogJ0NQJyxcbiAgICAgIGVuOiAnQ1AnIC8vIENyaW1pbmFsIENvZGVcbiAgICB9LFxuICAgICdDUCc6IHtcbiAgICAgIGRlOiAnU3RHQicsXG4gICAgICBmcjogJ0NQJyxcbiAgICAgIGl0OiAnQ1AnLFxuICAgICAgZW46ICdDUCdcbiAgICB9LFxuICAgICdTVFBPJzoge1xuICAgICAgZGU6ICdTdFBPJyxcbiAgICAgIGZyOiAnQ1BQJyxcbiAgICAgIGl0OiAnQ1BQJyxcbiAgICAgIGVuOiAnQ1BQJyAvLyBDcmltaW5hbCBQcm9jZWR1cmUgQ29kZVxuICAgIH0sXG4gICAgJ0NQUCc6IHtcbiAgICAgIGRlOiAnU3RQTycsXG4gICAgICBmcjogJ0NQUCcsXG4gICAgICBpdDogJ0NQUCcsXG4gICAgICBlbjogJ0NQUCdcbiAgICB9LFxuICAgICdaUE8nOiB7XG4gICAgICBkZTogJ1pQTycsXG4gICAgICBmcjogJ0NQQycsXG4gICAgICBpdDogJ0NQQycsXG4gICAgICBlbjogJ0NQQycgLy8gQ2l2aWwgUHJvY2VkdXJlIENvZGVcbiAgICB9LFxuICAgICdDUEMnOiB7XG4gICAgICBkZTogJ1pQTycsXG4gICAgICBmcjogJ0NQQycsXG4gICAgICBpdDogJ0NQQycsXG4gICAgICBlbjogJ0NQQydcbiAgICB9LFxuICAgICdCVic6IHtcbiAgICAgIGRlOiAnQlYnLFxuICAgICAgZnI6ICdDc3QnLFxuICAgICAgaXQ6ICdDb3N0JyxcbiAgICAgIGVuOiAnQ3N0JyAvLyBGZWRlcmFsIENvbnN0aXR1dGlvblxuICAgIH0sXG4gICAgJ0NTVCc6IHtcbiAgICAgIGRlOiAnQlYnLFxuICAgICAgZnI6ICdDc3QnLFxuICAgICAgaXQ6ICdDb3N0JyxcbiAgICAgIGVuOiAnQ3N0J1xuICAgIH0sXG4gICAgJ0NPU1QnOiB7XG4gICAgICBkZTogJ0JWJyxcbiAgICAgIGZyOiAnQ3N0JyxcbiAgICAgIGl0OiAnQ29zdCcsXG4gICAgICBlbjogJ0NzdCdcbiAgICB9LFxuICAgICdTQ0hLRyc6IHtcbiAgICAgIGRlOiAnU2NoS0cnLFxuICAgICAgZnI6ICdMUCcsXG4gICAgICBpdDogJ0xFRicsXG4gICAgICBlbjogJ0RFQkEnIC8vIERlYnQgQ29sbGVjdGlvbiBhbmQgQmFua3J1cHRjeSBBY3RcbiAgICB9LFxuICAgICdMUCc6IHtcbiAgICAgIGRlOiAnU2NoS0cnLFxuICAgICAgZnI6ICdMUCcsXG4gICAgICBpdDogJ0xFRicsXG4gICAgICBlbjogJ0RFQkEnXG4gICAgfSxcbiAgICAnTEVGJzoge1xuICAgICAgZGU6ICdTY2hLRycsXG4gICAgICBmcjogJ0xQJyxcbiAgICAgIGl0OiAnTEVGJyxcbiAgICAgIGVuOiAnREVCQSdcbiAgICB9LFxuICAgICdEU0cnOiB7XG4gICAgICBkZTogJ0RTRycsXG4gICAgICBmcjogJ0xQRCcsXG4gICAgICBpdDogJ0xQRCcsXG4gICAgICBlbjogJ0RQQScgLy8gRGF0YSBQcm90ZWN0aW9uIEFjdFxuICAgIH0sXG4gICAgJ0xQRCc6IHtcbiAgICAgIGRlOiAnRFNHJyxcbiAgICAgIGZyOiAnTFBEJyxcbiAgICAgIGl0OiAnTFBEJyxcbiAgICAgIGVuOiAnRFBBJ1xuICAgIH1cbiAgfTtcblxuICAvLyBGdWxsIHN0YXR1dGUgbmFtZXNcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgU1RBVFVURV9GVUxMX05BTUVTOiBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8TGFuZ3VhZ2UsIHN0cmluZz4+ID0ge1xuICAgICdaR0InOiB7XG4gICAgICBkZTogJ1NjaHdlaXplcmlzY2hlcyBaaXZpbGdlc2V0emJ1Y2gnLFxuICAgICAgZnI6ICdDb2RlIGNpdmlsIHN1aXNzZScsXG4gICAgICBpdDogJ0NvZGljZSBjaXZpbGUgc3Zpenplcm8nLFxuICAgICAgZW46ICdTd2lzcyBDaXZpbCBDb2RlJ1xuICAgIH0sXG4gICAgJ09SJzoge1xuICAgICAgZGU6ICdPYmxpZ2F0aW9uZW5yZWNodCcsXG4gICAgICBmcjogJ0NvZGUgZGVzIG9ibGlnYXRpb25zJyxcbiAgICAgIGl0OiAnQ29kaWNlIGRlbGxlIG9iYmxpZ2F6aW9uaScsXG4gICAgICBlbjogJ0NvZGUgb2YgT2JsaWdhdGlvbnMnXG4gICAgfSxcbiAgICAnU3RHQic6IHtcbiAgICAgIGRlOiAnU2Nod2VpemVyaXNjaGVzIFN0cmFmZ2VzZXR6YnVjaCcsXG4gICAgICBmcjogJ0NvZGUgcFx1MDBFOW5hbCBzdWlzc2UnLFxuICAgICAgaXQ6ICdDb2RpY2UgcGVuYWxlIHN2aXp6ZXJvJyxcbiAgICAgIGVuOiAnU3dpc3MgQ3JpbWluYWwgQ29kZSdcbiAgICB9LFxuICAgICdCVic6IHtcbiAgICAgIGRlOiAnQnVuZGVzdmVyZmFzc3VuZyBkZXIgU2Nod2VpemVyaXNjaGVuIEVpZGdlbm9zc2Vuc2NoYWZ0JyxcbiAgICAgIGZyOiAnQ29uc3RpdHV0aW9uIGZcdTAwRTlkXHUwMEU5cmFsZSBkZSBsYSBDb25mXHUwMEU5ZFx1MDBFOXJhdGlvbiBzdWlzc2UnLFxuICAgICAgaXQ6ICdDb3N0aXR1emlvbmUgZmVkZXJhbGUgZGVsbGEgQ29uZmVkZXJhemlvbmUgU3ZpenplcmEnLFxuICAgICAgZW46ICdGZWRlcmFsIENvbnN0aXR1dGlvbiBvZiB0aGUgU3dpc3MgQ29uZmVkZXJhdGlvbidcbiAgICB9XG4gIH07XG5cbiAgLy8gQ2l0YXRpb24gY29tcG9uZW50IGxhYmVscyBieSBsYW5ndWFnZVxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBMQUJFTFM6IFJlY29yZDxMYW5ndWFnZSwge1xuICAgIGFydGljbGU6IHN0cmluZztcbiAgICBwYXJhZ3JhcGg6IHN0cmluZztcbiAgICBsZXR0ZXI6IHN0cmluZztcbiAgICBudW1iZXI6IHN0cmluZztcbiAgfT4gPSB7XG4gICAgZGU6IHtcbiAgICAgIGFydGljbGU6ICdBcnQuJyxcbiAgICAgIHBhcmFncmFwaDogJ0Ficy4nLFxuICAgICAgbGV0dGVyOiAnbGl0LicsXG4gICAgICBudW1iZXI6ICdaaWZmLidcbiAgICB9LFxuICAgIGZyOiB7XG4gICAgICBhcnRpY2xlOiAnYXJ0LicsXG4gICAgICBwYXJhZ3JhcGg6ICdhbC4nLFxuICAgICAgbGV0dGVyOiAnbGV0LicsXG4gICAgICBudW1iZXI6ICdjaC4nXG4gICAgfSxcbiAgICBpdDoge1xuICAgICAgYXJ0aWNsZTogJ2FydC4nLFxuICAgICAgcGFyYWdyYXBoOiAnY3B2LicsXG4gICAgICBsZXR0ZXI6ICdsZXR0LicsXG4gICAgICBudW1iZXI6ICduLidcbiAgICB9LFxuICAgIGVuOiB7XG4gICAgICBhcnRpY2xlOiAnQXJ0LicsXG4gICAgICBwYXJhZ3JhcGg6ICdwYXJhLicsXG4gICAgICBsZXR0ZXI6ICdsZXQuJyxcbiAgICAgIG51bWJlcjogJ25vLidcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIEJHRS9BVEYvRFRGIGNpdGF0aW9uIHRvIHRhcmdldCBsYW5ndWFnZVxuICAgKi9cbiAgZm9ybWF0Q291cnRDaXRhdGlvbihcbiAgICB0eXBlOiAnYmdlJyB8ICdhdGYnIHwgJ2R0ZicsXG4gICAgY29tcG9uZW50czogQ2l0YXRpb25Db21wb25lbnRzLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApOiBGb3JtYXR0ZWRDaXRhdGlvbiB7XG4gICAgY29uc3QgeyB2b2x1bWUsIGNoYW1iZXIsIHBhZ2UgfSA9IGNvbXBvbmVudHM7XG5cbiAgICAvLyBCR0UvQVRGL0RURiBjb252ZXJzaW9uc1xuICAgIGNvbnN0IGNpdGF0aW9uUHJlZml4ID0gdGhpcy5jb252ZXJ0Q291cnRDaXRhdGlvblByZWZpeCh0eXBlLCB0YXJnZXRMYW5ndWFnZSk7XG5cbiAgICBjb25zdCBjaXRhdGlvbiA9IGAke2NpdGF0aW9uUHJlZml4fSAke3ZvbHVtZX0gJHtjaGFtYmVyfSAke3BhZ2V9YDtcblxuICAgIHJldHVybiB7XG4gICAgICBjaXRhdGlvbixcbiAgICAgIGxhbmd1YWdlOiB0YXJnZXRMYW5ndWFnZSxcbiAgICAgIHR5cGUsXG4gICAgICBhYmJyZXZpYXRlZFJlZmVyZW5jZTogY2l0YXRpb24sXG4gICAgICBmdWxsUmVmZXJlbmNlOiBjaXRhdGlvblxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydCBCR0UvQVRGL0RURiBwcmVmaXggYmFzZWQgb24gbGFuZ3VhZ2VcbiAgICovXG4gIHByaXZhdGUgY29udmVydENvdXJ0Q2l0YXRpb25QcmVmaXgoXG4gICAgc291cmNlVHlwZTogJ2JnZScgfCAnYXRmJyB8ICdkdGYnLFxuICAgIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZVxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHByZWZpeE1hcDogUmVjb3JkPExhbmd1YWdlLCBzdHJpbmc+ID0ge1xuICAgICAgZGU6ICdCR0UnLFxuICAgICAgZnI6ICdBVEYnLFxuICAgICAgaXQ6ICdEVEYnLFxuICAgICAgZW46ICdCR0UnIC8vIFVzZSBHZXJtYW4gYWJicmV2aWF0aW9uIGZvciBFbmdsaXNoXG4gICAgfTtcblxuICAgIHJldHVybiBwcmVmaXhNYXBbdGFyZ2V0TGFuZ3VhZ2VdO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBhIHN0YXR1dG9yeSBjaXRhdGlvbiB0byB0YXJnZXQgbGFuZ3VhZ2VcbiAgICovXG4gIGZvcm1hdFN0YXR1dG9yeUNpdGF0aW9uKFxuICAgIGNvbXBvbmVudHM6IENpdGF0aW9uQ29tcG9uZW50cyxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgb3B0aW9uczogRm9ybWF0T3B0aW9ucyA9IHsgbGFuZ3VhZ2U6IHRhcmdldExhbmd1YWdlIH1cbiAgKTogRm9ybWF0dGVkQ2l0YXRpb24ge1xuICAgIGNvbnN0IHsgYXJ0aWNsZSwgcGFyYWdyYXBoLCBsZXR0ZXIsIG51bWJlciwgc3RhdHV0ZSB9ID0gY29tcG9uZW50cztcblxuICAgIGlmICghc3RhdHV0ZSB8fCAhYXJ0aWNsZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0dXRlIGFuZCBhcnRpY2xlIGFyZSByZXF1aXJlZCBmb3Igc3RhdHV0b3J5IGNpdGF0aW9ucycpO1xuICAgIH1cblxuICAgIGNvbnN0IGxhYmVscyA9IENpdGF0aW9uRm9ybWF0dGVyLkxBQkVMU1t0YXJnZXRMYW5ndWFnZV07XG5cbiAgICAvLyBDb252ZXJ0IHN0YXR1dGUgY29kZSB0byB0YXJnZXQgbGFuZ3VhZ2VcbiAgICBjb25zdCBjb252ZXJ0ZWRTdGF0dXRlID0gdGhpcy5jb252ZXJ0U3RhdHV0ZUNvZGUoc3RhdHV0ZSwgdGFyZ2V0TGFuZ3VhZ2UpO1xuXG4gICAgLy8gQnVpbGQgY2l0YXRpb24gc3RyaW5nXG4gICAgbGV0IGNpdGF0aW9uID0gYCR7bGFiZWxzLmFydGljbGV9ICR7YXJ0aWNsZX1gO1xuXG4gICAgaWYgKHBhcmFncmFwaCkge1xuICAgICAgY2l0YXRpb24gKz0gYCAke2xhYmVscy5wYXJhZ3JhcGh9ICR7cGFyYWdyYXBofWA7XG4gICAgfVxuXG4gICAgaWYgKGxldHRlcikge1xuICAgICAgY2l0YXRpb24gKz0gYCAke2xhYmVscy5sZXR0ZXJ9ICR7bGV0dGVyfWA7XG4gICAgfVxuXG4gICAgaWYgKG51bWJlcikge1xuICAgICAgY2l0YXRpb24gKz0gYCAke2xhYmVscy5udW1iZXJ9ICR7bnVtYmVyfWA7XG4gICAgfVxuXG4gICAgY2l0YXRpb24gKz0gYCAke2NvbnZlcnRlZFN0YXR1dGV9YDtcblxuICAgIC8vIEJ1aWxkIGZ1bGwgcmVmZXJlbmNlIGlmIHJlcXVlc3RlZFxuICAgIGxldCBmdWxsUmVmZXJlbmNlID0gY2l0YXRpb247XG4gICAgaWYgKG9wdGlvbnMuZnVsbFN0YXR1dGVOYW1lKSB7XG4gICAgICBjb25zdCBmdWxsTmFtZSA9IENpdGF0aW9uRm9ybWF0dGVyLlNUQVRVVEVfRlVMTF9OQU1FU1tzdGF0dXRlXT8uW3RhcmdldExhbmd1YWdlXTtcbiAgICAgIGlmIChmdWxsTmFtZSkge1xuICAgICAgICBmdWxsUmVmZXJlbmNlID0gYCR7Y2l0YXRpb259ICgke2Z1bGxOYW1lfSlgO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjaXRhdGlvbixcbiAgICAgIGxhbmd1YWdlOiB0YXJnZXRMYW5ndWFnZSxcbiAgICAgIHR5cGU6ICdzdGF0dXRlJyxcbiAgICAgIGFiYnJldmlhdGVkUmVmZXJlbmNlOiBjaXRhdGlvbixcbiAgICAgIGZ1bGxSZWZlcmVuY2VcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgc3RhdHV0ZSBjb2RlIGJldHdlZW4gbGFuZ3VhZ2VzXG4gICAqL1xuICBwcml2YXRlIGNvbnZlcnRTdGF0dXRlQ29kZShzdGF0dXRlOiBzdHJpbmcsIHRhcmdldExhbmd1YWdlOiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFN0YXR1dGUgPSBzdGF0dXRlLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAvLyBEaXJlY3QgbWFwcGluZyBleGlzdHNcbiAgICBpZiAoQ2l0YXRpb25Gb3JtYXR0ZXIuU1RBVFVURV9OQU1FU1tub3JtYWxpemVkU3RhdHV0ZV0pIHtcbiAgICAgIHJldHVybiBDaXRhdGlvbkZvcm1hdHRlci5TVEFUVVRFX05BTUVTW25vcm1hbGl6ZWRTdGF0dXRlXVt0YXJnZXRMYW5ndWFnZV07XG4gICAgfVxuXG4gICAgLy8gUmV2ZXJzZSBsb29rdXAgLSBmaW5kIHRoZSBiYXNlIHN0YXR1dGVcbiAgICBmb3IgKGNvbnN0IFtiYXNlU3RhdHV0ZSwgdHJhbnNsYXRpb25zXSBvZiBPYmplY3QuZW50cmllcyhDaXRhdGlvbkZvcm1hdHRlci5TVEFUVVRFX05BTUVTKSkge1xuICAgICAgZm9yIChjb25zdCB0cmFuc2xhdGlvbiBvZiBPYmplY3QudmFsdWVzKHRyYW5zbGF0aW9ucykpIHtcbiAgICAgICAgaWYgKHRyYW5zbGF0aW9uLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWRTdGF0dXRlKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uc1t0YXJnZXRMYW5ndWFnZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBObyBtYXBwaW5nIGZvdW5kLCByZXR1cm4gb3JpZ2luYWxcbiAgICByZXR1cm4gc3RhdHV0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgYW55IGNpdGF0aW9uIHR5cGUgdG8gdGFyZ2V0IGxhbmd1YWdlXG4gICAqL1xuICBmb3JtYXQoXG4gICAgdHlwZTogQ2l0YXRpb25UeXBlLFxuICAgIGNvbXBvbmVudHM6IENpdGF0aW9uQ29tcG9uZW50cyxcbiAgICB0YXJnZXRMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgb3B0aW9ucz86IEZvcm1hdE9wdGlvbnNcbiAgKTogRm9ybWF0dGVkQ2l0YXRpb24ge1xuICAgIGNvbnN0IG9wdHM6IEZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICBsYW5ndWFnZTogdGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICBpbmNsdWRlQWJicmV2aWF0aW9uczogdHJ1ZSxcbiAgICAgIGZ1bGxTdGF0dXRlTmFtZTogZmFsc2UsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcblxuICAgIGlmICh0eXBlID09PSAnYmdlJyB8fCB0eXBlID09PSAnYXRmJyB8fCB0eXBlID09PSAnZHRmJykge1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Q291cnRDaXRhdGlvbih0eXBlLCBjb21wb25lbnRzLCB0YXJnZXRMYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzdGF0dXRlJyB8fCB0eXBlID09PSAnYXJ0aWNsZScpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvcm1hdFN0YXR1dG9yeUNpdGF0aW9uKGNvbXBvbmVudHMsIHRhcmdldExhbmd1YWdlLCBvcHRzKTtcbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNpdGF0aW9uIHR5cGUgZm9yIGZvcm1hdHRpbmc6ICR7dHlwZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0IGNpdGF0aW9uIGZyb20gb25lIGxhbmd1YWdlIHRvIGFub3RoZXJcbiAgICovXG4gIGNvbnZlcnQoXG4gICAgY2l0YXRpb246IHN0cmluZyxcbiAgICBzb3VyY2VMYW5ndWFnZTogTGFuZ3VhZ2UsXG4gICAgdGFyZ2V0TGFuZ3VhZ2U6IExhbmd1YWdlLFxuICAgIGNvbXBvbmVudHM6IENpdGF0aW9uQ29tcG9uZW50cyxcbiAgICB0eXBlOiBDaXRhdGlvblR5cGVcbiAgKTogRm9ybWF0dGVkQ2l0YXRpb24ge1xuICAgIHJldHVybiB0aGlzLmZvcm1hdCh0eXBlLCBjb21wb25lbnRzLCB0YXJnZXRMYW5ndWFnZSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCBhdmFpbGFibGUgdHJhbnNsYXRpb25zIGZvciBhIGNpdGF0aW9uXG4gICAqL1xuICBnZXRBbGxUcmFuc2xhdGlvbnMoXG4gICAgdHlwZTogQ2l0YXRpb25UeXBlLFxuICAgIGNvbXBvbmVudHM6IENpdGF0aW9uQ29tcG9uZW50c1xuICApOiBSZWNvcmQ8TGFuZ3VhZ2UsIHN0cmluZz4ge1xuICAgIGNvbnN0IGxhbmd1YWdlczogTGFuZ3VhZ2VbXSA9IFsnZGUnLCAnZnInLCAnaXQnLCAnZW4nXTtcbiAgICBjb25zdCB0cmFuc2xhdGlvbnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgbGFuZyBvZiBsYW5ndWFnZXMpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0KHR5cGUsIGNvbXBvbmVudHMsIGxhbmcpO1xuICAgICAgICB0cmFuc2xhdGlvbnNbbGFuZ10gPSBmb3JtYXR0ZWQuY2l0YXRpb247XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAvLyBTa2lwIGlmIHRyYW5zbGF0aW9uIGZhaWxzXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zbGF0aW9ucyBhcyBSZWNvcmQ8TGFuZ3VhZ2UsIHN0cmluZz47XG4gIH1cbn1cbiIsICIvKipcbiAqIENpdGF0aW9uIHBhcnNlciBmb3IgU3dpc3MgbGVnYWwgY2l0YXRpb25zXG4gKiBFeHRyYWN0cyBjb21wb25lbnRzIGFuZCBkZXRlY3RzIGxhbmd1YWdlIGZyb20gY2l0YXRpb24gc3RyaW5nc1xuICovXG5cbmltcG9ydCB0eXBlIHtcbiAgUGFyc2VkQ2l0YXRpb24sXG4gIExhbmd1YWdlLFxuICBDaXRhdGlvblR5cGUsXG4gIENpdGF0aW9uQ29tcG9uZW50c1xufSBmcm9tICcuLi90eXBlcy5qcyc7XG5pbXBvcnQgeyBDaXRhdGlvblZhbGlkYXRvciB9IGZyb20gJy4uL3ZhbGlkYXRvcnMvY2l0YXRpb24tdmFsaWRhdG9yLmpzJztcblxuZXhwb3J0IGNsYXNzIENpdGF0aW9uUGFyc2VyIHtcbiAgcHJpdmF0ZSB2YWxpZGF0b3I6IENpdGF0aW9uVmFsaWRhdG9yO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudmFsaWRhdG9yID0gbmV3IENpdGF0aW9uVmFsaWRhdG9yKCk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGxhbmd1YWdlIGZyb20gY2l0YXRpb24gc3RyaW5nXG4gICAqL1xuICBkZXRlY3RMYW5ndWFnZShjaXRhdGlvbjogc3RyaW5nKTogTGFuZ3VhZ2Uge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBjaXRhdGlvbi50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIENoZWNrIGZvciBGcmVuY2gtc3BlY2lmaWMgbWFya2Vyc1xuICAgIGlmIChub3JtYWxpemVkLmluY2x1ZGVzKCcgYWwuICcpIHx8IG5vcm1hbGl6ZWQuaW5jbHVkZXMoJyBsZXQuICcpIHx8IG5vcm1hbGl6ZWQuaW5jbHVkZXMoJyBjaC4gJykpIHtcbiAgICAgIHJldHVybiAnZnInO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBJdGFsaWFuLXNwZWNpZmljIG1hcmtlcnNcbiAgICBpZiAobm9ybWFsaXplZC5pbmNsdWRlcygnIGNwdi4gJykgfHwgbm9ybWFsaXplZC5pbmNsdWRlcygnIGxldHQuICcpKSB7XG4gICAgICByZXR1cm4gJ2l0JztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgR2VybWFuLXNwZWNpZmljIG1hcmtlcnNcbiAgICBpZiAobm9ybWFsaXplZC5pbmNsdWRlcygnIGFicy4gJykgfHwgbm9ybWFsaXplZC5pbmNsdWRlcygnIGxpdC4gJykgfHwgbm9ybWFsaXplZC5pbmNsdWRlcygnIHppZmYuICcpKSB7XG4gICAgICByZXR1cm4gJ2RlJztcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgY291cnQgY2l0YXRpb24gcHJlZml4ZXNcbiAgICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKCdhdGYnKSkge1xuICAgICAgcmV0dXJuICdmcic7XG4gICAgfVxuICAgIGlmIChub3JtYWxpemVkLnN0YXJ0c1dpdGgoJ2R0ZicpKSB7XG4gICAgICByZXR1cm4gJ2l0JztcbiAgICB9XG4gICAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnYmdlJykpIHtcbiAgICAgIHJldHVybiAnZGUnO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBzdGF0dXRlIGNvZGVzXG4gICAgaWYgKG5vcm1hbGl6ZWQuaW5jbHVkZXMoJyBjYycpIHx8IG5vcm1hbGl6ZWQuaW5jbHVkZXMoJyBjbycpIHx8IG5vcm1hbGl6ZWQuaW5jbHVkZXMoJyBjc3QnKSkge1xuICAgICAgLy8gQ291bGQgYmUgRlIgb3IgSVRcbiAgICAgIGlmIChub3JtYWxpemVkLmluY2x1ZGVzKCcgY3B2LicpKSByZXR1cm4gJ2l0JztcbiAgICAgIHJldHVybiAnZnInO1xuICAgIH1cblxuICAgIGlmIChub3JtYWxpemVkLmluY2x1ZGVzKCcgemdiJykgfHwgbm9ybWFsaXplZC5pbmNsdWRlcygnIG9yJykgfHwgbm9ybWFsaXplZC5pbmNsdWRlcygnIGJ2JykpIHtcbiAgICAgIHJldHVybiAnZGUnO1xuICAgIH1cblxuICAgIC8vIERlZmF1bHQgdG8gR2VybWFuIChtb3N0IGNvbW1vbiBmb3IgU3dpc3MgZmVkZXJhbCBsYXcpXG4gICAgcmV0dXJuICdkZSc7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZWN0IGNpdGF0aW9uIHR5cGVcbiAgICovXG4gIGRldGVjdFR5cGUoY2l0YXRpb246IHN0cmluZyk6IENpdGF0aW9uVHlwZSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IGNpdGF0aW9uLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnQkdFJykpIHJldHVybiAnYmdlJztcbiAgICBpZiAobm9ybWFsaXplZC5zdGFydHNXaXRoKCdBVEYnKSkgcmV0dXJuICdhdGYnO1xuICAgIGlmIChub3JtYWxpemVkLnN0YXJ0c1dpdGgoJ0RURicpKSByZXR1cm4gJ2R0Zic7XG4gICAgaWYgKG5vcm1hbGl6ZWQuc3RhcnRzV2l0aCgnQVJULicpKSByZXR1cm4gJ3N0YXR1dGUnO1xuXG4gICAgcmV0dXJuICd1bmtub3duJztcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhbnkgU3dpc3MgbGVnYWwgY2l0YXRpb25cbiAgICovXG4gIHBhcnNlKGNpdGF0aW9uOiBzdHJpbmcpOiBQYXJzZWRDaXRhdGlvbiB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZGV0ZWN0VHlwZShjaXRhdGlvbik7XG4gICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmRldGVjdExhbmd1YWdlKGNpdGF0aW9uKTtcblxuICAgIC8vIFZhbGlkYXRlIGFuZCBleHRyYWN0IGNvbXBvbmVudHNcbiAgICBjb25zdCB2YWxpZGF0aW9uUmVzdWx0ID0gdGhpcy52YWxpZGF0b3IudmFsaWRhdGUoY2l0YXRpb24pO1xuXG4gICAgY29uc3QgcGFyc2VkOiBQYXJzZWRDaXRhdGlvbiA9IHtcbiAgICAgIG9yaWdpbmFsOiBjaXRhdGlvbixcbiAgICAgIHR5cGUsXG4gICAgICBjb21wb25lbnRzOiB2YWxpZGF0aW9uUmVzdWx0LmNvbXBvbmVudHMgfHwge30sXG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGlzVmFsaWQ6IHZhbGlkYXRpb25SZXN1bHQudmFsaWRcbiAgICB9O1xuXG4gICAgLy8gQWRkIHN1Z2dlc3Rpb25zIGZvciBpbnZhbGlkIGNpdGF0aW9uc1xuICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC52YWxpZCAmJiB2YWxpZGF0aW9uUmVzdWx0LmVycm9ycykge1xuICAgICAgcGFyc2VkLnN1Z2dlc3Rpb25zID0gdGhpcy5nZW5lcmF0ZVN1Z2dlc3Rpb25zKGNpdGF0aW9uLCB0eXBlLCBsYW5ndWFnZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcnNlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBtdWx0aXBsZSBjaXRhdGlvbnMgZnJvbSB0ZXh0XG4gICAqL1xuICBwYXJzZU11bHRpcGxlKHRleHQ6IHN0cmluZyk6IFBhcnNlZENpdGF0aW9uW10ge1xuICAgIC8vIENvbW1vbiBjaXRhdGlvbiBwYXR0ZXJuc1xuICAgIGNvbnN0IHBhdHRlcm5zID0gW1xuICAgICAgLy8gQkdFL0FURi9EVEY6IFwiQkdFIDEyMyBJViA0NTZcIlxuICAgICAgLyg/OkJHRXxBVEZ8RFRGKVxccytcXGR7MSwzfVxccytbSVZYXStcXHMrXFxkKy9naSxcbiAgICAgIC8vIFN0YXR1dG9yeTogXCJBcnQuIDEyMyBPUlwiXG4gICAgICAvQXJ0XFwuXFxzKlxcZCtbYS16XT8oPzpcXHMrKD86QWJzfGFsfGNwdilcXC5cXHMqXFxkKyk/KD86XFxzKyg/OmxpdHxsZXR8bGV0dClcXC5cXHMqW2Etel0pPyg/OlxccysoPzpaaWZmfGNofG4pXFwuXFxzKlxcZCspP1xccytbQS1aXXsyLH0vZ2lcbiAgICBdO1xuXG4gICAgY29uc3QgY2l0YXRpb25zOiBQYXJzZWRDaXRhdGlvbltdID0gW107XG4gICAgY29uc3QgZm91bmRDaXRhdGlvbnMgPSBuZXcgU2V0PHN0cmluZz4oKTtcblxuICAgIGZvciAoY29uc3QgcGF0dGVybiBvZiBwYXR0ZXJucykge1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IHRleHQubWF0Y2hBbGwocGF0dGVybik7XG4gICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIG1hdGNoZXMpIHtcbiAgICAgICAgY29uc3QgY2l0YXRpb24gPSBtYXRjaFswXTtcbiAgICAgICAgaWYgKCFmb3VuZENpdGF0aW9ucy5oYXMoY2l0YXRpb24pKSB7XG4gICAgICAgICAgZm91bmRDaXRhdGlvbnMuYWRkKGNpdGF0aW9uKTtcbiAgICAgICAgICBjaXRhdGlvbnMucHVzaCh0aGlzLnBhcnNlKGNpdGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2l0YXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIHN1Z2dlc3Rpb25zIGZvciBpbnZhbGlkIGNpdGF0aW9uc1xuICAgKi9cbiAgcHJpdmF0ZSBnZW5lcmF0ZVN1Z2dlc3Rpb25zKGNpdGF0aW9uOiBzdHJpbmcsIHR5cGU6IENpdGF0aW9uVHlwZSwgbGFuZ3VhZ2U6IExhbmd1YWdlKTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHN1Z2dlc3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgaWYgKHR5cGUgPT09ICdiZ2UnIHx8IHR5cGUgPT09ICdhdGYnIHx8IHR5cGUgPT09ICdkdGYnKSB7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKCdGb3JtYXQ6IEJHRSBbdm9sdW1lXSBbY2hhbWJlcl0gW3BhZ2VdJyk7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKCdFeGFtcGxlOiBCR0UgMTQ3IElWIDczJyk7XG4gICAgICBzdWdnZXN0aW9ucy5wdXNoKCdDaGFtYmVyIG11c3QgYmUgUm9tYW4gbnVtZXJhbCAoSS1YKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc3RhdHV0ZScpIHtcbiAgICAgIGlmIChsYW5ndWFnZSA9PT0gJ2RlJykge1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKCdGb3JtYXQ6IEFydC4gW251bWJlcl0gW0Ficy4gWF0gW2xpdC4gYV0gW3N0YXR1dGVdJyk7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0V4YW1wbGU6IEFydC4gOTcgQWJzLiAxIE9SJyk7XG4gICAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnZnInKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0Zvcm1hdDogYXJ0LiBbbnVtYmVyXSBbYWwuIFhdIFtsZXQuIGFdIFtzdGF0dXRlXScpO1xuICAgICAgICBzdWdnZXN0aW9ucy5wdXNoKCdFeGFtcGxlOiBhcnQuIDk3IGFsLiAxIENPJyk7XG4gICAgICB9IGVsc2UgaWYgKGxhbmd1YWdlID09PSAnaXQnKSB7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0Zvcm1hdDogYXJ0LiBbbnVtYmVyXSBbY3B2LiBYXSBbbGV0dC4gYV0gW3N0YXR1dGVdJyk7XG4gICAgICAgIHN1Z2dlc3Rpb25zLnB1c2goJ0V4YW1wbGU6IGFydC4gOTcgY3B2LiAxIENPJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHN1Z2dlc3Rpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgYXJ0aWNsZSBudW1iZXIgZnJvbSBjaXRhdGlvblxuICAgKi9cbiAgZXh0cmFjdEFydGljbGVOdW1iZXIoY2l0YXRpb246IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xuICAgIGNvbnN0IG1hdGNoID0gL0FydFxcLlxccyooXFxkK1thLXpdPykvaS5leGVjKGNpdGF0aW9uKTtcbiAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBzdGF0dXRlIGNvZGUgZnJvbSBjaXRhdGlvblxuICAgKi9cbiAgZXh0cmFjdFN0YXR1dGVDb2RlKGNpdGF0aW9uOiBzdHJpbmcpOiBzdHJpbmcgfCBudWxsIHtcbiAgICBjb25zdCBtYXRjaCA9IC9cXHMoW0EtWl17Mix9KSQvaS5leGVjKGNpdGF0aW9uLnRyaW0oKSk7XG4gICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0udG9VcHBlckNhc2UoKSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgaWYgdGV4dCBjb250YWlucyBsZWdhbCBjaXRhdGlvbnNcbiAgICovXG4gIGNvbnRhaW5zQ2l0YXRpb25zKHRleHQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiAvKD86QkdFfEFURnxEVEYpXFxzK1xcZHsxLDN9XFxzK1tJVlhdK1xccytcXGQrfEFydFxcLlxccypcXGQrW2Etel0/LipbQS1aXXsyLH0vaS50ZXN0KHRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvdW50IGNpdGF0aW9ucyBpbiB0ZXh0XG4gICAqL1xuICBjb3VudENpdGF0aW9ucyh0ZXh0OiBzdHJpbmcpOiBudW1iZXIge1xuICAgIHJldHVybiB0aGlzLnBhcnNlTXVsdGlwbGUodGV4dCkubGVuZ3RoO1xuICB9XG59XG4iLCAiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG4vKipcbiAqIExlZ2FsIENpdGF0aW9ucyBNQ1AgU2VydmVyXG4gKiBQcm92aWRlcyBjaXRhdGlvbiB2ZXJpZmljYXRpb24gYW5kIG11bHRpLWxpbmd1YWwgZm9ybWF0dGluZyBmb3IgU3dpc3MgbGF3XG4gKlxuICogQHNlZSBodHRwczovL21vZGVsY29udGV4dHByb3RvY29sLmlvL1xuICovXG5cbmltcG9ydCB7IFNlcnZlciB9IGZyb20gJ0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL2luZGV4LmpzJztcbmltcG9ydCB7IFN0ZGlvU2VydmVyVHJhbnNwb3J0IH0gZnJvbSAnQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvc3RkaW8uanMnO1xuaW1wb3J0IHtcbiAgQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLFxuICBMaXN0VG9vbHNSZXF1ZXN0U2NoZW1hLFxuICBFcnJvckNvZGUsXG4gIE1jcEVycm9yXG59IGZyb20gJ0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvdHlwZXMuanMnO1xuXG5pbXBvcnQgeyBDaXRhdGlvblZhbGlkYXRvciB9IGZyb20gJy4vdmFsaWRhdG9ycy9jaXRhdGlvbi12YWxpZGF0b3IuanMnO1xuaW1wb3J0IHsgQ2l0YXRpb25Gb3JtYXR0ZXIgfSBmcm9tICcuL2Zvcm1hdHRlcnMvY2l0YXRpb24tZm9ybWF0dGVyLmpzJztcbmltcG9ydCB7IENpdGF0aW9uUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXJzL2NpdGF0aW9uLXBhcnNlci5qcyc7XG5pbXBvcnQgdHlwZSB7IExhbmd1YWdlLCBGb3JtYXRPcHRpb25zLCBDaXRhdGlvbkNvbXBvbmVudHMsIENpdGF0aW9uVHlwZSwgUGFyc2VkQ2l0YXRpb24gfSBmcm9tICcuL3R5cGVzLmpzJztcblxuLyoqXG4gKiBGZWRsZXggQVBJIGNvbmZpZ3VyYXRpb24gZm9yIHByb3Zpc2lvbiB0ZXh0IHJldHJpZXZhbFxuICovXG5jb25zdCBGRURMRVhfQkFTRV9VUkwgPSAnaHR0cHM6Ly93d3cuZmVkbGV4LmFkbWluLmNoL2VsaSc7XG5cbi8qKlxuICogU3RhdHV0ZSB0byBTUiBudW1iZXIgbWFwcGluZyBmb3IgRmVkbGV4IEFQSVxuICovXG5jb25zdCBTVEFUVVRFX1NSX01BUFBJTkc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7XG4gIC8vIENpdmlsIExhd1xuICAnWkdCJzogJzIxMCcsICAgICAgLy8gWml2aWxnZXNldHpidWNoXG4gICdDQyc6ICcyMTAnLCAgICAgICAvLyBDb2RlIGNpdmlsXG4gICdDQ1MnOiAnMjEwJywgICAgICAvLyBDb2RpY2UgY2l2aWxlIHN2aXp6ZXJvXG5cbiAgLy8gT2JsaWdhdGlvbnNcbiAgJ09SJzogJzIyMCcsICAgICAgIC8vIE9ibGlnYXRpb25lbnJlY2h0XG4gICdDTyc6ICcyMjAnLCAgICAgICAvLyBDb2RlIGRlcyBvYmxpZ2F0aW9uc1xuXG4gIC8vIENyaW1pbmFsIExhd1xuICAnU3RHQic6ICczMTEuMCcsICAgLy8gU3RyYWZnZXNldHpidWNoXG4gICdDUCc6ICczMTEuMCcsICAgICAvLyBDb2RlIHBcdTAwRTluYWxcbiAgJ0NQUyc6ICczMTEuMCcsICAgIC8vIENvZGljZSBwZW5hbGUgc3Zpenplcm9cblxuICAvLyBGZWRlcmFsIENvbnN0aXR1dGlvblxuICAnQlYnOiAnMTAxJywgICAgICAgLy8gQnVuZGVzdmVyZmFzc3VuZ1xuICAnQ3N0JzogJzEwMScsICAgICAgLy8gQ29uc3RpdHV0aW9uIGZcdTAwRTlkXHUwMEU5cmFsZVxuICAnQ29zdCc6ICcxMDEnLCAgICAgLy8gQ29zdGl0dXppb25lIGZlZGVyYWxlXG5cbiAgLy8gQWRtaW5pc3RyYXRpdmUgTGF3XG4gICdWd1ZHJzogJzE3Mi4wMjEnLCAvLyBWZXJ3YWx0dW5nc3ZlcmZhaHJlbnNnZXNldHpcbiAgJ1BBJzogJzE3Mi4wMjEnLCAgIC8vIExvaSBzdXIgbGEgcHJvY1x1MDBFOWR1cmUgYWRtaW5pc3RyYXRpdmVcblxuICAvLyBCR0dcbiAgJ0JHRyc6ICcxNzMuMTEwJywgIC8vIEJ1bmRlc2dlcmljaHRzZ2VzZXR6XG4gICdMVEYnOiAnMTczLjExMCcsICAvLyBMb2kgc3VyIGxlIFRyaWJ1bmFsIGZcdTAwRTlkXHUwMEU5cmFsXG5cbiAgLy8gU2NoS0dcbiAgJ1NjaEtHJzogJzI4MS4xJywgIC8vIFNjaHVsZGJldHJlaWJ1bmdzLSB1bmQgS29ua3Vyc2dlc2V0elxuICAnTFAnOiAnMjgxLjEnLCAgICAgLy8gTG9pIHN1ciBsYSBwb3Vyc3VpdGUgcG91ciBkZXR0ZXNcblxuICAvLyBaUE9cbiAgJ1pQTyc6ICcyNzInLCAgICAgIC8vIFppdmlscHJvemVzc29yZG51bmdcbiAgJ0NQQyc6ICcyNzInLCAgICAgIC8vIENvZGUgZGUgcHJvY1x1MDBFOWR1cmUgY2l2aWxlXG5cbiAgLy8gU3RQT1xuICAnU3RQTyc6ICczMTIuMCcsICAgLy8gU3RyYWZwcm96ZXNzb3JkbnVuZ1xuICAnQ1BQJzogJzMxMi4wJywgICAgLy8gQ29kZSBkZSBwcm9jXHUwMEU5ZHVyZSBwXHUwMEU5bmFsZVxuXG4gIC8vIEFWSUdcbiAgJ0FWSUcnOiAnODM3LjAnLCAgIC8vIEFyYmVpdHNsb3NlbnZlcnNpY2hlcnVuZ3NnZXNldHpcbiAgJ0xBQ0knOiAnODM3LjAnLCAgIC8vIExvaSBzdXIgbCdhc3N1cmFuY2UtY2hcdTAwRjRtYWdlXG5cbiAgLy8gQUhWR1xuICAnQUhWRyc6ICc4MzEuMTAnLCAgLy8gQUhWLUdlc2V0elxuICAnTEFWUyc6ICc4MzEuMTAnLCAgLy8gTG9pIHN1ciBsJ0FWU1xuXG4gIC8vIElWR1xuICAnSVZHJzogJzgzMS4yMCcsICAgLy8gSW52YWxpZGVudmVyc2ljaGVydW5nc2dlc2V0elxuICAnTEFJJzogJzgzMS4yMCcsICAgLy8gTG9pIHN1ciBsJ0FJXG5cbiAgLy8gQlZHXG4gICdCVkcnOiAnODMxLjQwJywgICAvLyBCdW5kZXNnZXNldHogXHUwMEZDYmVyIGRpZSBiZXJ1ZmxpY2hlIFZvcnNvcmdlXG4gICdMUFAnOiAnODMxLjQwJywgICAvLyBMb2kgc3VyIGxhIHByXHUwMEU5dm95YW5jZSBwcm9mZXNzaW9ubmVsbGVcblxuICAvLyBVVkdcbiAgJ1VWRyc6ICc4MzIuMjAnLCAgIC8vIFVuZmFsbHZlcnNpY2hlcnVuZ3NnZXNldHpcbiAgJ0xBQSc6ICc4MzIuMjAnLCAgIC8vIExvaSBzdXIgbCdhc3N1cmFuY2UtYWNjaWRlbnRzXG5cbiAgLy8gS1ZHXG4gICdLVkcnOiAnODMyLjEwJywgICAvLyBLcmFua2VudmVyc2ljaGVydW5nc2dlc2V0elxuICAnTEFNYWwnOiAnODMyLjEwJywgLy8gTG9pIHN1ciBsJ2Fzc3VyYW5jZS1tYWxhZGllXG5cbiAgLy8gRFNHXG4gICdEU0cnOiAnMjM1LjEnLCAgICAvLyBEYXRlbnNjaHV0emdlc2V0elxuICAnTFBEJzogJzIzNS4xJywgICAgLy8gTG9pIHN1ciBsYSBwcm90ZWN0aW9uIGRlcyBkb25uXHUwMEU5ZXNcblxuICAvLyBJUFJHXG4gICdJUFJHJzogJzI5MScsICAgICAvLyBCdW5kZXNnZXNldHogXHUwMEZDYmVyIGRhcyBJbnRlcm5hdGlvbmFsZSBQcml2YXRyZWNodFxuICAnTERJUCc6ICcyOTEnLCAgICAgLy8gTG9pIHN1ciBsZSBkcm9pdCBpbnRlcm5hdGlvbmFsIHByaXZcdTAwRTlcblxuICAvLyBNV1N0R1xuICAnTVdTdEcnOiAnNjQxLjIwJywgLy8gTWVocndlcnRzdGV1ZXJnZXNldHpcbiAgJ0xUVkEnOiAnNjQxLjIwJywgIC8vIExvaSBzdXIgbGEgVFZBXG5cbiAgLy8gREJHXG4gICdEQkcnOiAnNjQyLjExJywgICAvLyBEaXJla3RlIEJ1bmRlc3N0ZXVlclxuICAnTElGRCc6ICc2NDIuMTEnLCAgLy8gTG9pIHN1ciBsJ2ltcFx1MDBGNHQgZlx1MDBFOWRcdTAwRTlyYWwgZGlyZWN0XG59O1xuXG4vKipcbiAqIEZ1bGwgc3RhdHV0ZSBuYW1lcyBieSBsYW5ndWFnZVxuICovXG5jb25zdCBTVEFUVVRFX0ZVTExfTkFNRVM6IFJlY29yZDxzdHJpbmcsIFJlY29yZDxMYW5ndWFnZSwgc3RyaW5nPj4gPSB7XG4gICdaR0InOiB7XG4gICAgZGU6ICdTY2h3ZWl6ZXJpc2NoZXMgWml2aWxnZXNldHpidWNoJyxcbiAgICBmcjogJ0NvZGUgY2l2aWwgc3Vpc3NlJyxcbiAgICBpdDogJ0NvZGljZSBjaXZpbGUgc3Zpenplcm8nLFxuICAgIGVuOiAnU3dpc3MgQ2l2aWwgQ29kZSdcbiAgfSxcbiAgJ09SJzoge1xuICAgIGRlOiAnT2JsaWdhdGlvbmVucmVjaHQnLFxuICAgIGZyOiAnQ29kZSBkZXMgb2JsaWdhdGlvbnMnLFxuICAgIGl0OiAnRGlyaXR0byBkZWxsZSBvYmJsaWdhemlvbmknLFxuICAgIGVuOiAnQ29kZSBvZiBPYmxpZ2F0aW9ucydcbiAgfSxcbiAgJ1N0R0InOiB7XG4gICAgZGU6ICdTY2h3ZWl6ZXJpc2NoZXMgU3RyYWZnZXNldHpidWNoJyxcbiAgICBmcjogJ0NvZGUgcFx1MDBFOW5hbCBzdWlzc2UnLFxuICAgIGl0OiAnQ29kaWNlIHBlbmFsZSBzdml6emVybycsXG4gICAgZW46ICdTd2lzcyBDcmltaW5hbCBDb2RlJ1xuICB9LFxuICAnQlYnOiB7XG4gICAgZGU6ICdCdW5kZXN2ZXJmYXNzdW5nIGRlciBTY2h3ZWl6ZXJpc2NoZW4gRWlkZ2Vub3NzZW5zY2hhZnQnLFxuICAgIGZyOiAnQ29uc3RpdHV0aW9uIGZcdTAwRTlkXHUwMEU5cmFsZSBkZSBsYSBDb25mXHUwMEU5ZFx1MDBFOXJhdGlvbiBzdWlzc2UnLFxuICAgIGl0OiAnQ29zdGl0dXppb25lIGZlZGVyYWxlIGRlbGxhIENvbmZlZGVyYXppb25lIFN2aXp6ZXJhJyxcbiAgICBlbjogJ0ZlZGVyYWwgQ29uc3RpdHV0aW9uIG9mIHRoZSBTd2lzcyBDb25mZWRlcmF0aW9uJ1xuICB9LFxuICAnQkdHJzoge1xuICAgIGRlOiAnQnVuZGVzZ2VyaWNodHNnZXNldHonLFxuICAgIGZyOiAnTG9pIHN1ciBsZSBUcmlidW5hbCBmXHUwMEU5ZFx1MDBFOXJhbCcsXG4gICAgaXQ6ICdMZWdnZSBzdWwgVHJpYnVuYWxlIGZlZGVyYWxlJyxcbiAgICBlbjogJ0ZlZGVyYWwgU3VwcmVtZSBDb3VydCBBY3QnXG4gIH0sXG4gICdaUE8nOiB7XG4gICAgZGU6ICdTY2h3ZWl6ZXJpc2NoZSBaaXZpbHByb3plc3NvcmRudW5nJyxcbiAgICBmcjogJ0NvZGUgZGUgcHJvY1x1MDBFOWR1cmUgY2l2aWxlJyxcbiAgICBpdDogJ0NvZGljZSBkaSBkaXJpdHRvIHByb2Nlc3N1YWxlIGNpdmlsZSBzdml6emVybycsXG4gICAgZW46ICdTd2lzcyBDaXZpbCBQcm9jZWR1cmUgQ29kZSdcbiAgfSxcbiAgJ1N0UE8nOiB7XG4gICAgZGU6ICdTY2h3ZWl6ZXJpc2NoZSBTdHJhZnByb3plc3NvcmRudW5nJyxcbiAgICBmcjogJ0NvZGUgZGUgcHJvY1x1MDBFOWR1cmUgcFx1MDBFOW5hbGUgc3Vpc3NlJyxcbiAgICBpdDogJ0NvZGljZSBkaSBkaXJpdHRvIHByb2Nlc3N1YWxlIHBlbmFsZSBzdml6emVybycsXG4gICAgZW46ICdTd2lzcyBDcmltaW5hbCBQcm9jZWR1cmUgQ29kZSdcbiAgfSxcbn07XG5cbi8qKlxuICogTUNQIFNlcnZlciBmb3IgU3dpc3MgTGVnYWwgQ2l0YXRpb25zXG4gKiBWZXJzaW9uOiAxLjEuMFxuICovXG5jbGFzcyBMZWdhbENpdGF0aW9uc01DUFNlcnZlciB7XG4gIHByaXZhdGUgc2VydmVyOiBTZXJ2ZXI7XG4gIHByaXZhdGUgdmFsaWRhdG9yOiBDaXRhdGlvblZhbGlkYXRvcjtcbiAgcHJpdmF0ZSBmb3JtYXR0ZXI6IENpdGF0aW9uRm9ybWF0dGVyO1xuICBwcml2YXRlIHBhcnNlcjogQ2l0YXRpb25QYXJzZXI7XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zZXJ2ZXIgPSBuZXcgU2VydmVyKFxuICAgICAge1xuICAgICAgICBuYW1lOiAnbGVnYWwtY2l0YXRpb25zJyxcbiAgICAgICAgdmVyc2lvbjogJzEuMS4wJ1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICAgICAgdG9vbHM6IHt9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuXG4gICAgdGhpcy52YWxpZGF0b3IgPSBuZXcgQ2l0YXRpb25WYWxpZGF0b3IoKTtcbiAgICB0aGlzLmZvcm1hdHRlciA9IG5ldyBDaXRhdGlvbkZvcm1hdHRlcigpO1xuICAgIHRoaXMucGFyc2VyID0gbmV3IENpdGF0aW9uUGFyc2VyKCk7XG5cbiAgICB0aGlzLnNldHVwVG9vbEhhbmRsZXJzKCk7XG4gICAgdGhpcy5zZXR1cEVycm9ySGFuZGxpbmcoKTtcbiAgfVxuXG4gIHByaXZhdGUgc2V0dXBFcnJvckhhbmRsaW5nKCk6IHZvaWQge1xuICAgIHRoaXMuc2VydmVyLm9uZXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1tNQ1AgRXJyb3JdJywgZXJyb3IpO1xuICAgIH07XG5cbiAgICBwcm9jZXNzLm9uKCdTSUdJTlQnLCBhc3luYyAoKSA9PiB7XG4gICAgICBhd2FpdCB0aGlzLnNlcnZlci5jbG9zZSgpO1xuICAgICAgcHJvY2Vzcy5leGl0KDApO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cFRvb2xIYW5kbGVycygpOiB2b2lkIHtcbiAgICAvLyBMaXN0IGF2YWlsYWJsZSB0b29sc1xuICAgIHRoaXMuc2VydmVyLnNldFJlcXVlc3RIYW5kbGVyKExpc3RUb29sc1JlcXVlc3RTY2hlbWEsIGFzeW5jICgpID0+ICh7XG4gICAgICB0b29sczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3ZhbGlkYXRlX2NpdGF0aW9uJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1ZhbGlkYXRlIGEgU3dpc3MgbGVnYWwgY2l0YXRpb24gKEJHRS9BVEYvRFRGIG9yIHN0YXR1dG9yeSkuIFJldHVybnMgdmFsaWRhdGlvbiByZXN1bHQgd2l0aCBub3JtYWxpemVkIGNpdGF0aW9uIGFuZCBlcnJvciBtZXNzYWdlcyBpZiBpbnZhbGlkLicsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBjaXRhdGlvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGxlZ2FsIGNpdGF0aW9uIHRvIHZhbGlkYXRlIChlLmcuLCBcIkJHRSAxNDcgSVYgNzNcIiwgXCJBcnQuIDk3IE9SXCIpJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFsnY2l0YXRpb24nXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdmb3JtYXRfY2l0YXRpb24nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRm9ybWF0IGEgU3dpc3MgbGVnYWwgY2l0YXRpb24gdG8gYSBzcGVjaWZpYyBsYW5ndWFnZSAoREUvRlIvSVQvRU4pLiBDb252ZXJ0cyBjaXRhdGlvbiBjb21wb25lbnRzIHdoaWxlIHByZXNlcnZpbmcgbGVnYWwgbWVhbmluZy4nLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgY2l0YXRpb246IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBsZWdhbCBjaXRhdGlvbiB0byBmb3JtYXQnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHRhcmdldExhbmd1YWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgZW51bTogWydkZScsICdmcicsICdpdCcsICdlbiddLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGFyZ2V0IGxhbmd1YWdlIGZvciBmb3JtYXR0aW5nIChkZT1HZXJtYW4sIGZyPUZyZW5jaCwgaXQ9SXRhbGlhbiwgZW49RW5nbGlzaCknXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGZ1bGxTdGF0dXRlTmFtZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0luY2x1ZGUgZnVsbCBzdGF0dXRlIG5hbWUgaW4gcGFyZW50aGVzZXMgKG9wdGlvbmFsLCBkZWZhdWx0OiBmYWxzZSknLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogWydjaXRhdGlvbicsICd0YXJnZXRMYW5ndWFnZSddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ2NvbnZlcnRfY2l0YXRpb24nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQ29udmVydCBhIGNpdGF0aW9uIGZyb20gb25lIGxhbmd1YWdlIHRvIGFub3RoZXIuIEF1dG8tZGV0ZWN0cyBzb3VyY2UgbGFuZ3VhZ2UgYW5kIGNvbnZlcnRzIHRvIHRhcmdldCBsYW5ndWFnZS4nLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgY2l0YXRpb246IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBsZWdhbCBjaXRhdGlvbiB0byBjb252ZXJ0J1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0YXJnZXRMYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGVudW06IFsnZGUnLCAnZnInLCAnaXQnLCAnZW4nXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RhcmdldCBsYW5ndWFnZSAoZGU9R2VybWFuLCBmcj1GcmVuY2gsIGl0PUl0YWxpYW4sIGVuPUVuZ2xpc2gpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBmdWxsU3RhdHV0ZU5hbWU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdJbmNsdWRlIGZ1bGwgc3RhdHV0ZSBuYW1lIChvcHRpb25hbCwgZGVmYXVsdDogZmFsc2UpJyxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFsnY2l0YXRpb24nLCAndGFyZ2V0TGFuZ3VhZ2UnXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdwYXJzZV9jaXRhdGlvbicsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdQYXJzZSBhIFN3aXNzIGxlZ2FsIGNpdGF0aW9uIGFuZCBleHRyYWN0IGFsbCBjb21wb25lbnRzLiBSZXR1cm5zIGNpdGF0aW9uIHR5cGUsIGxhbmd1YWdlLCBjb21wb25lbnRzLCBhbmQgdmFsaWRpdHkgc3RhdHVzLicsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBjaXRhdGlvbjoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGxlZ2FsIGNpdGF0aW9uIHRvIHBhcnNlJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFsnY2l0YXRpb24nXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdnZXRfcHJvdmlzaW9uX3RleHQnLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUmV0cmlldmUgdGhlIG9mZmljaWFsIHRleHQgb2YgYSBTd2lzcyBzdGF0dXRvcnkgcHJvdmlzaW9uIGZyb20gRmVkbGV4LiBSZXR1cm5zIHRoZSBwcm92aXNpb24gdGV4dCBpbiB0aGUgcmVxdWVzdGVkIGxhbmd1YWdlIHdpdGggbWV0YWRhdGEuJyxcbiAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHN0YXR1dGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1N0YXR1dGUgYWJicmV2aWF0aW9uIChlLmcuLCBcIk9SXCIsIFwiWkdCXCIsIFwiU3RHQlwiLCBcIkJWXCIsIFwiQkdHXCIpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhcnRpY2xlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdBcnRpY2xlIG51bWJlcidcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdQYXJhZ3JhcGgvQWJzYXR6IG51bWJlciAob3B0aW9uYWwpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsZXR0ZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0xldHRlci9CdWNoc3RhYmUgKG9wdGlvbmFsLCBlLmcuLCBcImFcIiwgXCJiXCIpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGVudW06IFsnZGUnLCAnZnInLCAnaXQnXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0xhbmd1YWdlIGZvciB0aGUgcHJvdmlzaW9uIHRleHQgKGRlZmF1bHQ6IGRlKSdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYXNPZkRhdGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1BvaW50LWluLXRpbWUgdmVyc2lvbiAoSVNPIGRhdGUgZm9ybWF0LCBvcHRpb25hbCknXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogWydzdGF0dXRlJywgJ2FydGljbGUnXVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6ICdleHRyYWN0X2NpdGF0aW9ucycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdFeHRyYWN0IGFsbCBsZWdhbCBjaXRhdGlvbnMgZnJvbSBhIGRvY3VtZW50IG9yIHRleHQuIElkZW50aWZpZXMgQkdFL0FURi9EVEYgY2FzZSBjaXRhdGlvbnMgYW5kIHN0YXR1dG9yeSByZWZlcmVuY2VzLicsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICB0ZXh0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdUaGUgZG9jdW1lbnQgdGV4dCB0byBhbmFseXplIGZvciBjaXRhdGlvbnMnXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluY2x1ZGVUeXBlczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgZW51bTogWydiZ2UnLCAnYXRmJywgJ2R0ZicsICdzdGF0dXRlJywgJ2NhbnRvbmFsJywgJ2FsbCddXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1R5cGVzIG9mIGNpdGF0aW9ucyB0byBleHRyYWN0IChkZWZhdWx0OiBhbGwpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWxpZGF0ZUNpdGF0aW9uczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1doZXRoZXIgdG8gdmFsaWRhdGUgZWFjaCBleHRyYWN0ZWQgY2l0YXRpb24gKGRlZmF1bHQ6IHRydWUpJ1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFsndGV4dCddXG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogJ3N0YW5kYXJkaXplX2RvY3VtZW50X2NpdGF0aW9ucycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdTdGFuZGFyZGl6ZSBhbGwgbGVnYWwgY2l0YXRpb25zIGluIGEgZG9jdW1lbnQgdG8gYSBjb25zaXN0ZW50IGZvcm1hdCBhbmQgbGFuZ3VhZ2UuIFJldHVybnMgdGhlIGRvY3VtZW50IHdpdGggbm9ybWFsaXplZCBjaXRhdGlvbnMuJyxcbiAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHRleHQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBkb2N1bWVudCB0ZXh0IGNvbnRhaW5pbmcgY2l0YXRpb25zIHRvIHN0YW5kYXJkaXplJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB0YXJnZXRMYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICAgIGVudW06IFsnZGUnLCAnZnInLCAnaXQnLCAnZW4nXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RhcmdldCBsYW5ndWFnZSBmb3Igc3RhbmRhcmRpemVkIGNpdGF0aW9ucydcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgZW51bTogWydzaG9ydCcsICdsb25nJywgJ2FjYWRlbWljJ10sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdDaXRhdGlvbiBmb3JtYXQgc3R5bGUgKGRlZmF1bHQ6IHNob3J0KSdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgaW5jbHVkZUZ1bGxOYW1lczoge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0luY2x1ZGUgZnVsbCBzdGF0dXRlIG5hbWVzIChkZWZhdWx0OiBmYWxzZSknXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogWyd0ZXh0JywgJ3RhcmdldExhbmd1YWdlJ11cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiAnY29tcGFyZV9jaXRhdGlvbl92ZXJzaW9ucycsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdDb21wYXJlIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBhIHN0YXR1dG9yeSBwcm92aXNpb24gb3ZlciB0aW1lLiBTaG93cyBjaGFuZ2VzIGJldHdlZW4gdmVyc2lvbnMgd2l0aCBlZmZlY3RpdmUgZGF0ZXMuJyxcbiAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHN0YXR1dGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1N0YXR1dGUgYWJicmV2aWF0aW9uIChlLmcuLCBcIk9SXCIsIFwiWkdCXCIpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhcnRpY2xlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdBcnRpY2xlIG51bWJlcidcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdQYXJhZ3JhcGggbnVtYmVyIChvcHRpb25hbCknXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRhdGVGcm9tOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdTdGFydCBkYXRlIGZvciB2ZXJzaW9uIGNvbXBhcmlzb24gKElTTyBmb3JtYXQpJ1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkYXRlVG86IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0VuZCBkYXRlIGZvciB2ZXJzaW9uIGNvbXBhcmlzb24gKElTTyBmb3JtYXQsIGRlZmF1bHQ6IHRvZGF5KSdcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgICBlbnVtOiBbJ2RlJywgJ2ZyJywgJ2l0J10sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdMYW5ndWFnZSBmb3IgcHJvdmlzaW9uIHRleHQgKGRlZmF1bHQ6IGRlKSdcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbJ3N0YXR1dGUnLCAnYXJ0aWNsZSddXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSkpO1xuXG4gICAgLy8gSGFuZGxlIHRvb2wgY2FsbHNcbiAgICB0aGlzLnNlcnZlci5zZXRSZXF1ZXN0SGFuZGxlcihDYWxsVG9vbFJlcXVlc3RTY2hlbWEsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCB7IG5hbWUsIGFyZ3VtZW50czogYXJncyB9ID0gcmVxdWVzdC5wYXJhbXM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3ZhbGlkYXRlX2NpdGF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVZhbGlkYXRlQ2l0YXRpb24oYXJncyk7XG5cbiAgICAgICAgICBjYXNlICdmb3JtYXRfY2l0YXRpb24nOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlRm9ybWF0Q2l0YXRpb24oYXJncyk7XG5cbiAgICAgICAgICBjYXNlICdjb252ZXJ0X2NpdGF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZUNvbnZlcnRDaXRhdGlvbihhcmdzKTtcblxuICAgICAgICAgIGNhc2UgJ3BhcnNlX2NpdGF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZVBhcnNlQ2l0YXRpb24oYXJncyk7XG5cbiAgICAgICAgICBjYXNlICdnZXRfcHJvdmlzaW9uX3RleHQnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlR2V0UHJvdmlzaW9uVGV4dChhcmdzKTtcblxuICAgICAgICAgIGNhc2UgJ2V4dHJhY3RfY2l0YXRpb25zJzpcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLmhhbmRsZUV4dHJhY3RDaXRhdGlvbnMoYXJncyk7XG5cbiAgICAgICAgICBjYXNlICdzdGFuZGFyZGl6ZV9kb2N1bWVudF9jaXRhdGlvbnMnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlU3RhbmRhcmRpemVEb2N1bWVudENpdGF0aW9ucyhhcmdzKTtcblxuICAgICAgICAgIGNhc2UgJ2NvbXBhcmVfY2l0YXRpb25fdmVyc2lvbnMnOlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuaGFuZGxlQ29tcGFyZUNpdGF0aW9uVmVyc2lvbnMoYXJncyk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICAgICAgICBFcnJvckNvZGUuTWV0aG9kTm90Rm91bmQsXG4gICAgICAgICAgICAgIGBVbmtub3duIHRvb2w6ICR7bmFtZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBNY3BFcnJvcikge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvcic7XG4gICAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgICBFcnJvckNvZGUuSW50ZXJuYWxFcnJvcixcbiAgICAgICAgICBgRXJyb3IgZXhlY3V0aW5nIHRvb2wgJHtuYW1lfTogJHtlcnJvck1lc3NhZ2V9YFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVWYWxpZGF0ZUNpdGF0aW9uKGFyZ3M6IGFueSkge1xuICAgIGNvbnN0IHsgY2l0YXRpb24gfSA9IGFyZ3M7XG5cbiAgICBpZiAoIWNpdGF0aW9uIHx8IHR5cGVvZiBjaXRhdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsXG4gICAgICAgICdDaXRhdGlvbiBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMudmFsaWRhdG9yLnZhbGlkYXRlKGNpdGF0aW9uKTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhbGlkOiByZXN1bHQudmFsaWQsXG4gICAgICAgICAgICAgIHR5cGU6IHJlc3VsdC50eXBlLFxuICAgICAgICAgICAgICBub3JtYWxpemVkOiByZXN1bHQubm9ybWFsaXplZCxcbiAgICAgICAgICAgICAgY29tcG9uZW50czogcmVzdWx0LmNvbXBvbmVudHMsXG4gICAgICAgICAgICAgIGVycm9yczogcmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgICAgd2FybmluZ3M6IHJlc3VsdC53YXJuaW5nc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlRm9ybWF0Q2l0YXRpb24oYXJnczogYW55KSB7XG4gICAgY29uc3QgeyBjaXRhdGlvbiwgdGFyZ2V0TGFuZ3VhZ2UsIGZ1bGxTdGF0dXRlTmFtZSA9IGZhbHNlIH0gPSBhcmdzO1xuXG4gICAgaWYgKCFjaXRhdGlvbiB8fCB0eXBlb2YgY2l0YXRpb24gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoXG4gICAgICAgIEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLFxuICAgICAgICAnQ2l0YXRpb24gcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldExhbmd1YWdlIHx8ICFbJ2RlJywgJ2ZyJywgJ2l0JywgJ2VuJ10uaW5jbHVkZXModGFyZ2V0TGFuZ3VhZ2UpKSB7XG4gICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoXG4gICAgICAgIEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLFxuICAgICAgICAndGFyZ2V0TGFuZ3VhZ2UgbXVzdCBiZSBvbmUgb2Y6IGRlLCBmciwgaXQsIGVuJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBjaXRhdGlvbiBmaXJzdFxuICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VyLnBhcnNlKGNpdGF0aW9uKTtcblxuICAgIGlmICghcGFyc2VkLmlzVmFsaWQpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsXG4gICAgICAgIGBJbnZhbGlkIGNpdGF0aW9uOiAke2NpdGF0aW9ufWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IHRvIHRhcmdldCBsYW5ndWFnZVxuICAgIGNvbnN0IG9wdGlvbnM6IEZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICBsYW5ndWFnZTogdGFyZ2V0TGFuZ3VhZ2UgYXMgTGFuZ3VhZ2UsXG4gICAgICBmdWxsU3RhdHV0ZU5hbWVcbiAgICB9O1xuXG4gICAgY29uc3QgZm9ybWF0dGVkID0gdGhpcy5mb3JtYXR0ZXIuZm9ybWF0KFxuICAgICAgcGFyc2VkLnR5cGUsXG4gICAgICBwYXJzZWQuY29tcG9uZW50cyxcbiAgICAgIHRhcmdldExhbmd1YWdlIGFzIExhbmd1YWdlLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBvcmlnaW5hbDogY2l0YXRpb24sXG4gICAgICAgICAgICAgIGZvcm1hdHRlZDogZm9ybWF0dGVkLmNpdGF0aW9uLFxuICAgICAgICAgICAgICBsYW5ndWFnZTogZm9ybWF0dGVkLmxhbmd1YWdlLFxuICAgICAgICAgICAgICB0eXBlOiBmb3JtYXR0ZWQudHlwZSxcbiAgICAgICAgICAgICAgZnVsbFJlZmVyZW5jZTogZm9ybWF0dGVkLmZ1bGxSZWZlcmVuY2VcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZUNvbnZlcnRDaXRhdGlvbihhcmdzOiBhbnkpIHtcbiAgICBjb25zdCB7IGNpdGF0aW9uLCB0YXJnZXRMYW5ndWFnZSwgZnVsbFN0YXR1dGVOYW1lID0gZmFsc2UgfSA9IGFyZ3M7XG5cbiAgICBpZiAoIWNpdGF0aW9uIHx8IHR5cGVvZiBjaXRhdGlvbiAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsXG4gICAgICAgICdDaXRhdGlvbiBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBzdHJpbmcnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGFyZ2V0TGFuZ3VhZ2UgfHwgIVsnZGUnLCAnZnInLCAnaXQnLCAnZW4nXS5pbmNsdWRlcyh0YXJnZXRMYW5ndWFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsXG4gICAgICAgICd0YXJnZXRMYW5ndWFnZSBtdXN0IGJlIG9uZSBvZjogZGUsIGZyLCBpdCwgZW4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGFuZCBkZXRlY3Qgc291cmNlIGxhbmd1YWdlXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZXIucGFyc2UoY2l0YXRpb24pO1xuXG4gICAgaWYgKCFwYXJzZWQuaXNWYWxpZCkge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICBFcnJvckNvZGUuSW52YWxpZFBhcmFtcyxcbiAgICAgICAgYEludmFsaWQgY2l0YXRpb246ICR7Y2l0YXRpb259YFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYWxsIHRyYW5zbGF0aW9uc1xuICAgIGNvbnN0IGFsbFRyYW5zbGF0aW9ucyA9IHRoaXMuZm9ybWF0dGVyLmdldEFsbFRyYW5zbGF0aW9ucyhcbiAgICAgIHBhcnNlZC50eXBlLFxuICAgICAgcGFyc2VkLmNvbXBvbmVudHNcbiAgICApO1xuXG4gICAgLy8gRm9ybWF0IHRvIHRhcmdldCBsYW5ndWFnZSB3aXRoIG9wdGlvbnNcbiAgICBjb25zdCBvcHRpb25zOiBGb3JtYXRPcHRpb25zID0ge1xuICAgICAgbGFuZ3VhZ2U6IHRhcmdldExhbmd1YWdlIGFzIExhbmd1YWdlLFxuICAgICAgZnVsbFN0YXR1dGVOYW1lXG4gICAgfTtcblxuICAgIGNvbnN0IGZvcm1hdHRlZCA9IHRoaXMuZm9ybWF0dGVyLmZvcm1hdChcbiAgICAgIHBhcnNlZC50eXBlLFxuICAgICAgcGFyc2VkLmNvbXBvbmVudHMsXG4gICAgICB0YXJnZXRMYW5ndWFnZSBhcyBMYW5ndWFnZSxcbiAgICAgIG9wdGlvbnNcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IGNpdGF0aW9uLFxuICAgICAgICAgICAgICBzb3VyY2VMYW5ndWFnZTogcGFyc2VkLmxhbmd1YWdlLFxuICAgICAgICAgICAgICB0YXJnZXRMYW5ndWFnZSxcbiAgICAgICAgICAgICAgY29udmVydGVkOiBmb3JtYXR0ZWQuY2l0YXRpb24sXG4gICAgICAgICAgICAgIGZ1bGxSZWZlcmVuY2U6IGZvcm1hdHRlZC5mdWxsUmVmZXJlbmNlLFxuICAgICAgICAgICAgICBhbGxUcmFuc2xhdGlvbnNcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGhhbmRsZVBhcnNlQ2l0YXRpb24oYXJnczogYW55KSB7XG4gICAgY29uc3QgeyBjaXRhdGlvbiB9ID0gYXJncztcblxuICAgIGlmICghY2l0YXRpb24gfHwgdHlwZW9mIGNpdGF0aW9uICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICBFcnJvckNvZGUuSW52YWxpZFBhcmFtcyxcbiAgICAgICAgJ0NpdGF0aW9uIHBhcmFtZXRlciBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZXIucGFyc2UoY2l0YXRpb24pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb3JpZ2luYWw6IHBhcnNlZC5vcmlnaW5hbCxcbiAgICAgICAgICAgICAgdHlwZTogcGFyc2VkLnR5cGUsXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiBwYXJzZWQubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgIGNvbXBvbmVudHM6IHBhcnNlZC5jb21wb25lbnRzLFxuICAgICAgICAgICAgICBpc1ZhbGlkOiBwYXJzZWQuaXNWYWxpZCxcbiAgICAgICAgICAgICAgc3VnZ2VzdGlvbnM6IHBhcnNlZC5zdWdnZXN0aW9uc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHJvdmlzaW9uIHRleHQgZnJvbSBGZWRsZXhcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlR2V0UHJvdmlzaW9uVGV4dChhcmdzOiBhbnkpIHtcbiAgICBjb25zdCB7IHN0YXR1dGUsIGFydGljbGUsIHBhcmFncmFwaCwgbGV0dGVyLCBsYW5ndWFnZSA9ICdkZScsIGFzT2ZEYXRlIH0gPSBhcmdzO1xuXG4gICAgaWYgKCFzdGF0dXRlIHx8IHR5cGVvZiBzdGF0dXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICBFcnJvckNvZGUuSW52YWxpZFBhcmFtcyxcbiAgICAgICAgJ3N0YXR1dGUgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFydGljbGUgIT09ICdudW1iZXInKSB7XG4gICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoXG4gICAgICAgIEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLFxuICAgICAgICAnYXJ0aWNsZSBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQgYW5kIG11c3QgYmUgYSBudW1iZXInXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIE5vcm1hbGl6ZSBzdGF0dXRlIGFiYnJldmlhdGlvblxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGF0dXRlID0gc3RhdHV0ZS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHNyTnVtYmVyID0gU1RBVFVURV9TUl9NQVBQSU5HW25vcm1hbGl6ZWRTdGF0dXRlXSB8fCBTVEFUVVRFX1NSX01BUFBJTkdbc3RhdHV0ZV07XG5cbiAgICBpZiAoIXNyTnVtYmVyKSB7XG4gICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoXG4gICAgICAgIEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLFxuICAgICAgICBgVW5rbm93biBzdGF0dXRlIGFiYnJldmlhdGlvbjogJHtzdGF0dXRlfS4gU3VwcG9ydGVkOiAke09iamVjdC5rZXlzKFNUQVRVVEVfU1JfTUFQUElORykuam9pbignLCAnKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIEZlZGxleCBVUkwgZm9yIEFQSSBjYWxsXG4gICAgY29uc3QgbGFuZ0NvZGUgPSBsYW5ndWFnZSA9PT0gJ2RlJyA/ICdkZScgOiBsYW5ndWFnZSA9PT0gJ2ZyJyA/ICdmcicgOiAnaXQnO1xuICAgIGNvbnN0IGZlZGxleFVybCA9IGAke0ZFRExFWF9CQVNFX1VSTH0vY2MvJHtzck51bWJlcn0vJHtsYW5nQ29kZX1gO1xuXG4gICAgLy8gQnVpbGQgdGhlIGZvcm1hdHRlZCBjaXRhdGlvbiByZWZlcmVuY2VcbiAgICBjb25zdCBmb3JtYXR0ZWRDaXRhdGlvbiA9IHRoaXMuYnVpbGRQcm92aXNpb25SZWZlcmVuY2UoXG4gICAgICBub3JtYWxpemVkU3RhdHV0ZSxcbiAgICAgIGFydGljbGUsXG4gICAgICBwYXJhZ3JhcGgsXG4gICAgICBsZXR0ZXIsXG4gICAgICBsYW5ndWFnZSBhcyBMYW5ndWFnZVxuICAgICk7XG5cbiAgICAvLyBTaW11bGF0ZSBGZWRsZXggQVBJIHJlc3BvbnNlIChpbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGJlIGEgcmVhbCBIVFRQIGNhbGwpXG4gICAgLy8gRm9yIG5vdywgcmV0dXJuIHN0cnVjdHVyZWQgcHJvdmlzaW9uIGluZm9ybWF0aW9uXG4gICAgY29uc3QgcHJvdmlzaW9uVGV4dCA9IGF3YWl0IHRoaXMuZmV0Y2hQcm92aXNpb25UZXh0KFxuICAgICAgc3JOdW1iZXIsXG4gICAgICBhcnRpY2xlLFxuICAgICAgcGFyYWdyYXBoLFxuICAgICAgbGV0dGVyLFxuICAgICAgbGFuZ0NvZGUsXG4gICAgICBhc09mRGF0ZVxuICAgICk7XG5cbiAgICBjb25zdCBmdWxsU3RhdHV0ZU5hbWUgPSBTVEFUVVRFX0ZVTExfTkFNRVNbbm9ybWFsaXplZFN0YXR1dGVdPy5bbGFuZ3VhZ2UgYXMgTGFuZ3VhZ2VdIHx8XG4gICAgICBTVEFUVVRFX0ZVTExfTkFNRVNbT2JqZWN0LmtleXMoU1RBVFVURV9TUl9NQVBQSU5HKS5maW5kKGsgPT4gU1RBVFVURV9TUl9NQVBQSU5HW2tdID09PSBzck51bWJlcikgfHwgJyddPy5bbGFuZ3VhZ2UgYXMgTGFuZ3VhZ2VdIHx8XG4gICAgICBub3JtYWxpemVkU3RhdHV0ZTtcblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIHByb3Zpc2lvbjoge1xuICAgICAgICAgICAgICAgIHN0YXR1dGU6IG5vcm1hbGl6ZWRTdGF0dXRlLFxuICAgICAgICAgICAgICAgIHNyTnVtYmVyLFxuICAgICAgICAgICAgICAgIGFydGljbGUsXG4gICAgICAgICAgICAgICAgcGFyYWdyYXBoLFxuICAgICAgICAgICAgICAgIGxldHRlcixcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRDaXRhdGlvbixcbiAgICAgICAgICAgICAgICBmdWxsU3RhdHV0ZU5hbWVcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgdGV4dDogcHJvdmlzaW9uVGV4dC50ZXh0LFxuICAgICAgICAgICAgICBlZmZlY3RpdmVEYXRlOiBwcm92aXNpb25UZXh0LmVmZmVjdGl2ZURhdGUsXG4gICAgICAgICAgICAgIGxhbmd1YWdlLFxuICAgICAgICAgICAgICBmZWRsZXhVcmwsXG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBwcm92aXNpb25UZXh0Lmxhc3RNb2RpZmllZCxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBwcm92aXNpb25UZXh0LnZlcnNpb25cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZCBhIGZvcm1hdHRlZCBwcm92aXNpb24gcmVmZXJlbmNlXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkUHJvdmlzaW9uUmVmZXJlbmNlKFxuICAgIHN0YXR1dGU6IHN0cmluZyxcbiAgICBhcnRpY2xlOiBudW1iZXIsXG4gICAgcGFyYWdyYXBoPzogbnVtYmVyLFxuICAgIGxldHRlcj86IHN0cmluZyxcbiAgICBsYW5ndWFnZTogTGFuZ3VhZ2UgPSAnZGUnXG4gICk6IHN0cmluZyB7XG4gICAgY29uc3QgbGFiZWxzID0ge1xuICAgICAgZGU6IHsgYXJ0OiAnQXJ0LicsIGFiczogJ0Ficy4nLCBsaXQ6ICdsaXQuJyB9LFxuICAgICAgZnI6IHsgYXJ0OiAnYXJ0LicsIGFiczogJ2FsLicsIGxpdDogJ2xldC4nIH0sXG4gICAgICBpdDogeyBhcnQ6ICdhcnQuJywgYWJzOiAnY3B2LicsIGxpdDogJ2xldHQuJyB9LFxuICAgICAgZW46IHsgYXJ0OiAnQXJ0LicsIGFiczogJ3BhcmEuJywgbGl0OiAnbGl0LicgfVxuICAgIH07XG5cbiAgICBjb25zdCBsID0gbGFiZWxzW2xhbmd1YWdlXTtcbiAgICBsZXQgcmVmID0gYCR7bC5hcnR9ICR7YXJ0aWNsZX1gO1xuXG4gICAgaWYgKHBhcmFncmFwaCkge1xuICAgICAgcmVmICs9IGAgJHtsLmFic30gJHtwYXJhZ3JhcGh9YDtcbiAgICB9XG5cbiAgICBpZiAobGV0dGVyKSB7XG4gICAgICByZWYgKz0gYCAke2wubGl0fSAke2xldHRlcn1gO1xuICAgIH1cblxuICAgIHJlZiArPSBgICR7c3RhdHV0ZX1gO1xuXG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwcm92aXNpb24gdGV4dCAoc2ltdWxhdGVkIC0gaW4gcHJvZHVjdGlvbiB3b3VsZCBjYWxsIEZlZGxleCBBUEkpXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGZldGNoUHJvdmlzaW9uVGV4dChcbiAgICBzck51bWJlcjogc3RyaW5nLFxuICAgIGFydGljbGU6IG51bWJlcixcbiAgICBwYXJhZ3JhcGg/OiBudW1iZXIsXG4gICAgbGV0dGVyPzogc3RyaW5nLFxuICAgIGxhbmd1YWdlOiBzdHJpbmcgPSAnZGUnLFxuICAgIGFzT2ZEYXRlPzogc3RyaW5nXG4gICk6IFByb21pc2U8eyB0ZXh0OiBzdHJpbmc7IGVmZmVjdGl2ZURhdGU6IHN0cmluZzsgbGFzdE1vZGlmaWVkOiBzdHJpbmc7IHZlcnNpb246IHN0cmluZyB9PiB7XG4gICAgLy8gSW4gcHJvZHVjdGlvbiwgdGhpcyB3b3VsZCBtYWtlIGFuIEhUVFAgcmVxdWVzdCB0byBGZWRsZXggQVBJXG4gICAgLy8gRm9yIG5vdywgcmV0dXJuIGEgcGxhY2Vob2xkZXIgaW5kaWNhdGluZyB0aGUgcHJvdmlzaW9uIGxvY2F0aW9uXG5cbiAgICBjb25zdCBlZmZlY3RpdmVEYXRlID0gYXNPZkRhdGUgfHwgbmV3IERhdGUoKS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF07XG5cbiAgICAvLyBSZXR1cm4gc3RydWN0dXJlZCByZXNwb25zZSBpbmRpY2F0aW5nIHRoaXMgd291bGQgbmVlZCByZWFsIEFQSSBpbnRlZ3JhdGlvblxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0OiBgW1Byb3Zpc2lvbiB0ZXh0IHdvdWxkIGJlIGZldGNoZWQgZnJvbSBGZWRsZXggQVBJOiBTUiAke3NyTnVtYmVyfSwgQXJ0LiAke2FydGljbGV9JHtwYXJhZ3JhcGggPyBgIEFicy4gJHtwYXJhZ3JhcGh9YCA6ICcnfSR7bGV0dGVyID8gYCBsaXQuICR7bGV0dGVyfWAgOiAnJ31dYCxcbiAgICAgIGVmZmVjdGl2ZURhdGUsXG4gICAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcbiAgICAgIHZlcnNpb246ICdjdXJyZW50J1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCBhbGwgbGVnYWwgY2l0YXRpb25zIGZyb20gZG9jdW1lbnQgdGV4dFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVFeHRyYWN0Q2l0YXRpb25zKGFyZ3M6IGFueSkge1xuICAgIGNvbnN0IHsgdGV4dCwgaW5jbHVkZVR5cGVzID0gWydhbGwnXSwgdmFsaWRhdGVDaXRhdGlvbnMgPSB0cnVlIH0gPSBhcmdzO1xuXG4gICAgaWYgKCF0ZXh0IHx8IHR5cGVvZiB0ZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICBFcnJvckNvZGUuSW52YWxpZFBhcmFtcyxcbiAgICAgICAgJ3RleHQgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBleHRyYWN0ZWRDaXRhdGlvbnM6IEFycmF5PHtcbiAgICAgIGNpdGF0aW9uOiBzdHJpbmc7XG4gICAgICB0eXBlOiBDaXRhdGlvblR5cGU7XG4gICAgICBwb3NpdGlvbjogeyBzdGFydDogbnVtYmVyOyBlbmQ6IG51bWJlciB9O1xuICAgICAgcGFyc2VkPzogUGFyc2VkQ2l0YXRpb247XG4gICAgICB2YWxpZD86IGJvb2xlYW47XG4gICAgfT4gPSBbXTtcblxuICAgIC8vIERlZmluZSBjaXRhdGlvbiBwYXR0ZXJuc1xuICAgIGNvbnN0IHBhdHRlcm5zOiBBcnJheTx7IHJlZ2V4OiBSZWdFeHA7IHR5cGU6IENpdGF0aW9uVHlwZSB9PiA9IFtcbiAgICAgIC8vIEJHRS9BVEYvRFRGIHBhdHRlcm5zXG4gICAgICB7IHJlZ2V4OiAvQkdFXFxzK1xcZHsxLDN9XFxzK1tJVl0rXFxzK1xcZCsvZ2ksIHR5cGU6ICdiZ2UnIH0sXG4gICAgICB7IHJlZ2V4OiAvQVRGXFxzK1xcZHsxLDN9XFxzK1tJVl0rXFxzK1xcZCsvZ2ksIHR5cGU6ICdhdGYnIH0sXG4gICAgICB7IHJlZ2V4OiAvRFRGXFxzK1xcZHsxLDN9XFxzK1tJVl0rXFxzK1xcZCsvZ2ksIHR5cGU6ICdkdGYnIH0sXG5cbiAgICAgIC8vIFN0YXR1dGUgcGF0dGVybnMgKEdlcm1hbilcbiAgICAgIHsgcmVnZXg6IC9BcnRcXC5cXHMqXFxkK1thLXpdP1xccyooQWJzXFwuXFxzKlxcZCspP1xccyoobGl0XFwuXFxzKlthLXpdKT9cXHMqKFppZmZcXC5cXHMqXFxkKyk/XFxzKihaR0J8T1J8U3RHQnxCVnxCR0d8WlBPfFN0UE98U2NoS0d8VndWR3xBVklHfEFIVkd8SVZHfEJWR3xVVkd8S1ZHfERTR3xJUFJHfE1XU3RHfERCRykvZ2ksIHR5cGU6ICdzdGF0dXRlJyB9LFxuXG4gICAgICAvLyBTdGF0dXRlIHBhdHRlcm5zIChGcmVuY2gpXG4gICAgICB7IHJlZ2V4OiAvYXJ0XFwuXFxzKlxcZCtbYS16XT9cXHMqKGFsXFwuXFxzKlxcZCspP1xccyoobGV0XFwuXFxzKlthLXpdKT9cXHMqKGNoXFwuXFxzKlxcZCspP1xccyooQ0N8Q098Q1B8Q3N0fExURnxDUEN8Q1BQfExQfFBBfExBQ0l8TEFWU3xMQUl8TFBQfExBQXxMQU1hbHxMUER8TERJUHxMVFZBfExJRkQpL2dpLCB0eXBlOiAnc3RhdHV0ZScgfSxcblxuICAgICAgLy8gU3RhdHV0ZSBwYXR0ZXJucyAoSXRhbGlhbilcbiAgICAgIHsgcmVnZXg6IC9hcnRcXC5cXHMqXFxkK1thLXpdP1xccyooY3B2XFwuXFxzKlxcZCspP1xccyoobGV0dFxcLlxccypbYS16XSk/XFxzKihuXFwuXFxzKlxcZCspP1xccyooQ0NTfENPfENQU3xDb3N0KS9naSwgdHlwZTogJ3N0YXR1dGUnIH0sXG5cbiAgICAgIC8vIENhbnRvbmFsIGNvdXJ0IHBhdHRlcm5zXG4gICAgICB7IHJlZ2V4OiAvW0EtWl17Miw0fVstX11cXGR7NH1bLV9dXFxkKy9nLCB0eXBlOiAnY2FudG9uYWwnIH1cbiAgICBdO1xuXG4gICAgLy8gRmlsdGVyIHBhdHRlcm5zIGJhc2VkIG9uIGluY2x1ZGVUeXBlc1xuICAgIGNvbnN0IHNob3VsZEluY2x1ZGVBbGwgPSBpbmNsdWRlVHlwZXMuaW5jbHVkZXMoJ2FsbCcpO1xuICAgIGNvbnN0IGZpbHRlcmVkUGF0dGVybnMgPSBwYXR0ZXJucy5maWx0ZXIocCA9PlxuICAgICAgc2hvdWxkSW5jbHVkZUFsbCB8fCBpbmNsdWRlVHlwZXMuaW5jbHVkZXMocC50eXBlKVxuICAgICk7XG5cbiAgICAvLyBFeHRyYWN0IGNpdGF0aW9uc1xuICAgIGZvciAoY29uc3QgeyByZWdleCwgdHlwZSB9IG9mIGZpbHRlcmVkUGF0dGVybnMpIHtcbiAgICAgIGxldCBtYXRjaDtcbiAgICAgIGNvbnN0IHJlZ2V4Q29weSA9IG5ldyBSZWdFeHAocmVnZXguc291cmNlLCByZWdleC5mbGFncyk7XG5cbiAgICAgIHdoaWxlICgobWF0Y2ggPSByZWdleENvcHkuZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY2l0YXRpb24gPSBtYXRjaFswXS50cmltKCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0geyBzdGFydDogbWF0Y2guaW5kZXgsIGVuZDogbWF0Y2guaW5kZXggKyBjaXRhdGlvbi5sZW5ndGggfTtcblxuICAgICAgICAvLyBDaGVjayBmb3IgZHVwbGljYXRlc1xuICAgICAgICBjb25zdCBpc0R1cGxpY2F0ZSA9IGV4dHJhY3RlZENpdGF0aW9ucy5zb21lKFxuICAgICAgICAgIGVjID0+IGVjLmNpdGF0aW9uID09PSBjaXRhdGlvbiAmJiBlYy5wb3NpdGlvbi5zdGFydCA9PT0gcG9zaXRpb24uc3RhcnRcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIWlzRHVwbGljYXRlKSB7XG4gICAgICAgICAgY29uc3QgZW50cnk6IHR5cGVvZiBleHRyYWN0ZWRDaXRhdGlvbnNbMF0gPSB7XG4gICAgICAgICAgICBjaXRhdGlvbixcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBwb3NpdGlvblxuICAgICAgICAgIH07XG5cbiAgICAgICAgICAvLyBWYWxpZGF0ZSBpZiByZXF1ZXN0ZWRcbiAgICAgICAgICBpZiAodmFsaWRhdGVDaXRhdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMucGFyc2VyLnBhcnNlKGNpdGF0aW9uKTtcbiAgICAgICAgICAgIGVudHJ5LnBhcnNlZCA9IHBhcnNlZDtcbiAgICAgICAgICAgIGVudHJ5LnZhbGlkID0gcGFyc2VkLmlzVmFsaWQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXh0cmFjdGVkQ2l0YXRpb25zLnB1c2goZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCBieSBwb3NpdGlvblxuICAgIGV4dHJhY3RlZENpdGF0aW9ucy5zb3J0KChhLCBiKSA9PiBhLnBvc2l0aW9uLnN0YXJ0IC0gYi5wb3NpdGlvbi5zdGFydCk7XG5cbiAgICAvLyBHZW5lcmF0ZSBzdGF0aXN0aWNzXG4gICAgY29uc3Qgc3RhdGlzdGljcyA9IHtcbiAgICAgIHRvdGFsOiBleHRyYWN0ZWRDaXRhdGlvbnMubGVuZ3RoLFxuICAgICAgYnlUeXBlOiB7fSBhcyBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+LFxuICAgICAgdmFsaWRDb3VudDogZXh0cmFjdGVkQ2l0YXRpb25zLmZpbHRlcihjID0+IGMudmFsaWQgIT09IGZhbHNlKS5sZW5ndGgsXG4gICAgICBpbnZhbGlkQ291bnQ6IGV4dHJhY3RlZENpdGF0aW9ucy5maWx0ZXIoYyA9PiBjLnZhbGlkID09PSBmYWxzZSkubGVuZ3RoXG4gICAgfTtcblxuICAgIGZvciAoY29uc3QgY2l0YXRpb24gb2YgZXh0cmFjdGVkQ2l0YXRpb25zKSB7XG4gICAgICBzdGF0aXN0aWNzLmJ5VHlwZVtjaXRhdGlvbi50eXBlXSA9IChzdGF0aXN0aWNzLmJ5VHlwZVtjaXRhdGlvbi50eXBlXSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgY2l0YXRpb25zOiBleHRyYWN0ZWRDaXRhdGlvbnMsXG4gICAgICAgICAgICAgIHN0YXRpc3RpY3MsXG4gICAgICAgICAgICAgIHRleHRMZW5ndGg6IHRleHQubGVuZ3RoXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgIDJcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgIF1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YW5kYXJkaXplIGFsbCBjaXRhdGlvbnMgaW4gYSBkb2N1bWVudCB0byBjb25zaXN0ZW50IGZvcm1hdFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVTdGFuZGFyZGl6ZURvY3VtZW50Q2l0YXRpb25zKGFyZ3M6IGFueSkge1xuICAgIGNvbnN0IHsgdGV4dCwgdGFyZ2V0TGFuZ3VhZ2UsIGZvcm1hdCA9ICdzaG9ydCcsIGluY2x1ZGVGdWxsTmFtZXMgPSBmYWxzZSB9ID0gYXJncztcblxuICAgIGlmICghdGV4dCB8fCB0eXBlb2YgdGV4dCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsXG4gICAgICAgICd0ZXh0IHBhcmFtZXRlciBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCF0YXJnZXRMYW5ndWFnZSB8fCAhWydkZScsICdmcicsICdpdCcsICdlbiddLmluY2x1ZGVzKHRhcmdldExhbmd1YWdlKSkge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICBFcnJvckNvZGUuSW52YWxpZFBhcmFtcyxcbiAgICAgICAgJ3RhcmdldExhbmd1YWdlIG11c3QgYmUgb25lIG9mOiBkZSwgZnIsIGl0LCBlbidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QgZXh0cmFjdCBhbGwgY2l0YXRpb25zXG4gICAgY29uc3QgZXh0cmFjdFJlc3VsdCA9IGF3YWl0IHRoaXMuaGFuZGxlRXh0cmFjdENpdGF0aW9ucyh7XG4gICAgICB0ZXh0LFxuICAgICAgaW5jbHVkZVR5cGVzOiBbJ2FsbCddLFxuICAgICAgdmFsaWRhdGVDaXRhdGlvbnM6IHRydWVcbiAgICB9KTtcblxuICAgIGNvbnN0IGV4dHJhY3RlZERhdGEgPSBKU09OLnBhcnNlKGV4dHJhY3RSZXN1bHQuY29udGVudFswXS50ZXh0KTtcbiAgICBjb25zdCBjaXRhdGlvbnMgPSBleHRyYWN0ZWREYXRhLmNpdGF0aW9ucztcblxuICAgIC8vIEJ1aWxkIHJlcGxhY2VtZW50IG1hcFxuICAgIGNvbnN0IHJlcGxhY2VtZW50czogQXJyYXk8e1xuICAgICAgb3JpZ2luYWw6IHN0cmluZztcbiAgICAgIHN0YW5kYXJkaXplZDogc3RyaW5nO1xuICAgICAgcG9zaXRpb246IHsgc3RhcnQ6IG51bWJlcjsgZW5kOiBudW1iZXIgfTtcbiAgICB9PiA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBjaXRhdGlvbkVudHJ5IG9mIGNpdGF0aW9ucykge1xuICAgICAgaWYgKCFjaXRhdGlvbkVudHJ5LnZhbGlkIHx8ICFjaXRhdGlvbkVudHJ5LnBhcnNlZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgcGFyc2VkID0gY2l0YXRpb25FbnRyeS5wYXJzZWQ7XG5cbiAgICAgIC8vIEZvcm1hdCB0byB0YXJnZXQgbGFuZ3VhZ2VcbiAgICAgIGNvbnN0IG9wdGlvbnM6IEZvcm1hdE9wdGlvbnMgPSB7XG4gICAgICAgIGxhbmd1YWdlOiB0YXJnZXRMYW5ndWFnZSBhcyBMYW5ndWFnZSxcbiAgICAgICAgZnVsbFN0YXR1dGVOYW1lOiBpbmNsdWRlRnVsbE5hbWVzXG4gICAgICB9O1xuXG4gICAgICBjb25zdCBmb3JtYXR0ZWQgPSB0aGlzLmZvcm1hdHRlci5mb3JtYXQoXG4gICAgICAgIHBhcnNlZC50eXBlLFxuICAgICAgICBwYXJzZWQuY29tcG9uZW50cyxcbiAgICAgICAgdGFyZ2V0TGFuZ3VhZ2UgYXMgTGFuZ3VhZ2UsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgICk7XG5cbiAgICAgIGxldCBzdGFuZGFyZGl6ZWQgPSBmb3JtYXR0ZWQuY2l0YXRpb247XG5cbiAgICAgIC8vIEFwcGx5IGZvcm1hdCBzdHlsZVxuICAgICAgaWYgKGZvcm1hdCA9PT0gJ2xvbmcnICYmIGZvcm1hdHRlZC5mdWxsUmVmZXJlbmNlKSB7XG4gICAgICAgIHN0YW5kYXJkaXplZCA9IGZvcm1hdHRlZC5mdWxsUmVmZXJlbmNlO1xuICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdhY2FkZW1pYycpIHtcbiAgICAgICAgLy8gQWNhZGVtaWMgZm9ybWF0OiBpbmNsdWRlIGJvdGggYWJicmV2aWF0aW9uIGFuZCBmdWxsIG5hbWVcbiAgICAgICAgaWYgKGZvcm1hdHRlZC5mdWxsUmVmZXJlbmNlICYmIGZvcm1hdHRlZC5jaXRhdGlvbiAhPT0gZm9ybWF0dGVkLmZ1bGxSZWZlcmVuY2UpIHtcbiAgICAgICAgICBzdGFuZGFyZGl6ZWQgPSBgJHtmb3JtYXR0ZWQuY2l0YXRpb259ICgke2Zvcm1hdHRlZC5mdWxsUmVmZXJlbmNlfSlgO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGFuZGFyZGl6ZWQgIT09IGNpdGF0aW9uRW50cnkuY2l0YXRpb24pIHtcbiAgICAgICAgcmVwbGFjZW1lbnRzLnB1c2goe1xuICAgICAgICAgIG9yaWdpbmFsOiBjaXRhdGlvbkVudHJ5LmNpdGF0aW9uLFxuICAgICAgICAgIHN0YW5kYXJkaXplZCxcbiAgICAgICAgICBwb3NpdGlvbjogY2l0YXRpb25FbnRyeS5wb3NpdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBcHBseSByZXBsYWNlbWVudHMgZnJvbSBlbmQgdG8gc3RhcnQgdG8gcHJlc2VydmUgcG9zaXRpb25zXG4gICAgbGV0IHN0YW5kYXJkaXplZFRleHQgPSB0ZXh0O1xuICAgIGNvbnN0IHNvcnRlZFJlcGxhY2VtZW50cyA9IFsuLi5yZXBsYWNlbWVudHNdLnNvcnQoXG4gICAgICAoYSwgYikgPT4gYi5wb3NpdGlvbi5zdGFydCAtIGEucG9zaXRpb24uc3RhcnRcbiAgICApO1xuXG4gICAgZm9yIChjb25zdCByZXBsYWNlbWVudCBvZiBzb3J0ZWRSZXBsYWNlbWVudHMpIHtcbiAgICAgIHN0YW5kYXJkaXplZFRleHQgPVxuICAgICAgICBzdGFuZGFyZGl6ZWRUZXh0LnN1YnN0cmluZygwLCByZXBsYWNlbWVudC5wb3NpdGlvbi5zdGFydCkgK1xuICAgICAgICByZXBsYWNlbWVudC5zdGFuZGFyZGl6ZWQgK1xuICAgICAgICBzdGFuZGFyZGl6ZWRUZXh0LnN1YnN0cmluZyhyZXBsYWNlbWVudC5wb3NpdGlvbi5lbmQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb250ZW50OiBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgIG9yaWdpbmFsVGV4dDogdGV4dCxcbiAgICAgICAgICAgICAgc3RhbmRhcmRpemVkVGV4dCxcbiAgICAgICAgICAgICAgdGFyZ2V0TGFuZ3VhZ2UsXG4gICAgICAgICAgICAgIGZvcm1hdCxcbiAgICAgICAgICAgICAgcmVwbGFjZW1lbnRzLFxuICAgICAgICAgICAgICBzdGF0aXN0aWNzOiB7XG4gICAgICAgICAgICAgICAgdG90YWxDaXRhdGlvbnM6IGNpdGF0aW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgc3RhbmRhcmRpemVkOiByZXBsYWNlbWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIHVuY2hhbmdlZDogY2l0YXRpb25zLmxlbmd0aCAtIHJlcGxhY2VtZW50cy5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAyXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wYXJlIHByb3Zpc2lvbiB2ZXJzaW9ucyBvdmVyIHRpbWVcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgaGFuZGxlQ29tcGFyZUNpdGF0aW9uVmVyc2lvbnMoYXJnczogYW55KSB7XG4gICAgY29uc3QgeyBzdGF0dXRlLCBhcnRpY2xlLCBwYXJhZ3JhcGgsIGRhdGVGcm9tLCBkYXRlVG8sIGxhbmd1YWdlID0gJ2RlJyB9ID0gYXJncztcblxuICAgIGlmICghc3RhdHV0ZSB8fCB0eXBlb2Ygc3RhdHV0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBNY3BFcnJvcihcbiAgICAgICAgRXJyb3JDb2RlLkludmFsaWRQYXJhbXMsXG4gICAgICAgICdzdGF0dXRlIHBhcmFtZXRlciBpcyByZXF1aXJlZCBhbmQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBhcnRpY2xlICE9PSAnbnVtYmVyJykge1xuICAgICAgdGhyb3cgbmV3IE1jcEVycm9yKFxuICAgICAgICBFcnJvckNvZGUuSW52YWxpZFBhcmFtcyxcbiAgICAgICAgJ2FydGljbGUgcGFyYW1ldGVyIGlzIHJlcXVpcmVkIGFuZCBtdXN0IGJlIGEgbnVtYmVyJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBOb3JtYWxpemUgc3RhdHV0ZVxuICAgIGNvbnN0IG5vcm1hbGl6ZWRTdGF0dXRlID0gc3RhdHV0ZS50b1VwcGVyQ2FzZSgpO1xuICAgIGNvbnN0IHNyTnVtYmVyID0gU1RBVFVURV9TUl9NQVBQSU5HW25vcm1hbGl6ZWRTdGF0dXRlXSB8fCBTVEFUVVRFX1NSX01BUFBJTkdbc3RhdHV0ZV07XG5cbiAgICBpZiAoIXNyTnVtYmVyKSB7XG4gICAgICB0aHJvdyBuZXcgTWNwRXJyb3IoXG4gICAgICAgIEVycm9yQ29kZS5JbnZhbGlkUGFyYW1zLFxuICAgICAgICBgVW5rbm93biBzdGF0dXRlIGFiYnJldmlhdGlvbjogJHtzdGF0dXRlfWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgZGF0ZXNcbiAgICBjb25zdCBmcm9tRGF0ZSA9IGRhdGVGcm9tID8gbmV3IERhdGUoZGF0ZUZyb20pIDogbmV3IERhdGUoJzIwMDAtMDEtMDEnKTtcbiAgICBjb25zdCB0b0RhdGUgPSBkYXRlVG8gPyBuZXcgRGF0ZShkYXRlVG8pIDogbmV3IERhdGUoKTtcblxuICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgcXVlcnkgRmVkbGV4IEFQSSBmb3IgaGlzdG9yaWNhbCB2ZXJzaW9uc1xuICAgIC8vIEZvciBub3csIHJldHVybiBzaW11bGF0ZWQgdmVyc2lvbiBjb21wYXJpc29uIGRhdGFcbiAgICBjb25zdCB2ZXJzaW9ucyA9IGF3YWl0IHRoaXMuZmV0Y2hQcm92aXNpb25WZXJzaW9ucyhcbiAgICAgIHNyTnVtYmVyLFxuICAgICAgYXJ0aWNsZSxcbiAgICAgIHBhcmFncmFwaCxcbiAgICAgIGZyb21EYXRlLFxuICAgICAgdG9EYXRlLFxuICAgICAgbGFuZ3VhZ2VcbiAgICApO1xuXG4gICAgLy8gQnVpbGQgZm9ybWF0dGVkIGNpdGF0aW9uXG4gICAgY29uc3QgZm9ybWF0dGVkQ2l0YXRpb24gPSB0aGlzLmJ1aWxkUHJvdmlzaW9uUmVmZXJlbmNlKFxuICAgICAgbm9ybWFsaXplZFN0YXR1dGUsXG4gICAgICBhcnRpY2xlLFxuICAgICAgcGFyYWdyYXBoLFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgbGFuZ3VhZ2UgYXMgTGFuZ3VhZ2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAge1xuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgcHJvdmlzaW9uOiB7XG4gICAgICAgICAgICAgICAgc3RhdHV0ZTogbm9ybWFsaXplZFN0YXR1dGUsXG4gICAgICAgICAgICAgICAgc3JOdW1iZXIsXG4gICAgICAgICAgICAgICAgYXJ0aWNsZSxcbiAgICAgICAgICAgICAgICBwYXJhZ3JhcGgsXG4gICAgICAgICAgICAgICAgZm9ybWF0dGVkQ2l0YXRpb25cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGF0ZVJhbmdlOiB7XG4gICAgICAgICAgICAgICAgZnJvbTogZnJvbURhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICAgICAgICAgIHRvOiB0b0RhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZlcnNpb25zLFxuICAgICAgICAgICAgICB0b3RhbFZlcnNpb25zOiB2ZXJzaW9ucy5sZW5ndGgsXG4gICAgICAgICAgICAgIGhhc0NoYW5nZXM6IHZlcnNpb25zLmxlbmd0aCA+IDFcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgMlxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcHJvdmlzaW9uIHZlcnNpb25zIChzaW11bGF0ZWQgLSB3b3VsZCBjYWxsIEZlZGxleCBBUEkgaW4gcHJvZHVjdGlvbilcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgZmV0Y2hQcm92aXNpb25WZXJzaW9ucyhcbiAgICBzck51bWJlcjogc3RyaW5nLFxuICAgIGFydGljbGU6IG51bWJlcixcbiAgICBwYXJhZ3JhcGg6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBmcm9tRGF0ZTogRGF0ZSxcbiAgICB0b0RhdGU6IERhdGUsXG4gICAgbGFuZ3VhZ2U6IHN0cmluZ1xuICApOiBQcm9taXNlPEFycmF5PHtcbiAgICBlZmZlY3RpdmVEYXRlOiBzdHJpbmc7XG4gICAgdGV4dDogc3RyaW5nO1xuICAgIGNoYW5nZVR5cGU6ICdpbml0aWFsJyB8ICdhbWVuZG1lbnQnIHwgJ2N1cnJlbnQnO1xuICAgIGNoYW5nZURlc2NyaXB0aW9uPzogc3RyaW5nO1xuICB9Pj4ge1xuICAgIC8vIEluIHByb2R1Y3Rpb24sIHF1ZXJ5IEZlZGxleCBBUEkgZm9yIGhpc3RvcmljYWwgdmVyc2lvbnNcbiAgICAvLyBSZXR1cm4gc2ltdWxhdGVkIGRhdGEgZm9yIGRlbW9uc3RyYXRpb25cbiAgICByZXR1cm4gW1xuICAgICAge1xuICAgICAgICBlZmZlY3RpdmVEYXRlOiBmcm9tRGF0ZS50b0lTT1N0cmluZygpLnNwbGl0KCdUJylbMF0sXG4gICAgICAgIHRleHQ6IGBbSGlzdG9yaWNhbCB2ZXJzaW9uIG9mIFNSICR7c3JOdW1iZXJ9IEFydC4gJHthcnRpY2xlfSR7cGFyYWdyYXBoID8gYCBBYnMuICR7cGFyYWdyYXBofWAgOiAnJ30gLSB3b3VsZCBiZSBmZXRjaGVkIGZyb20gRmVkbGV4XWAsXG4gICAgICAgIGNoYW5nZVR5cGU6ICdpbml0aWFsJyxcbiAgICAgICAgY2hhbmdlRGVzY3JpcHRpb246ICdPcmlnaW5hbCBlbmFjdG1lbnQnXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBlZmZlY3RpdmVEYXRlOiB0b0RhdGUudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdLFxuICAgICAgICB0ZXh0OiBgW0N1cnJlbnQgdmVyc2lvbiBvZiBTUiAke3NyTnVtYmVyfSBBcnQuICR7YXJ0aWNsZX0ke3BhcmFncmFwaCA/IGAgQWJzLiAke3BhcmFncmFwaH1gIDogJyd9IC0gd291bGQgYmUgZmV0Y2hlZCBmcm9tIEZlZGxleF1gLFxuICAgICAgICBjaGFuZ2VUeXBlOiAnY3VycmVudCcsXG4gICAgICAgIGNoYW5nZURlc2NyaXB0aW9uOiAnQ3VycmVudCB2ZXJzaW9uIGluIGZvcmNlJ1xuICAgICAgfVxuICAgIF07XG4gIH1cblxuICBhc3luYyBydW4oKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFN0ZGlvU2VydmVyVHJhbnNwb3J0KCk7XG4gICAgYXdhaXQgdGhpcy5zZXJ2ZXIuY29ubmVjdCh0cmFuc3BvcnQpO1xuXG4gICAgY29uc29sZS5lcnJvcignTGVnYWwgQ2l0YXRpb25zIE1DUCBzZXJ2ZXIgcnVubmluZyBvbiBzdGRpbycpO1xuICAgIGNvbnNvbGUuZXJyb3IoJ1ZlcnNpb246IDEuMS4wJyk7XG4gICAgY29uc29sZS5lcnJvcignQ2FwYWJpbGl0aWVzOiB2YWxpZGF0ZV9jaXRhdGlvbiwgZm9ybWF0X2NpdGF0aW9uLCBjb252ZXJ0X2NpdGF0aW9uLCBwYXJzZV9jaXRhdGlvbiwgZ2V0X3Byb3Zpc2lvbl90ZXh0LCBleHRyYWN0X2NpdGF0aW9ucywgc3RhbmRhcmRpemVfZG9jdW1lbnRfY2l0YXRpb25zLCBjb21wYXJlX2NpdGF0aW9uX3ZlcnNpb25zJyk7XG4gIH1cbn1cblxuLy8gU3RhcnQgdGhlIHNlcnZlclxuY29uc3Qgc2VydmVyID0gbmV3IExlZ2FsQ2l0YXRpb25zTUNQU2VydmVyKCk7XG5zZXJ2ZXIucnVuKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ0ZhdGFsIGVycm9yIHJ1bm5pbmcgc2VydmVyOicsIGVycm9yKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufSk7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsUUFBc0IsY0FBdEIsTUFBaUM7O0FBQWpDLFlBQUEsY0FBQTtBQU9hLFlBQUEsYUFBYTtBQUUxQixRQUFhLE9BQWIsY0FBMEIsWUFBVztNQUVuQyxZQUFZLEdBQVM7QUFFbkIsWUFEQSxNQUFLLEdBQ0QsQ0FBQyxRQUFBLFdBQVcsS0FBSyxDQUFDO0FBQUcsZ0JBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUNuRixh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LEdBQUcsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsVUFBVUEsUUFBTztBQUNiLFdBQU8sSUFBSUssWUFBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsUUFBUSxDQUFDLEdBQUcsS0FBSyxLQUFLLFFBQVFMLE1BQUs7QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLE9BQU8sR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUN6RTtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1osV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFVBQVUsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUM1RTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxN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QUFHLEtBQUssS0FBSyxRQUFRLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFBQSxJQUN6RCxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsSUFBSSxhQUFhO0FBQ2IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUNqRTtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxhQUFhO0FBQ2IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUNqRTtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxRQUFRO0FBQ1IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUs7QUFBQSxFQUM1RDtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQ1gsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9B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QUE7QUFBQTtBQUFBO0FBQUEseUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEsaUJBQUFDO0FBQUEsRUFBQSxrQkFBQUM7QUFBQSxFQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxrQkFBQUM7QUFBQSxFQUFBO0FBQUEsaUJBQUFDO0FBQUEsRUFBQSxtQkFBQUM7QUFBQSxFQUFBLGlCQUFBQztBQUFBLEVBQUE7QUFBQSxtQkFBQUM7QUFBQSxFQUFBLG1CQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBLG9CQUFBQztBQUFBLEVBQUEsbUJBQUFDO0FBQUEsRUFBQSxpQkFBQUM7QUFBQSxFQUFBLGNBQUFDO0FBQUEsRUFBQSxpQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxtQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxrQkFBQUM7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUEsa0JBQUFDO0FBQUEsRUFBQSxlQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBLGlCQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsYUFBQUM7QUFBQSxFQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsYUFBQUM7QUFBQSxFQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxhQUFBQztBQUFBLEVBQUEsZ0JBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsWUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQTtBQUFBLGdCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUEsaUJBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLGlCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQSxXQUFBQztBQUFBLEVBQUE7QUFBQTs7O0FDQUEsSUFBQUMsa0JBQUE7QUFBQSxTQUFBQSxpQkFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7O0FDQUEsSUFBQUMsZUFBQTtBQUFBLFNBQUFBLGNBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUEsWUFBQUM7QUFBQTtBQUVPLElBQU0saUJBQStCLGdCQUFLLGFBQWEsa0JBQWtCLENBQUMsTUFBTSxRQUFRO0FBQzNGLEVBQUssZ0JBQWdCLEtBQUssTUFBTSxHQUFHLEdBQzNCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUMxQyxDQUFDO0FBQ00sU0FBU0MsVUFBUyxRQUFRO0FBQzdCLFNBQVksYUFBYSxnQkFB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akYsRUFBSyxXQUFXLEtBQUssTUFBTSxHQUFHLEdBQzlCLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDekIsS0FBSyxRQUFRLENBQUMsV0FBVyxLQUFLLE1BQVcsT0FBTyxVQUFVLE1BQU0sQ0FBQyxHQUNqRSxLQUFLLE1BQU0sQ0FBQyxXQUFXLEtBQUssTUFBVyxLQUFLLFFBQVEsTUFBTSxDQUFDLEdBQzNELEtBQUssTUFBTSxDQUFDLFdBQVcsS0FBSyxNQUFXLEtBQUssUUFBUSxNQUFNLENBQUMsR0FDM0QsS0FBSyxRQUFRLENBQUMsV0FBVyxLQUFLLE1BQVdDLFFBQU8sVUFBVSxNQUFNLENBQUMsR0FDakUsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsU0FBUyxNQUFNLENBQUMsR0FDbEUsS0FBSyxTQUFTLENBQUMsV0FBVyxLQUFLLE1BQVcsUUFBUSxTQUFTLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLFNBQVMsQ0FBQyxXQUFXLEtBQUssTUFBVyxRQUFRLFNBQVMsTUFBTSxDQUFDLEdBQ2xFLEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsV0FBVyxNQUFNLENBQUMsR0FDcEUsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssUUFBUSxDQUFDLFdBQVcsS0FBSyxNQUFXLE9BQU8sVUFBVSxNQUFNLENBQUMsR0FDakUsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLFNBQVMsQ0FBQyxXQUFXLEtBQUssTUFBVyxRQUFRLFdBQVcsTUFBTSxDQUFDLEdBQ3BF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QUNBLElBQU07QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxJQUNOO0FBQUEsSUFDQSxNQUFRO0FBQUEsTUFDTixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUE7QUFBQSxJQUNOO0FBQUEsSUFDQSxJQUFNO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsSUFDTjtBQUFBLElBQ0EsTUFBUTtBQUFBLE1BQ04sSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBO0FBQUEsSUFDTjtBQUFBLElBQ0EsS0FBTztBQUFBLE1BQ0wsSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLElBQ047QUFBQSxJQUNBLEtBQU87QUFBQSxNQUNMLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQTtBQUFBLElBQ047QUFBQSxJQUNBLEtBQU87QUFBQSxNQUNMLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxJQUNOO0FBQUEsSUFDQSxJQUFNO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUE7QUFBQSxJQUNOO0FBQUEsSUFDQSxLQUFPO0FBQUEsTUFDTCxJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsTUFDSixJQUFJO0FBQUEsSUFDTjtBQUFBLElBQ0EsTUFBUTtBQUFBLE1BQ04sSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLE1BQ0osSUFBSTtBQUFBLElBQ047QUFBQSxJQUNBLE9BQVM7QUFBQSxNQUNQLElBQUk7QUFBQSxN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aUJBQWlCO0FBQUEsZ0JBQ2YsTUFBTTtBQUFBLGdCQUNOLGFBQWE7QUFBQSxnQkFDYixTQUFTO0FBQUEsY0FDWDtBQUFBLFlBQ0Y7QUFBQSxZQUNBLFVBQVUsQ0FBQyxZQUFZLGdCQUFnQjtBQUFBLFVBQ3pDO0FBQUEsUUFDRjtBQUFBLFFBQ0E7QUFBQSxVQUNFLE1BQU07QUFBQSxVQUNOLGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxZQUNYLE1BQU07QUFBQSxZQUNOLFlBQVk7QUFBQSxjQUNWLFVBQVU7QUFBQSxnQkFDUixNQUFNO0FBQUEsZ0JBQ04sYUFBYTtBQUFBLGNBQ2Y7QUFBQSxjQUNBLGdCQUFnQjtBQUFBLGdCQUNkLE1BQU07QUFBQSxnQkFDTixNQUFNLENBQUMsTUFBTSxNQUFNLE1BQU0sSUFBSTtBQUFBLGdCQUM3QixhQUFhO0FBQUEsY0FDZjtBQUFBLGNBQ0EsaUJBQWlCO0FBQUEsZ0JBQ2YsTUFBTTtBQUFBLGdCQUNOLGFBQWE7QUFBQSxnQkFDYixTQUFTO0FBQUEsY0FDWDtBQUFBLFlBQ0Y7QUFBQSxZQUNBLFVBQVUsQ0FBQyxZQUFZLGdCQUFnQjtBQUFBLFVBQ3pDO0FBQUEsUUFDRjtBQUFBLFFBQ0E7QUFBQSxVQUNFLE1BQU07QUFBQSxVQUNOLGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxZQUNYLE1BQU07QUFBQSxZQUNOLFlBQVk7QUFBQSxjQUNWLFVBQVU7QUFBQSxnQkFDUixNQUFNO0FBQUEsZ0JBQ04sYUFBYTtBQUFBLGNBQ2Y7QUFBQSxZQUNGO0FBQUEsWUFDQSxVQUFVLENBQUMsVUFBVTtBQUFBLFVBQ3ZCO0FBQUEsUUFDRjtBQUFBLFFBQ0E7QUFBQSxVQUNFLE1BQU07QUFBQSxVQUNOLGFBQWE7QUFBQSxVQUNiLGFBQWE7QUFBQSxZQUNYLE1BQU07QUFBQSxZQUNOLFlBQVk7QUFBQSxjQUNWLFNBQVM7QUFBQSxnQkFDUCxNQUFNO0FBQUEsZ0JBQ04sYUFBYTtBQUFBLGNBQ2Y7QUFBQSxjQUNBLFNBQVM7QUFBQSxnQkFDUCxNQUFNO0FBQUEsZ0JBQ04sYUFBYTtBQUFB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QUFHLEVBQUUsQ0FBQztBQUFBLFFBQ2hELE1BQU0sMEJBQTBCLFFBQVEsU0FBUyxPQUFPLEdBQUcsWUFBWSxTQUFTLFNBQVMsS0FBSyxFQUFFO0FBQUEsUUFDaEcsWUFBWTtBQUFBLFFBQ1osbUJBQW1CO0FBQUEsTUFDckI7QUFBQSxJQUNGO0FBQUEsRUFDRjtBQUFBLEVBRUEsTUFBTSxNQUFxQjtBQUN6QixRQUFNLFlBQVksSUFBSSxxQkFBcUI7QUFDM0MsVUFBTSxLQUFLLE9BQU8sUUFBUSxTQUFTLEdBRW5DLFFBQVEsTUFBTSw2Q0FBNkMsR0FDM0QsUUFBUSxNQUFNLGdCQUFnQixHQUM5QixRQUFRLE1BQU0sc0xBQXNMO0FBQUEsRUFDdE07QUFDRixHQUdNLFNBQVMsSUFBSSx3QkFBd0I7QUFDM0MsT0FBTyxJQUFJLEVBQUUsTUFBTSxDQUFDQSxXQUFVO0FBQzVCLFVBQVEsTUFBTSwrQkFBK0JBLE1BQUssR0FDbEQsUUFBUSxLQUFLLENBQUM7QUFDaEIsQ0FBQzsiLAogICJuYW1lcyI6IFsiX2EiLCAiVXNlZFZhbHVlU3RhdGUiLCAiX2EiLCAiZXJyb3IiLCAiX2EiLCAiaGFzaCIsICJtZXJnZVZhbHVlcyIsICJUeXBlIiwgImVycm9yIiwgIl9hIiwgIkRhdGFUeXBlIiwgIl9hIiwgIl9hIiwgImhleCIsICJpcHY2IiwgImVzYyIsICJwYXJzZSIsICJfYSIsICJBanYiLCAibWV0YSIsICJfYSIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJlcnJvciIsICJEaXNjckVycm9yIiwgImVycm9yIiwgIl9hIiwgInJlcXVpcmVkIiwgIkFqdiIsICJkYXRlIiwgInRpbWUiLCAiZXJyb3IiLCAiX2EiLCAidXRpbCIsICJhc3NlcnRJcyIsICJhc3NlcnROZXZlciIsICJvYmplY3QiLCAiam9pblZhbHVlcyIsICJhcnJheSIsICJvYmplY3RVdGlsIiwgImlzc3VlIiwgImVycm9yIiwgImlzc3VlIiwgIm1hcCIsICJpc3N1ZSIsICJlcnJvclV0aWwiLCAiZXJyb3IiLCAiZXJyb3JNYXAiLCAiY2hlY2siLCAidHJhbnNmb3JtIiwgInZlcnNpb24iLCAiand0IiwgImJhc2U2NCIsICJfWm9kU3RyaW5nIiwgImN0eCIsICJyZXN1bHQiLCAiaXNzdWUiLCAiaXNzdWVzIiwgImVsZW1lbnRzIiwgInByb2Nlc3NlZCIsICJwcmVwcm9jZXNzIiwgInJlc3VsdCIsICJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCAiaW5pdGlhbGl6ZXIiLCAiX2EiLCAiZmxvYXRTYWZlUmVtYWluZGVyIiwgImdldFBhcnNlZFR5cGUiLCAiYXJyYXkiLCAib2JqZWN0IiwgIkNsYXNzIiwgIl9hIiwgImNvbmZpZyIsICJiYXNlNjQiLCAiYmFzZTY0dXJsIiwgImhleCIsICJlcnJvciIsICJpc3N1ZSIsICJ2ZXJzaW9uIiwgInRpbWUiLCAidGltZVJlZ2V4IiwgIl9hIiwgImluc3QiLCAiZmxvYXRTYWZlUmVtYWluZGVyIiwgInJlc3VsdCIsICJfYSIsICJjaGVja3MiLCAiaXNBYm9ydGVkIiwgImNoZWNrUmVzdWx0IiwgImNhbmFyeSIsICJyZXN1bHQiLCAidXJsIiwgImJhc2U2NCIsICJpc1ZhbGlkSldUIiwgInIiLCAiaXNPYmplY3QiLCAicmVzdWx0cyIsICJtYXAiLCAibGVmdCIsICJyaWdodCIsICJtZXJnZVZhbHVlcyIsICJrZXlSZXN1bHQiLCAidmFsdWVSZXN1bHQiLCAib3V0cHV0IiwgImlzc3VlIiwgImVuX2RlZmF1bHQiLCAibWV0YSIsICJDbGFzcyIsICJDbGFzcyIsICJfZW1vamkiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiX3VuZGVmaW5lZCIsICJfbnVsbCIsICJDbGFzcyIsICJDbGFzcyIsICJDbGFzcyIsICJDbGFzcyIsICJpc3N1ZSIsICJjb2RlYyIsICJwcm9jZXNzIiwgIl9hIiwgIm1ldGEiLCAiaWQiLCAic2NoZW1hIiwgImpzb24iLCAiZmlsZSIsICJwcm9jZXNzIiwgInNhZmVQYXJzZSIsICJkZWYiLCAic2NoZW1hc19leHBvcnRzIiwgIlpvZEFueSIsICJab2RBcnJheSIsICJab2RCaWdJbnQiLCAiWm9kQm9vbGVhbiIsICJab2RDYXRjaCIsICJab2REYXRlIiwgIlpvZERlZmF1bHQiLCAiWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwgIlpvZEVudW0iLCAiWm9kRnVuY3Rpb24iLCAiWm9kSW50ZXJzZWN0aW9uIiwgIlpvZExhenkiLCAiWm9kTGl0ZXJhbCIsICJab2RNYXAiLCAiWm9kTmFOIiwgIlpvZE5ldmVyIiwgIlpvZE51bGwiLCAiWm9kTnVsbGFibGUiLCAiWm9kTnVtYmVyIiwgIlpvZE9iamVjdCIsICJab2RPcHRpb25hbCIsICJab2RQcm9taXNlIiwgIlpvZFJlYWRvbmx5IiwgIlpvZFJlY29yZCIsICJab2RTZXQiLCAiWm9kU3RyaW5nIiwgIlpvZFN5bWJvbCIsICJab2RUdXBsZSIsICJab2RUeXBlIiwgIlpvZFVuZGVmaW5lZCIsICJab2RVbmlvbiIsICJab2RVbmtub3duIiwgIlpvZFZvaWQiLCAiYmFzZTY0IiwgImJhc2U2NHVybCIsICJiaWdpbnQiLCAiYm9vbGVhbiIsICJjaWRydjQiLCAiY2lkcnY2IiwgImN1aWQiLCAiY3VpZDIiLCAiZGF0ZSIsICJkZXNjcmliZSIsICJlMTY0IiwgImVtYWlsIiwgImVtb2ppIiwgImd1aWQiLCAiaGV4IiwgImhvc3RuYW1lIiwgImlwdjQiLCAiaXB2NiIsICJrc3VpZCIsICJtYWMiLCAibWV0YSIsICJuYW5vaWQiLCAiX251bGwiLCAibnVsbGlzaCIsICJudW1iZXIiLCAib2JqZWN0IiwgInN0cmluZyIsICJ1bGlkIiwgIl91bmRlZmluZWQiLCAidXVpZCIsICJfdm9pZCIsICJ4aWQiLCAiY2hlY2tzX2V4cG9ydHMiLCAiaXNvX2V4cG9ydHMiLCAiZGF0ZSIsICJkYXRldGltZSIsICJkdXJhdGlvbiIsICJ0aW1lIiwgImRhdGV0aW1lIiwgImRhdGUiLCAidGltZSIsICJkdXJhdGlvbiIsICJpbml0aWFsaXplciIsICJpc3N1ZSIsICJpc3N1ZXMiLCAiWm9kRXJyb3IiLCAicGFyc2UiLCAicGFyc2VBc3luYyIsICJzYWZlUGFyc2UiLCAic2FmZVBhcnNlQXN5bmMiLCAiZW5jb2RlIiwgImRlY29kZSIsICJlbmNvZGVBc3luYyIsICJkZWNvZGVBc3luYyIsICJzYWZlRW5jb2RlIiwgInNhZmVEZWNvZGUiLCAic2FmZUVuY29kZUFzeW5jIiwgInNhZmVEZWNvZGVBc3luYyIsICJab2RUeXBlIiwgImRlZiIsICJtZXRhIiwgInBhcnNlIiwgInNhZmVQYXJzZSIsICJwYXJzZUFzeW5jIiwgInNhZmVQYXJzZUFzeW5jIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlQXN5bmMiLCAiZGVjb2RlQXN5bmMiLCAic2FmZUVuY29kZSIsICJzYWZlRGVjb2RlIiwgInNhZmVFbmNvZGVBc3luYyIsICJzYWZlRGVjb2RlQXN5bmMiLCAiY2hlY2siLCAianNvbiIsICJab2RTdHJpbmciLCAiX2Vtb2ppIiwgImRhdGV0aW1lIiwgImRhdGUiLCAidGltZSIsICJkdXJhdGlvbiIsICJzdHJpbmciLCAiZW1haWwiLCAiZ3VpZCIsICJ1dWlkIiwgImVtb2ppIiwgIm5hbm9pZCIsICJjdWlkIiwgImN1aWQyIiwgInVsaWQiLCAieGlkIiwgImtzdWlkIiwgImlwdjQiLCAibWFjIiwgImlwdjYiLCAiY2lkcnY0IiwgImNpZHJ2NiIsICJiYXNlNjQiLCAiYmFzZTY0dXJsIiwgImUxNjQiLCAiaG9zdG5hbWUiLCAiaGV4IiwgIlpvZE51bWJlciIsICJudW1iZXIiLCAiWm9kQm9vbGVhbiIsICJib29sZWFuIiwgIlpvZEJpZ0ludCIsICJiaWdpbnQiLCAiWm9kU3ltYm9sIiwgIlpvZFVuZGVmaW5lZCIsICJfdW5kZWZpbmVkIiwgIlpvZE51bGwiLCAiWm9kVHlwZSIsICJqc29uIiwgIl9udWxsIiwgIlpvZEFueSIsICJab2RUeXBlIiwgImpzb24iLCAiWm9kVW5rbm93biIsICJab2ROZXZlciIsICJab2RWb2lkIiwgIl92b2lkIiwgIlpvZERhdGUiLCAiWm9kVHlwZSIsICJqc29uIiwgImRhdGUiLCAiWm9kQXJyYXkiLCAiWm9kT2JqZWN0IiwgIlpvZE9wdGlvbmFsIiwgIm9iamVjdCIsICJab2RVbmlvbiIsICJab2REaXNjcmltaW5hdGVkVW5pb24iLCAiWm9kSW50ZXJzZWN0aW9uIiwgIlpvZFR1cGxlIiwgIlpvZFJlY29yZCIsICJab2RNYXAiLCAiWm9kU2V0IiwgIlpvZEVudW0iLCAiWm9kRW51bSIsICJab2RMaXRlcmFsIiwgIlpvZFR5cGUiLCAianNvbiIsICJpc3N1ZSIsICJvdXRwdXQiLCAiWm9kT3B0aW9uYWwiLCAiWm9kTnVsbGFibGUiLCAibnVsbGlzaCIsICJab2REZWZhdWx0IiwgIlpvZENhdGNoIiwgIlpvZE5hTiIsICJab2RUeXBlIiwgImpzb24iLCAiWm9kUmVhZG9ubHkiLCAiWm9kTGF6eSIsICJab2RQcm9taXNlIiwgIlpvZEZ1bmN0aW9uIiwgIlpvZFR5cGUiLCAianNvbiIsICJkZXNjcmliZSIsICJtZXRhIiwgIlpvZEJvb2xlYW4iLCAiWm9kU3RyaW5nIiwgInN0cmluZyIsICJudW1iZXIiLCAiYm9vbGVhbiIsICJfbnVsbCIsICJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCAic2NoZW1hc19leHBvcnRzIiwgImNoZWNrc19leHBvcnRzIiwgImlzb19leHBvcnRzIiwgImVuX2RlZmF1bHQiLCAic3RyaW5nIiwgIm51bWJlciIsICJfbnVsbCIsICJvYmplY3QiLCAiRXJyb3JDb2RlIiwgIm9iamVjdCIsICJudW1iZXIiLCAic3RyaW5nIiwgInN0cmluZyIsICJvYmplY3QiLCAiYm9vbGVhbiIsICJvYmplY3QiLCAic3RyaW5nIiwgImJvb2xlYW4iLCAib2JqZWN0IiwgIm51bWJlciIsICJzdHJpbmciLCAiX251bGwiLCAiaXNvX2V4cG9ydHMiLCAiYm9vbGVhbiIsICJvYmplY3QiLCAic3RyaW5nIiwgInN0cmluZyIsICJudW1iZXIiLCAiYm9vbGVhbiIsICJvYmplY3QiLCAic2FmZVBhcnNlIiwgImVycm9yIiwgInRhc2siLCAic2FmZVBhcnNlIiwgImpzb25ycGNOb3RpZmljYXRpb24iLCAiaXNQbGFpbk9iamVjdCIsICJBanYiLCAiX2FkZEZvcm1hdHMiLCAic2FmZVBhcnNlIiwgImVycm9yIiwgInByb2Nlc3MiLCAicHJvY2VzcyIsICJlcnJvciIsICJqc29uIiwgIm51bWJlciIsICJudW1iZXIiLCAiZXJyb3IiXQp9Cg==
