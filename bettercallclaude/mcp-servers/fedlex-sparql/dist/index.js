#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        if (super(), !exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super(), this._items = typeof code == "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        let item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => (c instanceof Name && (names[c.str] = (names[c.str] || 0) + 1), names), {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      let code = [strs[0]], i = 0;
      for (; i < args.length; )
        addCodeArg(code, args[i]), code.push(strs[++i]);
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      let expr = [safeStringify(strs[0])], i = 0;
      for (; i < args.length; )
        expr.push(plus), addCodeArg(expr, args[i]), expr.push(plus, safeStringify(strs[++i]));
      return optimize(expr), new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      arg instanceof _Code ? code.push(...arg._items) : arg instanceof Name ? code.push(arg) : code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      for (; i < expr.length - 1; ) {
        if (expr[i] === plus) {
          let res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string")
        return b instanceof Name || a[a.length - 1] !== '"' ? void 0 : typeof b != "string" ? `${a.slice(0, -1)}${b}"` : b[0] === '"' ? a.slice(0, -1) + b.slice(1) : void 0;
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key))
        return new _Code(`${key}`);
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code(), ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`), this.value = name.value;
      }
    }, UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2.Started = 0] = "Started", UsedValueState2[UsedValueState2.Completed = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {}, this._prefixes = prefixes, this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        let ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (!((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0) && _b.has(prefix) || this._prefixes && !this._prefixes.has(prefix))
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr), this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value, this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`, ValueScope = class extends Scope {
      constructor(opts) {
        super(opts), this._values = {}, this._scope = opts.scope, this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        let name = this.toName(nameOrPrefix), { prefix } = name, valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref, vs = this._values[prefix];
        if (vs) {
          let _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        vs.set(valueKey, name);
        let s = this._scope[prefix] || (this._scope[prefix] = []), itemIndex = s.length;
        return s[itemIndex] = value.ref, name.setValue(value, { property: prefix, itemIndex }), name;
      }
      getValue(prefix, keyOrRef) {
        let vs = this._values[prefix];
        if (vs)
          return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (let prefix in values) {
          let vs = values[prefix];
          if (!vs)
            continue;
          let nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              let def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode?.(name))
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            else
              throw new ValueError(name);
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code(), scope_1 = require_scope(), code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: !0, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: !0, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: !0, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: !0, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: !0, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: !0, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: !0, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: !0, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: !0, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: !0, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: !0, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: !0, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }, Def = class extends Node {
      constructor(varKind, name, rhs) {
        super(), this.varKind = varKind, this.name = name, this.rhs = rhs;
      }
      render({ es5, _n }) {
        let varKind = es5 ? scope_1.varKinds.var : this.varKind, rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (names[this.name.str])
          return this.rhs && (this.rhs = optimizeExpr(this.rhs, names, constants)), this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }, Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super(), this.lhs = lhs, this.rhs = rhs, this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!(this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects))
          return this.rhs = optimizeExpr(this.rhs, names, constants), this;
      }
      get names() {
        let names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    }, AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects), this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }, Label = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }, Break = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `break${this.label ? ` ${this.label}` : ""};` + _n;
      }
    }, Throw = class extends Node {
      constructor(error2) {
        super(), this.error = error2;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }, AnyCode = class extends Node {
      constructor(code) {
        super(), this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        return this.code = optimizeExpr(this.code, names, constants), this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }, ParentNode = class extends Node {
      constructor(nodes = []) {
        super(), this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i].optimizeNodes();
          Array.isArray(n) ? nodes.splice(i, 1, ...n) : n ? nodes[i] = n : nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i];
          n.optimizeNames(names, constants) || (subtractNames(names, n.names), nodes.splice(i, 1));
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    }, BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }, Root = class extends ParentNode {
    }, Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes), this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        return this.else && (code += "else " + this.else.render(opts)), code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let cond = this.condition;
        if (cond === !0)
          return this.nodes;
        let e = this.else;
        if (e) {
          let ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e)
          return cond === !1 ? e instanceof _If ? e : e.nodes : this.nodes.length ? this : new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        if (!(cond === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        if (this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants), !!(super.optimizeNames(names, constants) || this.else))
          return this.condition = optimizeExpr(this.condition, names, constants), this;
      }
      get names() {
        let names = super.names;
        return addExprNames(names, this.condition), this.else && addNames(names, this.else.names), names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super(), this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iteration = optimizeExpr(this.iteration, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }, ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super(), this.varKind = varKind, this.name = name, this.from = from, this.to = to;
      }
      render(opts) {
        let varKind = opts.es5 ? scope_1.varKinds.var : this.varKind, { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        let names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    }, ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super(), this.loop = loop, this.varKind = varKind, this.name = name, this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iterable = optimizeExpr(this.iterable, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }, Func = class extends BlockNode {
      constructor(name, args, async) {
        super(), this.name = name, this.args = args, this.async = async;
      }
      render(opts) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        return this.catch && (code += this.catch.render(opts)), this.finally && (code += this.finally.render(opts)), code;
      }
      optimizeNodes() {
        var _a2, _b;
        return super.optimizeNodes(), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNodes(), (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes(), this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        return super.optimizeNames(names, constants), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNames(names, constants), (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants), this;
      }
      get names() {
        let names = super.names;
        return this.catch && addNames(names, this.catch.names), this.finally && addNames(names, this.finally.names), names;
      }
    }, Catch = class extends BlockNode {
      constructor(error2) {
        super(), this.error = error2;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...opts, _n: opts.lines ? `
` : "" }, this._extScope = extScope, this._scope = new scope_1.Scope({ parent: extScope }), this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        let name = this._extScope.value(prefixOrName, value);
        return (this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name), name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        let name = this._scope.toName(nameOrPrefix);
        return rhs !== void 0 && constant && (this._constants[name.str] = rhs), this._leafNode(new Def(varKind, name, rhs)), name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        return typeof c == "function" ? c() : c !== code_1.nil && this._leafNode(new AnyCode(c)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        let code = ["{"];
        for (let [key, value] of keyValues)
          code.length > 1 && code.push(","), code.push(key), (key !== value || this.opts.es5) && (code.push(":"), (0, code_1.addCodeArg)(code, value));
        return code.push("}"), new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        if (this._blockNode(new If(condition)), thenBody && elseBody)
          this.code(thenBody).else().code(elseBody).endIf();
        else if (thenBody)
          this.code(thenBody).endIf();
        else if (elseBody)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        return this._blockNode(node), forBody && this.code(forBody).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        let name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          let arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`), forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        let node = new Return();
        if (this._blockNode(node), this.code(value), node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        let node = new Try();
        if (this._blockNode(node), this.code(tryBody), catchCode) {
          let error2 = this.name("e");
          this._currNode = node.catch = new Catch(error2), catchCode(error2);
        }
        return finallyCode && (this._currNode = node.finally = new Finally(), this.code(finallyCode)), this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error2) {
        return this._leafNode(new Throw(error2));
      }
      // start self-balancing block
      block(body, nodeCount) {
        return this._blockStarts.push(this._nodes.length), body && this.code(body).endBlock(nodeCount), this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        let len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        let toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount)
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        return this._nodes.length = len, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        return this._blockNode(new Func(name, args, async)), funcBody && this.code(funcBody).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        for (; n-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(node) {
        return this._currNode.nodes.push(node), this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node), this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        let n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        let n = this._currNode;
        if (!(n instanceof If))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = n.else = node, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        let ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => (c instanceof code_1.Name && (c = replaceName(c)), c instanceof code_1._Code ? items.push(...c._items) : items.push(c), items), []));
      function replaceName(n) {
        let c = constants[n.str];
        return c === void 0 || names[n.str] !== 1 ? n : (delete names[n.str], c);
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen(), code_1 = require_code();
    function toHash(arr) {
      let hash2 = {};
      for (let item of arr)
        hash2[item] = !0;
      return hash2;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      return typeof schema == "boolean" ? schema : Object.keys(schema).length === 0 ? !0 : (checkUnknownRules(it, schema), !schemaHasRules(schema, it.self.RULES.all));
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      let { opts, self } = it;
      if (!opts.strictSchema || typeof schema == "boolean")
        return;
      let rules = self.RULES.keywords;
      for (let key in schema)
        rules[key] || checkStrictMode(it, `unknown keyword: "${key}"`);
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (rules[key])
          return !0;
      return !1;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (key !== "$ref" && RULES.all[key])
          return !0;
      return !1;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      return typeof str == "number" ? `${str}` : str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs))
        for (let x of xs)
          f(x);
      else
        f(xs);
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
      return (gen, from, to, toName) => {
        let res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, !0), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          from === !0 ? gen.assign(to, !0) : (gen.assign(to, (0, codegen_1._)`${to} || {}`), setEvaluated(gen, to, from));
        }),
        mergeValues: (from, to) => from === !0 ? !0 : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === !0 ? !0 : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === !0 ? !0 : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === !0)
        return gen.var("props", !0);
      let props = gen.var("props", (0, codegen_1._)`{}`);
      return ps !== void 0 && setEvaluated(gen, props, ps), props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, !0));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2.Num = 0] = "Num", Type2[Type2.Str = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        let isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (mode) {
        if (msg = `strict mode: ${msg}`, mode === !0)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      overrideAllErrors ?? (compositeRule || allErrors) ? addError(gen, errObj) : returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      addError(gen, errObj), compositeRule || allErrors || returnErrors(it, names_1.default.vErrors);
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount), gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      let err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`), gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath))), gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`), it.opts.verbose && (gen.assign((0, codegen_1._)`${err}.schema`, schemaValue), gen.assign((0, codegen_1._)`${err}.data`, data));
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      let err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`), gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      let { gen, validateName, schemaEnv } = it;
      schemaEnv.$async ? gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`) : (gen.assign((0, codegen_1._)`${validateName}.errors`, errs), gen.return(!1));
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error2, errorPaths) {
      let { createErrors } = cxt.it;
      return createErrors === !1 ? (0, codegen_1._)`{}` : errorObject(cxt, error2, errorPaths);
    }
    function errorObject(cxt, error2, errorPaths = {}) {
      let { gen, it } = cxt, keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      return extraErrorProps(cxt, error2, keyValues), gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      let instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      return schemaPath && (schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`), [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      let { keyword, data, schemaValue, it } = cxt, { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]), opts.messages && keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]), opts.verbose && keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]), propertyName && keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors(), codegen_1 = require_codegen(), names_1 = require_names(), boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      let { gen, schema, validateName } = it;
      schema === !1 ? falseSchemaError(it, !1) : typeof schema == "object" && schema.$async === !0 ? gen.return(names_1.default.data) : (gen.assign((0, codegen_1._)`${validateName}.errors`, null), gen.return(!0));
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      let { gen, schema } = it;
      schema === !1 ? (gen.var(valid, !1), falseSchemaError(it)) : gen.var(valid, !0);
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      let { gen, data } = it, cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"], jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      let groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      let group = self.RULES.types[type];
      return group && group !== !0 && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules(), applicability_1 = require_applicability(), errors_1 = require_errors(), codegen_1 = require_codegen(), util_1 = require_util(), DataType;
    (function(DataType2) {
      DataType2[DataType2.Correct = 0] = "Correct", DataType2[DataType2.Wrong = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      let types = getJSONTypes(schema.type);
      if (types.includes("null")) {
        if (schema.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        schema.nullable === !0 && types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      let types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      let { gen, data, opts } = it, coerceTo = coerceToTypes(types, opts.coerceTypes), checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        let wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          coerceTo.length ? coerceData(it, types, coerceTo) : reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      let { gen, data, opts } = it, dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`), coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      opts.coerceTypes === "array" && gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))), gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (let t of coerceTo)
        (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") && coerceSpecificType(t);
      gen.else(), reportTypeError(it), gen.endIf(), gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced), assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, !1).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, !0);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`), gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      let EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ, cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1)
        return checkDataType(dataTypes[0], data, strictNums, correct);
      let cond, types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        let notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`, delete types.null, delete types.array, delete types.object;
      } else
        cond = codegen_1.nil;
      types.number && delete types.integer;
      for (let t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      let cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      let { gen, data, schema } = it, schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function assignDefaults(it, ty) {
      let { properties, items } = it.schema;
      if (ty === "object" && properties)
        for (let key in properties)
          assignDefault(it, key, properties[key].default);
      else ty === "array" && Array.isArray(items) && items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      let { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      let childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      opts.useDefaults === "empty" && (condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`), gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names(), util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      let { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, !0), cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, !0), cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      let dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data, valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      it.opts.dynamicRef && valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      let args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      let u = opts.unicodeRegExp ? "u" : "", { regExp } = opts.code, rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      if (it.allErrors) {
        let validArr = gen.let("valid", !0);
        return validateItems(() => gen.assign(validArr, !1)), validArr;
      }
      return gen.var(valid, !0), validateItems(() => gen.break()), valid;
      function validateItems(notValid) {
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid), gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      let { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated)
        return;
      let valid = gen.let("valid", !1), schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        let schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: !0
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`), cxt.mergeValidEvaluated(schCxt, schValid) || gen.if((0, codegen_1.not)(valid));
      })), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
    }
    exports2.validateUnion = validateUnion;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen(), names_1 = require_names(), code_1 = require_code2(), errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      let { gen, keyword, schema, parentSchema, it } = cxt, macroSchema = def.macro.call(it.self, schema, parentSchema, it), schemaRef = useKeyword(gen, keyword, macroSchema);
      it.opts.validateSchema !== !1 && it.self.validateSchema(macroSchema, !0);
      let valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: !0
      }, valid), cxt.pass(valid, () => cxt.error(!0));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      let { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      let validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate, validateRef = useKeyword(gen, keyword, validate), valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword), cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === !1)
          assignValid(), def.modifying && modifyData(cxt), reportErrs(() => cxt.error());
        else {
          let ruleErrs = def.async ? validateAsync() : validateSync();
          def.modifying && modifyData(cxt), reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        let ruleErrs = gen.let("ruleErrs", null);
        return gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, !1).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e))), ruleErrs;
      }
      function validateSync() {
        let validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        return gen.assign(validateErrs, null), assignValid(codegen_1.nil), validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        let passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self, passSchema = !("compile" in def && !$data || def.schema === !1);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      let { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      let { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`), (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = !1) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema > "u");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword)
        throw new Error("ajv implementation error");
      let deps = def.dependencies;
      if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)))
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      if (def.validateSchema && !def.validateSchema(schema[keyword])) {
        let msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (keyword !== void 0) {
        let sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      let { gen } = it;
      if (dataProp !== void 0) {
        let { errorPath, dataPathArr, opts } = it, nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, !0);
        dataContextProps(nextData), subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`, subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`, subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        let nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, !0);
        dataContextProps(nextData), propertyName !== void 0 && (subschema.propertyName = propertyName);
      }
      dataTypes && (subschema.dataTypes = dataTypes);
      function dataContextProps(_nextData) {
        subschema.data = _nextData, subschema.dataLevel = it.dataLevel + 1, subschema.dataTypes = [], it.definedProperties = /* @__PURE__ */ new Set(), subschema.parentData = it.data, subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      compositeRule !== void 0 && (subschema.compositeRule = compositeRule), createErrors !== void 0 && (subschema.createErrors = createErrors), allErrors !== void 0 && (subschema.allErrors = allErrors), subschema.jtdDiscriminator = jtdDiscriminator, subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// mcp-servers-src/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "mcp-servers-src/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return !0;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return !1;
        var length, i, keys;
        if (Array.isArray(a)) {
          if (length = a.length, length != b.length) return !1;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return !1;
          return !0;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return !1;
        }
        return !0;
      }
      return a !== a && b !== b;
    };
  }
});

// mcp-servers-src/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "mcp-servers-src/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      }, post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    };
    traverse.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    };
    traverse.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    };
    traverse.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords)
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object")
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util(), equal = require_fast_deep_equal(), traverse = require_json_schema_traverse(), SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = !0) {
      return typeof schema == "boolean" ? !0 : limit === !0 ? !hasRef(schema) : limit ? countKeys(schema) <= limit : !1;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (let key in schema) {
        if (REF_KEYWORDS.has(key))
          return !0;
        let sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef) || typeof sch == "object" && hasRef(sch))
          return !0;
      }
      return !1;
    }
    function countKeys(schema) {
      let count = 0;
      for (let key in schema) {
        if (key === "$ref")
          return 1 / 0;
        if (count++, !SIMPLE_INLINED.has(key) && (typeof schema[key] == "object" && (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch)), count === 1 / 0))
          return 1 / 0;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      normalize !== !1 && (id = normalizeId(id));
      let p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      return resolver.serialize(p).split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      return id = normalizeId(id), resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      let { schemaId, uriResolver } = this.opts, schId = normalizeId(schema[schemaId] || baseId), baseIds = { "": schId }, pathPrefix = getFullPath(uriResolver, schId, !1), localRefs = {}, schemaRefs = /* @__PURE__ */ new Set();
      return traverse(schema, { allKeys: !0 }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        let fullPath = pathPrefix + jsonPtr, innerBaseId = baseIds[parentJsonPtr];
        typeof sch[schemaId] == "string" && (innerBaseId = addRef.call(this, sch[schemaId])), addAnchor.call(this, sch.$anchor), addAnchor.call(this, sch.$dynamicAnchor), baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          let _resolve = this.opts.uriResolver.resolve;
          if (ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref), schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          return typeof schOrRef == "string" && (schOrRef = this.refs[schOrRef]), typeof schOrRef == "object" ? checkAmbiguosRef(sch, schOrRef.schema, ref) : ref !== normalizeId(fullPath) && (ref[0] === "#" ? (checkAmbiguosRef(sch, localRefs[ref], ref), localRefs[ref] = sch) : this.refs[ref] = fullPath), ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      }), localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema(), dataType_1 = require_dataType(), applicability_1 = require_applicability(), dataType_2 = require_dataType(), defaults_1 = require_defaults(), keyword_1 = require_keyword(), subschema_1 = require_subschema(), codegen_1 = require_codegen(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        topSchemaObjCode(it);
        return;
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      opts.code.es5 ? gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`), destructureValCxtES5(gen, opts), gen.code(body);
      }) : gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`), gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`), gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`), gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`), gen.var(names_1.default.rootData, names_1.default.data), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      let { schema, opts, gen } = it;
      validateFunction(it, () => {
        opts.$comment && schema.$comment && commentKeyword(it), checkNoDefault(it), gen.let(names_1.default.vErrors, null), gen.let(names_1.default.errors, 0), opts.unevaluated && resetEvaluated(it), typeAndKeywords(it), returnResults(it);
      });
    }
    function resetEvaluated(it) {
      let { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`), gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`)), gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      let schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        subSchemaObjCode(it, valid);
        return;
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (self.RULES.all[key])
          return !0;
      return !1;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      let { schema, gen, opts } = it;
      opts.$comment && schema.$comment && commentKeyword(it), updateContext(it), checkAsyncSchema(it);
      let errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount), gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it), checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], !1, errsCount);
      let types = (0, dataType_1.getSchemaTypes)(it.schema), checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      let { schema, errSchemaPath, opts, self } = it;
      schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES) && self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
    function checkNoDefault(it) {
      let { schema, opts } = it;
      schema.default !== void 0 && opts.useDefaults && opts.strictSchema && (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
    function updateContext(it) {
      let schId = it.schema[it.opts.schemaId];
      schId && (it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId));
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      let msg = schema.$comment;
      if (opts.$comment === !0)
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      else if (typeof opts.$comment == "function") {
        let schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`, rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      let { gen, schemaEnv, validateName, ValidationError, opts } = it;
      schemaEnv.$async ? gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`)) : (gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors), opts.unevaluated && assignEvaluated(it), gen.return((0, codegen_1._)`${names_1.default.errors} === 0`));
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      props instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.props`, props), items instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      let { gen, schema, data, allErrors, opts, self } = it, { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      opts.jtd || checkStrictTypes(it, types), gen.block(() => {
        for (let group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        (0, applicability_1.shouldUseGroup)(schema, group) && (group.type ? (gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)), iterateKeywords(it, group), types.length === 1 && types[0] === group.type && typeErrors && (gen.else(), (0, dataType_2.reportTypeError)(it)), gen.endIf()) : iterateKeywords(it, group), allErrors || gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`));
      }
    }
    function iterateKeywords(it, group) {
      let { gen, schema, opts: { useDefaults } } = it;
      useDefaults && (0, defaults_1.assignDefaults)(it, group.type), gen.block(() => {
        for (let rule of group.rules)
          (0, applicability_1.shouldUseRule)(schema, rule) && keywordCode(it, rule.keyword, rule.definition, group.type);
      });
    }
    function checkStrictTypes(it, types) {
      it.schemaEnv.meta || !it.opts.strictTypes || (checkContextTypes(it, types), it.opts.allowUnionTypes || checkMultipleTypes(it, types), checkKeywordTypes(it, it.dataTypes));
    }
    function checkContextTypes(it, types) {
      if (types.length) {
        if (!it.dataTypes.length) {
          it.dataTypes = types;
          return;
        }
        types.forEach((t) => {
          includesType(it.dataTypes, t) || strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }), narrowSchemaTypes(it, types);
      }
    }
    function checkMultipleTypes(it, ts) {
      ts.length > 1 && !(ts.length === 2 && ts.includes("null")) && strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
    function checkKeywordTypes(it, ts) {
      let rules = it.self.RULES.all;
      for (let keyword in rules) {
        let rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          let { type } = rule.definition;
          type.length && !type.some((t) => hasApplicableType(ts, t)) && strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      let ts = [];
      for (let t of it.dataTypes)
        includesType(withTypes, t) ? ts.push(t) : withTypes.includes("integer") && t === "number" && ts.push("integer");
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      let schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`, (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        if ((0, keyword_1.validateKeywordUsage)(it, def, keyword), this.gen = it.gen, this.allErrors = it.allErrors, this.keyword = keyword, this.data = it.data, this.schema = it.schema[keyword], this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data), this.schemaType = def.schemaType, this.parentSchema = it.schema, this.params = {}, this.it = it, this.def = def, this.$data)
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        else if (this.schemaCode = this.schemaValue, !(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined))
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        ("code" in def ? def.trackErrors : def.errors !== !1) && (this.errsCount = it.gen.const("_errs", names_1.default.errors));
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition), failAction ? failAction() : this.error(), successAction ? (this.gen.else(), successAction(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(condition), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        let { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams), this._error(append, errorPaths), this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        this.allErrors || this.gen.if(cond);
      }
      setParams(obj, assign) {
        assign ? Object.assign(this.params, obj) : this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid), codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        let { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid)), valid !== codegen_1.nil && gen.assign(valid, !0), (schemaType.length || def.validateSchema) && (gen.elseIf(this.invalid$data()), this.$dataError(), valid !== codegen_1.nil && gen.assign(valid, !1)), gen.else();
      }
      invalid$data() {
        let { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            let st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            let validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        let subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl), (0, subschema_1.extendSubschemaMode)(subschema, appl);
        let nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        return subschemaCode(nextContext, valid), nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        let { it, gen } = this;
        it.opts.unevaluated && (it.props !== !0 && schemaCxt.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)), it.items !== !0 && schemaCxt.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)));
      }
      mergeValidEvaluated(schemaCxt, valid) {
        let { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== !0 || it.items !== !0))
          return gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name)), !0;
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      let cxt = new KeywordCxt(it, def, keyword);
      "code" in def ? def.code(cxt, ruleType) : cxt.$data && def.validate ? (0, keyword_1.funcKeywordCode)(cxt, def) : "macro" in def ? (0, keyword_1.macroKeywordCode)(cxt, def) : (def.compile || def.validate) && (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer, data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data, data = names_1.default.rootData;
      } else {
        let matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        let up = +matches[1];
        if (jsonPointer = matches[2], jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        if (data = dataNames[dataLevel - up], !jsonPointer)
          return data;
      }
      let expr = data, segments = jsonPointer.split("/");
      for (let segment of segments)
        segment && (data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`, expr = (0, codegen_1._)`${expr} && ${data}`);
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed"), this.errors = errors, this.ajv = this.validation = !0;
      }
    };
    exports2.default = ValidationError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var resolve_1 = require_resolve(), MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`), this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref), this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen(), validation_error_1 = require_validation_error(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), validate_1 = require_validate(), SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {}, this.dynamicAnchors = {};
        let schema;
        typeof env.schema == "object" && (schema = env.schema), this.schema = env.schema, this.schemaId = env.schemaId, this.root = env.root || this, this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema?.[env.schemaId || "$id"]), this.schemaPath = env.schemaPath, this.localRefs = env.localRefs, this.meta = env.meta, this.$async = schema?.$async, this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      let _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      let rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId), { es5, lines } = this.opts.code, { ownProperties } = this.opts, gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties }), _ValidationError;
      sch.$async && (_ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      }));
      let validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      let schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === !0 ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      }, sourceCode;
      try {
        this._compilations.add(sch), (0, validate_1.validateFunctionCode)(schemaCxt), gen.optimize(this.opts.code.optimize);
        let validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`, this.opts.code.process && (sourceCode = this.opts.code.process(sourceCode, sch));
        let validate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode)(this, this.scope.get());
        if (this.scope.value(validateName, { ref: validate }), validate.errors = null, validate.schema = sch.schema, validate.schemaEnv = sch, sch.$async && (validate.$async = !0), this.opts.code.source === !0 && (validate.source = { validateName, validateCode, scopeValues: gen._values }), this.opts.unevaluated) {
          let { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          }, validate.source && (validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated));
        }
        return sch.validate = validate, sch;
      } catch (e) {
        throw delete sch.validate, delete sch.validateName, sourceCode && this.logger.error("Error compiling schema, function code:", sourceCode), e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      let schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        let schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref], { schemaId } = this.opts;
        schema && (_sch = new SchemaEnv({ schema, schemaId, root, baseId }));
      }
      if (_sch !== void 0)
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      return (0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs) ? sch.schema : sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (let sch of this._compilations)
        if (sameSchemaEnv(sch, schEnv))
          return sch;
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      for (; typeof (sch = this.refs[ref]) == "string"; )
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      let p = this.opts.uriResolver.parse(ref), refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p), baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId)
        return getJsonPointer.call(this, p, root);
      let id = (0, resolve_1.normalizeId)(refPath), schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        let sch = resolveSchema.call(this, root, schOrRef);
        return typeof sch?.schema != "object" ? void 0 : getJsonPointer.call(this, p, sch);
      }
      if (typeof schOrRef?.schema == "object") {
        if (schOrRef.validate || compileSchema.call(this, schOrRef), id === (0, resolve_1.normalizeId)(ref)) {
          let { schema } = schOrRef, { schemaId } = this.opts, schId = schema[schemaId];
          return schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId)), new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
      }
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (let part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
          return;
        let partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        let schId = typeof schema == "object" && schema[this.opts.schemaId];
        !PREVENT_SCOPE_CHANGE.has(part) && schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId));
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        let $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      let { schemaId } = this.opts;
      if (env = env || new SchemaEnv({ schema, schemaId, root, baseId }), env.schema !== env.root.schema)
        return env;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: !1
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "", code = 0, i = 0;
      for (i = 0; i < input.length; i++)
        if (code = input[i].charCodeAt(0), code !== 48) {
          if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
            return "";
          acc += input[i];
          break;
        }
      for (i += 1; i < input.length; i++) {
        if (code = input[i].charCodeAt(0), !(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
          return "";
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      return buffer.length = 0, !0;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        let hex3 = stringArrayToHexStripped(buffer);
        if (hex3 !== "")
          address.push(hex3);
        else
          return output.error = !0, !1;
        buffer.length = 0;
      }
      return !0;
    }
    function getIPV6(input) {
      let tokenCount = 0, output = { error: !1, address: "", zone: "" }, address = [], buffer = [], endipv6Encountered = !1, endIpv6 = !1, consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        let cursor = input[i];
        if (!(cursor === "[" || cursor === "]"))
          if (cursor === ":") {
            if (endipv6Encountered === !0 && (endIpv6 = !0), !consume(buffer, address, output))
              break;
            if (++tokenCount > 7) {
              output.error = !0;
              break;
            }
            i > 0 && input[i - 1] === ":" && (endipv6Encountered = !0), address.push(":");
            continue;
          } else if (cursor === "%") {
            if (!consume(buffer, address, output))
              break;
            consume = consumeIsZone;
          } else {
            buffer.push(cursor);
            continue;
          }
      }
      return buffer.length && (consume === consumeIsZone ? output.zone = buffer.join("") : endIpv6 ? address.push(buffer.join("")) : address.push(stringArrayToHexStripped(buffer))), output.address = address.join(""), output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2)
        return { host, isIPV6: !1 };
      let ipv63 = getIPV6(host);
      if (ipv63.error)
        return { host, isIPV6: !1 };
      {
        let newHost = ipv63.address, escapedHost = ipv63.address;
        return ipv63.zone && (newHost += "%" + ipv63.zone, escapedHost += "%25" + ipv63.zone), { host: newHost, isIPV6: !0, escapedHost };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++)
        str[i] === token && ind++;
      return ind;
    }
    function removeDotSegments(path) {
      let input = path, output = [], nextSlash = -1, len = 0;
      for (; len = input.length; ) {
        if (len === 1) {
          if (input === ".")
            break;
          if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".")
              break;
            if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/" && (input[1] === "." || input[1] === "/")) {
            output.push("/");
            break;
          }
        } else if (len === 3 && input === "/..") {
          output.length !== 0 && output.pop(), output.push("/");
          break;
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/" && input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === "." && input[3] === "/") {
            input = input.slice(3), output.length !== 0 && output.pop();
            continue;
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else
          output.push(input.slice(0, nextSlash)), input = input.slice(nextSlash);
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      let func = esc2 !== !0 ? escape : unescape;
      return component.scheme !== void 0 && (component.scheme = func(component.scheme)), component.userinfo !== void 0 && (component.userinfo = func(component.userinfo)), component.host !== void 0 && (component.host = func(component.host)), component.path !== void 0 && (component.path = func(component.path)), component.query !== void 0 && (component.query = func(component.query)), component.fragment !== void 0 && (component.fragment = func(component.fragment)), component;
    }
    function recomposeAuthority(component) {
      let uriTokens = [];
      if (component.userinfo !== void 0 && (uriTokens.push(component.userinfo), uriTokens.push("@")), component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          let ipV6res = normalizeIPv6(host);
          ipV6res.isIPV6 === !0 ? host = `[${ipV6res.escapedHost}]` : host = component.host;
        }
        uriTokens.push(host);
      }
      return (typeof component.port == "number" || typeof component.port == "string") && (uriTokens.push(":"), uriTokens.push(String(component.port))), uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var { isUUID } = require_utils(), URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      return wsComponent.secure === !0 ? !0 : wsComponent.secure === !1 ? !1 : wsComponent.scheme ? wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S") : !1;
    }
    function httpParse(component) {
      return component.host || (component.error = component.error || "HTTP URIs must have a host."), component;
    }
    function httpSerialize(component) {
      let secure = String(component.scheme).toLowerCase() === "https";
      return (component.port === (secure ? 443 : 80) || component.port === "") && (component.port = void 0), component.path || (component.path = "/"), component;
    }
    function wsParse(wsComponent) {
      return wsComponent.secure = wsIsSecure(wsComponent), wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : ""), wsComponent.path = void 0, wsComponent.query = void 0, wsComponent;
    }
    function wsSerialize(wsComponent) {
      if ((wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") && (wsComponent.port = void 0), typeof wsComponent.secure == "boolean" && (wsComponent.scheme = wsComponent.secure ? "wss" : "ws", wsComponent.secure = void 0), wsComponent.resourceName) {
        let [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0, wsComponent.query = query, wsComponent.resourceName = void 0;
      }
      return wsComponent.fragment = void 0, wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path)
        return urnComponent.error = "URN can not be parsed", urnComponent;
      let matches = urnComponent.path.match(URN_REG);
      if (matches) {
        let scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase(), urnComponent.nss = matches[2];
        let urnScheme = `${scheme}:${options.nid || urnComponent.nid}`, schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0, schemeHandler && (urnComponent = schemeHandler.parse(urnComponent, options));
      } else
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      let scheme = options.scheme || urnComponent.scheme || "urn", nid = urnComponent.nid.toLowerCase(), urnScheme = `${scheme}:${options.nid || nid}`, schemeHandler = getSchemeHandler(urnScheme);
      schemeHandler && (urnComponent = schemeHandler.serialize(urnComponent, options));
      let uriComponent = urnComponent, nss = urnComponent.nss;
      return uriComponent.path = `${nid || options.nid}:${nss}`, options.skipEscape = !0, uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      let uuidComponent = urnComponent;
      return uuidComponent.uuid = uuidComponent.nss, uuidComponent.nss = void 0, !options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid)) && (uuidComponent.error = uuidComponent.error || "UUID is not valid."), uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      let urnComponent = uuidComponent;
      return urnComponent.nss = (uuidComponent.uuid || "").toLowerCase(), urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: wsParse,
        serialize: wsSerialize
      }
    ), wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    ), urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: !0
      }
    ), urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: !0
      }
    ), SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module2.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils(), { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      return typeof uri == "string" ? uri = /** @type {T} */
      serialize(parse3(uri, options), options) : typeof uri == "object" && (uri = /** @type {T} */
      parse3(serialize(uri, options), options)), uri;
    }
    function resolve(baseURI, relativeURI, options) {
      let schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" }, resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, !0);
      return schemelessOptions.skipEscape = !0, serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      let target = {};
      return skipNormalization || (base = parse3(serialize(base, options), options), relative = parse3(serialize(relative, options), options)), options = options || {}, !options.tolerant && relative.scheme ? (target.scheme = relative.scheme, target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0 ? (target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.path ? (relative.path[0] === "/" ? target.path = removeDotSegments(relative.path) : ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path ? target.path = "/" + relative.path : base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path, target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, relative.query !== void 0 ? target.query = relative.query : target.query = base.query), target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), target.scheme = base.scheme), target.fragment = relative.fragment, target;
    }
    function equal(uriA, uriB, options) {
      return typeof uriA == "string" ? (uriA = unescape(uriA), uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), !0), { ...options, skipEscape: !0 })) : typeof uriA == "object" && (uriA = serialize(normalizeComponentEncoding(uriA, !0), { ...options, skipEscape: !0 })), typeof uriB == "string" ? (uriB = unescape(uriB), uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), !0), { ...options, skipEscape: !0 })) : typeof uriB == "object" && (uriB = serialize(normalizeComponentEncoding(uriB, !0), { ...options, skipEscape: !0 })), uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      let component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      }, options = Object.assign({}, opts), uriTokens = [], schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      schemeHandler && schemeHandler.serialize && schemeHandler.serialize(component, options), component.path !== void 0 && (options.skipEscape ? component.path = unescape(component.path) : (component.path = escape(component.path), component.scheme !== void 0 && (component.path = component.path.split("%3A").join(":")))), options.reference !== "suffix" && component.scheme && uriTokens.push(component.scheme, ":");
      let authority = recomposeAuthority(component);
      if (authority !== void 0 && (options.reference !== "suffix" && uriTokens.push("//"), uriTokens.push(authority), component.path && component.path[0] !== "/" && uriTokens.push("/")), component.path !== void 0) {
        let s = component.path;
        !options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath) && (s = removeDotSegments(s)), authority === void 0 && s[0] === "/" && s[1] === "/" && (s = "/%2F" + s.slice(2)), uriTokens.push(s);
      }
      return component.query !== void 0 && uriTokens.push("?", component.query), component.fragment !== void 0 && uriTokens.push("#", component.fragment), uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      let options = Object.assign({}, opts), parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, isIP = !1;
      options.reference === "suffix" && (options.scheme ? uri = options.scheme + ":" + uri : uri = "//" + uri);
      let matches = uri.match(URI_PARSE);
      if (matches) {
        if (parsed.scheme = matches[1], parsed.userinfo = matches[3], parsed.host = matches[4], parsed.port = parseInt(matches[5], 10), parsed.path = matches[6] || "", parsed.query = matches[7], parsed.fragment = matches[8], isNaN(parsed.port) && (parsed.port = matches[5]), parsed.host)
          if (isIPv4(parsed.host) === !1) {
            let ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase(), isIP = ipv6result.isIPV6;
          } else
            isIP = !0;
        parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path ? parsed.reference = "same-document" : parsed.scheme === void 0 ? parsed.reference = "relative" : parsed.fragment === void 0 ? parsed.reference = "absolute" : parsed.reference = "uri", options.reference && options.reference !== "suffix" && options.reference !== parsed.reference && (parsed.error = parsed.error || "URI is not a " + options.reference + " reference.");
        let schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport) && parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === !1 && nonSimpleDomain(parsed.host))
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) && (uri.indexOf("%") !== -1 && (parsed.scheme !== void 0 && (parsed.scheme = unescape(parsed.scheme)), parsed.host !== void 0 && (parsed.host = unescape(parsed.host))), parsed.path && (parsed.path = escape(unescape(parsed.path))), parsed.fragment && (parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment)))), schemeHandler && schemeHandler.parse && schemeHandler.parse(parsed, options);
      } else
        parsed.error = parsed.error || "URI can not be parsed.";
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error(), ref_error_1 = require_ref_error(), rules_1 = require_rules(), compile_1 = require_compile(), codegen_2 = require_codegen(), resolve_1 = require_resolve(), dataType_1 = require_dataType(), util_1 = require_util(), $dataRefSchema = require_data(), uri_1 = require_uri(), defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"], EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      let s = o.strict, _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize, optimize = _optz === !0 || _optz === void 0 ? 1 : _optz || 0, regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp, uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : !0,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : !0,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : !1,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : !0,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : !0,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : !0,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : !0,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : !0,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : !0,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : !0,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : !0,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), opts = this.opts = { ...opts, ...requiredOptions(opts) };
        let { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines }), this.logger = getLogger(opts.logger);
        let formatOpt = opts.validateFormats;
        opts.validateFormats = !1, this.RULES = (0, rules_1.getRules)(), checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED"), checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn"), this._metaOpts = getMetaSchemaOptions.call(this), opts.formats && addInitialFormats.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), opts.keywords && addInitialKeywords.call(this, opts.keywords), typeof opts.meta == "object" && this.addMetaSchema(opts.meta), addInitialSchemas.call(this), opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data, meta: meta3, schemaId } = this.opts, _dataRefSchema = $dataRefSchema;
        schemaId === "id" && (_dataRefSchema = { ...$dataRefSchema }, _dataRefSchema.id = _dataRefSchema.$id, delete _dataRefSchema.$id), meta3 && $data && this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], !1);
      }
      defaultMeta() {
        let { meta: meta3, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          if (v = this.getSchema(schemaKeyRef), !v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else
          v = this.compile(schemaKeyRef);
        let valid = v(data);
        return "$async" in v || (this.errors = v.errors), valid;
      }
      compile(schema, _meta) {
        let sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta3) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        let { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta3);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          let sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          $ref && !this.getSchema($ref) && await runCompileAsync.call(this, { $ref }, !0);
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            return checkLoaded.call(this, e), await loadMissingSchema.call(this, e.missingSchema), _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref])
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
        async function loadMissingSchema(ref) {
          let _schema = await _loadSchema.call(this, ref);
          this.refs[ref] || await loadMetaSchema.call(this, _schema.$schema), this.refs[ref] || this.addSchema(_schema, ref, meta3);
        }
        async function _loadSchema(ref) {
          let p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (let sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema == "object") {
          let { schemaId } = this.opts;
          if (id = schema[schemaId], id !== void 0 && typeof id != "string")
            throw new Error(`schema ${schemaId} must be string`);
        }
        return key = (0, resolve_1.normalizeId)(key || id), this._checkUnique(key), this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        return this.addSchema(schema, key, !0, _validateSchema), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return !0;
        let $schema;
        if ($schema = schema.$schema, $schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        if ($schema = $schema || this.opts.defaultMeta || this.defaultMeta(), !$schema)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        let valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          let message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        for (; typeof (sch = getSchEnv.call(this, keyRef)) == "string"; )
          keyRef = sch;
        if (sch === void 0) {
          let { schemaId } = this.opts, root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          if (sch = compile_1.resolveSchema.call(this, root, keyRef), !sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp)
          return this._removeAllSchemas(this.schemas, schemaKeyRef), this._removeAllSchemas(this.refs, schemaKeyRef), this;
        switch (typeof schemaKeyRef) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            let sch = getSchEnv.call(this, schemaKeyRef);
            return typeof sch == "object" && this._cache.delete(sch.schema), delete this.schemas[schemaKeyRef], delete this.refs[schemaKeyRef], this;
          }
          case "object": {
            let cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            return id && (id = (0, resolve_1.normalizeId)(id), delete this.schemas[id], delete this.refs[id]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (let def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string")
          keyword = kwdOrDef, typeof def == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), def.keyword = keyword);
        else if (typeof kwdOrDef == "object" && def === void 0) {
          if (def = kwdOrDef, keyword = def.keyword, Array.isArray(keyword) && !keyword.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (checkKeyword.call(this, keyword, def), !def)
          return (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd)), this;
        keywordMetaschema.call(this, def);
        let definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        return (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))), this;
      }
      getKeyword(keyword) {
        let rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        let { RULES } = this;
        delete RULES.keywords[keyword], delete RULES.all[keyword];
        for (let group of RULES.rules) {
          let i = group.rules.findIndex((rule) => rule.keyword === keyword);
          i >= 0 && group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        return typeof format == "string" && (format = new RegExp(format)), this.formats[name] = format, this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        return !errors || errors.length === 0 ? "No errors" : errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        let rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (let jsonPointer of keywordsJsonPointers) {
          let segments = jsonPointer.split("/").slice(1), keywords = metaSchema;
          for (let seg of segments)
            keywords = keywords[seg];
          for (let key in rules) {
            let rule = rules[key];
            if (typeof rule != "object")
              continue;
            let { $data } = rule.definition, schema = keywords[key];
            $data && schema && (keywords[key] = schemaOrData(schema));
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (let keyRef in schemas) {
          let sch = schemas[keyRef];
          (!regex || regex.test(keyRef)) && (typeof sch == "string" ? delete schemas[keyRef] : sch && !sch.meta && (this._cache.delete(sch.schema), delete schemas[keyRef]));
        }
      }
      _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id, { schemaId } = this.opts;
        if (typeof schema == "object")
          id = schema[schemaId];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        let localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        return sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs }), this._cache.set(sch.schema, sch), addSchema && !baseId.startsWith("#") && (baseId && this._checkUnique(baseId), this.refs[baseId] = sch), validateSchema && this.validateSchema(schema, !0), sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id])
          throw new Error(`schema with key or id "${id}" already exists`);
      }
      _compileSchemaEnv(sch) {
        if (sch.meta ? this._compileMetaSchema(sch) : compile_1.compileSchema.call(this, sch), !sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        let currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports2.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (let key in checkOpts) {
        let opt = key;
        opt in options && this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      return keyRef = (0, resolve_1.normalizeId)(keyRef), this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      let optsSchemas = this.opts.schemas;
      if (optsSchemas)
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (let key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (let name in this.opts.formats) {
        let format = this.opts.formats[name];
        format && this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let keyword in defs) {
        let def = defs[keyword];
        def.keyword || (def.keyword = keyword), this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      let metaOpts = { ...this.opts };
      for (let opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === !1)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      let { RULES } = this;
      if ((0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      }), !!def && def.$data && !("code" in def || "validate" in def))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      let post = definition?.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      let { RULES } = this, ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (ruleGroup || (ruleGroup = { type: dataType, rules: [] }, RULES.rules.push(ruleGroup)), RULES.keywords[keyword] = !0, !definition)
        return;
      let rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      definition.before ? addBeforeRule.call(this, ruleGroup, rule, definition.before) : ruleGroup.rules.push(rule), RULES.all[keyword] = rule, (_a2 = definition.implements) === null || _a2 === void 0 || _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      let i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      i >= 0 ? ruleGroup.rules.splice(i, 0, rule) : (ruleGroup.rules.push(rule), this.logger.warn(`rule ${before} is not defined`));
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      metaSchema !== void 0 && (def.$data && this.opts.$data && (metaSchema = schemaOrData(metaSchema)), def.validateSchema = this.compile(metaSchema, !0));
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error(), code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), compile_1 = require_compile(), util_1 = require_util(), def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        let { gen, schema: $ref, it } = cxt, { baseId, schemaEnv: env, validateName, opts, self } = it, { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        let schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          let rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          let v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          let schName = gen.scopeValue("schema", opts.code.source === !0 ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch }), valid = gen.name("valid"), schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt), cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      let { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      let { gen, it } = cxt, { allErrors, schemaEnv: env, opts } = it, passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      $async ? callAsyncRef() : callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        let valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`), addEvaluatedFrom(v), allErrors || gen.assign(valid, !0);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e)), addErrorsFrom(e), allErrors || gen.assign(valid, !1);
        }), cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        let errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`), gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        let schEvaluated = (_a2 = sch?.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== !0)
          if (schEvaluated && !schEvaluated.dynamicProps)
            schEvaluated.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props));
          else {
            let props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        if (it.items !== !0)
          if (schEvaluated && !schEvaluated.dynamicItems)
            schEvaluated.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items));
          else {
            let items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var id_1 = require_id(), ref_1 = require_ref(), core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    }, def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    }, def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, it } = cxt, prec = it.opts.multipleOfPrecision, res = gen.let("res"), invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    function ucs2length(str) {
      let len = str.length, length = 0, pos = 0, value;
      for (; pos < len; )
        length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), (value & 64512) === 56320 && pos++);
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), ucs2length_1 = require_ucs2length(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode, it } = cxt, op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT, len = it.opts.unicode === !1 ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    }, def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { data, $data, schema, schemaCode, it } = cxt, u = it.opts.unicodeRegExp ? "u" : "", regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    }, def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, schemaCode, data, $data, it } = cxt, { opts } = it;
        if (!$data && schema.length === 0)
          return;
        let useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors ? allErrorsMode() : exitOnErrorMode(), opts.strictRequired) {
          let props = cxt.parentSchema.properties, { definedProperties } = cxt.it;
          for (let requiredKey of schema)
            if (props?.[requiredKey] === void 0 && !definedProperties.has(requiredKey)) {
              let schemaPath = it.schemaEnv.baseId + it.errSchemaPath, msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
        }
        function allErrorsMode() {
          if (useLoop || $data)
            cxt.block$data(codegen_1.nil, loopAllRequired);
          else
            for (let prop of schema)
              (0, code_1.checkReportMissingProp)(cxt, prop);
        }
        function exitOnErrorMode() {
          let missing = gen.let("missing");
          if (useLoop || $data) {
            let valid = gen.let("valid", !0);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid)), cxt.ok(valid);
          } else
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing)), (0, code_1.reportMissingProp)(cxt, missing), gen.else();
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop }), gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing }), gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties)), gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(), gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var dataType_1 = require_dataType(), codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    }, def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        let valid = gen.let("valid"), itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`), cxt.ok(valid);
        function validateUniqueItems() {
          let i = gen.let("i", (0, codegen_1._)`${data}.length`), j = gen.let("j");
          cxt.setParams({ i, j }), gen.assign(valid, !0), gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          let item = gen.name("item"), wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong), indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`), gen.if(wrongType, (0, codegen_1._)`continue`), itemTypes.length > 1 && gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`), gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`), cxt.error(), gen.assign(valid, !1).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          let eql = (0, util_1.useFunc)(gen, equal_1.default), outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error(), gen.assign(valid, !1).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    }, def = {
      keyword: "const",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schemaCode, schema } = cxt;
        $data || schema && typeof schema == "object" ? cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`) : cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    }, def = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        let useLoop = schema.length >= it.opts.loopEnum, eql, getEql = () => eql ?? (eql = (0, util_1.useFunc)(gen, equal_1.default)), valid;
        if (useLoop || $data)
          valid = gen.let("valid"), cxt.block$data(valid, loopEnum);
        else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          let vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, !1), gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, !0).break()));
        }
        function equalCode(vSchema, i) {
          let sch = schema[i];
          return typeof sch == "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var limitNumber_1 = require_limitNumber(), multipleOf_1 = require_multipleOf(), limitLength_1 = require_limitLength(), pattern_1 = require_pattern(), limitProperties_1 = require_limitProperties(), required_1 = require_required(), limitItems_1 = require_limitItems(), uniqueItems_1 = require_uniqueItems(), const_1 = require_const(), enum_1 = require_enum(), validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { parentSchema, it } = cxt, { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      let { gen, schema, data, keyword, it } = cxt;
      it.items = !0;
      let len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === !1)
        cxt.setParams({ len: items.length }), cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        let valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid)), cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid), it.allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        let { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      let { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema), it.opts.unevaluated && schArr.length && it.items !== !0 && (it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items));
      let valid = gen.name("valid"), len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        (0, util_1.alwaysValidSchema)(it, sch) || (gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid)), cxt.ok(valid));
      });
      function checkStrictTuple(sch) {
        let { opts, errSchemaPath } = it, l = schArr.length, fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === !1);
        if (opts.strictTuples && !fullTuple) {
          let msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var items_1 = require_items(), def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), additionalItems_1 = require_additionalItems(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { schema, parentSchema, it } = cxt, { prefixItems } = parentSchema;
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && (prefixItems ? (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems) : cxt.ok((0, code_1.validateArray)(cxt)));
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    }, def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt, min, max, { minContains, maxContains } = parentSchema;
        it.opts.next ? (min = minContains === void 0 ? 1 : minContains, max = maxContains) : min = 1;
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (cxt.setParams({ min, max }), max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid'), cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          max !== void 0 && (cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`), cxt.pass(cond);
          return;
        }
        it.items = !0;
        let valid = gen.name("valid");
        max === void 0 && min === 1 ? validateItems(valid, () => gen.if(valid, () => gen.break())) : min === 0 ? (gen.let(valid, !0), max !== void 0 && gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount)) : (gen.let(valid, !1), validateItemsWithCount()), cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          let schValid = gen.name("_valid"), count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: !0
            }, _valid), block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`), max === void 0 ? gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0).break()) : (gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, !1).break()), min === 1 ? gen.assign(valid, !0) : gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0)));
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        let property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        let [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps), validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      let propertyDeps = {}, schemaDeps = {};
      for (let key in schema) {
        if (key === "__proto__")
          continue;
        let deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      let { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      let missing = gen.let("missing");
      for (let prop in propertyDeps) {
        let deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        let hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        }), it.allErrors ? gen.if(hasProperty, () => {
          for (let depProp of deps)
            (0, code_1.checkReportMissingProp)(cxt, depProp);
        }) : (gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`), (0, code_1.reportMissingProp)(cxt, missing), gen.else());
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      for (let prop in schemaDeps)
        (0, util_1.alwaysValidSchema)(it, schemaDeps[prop]) || (gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            let schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, !0)
          // TODO var
        ), cxt.ok(valid));
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    }, def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error2,
      code(cxt) {
        let { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        let valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key }), cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: !0
          }, valid), gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(!0), it.allErrors || gen.break();
          });
        }), cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), util_1 = require_util(), error2 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    }, def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        let { allErrors, opts } = it;
        if (it.props = !0, opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        let props = (0, code_1.allSchemaProperties)(parentSchema.properties), patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties(), cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            !props.length && !patProps.length ? additionalPropertyCode(key) : gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            let propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else props.length ? definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`)) : definedProp = codegen_1.nil;
          return patProps.length && (definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`))), (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === !1) {
            deleteAdditional(key);
            return;
          }
          if (schema === !1) {
            cxt.setParams({ additionalProperty: key }), cxt.error(), allErrors || gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            let valid = gen.name("valid");
            opts.removeAdditional === "failing" ? (applyAdditionalSchema(key, valid, !1), gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset(), deleteAdditional(key);
            })) : (applyAdditionalSchema(key, valid), allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break()));
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          let subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          errors === !1 && Object.assign(subschema, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var validate_1 = require_validate(), code_1 = require_code2(), util_1 = require_util(), additionalProperties_1 = require_additionalProperties(), def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt;
        it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0 && additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        let allProps = (0, code_1.allSchemaProperties)(schema);
        for (let prop of allProps)
          it.definedProperties.add(prop);
        it.opts.unevaluated && allProps.length && it.props !== !0 && (it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props));
        let properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        let valid = gen.name("valid");
        for (let prop of properties)
          hasDefault(prop) ? applyPropertySchema(prop) : (gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)), applyPropertySchema(prop), it.allErrors || gen.else().var(valid, !0), gen.endIf()), cxt.it.definedProperties.add(prop), cxt.ok(valid);
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), util_2 = require_util(), def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, data, parentSchema, it } = cxt, { opts } = it, patterns = (0, code_1.allSchemaProperties)(schema), alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === !0))
          return;
        let checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties, valid = gen.name("valid");
        it.props !== !0 && !(it.props instanceof codegen_1.Name) && (it.props = (0, util_2.evaluatedPropsToName)(gen, it.props));
        let { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (let pat of patterns)
            checkProperties && checkMatchingProperties(pat), it.allErrors ? validateProperties(pat) : (gen.var(valid, !0), validateProperties(pat), gen.if(valid));
        }
        function checkMatchingProperties(pat) {
          for (let prop in checkProperties)
            new RegExp(pat).test(prop) && (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              let alwaysValid = alwaysValidPatterns.includes(pat);
              alwaysValid || cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid), it.opts.unevaluated && props !== !0 ? gen.assign((0, codegen_1._)`${props}[${key}]`, !0) : !alwaysValid && !it.allErrors && gen.if((0, codegen_1.not)(valid), () => gen.break());
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(cxt) {
        let { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        let valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, valid), cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    }, def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        let schArr = schema, valid = gen.let("valid", !1), passing = gen.let("passing", null), schValid = gen.name("_valid");
        cxt.setParams({ passing }), gen.block(validateOneOf), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            (0, util_1.alwaysValidSchema)(it, sch) ? gen.var(schValid, !0) : schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: !0
            }, schValid), i > 0 && gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, !1).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else(), gen.if(schValid, () => {
              gen.assign(valid, !0), gen.assign(passing, i), schCxt && cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        let { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        let valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          let schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid), cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    }, def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, parentSchema, it } = cxt;
        parentSchema.then === void 0 && parentSchema.else === void 0 && (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        let hasThen = hasSchema(it, "then"), hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        let valid = gen.let("valid", !0), schValid = gen.name("_valid");
        if (validateIf(), cxt.reset(), hasThen && hasElse) {
          let ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause }), gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else hasThen ? gen.if(schValid, validateClause("then")) : gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        cxt.pass(valid, () => cxt.error(!0));
        function validateIf() {
          let schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            let schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid), cxt.mergeValidEvaluated(schCxt, valid), ifClause ? gen.assign(ifClause, (0, codegen_1._)`${keyword}`) : cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      let schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        parentSchema.if === void 0 && (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var additionalItems_1 = require_additionalItems(), prefixItems_1 = require_prefixItems(), items_1 = require_items(), items2020_1 = require_items2020(), contains_1 = require_contains(), dependencies_1 = require_dependencies(), propertyNames_1 = require_propertyNames(), additionalProperties_1 = require_additionalProperties(), properties_1 = require_properties(), patternProperties_1 = require_patternProperties(), not_1 = require_not(), anyOf_1 = require_anyOf(), oneOf_1 = require_oneOf(), allOf_1 = require_allOf(), if_1 = require_if(), thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = !1) {
      let applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      return draft2020 ? applicator.push(prefixItems_1.default, items2020_1.default) : applicator.push(additionalItems_1.default, items_1.default), applicator.push(contains_1.default), applicator;
    }
    exports2.default = getApplicator;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    }, def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt, ruleType) {
        let { gen, data, $data, schema, schemaCode, it } = cxt, { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        $data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`), fType = gen.let("fType"), format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)), cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            return opts.strictSchema === !1 ? codegen_1.nil : (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            let callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`, validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          let formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === !0)
            return;
          let [fmtType, format, fmtRef] = getFormat(formatDef);
          fmtType === ruleType && cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === !1) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            let code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0, fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            return typeof fmtDef == "object" && !(fmtDef instanceof RegExp) ? [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`] : ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var format_1 = require_format(), format = [format_1.default];
    exports2.default = format;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var core_1 = require_core2(), validation_1 = require_validation(), applicator_1 = require_applicator(), format_1 = require_format2(), metadata_1 = require_metadata(), draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2.Tag = "tag", DiscrError2.Mapping = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), types_1 = require_types(), compile_1 = require_compile(), ref_error_1 = require_ref_error(), util_1 = require_util(), error2 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    }, def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error2,
      code(cxt) {
        let { gen, data, schema, parentSchema, it } = cxt, { oneOf } = parentSchema;
        if (!it.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        let tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        let valid = gen.let("valid", !1), tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(!1, { discrError: types_1.DiscrError.Tag, tag, tagName })), cxt.ok(valid);
        function validateMapping() {
          let mapping = getMapping();
          gen.if(!1);
          for (let tagValue in mapping)
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`), gen.assign(valid, applyTagSchema(mapping[tagValue]));
          gen.else(), cxt.error(!1, { discrError: types_1.DiscrError.Mapping, tag, tagName }), gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          let _valid = gen.name("valid"), schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          return cxt.mergeEvaluated(schCxt, codegen_1.Name), _valid;
        }
        function getMapping() {
          var _a2;
          let oneOfMapping = {}, topRequired = hasRequired(parentSchema), tagRequired = !0;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (sch?.$ref && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              let ref = sch.$ref;
              if (sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref), sch instanceof compile_1.SchemaEnv && (sch = sch.schema), sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            let propSch = (_a2 = sch?.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            tagRequired = tagRequired && (topRequired || hasRequired(sch)), addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const)
              addMapping(sch.const, i);
            else if (sch.enum)
              for (let tagValue of sch.enum)
                addMapping(tagValue, i);
            else
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping)
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: !0,
        readOnly: {
          type: "boolean",
          default: !1
        },
        examples: {
          type: "array",
          items: !0
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: !1
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: {
          type: "array",
          items: !0,
          minItems: 1,
          uniqueItems: !0
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: !0
    };
  }
});

// mcp-servers-src/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core(), draft7_1 = require_draft7(), discriminator_1 = require_discriminator(), draft7MetaSchema = require_json_schema_draft_07(), META_SUPPORT_DATA = ["/properties"], META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies(), draft7_1.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        let metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, !1), this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv2;
    module2.exports = exports2 = Ajv2;
    module2.exports.Ajv = Ajv2;
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: !0, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: !0, get: function() {
      return ref_error_1.default;
    } });
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date4, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(!0), compareTime),
      "date-time": fmtDef(getDateTime(!0), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date4(str) {
      let matches = DATE.exec(str);
      if (!matches)
        return !1;
      let year = +matches[1], month = +matches[2], day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (d1 && d2)
        return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function(str) {
        let matches = TIME.exec(str);
        if (!matches)
          return !1;
        let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return !1;
        if (hr <= 23 && min <= 59 && sec < 60)
          return !0;
        let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return;
      let t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf(), t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (t1 && t2)
        return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return;
      let a1 = TIME.exec(t1), a2 = TIME.exec(t2);
      if (a1 && a2)
        return t1 = a1[1] + a1[2] + a1[3], t2 = a2[1] + a2[2] + a2[3], t1 > t2 ? 1 : t1 < t2 ? -1 : 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      let time3 = getTime(strictTimeZone);
      return function(str) {
        let dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date4(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let d1 = new Date(dt1).valueOf(), d2 = new Date(dt2).valueOf();
      if (d1 && d2)
        return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let [d1, t1] = dt1.split(DATE_TIME_SEPARATOR), [d2, t2] = dt2.split(DATE_TIME_SEPARATOR), res = compareDate(d1, d2);
      if (res !== void 0)
        return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      return BYTE.lastIndex = 0, BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31), MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return !0;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return !1;
      try {
        return new RegExp(str), !0;
      } catch {
        return !1;
      }
    }
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv(), codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, keyword, it } = cxt, { opts, self } = it;
        if (!opts.validateFormats)
          return;
        let fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        fCxt.$data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          let format = fCxt.schema, fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === !0)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function")
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          let fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => (ajv.addKeyword(exports2.formatLimitDefinition), ajv);
    exports2.default = formatLimitPlugin;
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var formats_1 = require_formats(), limit_1 = require_limit(), codegen_1 = require_codegen(), fullName = new codegen_1.Name("fullFormats"), fastName = new codegen_1.Name("fastFormats"), formatsPlugin = (ajv, opts = { keywords: !0 }) => {
      if (Array.isArray(opts))
        return addFormats(ajv, opts, formats_1.fullFormats, fullName), ajv;
      let [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName], list = opts.formats || formats_1.formatNames;
      return addFormats(ajv, list, formats, exportName), opts.keywords && (0, limit_1.default)(ajv), ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      let f = (mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats)[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a2, _b;
      (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== void 0 || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
      for (let f of list)
        ajv.addFormat(f, fs[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.default = formatsPlugin;
  }
});

// mcp-servers-src/node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2, util2.arrayToEnum = (items) => {
    let obj = {};
    for (let item of items)
      obj[item] = item;
    return obj;
  }, util2.getValidEnumValues = (obj) => {
    let validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] != "number"), filtered = {};
    for (let k of validKeys)
      filtered[k] = obj[k];
    return util2.objectValues(filtered);
  }, util2.objectValues = (obj) => util2.objectKeys(obj).map(function(e) {
    return obj[e];
  }), util2.objectKeys = typeof Object.keys == "function" ? (obj) => Object.keys(obj) : (object3) => {
    let keys = [];
    for (let key in object3)
      Object.prototype.hasOwnProperty.call(object3, key) && keys.push(key);
    return keys;
  }, util2.find = (arr, checker) => {
    for (let item of arr)
      if (checker(item))
        return item;
  }, util2.isInteger = typeof Number.isInteger == "function" ? (val) => Number.isInteger(val) : (val) => typeof val == "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val == "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2, util2.jsonStringifyReplacer = (_, value) => typeof value == "bigint" ? value.toString() : value;
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => ({
    ...first,
    ...second
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (data) => {
  switch (typeof data) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(data) ? ZodParsedType.array : data === null ? ZodParsedType.null : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && data instanceof Map ? ZodParsedType.map : typeof Set < "u" && data instanceof Set ? ZodParsedType.set : typeof Date < "u" && data instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// mcp-servers-src/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super(), this.issues = [], this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    }, this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    let actualProto = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, actualProto) : this.__proto__ = actualProto, this.name = "ZodError", this.issues = issues;
  }
  format(_mapper) {
    let mapper = _mapper || function(issue2) {
      return issue2.message;
    }, fieldErrors = { _errors: [] }, processError = (error2) => {
      for (let issue2 of error2.issues)
        if (issue2.code === "invalid_union")
          issue2.unionErrors.map(processError);
        else if (issue2.code === "invalid_return_type")
          processError(issue2.returnTypeError);
        else if (issue2.code === "invalid_arguments")
          processError(issue2.argumentsError);
        else if (issue2.path.length === 0)
          fieldErrors._errors.push(mapper(issue2));
        else {
          let curr = fieldErrors, i = 0;
          for (; i < issue2.path.length; ) {
            let el = issue2.path[i];
            i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
          }
        }
    };
    return processError(this), fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError))
      throw new Error(`Not a ZodError: ${value}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    let fieldErrors = /* @__PURE__ */ Object.create(null), formErrors = [];
    for (let sub of this.issues)
      if (sub.path.length > 0) {
        let firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [], fieldErrors[firstEl].push(mapper(sub));
      } else
        formErrors.push(mapper(sub));
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => new ZodError(issues);

// mcp-servers-src/node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      issue2.received === ZodParsedType.undefined ? message = "Required" : message = `Expected ${issue2.expected}, received ${issue2.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      message = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      message = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof issue2.validation == "object" ? "includes" in issue2.validation ? (message = `Invalid input: must include "${issue2.validation.includes}"`, typeof issue2.validation.position == "number" && (message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`)) : "startsWith" in issue2.validation ? message = `Invalid input: must start with "${issue2.validation.startsWith}"` : "endsWith" in issue2.validation ? message = `Invalid input: must end with "${issue2.validation.endsWith}"` : util.assertNever(issue2.validation) : issue2.validation !== "regex" ? message = `Invalid ${issue2.validation}` : message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "more than"} ${issue2.minimum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "over"} ${issue2.minimum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "bigint" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue2.minimum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "less than"} ${issue2.maximum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "under"} ${issue2.maximum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "bigint" ? message = `BigInt must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly" : issue2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue2.maximum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError, util.assertNever(issue2);
  }
  return { message };
}, en_default = errorMap;

// mcp-servers-src/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// mcp-servers-src/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  let { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0)
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  let errorMessage = "", maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (let map2 of maps)
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  let overrideMap = getErrorMap(), issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(status, results) {
    let arrayValue = [];
    for (let s of results) {
      if (s.status === "aborted")
        return INVALID;
      s.status === "dirty" && status.dirty(), arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    let syncPairs = [];
    for (let pair of pairs) {
      let key = await pair.key, value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    let finalObject = {};
    for (let pair of pairs) {
      let { key, value } = pair;
      if (key.status === "aborted" || value.status === "aborted")
        return INVALID;
      key.status === "dirty" && status.dirty(), value.status === "dirty" && status.dirty(), key.value !== "__proto__" && (typeof value.value < "u" || pair.alwaysSet) && (finalObject[key.value] = value.value);
    }
    return { status: status.value, value: finalObject };
  }
}, INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise < "u" && x instanceof Promise;

// mcp-servers-src/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message == "string" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message == "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// mcp-servers-src/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}, handleResult = (ctx, result) => {
  if (isValid(result))
    return { success: !0, data: result.value };
  if (!ctx.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      let error2 = new ZodError(ctx.common.issues);
      return this._error = error2, this._error;
    }
  };
};
function processCreateParams(params) {
  if (!params)
    return {};
  let { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return errorMap2 ? { errorMap: errorMap2, description } : { errorMap: (iss, ctx) => {
    let { message } = params;
    return iss.code === "invalid_enum_value" ? { message: message ?? ctx.defaultError } : typeof ctx.data > "u" ? { message: message ?? required_error ?? ctx.defaultError } : iss.code !== "invalid_type" ? { message: ctx.defaultError } : { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    let result = this._parse(input);
    if (isAsync(result))
      throw new Error("Synchronous parse encountered promise.");
    return result;
  }
  _parseAsync(input) {
    let result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    let result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    let ctx = {
      common: {
        issues: [],
        async: params?.async ?? !1,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    let ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async)
      try {
        let result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        err?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), ctx.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    let result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    let ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: !0
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    let getIssueProperties = (val) => typeof message == "string" || typeof message > "u" ? { message } : typeof message == "function" ? message(val) : message;
    return this._refinement((val, ctx) => {
      let result = check2(val), setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      return typeof Promise < "u" && result instanceof Promise ? result.then((data) => data ? !0 : (setError(), !1)) : result ? !0 : (setError(), !1);
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => check2(val) ? !0 : (ctx.addIssue(typeof refinementData == "function" ? refinementData(val, ctx) : refinementData), !1));
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    let defaultValueFunc = typeof def == "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    let catchValueFunc = typeof def == "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    let This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", emojiRegex, ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = "[0-5]\\d";
  args.precision ? secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}` : args.precision == null && (secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`);
  let secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`, opts = [];
  return opts.push(args.local ? "Z?" : "Z"), args.offset && opts.push("([+-]\\d{2}:?\\d{2})"), regex = `${regex}(${opts.join("|")})`, new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4Regex.test(ip) || (version2 === "v6" || !version2) && ipv6Regex.test(ip));
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return !1;
  try {
    let [header] = jwt2.split(".");
    if (!header)
      return !1;
    let base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "="), decoded = JSON.parse(atob(base643));
    return !(typeof decoded != "object" || decoded === null || "typ" in decoded && decoded?.typ !== "JWT" || !decoded.alg || alg && decoded.alg !== alg);
  } catch {
    return !1;
  }
}
function isValidCidr(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip) || (version2 === "v6" || !version2) && ipv6CidrRegex.test(ip));
}
var ZodString = class _ZodString2 extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = String(input.data)), this._getType(input) !== ZodParsedType.string) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      if (check2.kind === "min")
        input.data.length < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "max")
        input.data.length > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "length") {
        let tooBig = input.data.length > check2.value, tooSmall = input.data.length < check2.value;
        (tooBig || tooSmall) && (ctx = this._getOrReturnCtx(input, ctx), tooBig ? addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }) : tooSmall && addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }), status.dirty());
      } else if (check2.kind === "email")
        emailRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "uuid")
        uuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "nanoid")
        nanoidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid")
        cuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid2")
        cuid2Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "ulid")
        ulidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "url")
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          }), status.dirty();
        }
      else check2.kind === "regex" ? (check2.regex.lastIndex = 0, check2.regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "regex",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty())) : check2.kind === "trim" ? input.data = input.data.trim() : check2.kind === "includes" ? input.data.includes(check2.value, check2.position) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { includes: check2.value, position: check2.position },
        message: check2.message
      }), status.dirty()) : check2.kind === "toLowerCase" ? input.data = input.data.toLowerCase() : check2.kind === "toUpperCase" ? input.data = input.data.toUpperCase() : check2.kind === "startsWith" ? input.data.startsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { startsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "endsWith" ? input.data.endsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { endsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "datetime" ? datetimeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "datetime",
        message: check2.message
      }), status.dirty()) : check2.kind === "date" ? dateRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "date",
        message: check2.message
      }), status.dirty()) : check2.kind === "time" ? timeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "time",
        message: check2.message
      }), status.dirty()) : check2.kind === "duration" ? durationRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "duration",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "ip" ? isValidIP(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "ip",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "jwt" ? isValidJWT(input.data, check2.alg) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "jwt",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "cidr" ? isValidCidr(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "cidr",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64" ? base64Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64url" ? base64urlRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64url",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: options
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      offset: options?.offset ?? !1,
      local: options?.local ?? !1,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: options
    }) : this._addCheck({
      kind: "time",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxLength() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodString.create = (params) => new ZodString({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodString,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
function floatSafeRemainder(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepDecCount = (step.toString().split(".")[1] || "").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce && (input.data = Number(input.data)), this._getType(input) !== ZodParsedType.number) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      }), INVALID;
    }
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "int" ? util.isInteger(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: check2.message
      }), status.dirty()) : check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? floatSafeRemainder(input.data, check2.value) !== 0 && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : check2.kind === "finite" ? Number.isFinite(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_finite,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (let ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
        return !0;
      ch.kind === "min" ? (min === null || ch.value > min) && (min = ch.value) : ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce)
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    if (this._getType(input) !== ZodParsedType.bigint)
      return this._getInvalidInput(input);
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? input.data % check2.value !== BigInt(0) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    }), INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodBigInt.create = (params) => new ZodBigInt({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodBigInt,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = !!input.data), this._getType(input) !== ZodParsedType.boolean) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = new Date(input.data)), this._getType(input) !== ZodParsedType.date) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      }), INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      check2.kind === "min" ? input.data.getTime() < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        minimum: check2.value,
        type: "date"
      }), status.dirty()) : check2.kind === "max" ? input.data.getTime() > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        maximum: check2.value,
        type: "date"
      }), status.dirty()) : util.assertNever(check2);
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => new ZodDate({
  checks: [],
  coerce: params?.coerce || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(params)
});
var ZodSymbol = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.symbol) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(params)
});
var ZodUndefined = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(params)
});
var ZodNull = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.null) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(params)
});
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(params)
});
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(params)
});
var ZodNever = class extends ZodType {
  _parse(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    }), INVALID;
  }
};
ZodNever.create = (params) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(params)
});
var ZodVoid = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(params)
});
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    let { ctx, status } = this._processInputParams(input), def = this._def;
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (def.exactLength !== null) {
      let tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;
      (tooBig || tooSmall) && (addIssueToContext(ctx, {
        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: tooSmall ? def.exactLength.value : void 0,
        maximum: tooBig ? def.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: def.exactLength.message
      }), status.dirty());
    }
    if (def.minLength !== null && ctx.data.length < def.minLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.minLength.message
    }), status.dirty()), def.maxLength !== null && ctx.data.length > def.maxLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.maxLength.message
    }), status.dirty()), ctx.common.async)
      return Promise.all([...ctx.data].map((item, i) => def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result2) => ParseStatus.mergeArray(status, result2));
    let result = [...ctx.data].map((item, i) => def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => new ZodArray({
  type: schema,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(params)
});
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    let newShape = {};
    for (let key in schema.shape) {
      let fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else return schema instanceof ZodArray ? new ZodArray({
    ...schema._def,
    type: deepPartialify(schema.element)
  }) : schema instanceof ZodOptional ? ZodOptional.create(deepPartialify(schema.unwrap())) : schema instanceof ZodNullable ? ZodNullable.create(deepPartialify(schema.unwrap())) : schema instanceof ZodTuple ? ZodTuple.create(schema.items.map((item) => deepPartialify(item))) : schema;
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    let shape = this._def.shape(), keys = util.objectKeys(shape);
    return this._cached = { shape, keys }, this._cached;
  }
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.object) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      }), INVALID;
    }
    let { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (let key in ctx.data)
        shapeKeys.includes(key) || extraKeys.push(key);
    let pairs = [];
    for (let key of shapeKeys) {
      let keyValidator = shape[key], value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      let unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough")
        for (let key of extraKeys)
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
      else if (unknownKeys === "strict")
        extraKeys.length > 0 && (addIssueToContext(ctx, {
          code: ZodIssueCode.unrecognized_keys,
          keys: extraKeys
        }), status.dirty());
      else if (unknownKeys !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let catchall = this._def.catchall;
      for (let key of extraKeys) {
        let value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    return ctx.common.async ? Promise.resolve().then(async () => {
      let syncPairs = [];
      for (let pair of pairs) {
        let key = await pair.key, value = await pair.value;
        syncPairs.push({
          key,
          value,
          alwaysSet: pair.alwaysSet
        });
      }
      return syncPairs;
    }).then((syncPairs) => ParseStatus.mergeObjectSync(status, syncPairs)) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    return errorUtil.errToObj, new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          let defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          return issue2.code === "unrecognized_keys" ? {
            message: errorUtil.errToObj(message).message ?? defaultError
          } : {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    return new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    let shape = {};
    for (let key of util.objectKeys(mask))
      mask[key] && this.shape[key] && (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    let shape = {};
    for (let key of util.objectKeys(this.shape))
      mask[key] || (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape)) {
      let fieldSchema = this.shape[key];
      mask && !mask[key] ? newShape[key] = fieldSchema : newShape[key] = fieldSchema.optional();
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape))
      if (mask && !mask[key])
        newShape[key] = this.shape[key];
      else {
        let newField = this.shape[key];
        for (; newField instanceof ZodOptional; )
          newField = newField._def.innerType;
        newShape[key] = newField;
      }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.strictCreate = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.lazycreate = (shape, params) => new ZodObject({
  shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
var ZodUnion = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), options = this._def.options;
    function handleResults(results) {
      for (let result of results)
        if (result.result.status === "valid")
          return result.result;
      for (let result of results)
        if (result.result.status === "dirty")
          return ctx.common.issues.push(...result.ctx.common.issues), result.result;
      let unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
    if (ctx.common.async)
      return Promise.all(options.map(async (option) => {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    {
      let dirty, issues = [];
      for (let option of options) {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }, result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid")
          return result;
        result.status === "dirty" && !dirty && (dirty = { result, ctx: childCtx }), childCtx.common.issues.length && issues.push(childCtx.common.issues);
      }
      if (dirty)
        return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
      let unionErrors = issues.map((issues2) => new ZodError(issues2));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => new ZodUnion({
  options: types,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(params)
});
var getDiscriminator = (type) => type instanceof ZodLazy ? getDiscriminator(type.schema) : type instanceof ZodEffects ? getDiscriminator(type.innerType()) : type instanceof ZodLiteral ? [type.value] : type instanceof ZodEnum ? type.options : type instanceof ZodNativeEnum ? util.objectValues(type.enum) : type instanceof ZodDefault ? getDiscriminator(type._def.innerType) : type instanceof ZodUndefined ? [void 0] : type instanceof ZodNull ? [null] : type instanceof ZodOptional ? [void 0, ...getDiscriminator(type.unwrap())] : type instanceof ZodNullable ? [null, ...getDiscriminator(type.unwrap())] : type instanceof ZodBranded || type instanceof ZodReadonly ? getDiscriminator(type.unwrap()) : type instanceof ZodCatch ? getDiscriminator(type._def.innerType) : [], ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);
    return option ? ctx.common.async ? option._parseAsync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : option._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : (addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [discriminator]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    let optionsMap = /* @__PURE__ */ new Map();
    for (let type of options) {
      let discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length)
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      for (let value of discriminatorValues) {
        if (optionsMap.has(value))
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  let aType = getParsedType(a), bType = getParsedType(b);
  if (a === b)
    return { valid: !0, data: a };
  if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    let bKeys = util.objectKeys(b), sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid)
        return { valid: !1 };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length)
      return { valid: !1 };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid)
        return { valid: !1 };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  } else return aType === ZodParsedType.date && bType === ZodParsedType.date && +a == +b ? { valid: !0, data: a } : { valid: !1 };
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight))
        return INVALID;
      let merged = mergeValues(parsedLeft.value, parsedRight.value);
      return merged.valid ? ((isDirty(parsedLeft) || isDirty(parsedRight)) && status.dirty(), { status: status.value, value: merged.data }) : (addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return ctx.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }),
      this._def.right._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
    ]).then(([left, right]) => handleParsed(left, right)) : handleParsed(this._def.left._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }), this._def.right._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }));
  }
};
ZodIntersection.create = (left, right, params) => new ZodIntersection({
  left,
  right,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(params)
});
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (ctx.data.length < this._def.items.length)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && ctx.data.length > this._def.items.length && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), status.dirty());
    let items = [...ctx.data].map((item, itemIndex) => {
      let schema = this._def.items[itemIndex] || this._def.rest;
      return schema ? schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)) : null;
    }).filter((x) => !!x);
    return ctx.common.async ? Promise.all(items).then((results) => ParseStatus.mergeArray(status, results)) : ParseStatus.mergeArray(status, items);
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;
    for (let key in ctx.data)
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    return ctx.common.async ? ParseStatus.mergeObjectAsync(status, pairs) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    return second instanceof ZodType ? new _ZodRecord({
      keyType: first,
      valueType: second,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(third)
    }) : new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}, ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      }), INVALID;
    let keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => ({
      key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
      value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
    }));
    if (ctx.common.async) {
      let finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let pair of pairs) {
          let key = await pair.key, value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted")
            return INVALID;
          (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      let finalMap = /* @__PURE__ */ new Map();
      for (let pair of pairs) {
        let key = pair.key, value = pair.value;
        if (key.status === "aborted" || value.status === "aborted")
          return INVALID;
        (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => new ZodMap({
  valueType,
  keyType,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(params)
});
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      }), INVALID;
    let def = this._def;
    def.minSize !== null && ctx.data.size < def.minSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.minSize.message
    }), status.dirty()), def.maxSize !== null && ctx.data.size > def.maxSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.maxSize.message
    }), status.dirty());
    let valueType = this._def.valueType;
    function finalizeSet(elements2) {
      let parsedSet = /* @__PURE__ */ new Set();
      for (let element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        element.status === "dirty" && status.dirty(), parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    let elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ctx.common.async ? Promise.all(elements).then((elements2) => finalizeSet(elements2)) : finalizeSet(elements);
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => new ZodSet({
  valueType,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(params)
});
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      }), INVALID;
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    let params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      let me = this;
      return OK(async function(...args) {
        let error2 = new ZodError([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          throw error2.addIssue(makeArgsIssue(args, e)), error2;
        }), result = await Reflect.apply(fn, this, parsedArgs);
        return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          throw error2.addIssue(makeReturnsIssue(result, e)), error2;
        });
      });
    } else {
      let me = this;
      return OK(function(...args) {
        let parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success)
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        let result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success)
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    return this.parse(func);
  }
  strictImplement(func) {
    return this.parse(func);
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}, ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => new ZodLazy({
  getter,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(params)
});
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => new ZodLiteral({
  value,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(params)
});
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data != "string") {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(input.data)) {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Values() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    let nativeEnumValues = util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(util.getValidEnumValues(this._def.values))), !this._cache.has(input.data)) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => new ZodNativeEnum({
  values,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(params)
});
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      }), INVALID;
    let promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => this._def.type.parseAsync(data, {
      path: ctx.path,
      errorMap: ctx.common.contextualErrorMap
    })));
  }
};
ZodPromise.create = (schema, params) => new ZodPromise({
  type: schema,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(params)
});
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg), arg.fatal ? status.abort() : status.dirty();
      },
      get path() {
        return ctx.path;
      }
    };
    if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === "preprocess") {
      let processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async)
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          let result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
        });
      {
        if (status.value === "aborted")
          return INVALID;
        let result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
      }
    }
    if (effect.type === "refinement") {
      let executeRefinement = (acc) => {
        let result = effect.refinement(acc, checkCtx);
        if (ctx.common.async)
          return Promise.resolve(result);
        if (result instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return acc;
      };
      if (ctx.common.async === !1) {
        let inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value), { status: status.value, value: inner.value });
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value).then(() => ({ status: status.value, value: inner.value }))));
    }
    if (effect.type === "transform")
      if (ctx.common.async === !1) {
        let base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        let result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: status.value, value: result };
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => isValid(base) ? Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
          status: status.value,
          value: result
        })) : INVALID);
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => new ZodEffects({
  schema,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect,
  ...processCreateParams(params)
});
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => new ZodEffects({
  schema,
  effect: { type: "preprocess", transform: preprocess2 },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(params)
});
var ZodOptional = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => new ZodOptional({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(params)
});
var ZodNullable = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => new ZodNullable({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(params)
});
var ZodDefault = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return ctx.parsedType === ZodParsedType.undefined && (data = this._def.defaultValue()), this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => new ZodDefault({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof params.default == "function" ? params.default : () => params.default,
  ...processCreateParams(params)
});
var ZodCatch = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    }, result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    return isAsync(result) ? result.then((result2) => ({
      status: "valid",
      value: result2.status === "valid" ? result2.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    })) : {
      status: "valid",
      value: result.status === "valid" ? result.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => new ZodCatch({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof params.catch == "function" ? params.catch : () => params.catch,
  ...processCreateParams(params)
});
var ZodNaN = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.nan) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(params)
});
var BRAND = Symbol("zod_brand"), ZodBranded = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.common.async)
      return (async () => {
        let inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), DIRTY(inResult.value)) : this._def.out._parseAsync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      })();
    {
      let inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), {
        status: "dirty",
        value: inResult.value
      }) : this._def.out._parseSync({
        data: inResult.value,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}, ZodReadonly = class extends ZodType {
  _parse(input) {
    let result = this._def.innerType._parse(input), freeze = (data) => (isValid(data) && (data.value = Object.freeze(data.value)), data);
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => new ZodReadonly({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(params)
});
var late = {
  object: ZodObject.lazycreate
}, ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3.ZodString = "ZodString", ZodFirstPartyTypeKind3.ZodNumber = "ZodNumber", ZodFirstPartyTypeKind3.ZodNaN = "ZodNaN", ZodFirstPartyTypeKind3.ZodBigInt = "ZodBigInt", ZodFirstPartyTypeKind3.ZodBoolean = "ZodBoolean", ZodFirstPartyTypeKind3.ZodDate = "ZodDate", ZodFirstPartyTypeKind3.ZodSymbol = "ZodSymbol", ZodFirstPartyTypeKind3.ZodUndefined = "ZodUndefined", ZodFirstPartyTypeKind3.ZodNull = "ZodNull", ZodFirstPartyTypeKind3.ZodAny = "ZodAny", ZodFirstPartyTypeKind3.ZodUnknown = "ZodUnknown", ZodFirstPartyTypeKind3.ZodNever = "ZodNever", ZodFirstPartyTypeKind3.ZodVoid = "ZodVoid", ZodFirstPartyTypeKind3.ZodArray = "ZodArray", ZodFirstPartyTypeKind3.ZodObject = "ZodObject", ZodFirstPartyTypeKind3.ZodUnion = "ZodUnion", ZodFirstPartyTypeKind3.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ZodFirstPartyTypeKind3.ZodIntersection = "ZodIntersection", ZodFirstPartyTypeKind3.ZodTuple = "ZodTuple", ZodFirstPartyTypeKind3.ZodRecord = "ZodRecord", ZodFirstPartyTypeKind3.ZodMap = "ZodMap", ZodFirstPartyTypeKind3.ZodSet = "ZodSet", ZodFirstPartyTypeKind3.ZodFunction = "ZodFunction", ZodFirstPartyTypeKind3.ZodLazy = "ZodLazy", ZodFirstPartyTypeKind3.ZodLiteral = "ZodLiteral", ZodFirstPartyTypeKind3.ZodEnum = "ZodEnum", ZodFirstPartyTypeKind3.ZodEffects = "ZodEffects", ZodFirstPartyTypeKind3.ZodNativeEnum = "ZodNativeEnum", ZodFirstPartyTypeKind3.ZodOptional = "ZodOptional", ZodFirstPartyTypeKind3.ZodNullable = "ZodNullable", ZodFirstPartyTypeKind3.ZodDefault = "ZodDefault", ZodFirstPartyTypeKind3.ZodCatch = "ZodCatch", ZodFirstPartyTypeKind3.ZodPromise = "ZodPromise", ZodFirstPartyTypeKind3.ZodBranded = "ZodBranded", ZodFirstPartyTypeKind3.ZodPipeline = "ZodPipeline", ZodFirstPartyTypeKind3.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create;

// mcp-servers-src/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (inst._zod || Object.defineProperty(inst, "_zod", {
      value: {
        def,
        constr: _,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), inst._zod.traits.has(name))
      return;
    inst._zod.traits.add(name), initializer3(inst, def);
    let proto = _.prototype, keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      let k = keys[i];
      k in inst || (inst[k] = proto[k].bind(inst));
    }
  }
  let Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    let inst = params?.Parent ? new Definition() : this;
    init(inst, def), (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (let fn of inst._zod.deferred)
      fn();
    return inst;
  }
  return Object.defineProperty(_, "init", { value: init }), Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => params?.Parent && inst instanceof params.Parent ? !0 : inst?._zod?.traits?.has(name)
  }), Object.defineProperty(_, "name", { value: name }), _;
}
var $brand = Symbol("zod_brand"), $ZodAsyncError = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}, $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`), this.name = "ZodEncodeError";
  }
}, globalConfig = {};
function config(newConfig) {
  return newConfig && Object.assign(globalConfig, newConfig), globalConfig;
}

// mcp-servers-src/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  let numericValues = Object.values(entries).filter((v) => typeof v == "number");
  return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  return typeof value == "bigint" ? value.toString() : value;
}
function cached(getter) {
  return {
    get value() {
      {
        let value = getter();
        return Object.defineProperty(this, "value", { value }), value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input == null;
}
function cleanRegex(source) {
  let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepString = step.toString(), stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    let match = stepString.match(/\d?e-(\d?)/);
    match?.[1] && (stepDecCount = Number.parseInt(match[1]));
  }
  let decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object3, key, getter) {
  let value;
  Object.defineProperty(object3, key, {
    get() {
      if (value !== EVALUATING)
        return value === void 0 && (value = EVALUATING, value = getter()), value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function mergeDefs(...defs) {
  let mergedDescriptors = {};
  for (let def of defs) {
    let descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  return path ? path.reduce((acc, key) => acc?.[key], obj) : obj;
}
function promiseAllObject(promisesObj) {
  let keys = Object.keys(promisesObj), promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    let resolvedObj = {};
    for (let i = 0; i < keys.length; i++)
      resolvedObj[keys[i]] = results[i];
    return resolvedObj;
  });
}
function randomString(length = 10) {
  let chars = "abcdefghijklmnopqrstuvwxyz", str = "";
  for (let i = 0; i < length; i++)
    str += chars[Math.floor(Math.random() * chars.length)];
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data == "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    let F = Function;
    return new F(""), !0;
  } catch {
    return !1;
  }
});
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  let ctor = o.constructor;
  if (ctor === void 0 || typeof ctor != "function")
    return !0;
  let prot = ctor.prototype;
  return !(isObject(prot) === !1 || Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === !1);
}
function shallowClone(o) {
  return isPlainObject(o) ? { ...o } : Array.isArray(o) ? [...o] : o;
}
function numKeys(data) {
  let keyCount = 0;
  for (let key in data)
    Object.prototype.hasOwnProperty.call(data, key) && keyCount++;
  return keyCount;
}
var getParsedType2 = (data) => {
  let t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(data) ? "array" : data === null ? "null" : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? "promise" : typeof Map < "u" && data instanceof Map ? "map" : typeof Set < "u" && data instanceof Set ? "set" : typeof Date < "u" && data instanceof Date ? "date" : typeof File < "u" && data instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]), primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  let cl = new inst._zod.constr(def ?? inst._zod.def);
  return (!def || params?.parent) && (cl._zod.parent = inst), cl;
}
function normalizeParams(_params) {
  let params = _params;
  if (!params)
    return {};
  if (typeof params == "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  return delete params.message, typeof params.error == "string" ? { ...params, error: () => params.error } : params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      return target ?? (target = getter()), Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      return target ?? (target = getter()), Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      return target ?? (target = getter()), Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      return target ?? (target = getter()), Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      return target ?? (target = getter()), Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      return target ?? (target = getter()), Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      return target ?? (target = getter()), Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  return typeof value == "bigint" ? value.toString() + "n" : typeof value == "string" ? `"${value}"` : `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional");
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = {};
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && (newShape[key] = currDef.shape[key]);
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = { ...schema._zod.def.shape };
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && delete newShape[key];
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to extend: expected a plain object");
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0) {
    let existingShape = schema._zod.def.shape;
    for (let key in shape)
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  let def = mergeDefs(a._zod.def, {
    get shape() {
      let _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in oldShape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key]);
        }
      else
        for (let key in oldShape)
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
      return assignProp(this, "shape", shape), shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in shape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          }));
        }
      else
        for (let key in oldShape)
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
      return assignProp(this, "shape", shape), shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === !0)
    return !0;
  for (let i = startIndex; i < x.issues.length; i++)
    if (x.issues[i]?.continue !== !0)
      return !0;
  return !1;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    return (_a2 = iss).path ?? (_a2.path = []), iss.path.unshift(path), iss;
  });
}
function unwrapMessage(message) {
  return typeof message == "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  let full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    let message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  return delete full.inst, delete full.continue, ctx?.reportInput || delete full.input, full;
}
function getSizableOrigin(input) {
  return input instanceof Set ? "set" : input instanceof Map ? "map" : input instanceof File ? "file" : "unknown";
}
function getLengthableOrigin(input) {
  return Array.isArray(input) ? "array" : typeof input == "string" ? "string" : "unknown";
}
function parsedType(data) {
  let t = typeof data;
  switch (t) {
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "object": {
      if (data === null)
        return "null";
      if (Array.isArray(data))
        return "array";
      let obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor)
        return obj.constructor.name;
    }
  }
  return t;
}
function issue(...args) {
  let [iss, input, inst] = args;
  return typeof iss == "string" ? {
    message: iss,
    code: "custom",
    input,
    inst
  } : { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => Number.isNaN(Number.parseInt(k, 10))).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  let binaryString = atob(base643), bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++)
    bytes[i] = binaryString.charCodeAt(i);
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++)
    binaryString += String.fromCharCode(bytes[i]);
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  let base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/"), padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  let cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  let bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2)
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// mcp-servers-src/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError", Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: !1
  }), Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: !1
  }), inst.message = JSON.stringify(def, jsonStringifyReplacer, 2), Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: !1
  });
}, $ZodError = $constructor("$ZodError", initializer), $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = {}, formErrors = [];
  for (let sub of error2.issues)
    sub.path.length > 0 ? (fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub))) : formErrors.push(mapper(sub));
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = { _errors: [] }, processError = (error3) => {
    for (let issue2 of error3.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues });
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues });
      else if (issue2.path.length === 0)
        fieldErrors._errors.push(mapper(issue2));
      else {
        let curr = fieldErrors, i = 0;
        for (; i < issue2.path.length; ) {
          let el = issue2.path[i];
          i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
        }
      }
  };
  return processError(error2), fieldErrors;
}

// mcp-servers-src/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !1 }) : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  if (result.issues.length) {
    let e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, _params?.callee), e;
  }
  return result.value;
}, parse = /* @__PURE__ */ _parse($ZodRealError), _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise && (result = await result), result.issues.length) {
    let e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, params?.callee), e;
  }
  return result.value;
}, parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError), _safeParse = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? { ..._ctx, async: !1 } : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  return result.issues.length ? {
    success: !1,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParse = /* @__PURE__ */ _safeParse($ZodRealError), _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  return result instanceof Promise && (result = await result), result.issues.length ? {
    success: !1,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError), _encode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var _decode = (_Err) => (schema, value, _ctx) => _parse(_Err)(schema, value, _ctx);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var _decodeAsync = (_Err) => async (schema, value, _ctx) => _parseAsync(_Err)(schema, value, _ctx);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var _safeDecode = (_Err) => (schema, value, _ctx) => _safeParse(_Err)(schema, value, _ctx);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => _safeParseAsync(_Err)(schema, value, _ctx);

// mcp-servers-src/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/, cuid2 = /^[0-9a-z]+$/, ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, xid = /^[0-9a-vA-V]{20}$/, ksuid = /^[A-Za-z0-9]{27}$/, nanoid = /^[a-zA-Z0-9_-]{21}$/, duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, uuid = (version2) => version2 ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, uuid4 = /* @__PURE__ */ uuid(4), uuid6 = /* @__PURE__ */ uuid(6), uuid7 = /* @__PURE__ */ uuid(7), email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, idnEmail = unicodeEmail, browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, _emoji = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, mac = (delimiter) => {
  let escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, base64url = /^[A-Za-z0-9_-]*$/, hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, e164 = /^\+[1-9]\d{6,14}$/, dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  let hhmm = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof args.precision == "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  let time3 = timeSource({ precision: args.precision }), opts = ["Z"];
  args.local && opts.push(""), args.offset && opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let timeRegex2 = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  let regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${regex}$`);
}, bigint = /^-?\d+n?$/, integer = /^-?\d+$/, number = /^-?\d+(?:\.\d+)?$/, boolean = /^(?:true|false)$/i, _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/, uppercase = /^[^a-z]*$/, hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/, md5_base64 = /* @__PURE__ */ fixedBase64(22, "=="), md5_base64url = /* @__PURE__ */ fixedBase64url(22), sha1_hex = /^[0-9a-fA-F]{40}$/, sha1_base64 = /* @__PURE__ */ fixedBase64(27, "="), sha1_base64url = /* @__PURE__ */ fixedBase64url(27), sha256_hex = /^[0-9a-fA-F]{64}$/, sha256_base64 = /* @__PURE__ */ fixedBase64(43, "="), sha256_base64url = /* @__PURE__ */ fixedBase64url(43), sha384_hex = /^[0-9a-fA-F]{96}$/, sha384_base64 = /* @__PURE__ */ fixedBase64(64, ""), sha384_base64url = /* @__PURE__ */ fixedBase64url(64), sha512_hex = /^[0-9a-fA-F]{128}$/, sha512_base64 = /* @__PURE__ */ fixedBase64(86, "=="), sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// mcp-servers-src/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {}), inst._zod.def = def, (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
}), numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    def.value < curr && (def.inclusive ? bag.maximum = def.value : bag.exclusiveMaximum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value <= def.value : payload.value < def.value) || payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    def.value > curr && (def.inclusive ? bag.minimum = def.value : bag.exclusiveMinimum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value >= def.value : payload.value > def.value) || payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  }), inst._zod.check = (payload) => {
    if (typeof payload.value != typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof payload.value == "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0) || payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def), def.format = def.format || "float64";
  let isInt = def.format?.includes("int"), origin = isInt ? "int" : "number", [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum, isInt && (bag.pattern = integer);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: !1,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        input > 0 ? payload.issues.push({
          input,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        }) : payload.issues.push({
          input,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        });
        return;
      }
    }
    input < minimum && payload.issues.push({
      origin: "number",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "number",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  let [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input < minimum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size <= def.maximum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size >= def.minimum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.size, bag.maximum = def.size, bag.size = def.size;
  }), inst._zod.check = (payload) => {
    let input = payload.value, size = input.size;
    if (size === def.size)
      return;
    let tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length <= def.maximum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length >= def.minimum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.length, bag.maximum = def.length, bag.length = def.length;
  }), inst._zod.check = (payload) => {
    let input = payload.value, length = input.length;
    if (length === def.length)
      return;
    let origin = getLengthableOrigin(input), tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, def.pattern && (bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(def.pattern));
  }), def.pattern ? (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? { pattern: def.pattern.toString() } : {},
      inst,
      continue: !def.abort
    });
  }) : (_b = inst._zod).check ?? (_b.check = () => {
  });
}), $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  let escapedRegex = escapeRegex(def.includes), pattern = new RegExp(typeof def.position == "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern, inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.includes(def.includes, def.position) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.startsWith(def.prefix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.endsWith(def.suffix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  result.issues.length && payload.issues.push(...prefixIssues(property, result.issues));
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    let result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise)
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    handleCheckPropertyResult(result, payload, def.property);
  };
}), $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  let mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  }), inst._zod.check = (payload) => {
    mimeSet.has(payload.value.type) || payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// mcp-servers-src/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [], this.indent = 0, this && (this.args = args);
  }
  indented(fn) {
    this.indent += 1, fn(this), this.indent -= 1;
  }
  write(arg) {
    if (typeof arg == "function") {
      arg(this, { execution: "sync" }), arg(this, { execution: "async" });
      return;
    }
    let lines = arg.split(`
`).filter((x) => x), minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length)), dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (let line of dedented)
      this.content.push(line);
  }
  compile() {
    let F = Function, args = this?.args, lines = [...(this?.content ?? [""]).map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
};

// mcp-servers-src/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// mcp-servers-src/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {}), inst._zod.def = def, inst._zod.bag = inst._zod.bag || {}, inst._zod.version = version;
  let checks = [...inst._zod.def.checks ?? []];
  inst._zod.traits.has("$ZodCheck") && checks.unshift(inst);
  for (let ch of checks)
    for (let fn of ch._zod.onattach)
      fn(inst);
  if (checks.length === 0)
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []), inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  else {
    let runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload), asyncResult;
      for (let ch of checks2) {
        if (ch._zod.def.when) {
          if (!ch._zod.def.when(payload))
            continue;
        } else if (isAborted2)
          continue;
        let currLen = payload.issues.length, _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === !1)
          throw new $ZodAsyncError();
        if (asyncResult || _ instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _, payload.issues.length !== currLen && (isAborted2 || (isAborted2 = aborted(payload, currLen)));
          });
        else {
          if (payload.issues.length === currLen)
            continue;
          isAborted2 || (isAborted2 = aborted(payload, currLen));
        }
      }
      return asyncResult ? asyncResult.then(() => payload) : payload;
    }, handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary))
        return canary.aborted = !0, canary;
      let checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks)
        return inst._zod.parse(payload, ctx);
      if (ctx.direction === "backward") {
        let canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: !0 });
        return canary instanceof Promise ? canary.then((canary2) => handleCanaryResult(canary2, payload, ctx)) : handleCanaryResult(canary, payload, ctx);
      }
      let result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        let r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag), inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch {
      }
    return typeof payload.value == "string" || payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), $ZodString.init(inst, def);
}), $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid), $ZodStringFormat.init(inst, def);
}), $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    let v = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
}), $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email), $ZodStringFormat.init(inst, def);
}), $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    try {
      let trimmed = payload.value.trim(), url2 = new URL(trimmed);
      def.hostname && (def.hostname.lastIndex = 0, def.hostname.test(url2.hostname) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: def.hostname.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.protocol && (def.protocol.lastIndex = 0, def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: def.protocol.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.normalize ? payload.value = url2.href : payload.value = trimmed;
      return;
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji()), $ZodStringFormat.init(inst, def);
}), $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid), $ZodStringFormat.init(inst, def);
}), $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid), $ZodStringFormat.init(inst, def);
}), $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2), $ZodStringFormat.init(inst, def);
}), $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid), $ZodStringFormat.init(inst, def);
}), $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid), $ZodStringFormat.init(inst, def);
}), $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid), $ZodStringFormat.init(inst, def);
}), $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date), $ZodStringFormat.init(inst, def);
}), $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration), $ZodStringFormat.init(inst, def);
}), $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv4";
}), $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv6", inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter)), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "mac";
}), $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4), $ZodStringFormat.init(inst, def);
}), $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6), $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    let parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      let [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      let prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return !0;
  if (data.length % 4 !== 0)
    return !1;
  try {
    return atob(data), !0;
  } catch {
    return !1;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64", inst._zod.check = (payload) => {
    isValidBase64(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return !1;
  let base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/"), padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64url", inst._zod.check = (payload) => {
    isValidBase64URL(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164), $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    let tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return !1;
    let [header] = tokensParts;
    if (!header)
      return !1;
    let parsedHeader = JSON.parse(atob(header));
    return !("typ" in parsedHeader && parsedHeader?.typ !== "JWT" || !parsedHeader.alg || algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm));
  } catch {
    return !1;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    isValidJWT2(payload.value, def.alg) || payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.fn(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = inst._zod.bag.pattern ?? number, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch {
      }
    let input = payload.value;
    if (typeof input == "number" && !Number.isNaN(input) && Number.isFinite(input))
      return payload;
    let received = typeof input == "number" ? Number.isNaN(input) ? "NaN" : Number.isFinite(input) ? void 0 : "Infinity" : void 0;
    return payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    }), payload;
  };
}), $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def), $ZodNumber.init(inst, def);
}), $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = boolean, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = !!payload.value;
      } catch {
      }
    let input = payload.value;
    return typeof input == "boolean" || payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = bigint, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch {
      }
    return typeof payload.value == "bigint" || payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def), $ZodBigInt.init(inst, def);
}), $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input == "symbol" || payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _undefined, inst._zod.values = /* @__PURE__ */ new Set([void 0]), inst._zod.optin = "optional", inst._zod.optout = "optional", inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _null, inst._zod.values = /* @__PURE__ */ new Set([null]), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input === null || payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => (payload.issues.push({
    expected: "never",
    code: "invalid_type",
    input: payload.value,
    inst
  }), payload);
}), $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = new Date(payload.value);
      } catch {
      }
    let input = payload.value, isDate = input instanceof Date;
    return isDate && !Number.isNaN(input.getTime()) || payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    }), payload;
  };
});
function handleArrayResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = Array(input.length);
    let proms = [];
    for (let i = 0; i < input.length; i++) {
      let item = input[i], result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleArrayResult(result2, payload, i))) : handleArrayResult(result, payload, i);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input))
      return;
    final.issues.push(...prefixIssues(key, result.issues));
  }
  result.value === void 0 ? key in input && (final.value[key] = void 0) : final.value[key] = result.value;
}
function normalizeDef(def) {
  let keys = Object.keys(def.shape);
  for (let k of keys)
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
  let okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  let unrecognized = [], keySet = def.keySet, _catchall = def.catchall._zod, t = _catchall.def.type, isOptionalOut = _catchall.optout === "optional";
  for (let key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    let r = _catchall.run({ value: input[key], issues: [] }, ctx);
    r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
  }
  return unrecognized.length && payload.issues.push({
    code: "unrecognized_keys",
    keys: unrecognized,
    input,
    inst
  }), proms.length ? Promise.all(proms).then(() => payload) : payload;
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  if ($ZodType.init(inst, def), !Object.getOwnPropertyDescriptor(def, "shape")?.get) {
    let sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        let newSh = { ...sh };
        return Object.defineProperty(def, "shape", {
          value: newSh
        }), newSh;
      }
    });
  }
  let _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    let shape = def.shape, propValues = {};
    for (let key in shape) {
      let field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (let v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  let isObject2 = isObject, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    if (!isObject2(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = {};
    let proms = [], shape = value.shape;
    for (let key of value.keys) {
      let el = shape[key], isOptionalOut = el._zod.optout === "optional", r = el._zod.run({ value: input[key], issues: [] }, ctx);
      r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
    return catchall ? handleCatchall(proms, input, payload, ctx, _normalized.value, inst) : proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  let superParse = inst._zod.parse, _normalized = cached(() => normalizeDef(def)), generateFastpass = (shape) => {
    let doc = new Doc(["shape", "payload", "ctx"]), normalized = _normalized.value, parseStr = (key) => {
      let k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write("const input = payload.value;");
    let ids = /* @__PURE__ */ Object.create(null), counter = 0;
    for (let key of normalized.keys)
      ids[key] = `key_${counter++}`;
    doc.write("const newResult = {};");
    for (let key of normalized.keys) {
      let id = ids[key], k = esc(key), isOptionalOut = shape[key]?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`), isOptionalOut ? doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `) : doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write("payload.value = newResult;"), doc.write("return payload;");
    let fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, fastpass, isObject2 = isObject, jit = !globalConfig.jitless, fastEnabled = jit && allowsEval.value, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    return isObject2(input) ? jit && fastEnabled && ctx?.async === !1 && ctx.jitless !== !0 ? (fastpass || (fastpass = generateFastpass(def.shape)), payload = fastpass(payload, ctx), catchall ? handleCatchall([], input, payload, ctx, value, inst) : payload) : superParse(payload, ctx) : (payload.issues.push({
      expected: "object",
      code: "invalid_type",
      input,
      inst
    }), payload);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (let result of results)
    if (result.issues.length === 0)
      return final.value = result.value, final;
  let nonaborted = results.filter((r) => !aborted(r));
  return nonaborted.length === 1 ? (final.value = nonaborted[0].value, nonaborted[0]) : (final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }), final);
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values))
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
  }), defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      let patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
  });
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    return async ? Promise.all(results).then((results2) => handleUnionResults(results2, payload, inst, ctx)) : handleUnionResults(results, payload, inst, ctx);
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  let successes = results.filter((r) => r.issues.length === 0);
  return successes.length === 1 ? (final.value = successes[0].value, final) : (successes.length === 0 ? final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }) : final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: [],
    inclusive: !1
  }), final);
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def), def.inclusive = !1;
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      result instanceof Promise ? (results.push(result), async = !0) : results.push(result);
    }
    return async ? Promise.all(results).then((results2) => handleExclusiveUnionResults(results2, payload, inst, ctx)) : handleExclusiveUnionResults(results, payload, inst, ctx);
  };
}), $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = !1, $ZodUnion.init(inst, def);
  let _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    let propValues = {};
    for (let option of def.options) {
      let pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (let [k, v] of Object.entries(pv)) {
        propValues[k] || (propValues[k] = /* @__PURE__ */ new Set());
        for (let val of v)
          propValues[k].add(val);
      }
    }
    return propValues;
  });
  let disc = cached(() => {
    let opts = def.options, map2 = /* @__PURE__ */ new Map();
    for (let o of opts) {
      let values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (let v of values) {
        if (map2.has(v))
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isObject(input))
      return payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      }), payload;
    let opt = disc.value.get(input?.[def.discriminator]);
    return opt ? opt._zod.run(payload, ctx) : def.unionFallback ? _super(payload, ctx) : (payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    }), payload);
  };
}), $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value, left = def.left._zod.run({ value: input, issues: [] }, ctx), right = def.right._zod.run({ value: input, issues: [] }, ctx);
    return left instanceof Promise || right instanceof Promise ? Promise.all([left, right]).then(([left2, right2]) => handleIntersectionResults(payload, left2, right2)) : handleIntersectionResults(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b)
    return { valid: !0, data: a };
  if (a instanceof Date && b instanceof Date && +a == +b)
    return { valid: !0, data: a };
  if (isPlainObject(a) && isPlainObject(b)) {
    let bKeys = Object.keys(b), sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length)
      return { valid: !1, mergeErrorPath: [] };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  let unrecKeys = /* @__PURE__ */ new Map(), unrecIssue;
  for (let iss of left.issues)
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).l = !0;
    } else
      result.issues.push(iss);
  for (let iss of right.issues)
    if (iss.code === "unrecognized_keys")
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).r = !0;
    else
      result.issues.push(iss);
  let bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue && result.issues.push({ ...unrecIssue, keys: bothKeys }), aborted(result))
    return result;
  let merged = mergeValues2(left.value, right.value);
  if (!merged.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  return result.value = merged.data, result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  let items = def.items;
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      }), payload;
    payload.value = [];
    let proms = [], reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional"), optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      let tooBig = input.length > items.length, tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall)
        return payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: !0 } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        }), payload;
    }
    let i = -1;
    for (let item of items) {
      if (i++, i >= input.length && i >= optStart)
        continue;
      let result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
    }
    if (def.rest) {
      let rest = input.slice(items.length);
      for (let el of rest) {
        i++;
        let result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleTupleResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isPlainObject(input))
      return payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [], values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      let recordKeys = /* @__PURE__ */ new Set();
      for (let key of values)
        if (typeof key == "string" || typeof key == "number" || typeof key == "symbol") {
          recordKeys.add(typeof key == "number" ? key.toString() : key);
          let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          result instanceof Promise ? proms.push(result.then((result2) => {
            result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[key] = result2.value;
          })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[key] = result.value);
        }
      let unrecognized;
      for (let key in input)
        recordKeys.has(key) || (unrecognized = unrecognized ?? [], unrecognized.push(key));
      unrecognized && unrecognized.length > 0 && payload.issues.push({
        code: "unrecognized_keys",
        input,
        inst,
        keys: unrecognized
      });
    } else {
      payload.value = {};
      for (let key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof key == "string" && number.test(key) && keyResult.issues.length) {
          let retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          retryResult.issues.length === 0 && (keyResult = retryResult);
        }
        if (keyResult.issues.length) {
          def.mode === "loose" ? payload.value[key] = input[key] : payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          continue;
        }
        let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => {
          result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[keyResult.value] = result2.value;
        })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[keyResult.value] = result.value);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Map))
      return payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (let [key, value] of input) {
      let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx), valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      keyResult instanceof Promise || valueResult instanceof Promise ? proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
        handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
      })) : handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  keyResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, keyResult.issues)) : final.issues.push({
    code: "invalid_key",
    origin: "map",
    input,
    inst,
    issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), valueResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, valueResult.issues)) : final.issues.push({
    origin: "map",
    code: "invalid_element",
    input,
    inst,
    key,
    issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Set))
      return payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (let item of input) {
      let result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleSetResult(result2, payload))) : handleSetResult(result, payload);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleSetResult(result, final) {
  result.issues.length && final.issues.push(...result.issues), final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  let values = getEnumValues(def.entries), valuesSet = new Set(values);
  inst._zod.values = valuesSet, inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o == "string" ? escapeRegex(o) : o.toString()).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return valuesSet.has(input) || payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    }), payload;
  };
}), $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  if ($ZodType.init(inst, def), def.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  let values = new Set(def.values);
  inst._zod.values = values, inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o == "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return values.has(input) || payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    }), payload;
  };
}), $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input instanceof File || payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    let _out = def.transform(payload.value, payload);
    if (ctx.async)
      return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output2) => (payload.value = output2, payload));
    if (_out instanceof Promise)
      throw new $ZodAsyncError();
    return payload.value = _out, payload;
  };
});
function handleOptionalResult(result, input) {
  return result.issues.length && input === void 0 ? { issues: [], value: void 0 } : result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", inst._zod.optout = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      let result = def.innerType._zod.run(payload, ctx);
      return result instanceof Promise ? result.then((r) => handleOptionalResult(r, payload.value)) : handleOptionalResult(result, payload.value);
    }
    return payload.value === void 0 ? payload : def.innerType._zod.run(payload, ctx);
  };
}), $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern), inst._zod.parse = (payload, ctx) => def.innerType._zod.run(payload, ctx);
}), $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  }), defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0), inst._zod.parse = (payload, ctx) => payload.value === null ? payload : def.innerType._zod.run(payload, ctx);
}), $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0)
      return payload.value = def.defaultValue, payload;
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleDefaultResult(result2, def)) : handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  return payload.value === void 0 && (payload.value = def.defaultValue), payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => (ctx.direction === "backward" || payload.value === void 0 && (payload.value = def.defaultValue), def.innerType._zod.run(payload, ctx));
}), $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => {
    let v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleNonOptionalResult(result2, inst)) : handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  return !payload.issues.length && payload.value === void 0 && payload.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: payload.value,
    inst
  }), payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError("ZodSuccess");
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.issues.length === 0, payload)) : (payload.value = result.issues.length === 0, payload);
  };
}), $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.value, result2.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload)) : (payload.value = result.value, result.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload);
  };
}), $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => ((typeof payload.value != "number" || !Number.isNaN(payload.value)) && payload.issues.push({
    input: payload.value,
    inst,
    expected: "nan",
    code: "invalid_type"
  }), payload);
}), $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handlePipeResult(right2, def.in, ctx)) : handlePipeResult(right, def.in, ctx);
    }
    let left = def.in._zod.run(payload, ctx);
    return left instanceof Promise ? left.then((left2) => handlePipeResult(left2, def.out, ctx)) : handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if ((ctx.direction || "forward") === "forward") {
      let left = def.in._zod.run(payload, ctx);
      return left instanceof Promise ? left.then((left2) => handleCodecAResult(left2, def, ctx)) : handleCodecAResult(left, def, ctx);
    } else {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handleCodecAResult(right2, def, ctx)) : handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length)
    return result.aborted = !0, result;
  if ((ctx.direction || "forward") === "forward") {
    let transformed = def.transform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx)) : handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    let transformed = def.reverseTransform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx)) : handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin), defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then(handleReadonlyResult) : handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  return payload.value = Object.freeze(payload.value), payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  let regexParts = [];
  for (let part of def.parts)
    if (typeof part == "object" && part !== null) {
      if (!part._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      let source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part))
      regexParts.push(escapeRegex(`${part}`));
    else
      throw new Error(`Invalid template literal part: ${part}`);
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`), inst._zod.parse = (payload, _ctx) => typeof payload.value != "string" ? (payload.issues.push({
    input: payload.value,
    inst,
    expected: "string",
    code: "invalid_type"
  }), payload) : (inst._zod.pattern.lastIndex = 0, inst._zod.pattern.test(payload.value) || payload.issues.push({
    input: payload.value,
    inst,
    code: "invalid_format",
    format: def.format ?? "template_literal",
    pattern: inst._zod.pattern.source
  }), payload);
}), $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => ($ZodType.init(inst, def), inst._def = def, inst._zod.def = def, inst.implement = (func) => {
  if (typeof func != "function")
    throw new Error("implement() must be called with a function");
  return function(...args) {
    let parsedArgs = inst._def.input ? parse(inst._def.input, args) : args, result = Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? parse(inst._def.output, result) : result;
  };
}, inst.implementAsync = (func) => {
  if (typeof func != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...args) {
    let parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args, result = await Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? await parseAsync(inst._def.output, result) : result;
  };
}, inst._zod.parse = (payload, _ctx) => typeof payload.value != "function" ? (payload.issues.push({
  code: "invalid_type",
  expected: "function",
  input: payload.value,
  inst
}), payload) : (inst._def.output && inst._def.output._zod.def.type === "promise" ? payload.value = inst.implementAsync(payload.value) : payload.value = inst.implement(payload.value), payload), inst.input = (...args) => {
  let F = inst.constructor;
  return Array.isArray(args[0]) ? new F({
    type: "function",
    input: new $ZodTuple({
      type: "tuple",
      items: args[0],
      rest: args[1]
    }),
    output: inst._def.output
  }) : new F({
    type: "function",
    input: args[0],
    output: inst._def.output
  });
}, inst.output = (output) => {
  let F = inst.constructor;
  return new F({
    type: "function",
    input: inst._def.input,
    output
  });
}, inst)), $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
}), $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "innerType", () => def.getter()), defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern), defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues), defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0), defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0), inst._zod.parse = (payload, ctx) => inst._zod.innerType._zod.run(payload, ctx);
}), $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def), $ZodType.init(inst, def), inst._zod.parse = (payload, _) => payload, inst._zod.check = (payload) => {
    let input = payload.value, r = def.fn(input);
    if (r instanceof Promise)
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    handleRefineResult(r, payload, input, inst);
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    let _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    inst._zod.def.params && (_iss.params = inst._zod.def.params), payload.issues.push(issue(_iss));
  }
}

// mcp-servers-src/node_modules/zod/v4/locales/en.js
var error = () => {
  let Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        return issue2.values.length === 1 ? `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}` : `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        return sizing ? `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}` : `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        return sizing ? `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}` : `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        return _issue.format === "starts_with" ? `Invalid string: must start with "${_issue.prefix}"` : _issue.format === "ends_with" ? `Invalid string: must end with "${_issue.suffix}"` : _issue.format === "includes" ? `Invalid string: must include "${_issue.includes}"` : _issue.format === "regex" ? `Invalid string: must match pattern ${_issue.pattern}` : `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function en_default2() {
  return {
    localeError: error()
  };
}

// mcp-servers-src/node_modules/zod/v4/core/registries.js
var _a, $output = Symbol("ZodOutput"), $input = Symbol("ZodInput"), $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    let meta3 = _meta[0];
    return this._map.set(schema, meta3), meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.set(meta3.id, schema), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(schema) {
    let meta3 = this._map.get(schema);
    return meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.delete(meta3.id), this._map.delete(schema), this;
  }
  get(schema) {
    let p = schema._zod.parent;
    if (p) {
      let pm = { ...this.get(p) ?? {} };
      delete pm.id;
      let f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// mcp-servers-src/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  return new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  let norm = normalizeParams(_params);
  return norm.abort ?? (norm.abort = !0), new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  return new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  let ch = /* @__PURE__ */ _check((payload) => (payload.addIssue = (issue2) => {
    if (typeof issue2 == "string")
      payload.issues.push(issue(issue2, payload.value, ch._zod.def));
    else {
      let _issue = issue2;
      _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = ch), _issue.continue ?? (_issue.continue = !ch._zod.def.abort), payload.issues.push(issue(_issue));
    }
  }, fn(payload.value, payload)));
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  let ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  return ch._zod.check = fn, ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  let ch = new $ZodCheck({ check: "describe" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  let ch = new $ZodCheck({ check: "meta" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  let params = normalizeParams(_params), truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  params.case !== "sensitive" && (truthyArray = truthyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v), falsyArray = falsyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v));
  let truthySet = new Set(truthyArray), falsySet = new Set(falsyArray), _Codec = Classes.Codec ?? $ZodCodec, _Boolean = Classes.Boolean ?? $ZodBoolean, _String = Classes.String ?? $ZodString, stringSchema = new _String({ type: "string", error: params.error }), booleanSchema = new _Boolean({ type: "boolean", error: params.error }), codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      return params.case !== "sensitive" && (data = data.toLowerCase()), truthySet.has(data) ? !0 : falsySet.has(data) ? !1 : (payload.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...truthySet, ...falsySet],
        input: payload.value,
        inst: codec2,
        continue: !1
      }), {});
    },
    reverseTransform: (input, _payload) => input === !0 ? truthyArray[0] || "true" : falsyArray[0] || "false",
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  let params = normalizeParams(_params), def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex == "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  return fnOrRegex instanceof RegExp && (def.pattern = fnOrRegex), new Class2(def);
}

// mcp-servers-src/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  return target === "draft-4" && (target = "draft-04"), target === "draft-7" && (target = "draft-07"), {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  let def = schema._zod.def, seen = ctx.seen.get(schema);
  if (seen)
    return seen.count++, _params.schemaPath.includes(schema) && (seen.cycle = _params.path), seen.schema;
  let result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  let overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema)
    result.schema = overrideSchema;
  else {
    let params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema)
      schema._zod.processJSONSchema(ctx, result.schema, params);
    else {
      let _json = result.schema, processor = ctx.processors[def.type];
      if (!processor)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      processor(schema, ctx, _json, params);
    }
    let parent = schema._zod.parent;
    parent && (result.ref || (result.ref = parent), process2(parent, ctx, params), ctx.seen.get(parent).isParent = !0);
  }
  let meta3 = ctx.metadataRegistry.get(schema);
  return meta3 && Object.assign(result.schema, meta3), ctx.io === "input" && isTransforming(schema) && (delete result.schema.examples, delete result.schema.default), ctx.io === "input" && result.schema._prefault && ((_a2 = result.schema).default ?? (_a2.default = result.schema._prefault)), delete result.schema._prefault, ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let idToSchema = /* @__PURE__ */ new Map();
  for (let entry of ctx.seen.entries()) {
    let id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      let existing = idToSchema.get(id);
      if (existing && existing !== entry[0])
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      idToSchema.set(id, entry[0]);
    }
  }
  let makeURI = (entry) => {
    let defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      let externalId = ctx.external.registry.get(entry[0])?.id, uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId)
        return { ref: uriGenerator(externalId) };
      let id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      return entry[1].defId = id, { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root)
      return { ref: "#" };
    let defUriPrefix = `#/${defsSegment}/`, defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, extractToDef = (entry) => {
    if (entry[1].schema.$ref)
      return;
    let seen = entry[1], { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema }, defId && (seen.defId = defId);
    let schema2 = seen.schema;
    for (let key in schema2)
      delete schema2[key];
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw")
    for (let entry of ctx.seen.entries()) {
      let seen = entry[1];
      if (seen.cycle)
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      let ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    if (ctx.metadataRegistry.get(entry[0])?.id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1 && ctx.reused === "ref") {
      extractToDef(entry);
      continue;
    }
  }
}
function finalize(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let flattenRef = (zodSchema) => {
    let seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    let schema2 = seen.def ?? seen.schema, _cached = { ...schema2 }, ref = seen.ref;
    if (seen.ref = null, ref) {
      flattenRef(ref);
      let refSeen = ctx.seen.get(ref), refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0") ? (schema2.allOf = schema2.allOf ?? [], schema2.allOf.push(refSchema)) : Object.assign(schema2, refSchema), Object.assign(schema2, _cached), zodSchema._zod.parent === ref)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in _cached || delete schema2[key];
      if (refSchema.$ref && refSeen.def)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key]) && delete schema2[key];
    }
    let parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      let parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref && (schema2.$ref = parentSeen.schema.$ref, parentSeen.def))
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key]) && delete schema2[key];
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (let entry of [...ctx.seen.entries()].reverse())
    flattenRef(entry[0]);
  let result = {};
  if (ctx.target === "draft-2020-12" ? result.$schema = "https://json-schema.org/draft/2020-12/schema" : ctx.target === "draft-07" ? result.$schema = "http://json-schema.org/draft-07/schema#" : ctx.target === "draft-04" ? result.$schema = "http://json-schema.org/draft-04/schema#" : ctx.target, ctx.external?.uri) {
    let id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  let defs = ctx.external?.defs ?? {};
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    seen.def && seen.defId && (defs[seen.defId] = seen.def);
  }
  ctx.external || Object.keys(defs).length > 0 && (ctx.target === "draft-2020-12" ? result.$defs = defs : result.definitions = defs);
  try {
    let finalized = JSON.parse(JSON.stringify(result));
    return Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), finalized;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  let ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return !1;
  ctx.seen.add(_schema);
  let def = _schema._zod.def;
  if (def.type === "transform")
    return !0;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault")
    return isTransforming(def.innerType, ctx);
  if (def.type === "intersection")
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  if (def.type === "record" || def.type === "map")
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  if (def.type === "pipe")
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  if (def.type === "object") {
    for (let key in def.shape)
      if (isTransforming(def.shape[key], ctx))
        return !0;
    return !1;
  }
  if (def.type === "union") {
    for (let option of def.options)
      if (isTransforming(option, ctx))
        return !0;
    return !1;
  }
  if (def.type === "tuple") {
    for (let item of def.items)
      if (isTransforming(item, ctx))
        return !0;
    return !!(def.rest && isTransforming(def.rest, ctx));
  }
  return !1;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  let ctx = initializeContext({ ...params, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  let { libraryOptions, target } = params ?? {}, ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
};

// mcp-servers-src/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, stringProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json;
  json2.type = "string";
  let { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum == "number" && (json2.minLength = minimum), typeof maximum == "number" && (json2.maxLength = maximum), format && (json2.format = formatMap[format] ?? format, json2.format === "" && delete json2.format, format === "time" && delete json2.format), contentEncoding && (json2.contentEncoding = contentEncoding), patterns && patterns.size > 0) {
    let regexes = [...patterns];
    regexes.length === 1 ? json2.pattern = regexes[0].source : regexes.length > 1 && (json2.allOf = [
      ...regexes.map((regex) => ({
        ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: regex.source
      }))
    ]);
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json, { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  typeof format == "string" && format.includes("int") ? json2.type = "integer" : json2.type = "number", typeof exclusiveMinimum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.minimum = exclusiveMinimum, json2.exclusiveMinimum = !0) : json2.exclusiveMinimum = exclusiveMinimum), typeof minimum == "number" && (json2.minimum = minimum, typeof exclusiveMinimum == "number" && ctx.target !== "draft-04" && (exclusiveMinimum >= minimum ? delete json2.minimum : delete json2.exclusiveMinimum)), typeof exclusiveMaximum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.maximum = exclusiveMaximum, json2.exclusiveMaximum = !0) : json2.exclusiveMaximum = exclusiveMaximum), typeof maximum == "number" && (json2.maximum = maximum, typeof exclusiveMaximum == "number" && ctx.target !== "draft-04" && (exclusiveMaximum <= maximum ? delete json2.maximum : delete json2.exclusiveMaximum)), typeof multipleOf == "number" && (json2.multipleOf = multipleOf);
}, booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, nullProcessor = (_schema, ctx, json2, _params) => {
  ctx.target === "openapi-3.0" ? (json2.type = "string", json2.nullable = !0, json2.enum = [null]) : json2.type = "null";
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {
}, unknownProcessor = (_schema, _ctx, _json, _params) => {
}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, enumProcessor = (schema, _ctx, json2, _params) => {
  let def = schema._zod.def, values = getEnumValues(def.entries);
  values.every((v) => typeof v == "number") && (json2.type = "number"), values.every((v) => typeof v == "string") && (json2.type = "string"), json2.enum = values;
}, literalProcessor = (schema, ctx, json2, _params) => {
  let def = schema._zod.def, vals = [];
  for (let val of def.values)
    if (val === void 0) {
      if (ctx.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof val == "bigint") {
      if (ctx.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      vals.push(Number(val));
    } else
      vals.push(val);
  if (vals.length !== 0)
    if (vals.length === 1) {
      let val = vals[0];
      json2.type = val === null ? "null" : typeof val, ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? json2.enum = [val] : json2.const = val;
    } else
      vals.every((v) => typeof v == "number") && (json2.type = "number"), vals.every((v) => typeof v == "string") && (json2.type = "string"), vals.every((v) => typeof v == "boolean") && (json2.type = "boolean"), vals.every((v) => v === null) && (json2.type = "null"), json2.enum = vals;
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string", _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum, maximum, mime } = schema._zod.bag;
  minimum !== void 0 && (file2.minLength = minimum), maximum !== void 0 && (file2.maxLength = maximum), mime ? mime.length === 1 ? (file2.contentMediaType = mime[0], Object.assign(_json, file2)) : (Object.assign(_json, file2), _json.anyOf = mime.map((m) => ({ contentMediaType: m }))) : Object.assign(_json, file2);
}, successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, arrayProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def, { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum), json2.type = "array", json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object", json2.properties = {};
  let shape = def.shape;
  for (let key in shape)
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  let allKeys = new Set(Object.keys(shape)), requiredKeys = new Set([...allKeys].filter((key) => {
    let v = def.shape[key]._zod;
    return ctx.io === "input" ? v.optin === void 0 : v.optout === void 0;
  }));
  requiredKeys.size > 0 && (json2.required = Array.from(requiredKeys)), def.catchall?._zod.def.type === "never" ? json2.additionalProperties = !1 : def.catchall ? def.catchall && (json2.additionalProperties = process2(def.catchall, ctx, {
    ...params,
    path: [...params.path, "additionalProperties"]
  })) : ctx.io === "output" && (json2.additionalProperties = !1);
}, unionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, isExclusive = def.inclusive === !1, options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  isExclusive ? json2.oneOf = options : json2.anyOf = options;
}, intersectionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  }), b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  }), isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1, allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "array";
  let prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items", restPath = ctx.target === "draft-2020-12" || ctx.target === "openapi-3.0" ? "items" : "additionalItems", prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  })), rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  ctx.target === "draft-2020-12" ? (json2.prefixItems = prefixItems, rest && (json2.items = rest)) : ctx.target === "openapi-3.0" ? (json2.items = {
    anyOf: prefixItems
  }, rest && json2.items.anyOf.push(rest), json2.minItems = prefixItems.length, rest || (json2.maxItems = prefixItems.length)) : (json2.items = prefixItems, rest && (json2.additionalItems = rest));
  let { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum);
}, recordProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object";
  let keyType = def.keyType, patterns = keyType._zod.bag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    let valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (let pattern of patterns)
      json2.patternProperties[pattern.source] = valueSchema;
  } else
    (ctx.target === "draft-07" || ctx.target === "draft-2020-12") && (json2.propertyNames = process2(def.keyType, ctx, {
      ...params,
      path: [...params.path, "propertyNames"]
    })), json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  let keyValues = keyType._zod.values;
  if (keyValues) {
    let validKeyValues = [...keyValues].filter((v) => typeof v == "string" || typeof v == "number");
    validKeyValues.length > 0 && (json2.required = validKeyValues);
  }
}, nullableProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, inner = process2(def.innerType, ctx, params), seen = ctx.seen.get(schema);
  ctx.target === "openapi-3.0" ? (seen.ref = def.innerType, json2.nullable = !0) : json2.anyOf = [inner, { type: "null" }];
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, ctx.io === "input" && (json2._prefault = JSON.parse(JSON.stringify(def.defaultValue)));
}, catchProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def, innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.readOnly = !0;
}, promiseProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  let innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  return !!s._zod;
}
function safeParse2(schema, data) {
  return isZ4Schema(schema) ? safeParse(schema, data) : schema.safeParse(data);
}
function getObjectShape(schema) {
  if (!schema)
    return;
  let rawShape;
  if (isZ4Schema(schema) ? rawShape = schema._zod?.def?.shape : rawShape = schema.shape, !!rawShape) {
    if (typeof rawShape == "function")
      try {
        return rawShape();
      } catch {
        return;
      }
    return rawShape;
  }
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    let def2 = schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0)
        return def2.values[0];
    }
  }
  let def = schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0)
      return def.values[0];
  }
  let directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
}

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var schemas_exports3 = {};
__export(schemas_exports3, {
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object2,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// mcp-servers-src/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// mcp-servers-src/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def), ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def), ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// mcp-servers-src/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues), inst.name = "ZodError", Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, ZodError2 = $constructor("ZodError", initializer2), ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// mcp-servers-src/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError), parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError), safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError), safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError), encode2 = /* @__PURE__ */ _encode(ZodRealError), decode2 = /* @__PURE__ */ _decode(ZodRealError), encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError), decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError), safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError), safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError), safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError), safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => ($ZodType.init(inst, def), Object.assign(inst["~standard"], {
  jsonSchema: {
    input: createStandardJSONSchemaMethod(inst, "input"),
    output: createStandardJSONSchemaMethod(inst, "output")
  }
}), inst.toJSONSchema = createToJSONSchemaMethod(inst, {}), inst.def = def, inst.type = def.type, Object.defineProperty(inst, "_def", { value: def }), inst.check = (...checks) => inst.clone(util_exports.mergeDefs(def, {
  checks: [
    ...def.checks ?? [],
    ...checks.map((ch) => typeof ch == "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
  ]
}), {
  parent: !0
}), inst.with = inst.check, inst.clone = (def2, params) => clone(inst, def2, params), inst.brand = () => inst, inst.register = (reg, meta3) => (reg.add(inst, meta3), inst), inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse }), inst.safeParse = (data, params) => safeParse3(inst, data, params), inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync }), inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params), inst.spa = inst.safeParseAsync, inst.encode = (data, params) => encode2(inst, data, params), inst.decode = (data, params) => decode2(inst, data, params), inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params), inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params), inst.safeEncode = (data, params) => safeEncode2(inst, data, params), inst.safeDecode = (data, params) => safeDecode2(inst, data, params), inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params), inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params), inst.refine = (check2, params) => inst.check(refine(check2, params)), inst.superRefine = (refinement) => inst.check(superRefine(refinement)), inst.overwrite = (fn) => inst.check(_overwrite(fn)), inst.optional = () => optional(inst), inst.exactOptional = () => exactOptional(inst), inst.nullable = () => nullable(inst), inst.nullish = () => optional(nullable(inst)), inst.nonoptional = (params) => nonoptional(inst, params), inst.array = () => array(inst), inst.or = (arg) => union([inst, arg]), inst.and = (arg) => intersection(inst, arg), inst.transform = (tx) => pipe(inst, transform(tx)), inst.default = (def2) => _default(inst, def2), inst.prefault = (def2) => prefault(inst, def2), inst.catch = (params) => _catch(inst, params), inst.pipe = (target) => pipe(inst, target), inst.readonly = () => readonly(inst), inst.describe = (description) => {
  let cl = inst.clone();
  return globalRegistry.add(cl, { description }), cl;
}, Object.defineProperty(inst, "description", {
  get() {
    return globalRegistry.get(inst)?.description;
  },
  configurable: !0
}), inst.meta = (...args) => {
  if (args.length === 0)
    return globalRegistry.get(inst);
  let cl = inst.clone();
  return globalRegistry.add(cl, args[0]), cl;
}, inst.isOptional = () => inst.safeParse(void 0).success, inst.isNullable = () => inst.safeParse(null).success, inst.apply = (fn) => fn(inst), inst)), _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  let bag = inst._zod.bag;
  inst.format = bag.format ?? null, inst.minLength = bag.minimum ?? null, inst.maxLength = bag.maximum ?? null, inst.regex = (...args) => inst.check(_regex(...args)), inst.includes = (...args) => inst.check(_includes(...args)), inst.startsWith = (...args) => inst.check(_startsWith(...args)), inst.endsWith = (...args) => inst.check(_endsWith(...args)), inst.min = (...args) => inst.check(_minLength(...args)), inst.max = (...args) => inst.check(_maxLength(...args)), inst.length = (...args) => inst.check(_length(...args)), inst.nonempty = (...args) => inst.check(_minLength(1, ...args)), inst.lowercase = (params) => inst.check(_lowercase(params)), inst.uppercase = (params) => inst.check(_uppercase(params)), inst.trim = () => inst.check(_trim()), inst.normalize = (...args) => inst.check(_normalize(...args)), inst.toLowerCase = () => inst.check(_toLowerCase()), inst.toUpperCase = () => inst.check(_toUpperCase()), inst.slugify = () => inst.check(_slugify());
}), ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def), _ZodString.init(inst, def), inst.email = (params) => inst.check(_email(ZodEmail, params)), inst.url = (params) => inst.check(_url(ZodURL, params)), inst.jwt = (params) => inst.check(_jwt(ZodJWT, params)), inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.uuid = (params) => inst.check(_uuid(ZodUUID, params)), inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params)), inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params)), inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params)), inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.cuid = (params) => inst.check(_cuid(ZodCUID, params)), inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params)), inst.ulid = (params) => inst.check(_ulid(ZodULID, params)), inst.base64 = (params) => inst.check(_base64(ZodBase64, params)), inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params)), inst.xid = (params) => inst.check(_xid(ZodXID, params)), inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params)), inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params)), inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params)), inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params)), inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params)), inst.e164 = (params) => inst.check(_e164(ZodE164, params)), inst.datetime = (params) => inst.check(datetime2(params)), inst.date = (params) => inst.check(date2(params)), inst.time = (params) => inst.check(time2(params)), inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString2, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), _ZodString.init(inst, def);
}), ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def), ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def), ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def), ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def), ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def), ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def), ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def), ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def), ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def), ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def), ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def), ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  let enc = params?.enc ?? "hex", format = `${alg}_${enc}`, regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.int = (params) => inst.check(int(params)), inst.safe = (params) => inst.check(int(params)), inst.positive = (params) => inst.check(_gt(0, params)), inst.nonnegative = (params) => inst.check(_gte(0, params)), inst.negative = (params) => inst.check(_lt(0, params)), inst.nonpositive = (params) => inst.check(_lte(0, params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params)), inst.step = (value, params) => inst.check(_multipleOf(value, params)), inst.finite = () => inst;
  let bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5), inst.isFinite = !0, inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber2, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def), ZodNumber2.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.positive = (params) => inst.check(_gt(BigInt(0), params)), inst.negative = (params) => inst.check(_lt(BigInt(0), params)), inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params)), inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  let bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null, inst.maxValue = bag.maximum ?? null, inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt2, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def), ZodBigInt2.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params), inst.min = (value, params) => inst.check(_gte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params));
  let c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null, inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params), inst.element = def.element, inst.min = (minLength, params) => inst.check(_minLength(minLength, params)), inst.nonempty = (params) => inst.check(_minLength(1, params)), inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params)), inst.length = (len, params) => inst.check(_length(len, params)), inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray2, element, params);
}
function keyof(schema) {
  let shape = schema._zod.def.shape;
  return _enum(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params), util_exports.defineLazy(inst, "shape", () => def.shape), inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)), inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall }), inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() }), inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 }), inst.extend = (incoming) => util_exports.extend(inst, incoming), inst.safeExtend = (incoming) => util_exports.safeExtend(inst, incoming), inst.merge = (other) => util_exports.merge(inst, other), inst.pick = (mask) => util_exports.pick(inst, mask), inst.omit = (mask) => util_exports.omit(inst, mask), inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]), inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  let def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodXor.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: !1,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params), inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  let hasRest = _paramsOrRest instanceof $ZodType, params = hasRest ? _params : _paramsOrRest, rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  let k = clone(keyType);
  return k._zod.values = void 0, new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType, inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params), inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params), inst.enum = def.entries, inst.options = Object.values(def.entries);
  let keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    let newEntries = {};
    for (let value of values)
      if (keys.has(value))
        newEntries[value] = def.entries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  }, inst.exclude = (values, params) => {
    let newEntries = { ...def.entries };
    for (let value of values)
      if (keys.has(value))
        delete newEntries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  let entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params), inst.values = new Set(def.values), Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params), inst.min = (size, params) => inst.check(_minSize(size, params)), inst.max = (size, params) => inst.check(_maxSize(size, params)), inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params), inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    payload.addIssue = (issue2) => {
      if (typeof issue2 == "string")
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      else {
        let _issue = issue2;
        _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = inst), payload.issues.push(util_exports.issue(_issue));
      }
    };
    let output = def.transform(payload.value, payload);
    return output instanceof Promise ? output.then((output2) => (payload.value = output2, payload)) : (payload.value = output, payload);
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue == "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN2, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params), inst.in = def.in, inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def), $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  let ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return ch._zod.check = fn, ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => !0), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe, meta2 = meta;
function _instanceof(cls, params = {}) {
  let inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: !0,
    ...util_exports.normalizeParams(params)
  });
  return inst._zod.bag.Class = cls, inst._zod.check = (payload) => {
    payload.value instanceof cls || payload.issues.push({
      code: "invalid_type",
      expected: cls.name,
      input: payload.value,
      inst,
      path: [...inst._zod.def.path ?? []]
    });
  }, inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json(params) {
  let jsonSchema = lazy(() => union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]));
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// mcp-servers-src/node_modules/zod/v4/classic/compat.js
var ZodFirstPartyTypeKind2;
ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {});

// mcp-servers-src/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports3,
  ...checks_exports2,
  iso: iso_exports2
};

// mcp-servers-src/node_modules/zod/v4/classic/external.js
config(en_default2());

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"], RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task", JSONRPC_VERSION = "2.0", AssertObjectSchema = custom((v) => v !== null && (typeof v == "object" || typeof v == "function")), ProgressTokenSchema = union([string2(), number2().int()]), CursorSchema = string2(), TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number2().optional()
}), TaskMetadataSchema = object2({
  ttl: number2().optional()
}), RelatedTaskMetadataSchema = object2({
  taskId: string2()
}), RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
}), BaseRequestParamsSchema = object2({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
}), TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
}), isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success, RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.loose().optional()
}), NotificationsParamsSchema = object2({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.loose().optional()
}), ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), RequestIdSchema = union([string2(), number2().int()]), JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict(), isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success, JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict(), isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success, JSONRPCResultResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict(), isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2.ConnectionClosed = -32e3] = "ConnectionClosed", ErrorCode2[ErrorCode2.RequestTimeout = -32001] = "RequestTimeout", ErrorCode2[ErrorCode2.ParseError = -32700] = "ParseError", ErrorCode2[ErrorCode2.InvalidRequest = -32600] = "InvalidRequest", ErrorCode2[ErrorCode2.MethodNotFound = -32601] = "MethodNotFound", ErrorCode2[ErrorCode2.InvalidParams = -32602] = "InvalidParams", ErrorCode2[ErrorCode2.InternalError = -32603] = "InternalError", ErrorCode2[ErrorCode2.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object2({
    /**
     * The error type that occurred.
     */
    code: number2().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string2(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]), JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]), EmptyResultSchema = ResultSchema.strict(), CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string2().optional()
}), CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
}), IconSchema = object2({
  /**
   * URL or data URI for the icon.
   */
  src: string2(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string2().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string2()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
}), IconsSchema = object2({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
}), BaseMetadataSchema = object2({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string2(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string2().optional()
}), ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string2().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string2().optional()
}), FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown())), ElicitationCapabilitySchema = preprocess((value) => value && typeof value == "object" && !Array.isArray(value) && Object.keys(value).length === 0 ? { form: {} } : value, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional())), ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ClientCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object2({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object2({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
}), InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
}), InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object2({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object2({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean2().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object2({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
}), InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string2().optional()
}), InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
}), ProgressSchema = object2({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number2(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number2()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string2())
}), ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
}), ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
}), PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
}), PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
}), PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
}), TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]), TaskSchema = object2({
  taskId: string2(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string2(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string2(),
  pollInterval: optional(number2()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string2())
}), CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
}), TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema), TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
}), GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskResultSchema = ResultSchema.merge(TaskSchema), GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskPayloadResultSchema = ResultSchema.loose(), ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
}), ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
}), CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), CancelTaskResultSchema = ResultSchema.merge(TaskSchema), ResourceContentsSchema = object2({
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string2()
}), Base64Schema = string2().refine((val) => {
  try {
    return atob(val), !0;
  } catch {
    return !1;
  }
}, { message: "Invalid Base64 string" }), BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
}), RoleSchema = _enum(["user", "assistant"]), AnnotationsSchema = object2({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number2().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports2.datetime({ offset: !0 }).optional()
}), ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string2(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
}), ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
}), ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
}), ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
}), ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string2()
}), ReadResourceRequestParamsSchema = ResourceRequestParamsSchema, ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
}), ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
}), ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
}), SubscribeRequestParamsSchema = ResourceRequestParamsSchema, SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
}), UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema, UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
}), ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string2()
}), ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
}), PromptArgumentSchema = object2({
  /**
   * The name of the argument.
   */
  name: string2(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string2()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean2())
}), PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string2()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
}), ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
}), GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string2(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string2(), string2()).optional()
}), GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
}), TextContentSchema = object2({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ImageContentSchema = object2({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), AudioContentSchema = object2({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ToolUseContentSchema = object2({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string2(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string2(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string2(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
}), ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]), PromptMessageSchema = object2({
  role: RoleSchema,
  content: ContentBlockSchema
}), GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string2().optional(),
  messages: array(PromptMessageSchema)
}), PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ToolAnnotationsSchema = object2({
  /**
   * A human-readable title for the tool.
   */
  title: string2().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean2().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean2().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean2().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean2().optional()
}), ToolExecutionSchema = object2({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
}), ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string2().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
}), ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
}), CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string2(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean2().optional()
}), CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
})), CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string2(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string2(), unknown()).optional()
}), CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
}), ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ListChangedOptionsBaseSchema = object2({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean2().default(!0),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number2().int().nonnegative().default(300)
}), LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
}), SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
}), LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string2().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
}), LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
}), ModelHintSchema = object2({
  /**
   * A hint for a model name.
   */
  name: string2().optional()
}), ModelPreferencesSchema = object2({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number2().min(0).max(1).optional()
}), ToolChoiceSchema = object2({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
}), ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).loose().optional(),
  isError: boolean2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]), SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]), SamplingMessageSchema = object2({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string2().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
}), CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
}), CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
}), CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
}), BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
}), StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
}), NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
}), UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
}), TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
}), LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
}), SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]), UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
}), TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
}), MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]), EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]), PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]), ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string2(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
}), ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string2(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string2(),
  /**
   * The URL that the user should navigate to.
   */
  url: string2().url()
}), ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]), ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
}), ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string2()
}), ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
}), ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
}), ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string2()
}), CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object2({
    /**
     * The name of the argument
     */
    name: string2(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string2()
  }),
  context: object2({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string2(), string2()).optional()
  }).optional()
}), CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string2()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number2().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean2())
  })
}), RootSchema = object2({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string2().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
}), ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
}), RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]), ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]), ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`), this.code = code, this.data = data, this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      let errorData = data;
      if (errorData.elicitations)
        return new UrlElicitationRequiredError(errorData.elicitations, message);
    }
    return new _McpError(code, message, data);
  }
}, UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  let methodSchema = getObjectShape(schema)?.method;
  if (!methodSchema)
    throw new Error("Schema is missing a method literal");
  let value = getLiteralValue(methodSchema);
  if (typeof value != "string")
    throw new Error("Schema method literal must be a string");
  return value;
}
function parseWithCompat(schema, data) {
  let result = safeParse2(schema, data);
  if (!result.success)
    throw result.error;
  return result.data;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4, Protocol = class {
  constructor(_options) {
    this._options = _options, this._requestMessageId = 0, this._requestHandlers = /* @__PURE__ */ new Map(), this._requestHandlerAbortControllers = /* @__PURE__ */ new Map(), this._notificationHandlers = /* @__PURE__ */ new Map(), this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers = /* @__PURE__ */ new Map(), this._timeoutInfo = /* @__PURE__ */ new Map(), this._pendingDebouncedNotifications = /* @__PURE__ */ new Set(), this._taskProgressTokens = /* @__PURE__ */ new Map(), this._requestResolvers = /* @__PURE__ */ new Map(), this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    }), this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    }), this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    ), this._taskStore = _options?.taskStore, this._taskMessageQueue = _options?.taskMessageQueue, this._taskStore && (this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
      let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
      if (!task)
        throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
      return {
        ...task
      };
    }), this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
      let handleTaskResult = async () => {
        let taskId = request.params.taskId;
        if (this._taskMessageQueue) {
          let queuedMessage;
          for (; queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId); ) {
            if (queuedMessage.type === "response" || queuedMessage.type === "error") {
              let message = queuedMessage.message, requestId = message.id, resolver = this._requestResolvers.get(requestId);
              if (resolver)
                if (this._requestResolvers.delete(requestId), queuedMessage.type === "response")
                  resolver(message);
                else {
                  let errorMessage = message, error2 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                  resolver(error2);
                }
              else {
                let messageType = queuedMessage.type === "response" ? "Response" : "Error";
                this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
              }
              continue;
            }
            await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
          }
        }
        let task = await this._taskStore.getTask(taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
        if (!isTerminal(task.status))
          return await this._waitForTaskUpdate(taskId, extra.signal), await handleTaskResult();
        if (isTerminal(task.status)) {
          let result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
          return this._clearTaskQueue(taskId), {
            ...result,
            _meta: {
              ...result._meta,
              [RELATED_TASK_META_KEY]: {
                taskId
              }
            }
          };
        }
        return await handleTaskResult();
      };
      return await handleTaskResult();
    }), this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
      try {
        let { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
        return {
          tasks,
          nextCursor,
          _meta: {}
        };
      } catch (error2) {
        throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }), this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
      try {
        let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
        await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId), this._clearTaskQueue(request.params.taskId);
        let cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!cancelledTask)
          throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
        return {
          _meta: {},
          ...cancelledTask
        };
      } catch (error2) {
        throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }));
  }
  async _oncancel(notification) {
    if (!notification.params.requestId)
      return;
    this._requestHandlerAbortControllers.get(notification.params.requestId)?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = !1) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    if (!info)
      return !1;
    let totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout)
      throw this._timeoutInfo.delete(messageId), McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    return clearTimeout(info.timeoutId), info.timeoutId = setTimeout(info.onTimeout, info.timeout), !0;
  }
  _cleanupTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    info && (clearTimeout(info.timeoutId), this._timeoutInfo.delete(messageId));
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport)
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    this._transport = transport;
    let _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.(), this._onclose();
    };
    let _onerror = this.transport?.onerror;
    this._transport.onerror = (error2) => {
      _onerror?.(error2), this._onerror(error2);
    };
    let _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra), isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message) ? this._onresponse(message) : isJSONRPCRequest(message) ? this._onrequest(message, extra) : isJSONRPCNotification(message) ? this._onnotification(message) : this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
    }, await this._transport.start();
  }
  _onclose() {
    let responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
    for (let controller of this._requestHandlerAbortControllers.values())
      controller.abort();
    this._requestHandlerAbortControllers.clear();
    let error2 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0, this.onclose?.();
    for (let handler of responseHandlers.values())
      handler(error2);
  }
  _onerror(error2) {
    this.onerror?.(error2);
  }
  _onnotification(notification) {
    let handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    handler !== void 0 && Promise.resolve().then(() => handler(notification)).catch((error2) => this._onerror(new Error(`Uncaught error in notification handler: ${error2}`)));
  }
  _onrequest(request, extra) {
    let handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler, capturedTransport = this._transport, relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      relatedTaskId && this._taskMessageQueue ? this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId).catch((error2) => this._onerror(new Error(`Failed to enqueue error response: ${error2}`))) : capturedTransport?.send(errorResponse).catch((error2) => this._onerror(new Error(`Failed to send an error response: ${error2}`)));
      return;
    }
    let abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    let taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0, taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0, fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        let notificationOptions = { relatedRequestId: request.id };
        relatedTaskId && (notificationOptions.relatedTask = { taskId: relatedTaskId }), await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        if (abortController.signal.aborted)
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        let requestOptions = { ...options, relatedRequestId: request.id };
        relatedTaskId && !requestOptions.relatedTask && (requestOptions.relatedTask = { taskId: relatedTaskId });
        let effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        return effectiveTaskId && taskStore && await taskStore.updateTaskStatus(effectiveTaskId, "input_required"), await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      taskCreationParams && this.assertTaskHandlerCapability(request.method);
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted)
        return;
      let response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "response",
        message: response,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(response);
    }, async (error2) => {
      if (abortController.signal.aborted)
        return;
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error2.code) ? error2.code : ErrorCode.InternalError,
          message: error2.message ?? "Internal error",
          ...error2.data !== void 0 && { data: error2.data }
        }
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(errorResponse);
    }).catch((error2) => this._onerror(new Error(`Failed to send response: ${error2}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    let { progressToken, ...params } = notification.params, messageId = Number(progressToken), handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    let responseHandler = this._responseHandlers.get(messageId), timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress)
      try {
        this._resetTimeout(messageId);
      } catch (error2) {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), responseHandler(error2);
        return;
      }
    handler(params);
  }
  _onresponse(response) {
    let messageId = Number(response.id), resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      if (this._requestResolvers.delete(messageId), isJSONRPCResultResponse(response))
        resolver(response);
      else {
        let error2 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error2);
      }
      return;
    }
    let handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId), this._cleanupTimeout(messageId);
    let isTaskResponse = !1;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result == "object") {
      let result = response.result;
      if (result.task && typeof result.task == "object") {
        let task = result.task;
        typeof task.taskId == "string" && (isTaskResponse = !0, this._taskProgressTokens.set(task.taskId, messageId));
      }
    }
    if (isTaskResponse || this._progressHandlers.delete(messageId), isJSONRPCResultResponse(response))
      handler(response);
    else {
      let error2 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error2);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    let { task } = options ?? {};
    if (!task) {
      try {
        yield { type: "result", result: await this.request(request, resultSchema, options) };
      } catch (error2) {
        yield {
          type: "error",
          error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
        };
      }
      return;
    }
    let taskId;
    try {
      let createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task)
        taskId = createResult.task.taskId, yield { type: "taskCreated", task: createResult.task };
      else
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      for (; ; ) {
        let task2 = await this.getTask({ taskId }, options);
        if (yield { type: "taskStatus", task: task2 }, isTerminal(task2.status)) {
          task2.status === "completed" ? yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) } : task2.status === "failed" ? yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
          } : task2.status === "cancelled" && (yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
          });
          return;
        }
        if (task2.status === "input_required") {
          yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) };
          return;
        }
        let pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval)), options?.signal?.throwIfAborted();
      }
    } catch (error2) {
      yield {
        type: "error",
        error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    let { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      let earlyReject = (error2) => {
        reject(error2);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === !0)
        try {
          this.assertCapabilityForMethod(request.method), task && this.assertTaskCapability(request.method);
        } catch (e) {
          earlyReject(e);
          return;
        }
      options?.signal?.throwIfAborted();
      let messageId = this._requestMessageId++, jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      options?.onprogress && (this._progressHandlers.set(messageId, options.onprogress), jsonrpcRequest.params = {
        ...request.params,
        _meta: {
          ...request.params?._meta || {},
          progressToken: messageId
        }
      }), task && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        task
      }), relatedTask && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        _meta: {
          ...jsonrpcRequest.params?._meta || {},
          [RELATED_TASK_META_KEY]: relatedTask
        }
      });
      let cancel = (reason) => {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error3) => this._onerror(new Error(`Failed to send cancellation: ${error3}`)));
        let error2 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error2);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (!options?.signal?.aborted) {
          if (response instanceof Error)
            return reject(response);
          try {
            let parseResult = safeParse2(resultSchema, response.result);
            parseResult.success ? resolve(parseResult.data) : reject(parseResult.error);
          } catch (error2) {
            reject(error2);
          }
        }
      }), options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      let timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC, timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? !1);
      let relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        let responseResolver = (response) => {
          let handler = this._responseHandlers.get(messageId);
          handler ? handler(response) : this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
        };
        this._requestResolvers.set(messageId, responseResolver), this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
      } else
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport)
      throw new Error("Not connected");
    this.assertNotificationCapability(notification.method);
    let relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      let jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    if ((this._options?.debouncedNotificationMethods ?? []).includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask) {
      if (this._pendingDebouncedNotifications.has(notification.method))
        return;
      this._pendingDebouncedNotifications.add(notification.method), Promise.resolve().then(() => {
        if (this._pendingDebouncedNotifications.delete(notification.method), !this._transport)
          return;
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        options?.relatedTask && (jsonrpcNotification2 = {
          ...jsonrpcNotification2,
          params: {
            ...jsonrpcNotification2.params,
            _meta: {
              ...jsonrpcNotification2.params?._meta || {},
              [RELATED_TASK_META_KEY]: options.relatedTask
            }
          }
        }), this._transport?.send(jsonrpcNotification2, options).catch((error2) => this._onerror(error2));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    options?.relatedTask && (jsonrpcNotification = {
      ...jsonrpcNotification,
      params: {
        ...jsonrpcNotification.params,
        _meta: {
          ...jsonrpcNotification.params?._meta || {},
          [RELATED_TASK_META_KEY]: options.relatedTask
        }
      }
    }), await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    let method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method), this._requestHandlers.set(method, (request, extra) => {
      let parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method))
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    let method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      let parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    let progressToken = this._taskProgressTokens.get(taskId);
    progressToken !== void 0 && (this._progressHandlers.delete(progressToken), this._taskProgressTokens.delete(taskId));
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue)
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    let maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      let messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (let message of messages)
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          let requestId = message.message.id, resolver = this._requestResolvers.get(requestId);
          resolver ? (resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(requestId)) : this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
        }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      let task = await this._taskStore?.getTask(taskId);
      task?.pollInterval && (interval = task.pollInterval);
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      let timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId), reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: !0 });
    });
  }
  requestTaskStore(request, sessionId) {
    let taskStore = this._taskStore;
    if (!taskStore)
      throw new Error("No task store configured");
    return {
      createTask: async (taskParams) => {
        if (!request)
          throw new Error("No request provided");
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        let task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification), isTerminal(task.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      getTaskResult: (taskId) => taskStore.getTaskResult(taskId, sessionId),
      updateTaskStatus: async (taskId, status, statusMessage) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        let updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification), isTerminal(updatedTask.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      listTasks: (cursor) => taskStore.listTasks(cursor, sessionId)
    };
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  let result = { ...base };
  for (let key in additional) {
    let k = key, addValue = additional[k];
    if (addValue === void 0)
      continue;
    let baseValue = result[k];
    isPlainObject2(baseValue) && isPlainObject2(addValue) ? result[k] = { ...baseValue, ...addValue } : result[k] = addValue;
  }
  return result;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1), import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  let ajv = new import_ajv.default({
    strict: !1,
    validateFormats: !0,
    validateSchema: !1,
    allErrors: !0
  });
  return (0, import_ajv_formats.default)(ajv), ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    let ajvValidator = "$id" in schema && typeof schema.$id == "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => ajvValidator(input) ? {
      valid: !0,
      data: input,
      errorMessage: void 0
    } : {
      valid: !1,
      data: void 0,
      errorMessage: this._ajv.errorsText(ajvValidator.errors)
    };
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
var ExperimentalServerTasks = class {
  constructor(_server) {
    this._server = _server;
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._server.requestStream(request, resultSchema, options);
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._server.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._server.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._server.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._server.cancelTask({ taskId }, options);
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call)
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage)
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create)
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      break;
    default:
      break;
  }
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server = class extends Protocol {
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    super(options), this._serverInfo = _serverInfo, this._loggingLevels = /* @__PURE__ */ new Map(), this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index])), this.isMessageIgnored = (level, sessionId) => {
      let currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : !1;
    }, this._capabilities = options?.capabilities ?? {}, this._instructions = options?.instructions, this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator(), this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request)), this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.()), this._capabilities.logging && this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
      let transportSessionId = extra.sessionId || extra.requestInfo?.headers["mcp-session-id"] || void 0, { level } = request.params, parseResult = LoggingLevelSchema.safeParse(level);
      return parseResult.success && this._loggingLevels.set(transportSessionId, parseResult.data), {};
    });
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    return this._experimental || (this._experimental = {
      tasks: new ExperimentalServerTasks(this)
    }), this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport)
      throw new Error("Cannot register capabilities after connecting to transport");
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce server-side validation for tools/call.
   */
  setRequestHandler(requestSchema, handler) {
    let methodSchema = getObjectShape(requestSchema)?.method;
    if (!methodSchema)
      throw new Error("Schema is missing a method literal");
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      let v4Schema = methodSchema;
      methodValue = v4Schema._zod?.def?.value ?? v4Schema.value;
    } else {
      let v3Schema = methodSchema;
      methodValue = v3Schema._def?.value ?? v3Schema.value;
    }
    if (typeof methodValue != "string")
      throw new Error("Schema method literal must be a string");
    if (methodValue === "tools/call") {
      let wrappedHandler = async (request, extra) => {
        let validatedRequest = safeParse2(CallToolRequestSchema, request);
        if (!validatedRequest.success) {
          let errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
        }
        let { params } = validatedRequest.data, result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          let taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            let errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        let validationResult = safeParse2(CallToolResultSchema, result);
        if (!validationResult.success) {
          let errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._clientCapabilities?.sampling)
          throw new Error(`Client does not support sampling (required for ${method})`);
        break;
      case "elicitation/create":
        if (!this._clientCapabilities?.elicitation)
          throw new Error(`Client does not support elicitation (required for ${method})`);
        break;
      case "roots/list":
        if (!this._clientCapabilities?.roots)
          throw new Error(`Client does not support listing roots (required for ${method})`);
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging)
          throw new Error(`Server does not support logging (required for ${method})`);
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources)
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools)
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts)
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        break;
      case "notifications/elicitation/complete":
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error(`Client does not support URL elicitation (required for ${method})`);
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (this._capabilities)
      switch (method) {
        case "completion/complete":
          if (!this._capabilities.completions)
            throw new Error(`Server does not support completions (required for ${method})`);
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging)
            throw new Error(`Server does not support logging (required for ${method})`);
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts)
            throw new Error(`Server does not support prompts (required for ${method})`);
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources)
            throw new Error(`Server does not support resources (required for ${method})`);
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools)
            throw new Error(`Server does not support tools (required for ${method})`);
          break;
        case "tasks/get":
        case "tasks/list":
        case "tasks/result":
        case "tasks/cancel":
          if (!this._capabilities.tasks)
            throw new Error(`Server does not support tasks capability (required for ${method})`);
          break;
        case "ping":
        case "initialize":
          break;
      }
  }
  assertTaskCapability(method) {
    assertClientRequestTaskCapability(this._clientCapabilities?.tasks?.requests, method, "Client");
  }
  assertTaskHandlerCapability(method) {
    this._capabilities && assertToolsCallTaskCapability(this._capabilities.tasks?.requests, method, "Server");
  }
  async _oninitialize(request) {
    let requestedVersion = request.params.protocolVersion;
    return this._clientCapabilities = request.params.capabilities, this._clientVersion = request.params.clientInfo, {
      protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  // Implementation
  async createMessage(params, options) {
    if ((params.tools || params.toolChoice) && !this._clientCapabilities?.sampling?.tools)
      throw new Error("Client does not support sampling tools capability.");
    if (params.messages.length > 0) {
      let lastMessage = params.messages[params.messages.length - 1], lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content], hasToolResults = lastContent.some((c) => c.type === "tool_result"), previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0, previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [], hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
      if (hasToolResults) {
        if (lastContent.some((c) => c.type !== "tool_result"))
          throw new Error("The last message must contain only tool_result content if any is present");
        if (!hasPreviousToolUse)
          throw new Error("tool_result blocks are not matching any tool_use from the previous message");
      }
      if (hasPreviousToolUse) {
        let toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id)), toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
        if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id)))
          throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
      }
    }
    return params.tools ? this.request({ method: "sampling/createMessage", params }, CreateMessageResultWithToolsSchema, options) : this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  /**
   * Creates an elicitation request for the given parameters.
   * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
   * @param params The parameters for the elicitation request.
   * @param options Optional request options.
   * @returns The result of the elicitation request.
   */
  async elicitInput(params, options) {
    switch (params.mode ?? "form") {
      case "url": {
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error("Client does not support url elicitation.");
        let urlParams = params;
        return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options);
      }
      case "form": {
        if (!this._clientCapabilities?.elicitation?.form)
          throw new Error("Client does not support form elicitation.");
        let formParams = params.mode === "form" ? params : { ...params, mode: "form" }, result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content && formParams.requestedSchema)
          try {
            let validationResult = this._jsonSchemaValidator.getValidator(formParams.requestedSchema)(result.content);
            if (!validationResult.valid)
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
          } catch (error2) {
            throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error2 instanceof Error ? error2.message : String(error2)}`);
          }
        return result;
      }
    }
  }
  /**
   * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
   * notification for the specified elicitation ID.
   *
   * @param elicitationId The ID of the elicitation to mark as complete.
   * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
   * @returns A function that emits the completion notification when awaited.
   */
  createElicitationCompletionNotifier(elicitationId, options) {
    if (!this._clientCapabilities?.elicitation?.url)
      throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
    return () => this.notification({
      method: "notifications/elicitation/complete",
      params: {
        elicitationId
      }
    }, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging && !this.isMessageIgnored(params.level, sessionId))
      return this.notification({ method: "notifications/message", params });
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var import_node_process = __toESM(require("node:process"), 1);

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer)
      return null;
    let index = this._buffer.indexOf(`
`);
    if (index === -1)
      return null;
    let line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    return this._buffer = this._buffer.subarray(index + 1), deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var StdioServerTransport = class {
  constructor(_stdin = import_node_process.default.stdin, _stdout = import_node_process.default.stdout) {
    this._stdin = _stdin, this._stdout = _stdout, this._readBuffer = new ReadBuffer(), this._started = !1, this._ondata = (chunk) => {
      this._readBuffer.append(chunk), this.processReadBuffer();
    }, this._onerror = (error2) => {
      this.onerror?.(error2);
    };
  }
  /**
   * Starts listening for messages on stdin.
   */
  async start() {
    if (this._started)
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    this._started = !0, this._stdin.on("data", this._ondata), this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    for (; ; )
      try {
        let message = this._readBuffer.readMessage();
        if (message === null)
          break;
        this.onmessage?.(message);
      } catch (error2) {
        this.onerror?.(error2);
      }
  }
  async close() {
    this._stdin.off("data", this._ondata), this._stdin.off("error", this._onerror), this._stdin.listenerCount("data") === 0 && this._stdin.pause(), this._readBuffer.clear(), this.onclose?.();
  }
  send(message) {
    return new Promise((resolve) => {
      let json2 = serializeMessage(message);
      this._stdout.write(json2) ? resolve() : this._stdout.once("drain", resolve);
    });
  }
};

// mcp-servers-src/fedlex-sparql/src/sparql-client.ts
var DEFAULT_CONFIG = {
  endpoint: "https://fedlex.data.admin.ch/sparqlendpoint",
  // Correct Fedlex SPARQL endpoint
  timeout: 3e4,
  // 30 seconds
  maxRetries: 3,
  retryDelay: 1e3,
  // 1 second
  userAgent: "BetterCallClaude/2.0.1 (Swiss Legal Intelligence)"
}, SPARQLClient = class {
  config;
  constructor(config2 = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config2 };
  }
  /**
   * Execute a SPARQL SELECT query
   */
  async query(sparql, options = {}) {
    let { format = "json", timeout = this.config.timeout, acceptLanguage } = options, headers = {
      Accept: format === "json" ? "application/sparql-results+json" : "application/sparql-results+xml",
      "Content-Type": "application/x-www-form-urlencoded",
      "User-Agent": this.config.userAgent
    };
    acceptLanguage && (headers["Accept-Language"] = acceptLanguage);
    let body = new URLSearchParams({
      query: sparql
    }), lastError = null;
    for (let attempt = 0; attempt < this.config.maxRetries; attempt++)
      try {
        let controller = new AbortController(), timeoutId = setTimeout(() => controller.abort(), timeout), response = await fetch(this.config.endpoint, {
          method: "POST",
          headers,
          body: body.toString(),
          signal: controller.signal
        });
        if (clearTimeout(timeoutId), !response.ok) {
          let errorText = await response.text();
          throw new Error(`SPARQL query failed: ${response.status} ${response.statusText} - ${errorText}`);
        }
        return await response.json();
      } catch (error2) {
        if (lastError = error2, lastError.message.includes("4"))
          throw this.createFedlexError(lastError, sparql);
        attempt < this.config.maxRetries - 1 && await this.delay(this.config.retryDelay * (attempt + 1));
      }
    throw this.createFedlexError(lastError, sparql);
  }
  /**
   * Execute a SPARQL ASK query
   */
  async ask(sparql, options = {}) {
    return (await this.query(sparql, options)).boolean ?? !1;
  }
  /**
   * Execute a SPARQL DESCRIBE query
   */
  async describe(sparql, options = {}) {
    return this.query(sparql, { ...options, format: "json" });
  }
  /**
   * Helper to extract a single value from bindings
   */
  extractValue(binding) {
    return binding?.value;
  }
  /**
   * Helper to extract a localized value based on language preference
   */
  extractLocalizedValue(bindings, variableName, preferredLang = "de") {
    for (let binding of bindings) {
      let value = binding[variableName];
      if (value && value["xml:lang"] === preferredLang)
        return value.value;
    }
    for (let binding of bindings) {
      let value = binding[variableName];
      if (value)
        return value.value;
    }
  }
  /**
   * Helper to extract multilingual values
   */
  extractMultilingualValue(bindings, variableName) {
    let result = {};
    for (let binding of bindings) {
      let value = binding[variableName];
      value && value["xml:lang"] ? result[value["xml:lang"]] = value.value : value && !Object.keys(result).length && (result.de = value.value);
    }
    return result;
  }
  /**
   * Helper to group bindings by a key variable
   */
  groupBindings(bindings, keyVariable) {
    let groups = /* @__PURE__ */ new Map();
    for (let binding of bindings) {
      let key = this.extractValue(binding[keyVariable]);
      if (key) {
        let group = groups.get(key) || [];
        group.push(binding), groups.set(key, group);
      }
    }
    return groups;
  }
  /**
   * Validate a SPARQL query syntax (basic check)
   */
  validateQuery(sparql) {
    let trimmed = sparql.trim().toUpperCase();
    if (!trimmed.startsWith("SELECT") && !trimmed.startsWith("ASK") && !trimmed.startsWith("DESCRIBE") && !trimmed.startsWith("CONSTRUCT") && !trimmed.startsWith("PREFIX"))
      return { valid: !1, error: "Query must start with SELECT, ASK, DESCRIBE, CONSTRUCT, or PREFIX" };
    let openBraces = (sparql.match(/{/g) || []).length, closeBraces = (sparql.match(/}/g) || []).length;
    return openBraces !== closeBraces ? { valid: !1, error: "Unbalanced braces in query" } : { valid: !0 };
  }
  /**
   * Create a FedlexError from an Error
   */
  createFedlexError(error2, query) {
    return {
      code: "SPARQL_ERROR",
      message: error2.message,
      query,
      endpoint: this.config.endpoint
    };
  }
  /**
   * Delay helper for retry logic
   */
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Get the configured endpoint URL
   */
  getEndpoint() {
    return this.config.endpoint;
  }
  /**
   * Update client configuration
   */
  updateConfig(config2) {
    this.config = { ...this.config, ...config2 };
  }
};
function createFedlexClient(config2) {
  return new SPARQLClient({
    ...DEFAULT_CONFIG,
    ...config2
  });
}
function escapeForSPARQL(value) {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}

// mcp-servers-src/fedlex-sparql/src/queries/prefixes.ts
var RDF_PREFIXES = `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX dcterms: <http://purl.org/dc/terms/>
PREFIX dcat: <http://www.w3.org/ns/dcat#>
`, FEDLEX_PREFIXES = `
PREFIX eli: <http://data.europa.eu/eli/ontology#>
PREFIX jolux: <http://data.legilux.public.lu/resource/ontology/jolux#>
PREFIX fedlex: <https://fedlex.data.admin.ch/vocabulary/>
PREFIX fedlex-eli: <https://fedlex.data.admin.ch/eli/>
PREFIX fedlex-cc: <https://fedlex.data.admin.ch/eli/cc/>
PREFIX schema: <http://schema.org/>
`, LINDAS_PREFIXES = `
PREFIX ld: <https://ld.admin.ch/>
PREFIX cube: <https://cube.link/>
PREFIX qudt: <http://qudt.org/schema/qudt/>
`, ALL_PREFIXES = `${RDF_PREFIXES}${FEDLEX_PREFIXES}${LINDAS_PREFIXES}`;
function withPrefixes(query) {
  return `${ALL_PREFIXES}
${query}`;
}

// mcp-servers-src/fedlex-sparql/src/queries/lookup.ts
function buildLookupStatuteQuery(srNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?inForce ?dateInForce ?dateDocument ?actType
WHERE {
  # Find act via taxonomy classification
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  # Get SR number from taxonomy
  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get title from taxonomy prefLabel (has language tags)
  ?taxonomy skos:prefLabel ?title .
  ${langFilter}

  # Optional metadata
  OPTIONAL { ?act jolux:titleShort ?abbreviation }
  OPTIONAL { ?act jolux:dateDocument ?dateDocument }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
  OPTIONAL { ?act jolux:typeDocument ?actType }

  # Check if currently in force
  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }
}
ORDER BY ?srNumber
LIMIT 10
  `);
}
function buildLookupByAbbreviationQuery(abbreviation, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?inForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  ?taxonomy skos:prefLabel ?title .
  ${langFilter}

  # Search for abbreviation in various places
  {
    ?act jolux:titleShort ?abbreviation .
    FILTER(UCASE(STR(?abbreviation)) = "${escapeForSPARQL(abbreviation.toUpperCase())}")
  } UNION {
    ?taxonomy skos:altLabel ?abbreviation .
    FILTER(UCASE(STR(?abbreviation)) = "${escapeForSPARQL(abbreviation.toUpperCase())}")
  }

  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }
}
ORDER BY ?srNumber
LIMIT 10
  `);
}

// mcp-servers-src/fedlex-sparql/src/queries/articles.ts
function buildGetArticleQuery(srNumber, articleNumber, language) {
  let langFilter = language ? `FILTER(LANG(?actTitle) = "${language}")` : "", normalizedArticle = articleNumber.replace(/^Art\.?\s*/i, "").trim();
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?actTitle ?article ?articleNumber ?articleTitle ?text ?paragraphNum ?paragraphText
WHERE {
  # Find the act via taxonomy (ConsolidationAbstract for consolidated laws)
  ?act a jolux:ConsolidationAbstract ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?actTitle .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  # Find articles that belong to this act (inverse relationship: article \u2192 parent)
  ?article a jolux:LegalResourceSubdivision ;
           jolux:legalResourceSubdivisionIsPartOf ?act ;
           jolux:legalResourceSubdivisionType <https://fedlex.data.admin.ch/vocabulary/subdivision-type/art> .

  # Get article number from subdivision detail
  ?article jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?detail .
  ?detail jolux:legalResourceSubdivisionDetailId ?articleNumber .

  # Match article number
  FILTER(
    STR(?articleNumber) = "${escapeForSPARQL(normalizedArticle)}" ||
    REGEX(STR(?articleNumber), "^${escapeForSPARQL(normalizedArticle)}[a-z]?$", "i")
  )

  # Article title (marginal note) from expression
  OPTIONAL {
    ?article jolux:isRealizedBy ?articleExpr .
    ?articleExpr jolux:title ?articleTitle .
    ${language ? `FILTER(LANG(?articleTitle) = "${language}")` : ""}
  }

  # Get text content from manifestation
  OPTIONAL {
    ?article jolux:isRealizedBy ?expr .
    ?expr jolux:isEmbodiedBy ?manif .
    ?manif jolux:text ?text .
  }

  # Paragraphs (sub-subdivisions)
  OPTIONAL {
    ?paragraph a jolux:LegalResourceSubdivision ;
               jolux:legalResourceSubdivisionIsPartOf ?article .
    ?paragraph jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?pDetail .
    ?pDetail jolux:legalResourceSubdivisionDetailId ?paragraphNum .

    OPTIONAL {
      ?paragraph jolux:isRealizedBy ?pExpr .
      ?pExpr jolux:isEmbodiedBy ?pManif .
      ?pManif jolux:text ?paragraphText .
    }
  }
}
ORDER BY ?paragraphNum
  `);
}
function buildGetArticleParagraphQuery(srNumber, articleNumber, paragraphNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", normalizedArticle = articleNumber.replace(/^Art\.?\s*/i, "").trim();
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?article ?articleNumber ?paragraph ?paragraphNum ?text
WHERE {
  ?act a jolux:ConsolidationAbstract ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  # Find article via inverse relationship
  ?article a jolux:LegalResourceSubdivision ;
           jolux:legalResourceSubdivisionIsPartOf ?act ;
           jolux:legalResourceSubdivisionType <https://fedlex.data.admin.ch/vocabulary/subdivision-type/art> .

  ?article jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?detail .
  ?detail jolux:legalResourceSubdivisionDetailId ?articleNumber .

  FILTER(
    STR(?articleNumber) = "${escapeForSPARQL(normalizedArticle)}" ||
    REGEX(STR(?articleNumber), "^${escapeForSPARQL(normalizedArticle)}[a-z]?$", "i")
  )

  # Find paragraph within article
  ?paragraph a jolux:LegalResourceSubdivision ;
             jolux:legalResourceSubdivisionIsPartOf ?article .

  ?paragraph jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?pDetail .
  ?pDetail jolux:legalResourceSubdivisionDetailId ?paragraphNum .

  FILTER(STR(?paragraphNum) = "${escapeForSPARQL(paragraphNumber)}")

  # Get paragraph text
  OPTIONAL {
    ?paragraph jolux:isRealizedBy ?pExpr .
    ?pExpr jolux:isEmbodiedBy ?pManif .
    ?pManif jolux:text ?text .
  }
}
  `);
}

// mcp-servers-src/fedlex-sparql/src/queries/search.ts
function buildSearchQuery(searchText, filters = {}) {
  let {
    language,
    actType,
    // status filter not yet implemented - Fedlex uses jolux:inForce vocabulary
    srNumberPrefix,
    limit = 50,
    offset = 0
  } = filters, langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", srPrefixFilter = srNumberPrefix ? `FILTER(STRSTARTS(STR(?srNumber), "${escapeForSPARQL(srNumberPrefix)}"))` : "", actTypeFilter = actType && actType.length > 0 ? `FILTER(?actType IN (${actType.map((t) => `"${t}"`).join(", ")}))` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?actType ?dateInForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  # Get SR number from taxonomy
  ?taxonomy skos:notation ?srNumber .

  # Get title from taxonomy prefLabel (has language tags)
  ?taxonomy skos:prefLabel ?title .

  # Text search in title or SR number
  FILTER(
    CONTAINS(LCASE(STR(?title)), LCASE("${escapeForSPARQL(searchText)}")) ||
    CONTAINS(LCASE(STR(?srNumber)), LCASE("${escapeForSPARQL(searchText)}"))
  )

  ${langFilter}
  ${srPrefixFilter}
  ${actTypeFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
  OPTIONAL { ?act jolux:typeDocument ?actType }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
}
ORDER BY ?srNumber
OFFSET ${offset}
LIMIT ${limit}
  `);
}
function buildSearchCountQuery(searchText, filters = {}) {
  let { language, srNumberPrefix, actType } = filters, langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", srPrefixFilter = srNumberPrefix ? `FILTER(STRSTARTS(STR(?srNumber), "${escapeForSPARQL(srNumberPrefix)}"))` : "", actTypeFilter = actType && actType.length > 0 ? `FILTER(?actType IN (${actType.map((t) => `"${t}"`).join(", ")}))` : "";
  return withPrefixes(`
SELECT (COUNT(DISTINCT ?act) AS ?count)
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(
    CONTAINS(LCASE(STR(?title)), LCASE("${escapeForSPARQL(searchText)}")) ||
    CONTAINS(LCASE(STR(?srNumber)), LCASE("${escapeForSPARQL(searchText)}"))
  )

  ${langFilter}
  ${srPrefixFilter}
  ${actTypeFilter}

  OPTIONAL { ?act jolux:typeDocument ?actType }
}
  `);
}
function buildSearchByDomainQuery(domain2, language, limit = 100) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STRSTARTS(STR(?srNumber), "${escapeForSPARQL(domain2)}"))
  ${langFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
}
ORDER BY ?srNumber
LIMIT ${limit}
  `);
}
function buildSearchByDateQuery(dateFrom, dateTo, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", dateFilter = "";
  return dateFrom && dateTo ? dateFilter = `FILTER(?dateInForce >= "${dateFrom}"^^xsd:date && ?dateInForce <= "${dateTo}"^^xsd:date)` : dateFrom ? dateFilter = `FILTER(?dateInForce >= "${dateFrom}"^^xsd:date)` : dateTo && (dateFilter = `FILTER(?dateInForce <= "${dateTo}"^^xsd:date)`), withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?dateInForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy ;
       jolux:dateEntryInForce ?dateInForce .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  ${dateFilter}
  ${langFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
}
ORDER BY DESC(?dateInForce)
LIMIT ${limit}
  `);
}
var LEGAL_DOMAINS = {
  1: { de: "Staat - Volk - Beh\xF6rden", fr: "\xC9tat - Peuple - Autorit\xE9s", it: "Stato - Popolo - Autorit\xE0" },
  2: { de: "Privatrecht - Zivilrechtspflege - Vollstreckung", fr: "Droit priv\xE9 - Proc\xE9dure civile - Ex\xE9cution forc\xE9e", it: "Diritto privato - Procedura civile - Esecuzione" },
  3: { de: "Strafrecht - Strafrechtspflege - Strafvollzug", fr: "Droit p\xE9nal - Proc\xE9dure p\xE9nale - Ex\xE9cution des peines", it: "Diritto penale - Procedura penale - Esecuzione delle pene" },
  4: { de: "Schule - Wissenschaft - Kultur", fr: "\xC9cole - Science - Culture", it: "Scuola - Scienza - Cultura" },
  5: { de: "Landesverteidigung", fr: "D\xE9fense nationale", it: "Difesa nazionale" },
  6: { de: "Finanzen", fr: "Finances", it: "Finanze" },
  7: { de: "\xD6ffentliche Werke - Energie - Verkehr", fr: "Travaux publics - \xC9nergie - Transports", it: "Lavori pubblici - Energia - Trasporti" },
  8: { de: "Gesundheit - Arbeit - Soziale Sicherheit", fr: "Sant\xE9 - Travail - S\xE9curit\xE9 sociale", it: "Sanit\xE0 - Lavoro - Sicurezza sociale" },
  9: { de: "Wirtschaft - Technische Zusammenarbeit", fr: "\xC9conomie - Coop\xE9ration technique", it: "Economia - Cooperazione tecnica" }
};

// mcp-servers-src/fedlex-sparql/src/queries/related.ts
function buildFindAmendingActsQuery(srNumber, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?amendingTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?amendingAct ?amendingSrNumber ?amendingTitle ?amendmentDate ?amendmentType
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Find acts that amend this act via consolidation links
  # JOLUX uses legalResourceImpactHasLegalResource or similar predicates
  {
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?act .
    ?impactEntry jolux:impactFromLegalResource ?amendingAct .
  } UNION {
    # Alternative: direct amendment relationship if available
    ?amendingAct jolux:legalResourceLegalResourceAmends ?act .
  }

  ?amendingAct a jolux:Act ;
               jolux:classifiedByTaxonomyEntry ?amendingTax .

  ?amendingTax skos:notation ?amendingSrNumber ;
               skos:prefLabel ?amendingTitle .

  ${langFilter}

  OPTIONAL { ?amendingAct jolux:dateDocument ?amendmentDate }
  OPTIONAL { ?amendingAct jolux:typeDocument ?amendmentType }
}
ORDER BY DESC(?amendmentDate)
LIMIT ${limit}
  `);
}
function buildFindAmendedActsQuery(srNumber, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?amendedTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?amendedAct ?amendedSrNumber ?amendedTitle
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Find acts amended by this act
  {
    ?impactEntry jolux:impactFromLegalResource ?act .
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?amendedAct .
  } UNION {
    ?act jolux:legalResourceLegalResourceAmends ?amendedAct .
  }

  ?amendedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?amendedTax .

  ?amendedTax skos:notation ?amendedSrNumber ;
              skos:prefLabel ?amendedTitle .

  ${langFilter}
}
ORDER BY ?amendedSrNumber
LIMIT ${limit}
  `);
}
function buildFindReferencingActsQuery(srNumber, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?referencingTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?referencingAct ?referencingSrNumber ?referencingTitle ?referenceType
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Find acts that reference this act via various relationship types
  {
    ?referencingAct jolux:legalResourceLegalResourceCites ?act .
    BIND("cites" AS ?referenceType)
  } UNION {
    ?referencingAct jolux:legalResourceLegalResourceBasedOn ?act .
    BIND("based_on" AS ?referenceType)
  } UNION {
    ?referencingAct jolux:legalResourceLegalResourceImplements ?act .
    BIND("implements" AS ?referenceType)
  }

  ?referencingAct a jolux:Act ;
                  jolux:classifiedByTaxonomyEntry ?refTax .

  ?refTax skos:notation ?referencingSrNumber ;
          skos:prefLabel ?referencingTitle .

  ${langFilter}
}
ORDER BY ?referencingSrNumber
LIMIT ${limit}
  `);
}
function buildFindRelatedByDomainQuery(srNumber, language, limit = 20) {
  let langFilter = language ? `FILTER(LANG(?relatedTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?relatedAct ?relatedSrNumber ?relatedTitle
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get the domain prefix (first digit(s) of SR number)
  BIND(REPLACE(STR(?srNumber), "^([0-9]+)\\\\..*", "$1") AS ?domainPrefix)

  # Find acts in the same domain via taxonomy
  ?relatedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?relatedTax .

  ?relatedTax skos:notation ?relatedSrNumber ;
              skos:prefLabel ?relatedTitle .

  FILTER(?relatedAct != ?act)
  FILTER(STRSTARTS(STR(?relatedSrNumber), ?domainPrefix))

  ${langFilter}
}
ORDER BY ?relatedSrNumber
LIMIT ${limit}
  `);
}
function buildFindRelatedBySubjectQuery(srNumber, language, limit = 20) {
  let langFilter = language ? `FILTER(LANG(?relatedTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?relatedAct ?relatedSrNumber ?relatedTitle ?sharedSubject
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get subject via taxonomy or dcterms:subject
  {
    ?taxonomy skos:broader ?subject .
  } UNION {
    ?act dcterms:subject ?subject .
  }

  # Find acts with the same subject
  {
    ?relatedAct jolux:classifiedByTaxonomyEntry ?relatedTax .
    ?relatedTax skos:broader ?subject .
  } UNION {
    ?relatedAct dcterms:subject ?subject .
  }

  ?relatedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?relatedTaxMain .

  ?relatedTaxMain skos:notation ?relatedSrNumber ;
                  skos:prefLabel ?relatedTitle .

  FILTER(?relatedAct != ?act)

  OPTIONAL { ?subject skos:prefLabel ?sharedSubject }

  ${langFilter}
}
ORDER BY ?relatedSrNumber
LIMIT ${limit}
  `);
}
function buildFindAllRelatedQuery(srNumber, relationType, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?relatedTitle) = "${language}")` : "";
  if (relationType)
    switch (relationType) {
      case "amends":
        return buildFindAmendingActsQuery(srNumber, language, limit);
      case "amended_by":
        return buildFindAmendedActsQuery(srNumber, language, limit);
      case "cites":
      case "cited_by":
      case "implements":
      case "implemented_by":
      case "based_on":
        return buildFindReferencingActsQuery(srNumber, language, limit);
      case "same_domain":
        return buildFindRelatedByDomainQuery(srNumber, language, limit);
      case "same_subject":
        return buildFindRelatedBySubjectQuery(srNumber, language, limit);
    }
  return withPrefixes(`
SELECT DISTINCT ?relatedAct ?relatedSrNumber ?relatedTitle ?relationType ?relationDate
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  {
    # Amending acts (via impact entries)
    ?impactEntry jolux:impactFromLegalResource ?relatedAct .
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?act .
    BIND("amends" AS ?relationType)
  } UNION {
    # Amended acts
    ?impactEntry jolux:impactFromLegalResource ?act .
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?relatedAct .
    BIND("amended_by" AS ?relationType)
  } UNION {
    # Citing acts
    ?relatedAct jolux:legalResourceLegalResourceCites ?act .
    BIND("cites" AS ?relationType)
  } UNION {
    # Cited acts
    ?act jolux:legalResourceLegalResourceCites ?relatedAct .
    BIND("cited_by" AS ?relationType)
  } UNION {
    # Based on
    ?relatedAct jolux:legalResourceLegalResourceBasedOn ?act .
    BIND("based_on" AS ?relationType)
  }

  ?relatedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?relatedTax .

  ?relatedTax skos:notation ?relatedSrNumber ;
              skos:prefLabel ?relatedTitle .

  ${langFilter}

  OPTIONAL { ?relatedAct jolux:dateDocument ?relationDate }
}
ORDER BY ?relationType ?relatedSrNumber
LIMIT ${limit}
  `);
}
function buildLegislativeHistoryQuery(srNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?version ?date ?title ?changeDescription
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  # Get all versions/expressions in the consolidation
  ?act jolux:isRealizedBy ?version .
  ?version jolux:dateDocument ?date .

  OPTIONAL { ?version jolux:title ?changeDescription }
}
ORDER BY DESC(?date)
LIMIT 100
  `);
}

// mcp-servers-src/fedlex-sparql/src/queries/metadata.ts
function buildGetMetadataQuery(srNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?actType ?dateDocument ?dateInForce
       ?dateAbrogation ?publicationStatus ?responsibleAuthority ?legalBasis
       ?classificationNumber ?version ?expressionLanguage ?inForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
  OPTIONAL { ?act jolux:typeDocument ?actType }
  OPTIONAL { ?act jolux:dateDocument ?dateDocument }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
  OPTIONAL { ?act jolux:dateNoLongerInForce ?dateAbrogation }

  # In force status
  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }

  # Authority and basis
  OPTIONAL { ?act dcterms:creator ?responsibleAuthority }
  OPTIONAL { ?act jolux:legalResourceLegalResourceBasedOn ?legalBasis }

  # Classification number (same as SR)
  BIND(?srNumber AS ?classificationNumber)

  # Version info via Expression
  OPTIONAL {
    ?act jolux:isRealizedBy ?version .
    ?version jolux:language ?expressionLanguage .
  }
}
LIMIT 50
  `);
}
function buildGetLanguagesQuery(srNumber) {
  return withPrefixes(`
SELECT DISTINCT ?language ?title
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  BIND(LANG(?title) AS ?language)
  FILTER(BOUND(?language) && ?language != "")
}
ORDER BY ?language
  `);
}
function buildGetSubjectsQuery(srNumber, language) {
  let langFilter = language ? `FILTER(!BOUND(?label) || LANG(?label) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?subject ?label ?scheme
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get subjects from taxonomy hierarchy or dcterms:subject
  {
    ?taxonomy skos:broader ?subject .
  } UNION {
    ?act dcterms:subject ?subject .
  }

  OPTIONAL { ?subject skos:prefLabel ?label }
  OPTIONAL { ?subject skos:inScheme ?scheme }

  ${langFilter}
}
ORDER BY ?label
  `);
}
function buildGetVersionHistoryQuery(srNumber) {
  return withPrefixes(`
SELECT DISTINCT ?version ?versionDate ?versionType ?title
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  ?act jolux:isRealizedBy ?version .

  OPTIONAL { ?version jolux:dateDocument ?versionDate }
  OPTIONAL { ?version jolux:typeDocument ?versionType }
  OPTIONAL { ?version jolux:title ?title }
}
ORDER BY DESC(?versionDate)
LIMIT 50
  `);
}
function buildGetLegalStatusQuery(srNumber) {
  return withPrefixes(`
SELECT DISTINCT ?status ?inForce ?dateInForce ?dateAbrogation ?abrogatedBy
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
  OPTIONAL { ?act jolux:dateNoLongerInForce ?dateAbrogation }

  # Check if abrogated by another act
  OPTIONAL {
    ?abrogatingAct jolux:legalResourceLegalResourceRepeals ?act .
    ?abrogatingAct jolux:classifiedByTaxonomyEntry ?abrogatingTax .
    ?abrogatingTax skos:notation ?abrogatedBy .
  }

  BIND(
    IF(BOUND(?dateAbrogation), "abrogated",
      IF(BOUND(?dateInForce), "in_force", "pending")
    ) AS ?status
  )
}
  `);
}
function buildGetStructureQuery(srNumber, language) {
  let langFilter = language ? `FILTER(!BOUND(?partTitle) || LANG(?partTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?part ?partNumber ?partTitle ?partType ?parentPart
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get structural parts (chapters, sections, articles)
  ?act jolux:hasPart+ ?part .

  ?part jolux:number ?partNumber .

  OPTIONAL {
    ?part jolux:isRealizedBy ?partExpr .
    ?partExpr jolux:title ?partTitle .
  }
  OPTIONAL { ?part a ?partType }

  # Get parent relationship for hierarchy
  OPTIONAL {
    ?parentPart jolux:hasPart ?part .
    FILTER(?parentPart != ?act)
  }

  ${langFilter}
}
ORDER BY ?partNumber
LIMIT 500
  `);
}

// mcp-servers-src/fedlex-sparql/src/index.ts
var sparqlClient;
function initializeClient() {
  sparqlClient = createFedlexClient({
    timeout: 6e4,
    // 60 seconds for complex queries
    maxRetries: 3,
    retryDelay: 2e3
  }), console.error(`Fedlex SPARQL client initialized - endpoint: ${sparqlClient.getEndpoint()}`);
}
async function lookupStatute(input) {
  let startTime = Date.now();
  try {
    let query, searchType;
    /^\d/.test(input.identifier) ? (query = buildLookupStatuteQuery(input.identifier, input.language), searchType = "srNumber") : (query = buildLookupByAbbreviationQuery(input.identifier, input.language), searchType = "abbreviation");
    let bindings = (await sparqlClient.query(query)).results.bindings;
    if (bindings.length === 0)
      return {
        found: !1,
        searchTimeMs: Date.now() - startTime
      };
    let actGroups = sparqlClient.groupBindings(bindings, "act"), acts = [];
    for (let [actUri, actBindings] of actGroups) {
      let firstBinding = actBindings[0], act = {
        uri: actUri,
        srNumber: sparqlClient.extractValue(firstBinding.srNumber) || "",
        title: sparqlClient.extractMultilingualValue(actBindings, "title"),
        abbreviation: sparqlClient.extractMultilingualValue(actBindings, "abbreviation"),
        actType: sparqlClient.extractValue(firstBinding.actType),
        dateDocument: sparqlClient.extractValue(firstBinding.dateDocument),
        dateInForce: sparqlClient.extractValue(firstBinding.dateInForce),
        status: firstBinding.inForce ? "in_force" : "unknown"
      };
      acts.push(act);
    }
    return {
      found: !0,
      acts,
      searchType,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Lookup statute failed:", error2), error2;
  }
}
async function getArticle(input) {
  let startTime = Date.now();
  try {
    let query;
    input.paragraph ? query = buildGetArticleParagraphQuery(
      input.srNumber,
      input.articleNumber,
      input.paragraph,
      input.language
    ) : query = buildGetArticleQuery(
      input.srNumber,
      input.articleNumber,
      input.language
    );
    let bindings = (await sparqlClient.query(query)).results.bindings;
    if (bindings.length === 0)
      return {
        found: !1,
        searchTimeMs: Date.now() - startTime
      };
    let firstBinding = bindings[0], actInfo = {
      uri: sparqlClient.extractValue(firstBinding.act) || "",
      srNumber: sparqlClient.extractValue(firstBinding.srNumber) || "",
      title: sparqlClient.extractMultilingualValue(bindings, "actTitle")
    }, articleGroups = sparqlClient.groupBindings(bindings, "article"), articles = [];
    for (let [articleUri, articleBindings] of articleGroups) {
      let articleFirst = articleBindings[0], paragraphs = [], paragraphGroups = sparqlClient.groupBindings(articleBindings, "paragraphNum");
      for (let [paragraphNum, paragraphBindings] of paragraphGroups) {
        if (!paragraphNum) continue;
        let letters = [];
        for (let binding of paragraphBindings) {
          let letterLit = sparqlClient.extractValue(binding.letterLit);
          letterLit && letters.push({
            literal: letterLit,
            text: binding.letterText ? { [binding.letterText["xml:lang"] || "de"]: binding.letterText.value } : void 0
          });
        }
        paragraphs.push({
          number: paragraphNum,
          text: sparqlClient.extractMultilingualValue(paragraphBindings, "paragraphText"),
          letters: letters.length > 0 ? letters : void 0
        });
      }
      let article = {
        uri: articleUri,
        number: sparqlClient.extractValue(articleFirst.articleNumber) || "",
        title: sparqlClient.extractMultilingualValue(articleBindings, "articleTitle"),
        text: sparqlClient.extractMultilingualValue(articleBindings, "articleText"),
        paragraphs: paragraphs.length > 0 ? paragraphs : void 0
      };
      articles.push(article);
    }
    return {
      found: !0,
      act: actInfo,
      articles,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Get article failed:", error2), error2;
  }
}
async function searchLegislation(input) {
  let startTime = Date.now();
  try {
    let filters = {
      language: input.language,
      actType: input.actType,
      status: input.status,
      srNumberPrefix: input.srNumberPrefix,
      limit: input.limit || 50,
      offset: input.offset || 0
    }, query, countQuery;
    input.domain && !input.query ? query = buildSearchByDomainQuery(input.domain, input.language, filters.limit) : input.dateFrom || input.dateTo ? query = buildSearchByDateQuery(input.dateFrom, input.dateTo, input.language, filters.limit) : (query = buildSearchQuery(input.query || "", filters), countQuery = buildSearchCountQuery(input.query || "", filters));
    let bindings = (await sparqlClient.query(query)).results.bindings, totalCount = bindings.length;
    if (countQuery) {
      let countResult = await sparqlClient.query(countQuery);
      if (countResult.results.bindings.length > 0) {
        let countValue = sparqlClient.extractValue(countResult.results.bindings[0].count);
        totalCount = countValue ? parseInt(countValue, 10) : bindings.length;
      }
    }
    let acts = bindings.map((binding) => ({
      uri: sparqlClient.extractValue(binding.act) || "",
      srNumber: sparqlClient.extractValue(binding.srNumber) || "",
      title: binding.title ? { [binding.title["xml:lang"] || "de"]: binding.title.value } : {},
      abbreviation: binding.abbreviation ? { [binding.abbreviation["xml:lang"] || "de"]: binding.abbreviation.value } : void 0,
      actType: sparqlClient.extractValue(binding.actType),
      dateInForce: sparqlClient.extractValue(binding.dateInForce)
    })), domainFacets = {};
    for (let act of acts) {
      let prefix = act.srNumber.split(".")[0];
      prefix && LEGAL_DOMAINS[prefix] && (domainFacets[prefix] = (domainFacets[prefix] || 0) + 1);
    }
    return {
      acts,
      totalCount,
      hasMore: (filters.offset || 0) + acts.length < totalCount,
      facets: {
        byDomain: domainFacets
      },
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Search legislation failed:", error2), error2;
  }
}
async function findRelated(input) {
  let startTime = Date.now();
  try {
    let query = buildFindAllRelatedQuery(
      input.srNumber,
      input.relationType,
      input.language,
      input.limit || 50
    ), relatedActs = (await sparqlClient.query(query)).results.bindings.map((binding) => ({
      uri: sparqlClient.extractValue(binding.relatedAct) || "",
      srNumber: sparqlClient.extractValue(binding.relatedSrNumber) || "",
      title: binding.relatedTitle ? { [binding.relatedTitle["xml:lang"] || "de"]: binding.relatedTitle.value } : {},
      relationType: sparqlClient.extractValue(binding.relationType) || "same_domain",
      relationDate: sparqlClient.extractValue(binding.relationDate)
    })), byRelationType = {};
    for (let act of relatedActs) {
      let relType = act.relationType || "unknown";
      byRelationType[relType] = (byRelationType[relType] || 0) + 1;
    }
    let legislativeHistory;
    if (input.includeHistory) {
      let historyQuery = buildLegislativeHistoryQuery(input.srNumber, input.language);
      legislativeHistory = (await sparqlClient.query(historyQuery)).results.bindings.map((binding) => ({
        date: sparqlClient.extractValue(binding.date) || "",
        description: sparqlClient.extractValue(binding.changeDescription)
      }));
    }
    return {
      srNumber: input.srNumber,
      relatedActs,
      byRelationType,
      legislativeHistory,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Find related failed:", error2), error2;
  }
}
async function getMetadata(input) {
  let startTime = Date.now();
  try {
    let [
      metadataResult,
      languagesResult,
      subjectsResult,
      historyResult,
      statusResult,
      structureResult
    ] = await Promise.all([
      sparqlClient.query(buildGetMetadataQuery(input.srNumber, input.language)),
      sparqlClient.query(buildGetLanguagesQuery(input.srNumber)),
      sparqlClient.query(buildGetSubjectsQuery(input.srNumber, input.language)),
      sparqlClient.query(buildGetVersionHistoryQuery(input.srNumber)),
      sparqlClient.query(buildGetLegalStatusQuery(input.srNumber)),
      input.includeStructure ? sparqlClient.query(buildGetStructureQuery(input.srNumber, input.language)) : Promise.resolve({ results: { bindings: [] } })
    ]), metadataBindings = metadataResult.results.bindings;
    if (metadataBindings.length === 0)
      return {
        found: !1,
        searchTimeMs: Date.now() - startTime
      };
    let firstBinding = metadataBindings[0], metadata = {
      uri: sparqlClient.extractValue(firstBinding.act) || "",
      srNumber: sparqlClient.extractValue(firstBinding.srNumber) || "",
      title: sparqlClient.extractMultilingualValue(metadataBindings, "title"),
      abbreviation: sparqlClient.extractMultilingualValue(metadataBindings, "abbreviation"),
      actType: sparqlClient.extractValue(firstBinding.actType),
      dateDocument: sparqlClient.extractValue(firstBinding.dateDocument),
      dateInForce: sparqlClient.extractValue(firstBinding.dateInForce),
      dateAbrogation: sparqlClient.extractValue(firstBinding.dateAbrogation),
      status: "unknown"
    };
    metadata.availableLanguages = languagesResult.results.bindings.map((b) => sparqlClient.extractValue(b.language)).filter((lang) => !!lang);
    let subjects = subjectsResult.results.bindings.map((b) => sparqlClient.extractValue(b.label)).filter((s) => !!s);
    subjects.length > 0 && (metadata.subjects = subjects);
    let versions = historyResult.results.bindings.map((b) => ({
      date: sparqlClient.extractValue(b.versionDate) || "",
      type: sparqlClient.extractValue(b.versionType),
      description: sparqlClient.extractValue(b.changeDescription)
    }));
    if (versions.length > 0 && (metadata.versionHistory = versions), statusResult.results.bindings.length > 0) {
      let statusBinding = statusResult.results.bindings[0], status = sparqlClient.extractValue(statusBinding.status);
      (status === "in_force" || status === "abrogated" || status === "pending") && (metadata.status = status), metadata.abrogatedBy = sparqlClient.extractValue(statusBinding.abrogatedBy);
    }
    input.includeStructure && structureResult.results.bindings.length > 0 && (metadata.structure = structureResult.results.bindings.map((b) => ({
      partNumber: sparqlClient.extractValue(b.partNumber) || "",
      partTitle: sparqlClient.extractValue(b.partTitle),
      partType: sparqlClient.extractValue(b.partType)
    })));
    let domainPrefix = input.srNumber.split(".")[0];
    return LEGAL_DOMAINS[domainPrefix] && (metadata.legalDomain = LEGAL_DOMAINS[domainPrefix]), {
      found: !0,
      metadata,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Get metadata failed:", error2), error2;
  }
}
async function main() {
  initializeClient();
  let server = new Server(
    {
      name: "fedlex-sparql",
      version: "2.0.1"
    },
    {
      capabilities: {
        tools: {}
      }
    }
  );
  server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: "lookup_statute",
        description: "Look up a Swiss federal legal act by SR number (e.g., '220' for OR) or abbreviation (e.g., 'OR', 'ZGB'). Returns basic information including title, type, and status in multiple languages (DE/FR/IT).",
        inputSchema: {
          type: "object",
          properties: {
            identifier: {
              type: "string",
              description: "SR number (e.g., '220', '210') or abbreviation (e.g., 'OR', 'ZGB', 'StGB')"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for results (de=German, fr=French, it=Italian, rm=Romansh)"
            }
          },
          required: ["identifier"]
        }
      },
      {
        name: "get_article",
        description: "Retrieve a specific article within a Swiss legal act. Returns article text, marginal notes, paragraphs (Abs\xE4tze), and letters (Buchstaben) in structured format.",
        inputSchema: {
          type: "object",
          properties: {
            srNumber: {
              type: "string",
              description: "SR number of the legal act (e.g., '220' for OR)"
            },
            articleNumber: {
              type: "string",
              description: "Article number (e.g., '97', '41', 'Art. 97')"
            },
            paragraph: {
              type: "string",
              description: "Specific paragraph/Absatz number (optional)"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for article text"
            }
          },
          required: ["srNumber", "articleNumber"]
        }
      },
      {
        name: "search_legislation",
        description: "Search across Swiss federal legislation with full-text search and filters. Supports filtering by legal domain, date range, act type, and language.",
        inputSchema: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "Full-text search query (searches title and SR number)"
            },
            domain: {
              type: "string",
              enum: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
              description: "Legal domain filter by SR prefix: 1=State/Constitutional, 2=Private/Civil, 3=Criminal, 4=Education/Culture, 5=Defense, 6=Finance, 7=Public Works/Transport, 8=Health/Labor/Social Security, 9=Economy"
            },
            srNumberPrefix: {
              type: "string",
              description: "Filter by SR number prefix (e.g., '22' for contract law)"
            },
            dateFrom: {
              type: "string",
              format: "date",
              description: "Filter acts in force from this date (ISO 8601: YYYY-MM-DD)"
            },
            dateTo: {
              type: "string",
              format: "date",
              description: "Filter acts in force until this date (ISO 8601: YYYY-MM-DD)"
            },
            actType: {
              type: "array",
              items: { type: "string" },
              description: "Filter by act types (e.g., 'Bundesgesetz', 'Verordnung')"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Language filter for results"
            },
            limit: {
              type: "number",
              minimum: 1,
              maximum: 100,
              default: 50,
              description: "Maximum number of results"
            },
            offset: {
              type: "number",
              minimum: 0,
              default: 0,
              description: "Offset for pagination"
            }
          }
        }
      },
      {
        name: "find_related",
        description: "Find legislation related to a specific act through amendments, citations, references, or shared legal domain. Optionally includes legislative history (consolidation chain).",
        inputSchema: {
          type: "object",
          properties: {
            srNumber: {
              type: "string",
              description: "SR number of the legal act (e.g., '220' for OR)"
            },
            relationType: {
              type: "string",
              enum: [
                "amends",
                "amended_by",
                "cites",
                "cited_by",
                "implements",
                "implemented_by",
                "based_on",
                "same_domain",
                "same_subject"
              ],
              description: "Filter by specific relation type (optional - returns all if not specified)"
            },
            includeHistory: {
              type: "boolean",
              default: !1,
              description: "Include legislative history (consolidation chain)"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for results"
            },
            limit: {
              type: "number",
              minimum: 1,
              maximum: 100,
              default: 50,
              description: "Maximum number of related acts"
            }
          },
          required: ["srNumber"]
        }
      },
      {
        name: "get_metadata",
        description: "Get comprehensive metadata about a legal act including publication info, subjects/keywords, version history, legal status, available languages, and optionally the document structure (table of contents).",
        inputSchema: {
          type: "object",
          properties: {
            srNumber: {
              type: "string",
              description: "SR number of the legal act (e.g., '220' for OR)"
            },
            includeStructure: {
              type: "boolean",
              default: !1,
              description: "Include document structure (table of contents with chapters, sections, articles)"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for metadata text"
            }
          },
          required: ["srNumber"]
        }
      }
    ]
  })), server.setRequestHandler(CallToolRequestSchema, async (request) => {
    let { name, arguments: args } = request.params;
    try {
      if (name === "lookup_statute") {
        let result = await lookupStatute(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "get_article") {
        let result = await getArticle(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "search_legislation") {
        let result = await searchLegislation(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "find_related") {
        let result = await findRelated(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "get_metadata") {
        let result = await getMetadata(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      throw new Error(`Unknown tool: ${name}`);
    } catch (error2) {
      let errorMessage = error2 instanceof Error ? error2.message : String(error2);
      return console.error(`Tool execution failed: ${name}`, error2), {
        content: [
          {
            type: "text",
            text: JSON.stringify({ error: errorMessage }, null, 2)
          }
        ],
        isError: !0
      };
    }
  });
  let transport = new StdioServerTransport();
  await server.connect(transport), console.error("Fedlex SPARQL MCP server running on stdio");
}
main().catch((error2) => {
  console.error("Fatal error in main():", error2), process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2NvZGVnZW4vc2NvcGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91dGlsLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL25hbWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9ycy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3J1bGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3JlZl9lcnJvci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91cmkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvcmUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2lkLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvY29yZS9yZWYudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91Y3MybGVuZ3RoLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcGF0dGVybi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRJdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS9lcXVhbC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2NvbnN0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zMjAyMC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydHlOYW1lcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3BhdHRlcm5Qcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9vbmVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci90aGVuRWxzZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZm9ybWF0L2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvbWV0YWRhdGEudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kcmFmdDcudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvbiIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvc3JjL2Zvcm1hdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvbGltaXQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy91dGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL1pvZEVycm9yLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvZXJyb3JzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY29yZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3V0aWwuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2V4ZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9kb2MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS92ZXJzaW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvbG9jYWxlcy9lbi5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2lzdHJpZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9hcGkuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS90by1qc29uLXNjaGVtYS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2pzb24tc2NoZW1hLXByb2Nlc3NvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvem9kLWNvbXBhdC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9pc28uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2NvbXBhdC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2Zyb20tanNvbi1zY2hlbWEuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9leHRlcm5hbC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2ludGVyZmFjZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vT3B0aW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3NlcnZlci96b2QtanNvbi1zY2hlbWEtY29tcGF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL3Byb3RvY29sLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvdmFsaWRhdGlvbi9hanYtcHJvdmlkZXIudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9leHBlcmltZW50YWwvdGFza3Mvc2VydmVyLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2hlbHBlcnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zaGFyZWQvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3NwYXJxbC1jbGllbnQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3F1ZXJpZXMvcHJlZml4ZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3F1ZXJpZXMvbG9va3VwLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9xdWVyaWVzL2FydGljbGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9xdWVyaWVzL3NlYXJjaC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvZmVkbGV4LXNwYXJxbC9zcmMvcXVlcmllcy9yZWxhdGVkLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9xdWVyaWVzL21ldGFkYXRhLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgX0NvZGVPck5hbWUge1xuICBhYnN0cmFjdCByZWFkb25seSBzdHI6IHN0cmluZ1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG4gIGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZ1xuICBhYnN0cmFjdCBlbXB0eVN0cigpOiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBJREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2lcblxuZXhwb3J0IGNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gIHJlYWRvbmx5IHN0cjogc3RyaW5nXG4gIGNvbnN0cnVjdG9yKHM6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICBpZiAoIUlERU5USUZJRVIudGVzdChzKSkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKVxuICAgIHRoaXMuc3RyID0gc1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJcbiAgfVxuXG4gIGVtcHR5U3RyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHtbdGhpcy5zdHJdOiAxfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgcmVhZG9ubHkgX2l0ZW1zOiByZWFkb25seSBDb2RlSXRlbVtdXG4gIHByaXZhdGUgX3N0cj86IHN0cmluZ1xuICBwcml2YXRlIF9uYW1lcz86IFVzZWROYW1lc1xuXG4gIGNvbnN0cnVjdG9yKGNvZGU6IHN0cmluZyB8IHJlYWRvbmx5IENvZGVJdGVtW10pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGVcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RyXG4gIH1cblxuICBlbXB0eVN0cigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdXG4gICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInXG4gIH1cblxuICBnZXQgc3RyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLl9zdHIgPz89IHRoaXMuX2l0ZW1zLnJlZHVjZSgoczogc3RyaW5nLCBjOiBDb2RlSXRlbSkgPT4gYCR7c30ke2N9YCwgXCJcIikpXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gKHRoaXMuX25hbWVzID8/PSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIGMpID0+IHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSkgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDFcbiAgICAgIHJldHVybiBuYW1lc1xuICAgIH0sIHt9KSlcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDb2RlSXRlbSA9IE5hbWUgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG5leHBvcnQgdHlwZSBVc2VkTmFtZXMgPSBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCB0eXBlIENvZGUgPSBfQ29kZSB8IE5hbWVcblxuZXhwb3J0IHR5cGUgU2FmZUV4cHIgPSBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxcblxuZXhwb3J0IGNvbnN0IG5pbCA9IG5ldyBfQ29kZShcIlwiKVxuXG50eXBlIENvZGVBcmcgPSBTYWZlRXhwciB8IHN0cmluZyB8IHVuZGVmaW5lZFxuXG5leHBvcnQgZnVuY3Rpb24gXyhzdHJzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogQ29kZUFyZ1tdKTogX0NvZGUge1xuICBjb25zdCBjb2RlOiBDb2RlSXRlbVtdID0gW3N0cnNbMF1dXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKVxuICAgIGNvZGUucHVzaChzdHJzWysraV0pXG4gIH1cbiAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKVxufVxuXG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyKHN0cnM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiAoQ29kZUFyZyB8IHN0cmluZ1tdKVtdKTogX0NvZGUge1xuICBjb25zdCBleHByOiBDb2RlSXRlbVtdID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgZXhwci5wdXNoKHBsdXMpXG4gICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKVxuICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpXG4gIH1cbiAgb3B0aW1pemUoZXhwcilcbiAgcmV0dXJuIG5ldyBfQ29kZShleHByKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlOiBDb2RlSXRlbVtdLCBhcmc6IENvZGVBcmcgfCBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKVxuICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKSBjb2RlLnB1c2goYXJnKVxuICBlbHNlIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKVxufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZShleHByOiBDb2RlSXRlbVtdKTogdm9pZCB7XG4gIGxldCBpID0gMVxuICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pXG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcylcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGV4cHJbaSsrXSA9IFwiK1wiXG4gICAgfVxuICAgIGkrK1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGE6IENvZGVJdGVtLCBiOiBDb2RlSXRlbSk6IENvZGVJdGVtIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGIgPT09ICdcIlwiJykgcmV0dXJuIGFcbiAgaWYgKGEgPT09ICdcIlwiJykgcmV0dXJuIGJcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIikgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImBcbiAgICBpZiAoYlswXSA9PT0gJ1wiJykgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWBcbiAgcmV0dXJuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJDb25jYXQoYzE6IENvZGUsIGMyOiBDb2RlKTogQ29kZSB7XG4gIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHJgJHtjMX0ke2MyfWBcbn1cblxuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHg/OiBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsKTogU2FmZUV4cHIgfCBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgPyB4XG4gICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh4OiB1bmtub3duKTogQ29kZSB7XG4gIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeDogdW5rbm93bik6IHN0cmluZyB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleTogQ29kZSB8IHN0cmluZyB8IG51bWJlcik6IENvZGUge1xuICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIElERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfYFske2tleX1dYFxufVxuXG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXNtRXhwb3J0TmFtZShrZXk6IENvZGUgfCBzdHJpbmcgfCBudW1iZXIpOiBDb2RlIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBJREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4cENvZGUocng6IFJlZ0V4cCk6IENvZGUge1xuICByZXR1cm4gbmV3IF9Db2RlKHJ4LnRvU3RyaW5nKCkpXG59XG4iLCAiaW1wb3J0IHtfLCBuaWwsIENvZGUsIE5hbWV9IGZyb20gXCIuL2NvZGVcIlxuXG5pbnRlcmZhY2UgTmFtZUdyb3VwIHtcbiAgcHJlZml4OiBzdHJpbmdcbiAgaW5kZXg6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVWYWx1ZSB7XG4gIHJlZjogVmFsdWVSZWZlcmVuY2UgLy8gdGhpcyBpcyB0aGUgcmVmZXJlbmNlIHRvIGFueSB2YWx1ZSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBmcm9tIGdlbmVyYXRlZCBjb2RlIHZpYSBgZ2xvYmFsc2AgdmFyIGluIHRoZSBjbG9zdXJlXG4gIGtleT86IHVua25vd24gLy8gYW55IGtleSB0byBpZGVudGlmeSBhIGdsb2JhbCB0byBhdm9pZCBkdXBsaWNhdGVzLCBpZiBub3QgcGFzc2VkIHJlZiBpcyB1c2VkXG4gIGNvZGU/OiBDb2RlIC8vIHRoaXMgaXMgdGhlIGNvZGUgY3JlYXRpbmcgdGhlIHZhbHVlIG5lZWRlZCBmb3Igc3RhbmRhbG9uZSBjb2RlIHdpdF9vdXQgY2xvc3VyZSAtIGNhbiBiZSBhIHByaW1pdGl2ZSB2YWx1ZSwgZnVuY3Rpb24gb3IgaW1wb3J0IChgcmVxdWlyZWApXG59XG5cbmV4cG9ydCB0eXBlIFZhbHVlUmVmZXJlbmNlID0gdW5rbm93biAvLyBwb3NzaWJseSBtYWtlIENvZGVHZW4gcGFyYW1ldGVyaXplZCB0eXBlIG9uIHRoaXMgdHlwZVxuXG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSB2YWx1ZT86IE5hbWVWYWx1ZVxuICBjb25zdHJ1Y3RvcihuYW1lOiBWYWx1ZVNjb3BlTmFtZSkge1xuICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApXG4gICAgdGhpcy52YWx1ZSA9IG5hbWUudmFsdWVcbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NvcGVPcHRpb25zIHtcbiAgcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwYXJlbnQ/OiBTY29wZVxufVxuXG5pbnRlcmZhY2UgVmFsdWVTY29wZU9wdGlvbnMgZXh0ZW5kcyBTY29wZU9wdGlvbnMge1xuICBzY29wZTogU2NvcGVTdG9yZVxuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBTY29wZVN0b3JlID0gUmVjb3JkPHN0cmluZywgVmFsdWVSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZD5cblxudHlwZSBTY29wZVZhbHVlcyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogTWFwPHVua25vd24sIFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgdHlwZSBTY29wZVZhbHVlU2V0cyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogU2V0PFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgZW51bSBVc2VkVmFsdWVTdGF0ZSB7XG4gIFN0YXJ0ZWQsXG4gIENvbXBsZXRlZCxcbn1cblxuZXhwb3J0IHR5cGUgVXNlZFNjb3BlVmFsdWVzID0ge1xuICBbUHJlZml4IGluIHN0cmluZ10/OiBNYXA8VmFsdWVTY29wZU5hbWUsIFVzZWRWYWx1ZVN0YXRlIHwgdW5kZWZpbmVkPlxufVxuXG5leHBvcnQgY29uc3QgdmFyS2luZHMgPSB7XG4gIGNvbnN0OiBuZXcgTmFtZShcImNvbnN0XCIpLFxuICBsZXQ6IG5ldyBOYW1lKFwibGV0XCIpLFxuICB2YXI6IG5ldyBOYW1lKFwidmFyXCIpLFxufVxuXG5leHBvcnQgY2xhc3MgU2NvcGUge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX25hbWVzOiB7W1ByZWZpeCBpbiBzdHJpbmddPzogTmFtZUdyb3VwfSA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3BhcmVudD86IFNjb3BlXG5cbiAgY29uc3RydWN0b3Ioe3ByZWZpeGVzLCBwYXJlbnR9OiBTY29wZU9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXNcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIHRvTmFtZShuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogTmFtZSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV3TmFtZShwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpXG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YFxuICB9XG5cbiAgcHJpdmF0ZSBfbmFtZUdyb3VwKHByZWZpeDogc3RyaW5nKTogTmFtZUdyb3VwIHtcbiAgICBpZiAodGhpcy5fcGFyZW50Py5fcHJlZml4ZXM/LmhhcyhwcmVmaXgpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7cHJlZml4LCBpbmRleDogMH0pXG4gIH1cbn1cblxuaW50ZXJmYWNlIFNjb3BlUGF0aCB7XG4gIHByb3BlcnR5OiBzdHJpbmdcbiAgaXRlbUluZGV4OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgTmFtZSB7XG4gIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nXG4gIHZhbHVlPzogTmFtZVZhbHVlXG4gIHNjb3BlUGF0aD86IENvZGVcblxuICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgbmFtZVN0cjogc3RyaW5nKSB7XG4gICAgc3VwZXIobmFtZVN0cilcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICB9XG5cbiAgc2V0VmFsdWUodmFsdWU6IE5hbWVWYWx1ZSwge3Byb3BlcnR5LCBpdGVtSW5kZXh9OiBTY29wZVBhdGgpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLnNjb3BlUGF0aCA9IF9gLiR7bmV3IE5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYFxuICB9XG59XG5cbmludGVyZmFjZSBWU09wdGlvbnMgZXh0ZW5kcyBWYWx1ZVNjb3BlT3B0aW9ucyB7XG4gIF9uOiBDb2RlXG59XG5cbmNvbnN0IGxpbmUgPSBfYFxcbmBcblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlcyA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfc2NvcGU6IFNjb3BlU3RvcmVcbiAgcmVhZG9ubHkgb3B0czogVlNPcHRpb25zXG5cbiAgY29uc3RydWN0b3Iob3B0czogVmFsdWVTY29wZU9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZVxuICAgIHRoaXMub3B0cyA9IHsuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBuaWx9XG4gIH1cblxuICBnZXQoKTogU2NvcGVTdG9yZSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njb3BlXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogVmFsdWVTY29wZU5hbWUge1xuICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpXG4gIH1cblxuICB2YWx1ZShuYW1lT3JQcmVmaXg6IFZhbHVlU2NvcGVOYW1lIHwgc3RyaW5nLCB2YWx1ZTogTmFtZVZhbHVlKTogVmFsdWVTY29wZU5hbWUge1xuICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpXG4gICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCkgYXMgVmFsdWVTY29wZU5hbWVcbiAgICBjb25zdCB7cHJlZml4fSA9IG5hbWVcbiAgICBjb25zdCB2YWx1ZUtleSA9IHZhbHVlLmtleSA/PyB2YWx1ZS5yZWZcbiAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XVxuICAgIGlmICh2cykge1xuICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpXG4gICAgICBpZiAoX25hbWUpIHJldHVybiBfbmFtZVxuICAgIH0gZWxzZSB7XG4gICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpXG4gICAgfVxuICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSlcblxuICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pXG4gICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGhcbiAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWZcbiAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7cHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4fSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0VmFsdWUocHJlZml4OiBzdHJpbmcsIGtleU9yUmVmOiB1bmtub3duKTogVmFsdWVTY29wZU5hbWUgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF1cbiAgICBpZiAoIXZzKSByZXR1cm5cbiAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKVxuICB9XG5cbiAgc2NvcGVSZWZzKHNjb3BlTmFtZTogTmFtZSwgdmFsdWVzOiBTY29wZVZhbHVlcyB8IFNjb3BlVmFsdWVTZXRzID0gdGhpcy5fdmFsdWVzKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lOiBWYWx1ZVNjb3BlTmFtZSkgPT4ge1xuICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKVxuICAgICAgcmV0dXJuIF9gJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gXG4gICAgfSlcbiAgfVxuXG4gIHNjb3BlQ29kZShcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMgPSB0aGlzLl92YWx1ZXMsXG4gICAgdXNlZFZhbHVlcz86IFVzZWRTY29wZVZhbHVlcyxcbiAgICBnZXRDb2RlPzogKG46IFZhbHVlU2NvcGVOYW1lKSA9PiBDb2RlIHwgdW5kZWZpbmVkXG4gICk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXMoXG4gICAgICB2YWx1ZXMsXG4gICAgICAobmFtZTogVmFsdWVTY29wZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApXG4gICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGVcbiAgICAgIH0sXG4gICAgICB1c2VkVmFsdWVzLFxuICAgICAgZ2V0Q29kZVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3JlZHVjZVZhbHVlcyhcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMsXG4gICAgdmFsdWVDb2RlOiAobjogVmFsdWVTY29wZU5hbWUpID0+IENvZGUgfCB1bmRlZmluZWQsXG4gICAgdXNlZFZhbHVlczogVXNlZFNjb3BlVmFsdWVzID0ge30sXG4gICAgZ2V0Q29kZT86IChuOiBWYWx1ZVNjb3BlTmFtZSkgPT4gQ29kZSB8IHVuZGVmaW5lZFxuICApOiBDb2RlIHtcbiAgICBsZXQgY29kZTogQ29kZSA9IG5pbFxuICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XVxuICAgICAgaWYgKCF2cykgY29udGludWVcbiAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSlcbiAgICAgIHZzLmZvckVhY2goKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSkgcmV0dXJuXG4gICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpXG4gICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmNvbnN0XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSBpZiAoKGMgPSBnZXRDb2RlPy4obmFtZSkpKSB7XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSlcbiAgICAgICAgfVxuICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1Njb3BlVmFsdWVTZXRzLCBOYW1lVmFsdWUsIFZhbHVlU2NvcGUsIFZhbHVlU2NvcGVOYW1lfSBmcm9tIFwiLi9zY29wZVwiXG5pbXBvcnQge18sIG5pbCwgX0NvZGUsIENvZGUsIE5hbWUsIFVzZWROYW1lcywgQ29kZUl0ZW0sIGFkZENvZGVBcmcsIF9Db2RlT3JOYW1lfSBmcm9tIFwiLi9jb2RlXCJcbmltcG9ydCB7U2NvcGUsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbmV4cG9ydCB7Xywgc3RyLCBzdHJDb25jYXQsIG5pbCwgZ2V0UHJvcGVydHksIHN0cmluZ2lmeSwgcmVnZXhwQ29kZSwgTmFtZSwgQ29kZX0gZnJvbSBcIi4vY29kZVwiXG5leHBvcnQge1Njb3BlLCBTY29wZVN0b3JlLCBWYWx1ZVNjb3BlLCBWYWx1ZVNjb3BlTmFtZSwgU2NvcGVWYWx1ZVNldHMsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbi8vIHR5cGUgZm9yIGV4cHJlc3Npb25zIHRoYXQgY2FuIGJlIHNhZmVseSBpbnNlcnRlZCBpbiBjb2RlIHdpdGhvdXQgcXVvdGVzXG5leHBvcnQgdHlwZSBTYWZlRXhwciA9IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG4vLyB0eXBlIHRoYXQgaXMgZWl0aGVyIENvZGUgb2YgZnVuY3Rpb24gdGhhdCBhZGRzIGNvZGUgdG8gQ29kZUdlbiBpbnN0YW5jZSB1c2luZyBpdHMgbWV0aG9kc1xuZXhwb3J0IHR5cGUgQmxvY2sgPSBDb2RlIHwgKCgpID0+IHZvaWQpXG5cbmV4cG9ydCBjb25zdCBvcGVyYXRvcnMgPSB7XG4gIEdUOiBuZXcgX0NvZGUoXCI+XCIpLFxuICBHVEU6IG5ldyBfQ29kZShcIj49XCIpLFxuICBMVDogbmV3IF9Db2RlKFwiPFwiKSxcbiAgTFRFOiBuZXcgX0NvZGUoXCI8PVwiKSxcbiAgRVE6IG5ldyBfQ29kZShcIj09PVwiKSxcbiAgTkVROiBuZXcgX0NvZGUoXCIhPT1cIiksXG4gIE5PVDogbmV3IF9Db2RlKFwiIVwiKSxcbiAgT1I6IG5ldyBfQ29kZShcInx8XCIpLFxuICBBTkQ6IG5ldyBfQ29kZShcIiYmXCIpLFxuICBBREQ6IG5ldyBfQ29kZShcIitcIiksXG59XG5cbmFic3RyYWN0IGNsYXNzIE5vZGUge1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKF9uYW1lczogVXNlZE5hbWVzLCBfY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIDFcbiAgLy8gfVxufVxuXG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogTmFtZSxcbiAgICBwcml2YXRlIHJocz86IFNhZmVFeHByXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7ZXM1LCBfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZFxuICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YFxuICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSkgcmV0dXJuXG4gICAgaWYgKHRoaXMucmhzKSB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9XG4gIH1cbn1cblxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGxoczogQ29kZSxcbiAgICBwdWJsaWMgcmhzOiBTYWZlRXhwcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNpZGVFZmZlY3RzPzogYm9vbGVhblxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cykgcmV0dXJuXG4gICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBOYW1lID8ge30gOiB7Li4udGhpcy5saHMubmFtZXN9XG4gICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpXG4gIH1cbn1cblxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBsaHM6IENvZGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcDogQ29kZSxcbiAgICByaHM6IFNhZmVFeHByLFxuICAgIHNpZGVFZmZlY3RzPzogYm9vbGVhblxuICApIHtcbiAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfblxuICB9XG59XG5cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gIHJlYWRvbmx5IG5hbWVzOiBVc2VkTmFtZXMgPSB7fVxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBsYWJlbDogTmFtZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX25cbiAgfVxufVxuXG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICByZWFkb25seSBuYW1lczogVXNlZE5hbWVzID0ge31cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbGFiZWw/OiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCJcbiAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uXG4gIH1cbn1cblxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgZXJyb3I6IENvZGUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lc1xuICB9XG59XG5cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb2RlOiBTYWZlRXhwcikge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfblxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB7XG4gICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge31cbiAgfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IG5vZGVzOiBDaGlsZE5vZGVbXSA9IFtdKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IHRoaXMgfCBDaGlsZE5vZGUgfCBDaGlsZE5vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qge25vZGVzfSA9IHRoaXNcbiAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKSBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubilcbiAgICAgIGVsc2UgaWYgKG4pIG5vZGVzW2ldID0gblxuICAgICAgZWxzZSBub2Rlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qge25vZGVzfSA9IHRoaXNcbiAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgY29uc3QgbiA9IG5vZGVzW2ldXG4gICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKSBjb250aW51ZVxuICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcylcbiAgICAgIG5vZGVzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXM6IFVzZWROYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSlcbiAgfVxuXG4gIC8vIGdldCBjb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoYywgbikgPT4gYyArIG4uY291bnQsIDEpXG4gIC8vIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX25cbiAgfVxufVxuXG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7fVxuXG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImVsc2VcIlxufVxuXG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJpZlwiXG4gIGVsc2U/OiBJZiB8IEVsc2VcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb25kaXRpb246IENvZGUgfCBib29sZWFuLFxuICAgIG5vZGVzPzogQ2hpbGROb2RlW11cbiAgKSB7XG4gICAgc3VwZXIobm9kZXMpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuZWxzZSkgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpXG4gICAgcmV0dXJuIGNvZGVcbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogSWYgfCBDaGlsZE5vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgc3VwZXIub3B0aW1pemVOb2RlcygpXG4gICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uXG4gICAgaWYgKGNvbmQgPT09IHRydWUpIHJldHVybiB0aGlzLm5vZGVzIC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgbGV0IGUgPSB0aGlzLmVsc2VcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKVxuICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogKG5zIGFzIEVsc2UgfCB1bmRlZmluZWQpXG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICBpZiAoY29uZCA9PT0gZmFsc2UpIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2Rlc1xuICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpXG4gICAgfVxuICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIHRoaXMuZWxzZSA9IHRoaXMuZWxzZT8ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSkgcmV0dXJuXG4gICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXNcbiAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKVxuICAgIGlmICh0aGlzLmVsc2UpIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpXG4gICAgcmV0dXJuIG5hbWVzXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gc3VwZXIuY291bnQgKyAodGhpcy5lbHNlPy5jb3VudCB8fCAwKVxuICAvLyB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmb3JcIlxufVxuXG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpdGVyYXRpb246IENvZGUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKSByZXR1cm5cbiAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcylcbiAgfVxufVxuXG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFyS2luZDogTmFtZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5hbWU6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmcm9tOiBTYWZlRXhwcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvOiBTYWZlRXhwclxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmRcbiAgICBjb25zdCB7bmFtZSwgZnJvbSwgdG99ID0gdGhpc1xuICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSlcbiAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKVxuICB9XG59XG5cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxvb3A6IFwib2ZcIiB8IFwiaW5cIixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhcktpbmQ6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBOYW1lLFxuICAgIHByaXZhdGUgaXRlcmFibGU6IENvZGVcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKSByZXR1cm5cbiAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcylcbiAgfVxufVxuXG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImZ1bmNcIlxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbmFtZTogTmFtZSxcbiAgICBwdWJsaWMgYXJnczogQ29kZSxcbiAgICBwdWJsaWMgYXN5bmM/OiBib29sZWFuXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIlxuICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJyZXR1cm5cIlxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG59XG5cbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIGNhdGNoPzogQ2F0Y2hcbiAgZmluYWxseT86IEZpbmFsbHlcblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgICBpZiAodGhpcy5jYXRjaCkgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmZpbmFsbHkpIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKVxuICAgIHJldHVybiBjb2RlXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IHRoaXMge1xuICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKVxuICAgIHRoaXMuY2F0Y2g/Lm9wdGltaXplTm9kZXMoKSBhcyBDYXRjaCB8IHVuZGVmaW5lZFxuICAgIHRoaXMuZmluYWxseT8ub3B0aW1pemVOb2RlcygpIGFzIEZpbmFsbHkgfCB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMge1xuICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICB0aGlzLmNhdGNoPy5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpXG4gICAgdGhpcy5maW5hbGx5Py5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXNcbiAgICBpZiAodGhpcy5jYXRjaCkgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpXG4gICAgaWYgKHRoaXMuZmluYWxseSkgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcylcbiAgICByZXR1cm4gbmFtZXNcbiAgfVxuXG4gIC8vIGdldCBjb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiBzdXBlci5jb3VudCArICh0aGlzLmNhdGNoPy5jb3VudCB8fCAwKSArICh0aGlzLmZpbmFsbHk/LmNvdW50IHx8IDApXG4gIC8vIH1cbn1cblxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiY2F0Y2hcIlxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBlcnJvcjogTmFtZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmaW5hbGx5XCJcbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxudHlwZSBTdGFydEJsb2NrTm9kZSA9IElmIHwgRm9yIHwgRnVuYyB8IFJldHVybiB8IFRyeVxuXG50eXBlIExlYWZOb2RlID0gRGVmIHwgQXNzaWduIHwgTGFiZWwgfCBCcmVhayB8IFRocm93IHwgQW55Q29kZVxuXG50eXBlIENoaWxkTm9kZSA9IFN0YXJ0QmxvY2tOb2RlIHwgTGVhZk5vZGVcblxudHlwZSBFbmRCbG9ja05vZGVUeXBlID1cbiAgfCB0eXBlb2YgSWZcbiAgfCB0eXBlb2YgRWxzZVxuICB8IHR5cGVvZiBGb3JcbiAgfCB0eXBlb2YgRnVuY1xuICB8IHR5cGVvZiBSZXR1cm5cbiAgfCB0eXBlb2YgQ2F0Y2hcbiAgfCB0eXBlb2YgRmluYWxseVxuXG50eXBlIENvbnN0YW50cyA9IFJlY29yZDxzdHJpbmcsIFNhZmVFeHByIHwgdW5kZWZpbmVkPlxuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVHZW5PcHRpb25zIHtcbiAgZXM1PzogYm9vbGVhblxuICBsaW5lcz86IGJvb2xlYW5cbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIENHT3B0aW9ucyBleHRlbmRzIENvZGVHZW5PcHRpb25zIHtcbiAgX246IFwiXFxuXCIgfCBcIlwiXG59XG5cbmV4cG9ydCBjbGFzcyBDb2RlR2VuIHtcbiAgcmVhZG9ubHkgX3Njb3BlOiBTY29wZVxuICByZWFkb25seSBfZXh0U2NvcGU6IFZhbHVlU2NvcGVcbiAgcmVhZG9ubHkgX3ZhbHVlczogU2NvcGVWYWx1ZVNldHMgPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IF9ub2RlczogUGFyZW50Tm9kZVtdXG4gIHByaXZhdGUgcmVhZG9ubHkgX2Jsb2NrU3RhcnRzOiBudW1iZXJbXSA9IFtdXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbnN0YW50czogQ29uc3RhbnRzID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBvcHRzOiBDR09wdGlvbnNcblxuICBjb25zdHJ1Y3RvcihleHRTY29wZTogVmFsdWVTY29wZSwgb3B0czogQ29kZUdlbk9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0cyA9IHsuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwifVxuICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGVcbiAgICB0aGlzLl9zY29wZSA9IG5ldyBTY29wZSh7cGFyZW50OiBleHRTY29wZX0pXG4gICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV1cbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cylcbiAgfVxuXG4gIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gIG5hbWUocHJlZml4OiBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpXG4gIH1cblxuICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgc2NvcGVOYW1lKHByZWZpeDogc3RyaW5nKTogVmFsdWVTY29wZU5hbWUge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeClcbiAgfVxuXG4gIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZTogVmFsdWVTY29wZU5hbWUgfCBzdHJpbmcsIHZhbHVlOiBOYW1lVmFsdWUpOiBOYW1lIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSlcbiAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpXG4gICAgdnMuYWRkKG5hbWUpXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIGdldFNjb3BlVmFsdWUocHJlZml4OiBzdHJpbmcsIGtleU9yUmVmOiB1bmtub3duKTogVmFsdWVTY29wZU5hbWUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKVxuICB9XG5cbiAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgc2NvcGVSZWZzKHNjb3BlTmFtZTogTmFtZSk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpXG4gIH1cblxuICBzY29wZUNvZGUoKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpXG4gIH1cblxuICBwcml2YXRlIF9kZWYoXG4gICAgdmFyS2luZDogTmFtZSxcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgcmhzPzogU2FmZUV4cHIsXG4gICAgY29uc3RhbnQ/OiBib29sZWFuXG4gICk6IE5hbWUge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudCkgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJoc1xuICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gIGNvbnN0KG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZywgcmhzOiBTYWZlRXhwciwgX2NvbnN0YW50PzogYm9vbGVhbik6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9kZWYodmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICBsZXQobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLCByaHM/OiBTYWZlRXhwciwgX2NvbnN0YW50PzogYm9vbGVhbik6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9kZWYodmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KVxuICB9XG5cbiAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gIHZhcihuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsIHJocz86IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgYXNzaWduKGxoczogQ29kZSwgcmhzOiBTYWZlRXhwciwgc2lkZUVmZmVjdHM/OiBib29sZWFuKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSlcbiAgfVxuXG4gIC8vIGArPWAgY29kZVxuICBhZGQobGhzOiBDb2RlLCByaHM6IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIG9wZXJhdG9ycy5BREQsIHJocykpXG4gIH1cblxuICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gIGNvZGUoYzogQmxvY2sgfCBTYWZlRXhwcik6IENvZGVHZW4ge1xuICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpIGMoKVxuICAgIGVsc2UgaWYgKGMgIT09IG5pbCkgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgb2JqZWN0KC4uLmtleVZhbHVlczogW05hbWUgfCBzdHJpbmcsIFNhZmVFeHByIHwgc3RyaW5nXVtdKTogX0NvZGUge1xuICAgIGNvbnN0IGNvZGU6IENvZGVJdGVtW10gPSBbXCJ7XCJdXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICBpZiAoY29kZS5sZW5ndGggPiAxKSBjb2RlLnB1c2goXCIsXCIpXG4gICAgICBjb2RlLnB1c2goa2V5KVxuICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICBjb2RlLnB1c2goXCI6XCIpXG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgdmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpXG4gIH1cblxuICAvLyBgaWZgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGB0aGVuQm9keWAgYW5kLCBvcHRpb25hbGx5LCBgZWxzZUJvZHlgIGFyZSBwYXNzZWQpXG4gIGlmKGNvbmRpdGlvbjogQ29kZSB8IGJvb2xlYW4sIHRoZW5Cb2R5PzogQmxvY2ssIGVsc2VCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja05vZGUobmV3IElmKGNvbmRpdGlvbikpXG5cbiAgICBpZiAodGhlbkJvZHkgJiYgZWxzZUJvZHkpIHtcbiAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZWxzZSgpLmNvZGUoZWxzZUJvZHkpLmVuZElmKClcbiAgICB9IGVsc2UgaWYgKHRoZW5Cb2R5KSB7XG4gICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVuZElmKClcbiAgICB9IGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5JylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICBlbHNlSWYoY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbik6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgSWYoY29uZGl0aW9uKSlcbiAgfVxuXG4gIC8vIGBlbHNlYCBjbGF1c2UgLSBvbmx5IHZhbGlkIGFmdGVyIGBpZmAgb3IgYGVsc2UgaWZgIGNsYXVzZXNcbiAgZWxzZSgpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IEVsc2UoKSlcbiAgfVxuXG4gIC8vIGVuZCBgaWZgIHN0YXRlbWVudCAobmVlZGVkIGlmIGdlbi5pZiB3YXMgdXNlZCBvbmx5IHdpdGggY29uZGl0aW9uKVxuICBlbmRJZigpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKElmLCBFbHNlKVxuICB9XG5cbiAgcHJpdmF0ZSBfZm9yKG5vZGU6IEZvciwgZm9yQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpXG4gICAgaWYgKGZvckJvZHkpIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBhIGdlbmVyaWMgYGZvcmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYGZvckJvZHlgIGlzIHBhc3NlZClcbiAgZm9yKGl0ZXJhdGlvbjogQ29kZSwgZm9yQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KVxuICB9XG5cbiAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICBmb3JSYW5nZShcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgZnJvbTogU2FmZUV4cHIsXG4gICAgdG86IFNhZmVFeHByLFxuICAgIGZvckJvZHk6IChpbmRleDogTmFtZSkgPT4gdm9pZCxcbiAgICB2YXJLaW5kOiBDb2RlID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmxldFxuICApOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeClcbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JSYW5nZSh2YXJLaW5kLCBuYW1lLCBmcm9tLCB0byksICgpID0+IGZvckJvZHkobmFtZSkpXG4gIH1cblxuICAvLyBgZm9yLW9mYCBzdGF0ZW1lbnQgKGluIGVzNSBtb2RlIHJlcGxhY2Ugd2l0aCBhIG5vcm1hbCBmb3IgbG9vcClcbiAgZm9yT2YoXG4gICAgbmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLFxuICAgIGl0ZXJhYmxlOiBDb2RlLFxuICAgIGZvckJvZHk6IChpdGVtOiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB2YXJLaW5kcy5jb25zdFxuICApOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeClcbiAgICBpZiAodGhpcy5vcHRzLmVzNSkge1xuICAgICAgY29uc3QgYXJyID0gaXRlcmFibGUgaW5zdGFuY2VvZiBOYW1lID8gaXRlcmFibGUgOiB0aGlzLnZhcihcIl9hcnJcIiwgaXRlcmFibGUpXG4gICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsIF9gJHthcnJ9Lmxlbmd0aGAsIChpKSA9PiB7XG4gICAgICAgIHRoaXMudmFyKG5hbWUsIF9gJHthcnJ9WyR7aX1dYClcbiAgICAgICAgZm9yQm9keShuYW1lKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSlcbiAgfVxuXG4gIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICBmb3JJbihcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgb2JqOiBDb2RlLFxuICAgIGZvckJvZHk6IChpdGVtOiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB0aGlzLm9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdmFyS2luZHMuY29uc3RcbiAgKTogQ29kZUdlbiB7XG4gICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsIF9gT2JqZWN0LmtleXMoJHtvYmp9KWAsIGZvckJvZHkpXG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKVxuICB9XG5cbiAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgZW5kRm9yKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKVxuICB9XG5cbiAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgbGFiZWwobGFiZWw6IE5hbWUpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSlcbiAgfVxuXG4gIC8vIGBicmVha2Agc3RhdGVtZW50XG4gIGJyZWFrKGxhYmVsPzogQ29kZSk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQnJlYWsobGFiZWwpKVxuICB9XG5cbiAgLy8gYHJldHVybmAgc3RhdGVtZW50XG4gIHJldHVybih2YWx1ZTogQmxvY2sgfCBTYWZlRXhwcik6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgUmV0dXJuKClcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICB0aGlzLmNvZGUodmFsdWUpXG4gICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKVxuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoUmV0dXJuKVxuICB9XG5cbiAgLy8gYHRyeWAgc3RhdGVtZW50XG4gIHRyeSh0cnlCb2R5OiBCbG9jaywgY2F0Y2hDb2RlPzogKGU6IE5hbWUpID0+IHZvaWQsIGZpbmFsbHlDb2RlPzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJ0cnlcIiB3aXRob3V0IFwiY2F0Y2hcIiBhbmQgXCJmaW5hbGx5XCInKVxuICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KClcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICB0aGlzLmNvZGUodHJ5Qm9keSlcbiAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIilcbiAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5jYXRjaCA9IG5ldyBDYXRjaChlcnJvcilcbiAgICAgIGNhdGNoQ29kZShlcnJvcilcbiAgICB9XG4gICAgaWYgKGZpbmFsbHlDb2RlKSB7XG4gICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuZmluYWxseSA9IG5ldyBGaW5hbGx5KClcbiAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSlcbiAgfVxuXG4gIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gIHRocm93KGVycm9yOiBDb2RlKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpXG4gIH1cblxuICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICBibG9jayhib2R5PzogQmxvY2ssIG5vZGVDb3VudD86IG51bWJlcik6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrU3RhcnRzLnB1c2godGhpcy5fbm9kZXMubGVuZ3RoKVxuICAgIGlmIChib2R5KSB0aGlzLmNvZGUoYm9keSkuZW5kQmxvY2sobm9kZUNvdW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgZW5kQmxvY2sobm9kZUNvdW50PzogbnVtYmVyKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKClcbiAgICBpZiAobGVuID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKVxuICAgIGNvbnN0IHRvQ2xvc2UgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBsZW5cbiAgICBpZiAodG9DbG9zZSA8IDAgfHwgKG5vZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmIHRvQ2xvc2UgIT09IG5vZGVDb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogd3JvbmcgbnVtYmVyIG9mIG5vZGVzOiAke3RvQ2xvc2V9IHZzICR7bm9kZUNvdW50fSBleHBlY3RlZGApXG4gICAgfVxuICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IGxlblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICBmdW5jKG5hbWU6IE5hbWUsIGFyZ3M6IENvZGUgPSBuaWwsIGFzeW5jPzogYm9vbGVhbiwgZnVuY0JvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgRnVuYyhuYW1lLCBhcmdzLCBhc3luYykpXG4gICAgaWYgKGZ1bmNCb2R5KSB0aGlzLmNvZGUoZnVuY0JvZHkpLmVuZEZ1bmMoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICBlbmRGdW5jKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYylcbiAgfVxuXG4gIG9wdGltaXplKG4gPSAxKTogdm9pZCB7XG4gICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOb2RlcygpXG4gICAgICB0aGlzLl9yb290Lm9wdGltaXplTmFtZXModGhpcy5fcm9vdC5uYW1lcywgdGhpcy5fY29uc3RhbnRzKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2xlYWZOb2RlKG5vZGU6IExlYWZOb2RlKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIF9ibG9ja05vZGUobm9kZTogU3RhcnRCbG9ja05vZGUpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpXG4gICAgdGhpcy5fbm9kZXMucHVzaChub2RlKVxuICB9XG5cbiAgcHJpdmF0ZSBfZW5kQmxvY2tOb2RlKE4xOiBFbmRCbG9ja05vZGVUeXBlLCBOMj86IEVuZEJsb2NrTm9kZVR5cGUpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGVcbiAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICB0aGlzLl9ub2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBub3QgaW4gYmxvY2sgXCIke04yID8gYCR7TjEua2luZH0vJHtOMi5raW5kfWAgOiBOMS5raW5kfVwiYClcbiAgfVxuXG4gIHByaXZhdGUgX2Vsc2VOb2RlKG5vZGU6IElmIHwgRWxzZSk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZVxuICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKVxuICAgIH1cbiAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX3Jvb3QoKTogUm9vdCB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdIGFzIFJvb3RcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IF9jdXJyTm9kZSgpOiBQYXJlbnROb2RlIHtcbiAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzXG4gICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdXG4gIH1cblxuICBwcml2YXRlIHNldCBfY3Vyck5vZGUobm9kZTogUGFyZW50Tm9kZSkge1xuICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXNcbiAgICBuc1tucy5sZW5ndGggLSAxXSA9IG5vZGVcbiAgfVxuXG4gIC8vIGdldCBub2RlQ291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gdGhpcy5fcm9vdC5jb3VudFxuICAvLyB9XG59XG5cbmZ1bmN0aW9uIGFkZE5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGZyb206IFVzZWROYW1lcyk6IFVzZWROYW1lcyB7XG4gIGZvciAoY29uc3QgbiBpbiBmcm9tKSBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApXG4gIHJldHVybiBuYW1lc1xufVxuXG5mdW5jdGlvbiBhZGRFeHByTmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogU2FmZUV4cHIpOiBVc2VkTmFtZXMge1xuICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXNcbn1cblxuZnVuY3Rpb24gb3B0aW1pemVFeHByPFQgZXh0ZW5kcyBTYWZlRXhwciB8IENvZGU+KGV4cHI6IFQsIG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogVFxuZnVuY3Rpb24gb3B0aW1pemVFeHByKGV4cHI6IFNhZmVFeHByLCBuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IFNhZmVFeHByIHtcbiAgaWYgKGV4cHIgaW5zdGFuY2VvZiBOYW1lKSByZXR1cm4gcmVwbGFjZU5hbWUoZXhwcilcbiAgaWYgKCFjYW5PcHRpbWl6ZShleHByKSkgcmV0dXJuIGV4cHJcbiAgcmV0dXJuIG5ldyBfQ29kZShcbiAgICBleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zOiBDb2RlSXRlbVtdLCBjOiBTYWZlRXhwciB8IHN0cmluZykgPT4ge1xuICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKSBjID0gcmVwbGFjZU5hbWUoYylcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgX0NvZGUpIGl0ZW1zLnB1c2goLi4uYy5faXRlbXMpXG4gICAgICBlbHNlIGl0ZW1zLnB1c2goYylcbiAgICAgIHJldHVybiBpdGVtc1xuICAgIH0sIFtdKVxuICApXG5cbiAgZnVuY3Rpb24gcmVwbGFjZU5hbWUobjogTmFtZSk6IFNhZmVFeHByIHtcbiAgICBjb25zdCBjID0gY29uc3RhbnRzW24uc3RyXVxuICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKSByZXR1cm4gblxuICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl1cbiAgICByZXR1cm4gY1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuT3B0aW1pemUoZTogU2FmZUV4cHIpOiBlIGlzIF9Db2RlIHtcbiAgICByZXR1cm4gKFxuICAgICAgZSBpbnN0YW5jZW9mIF9Db2RlICYmXG4gICAgICBlLl9pdGVtcy5zb21lKFxuICAgICAgICAoYykgPT4gYyBpbnN0YW5jZW9mIE5hbWUgJiYgbmFtZXNbYy5zdHJdID09PSAxICYmIGNvbnN0YW50c1tjLnN0cl0gIT09IHVuZGVmaW5lZFxuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGZyb206IFVzZWROYW1lcyk6IHZvaWQge1xuICBmb3IgKGNvbnN0IG4gaW4gZnJvbSkgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgLSAoZnJvbVtuXSB8fCAwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm90PFQgZXh0ZW5kcyBDb2RlIHwgU2FmZUV4cHI+KHg6IFQpOiBUXG5leHBvcnQgZnVuY3Rpb24gbm90KHg6IENvZGUgfCBTYWZlRXhwcik6IENvZGUgfCBTYWZlRXhwciB7XG4gIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6IF9gISR7cGFyKHgpfWBcbn1cblxuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQob3BlcmF0b3JzLkFORClcblxuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmV4cG9ydCBmdW5jdGlvbiBhbmQoLi4uYXJnczogQ29kZVtdKTogQ29kZSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKVxufVxuXG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKG9wZXJhdG9ycy5PUilcblxuLy8gYm9vbGVhbiBPUiAofHwpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIG9yKC4uLmFyZ3M6IENvZGVbXSk6IENvZGUge1xuICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKVxufVxuXG50eXBlIE1BcHBlbmQgPSAoeDogQ29kZSwgeTogQ29kZSkgPT4gQ29kZVxuXG5mdW5jdGlvbiBtYXBwZW5kKG9wOiBDb2RlKTogTUFwcGVuZCB7XG4gIHJldHVybiAoeCwgeSkgPT4gKHggPT09IG5pbCA/IHkgOiB5ID09PSBuaWwgPyB4IDogX2Ake3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YClcbn1cblxuZnVuY3Rpb24gcGFyKHg6IENvZGUpOiBDb2RlIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBOYW1lID8geCA6IF9gKCR7eH0pYFxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWEsIEV2YWx1YXRlZFByb3BlcnRpZXMsIEV2YWx1YXRlZEl0ZW1zfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLlwiXG5pbXBvcnQge18sIGdldFByb3BlcnR5LCBDb2RlLCBOYW1lLCBDb2RlR2VufSBmcm9tIFwiLi9jb2RlZ2VuXCJcbmltcG9ydCB7X0NvZGV9IGZyb20gXCIuL2NvZGVnZW4vY29kZVwiXG5pbXBvcnQgdHlwZSB7UnVsZSwgVmFsaWRhdGlvblJ1bGVzfSBmcm9tIFwiLi9ydWxlc1wiXG5cbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIFNldFxuZXhwb3J0IGZ1bmN0aW9uIHRvSGFzaDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihhcnI6IFRbXSk6IHtbSyBpbiBUXT86IHRydWV9IHtcbiAgY29uc3QgaGFzaDoge1tLIGluIFRdPzogdHJ1ZX0gPSB7fVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSBoYXNoW2l0ZW1dID0gdHJ1ZVxuICByZXR1cm4gaGFzaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWx3YXlzVmFsaWRTY2hlbWEoaXQ6IFNjaGVtYUN4dCwgc2NoZW1hOiBBbnlTY2hlbWEpOiBib29sZWFuIHwgdm9pZCB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gc2NoZW1hXG4gIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWVcbiAgY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSlcbiAgcmV0dXJuICFzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIGl0LnNlbGYuUlVMRVMuYWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tVbmtub3duUnVsZXMoaXQ6IFNjaGVtYUN4dCwgc2NoZW1hOiBBbnlTY2hlbWEgPSBpdC5zY2hlbWEpOiB2b2lkIHtcbiAgY29uc3Qge29wdHMsIHNlbGZ9ID0gaXRcbiAgaWYgKCFvcHRzLnN0cmljdFNjaGVtYSkgcmV0dXJuXG4gIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIikgcmV0dXJuXG4gIGNvbnN0IHJ1bGVzID0gc2VsZi5SVUxFUy5rZXl3b3Jkc1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoIXJ1bGVzW2tleV0pIGNoZWNrU3RyaWN0TW9kZShpdCwgYHVua25vd24ga2V5d29yZDogXCIke2tleX1cImApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKFxuICBzY2hlbWE6IEFueVNjaGVtYSxcbiAgcnVsZXM6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFuIHwgUnVsZX1cbik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuICFzY2hlbWFcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSBpZiAocnVsZXNba2V5XSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWE6IEFueVNjaGVtYSwgUlVMRVM6IFZhbGlkYXRpb25SdWxlcyk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuICFzY2hlbWFcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSBpZiAoa2V5ICE9PSBcIiRyZWZcIiAmJiBSVUxFUy5hbGxba2V5XSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFSZWZPclZhbChcbiAge3RvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aH06IFNjaGVtYU9iakN4dCxcbiAgc2NoZW1hOiB1bmtub3duLFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gICRkYXRhPzogc3RyaW5nIHwgZmFsc2Vcbik6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHtcbiAgaWYgKCEkZGF0YSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHNjaGVtYVxuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIpIHJldHVybiBfYCR7c2NoZW1hfWBcbiAgfVxuICByZXR1cm4gX2Ake3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHtnZXRQcm9wZXJ0eShrZXl3b3JkKX1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHI6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cjogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIikgcmV0dXJuIGAke3N0cn1gXG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlYWNoSXRlbTxUPih4czogVCB8IFRbXSwgZjogKHg6IFQpID0+IHZvaWQpOiB2b2lkIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgZm9yIChjb25zdCB4IG9mIHhzKSBmKHgpXG4gIH0gZWxzZSB7XG4gICAgZih4cylcbiAgfVxufVxuXG50eXBlIFNvbWVFdmFsdWF0ZWQgPSBFdmFsdWF0ZWRQcm9wZXJ0aWVzIHwgRXZhbHVhdGVkSXRlbXNcblxudHlwZSBNZXJnZUV2YWx1YXRlZEZ1bmM8VCBleHRlbmRzIFNvbWVFdmFsdWF0ZWQ+ID0gKFxuICBnZW46IENvZGVHZW4sXG4gIGZyb206IE5hbWUgfCBULFxuICB0bzogTmFtZSB8IEV4Y2x1ZGU8VCwgdHJ1ZT4gfCB1bmRlZmluZWQsXG4gIHRvTmFtZT86IHR5cGVvZiBOYW1lXG4pID0+IE5hbWUgfCBUXG5cbmludGVyZmFjZSBNYWtlTWVyZ2VGdW5jQXJnczxUIGV4dGVuZHMgU29tZUV2YWx1YXRlZD4ge1xuICBtZXJnZU5hbWVzOiAoZ2VuOiBDb2RlR2VuLCBmcm9tOiBOYW1lLCB0bzogTmFtZSkgPT4gdm9pZFxuICBtZXJnZVRvTmFtZTogKGdlbjogQ29kZUdlbiwgZnJvbTogVCwgdG86IE5hbWUpID0+IHZvaWRcbiAgbWVyZ2VWYWx1ZXM6IChmcm9tOiBULCB0bzogRXhjbHVkZTxULCB0cnVlPikgPT4gVFxuICByZXN1bHRUb05hbWU6IChnZW46IENvZGVHZW4sIHJlcz86IFQpID0+IE5hbWVcbn1cblxuZnVuY3Rpb24gbWFrZU1lcmdlRXZhbHVhdGVkPFQgZXh0ZW5kcyBTb21lRXZhbHVhdGVkPih7XG4gIG1lcmdlTmFtZXMsXG4gIG1lcmdlVG9OYW1lLFxuICBtZXJnZVZhbHVlcyxcbiAgcmVzdWx0VG9OYW1lLFxufTogTWFrZU1lcmdlRnVuY0FyZ3M8VD4pOiBNZXJnZUV2YWx1YXRlZEZ1bmM8VD4ge1xuICByZXR1cm4gKGdlbiwgZnJvbSwgdG8sIHRvTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9XG4gICAgICB0byA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZnJvbVxuICAgICAgICA6IHRvIGluc3RhbmNlb2YgTmFtZVxuICAgICAgICA/IChmcm9tIGluc3RhbmNlb2YgTmFtZSA/IG1lcmdlTmFtZXMoZ2VuLCBmcm9tLCB0bykgOiBtZXJnZVRvTmFtZShnZW4sIGZyb20sIHRvKSwgdG8pXG4gICAgICAgIDogZnJvbSBpbnN0YW5jZW9mIE5hbWVcbiAgICAgICAgPyAobWVyZ2VUb05hbWUoZ2VuLCB0bywgZnJvbSksIGZyb20pXG4gICAgICAgIDogbWVyZ2VWYWx1ZXMoZnJvbSwgdG8pXG4gICAgcmV0dXJuIHRvTmFtZSA9PT0gTmFtZSAmJiAhKHJlcyBpbnN0YW5jZW9mIE5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlc1xuICB9XG59XG5cbmludGVyZmFjZSBNZXJnZUV2YWx1YXRlZCB7XG4gIHByb3BzOiBNZXJnZUV2YWx1YXRlZEZ1bmM8RXZhbHVhdGVkUHJvcGVydGllcz5cbiAgaXRlbXM6IE1lcmdlRXZhbHVhdGVkRnVuYzxFdmFsdWF0ZWRJdGVtcz5cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmdlRXZhbHVhdGVkOiBNZXJnZUV2YWx1YXRlZCA9IHtcbiAgcHJvcHM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5pZihcbiAgICAgICAgICBfYCR7ZnJvbX0gPT09IHRydWVgLFxuICAgICAgICAgICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLFxuICAgICAgICAgICgpID0+IGdlbi5hc3NpZ24odG8sIF9gJHt0b30gfHwge31gKS5jb2RlKF9gT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKVxuICAgICAgICApXG4gICAgICB9KSxcbiAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbi5hc3NpZ24odG8sIF9gJHt0b30gfHwge31gKVxuICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiB7Li4uZnJvbSwgLi4udG99KSxcbiAgICByZXN1bHRUb05hbWU6IGV2YWx1YXRlZFByb3BzVG9OYW1lLFxuICB9KSxcbiAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PlxuICAgICAgICBnZW4uYXNzaWduKHRvLCBfYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YClcbiAgICAgICksXG4gICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PlxuICAgICAgZ2VuLmlmKF9gJHt0b30gIT09IHRydWVgLCAoKSA9PlxuICAgICAgICBnZW4uYXNzaWduKHRvLCBmcm9tID09PSB0cnVlID8gdHJ1ZSA6IF9gJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YClcbiAgICAgICksXG4gICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogTWF0aC5tYXgoZnJvbSwgdG8pKSxcbiAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICB9KSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbjogQ29kZUdlbiwgcHM/OiBFdmFsdWF0ZWRQcm9wZXJ0aWVzKTogTmFtZSB7XG4gIGlmIChwcyA9PT0gdHJ1ZSkgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKVxuICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCBfYHt9YClcbiAgaWYgKHBzICE9PSB1bmRlZmluZWQpIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcylcbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuOiBDb2RlR2VuLCBwcm9wczogTmFtZSwgcHM6IHtbSyBpbiBzdHJpbmddPzogdHJ1ZX0pOiB2b2lkIHtcbiAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oX2Ake3Byb3BzfSR7Z2V0UHJvcGVydHkocCl9YCwgdHJ1ZSkpXG59XG5cbmNvbnN0IHNuaXBwZXRzOiB7W1MgaW4gc3RyaW5nXT86IF9Db2RlfSA9IHt9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGdW5jKGdlbjogQ29kZUdlbiwgZjoge2NvZGU6IHN0cmluZ30pOiBOYW1lIHtcbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgcmVmOiBmLFxuICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgX0NvZGUoZi5jb2RlKSksXG4gIH0pXG59XG5cbmV4cG9ydCBlbnVtIFR5cGUge1xuICBOdW0sXG4gIFN0cixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yUGF0aChcbiAgZGF0YVByb3A6IE5hbWUgfCBzdHJpbmcgfCBudW1iZXIsXG4gIGRhdGFQcm9wVHlwZT86IFR5cGUsXG4gIGpzUHJvcGVydHlTeW50YXg/OiBib29sZWFuXG4pOiBDb2RlIHwgc3RyaW5nIHtcbiAgLy8gbGV0IHBhdGhcbiAgaWYgKGRhdGFQcm9wIGluc3RhbmNlb2YgTmFtZSkge1xuICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bVxuICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICA/IGlzTnVtYmVyXG4gICAgICAgID8gX2BcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgIDogX2BcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgIDogaXNOdW1iZXJcbiAgICAgID8gX2BcIi9cIiArICR7ZGF0YVByb3B9YFxuICAgICAgOiBfYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgIC8vIFRPRE8gbWF5YmUgdXNlIGdsb2JhbCBlc2NhcGVQb2ludGVyXG4gIH1cbiAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyBnZXRQcm9wZXJ0eShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoXG4gIGl0OiBTY2hlbWFDeHQsXG4gIG1zZzogc3RyaW5nLFxuICBtb2RlOiBib29sZWFuIHwgXCJsb2dcIiA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hXG4pOiB2b2lkIHtcbiAgaWYgKCFtb2RlKSByZXR1cm5cbiAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gXG4gIGlmIChtb2RlID09PSB0cnVlKSB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZylcbn1cbiIsICJpbXBvcnQge05hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuXG5jb25zdCBuYW1lcyA9IHtcbiAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgZGF0YTogbmV3IE5hbWUoXCJkYXRhXCIpLCAvLyBkYXRhIHBhc3NlZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIC8vIGFyZ3MgcGFzc2VkIGZyb20gcmVmZXJlbmNpbmcgc2NoZW1hXG4gIHZhbEN4dDogbmV3IE5hbWUoXCJ2YWxDeHRcIiksIC8vIHZhbGlkYXRpb24vZGF0YSBjb250ZXh0IC0gc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCBpdCBpcyBkZXN0cnVjdHVyZWQgdG8gdGhlIG5hbWVzIGJlbG93XG4gIGluc3RhbmNlUGF0aDogbmV3IE5hbWUoXCJpbnN0YW5jZVBhdGhcIiksXG4gIHBhcmVudERhdGE6IG5ldyBOYW1lKFwicGFyZW50RGF0YVwiKSxcbiAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgTmFtZShcInBhcmVudERhdGFQcm9wZXJ0eVwiKSxcbiAgcm9vdERhdGE6IG5ldyBOYW1lKFwicm9vdERhdGFcIiksIC8vIHJvb3QgZGF0YSAtIHNhbWUgYXMgdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBmaXJzdC90b3AgdmFsaWRhdGlvbiBmdW5jdGlvblxuICBkeW5hbWljQW5jaG9yczogbmV3IE5hbWUoXCJkeW5hbWljQW5jaG9yc1wiKSwgLy8gdXNlZCB0byBzdXBwb3J0IHJlY3Vyc2l2ZVJlZiBhbmQgZHluYW1pY1JlZlxuICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gIHZFcnJvcnM6IG5ldyBOYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICBlcnJvcnM6IG5ldyBOYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gIHRoaXM6IG5ldyBOYW1lKFwidGhpc1wiKSxcbiAgLy8gXCJnbG9iYWxzXCJcbiAgc2VsZjogbmV3IE5hbWUoXCJzZWxmXCIpLFxuICBzY29wZTogbmV3IE5hbWUoXCJzY29wZVwiKSxcbiAgLy8gSlREIHNlcmlhbGl6ZS9wYXJzZSBuYW1lIGZvciBKU09OIHN0cmluZyBhbmQgcG9zaXRpb25cbiAganNvbjogbmV3IE5hbWUoXCJqc29uXCIpLFxuICBqc29uUG9zOiBuZXcgTmFtZShcImpzb25Qb3NcIiksXG4gIGpzb25MZW46IG5ldyBOYW1lKFwianNvbkxlblwiKSxcbiAganNvblBhcnQ6IG5ldyBOYW1lKFwianNvblBhcnRcIiksXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hbWVzXG4iLCAiaW1wb3J0IHR5cGUge0tleXdvcmRFcnJvckN4dCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHR9IGZyb20gXCIuL2luZGV4XCJcbmltcG9ydCB7Q29kZUdlbiwgXywgc3RyLCBzdHJDb25jYXQsIENvZGUsIE5hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IHtTYWZlRXhwcn0gZnJvbSBcIi4vY29kZWdlbi9jb2RlXCJcbmltcG9ydCB7Z2V0RXJyb3JQYXRoLCBUeXBlfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCBOIGZyb20gXCIuL25hbWVzXCJcblxuZXhwb3J0IGNvbnN0IGtleXdvcmRFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkfSkgPT4gc3RyYG11c3QgcGFzcyBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIHZhbGlkYXRpb25gLFxufVxuXG5leHBvcnQgY29uc3Qga2V5d29yZCREYXRhRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7a2V5d29yZCwgc2NoZW1hVHlwZX0pID0+XG4gICAgc2NoZW1hVHlwZVxuICAgICAgPyBzdHJgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgIDogc3RyYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvclBhdGhzIHtcbiAgaW5zdGFuY2VQYXRoPzogQ29kZVxuICBzY2hlbWFQYXRoPzogc3RyaW5nXG4gIHBhcmVudFNjaGVtYT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEVycm9yKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSBrZXl3b3JkRXJyb3IsXG4gIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzLFxuICBvdmVycmlkZUFsbEVycm9ycz86IGJvb2xlYW5cbik6IHZvaWQge1xuICBjb25zdCB7aXR9ID0gY3h0XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9yc30gPSBpdFxuICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocylcbiAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzID8/IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICBhZGRFcnJvcihnZW4sIGVyck9iailcbiAgfSBlbHNlIHtcbiAgICByZXR1cm5FcnJvcnMoaXQsIF9gWyR7ZXJyT2JqfV1gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRFeHRyYUVycm9yKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSBrZXl3b3JkRXJyb3IsXG4gIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzXG4pOiB2b2lkIHtcbiAgY29uc3Qge2l0fSA9IGN4dFxuICBjb25zdCB7Z2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnN9ID0gaXRcbiAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpXG4gIGFkZEVycm9yKGdlbiwgZXJyT2JqKVxuICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICByZXR1cm5FcnJvcnMoaXQsIE4udkVycm9ycylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRFcnJvcnNDb3VudChnZW46IENvZGVHZW4sIGVycnNDb3VudDogTmFtZSk6IHZvaWQge1xuICBnZW4uYXNzaWduKE4uZXJyb3JzLCBlcnJzQ291bnQpXG4gIGdlbi5pZihfYCR7Ti52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+XG4gICAgZ2VuLmlmKFxuICAgICAgZXJyc0NvdW50LFxuICAgICAgKCkgPT4gZ2VuLmFzc2lnbihfYCR7Ti52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLFxuICAgICAgKCkgPT4gZ2VuLmFzc2lnbihOLnZFcnJvcnMsIG51bGwpXG4gICAgKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRFcnJvcnMoe1xuICBnZW4sXG4gIGtleXdvcmQsXG4gIHNjaGVtYVZhbHVlLFxuICBkYXRhLFxuICBlcnJzQ291bnQsXG4gIGl0LFxufTogS2V5d29yZEVycm9yQ3h0KTogdm9pZCB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKVxuICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgTi5lcnJvcnMsIChpKSA9PiB7XG4gICAgZ2VuLmNvbnN0KGVyciwgX2Ake04udkVycm9yc31bJHtpfV1gKVxuICAgIGdlbi5pZihfYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+XG4gICAgICBnZW4uYXNzaWduKF9gJHtlcnJ9Lmluc3RhbmNlUGF0aGAsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKSlcbiAgICApXG4gICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5zY2hlbWFQYXRoYCwgc3RyYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApXG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSlcbiAgICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uZGF0YWAsIGRhdGEpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRFcnJvcihnZW46IENvZGVHZW4sIGVyck9iajogQ29kZSk6IHZvaWQge1xuICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKVxuICBnZW4uaWYoXG4gICAgX2Ake04udkVycm9yc30gPT09IG51bGxgLFxuICAgICgpID0+IGdlbi5hc3NpZ24oTi52RXJyb3JzLCBfYFske2Vycn1dYCksXG4gICAgX2Ake04udkVycm9yc30ucHVzaCgke2Vycn0pYFxuICApXG4gIGdlbi5jb2RlKF9gJHtOLmVycm9yc30rK2ApXG59XG5cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdDogU2NoZW1hQ3h0LCBlcnJzOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hRW52fSA9IGl0XG4gIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgZ2VuLnRocm93KF9gbmV3ICR7aXQuVmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9KCR7ZXJyc30pYClcbiAgfSBlbHNlIHtcbiAgICBnZW4uYXNzaWduKF9gJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpXG4gICAgZ2VuLnJldHVybihmYWxzZSlcbiAgfVxufVxuXG5jb25zdCBFID0ge1xuICBrZXl3b3JkOiBuZXcgTmFtZShcImtleXdvcmRcIiksXG4gIHNjaGVtYVBhdGg6IG5ldyBOYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgcGFyYW1zOiBuZXcgTmFtZShcInBhcmFtc1wiKSxcbiAgcHJvcGVydHlOYW1lOiBuZXcgTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgbWVzc2FnZTogbmV3IE5hbWUoXCJtZXNzYWdlXCIpLFxuICBzY2hlbWE6IG5ldyBOYW1lKFwic2NoZW1hXCIpLFxuICBwYXJlbnRTY2hlbWE6IG5ldyBOYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufVxuXG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHNcbik6IENvZGUge1xuICBjb25zdCB7Y3JlYXRlRXJyb3JzfSA9IGN4dC5pdFxuICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSkgcmV0dXJuIF9ge31gXG4gIHJldHVybiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzKVxufVxuXG5mdW5jdGlvbiBlcnJvck9iamVjdChcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBlcnJvclBhdGhzOiBFcnJvclBhdGhzID0ge31cbik6IENvZGUge1xuICBjb25zdCB7Z2VuLCBpdH0gPSBjeHRcbiAgY29uc3Qga2V5VmFsdWVzOiBbTmFtZSwgU2FmZUV4cHIgfCBzdHJpbmddW10gPSBbXG4gICAgZXJyb3JJbnN0YW5jZVBhdGgoaXQsIGVycm9yUGF0aHMpLFxuICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICBdXG4gIGV4dHJhRXJyb3JQcm9wcyhjeHQsIGVycm9yLCBrZXlWYWx1ZXMpXG4gIHJldHVybiBnZW4ub2JqZWN0KC4uLmtleVZhbHVlcylcbn1cblxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoe2Vycm9yUGF0aH06IFNjaGVtYUN4dCwge2luc3RhbmNlUGF0aH06IEVycm9yUGF0aHMpOiBbTmFtZSwgQ29kZV0ge1xuICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgID8gc3RyYCR7ZXJyb3JQYXRofSR7Z2V0RXJyb3JQYXRoKGluc3RhbmNlUGF0aCwgVHlwZS5TdHIpfWBcbiAgICA6IGVycm9yUGF0aFxuICByZXR1cm4gW04uaW5zdGFuY2VQYXRoLCBzdHJDb25jYXQoTi5pbnN0YW5jZVBhdGgsIGluc3RQYXRoKV1cbn1cblxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKFxuICB7a2V5d29yZCwgaXQ6IHtlcnJTY2hlbWFQYXRofX06IEtleXdvcmRFcnJvckN4dCxcbiAge3NjaGVtYVBhdGgsIHBhcmVudFNjaGVtYX06IEVycm9yUGF0aHNcbik6IFtOYW1lLCBzdHJpbmcgfCBDb2RlXSB7XG4gIGxldCBzY2hQYXRoID0gcGFyZW50U2NoZW1hID8gZXJyU2NoZW1hUGF0aCA6IHN0cmAke2VyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gXG4gIGlmIChzY2hlbWFQYXRoKSB7XG4gICAgc2NoUGF0aCA9IHN0cmAke3NjaFBhdGh9JHtnZXRFcnJvclBhdGgoc2NoZW1hUGF0aCwgVHlwZS5TdHIpfWBcbiAgfVxuICByZXR1cm4gW0Uuc2NoZW1hUGF0aCwgc2NoUGF0aF1cbn1cblxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAge3BhcmFtcywgbWVzc2FnZX06IEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIGtleVZhbHVlczogW05hbWUsIFNhZmVFeHByIHwgc3RyaW5nXVtdXG4pOiB2b2lkIHtcbiAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYVZhbHVlLCBpdH0gPSBjeHRcbiAgY29uc3Qge29wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRofSA9IGl0XG4gIGtleVZhbHVlcy5wdXNoKFxuICAgIFtFLmtleXdvcmQsIGtleXdvcmRdLFxuICAgIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCBfYHt9YF1cbiAgKVxuICBpZiAob3B0cy5tZXNzYWdlcykge1xuICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKVxuICB9XG4gIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICBrZXlWYWx1ZXMucHVzaChcbiAgICAgIFtFLnNjaGVtYSwgc2NoZW1hVmFsdWVdLFxuICAgICAgW0UucGFyZW50U2NoZW1hLCBfYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gXSxcbiAgICAgIFtOLmRhdGEsIGRhdGFdXG4gICAgKVxuICB9XG4gIGlmIChwcm9wZXJ0eU5hbWUpIGtleVZhbHVlcy5wdXNoKFtFLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lXSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEVycm9yRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yQ3h0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7cmVwb3J0RXJyb3J9IGZyb20gXCIuLi9lcnJvcnNcIlxuaW1wb3J0IHtfLCBOYW1lfSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vbmFtZXNcIlxuXG5jb25zdCBib29sRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCB2YWxpZGF0ZU5hbWV9ID0gaXRcbiAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSlcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgIGdlbi5yZXR1cm4oTi5kYXRhKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbClcbiAgICBnZW4ucmV0dXJuKHRydWUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0OiBTY2hlbWFDeHQsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYX0gPSBpdFxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKSAvLyBUT0RPIHZhclxuICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQpXG4gIH0gZWxzZSB7XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0OiBTY2hlbWFDeHQsIG92ZXJyaWRlQWxsRXJyb3JzPzogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhfSA9IGl0XG4gIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gIGNvbnN0IGN4dDogS2V5d29yZEVycm9yQ3h0ID0ge1xuICAgIGdlbixcbiAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgIGRhdGEsXG4gICAgc2NoZW1hOiBmYWxzZSxcbiAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpdCxcbiAgfVxuICByZXBvcnRFcnJvcihjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycylcbn1cbiIsICJpbXBvcnQgdHlwZSB7QWRkZWRLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uL3R5cGVzXCJcblxuY29uc3QgX2pzb25UeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCJdIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIEpTT05UeXBlID0gKHR5cGVvZiBfanNvblR5cGVzKVtudW1iZXJdXG5cbmNvbnN0IGpzb25UeXBlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KF9qc29uVHlwZXMpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pTT05UeXBlKHg6IHVua25vd24pOiB4IGlzIEpTT05UeXBlIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KVxufVxuXG50eXBlIFZhbGlkYXRpb25UeXBlcyA9IHtcbiAgW0sgaW4gSlNPTlR5cGVdOiBib29sZWFuIHwgUnVsZUdyb3VwIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJ1bGVzIHtcbiAgcnVsZXM6IFJ1bGVHcm91cFtdXG4gIHBvc3Q6IFJ1bGVHcm91cFxuICBhbGw6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFuIHwgUnVsZX0gLy8gcnVsZXMgdGhhdCBoYXZlIHRvIGJlIHZhbGlkYXRlZFxuICBrZXl3b3Jkczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW59IC8vIGFsbCBrbm93biBrZXl3b3JkcyAoc3VwZXJzZXQgb2YgXCJhbGxcIilcbiAgdHlwZXM6IFZhbGlkYXRpb25UeXBlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVHcm91cCB7XG4gIHR5cGU/OiBKU09OVHlwZVxuICBydWxlczogUnVsZVtdXG59XG5cbi8vIFRoaXMgaW50ZXJmYWNlIHdyYXBzIEtleXdvcmREZWZpbml0aW9uIGJlY2F1c2UgZGVmaW5pdGlvbiBjYW4gaGF2ZSBtdWx0aXBsZSBrZXl3b3Jkc1xuZXhwb3J0IGludGVyZmFjZSBSdWxlIHtcbiAga2V5d29yZDogc3RyaW5nXG4gIGRlZmluaXRpb246IEFkZGVkS2V5d29yZERlZmluaXRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bGVzKCk6IFZhbGlkYXRpb25SdWxlcyB7XG4gIGNvbnN0IGdyb3VwczogUmVjb3JkPFwibnVtYmVyXCIgfCBcInN0cmluZ1wiIHwgXCJhcnJheVwiIHwgXCJvYmplY3RcIiwgUnVsZUdyb3VwPiA9IHtcbiAgICBudW1iZXI6IHt0eXBlOiBcIm51bWJlclwiLCBydWxlczogW119LFxuICAgIHN0cmluZzoge3R5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXX0sXG4gICAgYXJyYXk6IHt0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXX0sXG4gICAgb2JqZWN0OiB7dHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdfSxcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVzOiB7Li4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlfSxcbiAgICBydWxlczogW3tydWxlczogW119LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgIHBvc3Q6IHtydWxlczogW119LFxuICAgIGFsbDoge30sXG4gICAga2V5d29yZHM6IHt9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYU9iamVjdH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGUsIFJ1bGVHcm91cCwgUnVsZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZShcbiAge3NjaGVtYSwgc2VsZn06IFNjaGVtYU9iakN4dCxcbiAgdHlwZTogSlNPTlR5cGVcbik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV1cbiAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgZ3JvdXA6IFJ1bGVHcm91cCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgcnVsZTogUnVsZSk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gKFxuICAgIHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cz8uc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKVxuICApXG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JDeHQsXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtpc0pTT05UeXBlLCBKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNGb3JUeXBlfSBmcm9tIFwiLi9hcHBsaWNhYmlsaXR5XCJcbmltcG9ydCB7cmVwb3J0RXJyb3J9IGZyb20gXCIuLi9lcnJvcnNcIlxuaW1wb3J0IHtfLCBuaWwsIGFuZCwgbm90LCBvcGVyYXRvcnMsIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7dG9IYXNoLCBzY2hlbWFSZWZPclZhbH0gZnJvbSBcIi4uL3V0aWxcIlxuXG5leHBvcnQgZW51bSBEYXRhVHlwZSB7XG4gIENvcnJlY3QsXG4gIFdyb25nLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpXG4gIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIilcbiAgaWYgKGhhc051bGwpIHtcbiAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIilcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpXG4gICAgfVxuICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpIHR5cGVzLnB1c2goXCJudWxsXCIpXG4gIH1cbiAgcmV0dXJuIHR5cGVzXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG5leHBvcnQgZnVuY3Rpb24gZ2V0SlNPTlR5cGVzKHRzOiB1bmtub3duIHwgdW5rbm93bltdKTogSlNPTlR5cGVbXSB7XG4gIGNvbnN0IHR5cGVzOiB1bmtub3duW10gPSBBcnJheS5pc0FycmF5KHRzKSA/IHRzIDogdHMgPyBbdHNdIDogW11cbiAgaWYgKHR5cGVzLmV2ZXJ5KGlzSlNPTlR5cGUpKSByZXR1cm4gdHlwZXNcbiAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0OiBTY2hlbWFPYmpDeHQsIHR5cGVzOiBKU09OVHlwZVtdKTogYm9vbGVhbiB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIG9wdHN9ID0gaXRcbiAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKVxuICBjb25zdCBjaGVja1R5cGVzID1cbiAgICB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgIShjb2VyY2VUby5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAxICYmIHNjaGVtYUhhc1J1bGVzRm9yVHlwZShpdCwgdHlwZXNbMF0pKVxuICBpZiAoY2hlY2tUeXBlcykge1xuICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKVxuICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbylcbiAgICAgIGVsc2UgcmVwb3J0VHlwZUVycm9yKGl0KVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGNoZWNrVHlwZXNcbn1cblxuY29uc3QgQ09FUkNJQkxFOiBTZXQ8SlNPTlR5cGU+ID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pXG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzOiBKU09OVHlwZVtdLCBjb2VyY2VUeXBlcz86IGJvb2xlYW4gfCBcImFycmF5XCIpOiBKU09OVHlwZVtdIHtcbiAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10sIGNvZXJjZVRvOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIG9wdHN9ID0gaXRcbiAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgX2B0eXBlb2YgJHtkYXRhfWApXG4gIGNvbnN0IGNvZXJjZWQgPSBnZW4ubGV0KFwiY29lcmNlZFwiLCBfYHVuZGVmaW5lZGApXG4gIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICBnZW4uaWYoX2Ake2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PlxuICAgICAgZ2VuXG4gICAgICAgIC5hc3NpZ24oZGF0YSwgX2Ake2RhdGF9WzBdYClcbiAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgX2B0eXBlb2YgJHtkYXRhfWApXG4gICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSlcbiAgICApXG4gIH1cbiAgZ2VuLmlmKF9gJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYClcbiAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodClcbiAgICB9XG4gIH1cbiAgZ2VuLmVsc2UoKVxuICByZXBvcnRUeXBlRXJyb3IoaXQpXG4gIGdlbi5lbmRJZigpXG5cbiAgZ2VuLmlmKF9gJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZClcbiAgICBhc3NpZ25QYXJlbnREYXRhKGl0LCBjb2VyY2VkKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihfYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2BcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgLmVsc2VJZihfYCR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2BcIlwiYClcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoXG4gICAgICAgICAgICBfYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYCske2RhdGF9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKFxuICAgICAgICAgICAgX2Ake2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYCske2RhdGF9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBmYWxzZSlcbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCB0cnVlKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgIGdlbi5lbHNlSWYoX2Ake2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKVxuICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihcbiAgICAgICAgICAgIF9gJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgXG4gICAgICAgICAgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2BbJHtkYXRhfV1gKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25QYXJlbnREYXRhKHtnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eX06IFNjaGVtYU9iakN4dCwgZXhwcjogTmFtZSk6IHZvaWQge1xuICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgZ2VuLmlmKF9gJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT5cbiAgICBnZW4uYXNzaWduKF9gJHtwYXJlbnREYXRhfVske3BhcmVudERhdGFQcm9wZXJ0eX1dYCwgZXhwcilcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShcbiAgZGF0YVR5cGU6IEpTT05UeXBlLFxuICBkYXRhOiBOYW1lLFxuICBzdHJpY3ROdW1zPzogYm9vbGVhbiB8IFwibG9nXCIsXG4gIGNvcnJlY3QgPSBEYXRhVHlwZS5Db3JyZWN0XG4pOiBDb2RlIHtcbiAgY29uc3QgRVEgPSBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gb3BlcmF0b3JzLkVRIDogb3BlcmF0b3JzLk5FUVxuICBsZXQgY29uZDogQ29kZVxuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICAgIHJldHVybiBfYCR7ZGF0YX0gJHtFUX0gbnVsbGBcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGNvbmQgPSBfYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGNvbmQgPSBfYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWBcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgIGNvbmQgPSBudW1Db25kKF9gISgke2RhdGF9ICUgMSkgJiYgIWlzTmFOKCR7ZGF0YX0pYClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY29uZCA9IG51bUNvbmQoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF9gdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gXG4gIH1cbiAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogbm90KGNvbmQpXG5cbiAgZnVuY3Rpb24gbnVtQ29uZChfY29uZDogQ29kZSA9IG5pbCk6IENvZGUge1xuICAgIHJldHVybiBhbmQoX2B0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyBfYGlzRmluaXRlKCR7ZGF0YX0pYCA6IG5pbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoXG4gIGRhdGFUeXBlczogSlNPTlR5cGVbXSxcbiAgZGF0YTogTmFtZSxcbiAgc3RyaWN0TnVtcz86IGJvb2xlYW4gfCBcImxvZ1wiLFxuICBjb3JyZWN0PzogRGF0YVR5cGVcbik6IENvZGUge1xuICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdClcbiAgfVxuICBsZXQgY29uZDogQ29kZVxuICBjb25zdCB0eXBlcyA9IHRvSGFzaChkYXRhVHlwZXMpXG4gIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICBjb25zdCBub3RPYmogPSBfYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgXG4gICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiBfYCEke2RhdGF9IHx8ICR7bm90T2JqfWBcbiAgICBkZWxldGUgdHlwZXMubnVsbFxuICAgIGRlbGV0ZSB0eXBlcy5hcnJheVxuICAgIGRlbGV0ZSB0eXBlcy5vYmplY3RcbiAgfSBlbHNlIHtcbiAgICBjb25kID0gbmlsXG4gIH1cbiAgaWYgKHR5cGVzLm51bWJlcikgZGVsZXRlIHR5cGVzLmludGVnZXJcbiAgZm9yIChjb25zdCB0IGluIHR5cGVzKSBjb25kID0gYW5kKGNvbmQsIGNoZWNrRGF0YVR5cGUodCBhcyBKU09OVHlwZSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpXG4gIHJldHVybiBjb25kXG59XG5cbmV4cG9ydCB0eXBlIFR5cGVFcnJvciA9IEVycm9yT2JqZWN0PFwidHlwZVwiLCB7dHlwZTogc3RyaW5nfT5cblxuY29uc3QgdHlwZUVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYX0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gIHBhcmFtczogKHtzY2hlbWEsIHNjaGVtYVZhbHVlfSkgPT5cbiAgICB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyBfYHt0eXBlOiAke3NjaGVtYX19YCA6IF9ge3R5cGU6ICR7c2NoZW1hVmFsdWV9fWAsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRUeXBlRXJyb3IoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCBjeHQgPSBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KVxuICByZXBvcnRFcnJvcihjeHQsIHR5cGVFcnJvcilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdDogU2NoZW1hT2JqQ3h0KTogS2V5d29yZEVycm9yQ3h0IHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hfSA9IGl0XG4gIGNvbnN0IHNjaGVtYUNvZGUgPSBzY2hlbWFSZWZPclZhbChpdCwgc2NoZW1hLCBcInR5cGVcIilcbiAgcmV0dXJuIHtcbiAgICBnZW4sXG4gICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgZGF0YSxcbiAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgIHNjaGVtYUNvZGUsXG4gICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpdCxcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge18sIGdldFByb3BlcnR5LCBzdHJpbmdpZnl9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vdXRpbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdDogU2NoZW1hT2JqQ3h0LCB0eT86IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB7cHJvcGVydGllcywgaXRlbXN9ID0gaXQuc2NoZW1hXG4gIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdClcbiAgICB9XG4gIH0gZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgIGl0ZW1zLmZvckVhY2goKHNjaCwgaTogbnVtYmVyKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdDogU2NoZW1hT2JqQ3h0LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIsIGRlZmF1bHRWYWx1ZTogdW5rbm93bik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzfSA9IGl0XG4gIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGNvbnN0IGNoaWxkRGF0YSA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcCl9YFxuICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApXG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY29uZGl0aW9uID0gX2Ake2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGBcbiAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgIGNvbmRpdGlvbiA9IF9gJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgXG4gIH1cbiAgLy8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYCArXG4gIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgZ2VuLmlmKGNvbmRpdGlvbiwgX2Ake2NoaWxkRGF0YX0gPSAke3N0cmluZ2lmeShkZWZhdWx0VmFsdWUpfWApXG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYSwgU2NoZW1hTWFwfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4uL2NvbXBpbGVcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Q29kZUdlbiwgXywgYW5kLCBvciwgbm90LCBuaWwsIHN0ckNvbmNhdCwgZ2V0UHJvcGVydHksIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgVHlwZX0gZnJvbSBcIi4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vY29tcGlsZS9uYW1lc1wiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi9jb21waWxlL3V0aWxcIlxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0OiBLZXl3b3JkQ3h0LCBwcm9wOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgaXR9ID0gY3h0XG4gIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogX2Ake3Byb3B9YH0sIHRydWUpXG4gICAgY3h0LmVycm9yKClcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTWlzc2luZ1Byb3AoXG4gIHtnZW4sIGRhdGEsIGl0OiB7b3B0c319OiBLZXl3b3JkQ3h0LFxuICBwcm9wZXJ0aWVzOiBzdHJpbmdbXSxcbiAgbWlzc2luZzogTmFtZVxuKTogQ29kZSB7XG4gIHJldHVybiBvcihcbiAgICAuLi5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT5cbiAgICAgIGFuZChub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgX2Ake21pc3Npbmd9ID0gJHtwcm9wfWApXG4gICAgKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRNaXNzaW5nUHJvcChjeHQ6IEtleXdvcmRDeHQsIG1pc3Npbmc6IE5hbWUpOiB2b2lkIHtcbiAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nfSwgdHJ1ZSlcbiAgY3h0LmVycm9yKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbjogQ29kZUdlbik6IE5hbWUge1xuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgcmVmOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgIGNvZGU6IF9gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc093blByb3BlcnR5KGdlbjogQ29kZUdlbiwgZGF0YTogTmFtZSwgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcpOiBDb2RlIHtcbiAgcmV0dXJuIF9gJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKFxuICBnZW46IENvZGVHZW4sXG4gIGRhdGE6IE5hbWUsXG4gIHByb3BlcnR5OiBOYW1lIHwgc3RyaW5nLFxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGNvbmQgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGBcbiAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBfYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKFxuICBnZW46IENvZGVHZW4sXG4gIGRhdGE6IE5hbWUsXG4gIHByb3BlcnR5OiBOYW1lIHwgc3RyaW5nLFxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGNvbmQgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGBcbiAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBvcihjb25kLCBub3QoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXA/OiBTY2hlbWFNYXApOiBzdHJpbmdbXSB7XG4gIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hUHJvcGVydGllcyhpdDogU2NoZW1hQ3h0LCBzY2hlbWFNYXA6IFNjaGVtYU1hcCk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKS5maWx0ZXIoXG4gICAgKHApID0+ICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hTWFwW3BdIGFzIEFueVNjaGVtYSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZShcbiAge3NjaGVtYUNvZGUsIGRhdGEsIGl0OiB7Z2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aH0sIGl0fTogS2V5d29yZEN4dCxcbiAgZnVuYzogQ29kZSxcbiAgY29udGV4dDogQ29kZSxcbiAgcGFzc1NjaGVtYT86IGJvb2xlYW5cbik6IENvZGUge1xuICBjb25zdCBkYXRhQW5kU2NoZW1hID0gcGFzc1NjaGVtYSA/IF9gJHtzY2hlbWFDb2RlfSwgJHtkYXRhfSwgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWAgOiBkYXRhXG4gIGNvbnN0IHZhbEN4dDogW05hbWUsIENvZGUgfCBudW1iZXJdW10gPSBbXG4gICAgW04uaW5zdGFuY2VQYXRoLCBzdHJDb25jYXQoTi5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgIFtOLnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgIFtOLnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICBbTi5yb290RGF0YSwgTi5yb290RGF0YV0sXG4gIF1cbiAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZikgdmFsQ3h0LnB1c2goW04uZHluYW1pY0FuY2hvcnMsIE4uZHluYW1pY0FuY2hvcnNdKVxuICBjb25zdCBhcmdzID0gX2Ake2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gXG4gIHJldHVybiBjb250ZXh0ICE9PSBuaWwgPyBfYCR7ZnVuY30uY2FsbCgke2NvbnRleHR9LCAke2FyZ3N9KWAgOiBfYCR7ZnVuY30oJHthcmdzfSlgXG59XG5cbmNvbnN0IG5ld1JlZ0V4cCA9IF9gbmV3IFJlZ0V4cGBcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdHRlcm4oe2dlbiwgaXQ6IHtvcHRzfX06IEtleXdvcmRDeHQsIHBhdHRlcm46IHN0cmluZyk6IE5hbWUge1xuICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiXG4gIGNvbnN0IHtyZWdFeHB9ID0gb3B0cy5jb2RlXG4gIGNvbnN0IHJ4ID0gcmVnRXhwKHBhdHRlcm4sIHUpXG5cbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAga2V5OiByeC50b1N0cmluZygpLFxuICAgIHJlZjogcngsXG4gICAgY29kZTogX2Ake3JlZ0V4cC5jb2RlID09PSBcIm5ldyBSZWdFeHBcIiA/IG5ld1JlZ0V4cCA6IHVzZUZ1bmMoZ2VuLCByZWdFeHApfSgke3BhdHRlcm59LCAke3V9KWAsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dDogS2V5d29yZEN4dCk6IE5hbWUge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICBjb25zdCB2YWxpZEFyciA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKVxuICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKVxuICAgIHJldHVybiB2YWxpZEFyclxuICB9XG4gIGdlbi52YXIodmFsaWQsIHRydWUpXG4gIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmJyZWFrKCkpXG4gIHJldHVybiB2YWxpZFxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQ6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgX2Ake2RhdGF9Lmxlbmd0aGApXG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksIG5vdFZhbGlkKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0OiBLZXl3b3JkQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaDogQW55U2NoZW1hKSA9PiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSlcbiAgaWYgKGFsd2F5c1ZhbGlkICYmICFpdC5vcHRzLnVuZXZhbHVhdGVkKSByZXR1cm5cblxuICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSlcbiAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuXG4gIGdlbi5ibG9jaygoKSA9PlxuICAgIHNjaGVtYS5mb3JFYWNoKChfc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBzY2hWYWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgX2Ake3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApXG4gICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKVxuICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIGFuZCBpdGVtcyB3ZXJlIGV2YWx1YXRlZCAoaXQucHJvcHMgPT09IHRydWUgJiYgaXQuaXRlbXMgPT09IHRydWUpXG4gICAgICBpZiAoIW1lcmdlZCkgZ2VuLmlmKG5vdCh2YWxpZCkpXG4gICAgfSlcbiAgKVxuXG4gIGN4dC5yZXN1bHQoXG4gICAgdmFsaWQsXG4gICAgKCkgPT4gY3h0LnJlc2V0KCksXG4gICAgKCkgPT4gY3h0LmVycm9yKHRydWUpXG4gIClcbn1cbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi5cIlxuaW1wb3J0IHR5cGUge1xuICBBbnlTY2hlbWEsXG4gIFNjaGVtYVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIE1hY3JvS2V5d29yZERlZmluaXRpb24sXG4gIEZ1bmNLZXl3b3JkRGVmaW5pdGlvbixcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge18sIG5pbCwgbm90LCBzdHJpbmdpZnksIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGV9IGZyb20gXCIuLi9ydWxlc1wiXG5pbXBvcnQge2NhbGxWYWxpZGF0ZUNvZGV9IGZyb20gXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiXG5pbXBvcnQge2V4dGVuZEVycm9yc30gZnJvbSBcIi4uL2Vycm9yc1wiXG5cbnR5cGUgS2V5d29yZENvbXBpbGF0aW9uUmVzdWx0ID0gQW55U2NoZW1hIHwgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbiB8IEFueVZhbGlkYXRlRnVuY3Rpb25cblxuZXhwb3J0IGZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0OiBLZXl3b3JkQ3h0LCBkZWY6IE1hY3JvS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdClcbiAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKVxuICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpXG5cbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGN4dC5zdWJzY2hlbWEoXG4gICAge1xuICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgIHNjaGVtYVBhdGg6IG5pbCxcbiAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgdG9wU2NoZW1hUmVmOiBzY2hlbWFSZWYsXG4gICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sXG4gICAgdmFsaWRcbiAgKVxuICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dDogS2V5d29yZEN4dCwgZGVmOiBGdW5jS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsICRkYXRhLCBpdH0gPSBjeHRcbiAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZilcbiAgY29uc3QgdmFsaWRhdGUgPVxuICAgICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZVxuICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSlcbiAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZClcbiAgY3h0Lm9rKGRlZi52YWxpZCA/PyB2YWxpZClcblxuICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKTogdm9pZCB7XG4gICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICBhc3NpZ25WYWxpZCgpXG4gICAgICBpZiAoZGVmLm1vZGlmeWluZykgbW9kaWZ5RGF0YShjeHQpXG4gICAgICByZXBvcnRFcnJzKCgpID0+IGN4dC5lcnJvcigpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpXG4gICAgICBpZiAoZGVmLm1vZGlmeWluZykgbW9kaWZ5RGF0YShjeHQpXG4gICAgICByZXBvcnRFcnJzKCgpID0+IGFkZEVycnMoY3h0LCBydWxlRXJycykpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpOiBOYW1lIHtcbiAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKVxuICAgIGdlbi50cnkoXG4gICAgICAoKSA9PiBhc3NpZ25WYWxpZChfYGF3YWl0IGApLFxuICAgICAgKGUpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5pZihcbiAgICAgICAgICBfYCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvciBhcyBOYW1lfWAsXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgX2Ake2V9LmVycm9yc2ApLFxuICAgICAgICAgICgpID0+IGdlbi50aHJvdyhlKVxuICAgICAgICApXG4gICAgKVxuICAgIHJldHVybiBydWxlRXJyc1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCk6IENvZGUge1xuICAgIGNvbnN0IHZhbGlkYXRlRXJycyA9IF9gJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYFxuICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKVxuICAgIGFzc2lnblZhbGlkKG5pbClcbiAgICByZXR1cm4gdmFsaWRhdGVFcnJzXG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25WYWxpZChfYXdhaXQ6IENvZGUgPSBkZWYuYXN5bmMgPyBfYGF3YWl0IGAgOiBuaWwpOiB2b2lkIHtcbiAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IE4udGhpcyA6IE4uc2VsZlxuICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSlcbiAgICBnZW4uYXNzaWduKFxuICAgICAgdmFsaWQsXG4gICAgICBfYCR7X2F3YWl0fSR7Y2FsbFZhbGlkYXRlQ29kZShjeHQsIHZhbGlkYXRlUmVmLCBwYXNzQ3h0LCBwYXNzU2NoZW1hKX1gLFxuICAgICAgZGVmLm1vZGlmeWluZ1xuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZ2VuLmlmKG5vdChkZWYudmFsaWQgPz8gdmFsaWQpLCBlcnJvcnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgaXR9ID0gY3h0XG4gIGdlbi5pZihpdC5wYXJlbnREYXRhLCAoKSA9PiBnZW4uYXNzaWduKGRhdGEsIF9gJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpXG59XG5cbmZ1bmN0aW9uIGFkZEVycnMoY3h0OiBLZXl3b3JkQ3h0LCBlcnJzOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IHtnZW59ID0gY3h0XG4gIGdlbi5pZihcbiAgICBfYEFycmF5LmlzQXJyYXkoJHtlcnJzfSlgLFxuICAgICgpID0+IHtcbiAgICAgIGdlblxuICAgICAgICAuYXNzaWduKE4udkVycm9ycywgX2Ake04udkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtOLnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgIC5hc3NpZ24oTi5lcnJvcnMsIF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGApXG4gICAgICBleHRlbmRFcnJvcnMoY3h0KVxuICAgIH0sXG4gICAgKCkgPT4gY3h0LmVycm9yKClcbiAgKVxufVxuXG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7c2NoZW1hRW52fTogU2NoZW1hT2JqQ3h0LCBkZWY6IEZ1bmNLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpXG59XG5cbmZ1bmN0aW9uIHVzZUtleXdvcmQoZ2VuOiBDb2RlR2VuLCBrZXl3b3JkOiBzdHJpbmcsIHJlc3VsdD86IEtleXdvcmRDb21waWxhdGlvblJlc3VsdCk6IE5hbWUge1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihga2V5d29yZCBcIiR7a2V5d29yZH1cIiBmYWlsZWQgdG8gY29tcGlsZWApXG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcbiAgICBcImtleXdvcmRcIixcbiAgICB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHtyZWY6IHJlc3VsdH0gOiB7cmVmOiByZXN1bHQsIGNvZGU6IHN0cmluZ2lmeShyZXN1bHQpfVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoXG4gIHNjaGVtYTogdW5rbm93bixcbiAgc2NoZW1hVHlwZTogSlNPTlR5cGVbXSxcbiAgYWxsb3dVbmRlZmluZWQgPSBmYWxzZVxuKTogYm9vbGVhbiB7XG4gIC8vIFRPRE8gYWRkIHRlc3RzXG4gIHJldHVybiAoXG4gICAgIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgc2NoZW1hVHlwZS5zb21lKChzdCkgPT5cbiAgICAgIHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgPyBBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIilcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKFxuICB7c2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRofTogU2NoZW1hT2JqQ3h0LFxuICBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIGtleXdvcmQ6IHN0cmluZ1xuKTogdm9pZCB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWYua2V5d29yZCkgPyAhZGVmLmtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgOiBkZWYua2V5d29yZCAhPT0ga2V5d29yZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICB9XG5cbiAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXNcbiAgaWYgKGRlcHM/LnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJlbnQgc2NoZW1hIG11c3QgaGF2ZSBkZXBlbmRlbmNpZXMgb2YgJHtrZXl3b3JkfTogJHtkZXBzLmpvaW4oXCIsXCIpfWApXG4gIH1cblxuICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKVxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIGNvbnN0IG1zZyA9XG4gICAgICAgIGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIHZhbHVlIGlzIGludmFsaWQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cIjogYCArXG4gICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKVxuICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpIHNlbGYubG9nZ2VyLmVycm9yKG1zZylcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7Xywgc3RyLCBnZXRQcm9wZXJ0eSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IHtlc2NhcGVGcmFnbWVudCwgZ2V0RXJyb3JQYXRoLCBUeXBlfSBmcm9tIFwiLi4vdXRpbFwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGV9IGZyb20gXCIuLi9ydWxlc1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NoZW1hQ29udGV4dCB7XG4gIC8vIFRPRE8gdXNlIE9wdGlvbmFsPyBhbGlnbiB3aXRoIFNjaGVtQ3h0IHByb3BlcnR5IHR5cGVzXG4gIHNjaGVtYTogQW55U2NoZW1hXG4gIHNjaGVtYVBhdGg6IENvZGVcbiAgZXJyU2NoZW1hUGF0aDogc3RyaW5nXG4gIHRvcFNjaGVtYVJlZj86IENvZGVcbiAgZXJyb3JQYXRoPzogQ29kZVxuICBkYXRhTGV2ZWw/OiBudW1iZXJcbiAgZGF0YVR5cGVzPzogSlNPTlR5cGVbXVxuICBkYXRhPzogTmFtZVxuICBwYXJlbnREYXRhPzogTmFtZVxuICBwYXJlbnREYXRhUHJvcGVydHk/OiBDb2RlIHwgbnVtYmVyXG4gIGRhdGFOYW1lcz86IE5hbWVbXVxuICBkYXRhUGF0aEFycj86IChDb2RlIHwgbnVtYmVyKVtdXG4gIHByb3BlcnR5TmFtZT86IE5hbWVcbiAganRkRGlzY3JpbWluYXRvcj86IHN0cmluZ1xuICBqdGRNZXRhZGF0YT86IGJvb2xlYW5cbiAgY29tcG9zaXRlUnVsZT86IHRydWVcbiAgY3JlYXRlRXJyb3JzPzogYm9vbGVhblxuICBhbGxFcnJvcnM/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFN1YnNjaGVtYUFyZ3MgPSBQYXJ0aWFsPHtcbiAga2V5d29yZDogc3RyaW5nXG4gIHNjaGVtYVByb3A6IHN0cmluZyB8IG51bWJlclxuICBzY2hlbWE6IEFueVNjaGVtYVxuICBzY2hlbWFQYXRoOiBDb2RlXG4gIGVyclNjaGVtYVBhdGg6IHN0cmluZ1xuICB0b3BTY2hlbWFSZWY6IENvZGVcbiAgZGF0YTogTmFtZSB8IENvZGVcbiAgZGF0YVByb3A6IENvZGUgfCBzdHJpbmcgfCBudW1iZXJcbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdXG4gIGRlZmluZWRQcm9wZXJ0aWVzOiBTZXQ8c3RyaW5nPlxuICBwcm9wZXJ0eU5hbWU6IE5hbWVcbiAgZGF0YVByb3BUeXBlOiBUeXBlXG4gIGp0ZERpc2NyaW1pbmF0b3I6IHN0cmluZ1xuICBqdGRNZXRhZGF0YTogYm9vbGVhblxuICBjb21wb3NpdGVSdWxlOiB0cnVlXG4gIGNyZWF0ZUVycm9yczogYm9vbGVhblxuICBhbGxFcnJvcnM6IGJvb2xlYW5cbn0+XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdWJzY2hlbWEoXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIHtrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZn06IFN1YnNjaGVtYUFyZ3Ncbik6IFN1YnNjaGVtYUNvbnRleHQge1xuICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpXG4gIH1cblxuICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgPyB7XG4gICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgc2NoZW1hUGF0aDogX2Ake2l0LnNjaGVtYVBhdGh9JHtnZXRQcm9wZXJ0eShrZXl3b3JkKX1gLFxuICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgICBzY2hlbWE6IHNjaFtzY2hlbWFQcm9wXSxcbiAgICAgICAgICBzY2hlbWFQYXRoOiBfYCR7aXQuc2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfSR7Z2V0UHJvcGVydHkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7ZXNjYXBlRnJhZ21lbnQoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1hLFxuICAgICAgc2NoZW1hUGF0aCxcbiAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKFxuICBzdWJzY2hlbWE6IFN1YnNjaGVtYUNvbnRleHQsXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIHtkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lfTogU3Vic2NoZW1hQXJnc1xuKTogdm9pZCB7XG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpXG4gIH1cblxuICBjb25zdCB7Z2VufSA9IGl0XG5cbiAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7ZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0c30gPSBpdFxuICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgX2Ake2l0LmRhdGF9JHtnZXRQcm9wZXJ0eShkYXRhUHJvcCl9YCwgdHJ1ZSlcbiAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKVxuICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSBzdHJgJHtlcnJvclBhdGh9JHtnZXRFcnJvclBhdGgoZGF0YVByb3AsIGRwVHlwZSwgb3B0cy5qc1Byb3BlcnR5U3ludGF4KX1gXG4gICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9IF9gJHtkYXRhUHJvcH1gXG4gICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XVxuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5leHREYXRhID0gZGF0YSBpbnN0YW5jZW9mIE5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSkgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpXG4gICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKSBzdWJzY2hlbWEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lXG4gICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgfVxuXG4gIGlmIChkYXRhVHlwZXMpIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXNcblxuICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YTogTmFtZSk6IHZvaWQge1xuICAgIHN1YnNjaGVtYS5kYXRhID0gX25leHREYXRhXG4gICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDFcbiAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW11cbiAgICBpdC5kZWZpbmVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgc3Vic2NoZW1hLnBhcmVudERhdGEgPSBpdC5kYXRhXG4gICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hTW9kZShcbiAgc3Vic2NoZW1hOiBTdWJzY2hlbWFDb250ZXh0LFxuICB7anRkRGlzY3JpbWluYXRvciwganRkTWV0YWRhdGEsIGNvbXBvc2l0ZVJ1bGUsIGNyZWF0ZUVycm9ycywgYWxsRXJyb3JzfTogU3Vic2NoZW1hQXJnc1xuKTogdm9pZCB7XG4gIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZVxuICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnNcbiAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKSBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzXG4gIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvciAvLyBub3QgaW5oZXJpdGVkXG4gIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhIC8vIG5vdCBpbmhlcml0ZWRcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hLCBBbnlTY2hlbWFPYmplY3QsIFVyaVJlc29sdmVyfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUgQWp2IGZyb20gXCIuLi9hanZcIlxuaW1wb3J0IHR5cGUge1VSSUNvbXBvbmVudH0gZnJvbSBcImZhc3QtdXJpXCJcbmltcG9ydCB7ZWFjaEl0ZW19IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0ICogYXMgZXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbFwiXG5pbXBvcnQgKiBhcyB0cmF2ZXJzZSBmcm9tIFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIlxuXG4vLyB0aGUgaGFzaCBvZiBsb2NhbCByZWZlcmVuY2VzIGluc2lkZSB0aGUgc2NoZW1hIChjcmVhdGVkIGJ5IGdldFNjaGVtYVJlZnMpLCB1c2VkIGZvciBpbmxpbmUgcmVzb2x1dGlvblxuZXhwb3J0IHR5cGUgTG9jYWxSZWZzID0ge1tSZWYgaW4gc3RyaW5nXT86IEFueVNjaGVtYU9iamVjdH1cblxuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgXCJ0eXBlXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwicGF0dGVyblwiLFxuICBcIm1heExlbmd0aFwiLFxuICBcIm1pbkxlbmd0aFwiLFxuICBcIm1heFByb3BlcnRpZXNcIixcbiAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gIFwibWF4SXRlbXNcIixcbiAgXCJtaW5JdGVtc1wiLFxuICBcIm1heGltdW1cIixcbiAgXCJtaW5pbXVtXCIsXG4gIFwidW5pcXVlSXRlbXNcIixcbiAgXCJtdWx0aXBsZU9mXCIsXG4gIFwicmVxdWlyZWRcIixcbiAgXCJlbnVtXCIsXG4gIFwiY29uc3RcIixcbl0pXG5cbmV4cG9ydCBmdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hOiBBbnlTY2hlbWEsIGxpbWl0OiBib29sZWFuIHwgbnVtYmVyID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHRydWVcbiAgaWYgKGxpbWl0ID09PSB0cnVlKSByZXR1cm4gIWhhc1JlZihzY2hlbWEpXG4gIGlmICghbGltaXQpIHJldHVybiBmYWxzZVxuICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXRcbn1cblxuY29uc3QgUkVGX0tFWVdPUkRTID0gbmV3IFNldChbXG4gIFwiJHJlZlwiLFxuICBcIiRyZWN1cnNpdmVSZWZcIixcbiAgXCIkcmVjdXJzaXZlQW5jaG9yXCIsXG4gIFwiJGR5bmFtaWNSZWZcIixcbiAgXCIkZHluYW1pY0FuY2hvclwiLFxuXSlcblxuZnVuY3Rpb24gaGFzUmVmKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0KTogYm9vbGVhbiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmIChSRUZfS0VZV09SRFMuaGFzKGtleSkpIHJldHVybiB0cnVlXG4gICAgY29uc3Qgc2NoID0gc2NoZW1hW2tleV1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpICYmIHNjaC5zb21lKGhhc1JlZikpIHJldHVybiB0cnVlXG4gICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIiAmJiBoYXNSZWYoc2NoKSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0KTogbnVtYmVyIHtcbiAgbGV0IGNvdW50ID0gMFxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoa2V5ID09PSBcIiRyZWZcIikgcmV0dXJuIEluZmluaXR5XG4gICAgY291bnQrK1xuICAgIGlmIChTSU1QTEVfSU5MSU5FRC5oYXMoa2V5KSkgY29udGludWVcbiAgICBpZiAodHlwZW9mIHNjaGVtYVtrZXldID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGVhY2hJdGVtKHNjaGVtYVtrZXldLCAoc2NoKSA9PiAoY291bnQgKz0gY291bnRLZXlzKHNjaCkpKVxuICAgIH1cbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gSW5maW5pdHlcbiAgfVxuICByZXR1cm4gY291bnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxQYXRoKHJlc29sdmVyOiBVcmlSZXNvbHZlciwgaWQgPSBcIlwiLCBub3JtYWxpemU/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZClcbiAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRGdWxsUGF0aChyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIHA6IFVSSUNvbXBvbmVudCk6IHN0cmluZyB7XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSByZXNvbHZlci5zZXJpYWxpemUocClcbiAgcmV0dXJuIHNlcmlhbGl6ZWQuc3BsaXQoXCIjXCIpWzBdICsgXCIjXCJcbn1cblxuY29uc3QgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVXJsKHJlc29sdmVyOiBVcmlSZXNvbHZlciwgYmFzZUlkOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShiYXNlSWQsIGlkKVxufVxuXG5jb25zdCBBTkNIT1IgPSAvXlthLXpfXVstYS16MC05Ll9dKiQvaVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyh0aGlzOiBBanYsIHNjaGVtYTogQW55U2NoZW1hLCBiYXNlSWQ6IHN0cmluZyk6IExvY2FsUmVmcyB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4ge31cbiAgY29uc3Qge3NjaGVtYUlkLCB1cmlSZXNvbHZlcn0gPSB0aGlzLm9wdHNcbiAgY29uc3Qgc2NoSWQgPSBub3JtYWxpemVJZChzY2hlbWFbc2NoZW1hSWRdIHx8IGJhc2VJZClcbiAgY29uc3QgYmFzZUlkczoge1tKc29uUHRyIGluIHN0cmluZ10/OiBzdHJpbmd9ID0ge1wiXCI6IHNjaElkfVxuICBjb25zdCBwYXRoUHJlZml4ID0gZ2V0RnVsbFBhdGgodXJpUmVzb2x2ZXIsIHNjaElkLCBmYWxzZSlcbiAgY29uc3QgbG9jYWxSZWZzOiBMb2NhbFJlZnMgPSB7fVxuICBjb25zdCBzY2hlbWFSZWZzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKVxuXG4gIHRyYXZlcnNlKHNjaGVtYSwge2FsbEtleXM6IHRydWV9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0clxuICAgIGxldCBpbm5lckJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl1cbiAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIikgaW5uZXJCYXNlSWQgPSBhZGRSZWYuY2FsbCh0aGlzLCBzY2hbc2NoZW1hSWRdKVxuICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kYW5jaG9yKVxuICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcilcbiAgICBiYXNlSWRzW2pzb25QdHJdID0gaW5uZXJCYXNlSWRcblxuICAgIGZ1bmN0aW9uIGFkZFJlZih0aGlzOiBBanYsIHJlZjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGNvbnN0IF9yZXNvbHZlID0gdGhpcy5vcHRzLnVyaVJlc29sdmVyLnJlc29sdmVcbiAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpXG4gICAgICBpZiAoc2NoZW1hUmVmcy5oYXMocmVmKSkgdGhyb3cgYW1iaWd1b3MocmVmKVxuICAgICAgc2NoZW1hUmVmcy5hZGQocmVmKVxuICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl1cbiAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdXG4gICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKVxuICAgICAgfSBlbHNlIGlmIChyZWYgIT09IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBsb2NhbFJlZnNbcmVmXSwgcmVmKVxuICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQW5jaG9yKHRoaXM6IEFqdiwgYW5jaG9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghQU5DSE9SLnRlc3QoYW5jaG9yKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFuY2hvciBcIiR7YW5jaG9yfVwiYClcbiAgICAgICAgYWRkUmVmLmNhbGwodGhpcywgYCMke2FuY2hvcn1gKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbG9jYWxSZWZzXG5cbiAgZnVuY3Rpb24gY2hlY2tBbWJpZ3Vvc1JlZihzY2gxOiBBbnlTY2hlbWEsIHNjaDI6IEFueVNjaGVtYSB8IHVuZGVmaW5lZCwgcmVmOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSkgdGhyb3cgYW1iaWd1b3MocmVmKVxuICB9XG5cbiAgZnVuY3Rpb24gYW1iaWd1b3MocmVmOiBzdHJpbmcpOiBFcnJvciB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgcmVmZXJlbmNlIFwiJHtyZWZ9XCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWFgKVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgS2V5d29yZEVycm9yQ3h0LFxuICBLZXl3b3JkQ3h0UGFyYW1zLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHR5cGUge0luc3RhbmNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2NvcmVcIlxuaW1wb3J0IHtib29sT3JFbXB0eVNjaGVtYSwgdG9wQm9vbE9yRW1wdHlTY2hlbWF9IGZyb20gXCIuL2Jvb2xTY2hlbWFcIlxuaW1wb3J0IHtjb2VyY2VBbmRDaGVja0RhdGFUeXBlLCBnZXRTY2hlbWFUeXBlc30gZnJvbSBcIi4vZGF0YVR5cGVcIlxuaW1wb3J0IHtzaG91bGRVc2VHcm91cCwgc2hvdWxkVXNlUnVsZX0gZnJvbSBcIi4vYXBwbGljYWJpbGl0eVwiXG5pbXBvcnQge2NoZWNrRGF0YVR5cGUsIGNoZWNrRGF0YVR5cGVzLCByZXBvcnRUeXBlRXJyb3IsIERhdGFUeXBlfSBmcm9tIFwiLi9kYXRhVHlwZVwiXG5pbXBvcnQge2Fzc2lnbkRlZmF1bHRzfSBmcm9tIFwiLi9kZWZhdWx0c1wiXG5pbXBvcnQge2Z1bmNLZXl3b3JkQ29kZSwgbWFjcm9LZXl3b3JkQ29kZSwgdmFsaWRhdGVLZXl3b3JkVXNhZ2UsIHZhbGlkU2NoZW1hVHlwZX0gZnJvbSBcIi4va2V5d29yZFwiXG5pbXBvcnQge2dldFN1YnNjaGVtYSwgZXh0ZW5kU3Vic2NoZW1hRGF0YSwgU3Vic2NoZW1hQXJncywgZXh0ZW5kU3Vic2NoZW1hTW9kZX0gZnJvbSBcIi4vc3Vic2NoZW1hXCJcbmltcG9ydCB7XywgbmlsLCBzdHIsIG9yLCBub3QsIGdldFByb3BlcnR5LCBCbG9jaywgQ29kZSwgTmFtZSwgQ29kZUdlbn0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uL25hbWVzXCJcbmltcG9ydCB7cmVzb2x2ZVVybH0gZnJvbSBcIi4uL3Jlc29sdmVcIlxuaW1wb3J0IHtcbiAgc2NoZW1hUmVmT3JWYWwsXG4gIHNjaGVtYUhhc1J1bGVzQnV0UmVmLFxuICBjaGVja1Vua25vd25SdWxlcyxcbiAgY2hlY2tTdHJpY3RNb2RlLFxuICB1bmVzY2FwZUpzb25Qb2ludGVyLFxuICBtZXJnZUV2YWx1YXRlZCxcbn0gZnJvbSBcIi4uL3V0aWxcIlxuaW1wb3J0IHR5cGUge0pTT05UeXBlLCBSdWxlLCBSdWxlR3JvdXB9IGZyb20gXCIuLi9ydWxlc1wiXG5pbXBvcnQge1xuICBFcnJvclBhdGhzLFxuICByZXBvcnRFcnJvcixcbiAgcmVwb3J0RXh0cmFFcnJvcixcbiAgcmVzZXRFcnJvcnNDb3VudCxcbiAga2V5d29yZCREYXRhRXJyb3IsXG59IGZyb20gXCIuLi9lcnJvcnNcIlxuXG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSBnZW5lcmF0ZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiwgc3Vic2NoZW1hQ29kZSAoYmVsb3cpIGlzIHVzZWQgZm9yIHN1YnNjaGVtYXNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdDogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICBjaGVja0tleXdvcmRzKGl0KVxuICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQpKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKFxuICB7Z2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzfTogU2NoZW1hQ3h0LFxuICBib2R5OiBCbG9ja1xuKTogdm9pZCB7XG4gIGlmIChvcHRzLmNvZGUuZXM1KSB7XG4gICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBfYCR7Ti5kYXRhfSwgJHtOLnZhbEN4dH1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiB7XG4gICAgICBnZW4uY29kZShfYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKVxuICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKVxuICAgICAgZ2VuLmNvZGUoYm9keSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgX2Ake04uZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT5cbiAgICAgIGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzOiBJbnN0YW5jZU9wdGlvbnMpOiBDb2RlIHtcbiAgcmV0dXJuIF9geyR7Ti5pbnN0YW5jZVBhdGh9PVwiXCIsICR7Ti5wYXJlbnREYXRhfSwgJHtOLnBhcmVudERhdGFQcm9wZXJ0eX0sICR7Ti5yb290RGF0YX09JHtcbiAgICBOLmRhdGFcbiAgfSR7b3B0cy5keW5hbWljUmVmID8gX2AsICR7Ti5keW5hbWljQW5jaG9yc309e31gIDogbmlsfX09e31gXG59XG5cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbjogQ29kZUdlbiwgb3B0czogSW5zdGFuY2VPcHRpb25zKTogdm9pZCB7XG4gIGdlbi5pZihcbiAgICBOLnZhbEN4dCxcbiAgICAoKSA9PiB7XG4gICAgICBnZW4udmFyKE4uaW5zdGFuY2VQYXRoLCBfYCR7Ti52YWxDeHR9LiR7Ti5pbnN0YW5jZVBhdGh9YClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhLCBfYCR7Ti52YWxDeHR9LiR7Ti5wYXJlbnREYXRhfWApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YVByb3BlcnR5LCBfYCR7Ti52YWxDeHR9LiR7Ti5wYXJlbnREYXRhUHJvcGVydHl9YClcbiAgICAgIGdlbi52YXIoTi5yb290RGF0YSwgX2Ake04udmFsQ3h0fS4ke04ucm9vdERhdGF9YClcbiAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpIGdlbi52YXIoTi5keW5hbWljQW5jaG9ycywgX2Ake04udmFsQ3h0fS4ke04uZHluYW1pY0FuY2hvcnN9YClcbiAgICB9LFxuICAgICgpID0+IHtcbiAgICAgIGdlbi52YXIoTi5pbnN0YW5jZVBhdGgsIF9gXCJcImApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YSwgX2B1bmRlZmluZWRgKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGFQcm9wZXJ0eSwgX2B1bmRlZmluZWRgKVxuICAgICAgZ2VuLnZhcihOLnJvb3REYXRhLCBOLmRhdGEpXG4gICAgICBpZiAob3B0cy5keW5hbWljUmVmKSBnZW4udmFyKE4uZHluYW1pY0FuY2hvcnMsIF9ge31gKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgb3B0cywgZ2VufSA9IGl0XG4gIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpIGNvbW1lbnRLZXl3b3JkKGl0KVxuICAgIGNoZWNrTm9EZWZhdWx0KGl0KVxuICAgIGdlbi5sZXQoTi52RXJyb3JzLCBudWxsKVxuICAgIGdlbi5sZXQoTi5lcnJvcnMsIDApXG4gICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpIHJlc2V0RXZhbHVhdGVkKGl0KVxuICAgIHR5cGVBbmRLZXl3b3JkcyhpdClcbiAgICByZXR1cm5SZXN1bHRzKGl0KVxuICB9KVxuICByZXR1cm5cbn1cblxuZnVuY3Rpb24gcmVzZXRFdmFsdWF0ZWQoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICAvLyBUT0RPIG1heWJlIHNvbWUgaG9vayB0byBleGVjdXRlIGl0IGluIHRoZSBlbmQgdG8gY2hlY2sgd2hldGhlciBwcm9wcy9pdGVtcyBhcmUgTmFtZSwgYXMgaW4gYXNzaWduRXZhbHVhdGVkXG4gIGNvbnN0IHtnZW4sIHZhbGlkYXRlTmFtZX0gPSBpdFxuICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgX2Ake3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYClcbiAgZ2VuLmlmKF9gJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNQcm9wc2AsICgpID0+IGdlbi5hc3NpZ24oX2Ake2l0LmV2YWx1YXRlZH0ucHJvcHNgLCBfYHVuZGVmaW5lZGApKVxuICBnZW4uaWYoX2Ake2l0LmV2YWx1YXRlZH0uZHluYW1pY0l0ZW1zYCwgKCkgPT4gZ2VuLmFzc2lnbihfYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsIF9gdW5kZWZpbmVkYCkpXG59XG5cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hOiBBbnlTY2hlbWEsIG9wdHM6IEluc3RhbmNlT3B0aW9ucyk6IENvZGUge1xuICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF1cbiAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/IF9gLyojIHNvdXJjZVVSTD0ke3NjaElkfSAqL2AgOiBuaWxcbn1cblxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IHRvIGdlbmVyYXRlIGNvZGUgZm9yIHN1Yi1zY2hlbWFzXG5mdW5jdGlvbiBzdWJzY2hlbWFDb2RlKGl0OiBTY2hlbWFDeHQsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICBjaGVja0tleXdvcmRzKGl0KVxuICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZClcbn1cblxuZnVuY3Rpb24gc2NoZW1hQ3h0SGFzUnVsZXMoe3NjaGVtYSwgc2VsZn06IFNjaGVtYUN4dCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuICFzY2hlbWFcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0OiBTY2hlbWFDeHQpOiBpdCBpcyBTY2hlbWFPYmpDeHQge1xuICByZXR1cm4gdHlwZW9mIGl0LnNjaGVtYSAhPSBcImJvb2xlYW5cIlxufVxuXG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0OiBTY2hlbWFPYmpDeHQsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIGdlbiwgb3B0c30gPSBpdFxuICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpIGNvbW1lbnRLZXl3b3JkKGl0KVxuICB1cGRhdGVDb250ZXh0KGl0KVxuICBjaGVja0FzeW5jU2NoZW1hKGl0KVxuICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBOLmVycm9ycylcbiAgdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpXG4gIC8vIFRPRE8gdmFyXG4gIGdlbi52YXIodmFsaWQsIF9gJHtlcnJzQ291bnR9ID09PSAke04uZXJyb3JzfWApXG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjaGVja1Vua25vd25SdWxlcyhpdClcbiAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpXG59XG5cbmZ1bmN0aW9uIHR5cGVBbmRLZXl3b3JkcyhpdDogU2NoZW1hT2JqQ3h0LCBlcnJzQ291bnQ/OiBOYW1lKTogdm9pZCB7XG4gIGlmIChpdC5vcHRzLmp0ZCkgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudClcbiAgY29uc3QgdHlwZXMgPSBnZXRTY2hlbWFUeXBlcyhpdC5zY2hlbWEpXG4gIGNvbnN0IGNoZWNrZWRUeXBlcyA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQsIHR5cGVzKVxuICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudClcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmfSA9IGl0XG4gIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgc2VsZi5sb2dnZXIud2FybihgJHJlZjoga2V5d29yZHMgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImApXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBvcHRzfSA9IGl0XG4gIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudXNlRGVmYXVsdHMgJiYgb3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBjaGVja1N0cmljdE1vZGUoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXVxuICBpZiAoc2NoSWQpIGl0LmJhc2VJZCA9IHJlc29sdmVVcmwoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZClcbn1cblxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIilcbn1cblxuZnVuY3Rpb24gY29tbWVudEtleXdvcmQoe2dlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHN9OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50XG4gIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgZ2VuLmNvZGUoX2Ake04uc2VsZn0ubG9nZ2VyLmxvZygke21zZ30pYClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gc3RyYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgXG4gICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwge3JlZjogc2NoZW1hRW52LnJvb3R9KVxuICAgIGdlbi5jb2RlKF9gJHtOLnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYClcbiAgfVxufVxuXG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hRW52LCB2YWxpZGF0ZU5hbWUsIFZhbGlkYXRpb25FcnJvciwgb3B0c30gPSBpdFxuICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgZ2VuLmlmKFxuICAgICAgX2Ake04uZXJyb3JzfSA9PT0gMGAsXG4gICAgICAoKSA9PiBnZW4ucmV0dXJuKE4uZGF0YSksXG4gICAgICAoKSA9PiBnZW4udGhyb3coX2BuZXcgJHtWYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0oJHtOLnZFcnJvcnN9KWApXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgTi52RXJyb3JzKVxuICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKSBhc3NpZ25FdmFsdWF0ZWQoaXQpXG4gICAgZ2VuLnJldHVybihfYCR7Ti5lcnJvcnN9ID09PSAwYClcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoe2dlbiwgZXZhbHVhdGVkLCBwcm9wcywgaXRlbXN9OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgaWYgKHByb3BzIGluc3RhbmNlb2YgTmFtZSkgZ2VuLmFzc2lnbihfYCR7ZXZhbHVhdGVkfS5wcm9wc2AsIHByb3BzKVxuICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBOYW1lKSBnZW4uYXNzaWduKF9gJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpXG59XG5cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKFxuICBpdDogU2NoZW1hT2JqQ3h0LFxuICB0eXBlczogSlNPTlR5cGVbXSxcbiAgdHlwZUVycm9yczogYm9vbGVhbixcbiAgZXJyc0NvdW50PzogTmFtZVxuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmfSA9IGl0XG4gIGNvbnN0IHtSVUxFU30gPSBzZWxmXG4gIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgIXNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIChSVUxFUy5hbGwuJHJlZiBhcyBSdWxlKS5kZWZpbml0aW9uKSkgLy8gVE9ETyB0eXBlY2FzdFxuICAgIHJldHVyblxuICB9XG4gIGlmICghb3B0cy5qdGQpIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKVxuICBnZW4uYmxvY2soKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIGdyb3VwS2V5d29yZHMoZ3JvdXApXG4gICAgZ3JvdXBLZXl3b3JkcyhSVUxFUy5wb3N0KVxuICB9KVxuXG4gIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXA6IFJ1bGVHcm91cCk6IHZvaWQge1xuICAgIGlmICghc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkpIHJldHVyblxuICAgIGlmIChncm91cC50eXBlKSB7XG4gICAgICBnZW4uaWYoY2hlY2tEYXRhVHlwZShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKVxuICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cClcbiAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IGdyb3VwLnR5cGUgJiYgdHlwZUVycm9ycykge1xuICAgICAgICBnZW4uZWxzZSgpXG4gICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdClcbiAgICAgIH1cbiAgICAgIGdlbi5lbmRJZigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApXG4gICAgfVxuICAgIC8vIFRPRE8gbWFrZSBpdCBcIm9rXCIgY2FsbD9cbiAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmlmKF9gJHtOLmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YClcbiAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCwgZ3JvdXA6IFJ1bGVHcm91cCk6IHZvaWQge1xuICBjb25zdCB7XG4gICAgZ2VuLFxuICAgIHNjaGVtYSxcbiAgICBvcHRzOiB7dXNlRGVmYXVsdHN9LFxuICB9ID0gaXRcbiAgaWYgKHVzZURlZmF1bHRzKSBhc3NpZ25EZWZhdWx0cyhpdCwgZ3JvdXAudHlwZSlcbiAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgIGlmIChzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpIHJldHVyblxuICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpXG4gIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpXG4gIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHR5cGVzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGlmICghdHlwZXMubGVuZ3RoKSByZXR1cm5cbiAgaWYgKCFpdC5kYXRhVHlwZXMubGVuZ3RoKSB7XG4gICAgaXQuZGF0YVR5cGVzID0gdHlwZXNcbiAgICByZXR1cm5cbiAgfVxuICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgaWYgKCFpbmNsdWRlc1R5cGUoaXQuZGF0YVR5cGVzLCB0KSkge1xuICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYHR5cGUgXCIke3R9XCIgbm90IGFsbG93ZWQgYnkgY29udGV4dCBcIiR7aXQuZGF0YVR5cGVzLmpvaW4oXCIsXCIpfVwiYClcbiAgICB9XG4gIH0pXG4gIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB0eXBlcylcbn1cblxuZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHRzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGlmICh0cy5sZW5ndGggPiAxICYmICEodHMubGVuZ3RoID09PSAyICYmIHRzLmluY2x1ZGVzKFwibnVsbFwiKSkpIHtcbiAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbFxuICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICBjb25zdCBydWxlID0gcnVsZXNba2V5d29yZF1cbiAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiBzaG91bGRVc2VSdWxlKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgIGNvbnN0IHt0eXBlfSA9IHJ1bGUuZGVmaW5pdGlvblxuICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0FwcGxpY2FibGVUeXBlKHNjaFRzOiBKU09OVHlwZVtdLCBrd2RUOiBKU09OVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKVxufVxuXG5mdW5jdGlvbiBpbmNsdWRlc1R5cGUodHM6IEpTT05UeXBlW10sIHQ6IEpTT05UeXBlKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpXG59XG5cbmZ1bmN0aW9uIG5hcnJvd1NjaGVtYVR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHdpdGhUeXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBjb25zdCB0czogSlNPTlR5cGVbXSA9IFtdXG4gIGZvciAoY29uc3QgdCBvZiBpdC5kYXRhVHlwZXMpIHtcbiAgICBpZiAoaW5jbHVkZXNUeXBlKHdpdGhUeXBlcywgdCkpIHRzLnB1c2godClcbiAgICBlbHNlIGlmICh3aXRoVHlwZXMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpICYmIHQgPT09IFwibnVtYmVyXCIpIHRzLnB1c2goXCJpbnRlZ2VyXCIpXG4gIH1cbiAgaXQuZGF0YVR5cGVzID0gdHNcbn1cblxuZnVuY3Rpb24gc3RyaWN0VHlwZXNFcnJvcihpdDogU2NoZW1hT2JqQ3h0LCBtc2c6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGhcbiAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWBcbiAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpXG59XG5cbmV4cG9ydCBjbGFzcyBLZXl3b3JkQ3h0IGltcGxlbWVudHMgS2V5d29yZEVycm9yQ3h0IHtcbiAgcmVhZG9ubHkgZ2VuOiBDb2RlR2VuXG4gIHJlYWRvbmx5IGFsbEVycm9ycz86IGJvb2xlYW5cbiAgcmVhZG9ubHkga2V5d29yZDogc3RyaW5nXG4gIHJlYWRvbmx5IGRhdGE6IE5hbWUgLy8gTmFtZSByZWZlcmVuY2luZyB0aGUgY3VycmVudCBsZXZlbCBvZiB0aGUgZGF0YSBpbnN0YW5jZVxuICByZWFkb25seSAkZGF0YT86IHN0cmluZyB8IGZhbHNlXG4gIHNjaGVtYTogYW55IC8vIGtleXdvcmQgdmFsdWUgaW4gdGhlIHNjaGVtYVxuICByZWFkb25seSBzY2hlbWFWYWx1ZTogQ29kZSB8IG51bWJlciB8IGJvb2xlYW4gLy8gQ29kZSByZWZlcmVuY2UgdG8ga2V5d29yZCBzY2hlbWEgdmFsdWUgb3IgcHJpbWl0aXZlIHZhbHVlXG4gIHJlYWRvbmx5IHNjaGVtYUNvZGU6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIC8vIENvZGUgcmVmZXJlbmNlIHRvIHJlc29sdmVkIHNjaGVtYSB2YWx1ZSAoZGlmZmVyZW50IGlmIHNjaGVtYSBpcyAkZGF0YSlcbiAgcmVhZG9ubHkgc2NoZW1hVHlwZTogSlNPTlR5cGVbXSAvLyBhbGxvd2VkIHR5cGUocykgb2Yga2V5d29yZCB2YWx1ZSBpbiB0aGUgc2NoZW1hXG4gIHJlYWRvbmx5IHBhcmVudFNjaGVtYTogQW55U2NoZW1hT2JqZWN0XG4gIHJlYWRvbmx5IGVycnNDb3VudD86IE5hbWUgLy8gTmFtZSByZWZlcmVuY2UgdG8gdGhlIG51bWJlciBvZiB2YWxpZGF0aW9uIGVycm9ycyBjb2xsZWN0ZWQgYmVmb3JlIHRoaXMga2V5d29yZCxcbiAgLy8gcmVxdWlyZXMgb3B0aW9uIHRyYWNrRXJyb3JzIGluIGtleXdvcmQgZGVmaW5pdGlvblxuICBwYXJhbXM6IEtleXdvcmRDeHRQYXJhbXMgLy8gb2JqZWN0IHRvIHBhc3MgcGFyYW1ldGVycyB0byBlcnJvciBtZXNzYWdlcyBmcm9tIGtleXdvcmQgY29kZVxuICByZWFkb25seSBpdDogU2NoZW1hT2JqQ3h0IC8vIHNjaGVtYSBjb21waWxhdGlvbiBjb250ZXh0IChzY2hlbWEgaXMgZ3VhcmFudGVlZCB0byBiZSBhbiBvYmplY3QsIG5vdCBib29sZWFuKVxuICByZWFkb25seSBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb25cblxuICBjb25zdHJ1Y3RvcihpdDogU2NoZW1hT2JqQ3h0LCBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb24sIGtleXdvcmQ6IHN0cmluZykge1xuICAgIHZhbGlkYXRlS2V5d29yZFVzYWdlKGl0LCBkZWYsIGtleXdvcmQpXG4gICAgdGhpcy5nZW4gPSBpdC5nZW5cbiAgICB0aGlzLmFsbEVycm9ycyA9IGl0LmFsbEVycm9yc1xuICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmRcbiAgICB0aGlzLmRhdGEgPSBpdC5kYXRhXG4gICAgdGhpcy5zY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGFcbiAgICB0aGlzLnNjaGVtYVZhbHVlID0gc2NoZW1hUmVmT3JWYWwoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKVxuICAgIHRoaXMuc2NoZW1hVHlwZSA9IGRlZi5zY2hlbWFUeXBlXG4gICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWFcbiAgICB0aGlzLnBhcmFtcyA9IHt9XG4gICAgdGhpcy5pdCA9IGl0XG4gICAgdGhpcy5kZWYgPSBkZWZcblxuICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlXG4gICAgICBpZiAoIXZhbGlkU2NoZW1hVHlwZSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgTi5lcnJvcnMpXG4gICAgfVxuICB9XG5cbiAgcmVzdWx0KGNvbmRpdGlvbjogQ29kZSwgc3VjY2Vzc0FjdGlvbj86ICgpID0+IHZvaWQsIGZhaWxBY3Rpb24/OiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5mYWlsUmVzdWx0KG5vdChjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKVxuICB9XG5cbiAgZmFpbFJlc3VsdChjb25kaXRpb246IENvZGUsIHN1Y2Nlc3NBY3Rpb24/OiAoKSA9PiB2b2lkLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbilcbiAgICBpZiAoZmFpbEFjdGlvbikgZmFpbEFjdGlvbigpXG4gICAgZWxzZSB0aGlzLmVycm9yKClcbiAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgdGhpcy5nZW4uZWxzZSgpXG4gICAgICBzdWNjZXNzQWN0aW9uKClcbiAgICAgIGlmICh0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uZW5kSWYoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmVuZElmKClcbiAgICAgIGVsc2UgdGhpcy5nZW4uZWxzZSgpXG4gICAgfVxuICB9XG5cbiAgcGFzcyhjb25kaXRpb246IENvZGUsIGZhaWxBY3Rpb24/OiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5mYWlsUmVzdWx0KG5vdChjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pXG4gIH1cblxuICBmYWlsKGNvbmRpdGlvbj86IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZXJyb3IoKVxuICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uaWYoZmFsc2UpIC8vIHRoaXMgYnJhbmNoIHdpbGwgYmUgcmVtb3ZlZCBieSBnZW4ub3B0aW1pemVcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pXG4gICAgdGhpcy5lcnJvcigpXG4gICAgaWYgKHRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5lbmRJZigpXG4gICAgZWxzZSB0aGlzLmdlbi5lbHNlKClcbiAgfVxuXG4gIGZhaWwkZGF0YShjb25kaXRpb246IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuJGRhdGEpIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKVxuICAgIGNvbnN0IHtzY2hlbWFDb2RlfSA9IHRoaXNcbiAgICB0aGlzLmZhaWwoX2Ake3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7b3IodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYClcbiAgfVxuXG4gIGVycm9yKGFwcGVuZD86IGJvb2xlYW4sIGVycm9yUGFyYW1zPzogS2V5d29yZEN4dFBhcmFtcywgZXJyb3JQYXRocz86IEVycm9yUGF0aHMpOiB2b2lkIHtcbiAgICBpZiAoZXJyb3JQYXJhbXMpIHtcbiAgICAgIHRoaXMuc2V0UGFyYW1zKGVycm9yUGFyYW1zKVxuICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKVxuICAgICAgdGhpcy5zZXRQYXJhbXMoe30pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKVxuICB9XG5cbiAgcHJpdmF0ZSBfZXJyb3IoYXBwZW5kPzogYm9vbGVhbiwgZXJyb3JQYXRocz86IEVycm9yUGF0aHMpOiB2b2lkIHtcbiAgICA7KGFwcGVuZCA/IHJlcG9ydEV4dHJhRXJyb3IgOiByZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpXG4gIH1cblxuICAkZGF0YUVycm9yKCk6IHZvaWQge1xuICAgIHJlcG9ydEVycm9yKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwga2V5d29yZCREYXRhRXJyb3IpXG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdhZGQgXCJ0cmFja0Vycm9yc1wiIHRvIGtleXdvcmQgZGVmaW5pdGlvbicpXG4gICAgcmVzZXRFcnJvcnNDb3VudCh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpXG4gIH1cblxuICBvayhjb25kOiBDb2RlIHwgYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmlmKGNvbmQpXG4gIH1cblxuICBzZXRQYXJhbXMob2JqOiBLZXl3b3JkQ3h0UGFyYW1zLCBhc3NpZ24/OiB0cnVlKTogdm9pZCB7XG4gICAgaWYgKGFzc2lnbikgT2JqZWN0LmFzc2lnbih0aGlzLnBhcmFtcywgb2JqKVxuICAgIGVsc2UgdGhpcy5wYXJhbXMgPSBvYmpcbiAgfVxuXG4gIGJsb2NrJGRhdGEodmFsaWQ6IE5hbWUsIGNvZGVCbG9jazogKCkgPT4gdm9pZCwgJGRhdGFWYWxpZDogQ29kZSA9IG5pbCk6IHZvaWQge1xuICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZClcbiAgICAgIGNvZGVCbG9jaygpXG4gICAgfSlcbiAgfVxuXG4gIGNoZWNrJGRhdGEodmFsaWQ6IE5hbWUgPSBuaWwsICRkYXRhVmFsaWQ6IENvZGUgPSBuaWwpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuJGRhdGEpIHJldHVyblxuICAgIGNvbnN0IHtnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZn0gPSB0aGlzXG4gICAgZ2VuLmlmKG9yKF9gJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpXG4gICAgaWYgKHZhbGlkICE9PSBuaWwpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKVxuICAgICAgdGhpcy4kZGF0YUVycm9yKClcbiAgICAgIGlmICh2YWxpZCAhPT0gbmlsKSBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICB9XG4gICAgZ2VuLmVsc2UoKVxuICB9XG5cbiAgaW52YWxpZCRkYXRhKCk6IENvZGUge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXR9ID0gdGhpc1xuICAgIHJldHVybiBvcih3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSlcblxuICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCk6IENvZGUge1xuICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIShzY2hlbWFDb2RlIGluc3RhbmNlb2YgTmFtZSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdXG4gICAgICAgIHJldHVybiBfYCR7Y2hlY2tEYXRhVHlwZXMoc3QsIHNjaGVtYUNvZGUsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpfWBcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKTogQ29kZSB7XG4gICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHtyZWY6IGRlZi52YWxpZGF0ZVNjaGVtYX0pIC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICByZXR1cm4gX2AhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgXG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsXG4gICAgfVxuICB9XG5cbiAgc3Vic2NoZW1hKGFwcGw6IFN1YnNjaGVtYUFyZ3MsIHZhbGlkOiBOYW1lKTogU2NoZW1hQ3h0IHtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWEodGhpcy5pdCwgYXBwbClcbiAgICBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgdGhpcy5pdCwgYXBwbClcbiAgICBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgYXBwbClcbiAgICBjb25zdCBuZXh0Q29udGV4dCA9IHsuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWR9XG4gICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpXG4gICAgcmV0dXJuIG5leHRDb250ZXh0XG4gIH1cblxuICBtZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQ6IFNjaGVtYUN4dCwgdG9OYW1lPzogdHlwZW9mIE5hbWUpOiB2b2lkIHtcbiAgICBjb25zdCB7aXQsIGdlbn0gPSB0aGlzXG4gICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKSByZXR1cm5cbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpXG4gICAgfVxuICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaGVtYUN4dC5pdGVtcywgaXQuaXRlbXMsIHRvTmFtZSlcbiAgICB9XG4gIH1cblxuICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dDogU2NoZW1hQ3h0LCB2YWxpZDogTmFtZSk6IGJvb2xlYW4gfCB2b2lkIHtcbiAgICBjb25zdCB7aXQsIGdlbn0gPSB0aGlzXG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgKGl0LnByb3BzICE9PSB0cnVlIHx8IGl0Lml0ZW1zICE9PSB0cnVlKSkge1xuICAgICAgZ2VuLmlmKHZhbGlkLCAoKSA9PiB0aGlzLm1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgTmFtZSkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBrZXl3b3JkQ29kZShcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAga2V5d29yZDogc3RyaW5nLFxuICBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIHJ1bGVUeXBlPzogSlNPTlR5cGVcbik6IHZvaWQge1xuICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKVxuICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSlcbiAgfSBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKVxuICB9IGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICBtYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKVxuICB9IGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfVxufVxuXG5jb25zdCBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvXG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGEoXG4gICRkYXRhOiBzdHJpbmcsXG4gIHtkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnJ9OiBTY2hlbWFDeHRcbik6IENvZGUgfCBudW1iZXIge1xuICBsZXQganNvblBvaW50ZXJcbiAgbGV0IGRhdGE6IENvZGVcbiAgaWYgKCRkYXRhID09PSBcIlwiKSByZXR1cm4gTi5yb290RGF0YVxuICBpZiAoJGRhdGFbMF0gPT09IFwiL1wiKSB7XG4gICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YClcbiAgICBqc29uUG9pbnRlciA9ICRkYXRhXG4gICAgZGF0YSA9IE4ucm9vdERhdGFcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpXG4gICAgaWYgKCFtYXRjaGVzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApXG4gICAgY29uc3QgdXA6IG51bWJlciA9ICttYXRjaGVzWzFdXG4gICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdXG4gICAgaWYgKGpzb25Qb2ludGVyID09PSBcIiNcIikge1xuICAgICAgaWYgKHVwID49IGRhdGFMZXZlbCkgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKVxuICAgICAgcmV0dXJuIGRhdGFQYXRoQXJyW2RhdGFMZXZlbCAtIHVwXVxuICAgIH1cbiAgICBpZiAodXAgPiBkYXRhTGV2ZWwpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKVxuICAgIGRhdGEgPSBkYXRhTmFtZXNbZGF0YUxldmVsIC0gdXBdXG4gICAgaWYgKCFqc29uUG9pbnRlcikgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGxldCBleHByID0gZGF0YVxuICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKVxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgZGF0YSA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkodW5lc2NhcGVKc29uUG9pbnRlcihzZWdtZW50KSl9YFxuICAgICAgZXhwciA9IF9gJHtleHByfSAmJiAke2RhdGF9YFxuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwclxuXG4gIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlOiBzdHJpbmcsIHVwOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgQ2Fubm90IGFjY2VzcyAke3BvaW50ZXJUeXBlfSAke3VwfSBsZXZlbHMgdXAsIGN1cnJlbnQgbGV2ZWwgaXMgJHtkYXRhTGV2ZWx9YFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yT2JqZWN0fSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IGVycm9yczogUGFydGlhbDxFcnJvck9iamVjdD5bXVxuICByZWFkb25seSBhanY6IHRydWVcbiAgcmVhZG9ubHkgdmFsaWRhdGlvbjogdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKGVycm9yczogUGFydGlhbDxFcnJvck9iamVjdD5bXSkge1xuICAgIHN1cGVyKFwidmFsaWRhdGlvbiBmYWlsZWRcIilcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yc1xuICAgIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZVxuICB9XG59XG4iLCAiaW1wb3J0IHtyZXNvbHZlVXJsLCBub3JtYWxpemVJZCwgZ2V0RnVsbFBhdGh9IGZyb20gXCIuL3Jlc29sdmVcIlxuaW1wb3J0IHR5cGUge1VyaVJlc29sdmVyfSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaXNzaW5nUmVmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IG1pc3NpbmdSZWY6IHN0cmluZ1xuICByZWFkb25seSBtaXNzaW5nU2NoZW1hOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIGJhc2VJZDogc3RyaW5nLCByZWY6IHN0cmluZywgbXNnPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobXNnIHx8IGBjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSAke3JlZn0gZnJvbSBpZCAke2Jhc2VJZH1gKVxuICAgIHRoaXMubWlzc2luZ1JlZiA9IHJlc29sdmVVcmwocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKVxuICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9IG5vcm1hbGl6ZUlkKGdldEZ1bGxQYXRoKHJlc29sdmVyLCB0aGlzLm1pc3NpbmdSZWYpKVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBBbnlTY2hlbWEsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uLFxuICBFdmFsdWF0ZWRQcm9wZXJ0aWVzLFxuICBFdmFsdWF0ZWRJdGVtcyxcbn0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIEFqdiBmcm9tIFwiLi4vY29yZVwiXG5pbXBvcnQgdHlwZSB7SW5zdGFuY2VPcHRpb25zfSBmcm9tIFwiLi4vY29yZVwiXG5pbXBvcnQge0NvZGVHZW4sIF8sIG5pbCwgc3RyaW5naWZ5LCBOYW1lLCBDb2RlLCBWYWx1ZVNjb3BlTmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5pbXBvcnQgVmFsaWRhdGlvbkVycm9yIGZyb20gXCIuLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIlxuaW1wb3J0IE4gZnJvbSBcIi4vbmFtZXNcIlxuaW1wb3J0IHtMb2NhbFJlZnMsIGdldEZ1bGxQYXRoLCBfZ2V0RnVsbFBhdGgsIGlubGluZVJlZiwgbm9ybWFsaXplSWQsIHJlc29sdmVVcmx9IGZyb20gXCIuL3Jlc29sdmVcIlxuaW1wb3J0IHtzY2hlbWFIYXNSdWxlc0J1dFJlZiwgdW5lc2NhcGVGcmFnbWVudH0gZnJvbSBcIi4vdXRpbFwiXG5pbXBvcnQge3ZhbGlkYXRlRnVuY3Rpb25Db2RlfSBmcm9tIFwiLi92YWxpZGF0ZVwiXG5pbXBvcnQge1VSSUNvbXBvbmVudH0gZnJvbSBcImZhc3QtdXJpXCJcbmltcG9ydCB7SlNPTlR5cGV9IGZyb20gXCIuL3J1bGVzXCJcblxuZXhwb3J0IHR5cGUgU2NoZW1hUmVmcyA9IHtcbiAgW1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgQW55U2NoZW1hXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hQ3h0IHtcbiAgcmVhZG9ubHkgZ2VuOiBDb2RlR2VuXG4gIHJlYWRvbmx5IGFsbEVycm9ycz86IGJvb2xlYW4gLy8gdmFsaWRhdGlvbiBtb2RlIC0gd2hldGhlciB0byBjb2xsZWN0IGFsbCBlcnJvcnMgb3IgYnJlYWsgb24gZXJyb3JcbiAgcmVhZG9ubHkgZGF0YTogTmFtZSAvLyBOYW1lIHdpdGggcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHBhcnQgb2YgZGF0YSBpbnN0YW5jZVxuICByZWFkb25seSBwYXJlbnREYXRhOiBOYW1lIC8vIHNob3VsZCBiZSB1c2VkIGluIGtleXdvcmRzIG1vZGlmeWluZyBkYXRhXG4gIHJlYWRvbmx5IHBhcmVudERhdGFQcm9wZXJ0eTogQ29kZSB8IG51bWJlciAvLyBzaG91bGQgYmUgdXNlZCBpbiBrZXl3b3JkcyBtb2RpZnlpbmcgZGF0YVxuICByZWFkb25seSBkYXRhTmFtZXM6IE5hbWVbXVxuICByZWFkb25seSBkYXRhUGF0aEFycjogKENvZGUgfCBudW1iZXIpW11cbiAgcmVhZG9ubHkgZGF0YUxldmVsOiBudW1iZXIgLy8gdGhlIGxldmVsIG9mIHRoZSBjdXJyZW50bHkgdmFsaWRhdGVkIGRhdGEsXG4gIC8vIGl0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyBib3RoIHRoZSBwcm9wZXJ0eSBuYW1lcyBhbmQgdGhlIGRhdGEgb24gYWxsIGxldmVscyBmcm9tIHRoZSB0b3AuXG4gIGRhdGFUeXBlczogSlNPTlR5cGVbXSAvLyBkYXRhIHR5cGVzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgcGFydCBvZiBkYXRhIGluc3RhbmNlXG4gIGRlZmluZWRQcm9wZXJ0aWVzOiBTZXQ8c3RyaW5nPiAvLyBzZXQgb2YgcHJvcGVydGllcyB0byBrZWVwIHRyYWNrIG9mIGZvciByZXF1aXJlZCBjaGVja3NcbiAgcmVhZG9ubHkgdG9wU2NoZW1hUmVmOiBDb2RlXG4gIHJlYWRvbmx5IHZhbGlkYXRlTmFtZTogTmFtZVxuICBldmFsdWF0ZWQ/OiBOYW1lXG4gIHJlYWRvbmx5IFZhbGlkYXRpb25FcnJvcj86IE5hbWVcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWEgLy8gY3VycmVudCBzY2hlbWEgb2JqZWN0IC0gZXF1YWwgdG8gcGFyZW50U2NoZW1hIHBhc3NlZCB2aWEgS2V5d29yZEN4dFxuICByZWFkb25seSBzY2hlbWFFbnY6IFNjaGVtYUVudlxuICByZWFkb25seSByb290SWQ6IHN0cmluZ1xuICBiYXNlSWQ6IHN0cmluZyAvLyB0aGUgY3VycmVudCBzY2hlbWEgYmFzZSBVUkkgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3IgcmVzb2x2aW5nIFVSSXMgaW4gcmVmZXJlbmNlcyAoXFwkcmVmKVxuICByZWFkb25seSBzY2hlbWFQYXRoOiBDb2RlIC8vIHRoZSBydW4tdGltZSBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBjdXJyZW50IHNjaGVtYVxuICByZWFkb25seSBlcnJTY2hlbWFQYXRoOiBzdHJpbmcgLy8gdGhpcyBpcyBhY3R1YWwgc3RyaW5nLCBzaG91bGQgbm90IGJlIGNoYW5nZWQgdG8gQ29kZVxuICByZWFkb25seSBlcnJvclBhdGg6IENvZGVcbiAgcmVhZG9ubHkgcHJvcGVydHlOYW1lPzogTmFtZVxuICByZWFkb25seSBjb21wb3NpdGVSdWxlPzogYm9vbGVhbiAvLyB0cnVlIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IHNjaGVtYSBpcyBpbnNpZGUgdGhlIGNvbXBvdW5kIGtleXdvcmQsXG4gIC8vIHdoZXJlIGZhaWxpbmcgc29tZSBydWxlIGRvZXNuJ3QgbWVhbiB2YWxpZGF0aW9uIGZhaWx1cmUgKGBhbnlPZmAsIGBvbmVPZmAsIGBub3RgLCBgaWZgKS5cbiAgLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgeW91IGNhbiByZXR1cm4gdmFsaWRhdGlvbiByZXN1bHQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IGVycm9yIGluIGNhc2UgdGhlIG9wdGlvbiBgYWxsRXJyb3JzYCBpcyBub3QgYHRydWUuXG4gIC8vIFlvdSBvbmx5IG5lZWQgdG8gdXNlIGl0IGlmIHlvdSBoYXZlIG1hbnkgc3RlcHMgaW4geW91ciBrZXl3b3JkcyBhbmQgcG90ZW50aWFsbHkgY2FuIGRlZmluZSBtdWx0aXBsZSBlcnJvcnMuXG4gIHByb3BzPzogRXZhbHVhdGVkUHJvcGVydGllcyB8IE5hbWUgLy8gcHJvcGVydGllcyBldmFsdWF0ZWQgYnkgdGhpcyBzY2hlbWEgLSB1c2VkIGJ5IHBhcmVudCBzY2hlbWEgb3IgYXNzaWduZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICBpdGVtcz86IEV2YWx1YXRlZEl0ZW1zIHwgTmFtZSAvLyBsYXN0IGl0ZW0gZXZhbHVhdGVkIGJ5IHRoaXMgc2NoZW1hIC0gdXNlZCBieSBwYXJlbnQgc2NoZW1hIG9yIGFzc2lnbmVkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAganRkRGlzY3JpbWluYXRvcj86IHN0cmluZ1xuICBqdGRNZXRhZGF0YT86IGJvb2xlYW5cbiAgcmVhZG9ubHkgY3JlYXRlRXJyb3JzPzogYm9vbGVhblxuICByZWFkb25seSBvcHRzOiBJbnN0YW5jZU9wdGlvbnMgLy8gQWp2IGluc3RhbmNlIG9wdGlvbi5cbiAgcmVhZG9ubHkgc2VsZjogQWp2IC8vIGN1cnJlbnQgQWp2IGluc3RhbmNlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hT2JqQ3h0IGV4dGVuZHMgU2NoZW1hQ3h0IHtcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3Rcbn1cbmludGVyZmFjZSBTY2hlbWFFbnZBcmdzIHtcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hSWQ/OiBcIiRpZFwiIHwgXCJpZFwiXG4gIHJlYWRvbmx5IHJvb3Q/OiBTY2hlbWFFbnZcbiAgcmVhZG9ubHkgYmFzZUlkPzogc3RyaW5nXG4gIHJlYWRvbmx5IHNjaGVtYVBhdGg/OiBzdHJpbmdcbiAgcmVhZG9ubHkgbG9jYWxSZWZzPzogTG9jYWxSZWZzXG4gIHJlYWRvbmx5IG1ldGE/OiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBTY2hlbWFFbnYgaW1wbGVtZW50cyBTY2hlbWFFbnZBcmdzIHtcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hSWQ/OiBcIiRpZFwiIHwgXCJpZFwiXG4gIHJlYWRvbmx5IHJvb3Q6IFNjaGVtYUVudlxuICBiYXNlSWQ6IHN0cmluZyAvLyBUT0RPIHBvc3NpYmx5LCBpdCBzaG91bGQgYmUgcmVhZG9ubHlcbiAgc2NoZW1hUGF0aD86IHN0cmluZ1xuICBsb2NhbFJlZnM/OiBMb2NhbFJlZnNcbiAgcmVhZG9ubHkgbWV0YT86IGJvb2xlYW5cbiAgcmVhZG9ubHkgJGFzeW5jPzogYm9vbGVhbiAvLyB0cnVlIGlmIHRoZSBjdXJyZW50IHNjaGVtYSBpcyBhc3luY2hyb25vdXMuXG4gIHJlYWRvbmx5IHJlZnM6IFNjaGVtYVJlZnMgPSB7fVxuICByZWFkb25seSBkeW5hbWljQW5jaG9yczoge1tSZWYgaW4gc3RyaW5nXT86IHRydWV9ID0ge31cbiAgdmFsaWRhdGU/OiBBbnlWYWxpZGF0ZUZ1bmN0aW9uXG4gIHZhbGlkYXRlTmFtZT86IFZhbHVlU2NvcGVOYW1lXG4gIHNlcmlhbGl6ZT86IChkYXRhOiB1bmtub3duKSA9PiBzdHJpbmdcbiAgc2VyaWFsaXplTmFtZT86IFZhbHVlU2NvcGVOYW1lXG4gIHBhcnNlPzogKGRhdGE6IHN0cmluZykgPT4gdW5rbm93blxuICBwYXJzZU5hbWU/OiBWYWx1ZVNjb3BlTmFtZVxuXG4gIGNvbnN0cnVjdG9yKGVudjogU2NoZW1hRW52QXJncykge1xuICAgIGxldCBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2YgZW52LnNjaGVtYSA9PSBcIm9iamVjdFwiKSBzY2hlbWEgPSBlbnYuc2NoZW1hXG4gICAgdGhpcy5zY2hlbWEgPSBlbnYuc2NoZW1hXG4gICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZFxuICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXNcbiAgICB0aGlzLmJhc2VJZCA9IGVudi5iYXNlSWQgPz8gbm9ybWFsaXplSWQoc2NoZW1hPy5bZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKVxuICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoXG4gICAgdGhpcy5sb2NhbFJlZnMgPSBlbnYubG9jYWxSZWZzXG4gICAgdGhpcy5tZXRhID0gZW52Lm1ldGFcbiAgICB0aGlzLiRhc3luYyA9IHNjaGVtYT8uJGFzeW5jXG4gICAgdGhpcy5yZWZzID0ge31cbiAgfVxufVxuXG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuXG4vLyBDb21waWxlcyBzY2hlbWEgaW4gU2NoZW1hRW52XG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVNjaGVtYSh0aGlzOiBBanYsIHNjaDogU2NoZW1hRW52KTogU2NoZW1hRW52IHtcbiAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgY29uc3QgX3NjaCA9IGdldENvbXBpbGluZ1NjaGVtYS5jYWxsKHRoaXMsIHNjaClcbiAgaWYgKF9zY2gpIHJldHVybiBfc2NoXG4gIGNvbnN0IHJvb3RJZCA9IGdldEZ1bGxQYXRoKHRoaXMub3B0cy51cmlSZXNvbHZlciwgc2NoLnJvb3QuYmFzZUlkKSAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICBjb25zdCB7ZXM1LCBsaW5lc30gPSB0aGlzLm9wdHMuY29kZVxuICBjb25zdCB7b3duUHJvcGVydGllc30gPSB0aGlzLm9wdHNcbiAgY29uc3QgZ2VuID0gbmV3IENvZGVHZW4odGhpcy5zY29wZSwge2VzNSwgbGluZXMsIG93blByb3BlcnRpZXN9KVxuICBsZXQgX1ZhbGlkYXRpb25FcnJvclxuICBpZiAoc2NoLiRhc3luYykge1xuICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgIHJlZjogVmFsaWRhdGlvbkVycm9yLFxuICAgICAgY29kZTogX2ByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZU5hbWUgPSBnZW4uc2NvcGVOYW1lKFwidmFsaWRhdGVcIilcbiAgc2NoLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZVxuXG4gIGNvbnN0IHNjaGVtYUN4dDogU2NoZW1hQ3h0ID0ge1xuICAgIGdlbixcbiAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgZGF0YTogTi5kYXRhLFxuICAgIHBhcmVudERhdGE6IE4ucGFyZW50RGF0YSxcbiAgICBwYXJlbnREYXRhUHJvcGVydHk6IE4ucGFyZW50RGF0YVByb3BlcnR5LFxuICAgIGRhdGFOYW1lczogW04uZGF0YV0sXG4gICAgZGF0YVBhdGhBcnI6IFtuaWxdLCAvLyBUT0RPIGNhbiBpdHMgbGVuZ3RoIGJlIHVzZWQgYXMgZGF0YUxldmVsIGlmIG5pbCBpcyByZW1vdmVkP1xuICAgIGRhdGFMZXZlbDogMCxcbiAgICBkYXRhVHlwZXM6IFtdLFxuICAgIGRlZmluZWRQcm9wZXJ0aWVzOiBuZXcgU2V0PHN0cmluZz4oKSxcbiAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFxuICAgICAgXCJzY2hlbWFcIixcbiAgICAgIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICA/IHtyZWY6IHNjaC5zY2hlbWEsIGNvZGU6IHN0cmluZ2lmeShzY2guc2NoZW1hKX1cbiAgICAgICAgOiB7cmVmOiBzY2guc2NoZW1hfVxuICAgICksXG4gICAgdmFsaWRhdGVOYW1lLFxuICAgIFZhbGlkYXRpb25FcnJvcjogX1ZhbGlkYXRpb25FcnJvcixcbiAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgc2NoZW1hRW52OiBzY2gsXG4gICAgcm9vdElkLFxuICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgc2NoZW1hUGF0aDogbmlsLFxuICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICBlcnJvclBhdGg6IF9gXCJcImAsXG4gICAgb3B0czogdGhpcy5vcHRzLFxuICAgIHNlbGY6IHRoaXMsXG4gIH1cblxuICBsZXQgc291cmNlQ29kZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHRyeSB7XG4gICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpXG4gICAgdmFsaWRhdGVGdW5jdGlvbkNvZGUoc2NoZW1hQ3h0KVxuICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSlcbiAgICAvLyBnZW4ub3B0aW1pemUoMSlcbiAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKVxuICAgIHNvdXJjZUNvZGUgPSBgJHtnZW4uc2NvcGVSZWZzKE4uc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gXG4gICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2Vzcykgc291cmNlQ29kZSA9IHRoaXMub3B0cy5jb2RlLnByb2Nlc3Moc291cmNlQ29kZSwgc2NoKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICBjb25zdCBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oYCR7Ti5zZWxmfWAsIGAke04uc2NvcGV9YCwgc291cmNlQ29kZSlcbiAgICBjb25zdCB2YWxpZGF0ZTogQW55VmFsaWRhdGVGdW5jdGlvbiA9IG1ha2VWYWxpZGF0ZSh0aGlzLCB0aGlzLnNjb3BlLmdldCgpKVxuICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7cmVmOiB2YWxpZGF0ZX0pXG5cbiAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsXG4gICAgdmFsaWRhdGUuc2NoZW1hID0gc2NoLnNjaGVtYVxuICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaFxuICAgIGlmIChzY2guJGFzeW5jKSAodmFsaWRhdGUgYXMgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uKS4kYXN5bmMgPSB0cnVlXG4gICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGUuc291cmNlID0ge3ZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXN9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdHMudW5ldmFsdWF0ZWQpIHtcbiAgICAgIGNvbnN0IHtwcm9wcywgaXRlbXN9ID0gc2NoZW1hQ3h0XG4gICAgICB2YWxpZGF0ZS5ldmFsdWF0ZWQgPSB7XG4gICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIE5hbWUgPyB1bmRlZmluZWQgOiBwcm9wcyxcbiAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgTmFtZSA/IHVuZGVmaW5lZCA6IGl0ZW1zLFxuICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgTmFtZSxcbiAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIE5hbWUsXG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGUuc291cmNlKSB2YWxpZGF0ZS5zb3VyY2UuZXZhbHVhdGVkID0gc3RyaW5naWZ5KHZhbGlkYXRlLmV2YWx1YXRlZClcbiAgICB9XG4gICAgc2NoLnZhbGlkYXRlID0gdmFsaWRhdGVcbiAgICByZXR1cm4gc2NoXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWxldGUgc2NoLnZhbGlkYXRlXG4gICAgZGVsZXRlIHNjaC52YWxpZGF0ZU5hbWVcbiAgICBpZiAoc291cmNlQ29kZSkgdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOlwiLCBzb3VyY2VDb2RlKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSwgdGhpcy5vcHRzKVxuICAgIHRocm93IGVcbiAgfSBmaW5hbGx5IHtcbiAgICB0aGlzLl9jb21waWxhdGlvbnMuZGVsZXRlKHNjaClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVJlZihcbiAgdGhpczogQWp2LFxuICByb290OiBTY2hlbWFFbnYsXG4gIGJhc2VJZDogc3RyaW5nLFxuICByZWY6IHN0cmluZ1xuKTogQW55U2NoZW1hIHwgU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgcmVmID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgcmVmKVxuICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXVxuICBpZiAoc2NoT3JGdW5jKSByZXR1cm4gc2NoT3JGdW5jXG5cbiAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKVxuICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gcm9vdC5sb2NhbFJlZnM/LltyZWZdIC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICBpZiAoc2NoZW1hKSBfc2NoID0gbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkfSlcbiAgfVxuXG4gIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHJldHVyblxuICByZXR1cm4gKHJvb3QucmVmc1tyZWZdID0gaW5saW5lT3JDb21waWxlLmNhbGwodGhpcywgX3NjaCkpXG59XG5cbmZ1bmN0aW9uIGlubGluZU9yQ29tcGlsZSh0aGlzOiBBanYsIHNjaDogU2NoZW1hRW52KTogQW55U2NoZW1hIHwgU2NoZW1hRW52IHtcbiAgaWYgKGlubGluZVJlZihzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpIHJldHVybiBzY2guc2NoZW1hXG4gIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKVxufVxuXG4vLyBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGlsaW5nU2NoZW1hKHRoaXM6IEFqdiwgc2NoRW52OiBTY2hlbWFFbnYpOiBTY2hlbWFFbnYgfCB2b2lkIHtcbiAgZm9yIChjb25zdCBzY2ggb2YgdGhpcy5fY29tcGlsYXRpb25zKSB7XG4gICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKSByZXR1cm4gc2NoXG4gIH1cbn1cblxuZnVuY3Rpb24gc2FtZVNjaGVtYUVudihzMTogU2NoZW1hRW52LCBzMjogU2NoZW1hRW52KTogYm9vbGVhbiB7XG4gIHJldHVybiBzMS5zY2hlbWEgPT09IHMyLnNjaGVtYSAmJiBzMS5yb290ID09PSBzMi5yb290ICYmIHMxLmJhc2VJZCA9PT0gczIuYmFzZUlkXG59XG5cbi8vIHJlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXG4vLyBUT0RPIHJldHVybnMgQW55U2NoZW1hT2JqZWN0IChpZiB0aGUgc2NoZW1hIGNhbiBiZSBpbmxpbmVkKSBvciB2YWxpZGF0aW9uIGZ1bmN0aW9uXG5mdW5jdGlvbiByZXNvbHZlKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudiwgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbiAgcmVmOiBzdHJpbmcgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbik6IFNjaGVtYUVudiB8IHVuZGVmaW5lZCB7XG4gIGxldCBzY2hcbiAgd2hpbGUgKHR5cGVvZiAoc2NoID0gdGhpcy5yZWZzW3JlZl0pID09IFwic3RyaW5nXCIpIHJlZiA9IHNjaFxuICByZXR1cm4gc2NoIHx8IHRoaXMuc2NoZW1hc1tyZWZdIHx8IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCByZWYpXG59XG5cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShcbiAgdGhpczogQWp2LFxuICByb290OiBTY2hlbWFFbnYsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbiAgcmVmOiBzdHJpbmcgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbik6IFNjaGVtYUVudiB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHAgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucGFyc2UocmVmKVxuICBjb25zdCByZWZQYXRoID0gX2dldEZ1bGxQYXRoKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcClcbiAgbGV0IGJhc2VJZCA9IGdldEZ1bGxQYXRoKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcm9vdC5iYXNlSWQsIHVuZGVmaW5lZClcbiAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMCAmJiByZWZQYXRoID09PSBiYXNlSWQpIHtcbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KVxuICB9XG5cbiAgY29uc3QgaWQgPSBub3JtYWxpemVJZChyZWZQYXRoKVxuICBjb25zdCBzY2hPclJlZiA9IHRoaXMucmVmc1tpZF0gfHwgdGhpcy5zY2hlbWFzW2lkXVxuICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpXG4gICAgaWYgKHR5cGVvZiBzY2g/LnNjaGVtYSAhPT0gXCJvYmplY3RcIikgcmV0dXJuXG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hPclJlZj8uc2NoZW1hICE9PSBcIm9iamVjdFwiKSByZXR1cm5cbiAgaWYgKCFzY2hPclJlZi52YWxpZGF0ZSkgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaE9yUmVmKVxuICBpZiAoaWQgPT09IG5vcm1hbGl6ZUlkKHJlZikpIHtcbiAgICBjb25zdCB7c2NoZW1hfSA9IHNjaE9yUmVmXG4gICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXVxuICAgIGlmIChzY2hJZCkgYmFzZUlkID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpXG4gICAgcmV0dXJuIG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZH0pXG4gIH1cbiAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoT3JSZWYpXG59XG5cbmNvbnN0IFBSRVZFTlRfU0NPUEVfQ0hBTkdFID0gbmV3IFNldChbXG4gIFwicHJvcGVydGllc1wiLFxuICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gIFwiZW51bVwiLFxuICBcImRlcGVuZGVuY2llc1wiLFxuICBcImRlZmluaXRpb25zXCIsXG5dKVxuXG5mdW5jdGlvbiBnZXRKc29uUG9pbnRlcihcbiAgdGhpczogQWp2LFxuICBwYXJzZWRSZWY6IFVSSUNvbXBvbmVudCxcbiAge2Jhc2VJZCwgc2NoZW1hLCByb290fTogU2NoZW1hRW52XG4pOiBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICBpZiAocGFyc2VkUmVmLmZyYWdtZW50Py5bMF0gIT09IFwiL1wiKSByZXR1cm5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgxKS5zcGxpdChcIi9cIikpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpIHJldHVyblxuICAgIGNvbnN0IHBhcnRTY2hlbWEgPSBzY2hlbWFbdW5lc2NhcGVGcmFnbWVudChwYXJ0KV1cbiAgICBpZiAocGFydFNjaGVtYSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBzY2hlbWEgPSBwYXJ0U2NoZW1hXG4gICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbdGhpcy5vcHRzLnNjaGVtYUlkXVxuICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICBiYXNlSWQgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZClcbiAgICB9XG4gIH1cbiAgbGV0IGVudjogU2NoZW1hRW52IHwgdW5kZWZpbmVkXG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiICYmIHNjaGVtYS4kcmVmICYmICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHRoaXMuUlVMRVMpKSB7XG4gICAgY29uc3QgJHJlZiA9IHJlc29sdmVVcmwodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaGVtYS4kcmVmKVxuICAgIGVudiA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKVxuICB9XG4gIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZH0pXG4gIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpIHJldHVybiBlbnZcbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuIiwgIntcbiAgXCIkaWRcIjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIk1ldGEtc2NoZW1hIGZvciAkZGF0YSByZWZlcmVuY2UgKEpTT04gQW55U2NoZW1hIGV4dGVuc2lvbiBwcm9wb3NhbClcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicmVxdWlyZWRcIjogW1wiJGRhdGFcIl0sXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCIkZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiYW55T2ZcIjogW3tcImZvcm1hdFwiOiBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwifSwge1wiZm9ybWF0XCI6IFwianNvbi1wb2ludGVyXCJ9XVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwgIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGUgeyh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFufSAqL1xuY29uc3QgaXNVVUlEID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL15bXFxkYS1mXXs4fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXsxMn0kL2l1KVxuXG4vKiogQHR5cGUgeyh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFufSAqL1xuY29uc3QgaXNJUHY0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZClcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpJC91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBjb2RlID0gMFxuICBsZXQgaSA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaW5wdXRbaV0uY2hhckNvZGVBdCgwKVxuICAgIGlmIChjb2RlID09PSA0OCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICAgIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgKz0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoISgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSB8fCAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikpKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgYWNjICs9IGlucHV0W2ldXG4gIH1cbiAgcmV0dXJuIGFjY1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdldElQVjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXJyb3IgLSBJbmRpY2F0ZXMgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHBhcnNpbmcgdGhlIElQdjYgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIHBhcnNlZCBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvbmVdIC0gVGhlIHpvbmUgaWRlbnRpZmllciwgaWYgcHJlc2VudC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IG5vblNpbXBsZURvbWFpbiA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9bXiFcIiQmJygpKissXFwtLjs9X2BhLXp7fX5dL3UpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSXNab25lIChidWZmZXIpIHtcbiAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhZGRyZXNzXG4gKiBAcGFyYW0ge0dldElQVjZSZXN1bHR9IG91dHB1dFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVIZXh0ZXRzIChidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkge1xuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IGhleCA9IHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpXG4gICAgaWYgKGhleCAhPT0gJycpIHtcbiAgICAgIGFkZHJlc3MucHVzaChoZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJucyB7R2V0SVBWNlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SVBWNiAoaW5wdXQpIHtcbiAgbGV0IHRva2VuQ291bnQgPSAwXG4gIGNvbnN0IG91dHB1dCA9IHsgZXJyb3I6IGZhbHNlLCBhZGRyZXNzOiAnJywgem9uZTogJycgfVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGFkZHJlc3MgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBlbmRpcHY2RW5jb3VudGVyZWQgPSBmYWxzZVxuICBsZXQgZW5kSXB2NiA9IGZhbHNlXG5cbiAgbGV0IGNvbnN1bWUgPSBjb25zdW1lSGV4dGV0c1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpKSB7IGJyZWFrIH1cbiAgICAgIGlmICgrK3Rva2VuQ291bnQgPiA3KSB7XG4gICAgICAgIC8vIG5vdCB2YWxpZFxuICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgaW5wdXRbaSAtIDFdID09PSAnOicpIHtcbiAgICAgICAgZW5kaXB2NkVuY291bnRlcmVkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgYWRkcmVzcy5wdXNoKCc6JylcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICAvLyBzd2l0Y2ggdG8gem9uZSBkZXRlY3Rpb25cbiAgICAgIGNvbnN1bWUgPSBjb25zdW1lSXNab25lXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IGNvbnN1bWVJc1pvbmUpIHtcbiAgICAgIG91dHB1dC56b25lID0gYnVmZmVyLmpvaW4oJycpXG4gICAgfSBlbHNlIGlmIChlbmRJcHY2KSB7XG4gICAgICBhZGRyZXNzLnB1c2goYnVmZmVyLmpvaW4oJycpKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRyZXNzLnB1c2goc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcikpXG4gICAgfVxuICB9XG4gIG91dHB1dC5hZGRyZXNzID0gYWRkcmVzcy5qb2luKCcnKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTm9ybWFsaXplSVB2NlJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3QgLSBUaGUgbm9ybWFsaXplZCBob3N0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlc2NhcGVkSG9zdF0gLSBUaGUgZXNjYXBlZCBob3N0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0lQVjYgLSBJbmRpY2F0ZXMgaWYgdGhlIGhvc3QgaXMgYW4gSVB2NiBhZGRyZXNzLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RcbiAqIEByZXR1cm5zIHtOb3JtYWxpemVJUHY2UmVzdWx0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJUHY2IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJzonKSA8IDIpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9IH1cbiAgY29uc3QgaXB2NiA9IGdldElQVjYoaG9zdClcblxuICBpZiAoIWlwdjYuZXJyb3IpIHtcbiAgICBsZXQgbmV3SG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGxldCBlc2NhcGVkSG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGlmIChpcHY2LnpvbmUpIHtcbiAgICAgIG5ld0hvc3QgKz0gJyUnICsgaXB2Ni56b25lXG4gICAgICBlc2NhcGVkSG9zdCArPSAnJTI1JyArIGlwdjYuem9uZVxuICAgIH1cbiAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0LCBpc0lQVjY6IHRydWUsIGVzY2FwZWRIb3N0IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZFRva2VuIChzdHIsIHRva2VuKSB7XG4gIGxldCBpbmQgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gdG9rZW4pIGluZCsrXG4gIH1cbiAgcmV0dXJuIGluZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMgKHBhdGgpIHtcbiAgbGV0IGlucHV0ID0gcGF0aFxuICBjb25zdCBvdXRwdXQgPSBbXVxuICBsZXQgbmV4dFNsYXNoID0gLTFcbiAgbGV0IGxlbiA9IDBcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgd2hpbGUgKGxlbiA9IGlucHV0Lmxlbmd0aCkge1xuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy4nKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLycpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJyB8fCBpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMykge1xuICAgICAgaWYgKGlucHV0ID09PSAnLy4uJykge1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlucHV0WzBdID09PSAnLicpIHtcbiAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsyXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnB1dFswXSA9PT0gJy8nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0WzJdID09PSAnLicpIHtcbiAgICAgICAgICBpZiAoaW5wdXRbM10gPT09ICcvJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKVxuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgb3V0cHV0LnBvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1bGUgMkU6IE1vdmUgbm9ybWFsIHBhdGggc2VnbWVudCB0byBvdXRwdXRcbiAgICBpZiAoKG5leHRTbGFzaCA9IGlucHV0LmluZGV4T2YoJy8nLCAxKSkgPT09IC0xKSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dClcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKGlucHV0LnNsaWNlKDAsIG5leHRTbGFzaCkpXG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKG5leHRTbGFzaClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudCwgZXNjKSB7XG4gIGNvbnN0IGZ1bmMgPSBlc2MgIT09IHRydWUgPyBlc2NhcGUgOiB1bmVzY2FwZVxuICBpZiAoY29tcG9uZW50LnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50LnNjaGVtZSlcbiAgfVxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudC51c2VyaW5mbylcbiAgfVxuICBpZiAoY29tcG9uZW50Lmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5ob3N0ID0gZnVuYyhjb21wb25lbnQuaG9zdClcbiAgfVxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gZnVuYyhjb21wb25lbnQucGF0aClcbiAgfVxuICBpZiAoY29tcG9uZW50LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucXVlcnkgPSBmdW5jKGNvbXBvbmVudC5xdWVyeSlcbiAgfVxuICBpZiAoY29tcG9uZW50LmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudC5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZWNvbXBvc2VBdXRob3JpdHkgKGNvbXBvbmVudCkge1xuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIGlmIChjb21wb25lbnQudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudC51c2VyaW5mbylcbiAgICB1cmlUb2tlbnMucHVzaCgnQCcpXG4gIH1cblxuICBpZiAoY29tcG9uZW50Lmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3N0ID0gdW5lc2NhcGUoY29tcG9uZW50Lmhvc3QpXG4gICAgaWYgKCFpc0lQdjQoaG9zdCkpIHtcbiAgICAgIGNvbnN0IGlwVjZyZXMgPSBub3JtYWxpemVJUHY2KGhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50Lmhvc3RcbiAgICAgIH1cbiAgICB9XG4gICAgdXJpVG9rZW5zLnB1c2goaG9zdClcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb21wb25lbnQucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudC5wb3J0KSlcbiAgfVxuXG4gIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oJycpIDogdW5kZWZpbmVkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9uU2ltcGxlRG9tYWluLFxuICByZWNvbXBvc2VBdXRob3JpdHksXG4gIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLFxuICByZW1vdmVEb3RTZWdtZW50cyxcbiAgaXNJUHY0LFxuICBpc1VVSUQsXG4gIG5vcm1hbGl6ZUlQdjYsXG4gIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZFxufVxuIiwgIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzVVVJRCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBVUk5fUkVHID0gLyhbXFxkYS16XVtcXGRcXC1hLXpdezAsMzF9KTooKD86W1xcdyEkJygpKissXFwtLjo7PUBdfCVbXFxkYS1mXXsyfSkrKS9pdVxuXG5jb25zdCBzdXBwb3J0ZWRTY2hlbWVOYW1lcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ2h0dHAnLCAnaHR0cHMnLCAnd3MnLFxuICAnd3NzJywgJ3VybicsICd1cm46dXVpZCddKVxuXG4vKiogQHR5cGVkZWYge3N1cHBvcnRlZFNjaGVtZU5hbWVzW251bWJlcl19IFNjaGVtZU5hbWUgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgU2NoZW1lTmFtZX1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNjaGVtZU5hbWUgKG5hbWUpIHtcbiAgcmV0dXJuIHN1cHBvcnRlZFNjaGVtZU5hbWVzLmluZGV4T2YoLyoqIEB0eXBlIHsqfSAqLyAobmFtZSkpICE9PSAtMVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBTY2hlbWVGblxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NoZW1lSGFuZGxlclxuICogQHByb3BlcnR5IHtTY2hlbWVOYW1lfSBzY2hlbWUgLSBUaGUgc2NoZW1lIG5hbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb21haW5Ib3N0XSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHN1cHBvcnRzIGRvbWFpbiBob3N0cy5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHBhcnNlIC0gRnVuY3Rpb24gdG8gcGFyc2UgdGhlIFVSSSBjb21wb25lbnQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtTY2hlbWVGbn0gc2VyaWFsaXplIC0gRnVuY3Rpb24gdG8gc2VyaWFsaXplIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemVdIC0gSW5kaWNhdGVzIGlmIG5vcm1hbGl6YXRpb24gc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWJzb2x1dGVQYXRoXSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHVzZXMgYWJzb2x1dGUgcGF0aHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmljb2RlU3VwcG9ydF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBVbmljb2RlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSB3c0NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHdzSXNTZWN1cmUgKHdzQ29tcG9uZW50KSB7XG4gIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zY2hlbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgd3NDb21wb25lbnQuc2NoZW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ3cnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ1cnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ1MnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ1MnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnQpIHtcbiAgaWYgKCFjb21wb25lbnQuaG9zdCkge1xuICAgIGNvbXBvbmVudC5lcnJvciA9IGNvbXBvbmVudC5lcnJvciB8fCAnSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuJ1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFNlcmlhbGl6ZSAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnQuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudC5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudC5wb3J0ID09PSAnJykge1xuICAgIGNvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnQucGF0aCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gJy8nXG4gIH1cblxuICAvLyBOT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gIC8vIGFzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAvLyBhbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NQYXJzZSAod3NDb21wb25lbnQpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnQuc2VjdXJlID0gd3NJc1NlY3VyZSh3c0NvbXBvbmVudClcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudC5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnQucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudC5xdWVyeSA6ICcnKVxuICB3c0NvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG4gIHdzQ29tcG9uZW50LnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnQpIHtcbi8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmICh3c0NvbXBvbmVudC5wb3J0ID09PSAod3NJc1NlY3VyZSh3c0NvbXBvbmVudCkgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICB3c0NvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudC5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgIHdzQ29tcG9uZW50LnNjaGVtZSA9ICh3c0NvbXBvbmVudC5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnQuc2VjdXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICBpZiAod3NDb21wb25lbnQucmVzb3VyY2VOYW1lKSB7XG4gICAgY29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50LnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnQucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpXG4gICAgd3NDb21wb25lbnQucXVlcnkgPSBxdWVyeVxuICAgIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudC5mcmFnbWVudCA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAoIXVybkNvbXBvbmVudC5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gJ1VSTiBjYW4gbm90IGJlIHBhcnNlZCdcbiAgICByZXR1cm4gdXJuQ29tcG9uZW50XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHVybkNvbXBvbmVudC5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICAgIHVybkNvbXBvbmVudC5uaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcbiAgICB1cm5Db21wb25lbnQubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnQubmlkfWBcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcih1cm5TY2hlbWUpXG4gICAgdXJuQ29tcG9uZW50LnBhdGggPSB1bmRlZmluZWRcblxuICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICB1cm5Db21wb25lbnQgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gdXJuQ29tcG9uZW50LmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKHVybkNvbXBvbmVudC5uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVVJOIHdpdGhvdXQgbmlkIGNhbm5vdCBiZSBzZXJpYWxpemVkJylcbiAgfVxuICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnQuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudC5uaWQudG9Mb3dlckNhc2UoKVxuICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWBcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuXG4gIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50LCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIGNvbnN0IG5zcyA9IHVybkNvbXBvbmVudC5uc3NcbiAgdXJpQ29tcG9uZW50LnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWBcblxuICBvcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiB1cmlDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRQYXJzZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHV1aWRDb21wb25lbnQgPSB1cm5Db21wb25lbnRcbiAgdXVpZENvbXBvbmVudC51dWlkID0gdXVpZENvbXBvbmVudC5uc3NcbiAgdXVpZENvbXBvbmVudC5uc3MgPSB1bmRlZmluZWRcblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50LnV1aWQgfHwgIWlzVVVJRCh1dWlkQ29tcG9uZW50LnV1aWQpKSkge1xuICAgIHV1aWRDb21wb25lbnQuZXJyb3IgPSB1dWlkQ29tcG9uZW50LmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudCkge1xuICBjb25zdCB1cm5Db21wb25lbnQgPSB1dWlkQ29tcG9uZW50XG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudC5uc3MgPSAodXVpZENvbXBvbmVudC51dWlkIHx8ICcnKS50b0xvd2VyQ2FzZSgpXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuY29uc3QgaHR0cCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufSlcblxuY29uc3QgaHR0cHMgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHBzJyxcbiAgZG9tYWluSG9zdDogaHR0cC5kb21haW5Ib3N0LFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IHdzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3cycsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiB3c1BhcnNlLFxuICBzZXJpYWxpemU6IHdzU2VyaWFsaXplXG59KVxuXG5jb25zdCB3c3MgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn0pXG5cbmNvbnN0IHVybiA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuJyxcbiAgcGFyc2U6IHVyblBhcnNlLFxuICBzZXJpYWxpemU6IHVyblNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufSlcblxuY29uc3QgdXJudXVpZCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuOnV1aWQnLFxuICBwYXJzZTogdXJudXVpZFBhcnNlLFxuICBzZXJpYWxpemU6IHVybnV1aWRTZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IFNDSEVNRVMgPSAvKiogQHR5cGUge1JlY29yZDxTY2hlbWVOYW1lLCBTY2hlbWVIYW5kbGVyPn0gKi8gKHtcbiAgaHR0cCxcbiAgaHR0cHMsXG4gIHdzLFxuICB3c3MsXG4gIHVybixcbiAgJ3Vybjp1dWlkJzogdXJudXVpZFxufSlcblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNDSEVNRVMsIG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzY2hlbWVcbiAqIEByZXR1cm5zIHtTY2hlbWVIYW5kbGVyfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1lSGFuZGxlciAoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lICYmIChcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyAoc2NoZW1lKV0gfHxcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyhzY2hlbWUudG9Mb3dlckNhc2UoKSldKVxuICApIHx8XG4gICAgdW5kZWZpbmVkXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3c0lzU2VjdXJlLFxuICBTQ0hFTUVTLFxuICBpc1ZhbGlkU2NoZW1lTmFtZSxcbiAgZ2V0U2NoZW1lSGFuZGxlcixcbn1cbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZywgaXNJUHY0LCBub25TaW1wbGVEb21haW4gfSA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJylcbmNvbnN0IHsgU0NIRU1FUywgZ2V0U2NoZW1lSGFuZGxlciB9ID0gcmVxdWlyZSgnLi9saWIvc2NoZW1lcycpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSBUXG4gKiBAcGFyYW0ge1R9IHVyaVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSAvKiogQHR5cGUge1R9ICovIChzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmkgPSAvKiogQHR5cGUge1R9ICovIChwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gIH1cbiAgcmV0dXJuIHVyaVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUklcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXNvbHZlIChiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucykgOiB7IHNjaGVtZTogJ251bGwnIH1cbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50KHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpXG4gIHNjaGVtZWxlc3NPcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZWQsIHNjaGVtZWxlc3NPcHRpb25zKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gYmFzZVxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSByZWxhdGl2ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemF0aW9uPWZhbHNlXVxuICogQHJldHVybnMge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQgKGJhc2UsIHJlbGF0aXZlLCBvcHRpb25zLCBza2lwTm9ybWFsaXphdGlvbikge1xuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gKi9cbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudFxuICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudFxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWVcbiAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoXG4gICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoWzBdID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IHVyaUFcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IHVyaUJcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZG9ubHk8aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50Pn0gY21wdHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdHNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudCA9IHtcbiAgICBob3N0OiBjbXB0cy5ob3N0LFxuICAgIHNjaGVtZTogY21wdHMuc2NoZW1lLFxuICAgIHVzZXJpbmZvOiBjbXB0cy51c2VyaW5mbyxcbiAgICBwb3J0OiBjbXB0cy5wb3J0LFxuICAgIHBhdGg6IGNtcHRzLnBhdGgsXG4gICAgcXVlcnk6IGNtcHRzLnF1ZXJ5LFxuICAgIG5pZDogY21wdHMubmlkLFxuICAgIG5zczogY21wdHMubnNzLFxuICAgIHV1aWQ6IGNtcHRzLnV1aWQsXG4gICAgZnJhZ21lbnQ6IGNtcHRzLmZyYWdtZW50LFxuICAgIHJlZmVyZW5jZTogY21wdHMucmVmZXJlbmNlLFxuICAgIHJlc291cmNlTmFtZTogY21wdHMucmVzb3VyY2VOYW1lLFxuICAgIHNlY3VyZTogY21wdHMuc2VjdXJlLFxuICAgIGVycm9yOiAnJ1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50LnNjaGVtZSlcblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnQsIG9wdGlvbnMpXG5cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcEVzY2FwZSkge1xuICAgICAgY29tcG9uZW50LnBhdGggPSBlc2NhcGUoY29tcG9uZW50LnBhdGgpXG5cbiAgICAgIGlmIChjb21wb25lbnQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LnBhdGggPSBjb21wb25lbnQucGF0aC5zcGxpdCgnJTNBJykuam9pbignOicpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC5wYXRoID0gdW5lc2NhcGUoY29tcG9uZW50LnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnQuc2NoZW1lKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50LnNjaGVtZSwgJzonKVxuICB9XG5cbiAgY29uc3QgYXV0aG9yaXR5ID0gcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudClcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50LnBhdGggJiYgY29tcG9uZW50LnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBzID0gY29tcG9uZW50LnBhdGhcblxuICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBzWzBdID09PSAnLycgJiZcbiAgICAgIHNbMV0gPT09ICcvJ1xuICAgICkge1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgIHMgPSAnLyUyRicgKyBzLnNsaWNlKDIpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2gocylcbiAgfVxuXG4gIGlmIChjb21wb25lbnQucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50LnF1ZXJ5KVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJyMnLCBjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBVUklfUEFSU0UgPSAvXig/OihbXiMvOj9dKyk6KT8oPzpcXC9cXC8oKD86KFteIy8/QF0qKUApPyhcXFtbXiMvP1xcXV0rXFxdfFteIy86P10qKSg/OjooXFxkKikpPykpPyhbXiM/XSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFtcXG5cXHJdKSopKT8vdVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdHNdXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBwYXJzZSAodXJpLCBvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gKi9cbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG5cbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB7XG4gICAgaWYgKG9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICB1cmkgPSBvcHRpb25zLnNjaGVtZSArICc6JyArIHVyaVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmkgPSAnLy8nICsgdXJpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaChVUklfUEFSU0UpXG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICAvLyBzdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgIHBhcnNlZC5zY2hlbWUgPSBtYXRjaGVzWzFdXG4gICAgcGFyc2VkLnVzZXJpbmZvID0gbWF0Y2hlc1szXVxuICAgIHBhcnNlZC5ob3N0ID0gbWF0Y2hlc1s0XVxuICAgIHBhcnNlZC5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApXG4gICAgcGFyc2VkLnBhdGggPSBtYXRjaGVzWzZdIHx8ICcnXG4gICAgcGFyc2VkLnF1ZXJ5ID0gbWF0Y2hlc1s3XVxuICAgIHBhcnNlZC5mcmFnbWVudCA9IG1hdGNoZXNbOF1cblxuICAgIC8vIGZpeCBwb3J0IG51bWJlclxuICAgIGlmIChpc05hTihwYXJzZWQucG9ydCkpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gbWF0Y2hlc1s1XVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgIGNvbnN0IGlwdjRyZXN1bHQgPSBpc0lQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXB2NnJlc3VsdCA9IG5vcm1hbGl6ZUlQdjYocGFyc2VkLmhvc3QpXG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NnJlc3VsdC5ob3N0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgaXNJUCA9IGlwdjZyZXN1bHQuaXNJUFY2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0lQID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5ob3N0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnBvcnQgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucXVlcnkgPT09IHVuZGVmaW5lZCAmJiAhcGFyc2VkLnBhdGgpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnc2FtZS1kb2N1bWVudCdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdyZWxhdGl2ZSdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ2Fic29sdXRlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3VyaSdcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IHBhcnNlZC5yZWZlcmVuY2UpIHtcbiAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGlzIG5vdCBhICcgKyBvcHRpb25zLnJlZmVyZW5jZSArICcgcmVmZXJlbmNlLidcbiAgICB9XG5cbiAgICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSlcblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAodXJpLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHBhcnNlZC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gZXNjYXBlKHVuZXNjYXBlKHBhcnNlZC5wYXRoKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQuZnJhZ21lbnQpIHtcbiAgICAgICAgcGFyc2VkLmZyYWdtZW50ID0gZW5jb2RlVVJJKGRlY29kZVVSSUNvbXBvbmVudChwYXJzZWQuZnJhZ21lbnQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKHBhcnNlZCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG4gIHJldHVybiBwYXJzZWRcbn1cblxuY29uc3QgZmFzdFVyaSA9IHtcbiAgU0NIRU1FUyxcbiAgbm9ybWFsaXplLFxuICByZXNvbHZlLFxuICByZXNvbHZlQ29tcG9uZW50LFxuICBlcXVhbCxcbiAgc2VyaWFsaXplLFxuICBwYXJzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5mYXN0VXJpID0gZmFzdFVyaVxuIiwgImltcG9ydCAqIGFzIHVyaSBmcm9tIFwiZmFzdC11cmlcIlxuXG50eXBlIFVSSSA9IHR5cGVvZiB1cmkgJiB7Y29kZTogc3RyaW5nfVxuOyh1cmkgYXMgVVJJKS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0J1xuXG5leHBvcnQgZGVmYXVsdCB1cmkgYXMgVVJJXG4iLCAiZXhwb3J0IHtcbiAgRm9ybWF0LFxuICBGb3JtYXREZWZpbml0aW9uLFxuICBBc3luY0Zvcm1hdERlZmluaXRpb24sXG4gIEtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIE1hY3JvS2V5d29yZERlZmluaXRpb24sXG4gIEZ1bmNLZXl3b3JkRGVmaW5pdGlvbixcbiAgVm9jYWJ1bGFyeSxcbiAgU2NoZW1hLFxuICBTY2hlbWFPYmplY3QsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgQXN5bmNTY2hlbWEsXG4gIEFueVNjaGVtYSxcbiAgVmFsaWRhdGVGdW5jdGlvbixcbiAgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgRXJyb3JOb1BhcmFtcyxcbn0gZnJvbSBcIi4vdHlwZXNcIlxuXG5leHBvcnQge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi9jb21waWxlXCJcbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luPE9wdHM+IHtcbiAgKGFqdjogQWp2LCBvcHRpb25zPzogT3B0cyk6IEFqdlxuICBbcHJvcDogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcIi4vY29tcGlsZS92YWxpZGF0ZVwiXG5leHBvcnQge0RlZmluZWRFcnJvcn0gZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2Vycm9yc1wiXG5leHBvcnQge0pTT05UeXBlfSBmcm9tIFwiLi9jb21waWxlL3J1bGVzXCJcbmV4cG9ydCB7SlNPTlNjaGVtYVR5cGV9IGZyb20gXCIuL3R5cGVzL2pzb24tc2NoZW1hXCJcbmV4cG9ydCB7SlREU2NoZW1hVHlwZSwgU29tZUpURFNjaGVtYVR5cGUsIEpURERhdGFUeXBlfSBmcm9tIFwiLi90eXBlcy9qdGQtc2NoZW1hXCJcbmV4cG9ydCB7Xywgc3RyLCBzdHJpbmdpZnksIG5pbCwgTmFtZSwgQ29kZSwgQ29kZUdlbiwgQ29kZUdlbk9wdGlvbnN9IGZyb20gXCIuL2NvbXBpbGUvY29kZWdlblwiXG5cbmltcG9ydCB0eXBlIHtcbiAgU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgU2NoZW1hT2JqZWN0LFxuICBBc3luY1NjaGVtYSxcbiAgVm9jYWJ1bGFyeSxcbiAgS2V5d29yZERlZmluaXRpb24sXG4gIEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEZvcm1hdCxcbiAgQWRkZWRGb3JtYXQsXG4gIFJlZ0V4cEVuZ2luZSxcbiAgVXJpUmVzb2x2ZXIsXG59IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtKU09OU2NoZW1hVHlwZX0gZnJvbSBcIi4vdHlwZXMvanNvbi1zY2hlbWFcIlxuaW1wb3J0IHR5cGUge0pURFNjaGVtYVR5cGUsIFNvbWVKVERTY2hlbWFUeXBlLCBKVEREYXRhVHlwZX0gZnJvbSBcIi4vdHlwZXMvanRkLXNjaGVtYVwiXG5pbXBvcnQgVmFsaWRhdGlvbkVycm9yIGZyb20gXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiXG5pbXBvcnQgTWlzc2luZ1JlZkVycm9yIGZyb20gXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCJcbmltcG9ydCB7Z2V0UnVsZXMsIFZhbGlkYXRpb25SdWxlcywgUnVsZSwgUnVsZUdyb3VwLCBKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5pbXBvcnQge1NjaGVtYUVudiwgY29tcGlsZVNjaGVtYSwgcmVzb2x2ZVNjaGVtYX0gZnJvbSBcIi4vY29tcGlsZVwiXG5pbXBvcnQge0NvZGUsIFZhbHVlU2NvcGV9IGZyb20gXCIuL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge25vcm1hbGl6ZUlkLCBnZXRTY2hlbWFSZWZzfSBmcm9tIFwiLi9jb21waWxlL3Jlc29sdmVcIlxuaW1wb3J0IHtnZXRKU09OVHlwZXN9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIlxuaW1wb3J0IHtlYWNoSXRlbX0gZnJvbSBcIi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCAqIGFzICRkYXRhUmVmU2NoZW1hIGZyb20gXCIuL3JlZnMvZGF0YS5qc29uXCJcblxuaW1wb3J0IERlZmF1bHRVcmlSZXNvbHZlciBmcm9tIFwiLi9ydW50aW1lL3VyaVwiXG5cbmNvbnN0IGRlZmF1bHRSZWdFeHA6IFJlZ0V4cEVuZ2luZSA9IChzdHIsIGZsYWdzKSA9PiBuZXcgUmVnRXhwKHN0ciwgZmxhZ3MpXG5kZWZhdWx0UmVnRXhwLmNvZGUgPSBcIm5ldyBSZWdFeHBcIlxuXG5jb25zdCBNRVRBX0lHTk9SRV9PUFRJT05TOiAoa2V5b2YgT3B0aW9ucylbXSA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdXG5jb25zdCBFWFRfU0NPUEVfTkFNRVMgPSBuZXcgU2V0KFtcbiAgXCJ2YWxpZGF0ZVwiLFxuICBcInNlcmlhbGl6ZVwiLFxuICBcInBhcnNlXCIsXG4gIFwid3JhcHBlclwiLFxuICBcInJvb3RcIixcbiAgXCJzY2hlbWFcIixcbiAgXCJrZXl3b3JkXCIsXG4gIFwicGF0dGVyblwiLFxuICBcImZvcm1hdHNcIixcbiAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gIFwiZnVuY1wiLFxuICBcIm9ialwiLFxuICBcIkVycm9yXCIsXG5dKVxuXG5leHBvcnQgdHlwZSBPcHRpb25zID0gQ3VycmVudE9wdGlvbnMgJiBEZXByZWNhdGVkT3B0aW9uc1xuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnJlbnRPcHRpb25zIHtcbiAgLy8gc3RyaWN0IG1vZGUgb3B0aW9ucyAoTkVXKVxuICBzdHJpY3Q/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RTY2hlbWE/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3ROdW1iZXJzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0VHlwZXM/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RUdXBsZXM/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RSZXF1aXJlZD86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzPzogYm9vbGVhbiAvLyBkaXNhYmxlcyBhIHN0cmljdCBtb2RlIHJlc3RyaWN0aW9uXG4gIGFsbG93VW5pb25UeXBlcz86IGJvb2xlYW5cbiAgdmFsaWRhdGVGb3JtYXRzPzogYm9vbGVhblxuICAvLyB2YWxpZGF0aW9uIGFuZCByZXBvcnRpbmcgb3B0aW9uczpcbiAgJGRhdGE/OiBib29sZWFuXG4gIGFsbEVycm9ycz86IGJvb2xlYW5cbiAgdmVyYm9zZT86IGJvb2xlYW5cbiAgZGlzY3JpbWluYXRvcj86IGJvb2xlYW5cbiAgdW5pY29kZVJlZ0V4cD86IGJvb2xlYW5cbiAgdGltZXN0YW1wPzogXCJzdHJpbmdcIiB8IFwiZGF0ZVwiIC8vIEpURCBvbmx5XG4gIHBhcnNlRGF0ZT86IGJvb2xlYW4gLy8gSlREIG9ubHlcbiAgYWxsb3dEYXRlPzogYm9vbGVhbiAvLyBKVEQgb25seVxuICAkY29tbWVudD86XG4gICAgfCB0cnVlXG4gICAgfCAoKGNvbW1lbnQ6IHN0cmluZywgc2NoZW1hUGF0aD86IHN0cmluZywgcm9vdFNjaGVtYT86IEFueVNjaGVtYU9iamVjdCkgPT4gdW5rbm93bilcbiAgZm9ybWF0cz86IHtbTmFtZSBpbiBzdHJpbmddPzogRm9ybWF0fVxuICBrZXl3b3Jkcz86IFZvY2FidWxhcnlcbiAgc2NoZW1hcz86IEFueVNjaGVtYVtdIHwge1tLZXkgaW4gc3RyaW5nXT86IEFueVNjaGVtYX1cbiAgbG9nZ2VyPzogTG9nZ2VyIHwgZmFsc2VcbiAgbG9hZFNjaGVtYT86ICh1cmk6IHN0cmluZykgPT4gUHJvbWlzZTxBbnlTY2hlbWFPYmplY3Q+XG4gIC8vIG9wdGlvbnMgdG8gbW9kaWZ5IHZhbGlkYXRlZCBkYXRhOlxuICByZW1vdmVBZGRpdGlvbmFsPzogYm9vbGVhbiB8IFwiYWxsXCIgfCBcImZhaWxpbmdcIlxuICB1c2VEZWZhdWx0cz86IGJvb2xlYW4gfCBcImVtcHR5XCJcbiAgY29lcmNlVHlwZXM/OiBib29sZWFuIHwgXCJhcnJheVwiXG4gIC8vIGFkdmFuY2VkIG9wdGlvbnM6XG4gIG5leHQ/OiBib29sZWFuIC8vIE5FV1xuICB1bmV2YWx1YXRlZD86IGJvb2xlYW4gLy8gTkVXXG4gIGR5bmFtaWNSZWY/OiBib29sZWFuIC8vIE5FV1xuICBzY2hlbWFJZD86IFwiaWRcIiB8IFwiJGlkXCJcbiAganRkPzogYm9vbGVhbiAvLyBORVdcbiAgbWV0YT86IFNjaGVtYU9iamVjdCB8IGJvb2xlYW5cbiAgZGVmYXVsdE1ldGE/OiBzdHJpbmcgfCBBbnlTY2hlbWFPYmplY3RcbiAgdmFsaWRhdGVTY2hlbWE/OiBib29sZWFuIHwgXCJsb2dcIlxuICBhZGRVc2VkU2NoZW1hPzogYm9vbGVhblxuICBpbmxpbmVSZWZzPzogYm9vbGVhbiB8IG51bWJlclxuICBwYXNzQ29udGV4dD86IGJvb2xlYW5cbiAgbG9vcFJlcXVpcmVkPzogbnVtYmVyXG4gIGxvb3BFbnVtPzogbnVtYmVyIC8vIE5FV1xuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxuICBtdWx0aXBsZU9mUHJlY2lzaW9uPzogbnVtYmVyXG4gIGludDMycmFuZ2U/OiBib29sZWFuIC8vIEpURCBvbmx5XG4gIG1lc3NhZ2VzPzogYm9vbGVhblxuICBjb2RlPzogQ29kZU9wdGlvbnMgLy8gTkVXXG4gIHVyaVJlc29sdmVyPzogVXJpUmVzb2x2ZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2RlT3B0aW9ucyB7XG4gIGVzNT86IGJvb2xlYW5cbiAgZXNtPzogYm9vbGVhblxuICBsaW5lcz86IGJvb2xlYW5cbiAgb3B0aW1pemU/OiBib29sZWFuIHwgbnVtYmVyXG4gIGZvcm1hdHM/OiBDb2RlIC8vIGNvZGUgdG8gcmVxdWlyZSAob3IgY29uc3RydWN0KSBtYXAgb2YgYXZhaWxhYmxlIGZvcm1hdHMgLSBmb3Igc3RhbmRhbG9uZSBjb2RlXG4gIHNvdXJjZT86IGJvb2xlYW5cbiAgcHJvY2Vzcz86IChjb2RlOiBzdHJpbmcsIHNjaGVtYT86IFNjaGVtYUVudikgPT4gc3RyaW5nXG4gIHJlZ0V4cD86IFJlZ0V4cEVuZ2luZVxufVxuXG5pbnRlcmZhY2UgSW5zdGFuY2VDb2RlT3B0aW9ucyBleHRlbmRzIENvZGVPcHRpb25zIHtcbiAgcmVnRXhwOiBSZWdFeHBFbmdpbmVcbiAgb3B0aW1pemU6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgRGVwcmVjYXRlZE9wdGlvbnMge1xuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgaWdub3JlS2V5d29yZHNXaXRoUmVmPzogYm9vbGVhblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAganNQcm9wZXJ0eVN5bnRheD86IGJvb2xlYW4gLy8gYWRkZWQgaW5zdGVhZCBvZiBqc29uUG9pbnRlcnNcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIHVuaWNvZGU/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBSZW1vdmVkT3B0aW9ucyB7XG4gIGZvcm1hdD86IGJvb2xlYW5cbiAgZXJyb3JEYXRhUGF0aD86IFwib2JqZWN0XCIgfCBcInByb3BlcnR5XCJcbiAgbnVsbGFibGU/OiBib29sZWFuIC8vIFwibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0XG4gIGpzb25Qb2ludGVycz86IGJvb2xlYW5cbiAgZXh0ZW5kUmVmcz86IHRydWUgfCBcImlnbm9yZVwiIHwgXCJmYWlsXCJcbiAgbWlzc2luZ1JlZnM/OiB0cnVlIHwgXCJpZ25vcmVcIiB8IFwiZmFpbFwiXG4gIHByb2Nlc3NDb2RlPzogKGNvZGU6IHN0cmluZywgc2NoZW1hPzogU2NoZW1hRW52KSA9PiBzdHJpbmdcbiAgc291cmNlQ29kZT86IGJvb2xlYW5cbiAgc3RyaWN0RGVmYXVsdHM/OiBib29sZWFuXG4gIHN0cmljdEtleXdvcmRzPzogYm9vbGVhblxuICB1bmlxdWVJdGVtcz86IGJvb2xlYW5cbiAgdW5rbm93bkZvcm1hdHM/OiB0cnVlIHwgc3RyaW5nW10gfCBcImlnbm9yZVwiXG4gIGNhY2hlPzogYW55XG4gIHNlcmlhbGl6ZT86IChzY2hlbWE6IEFueVNjaGVtYSkgPT4gdW5rbm93blxuICBhanZFcnJvcnM/OiBib29sZWFuXG59XG5cbnR5cGUgT3B0aW9uc0luZm88VCBleHRlbmRzIFJlbW92ZWRPcHRpb25zIHwgRGVwcmVjYXRlZE9wdGlvbnM+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuY29uc3QgcmVtb3ZlZE9wdGlvbnM6IE9wdGlvbnNJbmZvPFJlbW92ZWRPcHRpb25zPiA9IHtcbiAgZXJyb3JEYXRhUGF0aDogXCJcIixcbiAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICBudWxsYWJsZTogJ1wibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0LicsXG4gIGpzb25Qb2ludGVyczogXCJEZXByZWNhdGVkIGpzUHJvcGVydHlTeW50YXggY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICBtaXNzaW5nUmVmczogXCJQYXNzIGVtcHR5IHNjaGVtYSB3aXRoICRpZCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGFqdi5hZGRTY2hlbWEuXCIsXG4gIHByb2Nlc3NDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtwcm9jZXNzOiAoY29kZSwgc2NoZW1hRW52OiBvYmplY3QpID0+IHN0cmluZ31gXCIsXG4gIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gIHN0cmljdERlZmF1bHRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICBzdHJpY3RLZXl3b3JkczogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gIHVua25vd25Gb3JtYXRzOiBcIkRpc2FibGUgc3RyaWN0IG1vZGUgb3IgcGFzcyBgdHJ1ZWAgdG8gYGFqdi5hZGRGb3JtYXRgIChvciBgZm9ybWF0c2Agb3B0aW9uKS5cIixcbiAgY2FjaGU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICBhanZFcnJvcnM6IFwiSXQgaXMgZGVmYXVsdCBub3cuXCIsXG59XG5cbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zOiBPcHRpb25zSW5mbzxEZXByZWNhdGVkT3B0aW9ucz4gPSB7XG4gIGlnbm9yZUtleXdvcmRzV2l0aFJlZjogXCJcIixcbiAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgdW5pY29kZTogJ1wibWluTGVuZ3RoXCIvXCJtYXhMZW5ndGhcIiBhY2NvdW50IGZvciB1bmljb2RlIGNoYXJhY3RlcnMgYnkgZGVmYXVsdC4nLFxufVxuXG50eXBlIFJlcXVpcmVkSW5zdGFuY2VPcHRpb25zID0ge1xuICBbSyBpblxuICAgIHwgXCJzdHJpY3RTY2hlbWFcIlxuICAgIHwgXCJzdHJpY3ROdW1iZXJzXCJcbiAgICB8IFwic3RyaWN0VHlwZXNcIlxuICAgIHwgXCJzdHJpY3RUdXBsZXNcIlxuICAgIHwgXCJzdHJpY3RSZXF1aXJlZFwiXG4gICAgfCBcImlubGluZVJlZnNcIlxuICAgIHwgXCJsb29wUmVxdWlyZWRcIlxuICAgIHwgXCJsb29wRW51bVwiXG4gICAgfCBcIm1ldGFcIlxuICAgIHwgXCJtZXNzYWdlc1wiXG4gICAgfCBcInNjaGVtYUlkXCJcbiAgICB8IFwiYWRkVXNlZFNjaGVtYVwiXG4gICAgfCBcInZhbGlkYXRlU2NoZW1hXCJcbiAgICB8IFwidmFsaWRhdGVGb3JtYXRzXCJcbiAgICB8IFwiaW50MzJyYW5nZVwiXG4gICAgfCBcInVuaWNvZGVSZWdFeHBcIlxuICAgIHwgXCJ1cmlSZXNvbHZlclwiXTogTm9uTnVsbGFibGU8T3B0aW9uc1tLXT5cbn0gJiB7Y29kZTogSW5zdGFuY2VDb2RlT3B0aW9uc31cblxuZXhwb3J0IHR5cGUgSW5zdGFuY2VPcHRpb25zID0gT3B0aW9ucyAmIFJlcXVpcmVkSW5zdGFuY2VPcHRpb25zXG5cbmNvbnN0IE1BWF9FWFBSRVNTSU9OID0gMjAwXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiByZXF1aXJlZE9wdGlvbnMobzogT3B0aW9ucyk6IFJlcXVpcmVkSW5zdGFuY2VPcHRpb25zIHtcbiAgY29uc3QgcyA9IG8uc3RyaWN0XG4gIGNvbnN0IF9vcHR6ID0gby5jb2RlPy5vcHRpbWl6ZVxuICBjb25zdCBvcHRpbWl6ZSA9IF9vcHR6ID09PSB0cnVlIHx8IF9vcHR6ID09PSB1bmRlZmluZWQgPyAxIDogX29wdHogfHwgMFxuICBjb25zdCByZWdFeHAgPSBvLmNvZGU/LnJlZ0V4cCA/PyBkZWZhdWx0UmVnRXhwXG4gIGNvbnN0IHVyaVJlc29sdmVyID0gby51cmlSZXNvbHZlciA/PyBEZWZhdWx0VXJpUmVzb2x2ZXJcbiAgcmV0dXJuIHtcbiAgICBzdHJpY3RTY2hlbWE6IG8uc3RyaWN0U2NoZW1hID8/IHMgPz8gdHJ1ZSxcbiAgICBzdHJpY3ROdW1iZXJzOiBvLnN0cmljdE51bWJlcnMgPz8gcyA/PyB0cnVlLFxuICAgIHN0cmljdFR5cGVzOiBvLnN0cmljdFR5cGVzID8/IHMgPz8gXCJsb2dcIixcbiAgICBzdHJpY3RUdXBsZXM6IG8uc3RyaWN0VHVwbGVzID8/IHMgPz8gXCJsb2dcIixcbiAgICBzdHJpY3RSZXF1aXJlZDogby5zdHJpY3RSZXF1aXJlZCA/PyBzID8/IGZhbHNlLFxuICAgIGNvZGU6IG8uY29kZSA/IHsuLi5vLmNvZGUsIG9wdGltaXplLCByZWdFeHB9IDoge29wdGltaXplLCByZWdFeHB9LFxuICAgIGxvb3BSZXF1aXJlZDogby5sb29wUmVxdWlyZWQgPz8gTUFYX0VYUFJFU1NJT04sXG4gICAgbG9vcEVudW06IG8ubG9vcEVudW0gPz8gTUFYX0VYUFJFU1NJT04sXG4gICAgbWV0YTogby5tZXRhID8/IHRydWUsXG4gICAgbWVzc2FnZXM6IG8ubWVzc2FnZXMgPz8gdHJ1ZSxcbiAgICBpbmxpbmVSZWZzOiBvLmlubGluZVJlZnMgPz8gdHJ1ZSxcbiAgICBzY2hlbWFJZDogby5zY2hlbWFJZCA/PyBcIiRpZFwiLFxuICAgIGFkZFVzZWRTY2hlbWE6IG8uYWRkVXNlZFNjaGVtYSA/PyB0cnVlLFxuICAgIHZhbGlkYXRlU2NoZW1hOiBvLnZhbGlkYXRlU2NoZW1hID8/IHRydWUsXG4gICAgdmFsaWRhdGVGb3JtYXRzOiBvLnZhbGlkYXRlRm9ybWF0cyA/PyB0cnVlLFxuICAgIHVuaWNvZGVSZWdFeHA6IG8udW5pY29kZVJlZ0V4cCA/PyB0cnVlLFxuICAgIGludDMycmFuZ2U6IG8uaW50MzJyYW5nZSA/PyB0cnVlLFxuICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIGxvZyguLi5hcmdzOiB1bmtub3duW10pOiB1bmtub3duXG4gIHdhcm4oLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxuICBlcnJvciguLi5hcmdzOiB1bmtub3duW10pOiB1bmtub3duXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqdiB7XG4gIG9wdHM6IEluc3RhbmNlT3B0aW9uc1xuICBlcnJvcnM/OiBFcnJvck9iamVjdFtdIHwgbnVsbCAvLyBlcnJvcnMgZnJvbSB0aGUgbGFzdCB2YWxpZGF0aW9uXG4gIGxvZ2dlcjogTG9nZ2VyXG4gIC8vIHNoYXJlZCBleHRlcm5hbCBzY29wZSB2YWx1ZXMgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uc1xuICByZWFkb25seSBzY29wZTogVmFsdWVTY29wZVxuICByZWFkb25seSBzY2hlbWFzOiB7W0tleSBpbiBzdHJpbmddPzogU2NoZW1hRW52fSA9IHt9XG4gIHJlYWRvbmx5IHJlZnM6IHtbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBzdHJpbmd9ID0ge31cbiAgcmVhZG9ubHkgZm9ybWF0czoge1tOYW1lIGluIHN0cmluZ10/OiBBZGRlZEZvcm1hdH0gPSB7fVxuICByZWFkb25seSBSVUxFUzogVmFsaWRhdGlvblJ1bGVzXG4gIHJlYWRvbmx5IF9jb21waWxhdGlvbnM6IFNldDxTY2hlbWFFbnY+ID0gbmV3IFNldCgpXG4gIHByaXZhdGUgcmVhZG9ubHkgX2xvYWRpbmc6IHtbUmVmIGluIHN0cmluZ10/OiBQcm9taXNlPEFueVNjaGVtYU9iamVjdD59ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBfY2FjaGU6IE1hcDxBbnlTY2hlbWEsIFNjaGVtYUVudj4gPSBuZXcgTWFwKClcbiAgcHJpdmF0ZSByZWFkb25seSBfbWV0YU9wdHM6IEluc3RhbmNlT3B0aW9uc1xuXG4gIHN0YXRpYyBWYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3JcbiAgc3RhdGljIE1pc3NpbmdSZWZFcnJvciA9IE1pc3NpbmdSZWZFcnJvclxuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIG9wdHMgPSB0aGlzLm9wdHMgPSB7Li4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpfVxuICAgIGNvbnN0IHtlczUsIGxpbmVzfSA9IHRoaXMub3B0cy5jb2RlXG5cbiAgICB0aGlzLnNjb3BlID0gbmV3IFZhbHVlU2NvcGUoe3Njb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lc30pXG4gICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpXG4gICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHNcbiAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZhbHNlXG5cbiAgICB0aGlzLlJVTEVTID0gZ2V0UnVsZXMoKVxuICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIilcbiAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKVxuICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKVxuXG4gICAgaWYgKG9wdHMuZm9ybWF0cykgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKVxuICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpXG4gICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKVxuICAgIGlmIChvcHRzLmtleXdvcmRzKSBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpXG4gICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKVxuICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0XG4gIH1cblxuICBfYWRkVm9jYWJ1bGFyaWVzKCk6IHZvaWQge1xuICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk6IHZvaWQge1xuICAgIGNvbnN0IHskZGF0YSwgbWV0YSwgc2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgbGV0IF9kYXRhUmVmU2NoZW1hOiBTY2hlbWFPYmplY3QgPSAkZGF0YVJlZlNjaGVtYVxuICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICBfZGF0YVJlZlNjaGVtYSA9IHsuLi4kZGF0YVJlZlNjaGVtYX1cbiAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkXG4gICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkXG4gICAgfVxuICAgIGlmIChtZXRhICYmICRkYXRhKSB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpXG4gIH1cblxuICBkZWZhdWx0TWV0YSgpOiBzdHJpbmcgfCBBbnlTY2hlbWFPYmplY3QgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHttZXRhLCBzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgZGF0YSB1c2luZyBzY2hlbWFcbiAgLy8gQW55U2NoZW1hIHdpbGwgYmUgY29tcGlsZWQgYW5kIGNhY2hlZCB1c2luZyBzY2hlbWEgaXRzZWxmIGFzIGEga2V5IGZvciBNYXBcbiAgdmFsaWRhdGUoc2NoZW1hOiBTY2hlbWEgfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBib29sZWFuXG4gIHZhbGlkYXRlKHNjaGVtYUtleVJlZjogQW55U2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogYm9vbGVhbiB8IFByb21pc2U8dW5rbm93bj5cbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBTY2hlbWEgfCBKU09OU2NoZW1hVHlwZTxUPiB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVFxuICAvLyBTZXBhcmF0ZWQgZm9yIHR5cGUgaW5mZXJlbmNlIHRvIHdvcmtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBKVERTY2hlbWFUeXBlPFQ+LCBkYXRhOiB1bmtub3duKTogZGF0YSBpcyBUXG4gIC8vIFRoaXMgb3ZlcmxvYWQgaXMgb25seSBpbnRlbmRlZCBmb3IgdHlwZXNjcmlwdCBpbmZlcmVuY2UsIHRoZSBmaXJzdFxuICAvLyBhcmd1bWVudCBwcmV2ZW50cyBtYW51YWwgdHlwZSBhbm5vdGF0aW9uIGZyb20gbWF0Y2hpbmcgdGhpcyBvdmVybG9hZFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHZhbGlkYXRlPE4gZXh0ZW5kcyBuZXZlciwgVCBleHRlbmRzIFNvbWVKVERTY2hlbWFUeXBlPihcbiAgICBzY2hlbWE6IFQsXG4gICAgZGF0YTogdW5rbm93blxuICApOiBkYXRhIGlzIEpURERhdGFUeXBlPFQ+XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogQXN5bmNTY2hlbWEsIGRhdGE6IHVua25vd24gfCBUKTogUHJvbWlzZTxUPlxuICB2YWxpZGF0ZTxUPihzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVCB8IFByb21pc2U8VD5cbiAgdmFsaWRhdGU8VD4oXG4gICAgc2NoZW1hS2V5UmVmOiBBbnlTY2hlbWEgfCBzdHJpbmcsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuICAgIGRhdGE6IHVua25vd24gfCBUIC8vIHRvIGJlIHZhbGlkYXRlZFxuICApOiBib29sZWFuIHwgUHJvbWlzZTxUPiB7XG4gICAgbGV0IHY6IEFueVZhbGlkYXRlRnVuY3Rpb24gfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2ID0gdGhpcy5nZXRTY2hlbWE8VD4oc2NoZW1hS2V5UmVmKVxuICAgICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApXG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSB0aGlzLmNvbXBpbGU8VD4oc2NoZW1hS2V5UmVmKVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKVxuICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpIHRoaXMuZXJyb3JzID0gdi5lcnJvcnNcbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIC8vIENyZWF0ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hXG4gIC8vIF9tZXRhOiB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHkgdG8gY29tcGlsZSBtZXRhIHNjaGVtYXMgb2YgdXNlci1kZWZpbmVkIGtleXdvcmRzLlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IFNjaGVtYSB8IEpTT05TY2hlbWFUeXBlPFQ+LCBfbWV0YT86IGJvb2xlYW4pOiBWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFZhbGlkYXRlRnVuY3Rpb248VD5cbiAgLy8gVGhpcyBvdmVybG9hZCBpcyBvbmx5IGludGVuZGVkIGZvciB0eXBlc2NyaXB0IGluZmVyZW5jZSwgdGhlIGZpcnN0XG4gIC8vIGFyZ3VtZW50IHByZXZlbnRzIG1hbnVhbCB0eXBlIGFubm90YXRpb24gZnJvbSBtYXRjaGluZyB0aGlzIG92ZXJsb2FkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29tcGlsZTxOIGV4dGVuZHMgbmV2ZXIsIFQgZXh0ZW5kcyBTb21lSlREU2NoZW1hVHlwZT4oXG4gICAgc2NoZW1hOiBULFxuICAgIF9tZXRhPzogYm9vbGVhblxuICApOiBWYWxpZGF0ZUZ1bmN0aW9uPEpURERhdGFUeXBlPFQ+PlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEFzeW5jU2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBc3luY1ZhbGlkYXRlRnVuY3Rpb248VD5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBbnlTY2hlbWEsIF9tZXRhPzogYm9vbGVhbik6IEFueVZhbGlkYXRlRnVuY3Rpb248VD5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBbnlTY2hlbWEsIF9tZXRhPzogYm9vbGVhbik6IEFueVZhbGlkYXRlRnVuY3Rpb248VD4ge1xuICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhKVxuICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSkgYXMgQW55VmFsaWRhdGVGdW5jdGlvbjxUPlxuICB9XG5cbiAgLy8gQ3JlYXRlcyB2YWxpZGF0aW5nIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hIHdpdGggYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgbWlzc2luZyBzY2hlbWFzLlxuICAvLyBgbG9hZFNjaGVtYWAgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBzY2hlbWEgdXJpIGFuZCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzY2hlbWEuXG4gIC8vIFRPRE8gYWxsb3cgcGFzc2luZyBzY2hlbWEgVVJJXG4gIC8vIG1ldGEgLSBvcHRpb25hbCB0cnVlIHRvIGNvbXBpbGUgbWV0YS1zY2hlbWFcbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihcbiAgICBzY2hlbWE6IFNjaGVtYU9iamVjdCB8IEpTT05TY2hlbWFUeXBlPFQ+LFxuICAgIF9tZXRhPzogYm9vbGVhblxuICApOiBQcm9taXNlPFZhbGlkYXRlRnVuY3Rpb248VD4+XG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KHNjaGVtYTogSlREU2NoZW1hVHlwZTxUPiwgX21ldGE/OiBib29sZWFuKTogUHJvbWlzZTxWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KHNjaGVtYTogQXN5bmNTY2hlbWEsIG1ldGE/OiBib29sZWFuKTogUHJvbWlzZTxBc3luY1ZhbGlkYXRlRnVuY3Rpb248VD4+XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oXG4gICAgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAgbWV0YT86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIG1ldGE/OiBib29sZWFuXG4gICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbjxUPj4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIilcbiAgICB9XG4gICAgY29uc3Qge2xvYWRTY2hlbWF9ID0gdGhpcy5vcHRzXG4gICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSlcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhcbiAgICAgIHRoaXM6IEFqdixcbiAgICAgIF9zY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICAgIF9tZXRhPzogYm9vbGVhblxuICAgICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbj4ge1xuICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpXG4gICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoX3NjaGVtYSwgX21ldGEpXG4gICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEodGhpczogQWp2LCAkcmVmPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoJHJlZiAmJiAhdGhpcy5nZXRTY2hlbWEoJHJlZikpIHtcbiAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyRyZWZ9LCB0cnVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmModGhpczogQWp2LCBzY2g6IFNjaGVtYUVudik6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbj4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgTWlzc2luZ1JlZkVycm9yKSkgdGhyb3cgZVxuICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpXG4gICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKVxuICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0xvYWRlZCh0aGlzOiBBanYsIHttaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWZ9OiBNaXNzaW5nUmVmRXJyb3IpOiB2b2lkIHtcbiAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFueVNjaGVtYSAke3JlZn0gaXMgbG9hZGVkIGJ1dCAke21pc3NpbmdSZWZ9IGNhbm5vdCBiZSByZXNvbHZlZGApXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEodGhpczogQWp2LCByZWY6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgX3NjaGVtYSA9IGF3YWl0IF9sb2FkU2NoZW1hLmNhbGwodGhpcywgcmVmKVxuICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSkgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpXG4gICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKSB0aGlzLmFkZFNjaGVtYShfc2NoZW1hLCByZWYsIG1ldGEpXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEodGhpczogQWp2LCByZWY6IHN0cmluZyk6IFByb21pc2U8QW55U2NoZW1hT2JqZWN0PiB7XG4gICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdXG4gICAgICBpZiAocCkgcmV0dXJuIHBcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZVxuICBhZGRTY2hlbWEoXG4gICAgc2NoZW1hOiBBbnlTY2hlbWEgfCBBbnlTY2hlbWFbXSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXk/OiBzdHJpbmcsIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGE/OiBib29sZWFuLCAvLyB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHksIGFkZE1ldGFTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBvcHRpb24gdmFsaWRhdGVTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgKTogQWp2IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpIHRoaXMuYWRkU2NoZW1hKHNjaCwgdW5kZWZpbmVkLCBfbWV0YSwgX3ZhbGlkYXRlU2NoZW1hKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgbGV0IGlkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApXG4gICAgICB9XG4gICAgfVxuICAgIGtleSA9IG5vcm1hbGl6ZUlkKGtleSB8fCBpZClcbiAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpXG4gICAgdGhpcy5zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSwga2V5LCBfdmFsaWRhdGVTY2hlbWEsIHRydWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICBhZGRNZXRhU2NoZW1hKFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIGtleT86IHN0cmluZywgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICk6IEFqdiB7XG4gICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBrZXksIHRydWUsIF92YWxpZGF0ZVNjaGVtYSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICB2YWxpZGF0ZVNjaGVtYShzY2hlbWE6IEFueVNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yPzogYm9vbGVhbik6IGJvb2xlYW4gfCBQcm9taXNlPHVua25vd24+IHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHRydWVcbiAgICBsZXQgJHNjaGVtYTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hXG4gICAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkc2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIilcbiAgICB9XG4gICAgJHNjaGVtYSA9ICRzY2hlbWEgfHwgdGhpcy5vcHRzLmRlZmF1bHRNZXRhIHx8IHRoaXMuZGVmYXVsdE1ldGEoKVxuICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIilcbiAgICAgIHRoaXMuZXJyb3JzID0gbnVsbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSlcbiAgICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KClcbiAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpXG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIC8vIEdldCBjb21waWxlZCBzY2hlbWEgYnkgYGtleWAgb3IgYHJlZmAuXG4gIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICBnZXRTY2hlbWE8VCA9IHVua25vd24+KGtleVJlZjogc3RyaW5nKTogQW55VmFsaWRhdGVGdW5jdGlvbjxUPiB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHNjaFxuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpIGtleVJlZiA9IHNjaFxuICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgICAgY29uc3Qgcm9vdCA9IG5ldyBTY2hlbWFFbnYoe3NjaGVtYToge30sIHNjaGVtYUlkfSlcbiAgICAgIHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBrZXlSZWYpXG4gICAgICBpZiAoIXNjaCkgcmV0dXJuXG4gICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaFxuICAgIH1cbiAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpIGFzIEFueVZhbGlkYXRlRnVuY3Rpb248VD4gfCB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gIC8vIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWY/OiBBbnlTY2hlbWEgfCBzdHJpbmcgfCBSZWdFeHApOiBBanYge1xuICAgIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzLCBzY2hlbWFLZXlSZWYpXG4gICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKVxuICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcylcbiAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZilcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIikgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXVxuICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZlxuICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpXG4gICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tpZF1cbiAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zOiBWb2NhYnVsYXJ5KTogQWp2IHtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucykgdGhpcy5hZGRLZXl3b3JkKGRlZilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWRkS2V5d29yZChcbiAgICBrd2RPckRlZjogc3RyaW5nIHwgS2V5d29yZERlZmluaXRpb24sXG4gICAgZGVmPzogS2V5d29yZERlZmluaXRpb24gLy8gZGVwcmVjYXRlZFxuICApOiBBanYge1xuICAgIGxldCBrZXl3b3JkOiBzdHJpbmcgfCBzdHJpbmdbXVxuICAgIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAga2V5d29yZCA9IGt3ZE9yRGVmXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJ0aGVzZSBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkLCBzZWUgZG9jcyBmb3IgYWRkS2V5d29yZFwiKVxuICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWYgPSBrd2RPckRlZlxuICAgICAga2V5d29yZCA9IGRlZi5rZXl3b3JkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkS2V5d29yZHM6IGtleXdvcmQgbXVzdCBiZSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5XCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKVxuICAgIH1cblxuICAgIGNoZWNrS2V5d29yZC5jYWxsKHRoaXMsIGtleXdvcmQsIGRlZilcbiAgICBpZiAoIWRlZikge1xuICAgICAgZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBrZXl3b3JkTWV0YXNjaGVtYS5jYWxsKHRoaXMsIGRlZilcbiAgICBjb25zdCBkZWZpbml0aW9uOiBBZGRlZEtleXdvcmREZWZpbml0aW9uID0ge1xuICAgICAgLi4uZGVmLFxuICAgICAgdHlwZTogZ2V0SlNPTlR5cGVzKGRlZi50eXBlKSxcbiAgICAgIHNjaGVtYVR5cGU6IGdldEpTT05UeXBlcyhkZWYuc2NoZW1hVHlwZSksXG4gICAgfVxuICAgIGVhY2hJdGVtKFxuICAgICAga2V5d29yZCxcbiAgICAgIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgIDogKGspID0+IGRlZmluaXRpb24udHlwZS5mb3JFYWNoKCh0KSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbiwgdCkpXG4gICAgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRLZXl3b3JkKGtleXdvcmQ6IHN0cmluZyk6IEFkZGVkS2V5d29yZERlZmluaXRpb24gfCBib29sZWFuIHtcbiAgICBjb25zdCBydWxlID0gdGhpcy5SVUxFUy5hbGxba2V5d29yZF1cbiAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZVxuICB9XG5cbiAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgcmVtb3ZlS2V5d29yZChrZXl3b3JkOiBzdHJpbmcpOiBBanYge1xuICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgIGNvbnN0IHtSVUxFU30gPSB0aGlzXG4gICAgZGVsZXRlIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdXG4gICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXVxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZClcbiAgICAgIGlmIChpID49IDApIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQWRkIGZvcm1hdFxuICBhZGRGb3JtYXQobmFtZTogc3RyaW5nLCBmb3JtYXQ6IEZvcm1hdCk6IEFqdiB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIikgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpXG4gICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVycm9yc1RleHQoXG4gICAgZXJyb3JzOiBFcnJvck9iamVjdFtdIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHtzZXBhcmF0b3IgPSBcIiwgXCIsIGRhdGFWYXIgPSBcImRhdGFcIn06IEVycm9yc1RleHRPcHRpb25zID0ge30gLy8gb3B0aW9uYWwgb3B0aW9ucyB3aXRoIHByb3BlcnRpZXMgYHNlcGFyYXRvcmAgYW5kIGBkYXRhVmFyYFxuICApOiBzdHJpbmcge1xuICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApIHJldHVybiBcIk5vIGVycm9yc1wiXG4gICAgcmV0dXJuIGVycm9yc1xuICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKVxuICB9XG5cbiAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWE6IEFueVNjaGVtYU9iamVjdCwga2V5d29yZHNKc29uUG9pbnRlcnM6IHN0cmluZ1tdKTogQW55U2NoZW1hT2JqZWN0IHtcbiAgICBjb25zdCBydWxlcyA9IHRoaXMuUlVMRVMuYWxsXG4gICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpXG4gICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSkgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWFcbiAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ21lbnRzKSBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ10gYXMgQW55U2NoZW1hT2JqZWN0XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldXG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKSBjb250aW51ZVxuICAgICAgICBjb25zdCB7JGRhdGF9ID0gcnVsZS5kZWZpbml0aW9uXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV0gYXMgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgICAgIGlmICgkZGF0YSAmJiBzY2hlbWEpIGtleXdvcmRzW2tleV0gPSBzY2hlbWFPckRhdGEoc2NoZW1hKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXRhU2NoZW1hXG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXM6IHtbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBzdHJpbmd9LCByZWdleD86IFJlZ0V4cCk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXVxuICAgICAgaWYgKCFyZWdleCB8fCByZWdleC50ZXN0KGtleVJlZikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl1cbiAgICAgICAgfSBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpXG4gICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FkZFNjaGVtYShcbiAgICBzY2hlbWE6IEFueVNjaGVtYSxcbiAgICBtZXRhPzogYm9vbGVhbixcbiAgICBiYXNlSWQ/OiBzdHJpbmcsXG4gICAgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsXG4gICAgYWRkU2NoZW1hID0gdGhpcy5vcHRzLmFkZFVzZWRTY2hlbWFcbiAgKTogU2NoZW1hRW52IHtcbiAgICBsZXQgaWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0cy5qdGQpIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdFwiKVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIikgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0IG9yIGJvb2xlYW5cIilcbiAgICB9XG4gICAgbGV0IHNjaCA9IHRoaXMuX2NhY2hlLmdldChzY2hlbWEpXG4gICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gc2NoXG5cbiAgICBiYXNlSWQgPSBub3JtYWxpemVJZChpZCB8fCBiYXNlSWQpXG4gICAgY29uc3QgbG9jYWxSZWZzID0gZ2V0U2NoZW1hUmVmcy5jYWxsKHRoaXMsIHNjaGVtYSwgYmFzZUlkKVxuICAgIHNjaCA9IG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzfSlcbiAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKVxuICAgIGlmIChhZGRTY2hlbWEgJiYgIWJhc2VJZC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgLy8gVE9ETyBhdG0gaXQgaXMgYWxsb3dlZCB0byBvdmVyd3JpdGUgc2NoZW1hcyB3aXRob3V0IGlkIChpbnN0ZWFkIG9mIG5vdCBhZGRpbmcgdGhlbSlcbiAgICAgIGlmIChiYXNlSWQpIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZClcbiAgICAgIHRoaXMucmVmc1tiYXNlSWRdID0gc2NoXG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZVNjaGVtYSkgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpXG4gICAgcmV0dXJuIHNjaFxuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tVbmlxdWUoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNjaGVtYXNbaWRdIHx8IHRoaXMucmVmc1tpZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJHtpZH1cIiBhbHJlYWR5IGV4aXN0c2ApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29tcGlsZVNjaGVtYUVudihzY2g6IFNjaGVtYUVudik6IEFueVZhbGlkYXRlRnVuY3Rpb24ge1xuICAgIGlmIChzY2gubWV0YSkgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKVxuICAgIGVsc2UgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaClcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghc2NoLnZhbGlkYXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gIH1cblxuICBwcml2YXRlIF9jb21waWxlTWV0YVNjaGVtYShzY2g6IFNjaGVtYUVudik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzXG4gICAgdGhpcy5vcHRzID0gdGhpcy5fbWV0YU9wdHNcbiAgICB0cnkge1xuICAgICAgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvcnNUZXh0T3B0aW9ucyB7XG4gIHNlcGFyYXRvcj86IHN0cmluZ1xuICBkYXRhVmFyPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhcbiAgdGhpczogQWp2LFxuICBjaGVja09wdHM6IE9wdGlvbnNJbmZvPFJlbW92ZWRPcHRpb25zIHwgRGVwcmVjYXRlZE9wdGlvbnM+LFxuICBvcHRpb25zOiBPcHRpb25zICYgUmVtb3ZlZE9wdGlvbnMsXG4gIG1zZzogc3RyaW5nLFxuICBsb2c6IFwid2FyblwiIHwgXCJlcnJvclwiID0gXCJlcnJvclwiXG4pOiB2b2lkIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgY29uc3Qgb3B0ID0ga2V5IGFzIGtleW9mIHR5cGVvZiBjaGVja09wdHNcbiAgICBpZiAob3B0IGluIG9wdGlvbnMpIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjaEVudih0aGlzOiBBanYsIGtleVJlZjogc3RyaW5nKTogU2NoZW1hRW52IHwgc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAga2V5UmVmID0gbm9ybWFsaXplSWQoa2V5UmVmKSAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdXG59XG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKHRoaXM6IEFqdik6IHZvaWQge1xuICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzXG4gIGlmICghb3B0c1NjaGVtYXMpIHJldHVyblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKVxuICBlbHNlIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKSB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldIGFzIEFueVNjaGVtYSwga2V5KVxufVxuXG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cyh0aGlzOiBBanYpOiB2b2lkIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMub3B0cy5mb3JtYXRzKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV1cbiAgICBpZiAoZm9ybWF0KSB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKFxuICB0aGlzOiBBanYsXG4gIGRlZnM6IFZvY2FidWxhcnkgfCB7W0sgaW4gc3RyaW5nXT86IEtleXdvcmREZWZpbml0aW9ufVxuKTogdm9pZCB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZnMpKSB7XG4gICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpXG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKVxuICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgIGNvbnN0IGRlZiA9IGRlZnNba2V5d29yZF0gYXMgS2V5d29yZERlZmluaXRpb25cbiAgICBpZiAoIWRlZi5rZXl3b3JkKSBkZWYua2V5d29yZCA9IGtleXdvcmRcbiAgICB0aGlzLmFkZEtleXdvcmQoZGVmKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKHRoaXM6IEFqdik6IEluc3RhbmNlT3B0aW9ucyB7XG4gIGNvbnN0IG1ldGFPcHRzID0gey4uLnRoaXMub3B0c31cbiAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUykgZGVsZXRlIG1ldGFPcHRzW29wdF1cbiAgcmV0dXJuIG1ldGFPcHRzXG59XG5cbmNvbnN0IG5vTG9ncyA9IHtsb2coKSB7fSwgd2FybigpIHt9LCBlcnJvcigpIHt9fVxuXG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyPzogUGFydGlhbDxMb2dnZXI+IHwgZmFsc2UpOiBMb2dnZXIge1xuICBpZiAobG9nZ2VyID09PSBmYWxzZSkgcmV0dXJuIG5vTG9nc1xuICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIHJldHVybiBjb25zb2xlXG4gIGlmIChsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcikgcmV0dXJuIGxvZ2dlciBhcyBMb2dnZXJcbiAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKVxufVxuXG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pXG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZCh0aGlzOiBBanYsIGtleXdvcmQ6IHN0cmluZyB8IHN0cmluZ1tdLCBkZWY/OiBLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICBlYWNoSXRlbShrZXl3b3JkLCAoa3dkKSA9PiB7XG4gICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYClcbiAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApXG4gIH0pXG4gIGlmICghZGVmKSByZXR1cm5cbiAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEga2V5d29yZCBtdXN0IGhhdmUgXCJjb2RlXCIgb3IgXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSdWxlKFxuICB0aGlzOiBBanYsXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgZGVmaW5pdGlvbj86IEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIGRhdGFUeXBlPzogSlNPTlR5cGVcbik6IHZvaWQge1xuICBjb25zdCBwb3N0ID0gZGVmaW5pdGlvbj8ucG9zdFxuICBpZiAoZGF0YVR5cGUgJiYgcG9zdCkgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpXG4gIGNvbnN0IHtSVUxFU30gPSB0aGlzXG4gIGxldCBydWxlR3JvdXAgPSBwb3N0ID8gUlVMRVMucG9zdCA6IFJVTEVTLnJ1bGVzLmZpbmQoKHt0eXBlOiB0fSkgPT4gdCA9PT0gZGF0YVR5cGUpXG4gIGlmICghcnVsZUdyb3VwKSB7XG4gICAgcnVsZUdyb3VwID0ge3R5cGU6IGRhdGFUeXBlLCBydWxlczogW119XG4gICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApXG4gIH1cbiAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSB0cnVlXG4gIGlmICghZGVmaW5pdGlvbikgcmV0dXJuXG5cbiAgY29uc3QgcnVsZTogUnVsZSA9IHtcbiAgICBrZXl3b3JkLFxuICAgIGRlZmluaXRpb246IHtcbiAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICB0eXBlOiBnZXRKU09OVHlwZXMoZGVmaW5pdGlvbi50eXBlKSxcbiAgICAgIHNjaGVtYVR5cGU6IGdldEpTT05UeXBlcyhkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgIH0sXG4gIH1cbiAgaWYgKGRlZmluaXRpb24uYmVmb3JlKSBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSlcbiAgZWxzZSBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKVxuICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlXG4gIGRlZmluaXRpb24uaW1wbGVtZW50cz8uZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSlcbn1cblxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZSh0aGlzOiBBanYsIHJ1bGVHcm91cDogUnVsZUdyb3VwLCBydWxlOiBSdWxlLCBiZWZvcmU6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBpID0gcnVsZUdyb3VwLnJ1bGVzLmZpbmRJbmRleCgoX3J1bGUpID0+IF9ydWxlLmtleXdvcmQgPT09IGJlZm9yZSlcbiAgaWYgKGkgPj0gMCkge1xuICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSlcbiAgfSBlbHNlIHtcbiAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKVxuICAgIHRoaXMubG9nZ2VyLndhcm4oYHJ1bGUgJHtiZWZvcmV9IGlzIG5vdCBkZWZpbmVkYClcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYSh0aGlzOiBBanYsIGRlZjogS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgbGV0IHttZXRhU2NoZW1hfSA9IGRlZlxuICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSlcbiAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpXG59XG5cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAkcmVmOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxufVxuXG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hOiBBbnlTY2hlbWEpOiBBbnlTY2hlbWFPYmplY3Qge1xuICByZXR1cm4ge2FueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl19XG59XG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiaWRcIixcbiAgY29kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05PVCBTVVBQT1JURUQ6IGtleXdvcmQgXCJpZFwiLCB1c2UgXCIkaWRcIiBmb3Igc2NoZW1hIElEJylcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCBNaXNzaW5nUmVmRXJyb3IgZnJvbSBcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCJcbmltcG9ydCB7Y2FsbFZhbGlkYXRlQ29kZX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBuaWwsIHN0cmluZ2lmeSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiXG5pbXBvcnQge1NjaGVtYUVudiwgcmVzb2x2ZVJlZn0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuaW1wb3J0IHttZXJnZUV2YWx1YXRlZH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIiRyZWZcIixcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWE6ICRyZWYsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGZ9ID0gaXRcbiAgICBjb25zdCB7cm9vdH0gPSBlbnZcbiAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZCkgcmV0dXJuIGNhbGxSb290UmVmKClcbiAgICBjb25zdCBzY2hPckVudiA9IHJlc29sdmVSZWYuY2FsbChzZWxmLCByb290LCBiYXNlSWQsICRyZWYpXG4gICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBNaXNzaW5nUmVmRXJyb3IoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKVxuICAgIGlmIChzY2hPckVudiBpbnN0YW5jZW9mIFNjaGVtYUVudikgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudilcbiAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KVxuXG4gICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKTogdm9pZCB7XG4gICAgICBpZiAoZW52ID09PSByb290KSByZXR1cm4gY2FsbFJlZihjeHQsIHZhbGlkYXRlTmFtZSwgZW52LCBlbnYuJGFzeW5jKVxuICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwge3JlZjogcm9vdH0pXG4gICAgICByZXR1cm4gY2FsbFJlZihjeHQsIF9gJHtyb290TmFtZX0udmFsaWRhdGVgLCByb290LCByb290LiRhc3luYylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoOiBTY2hlbWFFbnYpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaClcbiAgICAgIGNhbGxSZWYoY3h0LCB2LCBzY2gsIHNjaC4kYXN5bmMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaDogQW55U2NoZW1hKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXG4gICAgICAgIFwic2NoZW1hXCIsXG4gICAgICAgIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7cmVmOiBzY2gsIGNvZGU6IHN0cmluZ2lmeShzY2gpfSA6IHtyZWY6IHNjaH1cbiAgICAgIClcbiAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgICAgc2NoZW1hUGF0aDogbmlsLFxuICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQ6IEtleXdvcmRDeHQsIHNjaDogU2NoZW1hRW52KTogQ29kZSB7XG4gIGNvbnN0IHtnZW59ID0gY3h0XG4gIHJldHVybiBzY2gudmFsaWRhdGVcbiAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwge3JlZjogc2NoLnZhbGlkYXRlfSlcbiAgICA6IF9gJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwge3JlZjogc2NofSl9LnZhbGlkYXRlYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbFJlZihjeHQ6IEtleXdvcmRDeHQsIHY6IENvZGUsIHNjaD86IFNjaGVtYUVudiwgJGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBpdH0gPSBjeHRcbiAgY29uc3Qge2FsbEVycm9ycywgc2NoZW1hRW52OiBlbnYsIG9wdHN9ID0gaXRcbiAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBOLnRoaXMgOiBuaWxcbiAgaWYgKCRhc3luYykgY2FsbEFzeW5jUmVmKClcbiAgZWxzZSBjYWxsU3luY1JlZigpXG5cbiAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCk6IHZvaWQge1xuICAgIGlmICghZW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIilcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICAgIGdlbi50cnkoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGdlbi5jb2RlKF9gYXdhaXQgJHtjYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCl9YClcbiAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KSAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBnZW4uaWYoX2AhKCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvciBhcyBOYW1lfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpXG4gICAgICAgIGFkZEVycm9yc0Zyb20oZSlcbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgfVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG4gIH1cblxuICBmdW5jdGlvbiBjYWxsU3luY1JlZigpOiB2b2lkIHtcbiAgICBjeHQucmVzdWx0KFxuICAgICAgY2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpLFxuICAgICAgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSxcbiAgICAgICgpID0+IGFkZEVycm9yc0Zyb20odilcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZTogQ29kZSk6IHZvaWQge1xuICAgIGNvbnN0IGVycnMgPSBfYCR7c291cmNlfS5lcnJvcnNgXG4gICAgZ2VuLmFzc2lnbihOLnZFcnJvcnMsIF9gJHtOLnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7Ti52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKSAvLyBUT0RPIHRhZ2dlZFxuICAgIGdlbi5hc3NpZ24oTi5lcnJvcnMsIF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGApXG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZTogQ29kZSk6IHZvaWQge1xuICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZCkgcmV0dXJuXG4gICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gc2NoPy52YWxpZGF0ZT8uZXZhbHVhdGVkXG4gICAgLy8gVE9ETyByZWZhY3RvclxuICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgX2Ake3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYClcbiAgICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHByb3BzLCBpdC5wcm9wcywgTmFtZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgIGlmIChzY2hFdmFsdWF0ZWQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCBfYCR7c291cmNlfS5ldmFsdWF0ZWQuaXRlbXNgKVxuICAgICAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBOYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBpZEtleXdvcmQgZnJvbSBcIi4vaWRcIlxuaW1wb3J0IHJlZktleXdvcmQgZnJvbSBcIi4vcmVmXCJcblxuY29uc3QgY29yZTogVm9jYWJ1bGFyeSA9IFtcbiAgXCIkc2NoZW1hXCIsXG4gIFwiJGlkXCIsXG4gIFwiJGRlZnNcIixcbiAgXCIkdm9jYWJ1bGFyeVwiLFxuICB7a2V5d29yZDogXCIkY29tbWVudFwifSxcbiAgXCJkZWZpbml0aW9uc1wiLFxuICBpZEtleXdvcmQsXG4gIHJlZktleXdvcmQsXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuY29uc3Qgb3BzID0gb3BlcmF0b3JzXG5cbnR5cGUgS3dkID0gXCJtYXhpbXVtXCIgfCBcIm1pbmltdW1cIiB8IFwiZXhjbHVzaXZlTWF4aW11bVwiIHwgXCJleGNsdXNpdmVNaW5pbXVtXCJcblxudHlwZSBDb21wYXJpc29uID0gXCI8PVwiIHwgXCI+PVwiIHwgXCI8XCIgfCBcIj5cIlxuXG5jb25zdCBLV0RzOiB7W0sgaW4gS3dkXToge29rU3RyOiBDb21wYXJpc29uOyBvazogQ29kZTsgZmFpbDogQ29kZX19ID0ge1xuICBtYXhpbXVtOiB7b2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVH0sXG4gIG1pbmltdW06IHtva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUfSxcbiAgZXhjbHVzaXZlTWF4aW11bToge29rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURX0sXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHtva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEV9LFxufVxuXG5leHBvcnQgdHlwZSBMaW1pdE51bWJlckVycm9yID0gRXJyb3JPYmplY3Q8XG4gIEt3ZCxcbiAge2xpbWl0OiBudW1iZXI7IGNvbXBhcmlzb246IENvbXBhcmlzb259LFxuICBudW1iZXIgfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IGJlICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICBwYXJhbXM6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+XG4gICAgX2B7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgdHlwZTogXCJudW1iZXJcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlfSA9IGN4dFxuICAgIGN4dC5mYWlsJGRhdGEoX2Ake2RhdGF9ICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuZXhwb3J0IHR5cGUgTXVsdGlwbGVPZkVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwibXVsdGlwbGVPZlwiLFxuICB7bXVsdGlwbGVPZjogbnVtYmVyfSxcbiAgbnVtYmVyIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBiZSBtdWx0aXBsZSBvZiAke3NjaGVtYUNvZGV9YCxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgdHlwZTogXCJudW1iZXJcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uXG4gICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKVxuICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICA/IF9gTWF0aC5hYnMoTWF0aC5yb3VuZCgke3Jlc30pIC0gJHtyZXN9KSA+IDFlLSR7cHJlY31gXG4gICAgICA6IF9gJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYFxuICAgIGN4dC5mYWlsJGRhdGEoX2AoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICIvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoXG4gIGxldCBsZW5ndGggPSAwXG4gIGxldCBwb3MgPSAwXG4gIGxldCB2YWx1ZTogbnVtYmVyXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBsZW5ndGgrK1xuICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspXG4gICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKVxuICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkgcG9zKysgLy8gbG93IHN1cnJvZ2F0ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoXG59XG5cbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgdWNzMmxlbmd0aCBmcm9tIFwiLi4vLi4vcnVudGltZS91Y3MybGVuZ3RoXCJcblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2Uoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSB7XG4gICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIlxuICAgIHJldHVybiBzdHJgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYFxuICB9LFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY29uc3QgbGVuID1cbiAgICAgIGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyBfYCR7ZGF0YX0ubGVuZ3RoYCA6IF9gJHt1c2VGdW5jKGN4dC5nZW4sIHVjczJsZW5ndGgpfSgke2RhdGF9KWBcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtsZW59ICR7b3B9ICR7c2NoZW1hQ29kZX1gKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge3VzZVBhdHRlcm59IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuZXhwb3J0IHR5cGUgUGF0dGVybkVycm9yID0gRXJyb3JPYmplY3Q8XCJwYXR0ZXJuXCIsIHtwYXR0ZXJuOiBzdHJpbmd9LCBzdHJpbmcgfCB7JGRhdGE6IHN0cmluZ30+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInBhdHRlcm5cIixcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICAvLyBUT0RPIHJlZ2V4cCBzaG91bGQgYmUgd3JhcHBlZCBpbiB0cnkvY2F0Y2hzXG4gICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIlxuICAgIGNvbnN0IHJlZ0V4cCA9ICRkYXRhID8gX2AobmV3IFJlZ0V4cCgke3NjaGVtYUNvZGV9LCAke3V9KSlgIDogdXNlUGF0dGVybihjeHQsIHNjaGVtYSlcbiAgICBjeHQuZmFpbCRkYXRhKF9gISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2Uoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSB7XG4gICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gcHJvcGVydGllc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZX0gPSBjeHRcbiAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY3h0LmZhaWwkZGF0YShfYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtcbiAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCxcbiAgY2hlY2tNaXNzaW5nUHJvcCxcbiAgcmVwb3J0TWlzc2luZ1Byb3AsXG4gIHByb3BlcnR5SW5EYXRhLFxuICBub1Byb3BlcnR5SW5EYXRhLFxufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIHN0ciwgbmlsLCBub3QsIE5hbWUsIENvZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHtjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBSZXF1aXJlZEVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwicmVxdWlyZWRcIixcbiAge21pc3NpbmdQcm9wZXJ0eTogc3RyaW5nfSxcbiAgc3RyaW5nW10gfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bWlzc2luZ1Byb3BlcnR5fX0pID0+IHN0cmBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bWlzc2luZ1Byb3BlcnR5fX0pID0+IF9ge21pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvcHRzfSA9IGl0XG4gICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBvcHRzLmxvb3BSZXF1aXJlZFxuICAgIGlmIChpdC5hbGxFcnJvcnMpIGFsbEVycm9yc01vZGUoKVxuICAgIGVsc2UgZXhpdE9uRXJyb3JNb2RlKClcblxuICAgIGlmIChvcHRzLnN0cmljdFJlcXVpcmVkKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IGN4dC5wYXJlbnRTY2hlbWEucHJvcGVydGllc1xuICAgICAgY29uc3Qge2RlZmluZWRQcm9wZXJ0aWVzfSA9IGN4dC5pdFxuICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHByb3BzPy5bcmVxdWlyZWRLZXldID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGhcbiAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgXG4gICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCk6IHZvaWQge1xuICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEobmlsLCBsb29wQWxsUmVxdWlyZWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKTogdm9pZCB7XG4gICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIilcbiAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSlcbiAgICAgICAgY3h0Lm9rKHZhbGlkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuLmlmKGNoZWNrTWlzc2luZ1Byb3AoY3h0LCBzY2hlbWEsIG1pc3NpbmcpKVxuICAgICAgICByZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpXG4gICAgICAgIGdlbi5lbHNlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKTogdm9pZCB7XG4gICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUgYXMgQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBwcm9wfSlcbiAgICAgICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiBjeHQuZXJyb3IoKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nOiBOYW1lLCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICAgICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nfSlcbiAgICAgIGdlbi5mb3JPZihcbiAgICAgICAgbWlzc2luZyxcbiAgICAgICAgc2NoZW1hQ29kZSBhcyBDb2RlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKVxuICAgICAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICAgICAgZ2VuLmJyZWFrKClcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBuaWxcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIlxuICAgIHJldHVybiBzdHJgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGV9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBvcGVyYXRvcnMuR1QgOiBvcGVyYXRvcnMuTFRcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5pbXBvcnQgKiBhcyBlcXVhbCBmcm9tIFwiZmFzdC1kZWVwLWVxdWFsXCJcblxudHlwZSBFcXVhbCA9IHR5cGVvZiBlcXVhbCAmIHtjb2RlOiBzdHJpbmd9XG47KGVxdWFsIGFzIEVxdWFsKS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnXG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsIGFzIEVxdWFsXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtjaGVja0RhdGFUeXBlcywgZ2V0U2NoZW1hVHlwZXMsIERhdGFUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiXG5pbXBvcnQge18sIHN0ciwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgVW5pcXVlSXRlbXNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcInVuaXF1ZUl0ZW1zXCIsXG4gIHtpOiBudW1iZXI7IGo6IG51bWJlcn0sXG4gIGJvb2xlYW4gfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7aSwgan19KSA9PlxuICAgIHN0cmBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtpLCBqfX0pID0+IF9ge2k6ICR7aX0sIGo6ICR7an19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/IGdldFNjaGVtYVR5cGVzKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXVxuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZVVuaXF1ZUl0ZW1zLCBfYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYClcbiAgICBjeHQub2sodmFsaWQpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZUl0ZW1zKCk6IHZvaWQge1xuICAgICAgY29uc3QgaSA9IGdlbi5sZXQoXCJpXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICAgICAgY29uc3QgaiA9IGdlbi5sZXQoXCJqXCIpXG4gICAgICBjeHQuc2V0UGFyYW1zKHtpLCBqfSlcbiAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICBnZW4uaWYoX2Ake2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGl0ZW1UeXBlcy5sZW5ndGggPiAwICYmICFpdGVtVHlwZXMuc29tZSgodCkgPT4gdCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcE4oaTogTmFtZSwgajogTmFtZSk6IHZvaWQge1xuICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKVxuICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXMoaXRlbVR5cGVzLCBpdGVtLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKVxuICAgICAgY29uc3QgaW5kaWNlcyA9IGdlbi5jb25zdChcImluZGljZXNcIiwgX2B7fWApXG4gICAgICBnZW4uZm9yKF9gOyR7aX0tLTtgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5sZXQoaXRlbSwgX2Ake2RhdGF9WyR7aX1dYClcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgX2Bjb250aW51ZWApXG4gICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSkgZ2VuLmlmKF9gdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsIF9gJHtpdGVtfSArPSBcIl9cImApXG4gICAgICAgIGdlblxuICAgICAgICAgIC5pZihfYHR5cGVvZiAke2luZGljZXN9WyR7aXRlbX1dID09IFwibnVtYmVyXCJgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKGosIF9gJHtpbmRpY2VzfVske2l0ZW19XWApXG4gICAgICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jb2RlKF9gJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wTjIoaTogTmFtZSwgajogTmFtZSk6IHZvaWQge1xuICAgICAgY29uc3QgZXFsID0gdXNlRnVuYyhnZW4sIGVxdWFsKVxuICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpXG4gICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcihfYDske2l9LS07YCwgKCkgPT5cbiAgICAgICAgZ2VuLmZvcihfYCR7an0gPSAke2l9OyAke2p9LS07YCwgKCkgPT5cbiAgICAgICAgICBnZW4uaWYoX2Ake2VxbH0oJHtkYXRhfVske2l9XSwgJHtkYXRhfVske2p9XSlgLCAoKSA9PiB7XG4gICAgICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKG91dGVyKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7X30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgQ29uc3RFcnJvciA9IEVycm9yT2JqZWN0PFwiY29uc3RcIiwge2FsbG93ZWRWYWx1ZTogYW55fT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJjb25zdFwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYUNvZGUsIHNjaGVtYX0gPSBjeHRcbiAgICBpZiAoJGRhdGEgfHwgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpKSB7XG4gICAgICBjeHQuZmFpbCRkYXRhKF9gISR7dXNlRnVuYyhnZW4sIGVxdWFsKX0oJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSlgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjeHQuZmFpbChfYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIG9yLCBOYW1lLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgZXF1YWwgZnJvbSBcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIlxuXG5leHBvcnQgdHlwZSBFbnVtRXJyb3IgPSBFcnJvck9iamVjdDxcImVudW1cIiwge2FsbG93ZWRWYWx1ZXM6IGFueVtdfSwgYW55W10gfCB7JGRhdGE6IHN0cmluZ30+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZW51bVwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcImVudW0gbXVzdCBoYXZlIG5vbi1lbXB0eSBhcnJheVwiKVxuICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW1cbiAgICBsZXQgZXFsOiBOYW1lIHwgdW5kZWZpbmVkXG4gICAgY29uc3QgZ2V0RXFsID0gKCk6IE5hbWUgPT4gKGVxbCA/Pz0gdXNlRnVuYyhnZW4sIGVxdWFsKSlcblxuICAgIGxldCB2YWxpZDogQ29kZVxuICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICAgIGNvbnN0IHZTY2hlbWEgPSBnZW4uY29uc3QoXCJ2U2NoZW1hXCIsIHNjaGVtYUNvZGUpXG4gICAgICB2YWxpZCA9IG9yKC4uLnNjaGVtYS5tYXAoKF94OiB1bmtub3duLCBpOiBudW1iZXIpID0+IGVxdWFsQ29kZSh2U2NoZW1hLCBpKSkpXG4gICAgfVxuICAgIGN4dC5wYXNzKHZhbGlkKVxuXG4gICAgZnVuY3Rpb24gbG9vcEVudW0oKTogdm9pZCB7XG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSBhcyBDb2RlLCAodikgPT5cbiAgICAgICAgZ2VuLmlmKF9gJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hOiBOYW1lLCBpOiBudW1iZXIpOiBDb2RlIHtcbiAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXVxuICAgICAgcmV0dXJuIHR5cGVvZiBzY2ggPT09IFwib2JqZWN0XCIgJiYgc2NoICE9PSBudWxsXG4gICAgICAgID8gX2Ake2dldEVxbCgpfSgke2RhdGF9LCAke3ZTY2hlbWF9WyR7aX1dKWBcbiAgICAgICAgOiBfYCR7ZGF0YX0gPT09ICR7c2NofWBcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtFcnJvck9iamVjdCwgVm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBsaW1pdE51bWJlciwge0xpbWl0TnVtYmVyRXJyb3J9IGZyb20gXCIuL2xpbWl0TnVtYmVyXCJcbmltcG9ydCBtdWx0aXBsZU9mLCB7TXVsdGlwbGVPZkVycm9yfSBmcm9tIFwiLi9tdWx0aXBsZU9mXCJcbmltcG9ydCBsaW1pdExlbmd0aCBmcm9tIFwiLi9saW1pdExlbmd0aFwiXG5pbXBvcnQgcGF0dGVybiwge1BhdHRlcm5FcnJvcn0gZnJvbSBcIi4vcGF0dGVyblwiXG5pbXBvcnQgbGltaXRQcm9wZXJ0aWVzIGZyb20gXCIuL2xpbWl0UHJvcGVydGllc1wiXG5pbXBvcnQgcmVxdWlyZWQsIHtSZXF1aXJlZEVycm9yfSBmcm9tIFwiLi9yZXF1aXJlZFwiXG5pbXBvcnQgbGltaXRJdGVtcyBmcm9tIFwiLi9saW1pdEl0ZW1zXCJcbmltcG9ydCB1bmlxdWVJdGVtcywge1VuaXF1ZUl0ZW1zRXJyb3J9IGZyb20gXCIuL3VuaXF1ZUl0ZW1zXCJcbmltcG9ydCBjb25zdEtleXdvcmQsIHtDb25zdEVycm9yfSBmcm9tIFwiLi9jb25zdFwiXG5pbXBvcnQgZW51bUtleXdvcmQsIHtFbnVtRXJyb3J9IGZyb20gXCIuL2VudW1cIlxuXG5jb25zdCB2YWxpZGF0aW9uOiBWb2NhYnVsYXJ5ID0gW1xuICAvLyBudW1iZXJcbiAgbGltaXROdW1iZXIsXG4gIG11bHRpcGxlT2YsXG4gIC8vIHN0cmluZ1xuICBsaW1pdExlbmd0aCxcbiAgcGF0dGVybixcbiAgLy8gb2JqZWN0XG4gIGxpbWl0UHJvcGVydGllcyxcbiAgcmVxdWlyZWQsXG4gIC8vIGFycmF5XG4gIGxpbWl0SXRlbXMsXG4gIHVuaXF1ZUl0ZW1zLFxuICAvLyBhbnlcbiAge2tleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXX0sXG4gIHtrZXl3b3JkOiBcIm51bGxhYmxlXCIsIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwifSxcbiAgY29uc3RLZXl3b3JkLFxuICBlbnVtS2V5d29yZCxcbl1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGlvblxuXG50eXBlIExpbWl0RXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJtYXhJdGVtc1wiIHwgXCJtaW5JdGVtc1wiIHwgXCJtaW5Qcm9wZXJ0aWVzXCIgfCBcIm1heFByb3BlcnRpZXNcIiB8IFwibWluTGVuZ3RoXCIgfCBcIm1heExlbmd0aFwiLFxuICB7bGltaXQ6IG51bWJlcn0sXG4gIG51bWJlciB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5leHBvcnQgdHlwZSBWYWxpZGF0aW9uS2V5d29yZEVycm9yID1cbiAgfCBMaW1pdEVycm9yXG4gIHwgTGltaXROdW1iZXJFcnJvclxuICB8IE11bHRpcGxlT2ZFcnJvclxuICB8IFBhdHRlcm5FcnJvclxuICB8IFJlcXVpcmVkRXJyb3JcbiAgfCBVbmlxdWVJdGVtc0Vycm9yXG4gIHwgQ29uc3RFcnJvclxuICB8IEVudW1FcnJvclxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBub3QsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgQWRkaXRpb25hbEl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcImFkZGl0aW9uYWxJdGVtc1wiLCB7bGltaXQ6IG51bWJlcn0sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bGVufX0pID0+IHN0cmBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bGVufX0pID0+IF9ge2xpbWl0OiAke2xlbn19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIgYXMgY29uc3QsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtpdGVtc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsICdcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGlnbm9yZWQgd2hlbiBcIml0ZW1zXCIgaXMgbm90IGFuIGFycmF5IG9mIHNjaGVtYXMnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpXG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQ6IEtleXdvcmRDeHQsIGl0ZW1zOiBBbnlTY2hlbWFbXSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBpdC5pdGVtcyA9IHRydWVcbiAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGN4dC5zZXRQYXJhbXMoe2xlbjogaXRlbXMubGVuZ3RofSlcbiAgICBjeHQucGFzcyhfYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi52YXIoXCJ2YWxpZFwiLCBfYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKSAvLyBUT0RPIHZhclxuICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSlcbiAgICBjeHQub2sodmFsaWQpXG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoe2tleXdvcmQsIGRhdGFQcm9wOiBpLCBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtfSwgdmFsaWQpXG4gICAgICBpZiAoIWl0LmFsbEVycm9ycykgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hLCBBbnlTY2hlbWFPYmplY3R9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtffSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIG1lcmdlRXZhbHVhdGVkLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHt2YWxpZGF0ZUFycmF5fSBmcm9tIFwiLi4vY29kZVwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJib29sZWFuXCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7c2NoZW1hLCBpdH0gPSBjeHRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSlcbiAgICBpdC5pdGVtcyA9IHRydWVcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGN4dC5vayh2YWxpZGF0ZUFycmF5KGN4dCkpXG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKFxuICBjeHQ6IEtleXdvcmRDeHQsXG4gIGV4dHJhSXRlbXM6IHN0cmluZyxcbiAgc2NoQXJyOiBBbnlTY2hlbWFbXSA9IGN4dC5zY2hlbWFcbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSlcbiAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcylcbiAgfVxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICBzY2hBcnIuZm9yRWFjaCgoc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkgcmV0dXJuXG4gICAgZ2VuLmlmKF9gJHtsZW59ID4gJHtpfWAsICgpID0+XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2g6IEFueVNjaGVtYU9iamVjdCk6IHZvaWQge1xuICAgIGNvbnN0IHtvcHRzLCBlcnJTY2hlbWFQYXRofSA9IGl0XG4gICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGhcbiAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKVxuICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgXG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgb3B0cy5zdHJpY3RUdXBsZXMpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQge3ZhbGlkYXRlVHVwbGV9IGZyb20gXCIuL2l0ZW1zXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicHJlZml4SXRlbXNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJhcnJheVwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGNvZGU6IChjeHQpID0+IHZhbGlkYXRlVHVwbGUoY3h0LCBcIml0ZW1zXCIpLFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7dmFsaWRhdGVBcnJheX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHt2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtc30gZnJvbSBcIi4vYWRkaXRpb25hbEl0ZW1zXCJcblxuZXhwb3J0IHR5cGUgSXRlbXNFcnJvciA9IEVycm9yT2JqZWN0PFwiaXRlbXNcIiwge2xpbWl0OiBudW1iZXJ9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2xlbn19KSA9PiBzdHJgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2xlbn19KSA9PiBfYHtsaW1pdDogJHtsZW59fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge3ByZWZpeEl0ZW1zfSA9IHBhcmVudFNjaGVtYVxuICAgIGl0Lml0ZW1zID0gdHJ1ZVxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgaWYgKHByZWZpeEl0ZW1zKSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIHByZWZpeEl0ZW1zKVxuICAgIGVsc2UgY3h0Lm9rKHZhbGlkYXRlQXJyYXkoY3h0KSlcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgQ29udGFpbnNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcImNvbnRhaW5zXCIsXG4gIHttaW5Db250YWluczogbnVtYmVyOyBtYXhDb250YWlucz86IG51bWJlcn0sXG4gIEFueVNjaGVtYVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHttaW4sIG1heH19KSA9PlxuICAgIG1heCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHN0cmBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IHZhbGlkIGl0ZW0ocylgXG4gICAgICA6IHN0cmBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bWluLCBtYXh9fSkgPT5cbiAgICBtYXggPT09IHVuZGVmaW5lZCA/IF9ge21pbkNvbnRhaW5zOiAke21pbn19YCA6IF9ge21pbkNvbnRhaW5zOiAke21pbn0sIG1heENvbnRhaW5zOiAke21heH19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdH0gPSBjeHRcbiAgICBsZXQgbWluOiBudW1iZXJcbiAgICBsZXQgbWF4OiBudW1iZXIgfCB1bmRlZmluZWRcbiAgICBjb25zdCB7bWluQ29udGFpbnMsIG1heENvbnRhaW5zfSA9IHBhcmVudFNjaGVtYVxuICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnNcbiAgICAgIG1heCA9IG1heENvbnRhaW5zXG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbiA9IDFcbiAgICB9XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICAgIGN4dC5zZXRQYXJhbXMoe21pbiwgbWF4fSlcbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPT0gMCB3aXRob3V0IFwibWF4Q29udGFpbnNcIjogXCJjb250YWluc1wiIGtleXdvcmQgaWdub3JlZGApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IG1heCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYClcbiAgICAgIGN4dC5mYWlsKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgIGxldCBjb25kID0gX2Ake2xlbn0gPj0gJHttaW59YFxuICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSBjb25kID0gX2Ake2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gXG4gICAgICBjeHQucGFzcyhjb25kKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaXQuaXRlbXMgPSB0cnVlXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMSkge1xuICAgICAgdmFsaWRhdGVJdGVtcyh2YWxpZCwgKCkgPT4gZ2VuLmlmKHZhbGlkLCAoKSA9PiBnZW4uYnJlYWsoKSkpXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpXG4gICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIGdlbi5pZihfYCR7ZGF0YX0ubGVuZ3RoID4gMGAsIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKVxuICAgICAgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpXG4gICAgfVxuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcbiAgICAgIGNvbnN0IGNvdW50ID0gZ2VuLmxldChcImNvdW50XCIsIDApXG4gICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQ6IE5hbWUsIGJsb2NrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5OdW0sXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3ZhbGlkXG4gICAgICAgIClcbiAgICAgICAgYmxvY2soKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudDogTmFtZSk6IHZvaWQge1xuICAgICAgZ2VuLmNvZGUoX2Ake2NvdW50fSsrYClcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnZW4uaWYoX2Ake2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuLmlmKF9gJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSlcbiAgICAgICAgaWYgKG1pbiA9PT0gMSkgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICAgICAgZWxzZSBnZW4uaWYoX2Ake2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgU2NoZW1hTWFwLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge2NoZWNrUmVwb3J0TWlzc2luZ1Byb3AsIGNoZWNrTWlzc2luZ1Byb3AsIHJlcG9ydE1pc3NpbmdQcm9wLCBwcm9wZXJ0eUluRGF0YX0gZnJvbSBcIi4uL2NvZGVcIlxuXG5leHBvcnQgdHlwZSBQcm9wZXJ0eURlcGVuZGVuY2llcyA9IHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW119XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwZW5kZW5jaWVzRXJyb3JQYXJhbXMge1xuICBwcm9wZXJ0eTogc3RyaW5nXG4gIG1pc3NpbmdQcm9wZXJ0eTogc3RyaW5nXG4gIGRlcHNDb3VudDogbnVtYmVyXG4gIGRlcHM6IHN0cmluZyAvLyBUT0RPIGNoYW5nZSB0byBzdHJpbmdbXVxufVxuXG50eXBlIFNjaGVtYURlcGVuZGVuY2llcyA9IFNjaGVtYU1hcFxuXG5leHBvcnQgdHlwZSBEZXBlbmRlbmNpZXNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcImRlcGVuZGVuY2llc1wiLFxuICBEZXBlbmRlbmNpZXNFcnJvclBhcmFtcyxcbiAge1tLIGluIHN0cmluZ10/OiBzdHJpbmdbXSB8IEFueVNjaGVtYX1cbj5cblxuZXhwb3J0IGNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge3Byb3BlcnR5LCBkZXBzQ291bnQsIGRlcHN9fSkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5X2llcyA9IGRlcHNDb3VudCA9PT0gMSA/IFwicHJvcGVydHlcIiA6IFwicHJvcGVydGllc1wiXG4gICAgcmV0dXJuIHN0cmBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YFxuICB9LFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7cHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5fX0pID0+XG4gICAgX2B7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KVxuICAgIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcERlcHMpXG4gICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcylcbiAgfSxcbn1cblxuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoe3NjaGVtYX06IEtleXdvcmRDeHQpOiBbUHJvcGVydHlEZXBlbmRlbmNpZXMsIFNjaGVtYURlcGVuZGVuY2llc10ge1xuICBjb25zdCBwcm9wZXJ0eURlcHM6IFByb3BlcnR5RGVwZW5kZW5jaWVzID0ge31cbiAgY29uc3Qgc2NoZW1hRGVwczogU2NoZW1hRGVwZW5kZW5jaWVzID0ge31cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikgY29udGludWVcbiAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzXG4gICAgZGVwc1trZXldID0gc2NoZW1hW2tleV1cbiAgfVxuICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlEZXBzKFxuICBjeHQ6IEtleXdvcmRDeHQsXG4gIHByb3BlcnR5RGVwczoge1tLIGluIHN0cmluZ10/OiBzdHJpbmdbXX0gPSBjeHQuc2NoZW1hXG4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgaXR9ID0gY3h0XG4gIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0eURlcHMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKVxuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlEZXBzKSB7XG4gICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXSBhcyBzdHJpbmdbXVxuICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMCkgY29udGludWVcbiAgICBjb25zdCBoYXNQcm9wZXJ0eSA9IHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKVxuICAgIGN4dC5zZXRQYXJhbXMoe1xuICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICBkZXBzQ291bnQ6IGRlcHMubGVuZ3RoLFxuICAgICAgZGVwczogZGVwcy5qb2luKFwiLCBcIiksXG4gICAgfSlcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICBnZW4uaWYoaGFzUHJvcGVydHksICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgZGVwUHJvcClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuLmlmKF9gJHtoYXNQcm9wZXJ0eX0gJiYgKCR7Y2hlY2tNaXNzaW5nUHJvcChjeHQsIGRlcHMsIG1pc3NpbmcpfSlgKVxuICAgICAgcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKVxuICAgICAgZ2VuLmVsc2UoKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWFEZXBzKGN4dDogS2V5d29yZEN4dCwgc2NoZW1hRGVwczogU2NoZW1hTWFwID0gY3h0LnNjaGVtYSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFEZXBzW3Byb3BdIGFzIEFueVNjaGVtYSkpIGNvbnRpbnVlXG4gICAgZ2VuLmlmKFxuICAgICAgcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkLCBzY2hlbWFQcm9wOiBwcm9wfSwgdmFsaWQpXG4gICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpXG4gICAgICB9LFxuICAgICAgKCkgPT4gZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgbm90fSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBQcm9wZXJ0eU5hbWVzRXJyb3IgPSBFcnJvck9iamVjdDxcInByb3BlcnR5TmFtZXNcIiwge3Byb3BlcnR5TmFtZTogc3RyaW5nfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdmFsaWRcIixcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcblxuICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICBjeHQuc2V0UGFyYW1zKHtwcm9wZXJ0eU5hbWU6IGtleX0pXG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgICAgZGF0YToga2V5LFxuICAgICAgICAgIGRhdGFUeXBlczogW1wic3RyaW5nXCJdLFxuICAgICAgICAgIHByb3BlcnR5TmFtZToga2V5LFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICBjeHQuZXJyb3IodHJ1ZSlcbiAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5icmVhaygpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjeHQub2sodmFsaWQpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHthbGxTY2hlbWFQcm9wZXJ0aWVzLCB1c2VQYXR0ZXJuLCBpc093blByb3BlcnR5fSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIG5pbCwgb3IsIG5vdCwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiXG5pbXBvcnQgdHlwZSB7U3Vic2NoZW1hQXJnc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIHNjaGVtYVJlZk9yVmFsLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gIHthZGRpdGlvbmFsUHJvcGVydHk6IHN0cmluZ30sXG4gIEFueVNjaGVtYVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uICYgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXR9ID0gY3h0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlcnJzQ291bnQpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIGNvbnN0IHthbGxFcnJvcnMsIG9wdHN9ID0gaXRcbiAgICBpdC5wcm9wcyA9IHRydWVcbiAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjb25zdCBwcm9wcyA9IGFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpXG4gICAgY29uc3QgcGF0UHJvcHMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKClcbiAgICBjeHQub2soX2Ake2VycnNDb3VudH0gPT09ICR7Ti5lcnJvcnN9YClcblxuICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTogdm9pZCB7XG4gICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleTogTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKSBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSlcbiAgICAgICAgZWxzZSBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleTogTmFtZSk6IENvZGUge1xuICAgICAgbGV0IGRlZmluZWRQcm9wOiBDb2RlXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSBzY2hlbWFSZWZPclZhbChpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKVxuICAgICAgICBkZWZpbmVkUHJvcCA9IGlzT3duUHJvcGVydHkoZ2VuLCBwcm9wc1NjaGVtYSBhcyBDb2RlLCBrZXkpXG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG9yKC4uLnByb3BzLm1hcCgocCkgPT4gX2Ake2tleX0gPT09ICR7cH1gKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZWRQcm9wID0gbmlsXG4gICAgICB9XG4gICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluZWRQcm9wID0gb3IoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gX2Ake3VzZVBhdHRlcm4oY3h0LCBwKX0udGVzdCgke2tleX0pYCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbm90KGRlZmluZWRQcm9wKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5OiBOYW1lKTogdm9pZCB7XG4gICAgICBnZW4uY29kZShfYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5OiBOYW1lKTogdm9pZCB7XG4gICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHthZGRpdGlvbmFsUHJvcGVydHk6IGtleX0pXG4gICAgICAgIGN4dC5lcnJvcigpXG4gICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uYnJlYWsoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGZhbHNlKVxuICAgICAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjeHQucmVzZXQoKVxuICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZClcbiAgICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleTogTmFtZSwgdmFsaWQ6IE5hbWUsIGVycm9ycz86IGZhbHNlKTogdm9pZCB7XG4gICAgICBjb25zdCBzdWJzY2hlbWE6IFN1YnNjaGVtYUFyZ3MgPSB7XG4gICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLlN0cixcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge3Byb3BlcnR5SW5EYXRhLCBhbGxTY2hlbWFQcm9wZXJ0aWVzfSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCB0b0hhc2gsIG1lcmdlRXZhbHVhdGVkfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBhcERlZiBmcm9tIFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXBEZWYuY29kZShuZXcgS2V5d29yZEN4dChpdCwgYXBEZWYsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpXG4gICAgfVxuICAgIGNvbnN0IGFsbFByb3BzID0gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIGFsbFByb3BzKSB7XG4gICAgICBpdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgYWxsUHJvcHMubGVuZ3RoICYmIGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgdG9IYXNoKGFsbFByb3BzKSwgaXQucHJvcHMpXG4gICAgfVxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdKSlcbiAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApIHJldHVyblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcykpXG4gICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcClcbiAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5lbHNlKCkudmFyKHZhbGlkLCB0cnVlKVxuICAgICAgICBnZW4uZW5kSWYoKVxuICAgICAgfVxuICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKVxuICAgICAgY3h0Lm9rKHZhbGlkKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHQocHJvcDogc3RyaW5nKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICBzY2hlbWFQcm9wOiBwcm9wLFxuICAgICAgICAgIGRhdGFQcm9wOiBwcm9wLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2FsbFNjaGVtYVByb3BlcnRpZXMsIHVzZVBhdHRlcm59IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7Xywgbm90LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge2V2YWx1YXRlZFByb3BzVG9OYW1lLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7QW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0c30gPSBpdFxuICAgIGNvbnN0IHBhdHRlcm5zID0gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpXG4gICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT5cbiAgICAgIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0gYXMgQW55U2NoZW1hKVxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSlcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9XG4gICAgICBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllc1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgTmFtZSkpIHtcbiAgICAgIGl0LnByb3BzID0gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBpdC5wcm9wcylcbiAgICB9XG4gICAgY29uc3Qge3Byb3BzfSA9IGl0XG4gICAgdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgICAgZm9yIChjb25zdCBwYXQgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcykgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KVxuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpXG4gICAgICAgICAgZ2VuLmlmKHZhbGlkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKG5ldyBSZWdFeHAocGF0KS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKFxuICAgICAgICAgICAgaXQsXG4gICAgICAgICAgICBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgZ2VuLmlmKF9gJHt1c2VQYXR0ZXJuKGN4dCwgcGF0KX0udGVzdCgke2tleX0pYCwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gYWx3YXlzVmFsaWRQYXR0ZXJucy5pbmNsdWRlcyhwYXQpXG4gICAgICAgICAgaWYgKCFhbHdheXNWYWxpZCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuU3RyLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKF9gJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpXG4gICAgICAgICAgfSBlbHNlIGlmICghYWx3YXlzVmFsaWQgJiYgIWl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllc2AgaXMgbm90IHN1cHBvcnRlZCAob3B0cy5uZXh0ID09PSBmYWxzZSlcbiAgICAgICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIHdlcmUgZXZhbHVhdGVkIChwcm9wcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JOb1BhcmFtcywgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBOb3RLZXl3b3JkRXJyb3IgPSBFcnJvck5vUGFyYW1zPFwibm90XCIsIEFueVNjaGVtYT5cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwibm90XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICBjeHQuZmFpbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAge1xuICAgICAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHZhbGlkXG4gICAgKVxuXG4gICAgY3h0LmZhaWxSZXN1bHQoXG4gICAgICB2YWxpZCxcbiAgICAgICgpID0+IGN4dC5yZXNldCgpLFxuICAgICAgKCkgPT4gY3h0LmVycm9yKClcbiAgICApXG4gIH0sXG4gIGVycm9yOiB7bWVzc2FnZTogXCJtdXN0IE5PVCBiZSB2YWxpZFwifSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JOb1BhcmFtcywgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHt2YWxpZGF0ZVVuaW9ufSBmcm9tIFwiLi4vY29kZVwiXG5cbmV4cG9ydCB0eXBlIEFueU9mRXJyb3IgPSBFcnJvck5vUGFyYW1zPFwiYW55T2ZcIiwgQW55U2NoZW1hW10+XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFueU9mXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGNvZGU6IHZhbGlkYXRlVW5pb24sXG4gIGVycm9yOiB7bWVzc2FnZTogXCJtdXN0IG1hdGNoIGEgc2NoZW1hIGluIGFueU9mXCJ9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge1NjaGVtYUN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuXG5leHBvcnQgdHlwZSBPbmVPZkVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwib25lT2ZcIixcbiAge3Bhc3NpbmdTY2hlbWFzOiBbbnVtYmVyLCBudW1iZXJdIHwgbnVsbH0sXG4gIEFueVNjaGVtYVtdXG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXCIsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtwYXNzaW5nU2NoZW1hczogJHtwYXJhbXMucGFzc2luZ319YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKSByZXR1cm5cbiAgICBjb25zdCBzY2hBcnI6IEFueVNjaGVtYVtdID0gc2NoZW1hXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpXG4gICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpXG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuICAgIGN4dC5zZXRQYXJhbXMoe3Bhc3Npbmd9KVxuICAgIC8vIFRPRE8gcG9zc2libHkgZmFpbCBzdHJhaWdodCBhd2F5ICh3aXRoIHdhcm5pbmcgb3IgZXhjZXB0aW9uKSBpZiB0aGVyZSBhcmUgdHdvIGVtcHR5IGFsd2F5cyB2YWxpZCBzY2hlbWFzXG5cbiAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZilcblxuICAgIGN4dC5yZXN1bHQoXG4gICAgICB2YWxpZCxcbiAgICAgICgpID0+IGN4dC5yZXNldCgpLFxuICAgICAgKCkgPT4gY3h0LmVycm9yKHRydWUpXG4gICAgKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpOiB2b2lkIHtcbiAgICAgIHNjaEFyci5mb3JFYWNoKChzY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGxldCBzY2hDeHQ6IFNjaGVtYUN4dCB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHtcbiAgICAgICAgICBnZW4udmFyKHNjaFZhbGlkLCB0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2hWYWxpZFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGdlblxuICAgICAgICAgICAgLmlmKF9gJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsIF9gWyR7cGFzc2luZ30sICR7aX1dYClcbiAgICAgICAgICAgIC5lbHNlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGdlbi5pZihzY2hWYWxpZCwgKCkgPT4ge1xuICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICAgICAgZ2VuLmFzc2lnbihwYXNzaW5nLCBpKVxuICAgICAgICAgIGlmIChzY2hDeHQpIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIE5hbWUpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhbGxPZlwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBpdH0gPSBjeHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgc2NoZW1hLmZvckVhY2goKHNjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkgcmV0dXJuXG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGl9LCB2YWxpZClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpXG4gICAgfSlcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5vdCwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBJZktleXdvcmRFcnJvciA9IEVycm9yT2JqZWN0PFwiaWZcIiwge2ZhaWxpbmdLZXl3b3JkOiBzdHJpbmd9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtc30pID0+IHN0cmBtdXN0IG1hdGNoIFwiJHtwYXJhbXMuaWZDbGF1c2V9XCIgc2NoZW1hYCxcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiaWZcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKVxuICAgIH1cbiAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIilcbiAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIilcbiAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpIHJldHVyblxuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSlcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG4gICAgdmFsaWRhdGVJZigpXG4gICAgY3h0LnJlc2V0KClcblxuICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpXG4gICAgICBjeHQuc2V0UGFyYW1zKHtpZkNsYXVzZX0pXG4gICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpXG4gICAgfSBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuLmlmKG5vdChzY2hWYWxpZCksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiKSlcbiAgICB9XG5cbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJZigpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHNjaFZhbGlkXG4gICAgICApXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlKGtleXdvcmQ6IHN0cmluZywgaWZDbGF1c2U/OiBOYW1lKTogKCkgPT4gdm9pZCB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkfSwgc2NoVmFsaWQpXG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKVxuICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKVxuICAgICAgICBpZiAoaWZDbGF1c2UpIGdlbi5hc3NpZ24oaWZDbGF1c2UsIF9gJHtrZXl3b3JkfWApXG4gICAgICAgIGVsc2UgY3h0LnNldFBhcmFtcyh7aWZDbGF1c2U6IGtleXdvcmR9KVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZnVuY3Rpb24gaGFzU2NoZW1hKGl0OiBTY2hlbWFPYmpDeHQsIGtleXdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBjb2RlKHtrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0fTogS2V5d29yZEN4dCkge1xuICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZCkgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCIke2tleXdvcmR9XCIgd2l0aG91dCBcImlmXCIgaXMgaWdub3JlZGApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtFcnJvck5vUGFyYW1zLCBWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IGFkZGl0aW9uYWxJdGVtcywge0FkZGl0aW9uYWxJdGVtc0Vycm9yfSBmcm9tIFwiLi9hZGRpdGlvbmFsSXRlbXNcIlxuaW1wb3J0IHByZWZpeEl0ZW1zIGZyb20gXCIuL3ByZWZpeEl0ZW1zXCJcbmltcG9ydCBpdGVtcyBmcm9tIFwiLi9pdGVtc1wiXG5pbXBvcnQgaXRlbXMyMDIwLCB7SXRlbXNFcnJvcn0gZnJvbSBcIi4vaXRlbXMyMDIwXCJcbmltcG9ydCBjb250YWlucywge0NvbnRhaW5zRXJyb3J9IGZyb20gXCIuL2NvbnRhaW5zXCJcbmltcG9ydCBkZXBlbmRlbmNpZXMsIHtEZXBlbmRlbmNpZXNFcnJvcn0gZnJvbSBcIi4vZGVwZW5kZW5jaWVzXCJcbmltcG9ydCBwcm9wZXJ0eU5hbWVzLCB7UHJvcGVydHlOYW1lc0Vycm9yfSBmcm9tIFwiLi9wcm9wZXJ0eU5hbWVzXCJcbmltcG9ydCBhZGRpdGlvbmFsUHJvcGVydGllcywge0FkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3J9IGZyb20gXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCJcbmltcG9ydCBwcm9wZXJ0aWVzIGZyb20gXCIuL3Byb3BlcnRpZXNcIlxuaW1wb3J0IHBhdHRlcm5Qcm9wZXJ0aWVzIGZyb20gXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCJcbmltcG9ydCBub3RLZXl3b3JkLCB7Tm90S2V5d29yZEVycm9yfSBmcm9tIFwiLi9ub3RcIlxuaW1wb3J0IGFueU9mLCB7QW55T2ZFcnJvcn0gZnJvbSBcIi4vYW55T2ZcIlxuaW1wb3J0IG9uZU9mLCB7T25lT2ZFcnJvcn0gZnJvbSBcIi4vb25lT2ZcIlxuaW1wb3J0IGFsbE9mIGZyb20gXCIuL2FsbE9mXCJcbmltcG9ydCBpZktleXdvcmQsIHtJZktleXdvcmRFcnJvcn0gZnJvbSBcIi4vaWZcIlxuaW1wb3J0IHRoZW5FbHNlIGZyb20gXCIuL3RoZW5FbHNlXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXBwbGljYXRvcihkcmFmdDIwMjAgPSBmYWxzZSk6IFZvY2FidWxhcnkge1xuICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgIC8vIGFueVxuICAgIG5vdEtleXdvcmQsXG4gICAgYW55T2YsXG4gICAgb25lT2YsXG4gICAgYWxsT2YsXG4gICAgaWZLZXl3b3JkLFxuICAgIHRoZW5FbHNlLFxuICAgIC8vIG9iamVjdFxuICAgIHByb3BlcnR5TmFtZXMsXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIHByb3BlcnRpZXMsXG4gICAgcGF0dGVyblByb3BlcnRpZXMsXG4gIF1cbiAgLy8gYXJyYXlcbiAgaWYgKGRyYWZ0MjAyMCkgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zLCBpdGVtczIwMjApXG4gIGVsc2UgYXBwbGljYXRvci5wdXNoKGFkZGl0aW9uYWxJdGVtcywgaXRlbXMpXG4gIGFwcGxpY2F0b3IucHVzaChjb250YWlucylcbiAgcmV0dXJuIGFwcGxpY2F0b3Jcbn1cblxuZXhwb3J0IHR5cGUgQXBwbGljYXRvcktleXdvcmRFcnJvciA9XG4gIHwgRXJyb3JOb1BhcmFtczxcImZhbHNlIHNjaGVtYVwiPlxuICB8IEFkZGl0aW9uYWxJdGVtc0Vycm9yXG4gIHwgSXRlbXNFcnJvclxuICB8IENvbnRhaW5zRXJyb3JcbiAgfCBBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yXG4gIHwgRGVwZW5kZW5jaWVzRXJyb3JcbiAgfCBJZktleXdvcmRFcnJvclxuICB8IEFueU9mRXJyb3JcbiAgfCBPbmVPZkVycm9yXG4gIHwgTm90S2V5d29yZEVycm9yXG4gIHwgUHJvcGVydHlOYW1lc0Vycm9yXG4iLCAiaW1wb3J0IHR5cGUge1xuICBBZGRlZEZvcm1hdCxcbiAgRm9ybWF0VmFsaWRhdG9yLFxuICBBc3luY0Zvcm1hdFZhbGlkYXRvcixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgbmlsLCBvciwgQ29kZSwgZ2V0UHJvcGVydHksIHJlZ2V4cENvZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG50eXBlIEZvcm1hdFZhbGlkYXRlID1cbiAgfCBGb3JtYXRWYWxpZGF0b3I8c3RyaW5nPlxuICB8IEZvcm1hdFZhbGlkYXRvcjxudW1iZXI+XG4gIHwgQXN5bmNGb3JtYXRWYWxpZGF0b3I8c3RyaW5nPlxuICB8IEFzeW5jRm9ybWF0VmFsaWRhdG9yPG51bWJlcj5cbiAgfCBSZWdFeHBcbiAgfCBzdHJpbmdcbiAgfCB0cnVlXG5cbmV4cG9ydCB0eXBlIEZvcm1hdEVycm9yID0gRXJyb3JPYmplY3Q8XCJmb3JtYXRcIiwge2Zvcm1hdDogc3RyaW5nfSwgc3RyaW5nIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCwgcnVsZVR5cGU/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmfSA9IGl0XG4gICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cykgcmV0dXJuXG5cbiAgICBpZiAoJGRhdGEpIHZhbGlkYXRlJERhdGFGb3JtYXQoKVxuICAgIGVsc2UgdmFsaWRhdGVGb3JtYXQoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICB9KVxuICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgX2Ake2ZtdHN9WyR7c2NoZW1hQ29kZX1dYClcbiAgICAgIGNvbnN0IGZUeXBlID0gZ2VuLmxldChcImZUeXBlXCIpXG4gICAgICBjb25zdCBmb3JtYXQgPSBnZW4ubGV0KFwiZm9ybWF0XCIpXG4gICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICBnZW4uaWYoXG4gICAgICAgIF9gdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCxcbiAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgX2Ake2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIF9gJHtmRGVmfS52YWxpZGF0ZWApLFxuICAgICAgICAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCBfYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKVxuICAgICAgKVxuICAgICAgY3h0LmZhaWwkZGF0YShvcih1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpXG5cbiAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKTogQ29kZSB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHJldHVybiBuaWxcbiAgICAgICAgcmV0dXJuIF9gJHtzY2hlbWFDb2RlfSAmJiAhJHtmb3JtYXR9YFxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZhbGlkRm10KCk6IENvZGUge1xuICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgID8gX2AoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgOiBfYCR7Zm9ybWF0fSgke2RhdGF9KWBcbiAgICAgICAgY29uc3QgdmFsaWREYXRhID0gX2AodHlwZW9mICR7Zm9ybWF0fSA9PSBcImZ1bmN0aW9uXCIgPyAke2NhbGxGb3JtYXR9IDogJHtmb3JtYXR9LnRlc3QoJHtkYXRhfSkpYFxuICAgICAgICByZXR1cm4gX2Ake2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YFxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCk6IHZvaWQge1xuICAgICAgY29uc3QgZm9ybWF0RGVmOiBBZGRlZEZvcm1hdCB8IHVuZGVmaW5lZCA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdXG4gICAgICBpZiAoIWZvcm1hdERlZikge1xuICAgICAgICB1bmtub3duRm9ybWF0KClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0RGVmID09PSB0cnVlKSByZXR1cm5cbiAgICAgIGNvbnN0IFtmbXRUeXBlLCBmb3JtYXQsIGZtdFJlZl0gPSBnZXRGb3JtYXQoZm9ybWF0RGVmKVxuICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKSBjeHQucGFzcyh2YWxpZENvbmRpdGlvbigpKVxuXG4gICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCk6IHZvaWQge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVua25vd25Nc2coKSlcblxuICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCk6IHN0cmluZyB7XG4gICAgICAgICAgcmV0dXJuIGB1bmtub3duIGZvcm1hdCBcIiR7c2NoZW1hIGFzIHN0cmluZ31cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZvcm1hdChmbXREZWY6IEFkZGVkRm9ybWF0KTogW3N0cmluZywgRm9ybWF0VmFsaWRhdGUsIENvZGVdIHtcbiAgICAgICAgY29uc3QgY29kZSA9XG4gICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICAgICA/IHJlZ2V4cENvZGUoZm10RGVmKVxuICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgPyBfYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtnZXRQcm9wZXJ0eShzY2hlbWEpfWBcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7a2V5OiBzY2hlbWEsIHJlZjogZm10RGVmLCBjb2RlfSlcbiAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgX2Ake2ZtdH0udmFsaWRhdGVgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKTogQ29kZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpXG4gICAgICAgICAgcmV0dXJuIF9gYXdhaXQgJHtmbXRSZWZ9KCR7ZGF0YX0pYFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/IF9gJHtmbXRSZWZ9KCR7ZGF0YX0pYCA6IF9gJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBmb3JtYXRLZXl3b3JkIGZyb20gXCIuL2Zvcm1hdFwiXG5cbmNvbnN0IGZvcm1hdDogVm9jYWJ1bGFyeSA9IFtmb3JtYXRLZXl3b3JkXVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRcbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGNvbnN0IG1ldGFkYXRhVm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSA9IFtcbiAgXCJ0aXRsZVwiLFxuICBcImRlc2NyaXB0aW9uXCIsXG4gIFwiZGVmYXVsdFwiLFxuICBcImRlcHJlY2F0ZWRcIixcbiAgXCJyZWFkT25seVwiLFxuICBcIndyaXRlT25seVwiLFxuICBcImV4YW1wbGVzXCIsXG5dXG5cbmV4cG9ydCBjb25zdCBjb250ZW50Vm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSA9IFtcbiAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gIFwiY29udGVudEVuY29kaW5nXCIsXG4gIFwiY29udGVudFNjaGVtYVwiLFxuXVxuIiwgImltcG9ydCB0eXBlIHtWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IGNvcmVWb2NhYnVsYXJ5IGZyb20gXCIuL2NvcmVcIlxuaW1wb3J0IHZhbGlkYXRpb25Wb2NhYnVsYXJ5IGZyb20gXCIuL3ZhbGlkYXRpb25cIlxuaW1wb3J0IGdldEFwcGxpY2F0b3JWb2NhYnVsYXJ5IGZyb20gXCIuL2FwcGxpY2F0b3JcIlxuaW1wb3J0IGZvcm1hdFZvY2FidWxhcnkgZnJvbSBcIi4vZm9ybWF0XCJcbmltcG9ydCB7bWV0YWRhdGFWb2NhYnVsYXJ5LCBjb250ZW50Vm9jYWJ1bGFyeX0gZnJvbSBcIi4vbWV0YWRhdGFcIlxuXG5jb25zdCBkcmFmdDdWb2NhYnVsYXJpZXM6IFZvY2FidWxhcnlbXSA9IFtcbiAgY29yZVZvY2FidWxhcnksXG4gIHZhbGlkYXRpb25Wb2NhYnVsYXJ5LFxuICBnZXRBcHBsaWNhdG9yVm9jYWJ1bGFyeSgpLFxuICBmb3JtYXRWb2NhYnVsYXJ5LFxuICBtZXRhZGF0YVZvY2FidWxhcnksXG4gIGNvbnRlbnRWb2NhYnVsYXJ5LFxuXVxuXG5leHBvcnQgZGVmYXVsdCBkcmFmdDdWb2NhYnVsYXJpZXNcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JPYmplY3R9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5cbmV4cG9ydCBlbnVtIERpc2NyRXJyb3Ige1xuICBUYWcgPSBcInRhZ1wiLFxuICBNYXBwaW5nID0gXCJtYXBwaW5nXCIsXG59XG5cbmV4cG9ydCB0eXBlIERpc2NyRXJyb3JPYmo8RSBleHRlbmRzIERpc2NyRXJyb3I+ID0gRXJyb3JPYmplY3Q8XG4gIFwiZGlzY3JpbWluYXRvclwiLFxuICB7ZXJyb3I6IEU7IHRhZzogc3RyaW5nOyB0YWdWYWx1ZTogdW5rbm93bn0sXG4gIHN0cmluZ1xuPlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYU9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIGdldFByb3BlcnR5LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7RGlzY3JFcnJvciwgRGlzY3JFcnJvck9ian0gZnJvbSBcIi4uL2Rpc2NyaW1pbmF0b3IvdHlwZXNcIlxuaW1wb3J0IHtyZXNvbHZlUmVmLCBTY2hlbWFFbnZ9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcbmltcG9ydCBNaXNzaW5nUmVmRXJyb3IgZnJvbSBcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNCdXRSZWZ9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBEaXNjcmltaW5hdG9yRXJyb3IgPSBEaXNjckVycm9yT2JqPERpc2NyRXJyb3IuVGFnPiB8IERpc2NyRXJyb3JPYmo8RGlzY3JFcnJvci5NYXBwaW5nPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtkaXNjckVycm9yLCB0YWdOYW1lfX0pID0+XG4gICAgZGlzY3JFcnJvciA9PT0gRGlzY3JFcnJvci5UYWdcbiAgICAgID8gYHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHN0cmluZ2BcbiAgICAgIDogYHZhbHVlIG9mIHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIGluIG9uZU9mYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2Rpc2NyRXJyb3IsIHRhZywgdGFnTmFtZX19KSA9PlxuICAgIF9ge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29uZU9mfSA9IHBhcmVudFNjaGVtYVxuICAgIGlmICghaXQub3B0cy5kaXNjcmltaW5hdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBkaXNjcmltaW5hdG9yIG9wdGlvblwiKVxuICAgIH1cbiAgICBjb25zdCB0YWdOYW1lID0gc2NoZW1hLnByb3BlcnR5TmFtZVxuICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBwcm9wZXJ0eU5hbWVcIilcbiAgICBpZiAoc2NoZW1hLm1hcHBpbmcpIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IG1hcHBpbmcgaXMgbm90IHN1cHBvcnRlZFwiKVxuICAgIGlmICghb25lT2YpIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIG9uZU9mIGtleXdvcmRcIilcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSlcbiAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eSh0YWdOYW1lKX1gKVxuICAgIGdlbi5pZihcbiAgICAgIF9gdHlwZW9mICR7dGFnfSA9PSBcInN0cmluZ1wiYCxcbiAgICAgICgpID0+IHZhbGlkYXRlTWFwcGluZygpLFxuICAgICAgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7ZGlzY3JFcnJvcjogRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZX0pXG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpOiB2b2lkIHtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKClcbiAgICAgIGdlbi5pZihmYWxzZSlcbiAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgaW4gbWFwcGluZykge1xuICAgICAgICBnZW4uZWxzZUlmKF9gJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApXG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSlcbiAgICAgIH1cbiAgICAgIGdlbi5lbHNlKClcbiAgICAgIGN4dC5lcnJvcihmYWxzZSwge2Rpc2NyRXJyb3I6IERpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lfSlcbiAgICAgIGdlbi5lbmRJZigpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcD86IG51bWJlcik6IE5hbWUge1xuICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wfSwgX3ZhbGlkKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgTmFtZSlcbiAgICAgIHJldHVybiBfdmFsaWRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCk6IHtbVCBpbiBzdHJpbmddPzogbnVtYmVyfSB7XG4gICAgICBjb25zdCBvbmVPZk1hcHBpbmc6IHtbVCBpbiBzdHJpbmddPzogbnVtYmVyfSA9IHt9XG4gICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSlcbiAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjaCA9IG9uZU9mW2ldXG4gICAgICAgIGlmIChzY2g/LiRyZWYgJiYgIXNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICBjb25zdCByZWYgPSBzY2guJHJlZlxuICAgICAgICAgIHNjaCA9IHJlc29sdmVSZWYuY2FsbChpdC5zZWxmLCBpdC5zY2hlbWFFbnYucm9vdCwgaXQuYmFzZUlkLCByZWYpXG4gICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIFNjaGVtYUVudikgc2NoID0gc2NoLnNjaGVtYVxuICAgICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IE1pc3NpbmdSZWZFcnJvcihpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZilcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wU2NoID0gc2NoPy5wcm9wZXJ0aWVzPy5bdGFnTmFtZV1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wU2NoICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSlcbiAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSlcbiAgICAgIH1cbiAgICAgIGlmICghdGFnUmVxdWlyZWQpIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApXG4gICAgICByZXR1cm4gb25lT2ZNYXBwaW5nXG5cbiAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHtyZXF1aXJlZH06IEFueVNjaGVtYU9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXF1aXJlZCkgJiYgcmVxdWlyZWQuaW5jbHVkZXModGFnTmFtZSlcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoOiBBbnlTY2hlbWFPYmplY3QsIGk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAoc2NoLmNvbnN0KSB7XG4gICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoLmVudW0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZyh0YWdWYWx1ZTogdW5rbm93biwgaTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnVmFsdWUgIT0gXCJzdHJpbmdcIiB8fCB0YWdWYWx1ZSBpbiBvbmVPZk1hcHBpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYClcbiAgICAgICAgfVxuICAgICAgICBvbmVPZk1hcHBpbmdbdGFnVmFsdWVdID0gaVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAie1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgXCIkaWRcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgIFwic2NoZW1hQXJyYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwiaXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgICB9LFxuICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwXG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcbiAgICAgIFwiYWxsT2ZcIjogW3tcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSwge1wiZGVmYXVsdFwiOiAwfV1cbiAgICB9LFxuICAgIFwic2ltcGxlVHlwZXNcIjoge1xuICAgICAgXCJlbnVtXCI6IFtcImFycmF5XCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJudWxsXCIsIFwibnVtYmVyXCIsIFwib2JqZWN0XCIsIFwic3RyaW5nXCJdXG4gICAgfSxcbiAgICBcInN0cmluZ0FycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogW11cbiAgICB9XG4gIH0sXG4gIFwidHlwZVwiOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICB9LFxuICAgIFwiJHNjaGVtYVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpXCJcbiAgICB9LFxuICAgIFwiJHJlZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRjb21tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcInRpdGxlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICBcInJlYWRPbmx5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJleGFtcGxlc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcIm11bHRpcGxlT2ZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJtYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwibWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1heExlbmd0aFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5MZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJwYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJyZWdleFwiXG4gICAgfSxcbiAgICBcImFkZGl0aW9uYWxJdGVtc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcIml0ZW1zXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW3tcIiRyZWZcIjogXCIjXCJ9LCB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifV0sXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtYXhJdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5JdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInVuaXF1ZUl0ZW1zXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJjb250YWluc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcIm1heFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInJlcXVpcmVkXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9LFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcImZvcm1hdFwiOiBcInJlZ2V4XCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIn1dXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5TmFtZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJjb25zdFwiOiB0cnVlLFxuICAgIFwiZW51bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB0cnVlLFxuICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCJ9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCJ9LFxuICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmb3JtYXRcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiaWZcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJ0aGVuXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZWxzZVwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImFsbE9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwiYW55T2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJvbmVPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcIm5vdFwiOiB7XCIkcmVmXCI6IFwiI1wifVxuICB9LFxuICBcImRlZmF1bHRcIjogdHJ1ZVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWFPYmplY3R9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCBBanZDb3JlIGZyb20gXCIuL2NvcmVcIlxuaW1wb3J0IGRyYWZ0N1ZvY2FidWxhcmllcyBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZHJhZnQ3XCJcbmltcG9ydCBkaXNjcmltaW5hdG9yIGZyb20gXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCJcbmltcG9ydCAqIGFzIGRyYWZ0N01ldGFTY2hlbWEgZnJvbSBcIi4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uXCJcblxuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXVxuXG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIlxuXG5leHBvcnQgY2xhc3MgQWp2IGV4dGVuZHMgQWp2Q29yZSB7XG4gIF9hZGRWb2NhYnVsYXJpZXMoKTogdm9pZCB7XG4gICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpXG4gICAgZHJhZnQ3Vm9jYWJ1bGFyaWVzLmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSlcbiAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yKVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk6IHZvaWQge1xuICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpXG4gICAgaWYgKCF0aGlzLm9wdHMubWV0YSkgcmV0dXJuXG4gICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYVxuICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpXG4gICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRFxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2XG5tb2R1bGUuZXhwb3J0cy5BanYgPSBBanZcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSlcblxuZXhwb3J0IGRlZmF1bHQgQWp2XG5cbmV4cG9ydCB7XG4gIEZvcm1hdCxcbiAgRm9ybWF0RGVmaW5pdGlvbixcbiAgQXN5bmNGb3JtYXREZWZpbml0aW9uLFxuICBLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBNYWNyb0tleXdvcmREZWZpbml0aW9uLFxuICBGdW5jS2V5d29yZERlZmluaXRpb24sXG4gIFZvY2FidWxhcnksXG4gIFNjaGVtYSxcbiAgU2NoZW1hT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFzeW5jU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEVycm9yTm9QYXJhbXMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IHtQbHVnaW4sIE9wdGlvbnMsIENvZGVPcHRpb25zLCBJbnN0YW5jZU9wdGlvbnMsIExvZ2dlciwgRXJyb3JzVGV4dE9wdGlvbnN9IGZyb20gXCIuL2NvcmVcIlxuZXhwb3J0IHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4vY29tcGlsZVwiXG5leHBvcnQge0tleXdvcmRDeHR9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGVcIlxuZXhwb3J0IHtEZWZpbmVkRXJyb3J9IGZyb20gXCIuL3ZvY2FidWxhcmllcy9lcnJvcnNcIlxuZXhwb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5leHBvcnQge0pTT05TY2hlbWFUeXBlfSBmcm9tIFwiLi90eXBlcy9qc29uLXNjaGVtYVwiXG5leHBvcnQge18sIHN0ciwgc3RyaW5naWZ5LCBuaWwsIE5hbWUsIENvZGUsIENvZGVHZW4sIENvZGVHZW5PcHRpb25zfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuZXhwb3J0IHtkZWZhdWx0IGFzIFZhbGlkYXRpb25FcnJvcn0gZnJvbSBcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNaXNzaW5nUmVmRXJyb3J9IGZyb20gXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCJcbiIsICJpbXBvcnQgdHlwZSB7Rm9ybWF0LCBGb3JtYXREZWZpbml0aW9ufSBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtGb3JtYXRWYWxpZGF0b3IsIEZvcm1hdENvbXBhcmV9IGZyb20gXCJhanYvZGlzdC90eXBlc1wiXG5cbmV4cG9ydCB0eXBlIEZvcm1hdE1vZGUgPSBcImZhc3RcIiB8IFwiZnVsbFwiXG5cbmV4cG9ydCB0eXBlIEZvcm1hdE5hbWUgPVxuICB8IFwiZGF0ZVwiXG4gIHwgXCJ0aW1lXCJcbiAgfCBcImRhdGUtdGltZVwiXG4gIHwgXCJpc28tdGltZVwiXG4gIHwgXCJpc28tZGF0ZS10aW1lXCJcbiAgfCBcImR1cmF0aW9uXCJcbiAgfCBcInVyaVwiXG4gIHwgXCJ1cmktcmVmZXJlbmNlXCJcbiAgfCBcInVyaS10ZW1wbGF0ZVwiXG4gIHwgXCJ1cmxcIlxuICB8IFwiZW1haWxcIlxuICB8IFwiaG9zdG5hbWVcIlxuICB8IFwiaXB2NFwiXG4gIHwgXCJpcHY2XCJcbiAgfCBcInJlZ2V4XCJcbiAgfCBcInV1aWRcIlxuICB8IFwianNvbi1wb2ludGVyXCJcbiAgfCBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIlxuICB8IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCJcbiAgfCBcImJ5dGVcIlxuICB8IFwiaW50MzJcIlxuICB8IFwiaW50NjRcIlxuICB8IFwiZmxvYXRcIlxuICB8IFwiZG91YmxlXCJcbiAgfCBcInBhc3N3b3JkXCJcbiAgfCBcImJpbmFyeVwiXG5cbmV4cG9ydCB0eXBlIERlZmluZWRGb3JtYXRzID0ge1xuICBba2V5IGluIEZvcm1hdE5hbWVdOiBGb3JtYXRcbn1cblxuZnVuY3Rpb24gZm10RGVmKFxuICB2YWxpZGF0ZTogUmVnRXhwIHwgRm9ybWF0VmFsaWRhdG9yPHN0cmluZz4sXG4gIGNvbXBhcmU6IEZvcm1hdENvbXBhcmU8c3RyaW5nPlxuKTogRm9ybWF0RGVmaW5pdGlvbjxzdHJpbmc+IHtcbiAgcmV0dXJuIHt2YWxpZGF0ZSwgY29tcGFyZX1cbn1cblxuZXhwb3J0IGNvbnN0IGZ1bGxGb3JtYXRzOiBEZWZpbmVkRm9ybWF0cyA9IHtcbiAgLy8gZGF0ZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICBkYXRlOiBmbXREZWYoZGF0ZSwgY29tcGFyZURhdGUpLFxuICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgdGltZTogZm10RGVmKGdldFRpbWUodHJ1ZSksIGNvbXBhcmVUaW1lKSxcbiAgXCJkYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKHRydWUpLCBjb21wYXJlRGF0ZVRpbWUpLFxuICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSgpLCBjb21wYXJlSXNvRGF0ZVRpbWUpLFxuICAvLyBkdXJhdGlvbjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQVxuICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gIHVyaSxcbiAgXCJ1cmktcmVmZXJlbmNlXCI6XG4gICAgL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaSxcbiAgLy8gdXJpLXRlbXBsYXRlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuICBcInVyaS10ZW1wbGF0ZVwiOlxuICAgIC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pLFxuICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgLy8gRm9yIHRlc3QgY2FzZXM6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleFxuICB1cmw6IC9eKD86aHR0cHM/fGZ0cCk6XFwvXFwvKD86XFxTKyg/OjpcXFMqKT9AKT8oPzooPyEoPzoxMHwxMjcpKD86XFwuXFxkezEsM30pezN9KSg/ISg/OjE2OVxcLjI1NHwxOTJcXC4xNjgpKD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSg/OlxcLig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSooPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfV17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpcXC9bXlxcc10qKT8kL2l1LFxuICBlbWFpbDpcbiAgICAvXlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgaG9zdG5hbWU6XG4gICAgL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaSxcbiAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkkLyxcbiAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gIHJlZ2V4LFxuICAvLyB1dWlkOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG4gIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gIC8vIHVyaSBmcmFnbWVudDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgLy8gcmVsYXRpdmUgSlNPTi1wb2ludGVyOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1sdWZmLXJlbGF0aXZlLWpzb24tcG9pbnRlci0wMFxuICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAvLyBieXRlOiBodHRwczovL2dpdGh1Yi5jb20vbWlndWVsbW90YS9pcy1iYXNlNjRcbiAgYnl0ZSxcbiAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gIGludDMyOiB7dHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzJ9LFxuICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgaW50NjQ6IHt0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NH0sXG4gIC8vIEMtdHlwZSBmbG9hdFxuICBmbG9hdDoge3R5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlcn0sXG4gIC8vIEMtdHlwZSBkb3VibGVcbiAgZG91YmxlOiB7dHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyfSxcbiAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gIHBhc3N3b3JkOiB0cnVlLFxuICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgYmluYXJ5OiB0cnVlLFxufVxuXG5leHBvcnQgY29uc3QgZmFzdEZvcm1hdHM6IERlZmluZWRGb3JtYXRzID0ge1xuICAuLi5mdWxsRm9ybWF0cyxcbiAgZGF0ZTogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC8sIGNvbXBhcmVEYXRlKSxcbiAgdGltZTogZm10RGVmKFxuICAgIC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksXG4gICAgY29tcGFyZVRpbWVcbiAgKSxcbiAgXCJkYXRlLXRpbWVcIjogZm10RGVmKFxuICAgIC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLFxuICAgIGNvbXBhcmVEYXRlVGltZVxuICApLFxuICBcImlzby10aW1lXCI6IGZtdERlZihcbiAgICAvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSxcbiAgICBjb21wYXJlSXNvVGltZVxuICApLFxuICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKFxuICAgIC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLFxuICAgIGNvbXBhcmVJc29EYXRlVGltZVxuICApLFxuICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICBcInVyaS1yZWZlcmVuY2VcIjogL14oPzooPzpbYS16XVthLXowLTkrXFwtLl0qOik/XFwvP1xcLyk/KD86W15cXFxcXFxzI11bXlxccyNdKik/KD86I1teXFxcXFxcc10qKT8kL2ksXG4gIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3MgKHNlYXJjaCBmb3IgJ3dpbGZ1bCB2aW9sYXRpb24nKVxuICBlbWFpbDpcbiAgICAvXlthLXowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pLFxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0TmFtZXMgPSBPYmplY3Qua2V5cyhmdWxsRm9ybWF0cykgYXMgRm9ybWF0TmFtZVtdXG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUNcbiAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApXG59XG5cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC9cbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1cblxuZnVuY3Rpb24gZGF0ZShzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIGNvbnN0IG1hdGNoZXM6IHN0cmluZ1tdIHwgbnVsbCA9IERBVEUuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IHllYXI6IG51bWJlciA9ICttYXRjaGVzWzFdXG4gIGNvbnN0IG1vbnRoOiBudW1iZXIgPSArbWF0Y2hlc1syXVxuICBjb25zdCBkYXk6IG51bWJlciA9ICttYXRjaGVzWzNdXG4gIHJldHVybiAoXG4gICAgbW9udGggPj0gMSAmJlxuICAgIG1vbnRoIDw9IDEyICYmXG4gICAgZGF5ID49IDEgJiZcbiAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKVxuICApXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxOiBzdHJpbmcsIGQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShkMSAmJiBkMikpIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKGQxID4gZDIpIHJldHVybiAxXG4gIGlmIChkMSA8IGQyKSByZXR1cm4gLTFcbiAgcmV0dXJuIDBcbn1cblxuY29uc3QgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCg/OlxcLlxcZCspPykoenwoWystXSkoXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPyk/JC9pXG5cbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmU/OiBib29sZWFuKTogKHN0cjogc3RyaW5nKSA9PiBib29sZWFuIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRpbWUoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBtYXRjaGVzOiBzdHJpbmdbXSB8IG51bGwgPSBUSU1FLmV4ZWMoc3RyKVxuICAgIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaHI6IG51bWJlciA9ICttYXRjaGVzWzFdXG4gICAgY29uc3QgbWluOiBudW1iZXIgPSArbWF0Y2hlc1syXVxuICAgIGNvbnN0IHNlYzogbnVtYmVyID0gK21hdGNoZXNbM11cbiAgICBjb25zdCB0ejogc3RyaW5nIHwgdW5kZWZpbmVkID0gbWF0Y2hlc1s0XVxuICAgIGNvbnN0IHR6U2lnbjogbnVtYmVyID0gbWF0Y2hlc1s1XSA9PT0gXCItXCIgPyAtMSA6IDFcbiAgICBjb25zdCB0ekg6IG51bWJlciA9ICsobWF0Y2hlc1s2XSB8fCAwKVxuICAgIGNvbnN0IHR6TTogbnVtYmVyID0gKyhtYXRjaGVzWzddIHx8IDApXG4gICAgaWYgKHR6SCA+IDIzIHx8IHR6TSA+IDU5IHx8IChzdHJpY3RUaW1lWm9uZSAmJiAhdHopKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoaHIgPD0gMjMgJiYgbWluIDw9IDU5ICYmIHNlYyA8IDYwKSByZXR1cm4gdHJ1ZVxuICAgIC8vIGxlYXAgc2Vjb25kXG4gICAgY29uc3QgdXRjTWluID0gbWluIC0gdHpNICogdHpTaWduXG4gICAgY29uc3QgdXRjSHIgPSBociAtIHR6SCAqIHR6U2lnbiAtICh1dGNNaW4gPCAwID8gMSA6IDApXG4gICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUaW1lKHMxOiBzdHJpbmcsIHMyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShzMSAmJiBzMikpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3QgdDEgPSBuZXcgRGF0ZShcIjIwMjAtMDEtMDFUXCIgKyBzMSkudmFsdWVPZigpXG4gIGNvbnN0IHQyID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczIpLnZhbHVlT2YoKVxuICBpZiAoISh0MSAmJiB0MikpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIHQxIC0gdDJcbn1cblxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDE6IHN0cmluZywgdDI6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICghKHQxICYmIHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBhMSA9IFRJTUUuZXhlYyh0MSlcbiAgY29uc3QgYTIgPSBUSU1FLmV4ZWModDIpXG4gIGlmICghKGExICYmIGEyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICB0MSA9IGExWzFdICsgYTFbMl0gKyBhMVszXVxuICB0MiA9IGEyWzFdICsgYTJbMl0gKyBhMlszXVxuICBpZiAodDEgPiB0MikgcmV0dXJuIDFcbiAgaWYgKHQxIDwgdDIpIHJldHVybiAtMVxuICByZXR1cm4gMFxufVxuXG5jb25zdCBEQVRFX1RJTUVfU0VQQVJBVE9SID0gL3R8XFxzL2lcbmZ1bmN0aW9uIGdldERhdGVUaW1lKHN0cmljdFRpbWVab25lPzogYm9vbGVhbik6IChzdHI6IHN0cmluZykgPT4gYm9vbGVhbiB7XG4gIGNvbnN0IHRpbWUgPSBnZXRUaW1lKHN0cmljdFRpbWVab25lKVxuXG4gIHJldHVybiBmdW5jdGlvbiBkYXRlX3RpbWUoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgZGF0ZVRpbWU6IHN0cmluZ1tdID0gc3RyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpXG4gICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlVGltZShkdDE6IHN0cmluZywgZHQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShkdDEgJiYgZHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBkMSA9IG5ldyBEYXRlKGR0MSkudmFsdWVPZigpXG4gIGNvbnN0IGQyID0gbmV3IERhdGUoZHQyKS52YWx1ZU9mKClcbiAgaWYgKCEoZDEgJiYgZDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIHJldHVybiBkMSAtIGQyXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDE6IHN0cmluZywgZHQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShkdDEgJiYgZHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBbZDEsIHQxXSA9IGR0MS5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKVxuICBjb25zdCBbZDIsIHQyXSA9IGR0Mi5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKVxuICBjb25zdCByZXMgPSBjb21wYXJlRGF0ZShkMSwgZDIpXG4gIGlmIChyZXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZFxuICByZXR1cm4gcmVzIHx8IGNvbXBhcmVUaW1lKHQxLCB0Milcbn1cblxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi9cbmNvbnN0IFVSSSA9XG4gIC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2lcblxuZnVuY3Rpb24gdXJpKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpXG59XG5cbmNvbnN0IEJZVEUgPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC9nbVxuXG5mdW5jdGlvbiBieXRlKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIEJZVEUubGFzdEluZGV4ID0gMFxuICByZXR1cm4gQllURS50ZXN0KHN0cilcbn1cblxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKVxuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDFcblxuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW50NjQodmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBKU09OIGFuZCBqYXZhc2NyaXB0IG1heCBJbnQgaXMgMioqNTMsIHNvIGFueSBpbnQgdGhhdCBwYXNzZXMgaXNJbnRlZ2VyIGlzIHZhbGlkIGZvciBJbnQ2NFxuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi9cbmZ1bmN0aW9uIHJlZ2V4KHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpIHJldHVybiBmYWxzZVxuICB0cnkge1xuICAgIG5ldyBSZWdFeHAoc3RyKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIEFqdiBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtcbiAgUGx1Z2luLFxuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIENvZGUsXG4gIE5hbWUsXG4gIEVycm9yT2JqZWN0LFxufSBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtBZGRlZEZvcm1hdH0gZnJvbSBcImFqdi9kaXN0L3R5cGVzXCJcbmltcG9ydCB0eXBlIHtSdWxlfSBmcm9tIFwiYWp2L2Rpc3QvY29tcGlsZS9ydWxlc1wiXG5pbXBvcnQge0tleXdvcmRDeHR9IGZyb20gXCJhanZcIlxuaW1wb3J0IHtfLCBzdHIsIG9yLCBnZXRQcm9wZXJ0eSwgb3BlcmF0b3JzfSBmcm9tIFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCJcblxudHlwZSBLd2QgPSBcImZvcm1hdE1heGltdW1cIiB8IFwiZm9ybWF0TWluaW11bVwiIHwgXCJmb3JtYXRFeGNsdXNpdmVNYXhpbXVtXCIgfCBcImZvcm1hdEV4Y2x1c2l2ZU1pbmltdW1cIlxuXG50eXBlIENvbXBhcmlzb24gPSBcIjw9XCIgfCBcIj49XCIgfCBcIjxcIiB8IFwiPlwiXG5cbmNvbnN0IG9wcyA9IG9wZXJhdG9yc1xuXG5jb25zdCBLV0RzOiB7W0sgaW4gS3dkXToge29rU3RyOiBDb21wYXJpc29uOyBvazogQ29kZTsgZmFpbDogQ29kZX19ID0ge1xuICBmb3JtYXRNYXhpbXVtOiB7b2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVH0sXG4gIGZvcm1hdE1pbmltdW06IHtva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUfSxcbiAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bToge29rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURX0sXG4gIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHtva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEV9LFxufVxuXG5leHBvcnQgdHlwZSBMaW1pdEZvcm1hdEVycm9yID0gRXJyb3JPYmplY3Q8S3dkLCB7bGltaXQ6IHN0cmluZzsgY29tcGFyaXNvbjogQ29tcGFyaXNvbn0+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PiBzdHJgc2hvdWxkIGJlICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICBwYXJhbXM6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+XG4gICAgX2B7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRMaW1pdERlZmluaXRpb246IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0cywgc2VsZn0gPSBpdFxuICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpIHJldHVyblxuXG4gICAgY29uc3QgZkN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCAoc2VsZi5SVUxFUy5hbGwuZm9ybWF0IGFzIFJ1bGUpLmRlZmluaXRpb24sIFwiZm9ybWF0XCIpXG4gICAgaWYgKGZDeHQuJGRhdGEpIHZhbGlkYXRlJERhdGFGb3JtYXQoKVxuICAgIGVsc2UgdmFsaWRhdGVGb3JtYXQoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICB9KVxuICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsIF9gJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYClcbiAgICAgIGN4dC5mYWlsJGRhdGEoXG4gICAgICAgIG9yKFxuICAgICAgICAgIF9gdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCxcbiAgICAgICAgICBfYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsXG4gICAgICAgICAgX2B0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCxcbiAgICAgICAgICBjb21wYXJlQ29kZShmbXQpXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGZDeHQuc2NoZW1hIGFzIHN0cmluZ1xuICAgICAgY29uc3QgZm10RGVmOiBBZGRlZEZvcm1hdCB8IHVuZGVmaW5lZCA9IHNlbGYuZm9ybWF0c1tmb3JtYXRdXG4gICAgICBpZiAoIWZtdERlZiB8fCBmbXREZWYgPT09IHRydWUpIHJldHVyblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgZm10RGVmICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgIHR5cGVvZiBmbXREZWYuY29tcGFyZSAhPSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl3b3JkfVwiOiBmb3JtYXQgXCIke2Zvcm1hdH1cIiBkb2VzIG5vdCBkZWZpbmUgXCJjb21wYXJlXCIgZnVuY3Rpb25gKVxuICAgICAgfVxuICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAga2V5OiBmb3JtYXQsXG4gICAgICAgIHJlZjogZm10RGVmLFxuICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IF9gJHtvcHRzLmNvZGUuZm9ybWF0c30ke2dldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgIH0pXG5cbiAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQ6IE5hbWUpOiBDb2RlIHtcbiAgICAgIHJldHVybiBfYCR7Zm10fS5jb21wYXJlKCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0uZmFpbH0gMGBcbiAgICB9XG4gIH0sXG4gIGRlcGVuZGVuY2llczogW1wiZm9ybWF0XCJdLFxufVxuXG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbjogUGx1Z2luPHVuZGVmaW5lZD4gPSAoYWp2OiBBanYpOiBBanYgPT4ge1xuICBhanYuYWRkS2V5d29yZChmb3JtYXRMaW1pdERlZmluaXRpb24pXG4gIHJldHVybiBhanZcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0TGltaXRQbHVnaW5cbiIsICJpbXBvcnQge1xuICBEZWZpbmVkRm9ybWF0cyxcbiAgRm9ybWF0TW9kZSxcbiAgRm9ybWF0TmFtZSxcbiAgZm9ybWF0TmFtZXMsXG4gIGZhc3RGb3JtYXRzLFxuICBmdWxsRm9ybWF0cyxcbn0gZnJvbSBcIi4vZm9ybWF0c1wiXG5pbXBvcnQgZm9ybWF0TGltaXQgZnJvbSBcIi4vbGltaXRcIlxuaW1wb3J0IHR5cGUgQWp2IGZyb20gXCJhanZcIlxuaW1wb3J0IHR5cGUge1BsdWdpbiwgRm9ybWF0fSBmcm9tIFwiYWp2XCJcbmltcG9ydCB7XywgTmFtZX0gZnJvbSBcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB7Rm9ybWF0TW9kZSwgRm9ybWF0TmFtZX0gZnJvbSBcIi4vZm9ybWF0c1wiXG5leHBvcnQge0xpbWl0Rm9ybWF0RXJyb3J9IGZyb20gXCIuL2xpbWl0XCJcbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0T3B0aW9ucyB7XG4gIG1vZGU/OiBGb3JtYXRNb2RlXG4gIGZvcm1hdHM/OiBGb3JtYXROYW1lW11cbiAga2V5d29yZHM/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZvcm1hdHNQbHVnaW5PcHRpb25zID0gRm9ybWF0TmFtZVtdIHwgRm9ybWF0T3B0aW9uc1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHNQbHVnaW4gZXh0ZW5kcyBQbHVnaW48Rm9ybWF0c1BsdWdpbk9wdGlvbnM+IHtcbiAgZ2V0OiAoZm9ybWF0OiBGb3JtYXROYW1lLCBtb2RlPzogRm9ybWF0TW9kZSkgPT4gRm9ybWF0XG59XG5cbmNvbnN0IGZ1bGxOYW1lID0gbmV3IE5hbWUoXCJmdWxsRm9ybWF0c1wiKVxuY29uc3QgZmFzdE5hbWUgPSBuZXcgTmFtZShcImZhc3RGb3JtYXRzXCIpXG5cbmNvbnN0IGZvcm1hdHNQbHVnaW46IEZvcm1hdHNQbHVnaW4gPSAoXG4gIGFqdjogQWp2LFxuICBvcHRzOiBGb3JtYXRzUGx1Z2luT3B0aW9ucyA9IHtrZXl3b3JkczogdHJ1ZX1cbik6IEFqdiA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZ1bGxGb3JtYXRzLCBmdWxsTmFtZSlcbiAgICByZXR1cm4gYWp2XG4gIH1cbiAgY29uc3QgW2Zvcm1hdHMsIGV4cG9ydE5hbWVdID1cbiAgICBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZnVsbEZvcm1hdHMsIGZ1bGxOYW1lXVxuICBjb25zdCBsaXN0ID0gb3B0cy5mb3JtYXRzIHx8IGZvcm1hdE5hbWVzXG4gIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKVxuICBpZiAob3B0cy5rZXl3b3JkcykgZm9ybWF0TGltaXQoYWp2KVxuICByZXR1cm4gYWp2XG59XG5cbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWU6IEZvcm1hdE5hbWUsIG1vZGU6IEZvcm1hdE1vZGUgPSBcImZ1bGxcIik6IEZvcm1hdCA9PiB7XG4gIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZhc3RGb3JtYXRzIDogZnVsbEZvcm1hdHNcbiAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV1cbiAgaWYgKCFmKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYClcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanY6IEFqdiwgbGlzdDogRm9ybWF0TmFtZVtdLCBmczogRGVmaW5lZEZvcm1hdHMsIGV4cG9ydE5hbWU6IE5hbWUpOiB2b2lkIHtcbiAgYWp2Lm9wdHMuY29kZS5mb3JtYXRzID8/PSBfYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWBcbiAgZm9yIChjb25zdCBmIG9mIGxpc3QpIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSlcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0c1BsdWdpblxuIiwgImV4cG9ydCB2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAoXykgPT4geyB9O1xuICAgIGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgICBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICAgIHV0aWwuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhvYmopLmZpbHRlcigoaykgPT4gdHlwZW9mIG9ialtvYmpba11dICE9PSBcIm51bWJlclwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH07XG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdXRpbC5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcbiAgICB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKHV0aWwgfHwgKHV0aWwgPSB7fSkpO1xuZXhwb3J0IHZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5leHBvcnQgY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuZXhwb3J0IGNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuIiwgImltcG9ydCB7IHV0aWwgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5leHBvcnQgY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmV4cG9ydCBjbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzc3VlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCBlcnJvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVsID0gc3ViLnBhdGhbMF07XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0gPSBmaWVsZEVycm9yc1tmaXJzdEVsXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuIiwgImltcG9ydCB7IFpvZElzc3VlQ29kZSB9IGZyb20gXCIuLi9ab2RFcnJvci5qc1wiO1xuaW1wb3J0IHsgdXRpbCwgWm9kUGFyc2VkVHlwZSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZTpcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlzc3VlLmV4cGVjdGVkLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3Qgc3RhcnQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5leHBvcnQgZGVmYXVsdCBlcnJvck1hcDtcbiIsICJpbXBvcnQgZGVmYXVsdEVycm9yTWFwIGZyb20gXCIuL2xvY2FsZXMvZW4uanNcIjtcbmxldCBvdmVycmlkZUVycm9yTWFwID0gZGVmYXVsdEVycm9yTWFwO1xuZXhwb3J0IHsgZGVmYXVsdEVycm9yTWFwIH07XG5leHBvcnQgZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cbiIsICJpbXBvcnQgeyBnZXRFcnJvck1hcCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4uL2xvY2FsZXMvZW4uanNcIjtcbmV4cG9ydCBjb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGlmIChpc3N1ZURhdGEubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzc3VlRGF0YS5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IEVNUFRZX1BBVEggPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBkZWZhdWx0RXJyb3JNYXAgPyB1bmRlZmluZWQgOiBkZWZhdWx0RXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuZXhwb3J0IGNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmV4cG9ydCBjb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuZXhwb3J0IGNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5leHBvcnQgY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmV4cG9ydCBjb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5leHBvcnQgY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuZXhwb3J0IGNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG4iLCAiZXhwb3J0IHZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcbiIsICJpbXBvcnQgeyBab2RFcnJvciwgWm9kSXNzdWVDb2RlLCB9IGZyb20gXCIuL1pvZEVycm9yLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0RXJyb3JNYXAsIGdldEVycm9yTWFwIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBlcnJvclV0aWwgfSBmcm9tIFwiLi9oZWxwZXJzL2Vycm9yVXRpbC5qc1wiO1xuaW1wb3J0IHsgRElSVFksIElOVkFMSUQsIE9LLCBQYXJzZVN0YXR1cywgYWRkSXNzdWVUb0NvbnRleHQsIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbWFrZUlzc3VlLCB9IGZyb20gXCIuL2hlbHBlcnMvcGFyc2VVdGlsLmpzXCI7XG5pbXBvcnQgeyB1dGlsLCBab2RQYXJzZWRUeXBlLCBnZXRQYXJzZWRUeXBlIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5jbGFzcyBQYXJzZUlucHV0TGF6eVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IHJlcXVpcmVkX2Vycm9yID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gaW52YWxpZF90eXBlX2Vycm9yID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5leHBvcnQgY2xhc3MgWm9kVHlwZSB7XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogcGFyYW1zPy5hc3luYyA/PyBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogISF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyPy5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpPy5pbmNsdWRlcyhcImVuY291bnRlcmVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguY29tbW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUFzeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pLnRoZW4oKHJlc3VsdCkgPT4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpID8gbWF5YmVBc3luY1Jlc3VsdCA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZ2V0SXNzdWVQcm9wZXJ0aWVzID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtZXNzYWdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVjayh2YWwpO1xuICAgICAgICAgICAgY29uc3Qgc2V0RXJyb3IgPSAoKSA9PiBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT09IFwiZnVuY3Rpb25cIiA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KSA6IHJlZmluZW1lbnREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChyZWZpbmVtZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKGRhdGEpID0+IHRoaXNbXCJ+dmFsaWRhdGVcIl0oZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgYW5kKGluY29taW5nKSB7XG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnJhbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZGVmKSB7XG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICAgIHJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBpc09wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UodW5kZWZpbmVkKS5zdWNjZXNzO1xuICAgIH1cbiAgICBpc051bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICB9XG59XG5jb25zdCBjdWlkUmVnZXggPSAvXmNbXlxccy1dezgsfSQvaTtcbmNvbnN0IGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC9pO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuY29uc3QgbmFub2lkUmVnZXggPSAvXlthLXowLTlfLV17MjF9JC9pO1xuY29uc3Qgand0UmVnZXggPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvO1xuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XG4vLyBvbGQgdmVyc2lvbjogdG9vIHNsb3csIGRpZG4ndCBzdXBwb3J0IHVuaWNvZGVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG4vL29sZCBlbWFpbCByZWdleFxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoPyEtKShbXjw+KClbXFxdLiw7Olxcc0BcIl0rXFwuKStbXjw+KClbXFxdLiw7Olxcc0BcIl17MSx9KVteLTw+KClbXFxdLiw7Olxcc0BcIl0kL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFsoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXF0pfChcXFtJUHY2OigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSlcXF0pfChbQS1aYS16MC05XShbQS1aYS16MC05LV0qW0EtWmEtejAtOV0pKihcXC5bQS1aYS16XXsyLH0pKykpJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16QS1aMC05XFwuXFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFx+XFwtXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xuY29uc3QgZW1haWxSZWdleCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aMC05XycrXFwtXFwuXSopW0EtWjAtOV8rLV1AKFtBLVowLTldW0EtWjAtOVxcLV0qXFwuKStbQS1aXXsyLH0kL2k7XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16MC05LiEjJCUmXHUyMDE5KisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxuY29uc3QgX2Vtb2ppUmVnZXggPSBgXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRgO1xubGV0IGVtb2ppUmVnZXg7XG4vLyBmYXN0ZXIsIHNpbXBsZXIsIHNhZmVyXG5jb25zdCBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xuY29uc3QgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xuLy8gY29uc3QgaXB2NlJlZ2V4ID1cbi8vIC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC87XG5jb25zdCBpcHY2Q2lkclJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuY29uc3QgYmFzZTY0UmVnZXggPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XG4vLyBodHRwczovL2Jhc2U2NC5ndXJ1L3N0YW5kYXJkcy9iYXNlNjR1cmxcbmNvbnN0IGJhc2U2NHVybFJlZ2V4ID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvO1xuLy8gc2ltcGxlXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1gO1xuLy8gbm8gbGVhcCB5ZWFyIHZhbGlkYXRpb25cbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XG4vLyB3aXRoIGxlYXAgeWVhciB2YWxpZGF0aW9uXG5jb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICAgIGxldCBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgWzAtNV1cXFxcZGA7XG4gICAgaWYgKGFyZ3MucHJlY2lzaW9uKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfShcXFxcLlxcXFxkKyk/YDtcbiAgICB9XG4gICAgY29uc3Qgc2Vjb25kc1F1YW50aWZpZXIgPSBhcmdzLnByZWNpc2lvbiA/IFwiK1wiIDogXCI/XCI7IC8vIHJlcXVpcmUgc2Vjb25kcyBpZiBwcmVjaXNpb24gaXMgbm9uemVyb1xuICAgIHJldHVybiBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQoOiR7c2Vjb25kc1JlZ2V4U291cmNlfSkke3NlY29uZHNRdWFudGlmaWVyfWA7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9JGApO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5leHBvcnQgZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0dXJsIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCBiYXNlNjQgPSBoZWFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL18vZywgXCIvXCIpXG4gICAgICAgICAgICAucGFkRW5kKGhlYWRlci5sZW5ndGggKyAoKDQgLSAoaGVhZGVyLmxlbmd0aCAlIDQpKSAlIDQpLCBcIj1cIik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChcInR5cFwiIGluIGRlY29kZWQgJiYgZGVjb2RlZD8udHlwICE9PSBcIkpXVFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGNsYXNzIFpvZFN0cmluZyBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IFN0cmluZyhpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW5vaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdWxpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGNoZWNrLnJlZ2V4LnRlc3QoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwicmVnZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5pbmNsdWRlcyhjaGVjay52YWx1ZSwgY2hlY2sucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVuZHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRldGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRlUmVnZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSB0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiand0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRKV1QoaW5wdXQuZGF0YSwgY2hlY2suYWxnKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImp3dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY2lkclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkQ2lkcihpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImNpZHJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjR1cmxcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0dXJsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgoZGF0YSkgPT4gcmVnZXgudGVzdChkYXRhKSwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbixcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWFpbChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1cmwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGVtb2ppKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHV1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBuYW5vaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm5hbm9pZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkMihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1bGlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjR1cmwobWVzc2FnZSkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGp3dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiand0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgaXAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgY2lkcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY2lkclwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gZmFsc2UsXG4gICAgICAgICAgICBsb2NhbDogb3B0aW9ucz8ubG9jYWwgPz8gZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHRpbWUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucz8ucG9zaXRpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgPz8gZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IE51bWJlci5wYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gMTAgKiogZGVjQ291bnQ7XG59XG5leHBvcnQgY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgPz8gZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGlucHV0LmRhdGEuZ2V0VGltZSgpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluRGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5EYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBtYXhEYXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICAgIH1cbn1cblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTeW1ib2woe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cbiAgICAgICAgdGhpcy5fYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RWb2lkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVm9pZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gdGhpcy5fZGVmLmVycm9yTWFwPy4oaXNzdWUsIGN0eCkubWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSA/PyBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXMobWFzaykpIHtcbiAgICAgICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgIGlmICghb3B0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICAgICAgICAgICAgcGF0aDogW2Rpc2NyaW1pbmF0b3JdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kaXNjcmltaW5hdG9yO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc01hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgdmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZXNcbiAgICAgICAgY29uc3Qgb3B0aW9uc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZXMgPSBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBkaXNjcmltaW5hdG9yIHZhbHVlIGZvciBrZXkgXFxgJHtkaXNjcmltaW5hdG9yfVxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc01hcC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlzY3JpbWluYXRvciBwcm9wZXJ0eSAke1N0cmluZyhkaXNjcmltaW5hdG9yKX0gaGFzIGR1cGxpY2F0ZSB2YWx1ZSAke1N0cmluZyh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZERpc2NyaW1pbmF0ZWRVbmlvbih7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uc01hcCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kSW50ZXJzZWN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eShwYXJzZWRMZWZ0KSB8fCBpc0RpcnR5KHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYubGVmdC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyB0eXBlIFpvZFR1cGxlSXRlbXMgPSBbWm9kVHlwZUFueSwgLi4uWm9kVHlwZUFueVtdXTtcbmV4cG9ydCBjbGFzcyBab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IFsuLi5jdHguZGF0YV1cbiAgICAgICAgICAgIC5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiAhIXgpOyAvLyBmaWx0ZXIgbnVsbHNcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgICB9XG4gICAgcmVzdChyZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zZXQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChkZWYubWluU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPCBkZWYubWluU2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluU2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhTaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pblNpemU6IHsgdmFsdWU6IG1pblNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heFNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaXplKHNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBtaW5TaXplOiBudWxsLFxuICAgICAgICBtYXhTaXplOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgY3R4LnNjaGVtYUVycm9yTWFwLCBnZXRFcnJvck1hcCgpLCBkZWZhdWx0RXJyb3JNYXBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHJldHVybnMsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJncy5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IG1lLl9kZWYucmV0dXJucy5zYWZlUGFyc2UocmVzdWx0LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIHBhcnNlZFJldHVybnMuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmFyZ3M7XG4gICAgfVxuICAgIHJldHVyblR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYucmV0dXJucztcbiAgICB9XG4gICAgYXJncyguLi5pdGVtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGFyZ3M6IFpvZFR1cGxlLmNyZWF0ZShpdGVtcykucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybnMocmV0dXJuVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVyblR5cGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0cmljdEltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShhcmdzLCByZXR1cm5zLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICBhcmdzOiAoYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZExhenkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGxhenlTY2hlbWEgPSB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgfVxufVxuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmV4cG9ydCBjbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nICYmIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiYgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSA/IGN0eC5kYXRhIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCB7IFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIgfTtcbmV4cG9ydCBjbGFzcyBab2RPcHRpb25hbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuZGVmYXVsdCA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZENhdGNoIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICAvLyBuZXdDdHggaXMgdXNlZCB0byBub3QgY29sbGVjdCBpc3N1ZXMgZnJvbSBpbm5lciB0eXBlcyBpbiBjdHhcbiAgICAgICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YTogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiBuZXdDdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgIC4uLm5ld0N0eCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kQ2F0Y2guY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBwYXJhbXMuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5jYXRjaCA6ICgpID0+IHBhcmFtcy5jYXRjaCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuZXhwb3J0IGNsYXNzIFpvZEJyYW5kZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgei5jdXN0b20gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBjbGVhblBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGRhdGEpIDogdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcGFyYW1zIH0gOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSBwYXJhbXMuZmF0YWwgPz8gZmF0YWwgPz8gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufVxuZXhwb3J0IHsgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZFR5cGUgYXMgWm9kU2NoZW1hIH07XG5leHBvcnQgY29uc3QgbGF0ZSA9IHtcbiAgICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlLFxufTtcbmV4cG9ydCB2YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbi8vIHJlcXVpcmVzIFRTIDQuNCtcbmNsYXNzIENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciguLi5fKSB7IH1cbn1cbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuZXhwb3J0IGNvbnN0IGNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmV4cG9ydCB7IGFueVR5cGUgYXMgYW55LCBhcnJheVR5cGUgYXMgYXJyYXksIGJpZ0ludFR5cGUgYXMgYmlnaW50LCBib29sZWFuVHlwZSBhcyBib29sZWFuLCBkYXRlVHlwZSBhcyBkYXRlLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGluc3RhbmNlT2ZUeXBlIGFzIGluc3RhbmNlb2YsIGludGVyc2VjdGlvblR5cGUgYXMgaW50ZXJzZWN0aW9uLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB2b2lkVHlwZSBhcyB2b2lkLCB9O1xuZXhwb3J0IGNvbnN0IE5FVkVSID0gSU5WQUxJRDtcbiIsICIvKiogQSBzcGVjaWFsIGNvbnN0YW50IHdpdGggdHlwZSBgbmV2ZXJgICovXG5leHBvcnQgY29uc3QgTkVWRVIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5leHBvcnQgLypAX19OT19TSURFX0VGRkVDVFNfXyovIGZ1bmN0aW9uICRjb25zdHJ1Y3RvcihuYW1lLCBpbml0aWFsaXplciwgcGFyYW1zKSB7XG4gICAgZnVuY3Rpb24gaW5pdChpbnN0LCBkZWYpIHtcbiAgICAgICAgaWYgKCFpbnN0Ll96b2QpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyOiBfLFxuICAgICAgICAgICAgICAgICAgICB0cmFpdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QuX3pvZC50cmFpdHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdC5fem9kLnRyYWl0cy5hZGQobmFtZSk7XG4gICAgICAgIGluaXRpYWxpemVyKGluc3QsIGRlZik7XG4gICAgICAgIC8vIHN1cHBvcnQgcHJvdG90eXBlIG1vZGlmaWNhdGlvbnNcbiAgICAgICAgY29uc3QgcHJvdG8gPSBfLnByb3RvdHlwZTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghKGsgaW4gaW5zdCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0W2tdID0gcHJvdG9ba10uYmluZChpbnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkb2Vzbid0IHdvcmsgaWYgUGFyZW50IGhhcyBhIGNvbnN0cnVjdG9yIHdpdGggYXJndW1lbnRzXG4gICAgY29uc3QgUGFyZW50ID0gcGFyYW1zPy5QYXJlbnQgPz8gT2JqZWN0O1xuICAgIGNsYXNzIERlZmluaXRpb24gZXh0ZW5kcyBQYXJlbnQge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmaW5pdGlvbiwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG4gICAgZnVuY3Rpb24gXyhkZWYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpbnN0ID0gcGFyYW1zPy5QYXJlbnQgPyBuZXcgRGVmaW5pdGlvbigpIDogdGhpcztcbiAgICAgICAgaW5pdChpbnN0LCBkZWYpO1xuICAgICAgICAoX2EgPSBpbnN0Ll96b2QpLmRlZmVycmVkID8/IChfYS5kZWZlcnJlZCA9IFtdKTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBpbnN0Ll96b2QuZGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcImluaXRcIiwgeyB2YWx1ZTogaW5pdCB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgICAgIHZhbHVlOiAoaW5zdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtcz8uUGFyZW50ICYmIGluc3QgaW5zdGFuY2VvZiBwYXJhbXMuUGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGluc3Q/Ll96b2Q/LnRyYWl0cz8uaGFzKG5hbWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICByZXR1cm4gXztcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFVUSUxJVElFUyAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0ICRicmFuZCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmV4cG9ydCBjbGFzcyAkWm9kQXN5bmNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYEVuY291bnRlcmVkIFByb21pc2UgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlLiBVc2UgLnBhcnNlQXN5bmMoKSBpbnN0ZWFkLmApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyAkWm9kRW5jb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihgRW5jb3VudGVyZWQgdW5pZGlyZWN0aW9uYWwgdHJhbnNmb3JtIGR1cmluZyBlbmNvZGU6ICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFbmNvZGVFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBnbG9iYWxDb25maWcgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKG5ld0NvbmZpZylcbiAgICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxDb25maWcsIG5ld0NvbmZpZyk7XG4gICAgcmV0dXJuIGdsb2JhbENvbmZpZztcbn1cbiIsICIvLyBmdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFcXVhbCh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vdEVxdWFsKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlIGluIGV4aGF1c3RpdmUgY2hlY2tcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KF8pIHsgfVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudW1WYWx1ZXMoZW50cmllcykge1xuICAgIGNvbnN0IG51bWVyaWNWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGVudHJpZXMpLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpO1xuICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKGVudHJpZXMpXG4gICAgICAgIC5maWx0ZXIoKFtrLCBfXSkgPT4gbnVtZXJpY1ZhbHVlcy5pbmRleE9mKCtrKSA9PT0gLTEpXG4gICAgICAgIC5tYXAoKFtfLCB2XSkgPT4gdik7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcInxcIikge1xuICAgIHJldHVybiBhcnJheS5tYXAoKHZhbCkgPT4gc3RyaW5naWZ5UHJpbWl0aXZlKHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqc29uU3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FjaGVkKGdldHRlcikge1xuICAgIGNvbnN0IHNldCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhY2hlZCB2YWx1ZSBhbHJlYWR5IHNldFwiKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bGxpc2goaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblJlZ2V4KHNvdXJjZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gc291cmNlLnN0YXJ0c1dpdGgoXCJeXCIpID8gMSA6IDA7XG4gICAgY29uc3QgZW5kID0gc291cmNlLmVuZHNXaXRoKFwiJFwiKSA/IHNvdXJjZS5sZW5ndGggLSAxIDogc291cmNlLmxlbmd0aDtcbiAgICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBTdHJpbmcgPSBzdGVwLnRvU3RyaW5nKCk7XG4gICAgbGV0IHN0ZXBEZWNDb3VudCA9IChzdGVwU3RyaW5nLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgaWYgKHN0ZXBEZWNDb3VudCA9PT0gMCAmJiAvXFxkP2UtXFxkPy8udGVzdChzdGVwU3RyaW5nKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0ZXBTdHJpbmcubWF0Y2goL1xcZD9lLShcXGQ/KS8pO1xuICAgICAgICBpZiAobWF0Y2g/LlsxXSkge1xuICAgICAgICAgICAgc3RlcERlY0NvdW50ID0gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IE51bWJlci5wYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gMTAgKiogZGVjQ291bnQ7XG59XG5jb25zdCBFVkFMVUFUSU5HID0gU3ltYm9sKFwiZXZhbHVhdGluZ1wiKTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVMYXp5KG9iamVjdCwga2V5LCBnZXR0ZXIpIHtcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gRVZBTFVBVElORykge1xuICAgICAgICAgICAgICAgIC8vIENpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCwgcmV0dXJuIHVuZGVmaW5lZCB0byBicmVhayB0aGUgY3ljbGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEVWQUxVQVRJTkc7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gb2JqZWN0W2tleV0gPSB2O1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0Q2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaiksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblByb3AodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWZzKC4uLmRlZnMpIHtcbiAgICBjb25zdCBtZXJnZWREZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhkZWYpO1xuICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZERlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgbWVyZ2VkRGVzY3JpcHRvcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRGVmKHNjaGVtYSkge1xuICAgIHJldHVybiBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50QXRQYXRoKG9iaiwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gcGF0aC5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2M/LltrZXldLCBvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VBbGxPYmplY3QocHJvbWlzZXNPYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvbWlzZXNPYmopO1xuICAgIGNvbnN0IHByb21pc2VzID0ga2V5cy5tYXAoKGtleSkgPT4gcHJvbWlzZXNPYmpba2V5XSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkT2JqID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzb2x2ZWRPYmpba2V5c1tpXV0gPSByZXN1bHRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZE9iajtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoID0gMTApIHtcbiAgICBjb25zdCBjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlc2Moc3RyKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2x1Z2lmeShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dFxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcd1xccy1dL2csIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxzXy1dKy9nLCBcIi1cIilcbiAgICAgICAgLnJlcGxhY2UoL14tK3wtKyQvZywgXCJcIik7XG59XG5leHBvcnQgY29uc3QgY2FwdHVyZVN0YWNrVHJhY2UgPSAoXCJjYXB0dXJlU3RhY2tUcmFjZVwiIGluIEVycm9yID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgOiAoLi4uX2FyZ3MpID0+IHsgfSk7XG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZXhwb3J0IGNvbnN0IGFsbG93c0V2YWwgPSBjYWNoZWQoKCkgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5jbHVkZXMoXCJDbG91ZGZsYXJlXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgICAgICBuZXcgRihcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgICBpZiAoaXNPYmplY3QobykgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgICBjb25zdCBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoY3RvciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGN0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gbW9kaWZpZWQgcHJvdG90eXBlXG4gICAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICAgIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBjdG9yIGRvZXNuJ3QgaGF2ZSBzdGF0aWMgYGlzUHJvdG90eXBlT2ZgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90LCBcImlzUHJvdG90eXBlT2ZcIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG8pIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvKSlcbiAgICAgICAgcmV0dXJuIHsgLi4ubyB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pKVxuICAgICAgICByZXR1cm4gWy4uLm9dO1xuICAgIHJldHVybiBvO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bUtleXMoZGF0YSkge1xuICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgIGtleUNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleUNvdW50O1xufVxuZXhwb3J0IGNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gXCJuYW5cIiA6IFwibnVtYmVyXCI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmlnaW50XCI7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmIGRhdGEuY2F0Y2ggJiYgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInByb21pc2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzZXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZpbGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHt0fWApO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcHJvcGVydHlLZXlUeXBlcyA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwic3ltYm9sXCJdKTtcbmV4cG9ydCBjb25zdCBwcmltaXRpdmVUeXBlcyA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYmlnaW50XCIsIFwiYm9vbGVhblwiLCBcInN5bWJvbFwiLCBcInVuZGVmaW5lZFwiXSk7XG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG4vLyB6b2Qtc3BlY2lmaWMgdXRpbHNcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShpbnN0LCBkZWYsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsID0gbmV3IGluc3QuX3pvZC5jb25zdHIoZGVmID8/IGluc3QuX3pvZC5kZWYpO1xuICAgIGlmICghZGVmIHx8IHBhcmFtcz8ucGFyZW50KVxuICAgICAgICBjbC5fem9kLnBhcmVudCA9IGluc3Q7XG4gICAgcmV0dXJuIGNsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gX3BhcmFtcztcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4geyBlcnJvcjogKCkgPT4gcGFyYW1zIH07XG4gICAgaWYgKHBhcmFtcz8ubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXM/LmVycm9yICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBib3RoIGBtZXNzYWdlYCBhbmQgYGVycm9yYCBwYXJhbXNcIik7XG4gICAgICAgIHBhcmFtcy5lcnJvciA9IHBhcmFtcy5tZXNzYWdlO1xuICAgIH1cbiAgICBkZWxldGUgcGFyYW1zLm1lc3NhZ2U7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZXJyb3IgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgZXJyb3I6ICgpID0+IHBhcmFtcy5lcnJvciB9O1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhbnNwYXJlbnRQcm94eShnZXR0ZXIpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZ2V0KF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF8sIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMoXywgcHJvcCkge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHkoXywgcHJvcCkge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzKF8pIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXywgcHJvcCkge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgXCJuXCI7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsS2V5cyhzaGFwZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzaGFwZSkuZmlsdGVyKChrKSA9PiB7XG4gICAgICAgIHJldHVybiBzaGFwZVtrXS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIgJiYgc2hhcGVba10uX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBOVU1CRVJfRk9STUFUX1JBTkdFUyA9IHtcbiAgICBzYWZlaW50OiBbTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSxcbiAgICBpbnQzMjogWy0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3XSxcbiAgICB1aW50MzI6IFswLCA0Mjk0OTY3Mjk1XSxcbiAgICBmbG9hdDMyOiBbLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgMy40MDI4MjM0NjYzODUyODg2ZTM4XSxcbiAgICBmbG9hdDY0OiBbLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUVdLFxufTtcbmV4cG9ydCBjb25zdCBCSUdJTlRfRk9STUFUX1JBTkdFUyA9IHtcbiAgICBpbnQ2NDogWy8qIEBfX1BVUkVfXyovIEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCAvKiBAX19QVVJFX18qLyBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpXSxcbiAgICB1aW50NjQ6IFsvKiBAX19QVVJFX18qLyBCaWdJbnQoMCksIC8qIEBfX1BVUkVfXyovIEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpXSxcbn07XG5leHBvcnQgZnVuY3Rpb24gcGljayhzY2hlbWEsIG1hc2spIHtcbiAgICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGNoZWNrcyA9IGN1cnJEZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5waWNrKCkgY2Fubm90IGJlIHVzZWQgb24gb2JqZWN0IHNjaGVtYXMgY29udGFpbmluZyByZWZpbmVtZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBjdXJyRGVmLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBjdXJyRGVmLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgbmV3U2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXdTaGFwZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9taXQoc2NoZW1hLCBtYXNrKSB7XG4gICAgY29uc3QgY3VyckRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBjaGVja3MgPSBjdXJyRGVmLmNoZWNrcztcbiAgICBjb25zdCBoYXNDaGVja3MgPSBjaGVja3MgJiYgY2hlY2tzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGhhc0NoZWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIub21pdCgpIGNhbm5vdCBiZSB1c2VkIG9uIG9iamVjdCBzY2hlbWFzIGNvbnRhaW5pbmcgcmVmaW5lbWVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBjdXJyRGVmLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdTaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIG5ld1NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gbmV3U2hhcGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoc2NoZW1hLCBzaGFwZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzaGFwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBleHRlbmQ6IGV4cGVjdGVkIGEgcGxhaW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBjaGVja3MgPSBzY2hlbWEuX3pvZC5kZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIC8vIE9ubHkgdGhyb3cgaWYgbmV3IHNoYXBlIG92ZXJsYXBzIHdpdGggZXhpc3Rpbmcgc2hhcGVcbiAgICAgICAgLy8gVXNlIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB0byBjaGVjayBrZXkgZXhpc3RlbmNlIHdpdGhvdXQgYWNjZXNzaW5nIHZhbHVlc1xuICAgICAgICBjb25zdCBleGlzdGluZ1NoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZXhpc3RpbmdTaGFwZSwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG92ZXJ3cml0ZSBrZXlzIG9uIG9iamVjdCBzY2hlbWFzIGNvbnRhaW5pbmcgcmVmaW5lbWVudHMuIFVzZSBgLnNhZmVFeHRlbmQoKWAgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBfc2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSwgLi4uc2hhcGUgfTtcbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzYWZlRXh0ZW5kKHNjaGVtYSwgc2hhcGUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc2hhcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gc2FmZUV4dGVuZDogZXhwZWN0ZWQgYSBwbGFpbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUsIC4uLnNoYXBlIH07XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gX3NoYXBlO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhhLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zaGFwZSA9IHsgLi4uYS5fem9kLmRlZi5zaGFwZSwgLi4uYi5fem9kLmRlZi5zaGFwZSB9O1xuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIF9zaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIF9zaGFwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNhdGNoYWxsKCkge1xuICAgICAgICAgICAgcmV0dXJuIGIuX3pvZC5kZWYuY2F0Y2hhbGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sIC8vIGRlbGV0ZSBleGlzdGluZyBjaGVja3NcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsKENsYXNzLCBzY2hlbWEsIG1hc2spIHtcbiAgICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGNoZWNrcyA9IGN1cnJEZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5wYXJ0aWFsKCkgY2Fubm90IGJlIHVzZWQgb24gb2JqZWN0IHNjaGVtYXMgY29udGFpbmluZyByZWZpbmVtZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBvbGRTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChvbGRTaGFwZVtrZXldIS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IENsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb2xkU2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAob2xkU2hhcGVba2V5XSEuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IENsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIHNoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlZChDbGFzcywgc2NoZW1hLCBtYXNrKSB7XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBzaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSB3aXRoIG5vbi1vcHRpb25hbFxuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gbmV3IENsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkU2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHdpdGggbm9uLW9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBuZXcgQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuLy8gaW52YWxpZF90eXBlIHwgdG9vX2JpZyB8IHRvb19zbWFsbCB8IGludmFsaWRfZm9ybWF0IHwgbm90X211bHRpcGxlX29mIHwgdW5yZWNvZ25pemVkX2tleXMgfCBpbnZhbGlkX3VuaW9uIHwgaW52YWxpZF9rZXkgfCBpbnZhbGlkX2VsZW1lbnQgfCBpbnZhbGlkX3ZhbHVlIHwgY3VzdG9tXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRlZCh4LCBzdGFydEluZGV4ID0gMCkge1xuICAgIGlmICh4LmFib3J0ZWQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgeC5pc3N1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHguaXNzdWVzW2ldPy5jb250aW51ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeElzc3VlcyhwYXRoLCBpc3N1ZXMpIHtcbiAgICByZXR1cm4gaXNzdWVzLm1hcCgoaXNzKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gaXNzKS5wYXRoID8/IChfYS5wYXRoID0gW10pO1xuICAgICAgICBpc3MucGF0aC51bnNoaWZ0KHBhdGgpO1xuICAgICAgICByZXR1cm4gaXNzO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlPy5tZXNzYWdlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZykge1xuICAgIGNvbnN0IGZ1bGwgPSB7IC4uLmlzcywgcGF0aDogaXNzLnBhdGggPz8gW10gfTtcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoIWlzcy5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB1bndyYXBNZXNzYWdlKGlzcy5pbnN0Py5fem9kLmRlZj8uZXJyb3I/Lihpc3MpKSA/P1xuICAgICAgICAgICAgdW53cmFwTWVzc2FnZShjdHg/LmVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIHVud3JhcE1lc3NhZ2UoY29uZmlnLmN1c3RvbUVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIHVud3JhcE1lc3NhZ2UoY29uZmlnLmxvY2FsZUVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICBmdWxsLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICAvLyBkZWxldGUgKGZ1bGwgYXMgYW55KS5kZWY7XG4gICAgZGVsZXRlIGZ1bGwuaW5zdDtcbiAgICBkZWxldGUgZnVsbC5jb250aW51ZTtcbiAgICBpZiAoIWN0eD8ucmVwb3J0SW5wdXQpIHtcbiAgICAgICAgZGVsZXRlIGZ1bGwuaW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBmdWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemFibGVPcmlnaW4oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpXG4gICAgICAgIHJldHVybiBcInNldFwiO1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgcmV0dXJuIFwibWFwXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgIHJldHVybiBcImZpbGVcIjtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VkVHlwZShkYXRhKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBcIm5hblwiIDogXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JqID0gZGF0YTtcbiAgICAgICAgICAgIGlmIChvYmogJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgXCJjb25zdHJ1Y3RvclwiIGluIG9iaiAmJiBvYmouY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNzdWUoLi4uYXJncykge1xuICAgIGNvbnN0IFtpc3MsIGlucHV0LCBpbnN0XSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBpc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzcyxcbiAgICAgICAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmlzcyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuRW51bShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKVxuICAgICAgICAuZmlsdGVyKChbaywgX10pID0+IHtcbiAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgTmFOLCBtZWFuaW5nIGl0J3Mgbm90IGEgbnVtYmVyLCB0aHVzIGEgc3RyaW5nIGtleVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlci5wYXJzZUludChrLCAxMCkpO1xuICAgIH0pXG4gICAgICAgIC5tYXAoKGVsKSA9PiBlbFsxXSk7XG59XG4vLyBDb2RlYyB1dGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjQpIHtcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvQmFzZTY0KGJ5dGVzKSB7XG4gICAgbGV0IGJpbmFyeVN0cmluZyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKGJpbmFyeVN0cmluZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0dXJsVG9VaW50OEFycmF5KGJhc2U2NHVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGJhc2U2NHVybC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBwYWRkaW5nID0gXCI9XCIucmVwZWF0KCg0IC0gKGJhc2U2NC5sZW5ndGggJSA0KSkgJSA0KTtcbiAgICByZXR1cm4gYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NCArIHBhZGRpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0Jhc2U2NHVybChieXRlcykge1xuICAgIHJldHVybiB1aW50OEFycmF5VG9CYXNlNjQoYnl0ZXMpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89L2csIFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvVWludDhBcnJheShoZXgpIHtcbiAgICBjb25zdCBjbGVhbkhleCA9IGhleC5yZXBsYWNlKC9eMHgvLCBcIlwiKTtcbiAgICBpZiAoY2xlYW5IZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmcgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNsZWFuSGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xlYW5IZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgYnl0ZXNbaSAvIDJdID0gTnVtYmVyLnBhcnNlSW50KGNsZWFuSGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvSGV4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpXG4gICAgICAgIC5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG59XG4vLyBpbnN0YW5jZW9mXG5leHBvcnQgY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKC4uLl9hcmdzKSB7IH1cbn1cbiIsICJpbXBvcnQgeyAkY29uc3RydWN0b3IgfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmNvbnN0IGluaXRpYWxpemVyID0gKGluc3QsIGRlZikgPT4ge1xuICAgIGluc3QubmFtZSA9IFwiJFpvZEVycm9yXCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX3pvZFwiLCB7XG4gICAgICAgIHZhbHVlOiBpbnN0Ll96b2QsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImlzc3Vlc1wiLCB7XG4gICAgICAgIHZhbHVlOiBkZWYsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGluc3QubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGRlZiwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcInRvU3RyaW5nXCIsIHtcbiAgICAgICAgdmFsdWU6ICgpID0+IGluc3QubWVzc2FnZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0ICRab2RFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplcik7XG5leHBvcnQgY29uc3QgJFpvZFJlYWxFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplciwgeyBQYXJlbnQ6IEVycm9yIH0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5FcnJvcihlcnJvciwgbWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IsIG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5lcnJvcnMubWFwKChpc3N1ZXMpID0+IHByb2Nlc3NFcnJvcih7IGlzc3VlcyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfa2V5XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlLmlzc3VlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9lbGVtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlLmlzc3VlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcHJvY2Vzc0Vycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZmllbGRFcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJlZWlmeUVycm9yKGVycm9yLCBtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IGVycm9yczogW10gfTtcbiAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IsIHBhdGggPSBbXSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyByZWd1bGFyIHVuaW9uIGVycm9yXG4gICAgICAgICAgICAgICAgaXNzdWUuZXJyb3JzLm1hcCgoaXNzdWVzKSA9PiBwcm9jZXNzRXJyb3IoeyBpc3N1ZXMgfSwgaXNzdWUucGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2tleVwiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZS5pc3N1ZXMgfSwgaXNzdWUucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfZWxlbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZS5pc3N1ZXMgfSwgaXNzdWUucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxscGF0aCA9IFsuLi5wYXRoLCAuLi5pc3N1ZS5wYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjdXJyID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGZ1bGxwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGZ1bGxwYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGZ1bGxwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIucHJvcGVydGllcyA/PyAoY3Vyci5wcm9wZXJ0aWVzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gY3Vyci5wcm9wZXJ0aWVzKVtlbF0gPz8gKF9hW2VsXSA9IHsgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLnByb3BlcnRpZXNbZWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyci5pdGVtcyA/PyAoY3Vyci5pdGVtcyA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGN1cnIuaXRlbXMpW2VsXSA/PyAoX2JbZWxdID0geyBlcnJvcnM6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnIuaXRlbXNbZWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyci5lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogRm9ybWF0IGEgWm9kRXJyb3IgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgaW4gdGhlIGZvbGxvd2luZyBmb3JtLlxuICpcbiAqIEZyb21cbiAqXG4gKiBgYGB0c1xuICogWm9kRXJyb3Ige1xuICogICBpc3N1ZXM6IFtcbiAqICAgICB7XG4gKiAgICAgICBleHBlY3RlZDogJ3N0cmluZycsXG4gKiAgICAgICBjb2RlOiAnaW52YWxpZF90eXBlJyxcbiAqICAgICAgIHBhdGg6IFsgJ3VzZXJuYW1lJyBdLFxuICogICAgICAgbWVzc2FnZTogJ0ludmFsaWQgaW5wdXQ6IGV4cGVjdGVkIHN0cmluZydcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIGV4cGVjdGVkOiAnbnVtYmVyJyxcbiAqICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICogICAgICAgcGF0aDogWyAnZmF2b3JpdGVOdW1iZXJzJywgMSBdLFxuICogICAgICAgbWVzc2FnZTogJ0ludmFsaWQgaW5wdXQ6IGV4cGVjdGVkIG51bWJlcidcbiAqICAgICB9XG4gKiAgIF07XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiB0b1xuICpcbiAqIGBgYFxuICogdXNlcm5hbWVcbiAqICAgXHUyNzE2IEV4cGVjdGVkIG51bWJlciwgcmVjZWl2ZWQgc3RyaW5nIGF0IFwidXNlcm5hbWVcbiAqIGZhdm9yaXRlTnVtYmVyc1swXVxuICogICBcdTI3MTYgSW52YWxpZCBpbnB1dDogZXhwZWN0ZWQgbnVtYmVyXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRG90UGF0aChfcGF0aCkge1xuICAgIGNvbnN0IHNlZ3MgPSBbXTtcbiAgICBjb25zdCBwYXRoID0gX3BhdGgubWFwKChzZWcpID0+ICh0eXBlb2Ygc2VnID09PSBcIm9iamVjdFwiID8gc2VnLmtleSA6IHNlZykpO1xuICAgIGZvciAoY29uc3Qgc2VnIG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWcgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBzZWdzLnB1c2goYFske3NlZ31dYCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWcgPT09IFwic3ltYm9sXCIpXG4gICAgICAgICAgICBzZWdzLnB1c2goYFske0pTT04uc3RyaW5naWZ5KFN0cmluZyhzZWcpKX1dYCk7XG4gICAgICAgIGVsc2UgaWYgKC9bXlxcdyRdLy50ZXN0KHNlZykpXG4gICAgICAgICAgICBzZWdzLnB1c2goYFske0pTT04uc3RyaW5naWZ5KHNlZyl9XWApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goXCIuXCIpO1xuICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlZ3Muam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dGlmeUVycm9yKGVycm9yKSB7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICAvLyBzb3J0IGJ5IHBhdGggbGVuZ3RoXG4gICAgY29uc3QgaXNzdWVzID0gWy4uLmVycm9yLmlzc3Vlc10uc29ydCgoYSwgYikgPT4gKGEucGF0aCA/PyBbXSkubGVuZ3RoIC0gKGIucGF0aCA/PyBbXSkubGVuZ3RoKTtcbiAgICAvLyBQcm9jZXNzIGVhY2ggaXNzdWVcbiAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGlzc3Vlcykge1xuICAgICAgICBsaW5lcy5wdXNoKGBcdTI3MTYgJHtpc3N1ZS5tZXNzYWdlfWApO1xuICAgICAgICBpZiAoaXNzdWUucGF0aD8ubGVuZ3RoKVxuICAgICAgICAgICAgbGluZXMucHVzaChgICBcdTIxOTIgYXQgJHt0b0RvdFBhdGgoaXNzdWUucGF0aCl9YCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgTWFwIHRvIGZvcm1hdHRlZCBzdHJpbmdcbiAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuL2NvcmUuanNcIjtcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0IF9wYXJzZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IGZhbHNlIH0pIDogeyBhc3luYzogZmFsc2UgfTtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlID0gbmV3IChfcGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpO1xuICAgICAgICB1dGlsLmNhcHR1cmVTdGFja1RyYWNlKGUsIF9wYXJhbXM/LmNhbGxlZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHBhcnNlID0gLyogQF9fUFVSRV9fKi8gX3BhcnNlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfcGFyc2VBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlID0gbmV3IChwYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSk7XG4gICAgICAgIHV0aWwuY2FwdHVyZVN0YWNrVHJhY2UoZSwgcGFyYW1zPy5jYWxsZWUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBwYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX3BhcnNlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlUGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8geyAuLi5fY3R4LCBhc3luYzogZmFsc2UgfSA6IHsgYXN5bmM6IGZhbHNlIH07XG4gICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGhcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgKF9FcnIgPz8gZXJyb3JzLiRab2RFcnJvcikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpLFxuICAgICAgICB9XG4gICAgICAgIDogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZVBhcnNlID0gLyogQF9fUFVSRV9fKi8gX3NhZmVQYXJzZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVQYXJzZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQuaXNzdWVzLmxlbmd0aFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBfRXJyKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKSxcbiAgICAgICAgfVxuICAgICAgICA6IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVQYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX3NhZmVQYXJzZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfZW5jb2RlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9KSA6IHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfTtcbiAgICByZXR1cm4gX3BhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IC8qIEBfX1BVUkVfXyovIF9lbmNvZGUoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9kZWNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3BhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAvKiBAX19QVVJFX18qLyBfZGVjb2RlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfZW5jb2RlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH0pIDogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9O1xuICAgIHJldHVybiBfcGFyc2VBc3luYyhfRXJyKShzY2hlbWEsIHZhbHVlLCBjdHgpO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9lbmNvZGVBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX2RlY29kZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgcmV0dXJuIF9wYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9kZWNvZGVBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVFbmNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH0pIDogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9O1xuICAgIHJldHVybiBfc2FmZVBhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVFbmNvZGUgPSAvKiBAX19QVVJFX18qLyBfc2FmZUVuY29kZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVEZWNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3NhZmVQYXJzZShfRXJyKShzY2hlbWEsIHZhbHVlLCBfY3R4KTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZURlY29kZSA9IC8qIEBfX1BVUkVfXyovIF9zYWZlRGVjb2RlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZUVuY29kZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9KSA6IHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfTtcbiAgICByZXR1cm4gX3NhZmVQYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVFbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9zYWZlRW5jb2RlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlRGVjb2RlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3NhZmVQYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlRGVjb2RlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfc2FmZURlY29kZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbiIsICJpbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCBjdWlkID0gL15bY0NdW15cXHMtXXs4LH0kLztcbmV4cG9ydCBjb25zdCBjdWlkMiA9IC9eWzAtOWEtel0rJC87XG5leHBvcnQgY29uc3QgdWxpZCA9IC9eWzAtOUEtSEpLTU5QLVRWLVphLWhqa21ucC10di16XXsyNn0kLztcbmV4cG9ydCBjb25zdCB4aWQgPSAvXlswLTlhLXZBLVZdezIwfSQvO1xuZXhwb3J0IGNvbnN0IGtzdWlkID0gL15bQS1aYS16MC05XXsyN30kLztcbmV4cG9ydCBjb25zdCBuYW5vaWQgPSAvXlthLXpBLVowLTlfLV17MjF9JC87XG4vKiogSVNPIDg2MDEtMSBkdXJhdGlvbiByZWdleC4gRG9lcyBub3Qgc3VwcG9ydCB0aGUgODYwMS0yIGV4dGVuc2lvbnMgbGlrZSBuZWdhdGl2ZSBkdXJhdGlvbnMgb3IgZnJhY3Rpb25hbC9uZWdhdGl2ZSBjb21wb25lbnRzLiAqL1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uID0gL15QKD86KFxcZCtXKXwoPyEuKlcpKD89XFxkfFRcXGQpKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrKFsuLF1cXGQrKT9TKT8pPykkLztcbi8qKiBJbXBsZW1lbnRzIElTTyA4NjAxLTIgZXh0ZW5zaW9ucyBsaWtlIGV4cGxpY2l0ICstIHByZWZpeGVzLCBtaXhpbmcgd2Vla3Mgd2l0aCBvdGhlciB1bml0cywgYW5kIGZyYWN0aW9uYWwvbmVnYXRpdmUgY29tcG9uZW50cy4gKi9cbmV4cG9ydCBjb25zdCBleHRlbmRlZER1cmF0aW9uID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8qKiBBIHJlZ2V4IGZvciBhbnkgVVVJRC1saWtlIGlkZW50aWZpZXI6IDgtNC00LTQtMTIgaGV4IHBhdHRlcm4gKi9cbmV4cG9ydCBjb25zdCBndWlkID0gL14oWzAtOWEtZkEtRl17OH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17MTJ9KSQvO1xuLyoqIFJldHVybnMgYSByZWdleCBmb3IgdmFsaWRhdGluZyBhbiBSRkMgOTU2Mi80MTIyIFVVSUQuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gT3B0aW9uYWxseSBzcGVjaWZ5IGEgdmVyc2lvbiAxLTguIElmIG5vIHZlcnNpb24gaXMgc3BlY2lmaWVkLCBhbGwgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZC4gKi9cbmV4cG9ydCBjb25zdCB1dWlkID0gKHZlcnNpb24pID0+IHtcbiAgICBpZiAoIXZlcnNpb24pXG4gICAgICAgIHJldHVybiAvXihbMC05YS1mQS1GXXs4fS1bMC05YS1mQS1GXXs0fS1bMS04XVswLTlhLWZBLUZdezN9LVs4OWFiQUJdWzAtOWEtZkEtRl17M30tWzAtOWEtZkEtRl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC87XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oWzAtOWEtZkEtRl17OH0tWzAtOWEtZkEtRl17NH0tJHt2ZXJzaW9ufVswLTlhLWZBLUZdezN9LVs4OWFiQUJdWzAtOWEtZkEtRl17M30tWzAtOWEtZkEtRl17MTJ9KSRgKTtcbn07XG5leHBvcnQgY29uc3QgdXVpZDQgPSAvKkBfX1BVUkVfXyovIHV1aWQoNCk7XG5leHBvcnQgY29uc3QgdXVpZDYgPSAvKkBfX1BVUkVfXyovIHV1aWQoNik7XG5leHBvcnQgY29uc3QgdXVpZDcgPSAvKkBfX1BVUkVfXyovIHV1aWQoNyk7XG4vKiogUHJhY3RpY2FsIGVtYWlsIHZhbGlkYXRpb24gKi9cbmV4cG9ydCBjb25zdCBlbWFpbCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aYS16MC05XycrXFwtXFwuXSopW0EtWmEtejAtOV8rLV1AKFtBLVphLXowLTldW0EtWmEtejAtOVxcLV0qXFwuKStbQS1aYS16XXsyLH0kLztcbi8qKiBFcXVpdmFsZW50IHRvIHRoZSBIVE1MNSBpbnB1dFt0eXBlPWVtYWlsXSB2YWxpZGF0aW9uIGltcGxlbWVudGVkIGJ5IGJyb3dzZXJzLiBTb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dC9lbWFpbCAqL1xuZXhwb3J0IGNvbnN0IGh0bWw1RW1haWwgPSAvXlthLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vKiogVGhlIGNsYXNzaWMgZW1haWxyZWdleC5jb20gcmVnZXggZm9yIFJGQyA1MzIyLWNvbXBsaWFudCBlbWFpbHMgKi9cbmV4cG9ydCBjb25zdCByZmM1MzIyRW1haWwgPSAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkLztcbi8qKiBBIGxvb3NlIHJlZ2V4IHRoYXQgYWxsb3dzIFVuaWNvZGUgY2hhcmFjdGVycywgZW5mb3JjZXMgbGVuZ3RoIGxpbWl0cywgYW5kIHRoYXQncyBhYm91dCBpdC4gKi9cbmV4cG9ydCBjb25zdCB1bmljb2RlRW1haWwgPSAvXlteXFxzQFwiXXsxLDY0fUBbXlxcc0BdezEsMjU1fSQvdTtcbmV4cG9ydCBjb25zdCBpZG5FbWFpbCA9IHVuaWNvZGVFbWFpbDtcbmV4cG9ydCBjb25zdCBicm93c2VyRW1haWwgPSAvXlthLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaSA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5leHBvcnQgZnVuY3Rpb24gZW1vamkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoX2Vtb2ppLCBcInVcIik7XG59XG5leHBvcnQgY29uc3QgaXB2NCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5leHBvcnQgY29uc3QgaXB2NiA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7N31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318OikpJC87XG5leHBvcnQgY29uc3QgbWFjID0gKGRlbGltaXRlcikgPT4ge1xuICAgIGNvbnN0IGVzY2FwZWREZWxpbSA9IHV0aWwuZXNjYXBlUmVnZXgoZGVsaW1pdGVyID8/IFwiOlwiKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXig/OlswLTlBLUZdezJ9JHtlc2NhcGVkRGVsaW19KXs1fVswLTlBLUZdezJ9JHxeKD86WzAtOWEtZl17Mn0ke2VzY2FwZWREZWxpbX0pezV9WzAtOWEtZl17Mn0kYCk7XG59O1xuZXhwb3J0IGNvbnN0IGNpZHJ2NCA9IC9eKCgyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKFswLTldfFsxLTJdWzAtOV18M1swLTJdKSQvO1xuZXhwb3J0IGNvbnN0IGNpZHJ2NiA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7N31bMC05YS1mQS1GXXsxLDR9fDo6fChbMC05YS1mQS1GXXsxLDR9KT86OihbMC05YS1mQS1GXXsxLDR9Oj8pezAsNn0pXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC9eJHxeKD86WzAtOWEtekEtWisvXXs0fSkqKD86KD86WzAtOWEtekEtWisvXXsyfT09KXwoPzpbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IC9eW0EtWmEtejAtOV8tXSokLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjE3OS9yZWd1bGFyLWV4cHJlc3Npb24tdG8tbWF0Y2gtZG5zLWhvc3RuYW1lLW9yLWlwLWFkZHJlc3Ncbi8vIGV4cG9ydCBjb25zdCBob3N0bmFtZTogUmVnRXhwID0gL14oW2EtekEtWjAtOS1dK1xcLikqW2EtekEtWjAtOS1dKyQvO1xuZXhwb3J0IGNvbnN0IGhvc3RuYW1lID0gL14oPz0uezEsMjUzfVxcLj8kKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86Wy0wLTlhLXpBLVpdezAsNjF9WzAtOWEtekEtWl0pPykqXFwuPyQvO1xuZXhwb3J0IGNvbnN0IGRvbWFpbiA9IC9eKFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pP1xcLikrW2EtekEtWl17Mix9JC87XG4vLyBodHRwczovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL3ZhbGlkYXRlLXBob25lLW51bWJlciNyNC0zIChyZWdleCBzYW5zIHNwYWNlcylcbi8vIEUuMTY0OiBsZWFkaW5nIGRpZ2l0IG11c3QgYmUgMS05OyB0b3RhbCBkaWdpdHMgKGV4Y2x1ZGluZyAnKycpIGJldHdlZW4gNy0xNVxuZXhwb3J0IGNvbnN0IGUxNjQgPSAvXlxcK1sxLTldXFxkezYsMTR9JC87XG4vLyBjb25zdCBkYXRlU291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlU291cmNlID0gYCg/Oig/OlxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSg/Oig/OjBbMTM1NzhdfDFbMDJdKS0oPzowWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoPzowWzQ2OV18MTEpLSg/OjBbMS05XXxbMTJdXFxcXGR8MzApfCg/OjAyKS0oPzowWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5leHBvcnQgY29uc3QgZGF0ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJlZ0V4cChgXiR7ZGF0ZVNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lU291cmNlKGFyZ3MpIHtcbiAgICBjb25zdCBoaG1tID0gYCg/OlswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGRgO1xuICAgIGNvbnN0IHJlZ2V4ID0gdHlwZW9mIGFyZ3MucHJlY2lzaW9uID09PSBcIm51bWJlclwiXG4gICAgICAgID8gYXJncy5wcmVjaXNpb24gPT09IC0xXG4gICAgICAgICAgICA/IGAke2hobW19YFxuICAgICAgICAgICAgOiBhcmdzLnByZWNpc2lvbiA9PT0gMFxuICAgICAgICAgICAgICAgID8gYCR7aGhtbX06WzAtNV1cXFxcZGBcbiAgICAgICAgICAgICAgICA6IGAke2hobW19OlswLTVdXFxcXGRcXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWBcbiAgICAgICAgOiBgJHtoaG1tfSg/OjpbMC01XVxcXFxkKD86XFxcXC5cXFxcZCspPyk/YDtcbiAgICByZXR1cm4gcmVnZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gdGltZShhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVTb3VyY2UoYXJncyl9JGApO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5leHBvcnQgZnVuY3Rpb24gZGF0ZXRpbWUoYXJncykge1xuICAgIGNvbnN0IHRpbWUgPSB0aW1lU291cmNlKHsgcHJlY2lzaW9uOiBhcmdzLnByZWNpc2lvbiB9KTtcbiAgICBjb25zdCBvcHRzID0gW1wiWlwiXTtcbiAgICBpZiAoYXJncy5sb2NhbClcbiAgICAgICAgb3B0cy5wdXNoKFwiXCIpO1xuICAgIC8vIGlmIChhcmdzLm9mZnNldCkgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9OlxcXFxkezJ9KWApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXSg/OlswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQpYCk7XG4gICAgY29uc3QgdGltZVJlZ2V4ID0gYCR7dGltZX0oPzoke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke2RhdGVTb3VyY2V9VCg/OiR7dGltZVJlZ2V4fSkkYCk7XG59XG5leHBvcnQgY29uc3Qgc3RyaW5nID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHJlZ2V4ID0gcGFyYW1zID8gYFtcXFxcc1xcXFxTXXske3BhcmFtcz8ubWluaW11bSA/PyAwfSwke3BhcmFtcz8ubWF4aW11bSA/PyBcIlwifX1gIDogYFtcXFxcc1xcXFxTXSpgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59O1xuZXhwb3J0IGNvbnN0IGJpZ2ludCA9IC9eLT9cXGQrbj8kLztcbmV4cG9ydCBjb25zdCBpbnRlZ2VyID0gL14tP1xcZCskLztcbmV4cG9ydCBjb25zdCBudW1iZXIgPSAvXi0/XFxkKyg/OlxcLlxcZCspPyQvO1xuZXhwb3J0IGNvbnN0IGJvb2xlYW4gPSAvXig/OnRydWV8ZmFsc2UpJC9pO1xuY29uc3QgX251bGwgPSAvXm51bGwkL2k7XG5leHBvcnQgeyBfbnVsbCBhcyBudWxsIH07XG5jb25zdCBfdW5kZWZpbmVkID0gL151bmRlZmluZWQkL2k7XG5leHBvcnQgeyBfdW5kZWZpbmVkIGFzIHVuZGVmaW5lZCB9O1xuLy8gcmVnZXggZm9yIHN0cmluZyB3aXRoIG5vIHVwcGVyY2FzZSBsZXR0ZXJzXG5leHBvcnQgY29uc3QgbG93ZXJjYXNlID0gL15bXkEtWl0qJC87XG4vLyByZWdleCBmb3Igc3RyaW5nIHdpdGggbm8gbG93ZXJjYXNlIGxldHRlcnNcbmV4cG9ydCBjb25zdCB1cHBlcmNhc2UgPSAvXlteYS16XSokLztcbi8vIHJlZ2V4IGZvciBoZXhhZGVjaW1hbCBzdHJpbmdzIChhbnkgbGVuZ3RoKVxuZXhwb3J0IGNvbnN0IGhleCA9IC9eWzAtOWEtZkEtRl0qJC87XG4vLyBIYXNoIHJlZ2V4ZXMgZm9yIGRpZmZlcmVudCBhbGdvcml0aG1zIGFuZCBlbmNvZGluZ3Ncbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYmFzZTY0IHJlZ2V4IHdpdGggZXhhY3QgbGVuZ3RoIGFuZCBwYWRkaW5nXG5mdW5jdGlvbiBmaXhlZEJhc2U2NChib2R5TGVuZ3RoLCBwYWRkaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5bQS1aYS16MC05Ky9deyR7Ym9keUxlbmd0aH19JHtwYWRkaW5nfSRgKTtcbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYmFzZTY0dXJsIHJlZ2V4IHdpdGggZXhhY3QgbGVuZ3RoIChubyBwYWRkaW5nKVxuZnVuY3Rpb24gZml4ZWRCYXNlNjR1cmwobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5bQS1aYS16MC05Xy1deyR7bGVuZ3RofX0kYCk7XG59XG4vLyBNRDUgKDE2IGJ5dGVzKTogYmFzZTY0ID0gMjQgY2hhcnMgdG90YWwgKDIyICsgXCI9PVwiKVxuZXhwb3J0IGNvbnN0IG1kNV9oZXggPSAvXlswLTlhLWZBLUZdezMyfSQvO1xuZXhwb3J0IGNvbnN0IG1kNV9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDIyLCBcIj09XCIpO1xuZXhwb3J0IGNvbnN0IG1kNV9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDIyKTtcbi8vIFNIQTEgKDIwIGJ5dGVzKTogYmFzZTY0ID0gMjggY2hhcnMgdG90YWwgKDI3ICsgXCI9XCIpXG5leHBvcnQgY29uc3Qgc2hhMV9oZXggPSAvXlswLTlhLWZBLUZdezQwfSQvO1xuZXhwb3J0IGNvbnN0IHNoYTFfYmFzZTY0ID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NCgyNywgXCI9XCIpO1xuZXhwb3J0IGNvbnN0IHNoYTFfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCgyNyk7XG4vLyBTSEEyNTYgKDMyIGJ5dGVzKTogYmFzZTY0ID0gNDQgY2hhcnMgdG90YWwgKDQzICsgXCI9XCIpXG5leHBvcnQgY29uc3Qgc2hhMjU2X2hleCA9IC9eWzAtOWEtZkEtRl17NjR9JC87XG5leHBvcnQgY29uc3Qgc2hhMjU2X2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoNDMsIFwiPVwiKTtcbmV4cG9ydCBjb25zdCBzaGEyNTZfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCg0Myk7XG4vLyBTSEEzODQgKDQ4IGJ5dGVzKTogYmFzZTY0ID0gNjQgY2hhcnMgdG90YWwgKG5vIHBhZGRpbmcpXG5leHBvcnQgY29uc3Qgc2hhMzg0X2hleCA9IC9eWzAtOWEtZkEtRl17OTZ9JC87XG5leHBvcnQgY29uc3Qgc2hhMzg0X2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoNjQsIFwiXCIpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NF9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDY0KTtcbi8vIFNIQTUxMiAoNjQgYnl0ZXMpOiBiYXNlNjQgPSA4OCBjaGFycyB0b3RhbCAoODYgKyBcIj09XCIpXG5leHBvcnQgY29uc3Qgc2hhNTEyX2hleCA9IC9eWzAtOWEtZkEtRl17MTI4fSQvO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDg2LCBcIj09XCIpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDg2KTtcbiIsICIvLyBpbXBvcnQgeyAkWm9kVHlwZSB9IGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vY29yZS5qc1wiO1xuaW1wb3J0ICogYXMgcmVnZXhlcyBmcm9tIFwiLi9yZWdleGVzLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2sgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaW5zdC5fem9kID8/IChpbnN0Ll96b2QgPSB7fSk7XG4gICAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgICAoX2EgPSBpbnN0Ll96b2QpLm9uYXR0YWNoID8/IChfYS5vbmF0dGFjaCA9IFtdKTtcbn0pO1xuY29uc3QgbnVtZXJpY09yaWdpbk1hcCA9IHtcbiAgICBudW1iZXI6IFwibnVtYmVyXCIsXG4gICAgYmlnaW50OiBcImJpZ2ludFwiLFxuICAgIG9iamVjdDogXCJkYXRlXCIsXG59O1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0xlc3NUaGFuID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0xlc3NUaGFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG51bWVyaWNPcmlnaW5NYXBbdHlwZW9mIGRlZi52YWx1ZV07XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgY29uc3QgY3VyciA9IChkZWYuaW5jbHVzaXZlID8gYmFnLm1heGltdW0gOiBiYWcuZXhjbHVzaXZlTWF4aW11bSkgPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBpZiAoZGVmLnZhbHVlIDwgY3Vycikge1xuICAgICAgICAgICAgaWYgKGRlZi5pbmNsdXNpdmUpXG4gICAgICAgICAgICAgICAgYmFnLm1heGltdW0gPSBkZWYudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmFnLmV4Y2x1c2l2ZU1heGltdW0gPSBkZWYudmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmluY2x1c2l2ZSA/IHBheWxvYWQudmFsdWUgPD0gZGVmLnZhbHVlIDogcGF5bG9hZC52YWx1ZSA8IGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICBtYXhpbXVtOiB0eXBlb2YgZGVmLnZhbHVlID09PSBcIm9iamVjdFwiID8gZGVmLnZhbHVlLmdldFRpbWUoKSA6IGRlZi52YWx1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBkZWYuaW5jbHVzaXZlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrR3JlYXRlclRoYW4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrR3JlYXRlclRoYW5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3Qgb3JpZ2luID0gbnVtZXJpY09yaWdpbk1hcFt0eXBlb2YgZGVmLnZhbHVlXTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBjb25zdCBjdXJyID0gKGRlZi5pbmNsdXNpdmUgPyBiYWcubWluaW11bSA6IGJhZy5leGNsdXNpdmVNaW5pbXVtKSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGlmIChkZWYudmFsdWUgPiBjdXJyKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmluY2x1c2l2ZSlcbiAgICAgICAgICAgICAgICBiYWcubWluaW11bSA9IGRlZi52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiYWcuZXhjbHVzaXZlTWluaW11bSA9IGRlZi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChkZWYuaW5jbHVzaXZlID8gcGF5bG9hZC52YWx1ZSA+PSBkZWYudmFsdWUgOiBwYXlsb2FkLnZhbHVlID4gZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgbWluaW11bTogdHlwZW9mIGRlZi52YWx1ZSA9PT0gXCJvYmplY3RcIiA/IGRlZi52YWx1ZS5nZXRUaW1lKCkgOiBkZWYudmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZGVmLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja011bHRpcGxlT2YgPSBcbi8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNdWx0aXBsZU9mXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gaW5zdC5fem9kLmJhZykubXVsdGlwbGVPZiA/PyAoX2EubXVsdGlwbGVPZiA9IGRlZi52YWx1ZSk7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlICE9PSB0eXBlb2YgZGVmLnZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1peCBudW1iZXIgYW5kIGJpZ2ludCBpbiBtdWx0aXBsZV9vZiBjaGVjay5cIik7XG4gICAgICAgIGNvbnN0IGlzTXVsdGlwbGUgPSB0eXBlb2YgcGF5bG9hZC52YWx1ZSA9PT0gXCJiaWdpbnRcIlxuICAgICAgICAgICAgPyBwYXlsb2FkLnZhbHVlICUgZGVmLnZhbHVlID09PSBCaWdJbnQoMClcbiAgICAgICAgICAgIDogdXRpbC5mbG9hdFNhZmVSZW1haW5kZXIocGF5bG9hZC52YWx1ZSwgZGVmLnZhbHVlKSA9PT0gMDtcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiB0eXBlb2YgcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGNvZGU6IFwibm90X211bHRpcGxlX29mXCIsXG4gICAgICAgICAgICBkaXZpc29yOiBkZWYudmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja051bWJlckZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tOdW1iZXJGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7IC8vIG5vIGZvcm1hdCBjaGVja3NcbiAgICBkZWYuZm9ybWF0ID0gZGVmLmZvcm1hdCB8fCBcImZsb2F0NjRcIjtcbiAgICBjb25zdCBpc0ludCA9IGRlZi5mb3JtYXQ/LmluY2x1ZGVzKFwiaW50XCIpO1xuICAgIGNvbnN0IG9yaWdpbiA9IGlzSW50ID8gXCJpbnRcIiA6IFwibnVtYmVyXCI7XG4gICAgY29uc3QgW21pbmltdW0sIG1heGltdW1dID0gdXRpbC5OVU1CRVJfRk9STUFUX1JBTkdFU1tkZWYuZm9ybWF0XTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcuZm9ybWF0ID0gZGVmLmZvcm1hdDtcbiAgICAgICAgYmFnLm1pbmltdW0gPSBtaW5pbXVtO1xuICAgICAgICBiYWcubWF4aW11bSA9IG1heGltdW07XG4gICAgICAgIGlmIChpc0ludClcbiAgICAgICAgICAgIGJhZy5wYXR0ZXJuID0gcmVnZXhlcy5pbnRlZ2VyO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKGlzSW50KSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW52YWxpZF9mb3JtYXQgaXNzdWVcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAvLyAgIGV4cGVjdGVkOiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgIC8vICAgZm9ybWF0OiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgIC8vICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIC8vICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgLy8gICBpbnN0LFxuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgIC8vIGludmFsaWRfdHlwZSBpc3N1ZVxuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGRlZi5mb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIG5vdF9tdWx0aXBsZV9vZiBpc3N1ZVxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vICAgY29kZTogXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICAgICAgICAgICAgICAvLyAgIG9yaWdpbjogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAvLyAgIGlucHV0LFxuICAgICAgICAgICAgICAgIC8vICAgaW5zdCxcbiAgICAgICAgICAgICAgICAvLyAgIGRpdmlzb3I6IDEsXG4gICAgICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9vX2JpZ1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW50ZWdlcnMgbXVzdCBiZSB3aXRoaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b29fc21hbGxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW50ZWdlcnMgbXVzdCBiZSB3aXRoaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgPCBtaW5pbXVtKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ID4gbWF4aW11bSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgICAgIG1heGltdW0sXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tCaWdJbnRGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrQmlnSW50Rm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpOyAvLyBubyBmb3JtYXQgY2hlY2tzXG4gICAgY29uc3QgW21pbmltdW0sIG1heGltdW1dID0gdXRpbC5CSUdJTlRfRk9STUFUX1JBTkdFU1tkZWYuZm9ybWF0XTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcuZm9ybWF0ID0gZGVmLmZvcm1hdDtcbiAgICAgICAgYmFnLm1pbmltdW0gPSBtaW5pbXVtO1xuICAgICAgICBiYWcubWF4aW11bSA9IG1heGltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoaW5wdXQgPCBtaW5pbXVtKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBtaW5pbXVtLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ID4gbWF4aW11bSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgICAgIG1heGltdW0sXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNYXhTaXplID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01heFNpemVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5zaXplICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyciA9IChpbnN0Ll96b2QuYmFnLm1heGltdW0gPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgaWYgKGRlZi5tYXhpbXVtIDwgY3VycilcbiAgICAgICAgICAgIGluc3QuX3pvZC5iYWcubWF4aW11bSA9IGRlZi5tYXhpbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGlucHV0LnNpemU7XG4gICAgICAgIGlmIChzaXplIDw9IGRlZi5tYXhpbXVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogdXRpbC5nZXRTaXphYmxlT3JpZ2luKGlucHV0KSxcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heGltdW0sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja01pblNpemUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWluU2l6ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLnNpemUgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyID0gKGluc3QuX3pvZC5iYWcubWluaW11bSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBpZiAoZGVmLm1pbmltdW0gPiBjdXJyKVxuICAgICAgICAgICAgaW5zdC5fem9kLmJhZy5taW5pbXVtID0gZGVmLm1pbmltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBzaXplID0gaW5wdXQuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPj0gZGVmLm1pbmltdW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiB1dGlsLmdldFNpemFibGVPcmlnaW4oaW5wdXQpLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5pbXVtLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tTaXplRXF1YWxzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1NpemVFcXVhbHNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5zaXplICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLm1pbmltdW0gPSBkZWYuc2l6ZTtcbiAgICAgICAgYmFnLm1heGltdW0gPSBkZWYuc2l6ZTtcbiAgICAgICAgYmFnLnNpemUgPSBkZWYuc2l6ZTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNpemUgPSBpbnB1dC5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gZGVmLnNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IHNpemUgPiBkZWYuc2l6ZTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IHV0aWwuZ2V0U2l6YWJsZU9yaWdpbihpbnB1dCksXG4gICAgICAgICAgICAuLi4odG9vQmlnID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogZGVmLnNpemUgfSA6IHsgY29kZTogXCJ0b29fc21hbGxcIiwgbWluaW11bTogZGVmLnNpemUgfSksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWF4TGVuZ3RoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01heExlbmd0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoaW5zdC5fem9kLmJhZy5tYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGlmIChkZWYubWF4aW11bSA8IGN1cnIpXG4gICAgICAgICAgICBpbnN0Ll96b2QuYmFnLm1heGltdW0gPSBkZWYubWF4aW11bTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSBkZWYubWF4aW11bSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdXRpbC5nZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhpbXVtLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNaW5MZW5ndGggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWluTGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyciA9IChpbnN0Ll96b2QuYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgICAgaWYgKGRlZi5taW5pbXVtID4gY3VycilcbiAgICAgICAgICAgIGluc3QuX3pvZC5iYWcubWluaW11bSA9IGRlZi5taW5pbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID49IGRlZi5taW5pbXVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcmlnaW4gPSB1dGlsLmdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluaW11bSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTGVuZ3RoRXF1YWxzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0xlbmd0aEVxdWFsc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5taW5pbXVtID0gZGVmLmxlbmd0aDtcbiAgICAgICAgYmFnLm1heGltdW0gPSBkZWYubGVuZ3RoO1xuICAgICAgICBiYWcubGVuZ3RoID0gZGVmLmxlbmd0aDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gZGVmLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdXRpbC5nZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICAgICAgY29uc3QgdG9vQmlnID0gbGVuZ3RoID4gZGVmLmxlbmd0aDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAuLi4odG9vQmlnID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogZGVmLmxlbmd0aCB9IDogeyBjb2RlOiBcInRvb19zbWFsbFwiLCBtaW5pbXVtOiBkZWYubGVuZ3RoIH0pLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja1N0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tTdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcuZm9ybWF0ID0gZGVmLmZvcm1hdDtcbiAgICAgICAgaWYgKGRlZi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBiYWcucGF0dGVybnMuYWRkKGRlZi5wYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkZWYucGF0dGVybilcbiAgICAgICAgKF9hID0gaW5zdC5fem9kKS5jaGVjayA/PyAoX2EuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgZGVmLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChkZWYucGF0dGVybi50ZXN0KHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIC4uLihkZWYucGF0dGVybiA/IHsgcGF0dGVybjogZGVmLnBhdHRlcm4udG9TdHJpbmcoKSB9IDoge30pLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgICAoX2IgPSBpbnN0Ll96b2QpLmNoZWNrID8/IChfYi5jaGVjayA9ICgpID0+IHsgfSk7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tSZWdleCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tSZWdleFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBkZWYucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoZGVmLnBhdHRlcm4udGVzdChwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgcGF0dGVybjogZGVmLnBhdHRlcm4udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0xvd2VyQ2FzZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tMb3dlckNhc2VcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMubG93ZXJjYXNlKTtcbiAgICAkWm9kQ2hlY2tTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrVXBwZXJDYXNlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1VwcGVyQ2FzZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy51cHBlcmNhc2UpO1xuICAgICRab2RDaGVja1N0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tJbmNsdWRlcyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tJbmNsdWRlc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBlc2NhcGVkUmVnZXggPSB1dGlsLmVzY2FwZVJlZ2V4KGRlZi5pbmNsdWRlcyk7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAodHlwZW9mIGRlZi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIiA/IGBeLnske2RlZi5wb3NpdGlvbn19JHtlc2NhcGVkUmVnZXh9YCA6IGVzY2FwZWRSZWdleCk7XG4gICAgZGVmLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5wYXR0ZXJucyA/PyAoYmFnLnBhdHRlcm5zID0gbmV3IFNldCgpKTtcbiAgICAgICAgYmFnLnBhdHRlcm5zLmFkZChwYXR0ZXJuKTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZS5pbmNsdWRlcyhkZWYuaW5jbHVkZXMsIGRlZi5wb3NpdGlvbikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICBpbmNsdWRlczogZGVmLmluY2x1ZGVzLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tTdGFydHNXaXRoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1N0YXJ0c1dpdGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoYF4ke3V0aWwuZXNjYXBlUmVnZXgoZGVmLnByZWZpeCl9LipgKTtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSBwYXR0ZXJuKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgIGJhZy5wYXR0ZXJucy5hZGQocGF0dGVybik7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUuc3RhcnRzV2l0aChkZWYucHJlZml4KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwic3RhcnRzX3dpdGhcIixcbiAgICAgICAgICAgIHByZWZpeDogZGVmLnByZWZpeCxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrRW5kc1dpdGggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrRW5kc1dpdGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoYC4qJHt1dGlsLmVzY2FwZVJlZ2V4KGRlZi5zdWZmaXgpfSRgKTtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSBwYXR0ZXJuKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgIGJhZy5wYXR0ZXJucy5hZGQocGF0dGVybik7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUuZW5kc1dpdGgoZGVmLnN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImVuZHNfd2l0aFwiLFxuICAgICAgICAgICAgc3VmZml4OiBkZWYuc3VmZml4LFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLyAgICAkWm9kQ2hlY2tQcm9wZXJ0eSAgICAvLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGhhbmRsZUNoZWNrUHJvcGVydHlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKHByb3BlcnR5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0ICRab2RDaGVja1Byb3BlcnR5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1Byb3BlcnR5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5zY2hlbWEuX3pvZC5ydW4oe1xuICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQudmFsdWVbZGVmLnByb3BlcnR5XSxcbiAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVDaGVja1Byb3BlcnR5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgZGVmLnByb3BlcnR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2hlY2tQcm9wZXJ0eVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGRlZi5wcm9wZXJ0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWltZVR5cGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWltZVR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgbWltZVNldCA9IG5ldyBTZXQoZGVmLm1pbWUpO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGluc3QuX3pvZC5iYWcubWltZSA9IGRlZi5taW1lO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChtaW1lU2V0LmhhcyhwYXlsb2FkLnZhbHVlLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWVzOiBkZWYubWltZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLnR5cGUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tPdmVyd3JpdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrT3ZlcndyaXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYudHgocGF5bG9hZC52YWx1ZSk7XG4gICAgfTtcbn0pO1xuIiwgImV4cG9ydCBjbGFzcyBEb2Mge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MgPSBbXSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICBpZiAodGhpcylcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIGluZGVudGVkKGZuKSB7XG4gICAgICAgIHRoaXMuaW5kZW50ICs9IDE7XG4gICAgICAgIGZuKHRoaXMpO1xuICAgICAgICB0aGlzLmluZGVudCAtPSAxO1xuICAgIH1cbiAgICB3cml0ZShhcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcInN5bmNcIiB9KTtcbiAgICAgICAgICAgIGFyZyh0aGlzLCB7IGV4ZWN1dGlvbjogXCJhc3luY1wiIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhcmc7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHgpID0+IHgpO1xuICAgICAgICBjb25zdCBtaW5JbmRlbnQgPSBNYXRoLm1pbiguLi5saW5lcy5tYXAoKHgpID0+IHgubGVuZ3RoIC0geC50cmltU3RhcnQoKS5sZW5ndGgpKTtcbiAgICAgICAgY29uc3QgZGVkZW50ZWQgPSBsaW5lcy5tYXAoKHgpID0+IHguc2xpY2UobWluSW5kZW50KSkubWFwKCh4KSA9PiBcIiBcIi5yZXBlYXQodGhpcy5pbmRlbnQgKiAyKSArIHgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgZGVkZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBpbGUoKSB7XG4gICAgICAgIGNvbnN0IEYgPSBGdW5jdGlvbjtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXM/LmFyZ3M7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzPy5jb250ZW50ID8/IFtgYF07XG4gICAgICAgIGNvbnN0IGxpbmVzID0gWy4uLmNvbnRlbnQubWFwKCh4KSA9PiBgICAke3h9YCldO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhsaW5lcy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGKC4uLmFyZ3MsIGxpbmVzLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9IHtcbiAgICBtYWpvcjogNCxcbiAgICBtaW5vcjogMyxcbiAgICBwYXRjaDogNixcbn07XG4iLCAiaW1wb3J0ICogYXMgY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQgeyBEb2MgfSBmcm9tIFwiLi9kb2MuanNcIjtcbmltcG9ydCB7IHBhcnNlLCBwYXJzZUFzeW5jLCBzYWZlUGFyc2UsIHNhZmVQYXJzZUFzeW5jIH0gZnJvbSBcIi4vcGFyc2UuanNcIjtcbmltcG9ydCAqIGFzIHJlZ2V4ZXMgZnJvbSBcIi4vcmVnZXhlcy5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvbnMuanNcIjtcbmV4cG9ydCBjb25zdCAkWm9kVHlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGluc3QgPz8gKGluc3QgPSB7fSk7XG4gICAgaW5zdC5fem9kLmRlZiA9IGRlZjsgLy8gc2V0IF9kZWYgcHJvcGVydHlcbiAgICBpbnN0Ll96b2QuYmFnID0gaW5zdC5fem9kLmJhZyB8fCB7fTsgLy8gaW5pdGlhbGl6ZSBfYmFnIG9iamVjdFxuICAgIGluc3QuX3pvZC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBjaGVja3MgPSBbLi4uKGluc3QuX3pvZC5kZWYuY2hlY2tzID8/IFtdKV07XG4gICAgLy8gaWYgaW5zdCBpcyBpdHNlbGYgYSBjaGVja3MuJFpvZENoZWNrLCBydW4gaXQgYXMgYSBjaGVja1xuICAgIGlmIChpbnN0Ll96b2QudHJhaXRzLmhhcyhcIiRab2RDaGVja1wiKSkge1xuICAgICAgICBjaGVja3MudW5zaGlmdChpbnN0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBjaC5fem9kLm9uYXR0YWNoKSB7XG4gICAgICAgICAgICBmbihpbnN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hlY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBkZWZlcnJlZCBpbml0aWFsaXplclxuICAgICAgICAvLyBpbnN0Ll96b2QucGFyc2UgaXMgbm90IHlldCBkZWZpbmVkXG4gICAgICAgIChfYSA9IGluc3QuX3pvZCkuZGVmZXJyZWQgPz8gKF9hLmRlZmVycmVkID0gW10pO1xuICAgICAgICBpbnN0Ll96b2QuZGVmZXJyZWQ/LnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgaW5zdC5fem9kLnJ1biA9IGluc3QuX3pvZC5wYXJzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBydW5DaGVja3MgPSAocGF5bG9hZCwgY2hlY2tzLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGxldCBpc0Fib3J0ZWQgPSB1dGlsLmFib3J0ZWQocGF5bG9hZCk7XG4gICAgICAgICAgICBsZXQgYXN5bmNSZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIGNoZWNrcykge1xuICAgICAgICAgICAgICAgIGlmIChjaC5fem9kLmRlZi53aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFJ1biA9IGNoLl96b2QuZGVmLndoZW4ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUnVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckxlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBfID0gY2guX3pvZC5jaGVjayhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBpZiAoXyBpbnN0YW5jZW9mIFByb21pc2UgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jUmVzdWx0IHx8IF8gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jUmVzdWx0ID0gKGFzeW5jUmVzdWx0ID8/IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IF87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMZW4gPT09IGN1cnJMZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fib3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBYm9ydGVkID0gdXRpbC5hYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBYm9ydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYm9ydGVkID0gdXRpbC5hYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3luY1Jlc3VsdC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuYXJ5UmVzdWx0ID0gKGNhbmFyeSwgcGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgICAgICAvLyBhYm9ydCBpZiB0aGUgY2FuYXJ5IGlzIGFib3J0ZWRcbiAgICAgICAgICAgIGlmICh1dGlsLmFib3J0ZWQoY2FuYXJ5KSkge1xuICAgICAgICAgICAgICAgIGNhbmFyeS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuYXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcnVuIGNoZWNrcyBmaXJzdCwgdGhlblxuICAgICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBydW5DaGVja3MocGF5bG9hZCwgY2hlY2tzLCBjdHgpO1xuICAgICAgICAgICAgaWYgKGNoZWNrUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdHguYXN5bmMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1Jlc3VsdC50aGVuKChjaGVja1Jlc3VsdCkgPT4gaW5zdC5fem9kLnBhcnNlKGNoZWNrUmVzdWx0LCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0Ll96b2QucGFyc2UoY2hlY2tSZXN1bHQsIGN0eCk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3QuX3pvZC5ydW4gPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3R4LnNraXBDaGVja3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdC5fem9kLnBhcnNlKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gcnVuIGNhbmFyeVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgcGFzcyAobm8gY2hlY2tzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmFyeSA9IGluc3QuX3pvZC5wYXJzZSh7IHZhbHVlOiBwYXlsb2FkLnZhbHVlLCBpc3N1ZXM6IFtdIH0sIHsgLi4uY3R4LCBza2lwQ2hlY2tzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYW5hcnkgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5hcnkudGhlbigoY2FuYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2FuYXJ5UmVzdWx0KGNhbmFyeSwgcGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYW5hcnlSZXN1bHQoY2FuYXJ5LCBwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yd2FyZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5zdC5fem9kLnBhcnNlKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdHguYXN5bmMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiBydW5DaGVja3MocmVzdWx0LCBjaGVja3MsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bkNoZWNrcyhyZXN1bHQsIGNoZWNrcywgY3R4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTGF6eSBpbml0aWFsaXplIH5zdGFuZGFyZCB0byBhdm9pZCBjcmVhdGluZyBvYmplY3RzIGZvciBldmVyeSBzY2hlbWFcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdCwgXCJ+c3RhbmRhcmRcIiwgKCkgPT4gKHtcbiAgICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gc2FmZVBhcnNlKGluc3QsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5zdWNjZXNzID8geyB2YWx1ZTogci5kYXRhIH0gOiB7IGlzc3Vlczogci5lcnJvcj8uaXNzdWVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZlUGFyc2VBc3luYyhpbnN0LCB2YWx1ZSkudGhlbigocikgPT4gKHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICB9KSk7XG59KTtcbmV4cG9ydCB7IGNsb25lIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0ICRab2RTdHJpbmcgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN0cmluZ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gWy4uLihpbnN0Py5fem9kLmJhZz8ucGF0dGVybnMgPz8gW10pXS5wb3AoKSA/PyByZWdleGVzLnN0cmluZyhpbnN0Ll96b2QuYmFnKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgXykgPT4ge1xuICAgICAgICBpZiAoZGVmLmNvZXJjZSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IFN0cmluZyhwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RTdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN0cmluZ0Zvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gY2hlY2sgaW5pdGlhbGl6YXRpb24gbXVzdCBjb21lIGZpcnN0XG4gICAgY2hlY2tzLiRab2RDaGVja1N0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgJFpvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kR1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kR1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5ndWlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBpZiAoZGVmLnZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbk1hcCA9IHtcbiAgICAgICAgICAgIHYxOiAxLFxuICAgICAgICAgICAgdjI6IDIsXG4gICAgICAgICAgICB2MzogMyxcbiAgICAgICAgICAgIHY0OiA0LFxuICAgICAgICAgICAgdjU6IDUsXG4gICAgICAgICAgICB2NjogNixcbiAgICAgICAgICAgIHY3OiA3LFxuICAgICAgICAgICAgdjg6IDgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHYgPSB2ZXJzaW9uTWFwW2RlZi52ZXJzaW9uXTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVVUlEIHZlcnNpb246IFwiJHtkZWYudmVyc2lvbn1cImApO1xuICAgICAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnV1aWQodikpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMudXVpZCgpKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RFbWFpbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRW1haWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZW1haWwpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVSTCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGZyb20gaW5wdXRcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBwYXlsb2FkLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodHJpbW1lZCk7XG4gICAgICAgICAgICBpZiAoZGVmLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgZGVmLmhvc3RuYW1lLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWYuaG9zdG5hbWUudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogXCJJbnZhbGlkIGhvc3RuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBkZWYuaG9zdG5hbWUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBkZWYucHJvdG9jb2wubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZi5wcm90b2NvbC50ZXN0KHVybC5wcm90b2NvbC5lbmRzV2l0aChcIjpcIikgPyB1cmwucHJvdG9jb2wuc2xpY2UoMCwgLTEpIDogdXJsLnByb3RvY29sKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW52YWxpZCBwcm90b2NvbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZGVmLnByb3RvY29sLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIG91dHB1dCB2YWx1ZSBiYXNlZCBvbiBub3JtYWxpemUgZmxhZ1xuICAgICAgICAgICAgaWYgKGRlZi5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2Ugbm9ybWFsaXplZCBVUkxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdXJsLmhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgaW5wdXQgKHRyaW1tZWQpXG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHRyaW1tZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RFbW9qaSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRW1vamlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZW1vamkoKSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTmFub0lEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROYW5vSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMubmFub2lkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmN1aWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENVSUQyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDVUlEMlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5jdWlkMik7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVUxJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVUxJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy51bGlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RYSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFhJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy54aWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEtTVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RLU1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5rc3VpZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVNPRGF0ZVRpbWUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElTT0RhdGVUaW1lXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmRhdGV0aW1lKGRlZikpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElTT0RhdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElTT0RhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZGF0ZSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVNPVGltZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVNPVGltZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy50aW1lKGRlZikpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElTT0R1cmF0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJU09EdXJhdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5kdXJhdGlvbik7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVB2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVB2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5pcHY0KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuYmFnLmZvcm1hdCA9IGBpcHY0YDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJUHY2ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJUHY2XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmlwdjYpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuZm9ybWF0ID0gYGlwdjZgO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBuZXcgVVJMKGBodHRwOi8vWyR7cGF5bG9hZC52YWx1ZX1dYCk7XG4gICAgICAgICAgICAvLyByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJpcHY2XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RNQUMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE1BQ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5tYWMoZGVmLmRlbGltaXRlcikpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuZm9ybWF0ID0gYG1hY2A7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ0lEUnY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDSURSdjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuY2lkcnY0KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDSURSdjYgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENJRFJ2NlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5jaWRydjYpOyAvLyBub3QgdXNlZCBmb3IgdmFsaWRhdGlvblxuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF5bG9hZC52YWx1ZS5zcGxpdChcIi9cIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgW2FkZHJlc3MsIHByZWZpeF0gPSBwYXJ0cztcbiAgICAgICAgICAgIGlmICghcHJlZml4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4TnVtID0gTnVtYmVyKHByZWZpeCk7XG4gICAgICAgICAgICBpZiAoYCR7cHJlZml4TnVtfWAgIT09IHByZWZpeClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXhOdW0gPCAwIHx8IHByZWZpeE51bSA+IDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG5ldyBVUkwoYGh0dHA6Ly9bJHthZGRyZXNzfV1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImNpZHJ2NlwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFpvZEJhc2U2NCAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCYXNlNjQoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJSA0ICE9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBhdG9iKGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0ICRab2RCYXNlNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEJhc2U2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5iYXNlNjQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuY29udGVudEVuY29kaW5nID0gXCJiYXNlNjRcIjtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoaXNWYWxpZEJhc2U2NChwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgWm9kQmFzZTY0ICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEJhc2U2NFVSTChkYXRhKSB7XG4gICAgaWYgKCFyZWdleGVzLmJhc2U2NHVybC50ZXN0KGRhdGEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YS5yZXBsYWNlKC9bLV9dL2csIChjKSA9PiAoYyA9PT0gXCItXCIgPyBcIitcIiA6IFwiL1wiKSk7XG4gICAgY29uc3QgcGFkZGVkID0gYmFzZTY0LnBhZEVuZChNYXRoLmNlaWwoYmFzZTY0Lmxlbmd0aCAvIDQpICogNCwgXCI9XCIpO1xuICAgIHJldHVybiBpc1ZhbGlkQmFzZTY0KHBhZGRlZCk7XG59XG5leHBvcnQgY29uc3QgJFpvZEJhc2U2NFVSTCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQmFzZTY0VVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmJhc2U2NHVybCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmJhZy5jb250ZW50RW5jb2RpbmcgPSBcImJhc2U2NHVybFwiO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChpc1ZhbGlkQmFzZTY0VVJMKHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEUxNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEUxNjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZTE2NCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFpvZEpXVCAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRKV1QodG9rZW4sIGFsZ29yaXRobSA9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0b2tlbnNQYXJ0cyA9IHRva2VuLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKHRva2Vuc1BhcnRzLmxlbmd0aCAhPT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW2hlYWRlcl0gPSB0b2tlbnNQYXJ0cztcbiAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgcGFyc2VkSGVhZGVyID0gSlNPTi5wYXJzZShhdG9iKGhlYWRlcikpO1xuICAgICAgICBpZiAoXCJ0eXBcIiBpbiBwYXJzZWRIZWFkZXIgJiYgcGFyc2VkSGVhZGVyPy50eXAgIT09IFwiSldUXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyc2VkSGVhZGVyLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZ29yaXRobSAmJiAoIShcImFsZ1wiIGluIHBhcnNlZEhlYWRlcikgfHwgcGFyc2VkSGVhZGVyLmFsZyAhPT0gYWxnb3JpdGhtKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCAkWm9kSldUID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RKV1RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChpc1ZhbGlkSldUKHBheWxvYWQudmFsdWUsIGRlZi5hbGcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJqd3RcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ3VzdG9tU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmZuKHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogZGVmLmZvcm1hdCxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE51bWJlciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVtYmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBpbnN0Ll96b2QuYmFnLnBhdHRlcm4gPz8gcmVnZXhlcy5udW1iZXI7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBOdW1iZXIocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKGlucHV0KSAmJiBOdW1iZXIuaXNGaW5pdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNlaXZlZCA9IHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBOdW1iZXIuaXNOYU4oaW5wdXQpXG4gICAgICAgICAgICAgICAgPyBcIk5hTlwiXG4gICAgICAgICAgICAgICAgOiAhTnVtYmVyLmlzRmluaXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IFwiSW5maW5pdHlcIlxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgLi4uKHJlY2VpdmVkID8geyByZWNlaXZlZCB9IDoge30pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROdW1iZXJGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE51bWJlckZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY2hlY2tzLiRab2RDaGVja051bWJlckZvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgJFpvZE51bWJlci5pbml0KGluc3QsIGRlZik7IC8vIG5vIGZvcm1hdCBjaGVja3Ncbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RCb29sZWFuID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCb29sZWFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSByZWdleGVzLmJvb2xlYW47XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBCb29sZWFuKHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQmlnSW50ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCaWdJbnRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IHJlZ2V4ZXMuYmlnaW50O1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gQmlnSW50KHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJiaWdpbnRcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEJpZ0ludEZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQmlnSW50Rm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjaGVja3MuJFpvZENoZWNrQmlnSW50Rm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICAkWm9kQmlnSW50LmluaXQoaW5zdCwgZGVmKTsgLy8gbm8gZm9ybWF0IGNoZWNrc1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFN5bWJvbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU3ltYm9sXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN5bWJvbFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3ltYm9sXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVbmRlZmluZWQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVuZGVmaW5lZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gcmVnZXhlcy51bmRlZmluZWQ7XG4gICAgaW5zdC5fem9kLnZhbHVlcyA9IG5ldyBTZXQoW3VuZGVmaW5lZF0pO1xuICAgIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgICBpbnN0Ll96b2Qub3B0b3V0ID0gXCJvcHRpb25hbFwiO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTnVsbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVsbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gcmVnZXhlcy5udWxsO1xuICAgIGluc3QuX3pvZC52YWx1ZXMgPSBuZXcgU2V0KFtudWxsXSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJudWxsXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RBbnkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEFueVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkKSA9PiBwYXlsb2FkO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVua25vd24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVua25vd25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCkgPT4gcGF5bG9hZDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROZXZlciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTmV2ZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5ldmVyXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RWb2lkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RWb2lkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwidm9pZFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRGF0ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRGF0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBuZXcgRGF0ZShwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGlzRGF0ZSA9IGlucHV0IGluc3RhbmNlb2YgRGF0ZTtcbiAgICAgICAgY29uc3QgaXNWYWxpZERhdGUgPSBpc0RhdGUgJiYgIU51bWJlci5pc05hTihpbnB1dC5nZXRUaW1lKCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJkYXRlXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAuLi4oaXNEYXRlID8geyByZWNlaXZlZDogXCJJbnZhbGlkIERhdGVcIiB9IDoge30pLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgZmluYWwsIGluZGV4KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kQXJyYXkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEFycmF5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmVsZW1lbnQuX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkOyAvL2hhbmRsZUFycmF5UmVzdWx0c0FzeW5jKHBhcnNlUmVzdWx0cywgZmluYWwpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5UmVzdWx0KHJlc3VsdCwgZmluYWwsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRm9yIG9wdGlvbmFsLW91dCBzY2hlbWFzLCBpZ25vcmUgZXJyb3JzIG9uIGFic2VudCBrZXlzXG4gICAgICAgIGlmIChpc09wdGlvbmFsT3V0ICYmICEoa2V5IGluIGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVEZWYoZGVmKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlZi5zaGFwZSk7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFkZWYuc2hhcGU/LltrXT8uX3pvZD8udHJhaXRzPy5oYXMoXCIkWm9kVHlwZVwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgYXQga2V5IFwiJHtrfVwiOiBleHBlY3RlZCBhIFpvZCBzY2hlbWFgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBva2V5cyA9IHV0aWwub3B0aW9uYWxLZXlzKGRlZi5zaGFwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmLFxuICAgICAgICBrZXlzLFxuICAgICAgICBrZXlTZXQ6IG5ldyBTZXQoa2V5cyksXG4gICAgICAgIG51bUtleXM6IGtleXMubGVuZ3RoLFxuICAgICAgICBvcHRpb25hbEtleXM6IG5ldyBTZXQob2tleXMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDYXRjaGFsbChwcm9tcywgaW5wdXQsIHBheWxvYWQsIGN0eCwgZGVmLCBpbnN0KSB7XG4gICAgY29uc3QgdW5yZWNvZ25pemVkID0gW107XG4gICAgLy8gaXRlcmF0ZSBvdmVyIGlucHV0IGtleXNcbiAgICBjb25zdCBrZXlTZXQgPSBkZWYua2V5U2V0O1xuICAgIGNvbnN0IF9jYXRjaGFsbCA9IGRlZi5jYXRjaGFsbC5fem9kO1xuICAgIGNvbnN0IHQgPSBfY2F0Y2hhbGwuZGVmLnR5cGU7XG4gICAgY29uc3QgaXNPcHRpb25hbE91dCA9IF9jYXRjaGFsbC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoa2V5U2V0LmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0ID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgICAgIHVucmVjb2duaXplZC5wdXNoKGtleSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gX2NhdGNoYWxsLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbXMucHVzaChyLnRoZW4oKHIpID0+IGhhbmRsZVByb3BlcnR5UmVzdWx0KHIsIHBheWxvYWQsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodW5yZWNvZ25pemVkLmxlbmd0aCkge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICAgICAgICAgIGtleXM6IHVucmVjb2duaXplZCxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcHJvbXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kT2JqZWN0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RPYmplY3RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIHJlcXVpcmVzIGNhc3QgYmVjYXVzZSB0ZWNobmljYWxseSAkWm9kT2JqZWN0IGRvZXNuJ3QgZXh0ZW5kXG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIC8vIGNvbnN0IHNoID0gZGVmLnNoYXBlO1xuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZiwgXCJzaGFwZVwiKTtcbiAgICBpZiAoIWRlc2M/LmdldCkge1xuICAgICAgICBjb25zdCBzaCA9IGRlZi5zaGFwZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlZiwgXCJzaGFwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTaCA9IHsgLi4uc2ggfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVmLCBcInNoYXBlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1NoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBfbm9ybWFsaXplZCA9IHV0aWwuY2FjaGVkKCgpID0+IG5vcm1hbGl6ZURlZihkZWYpKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZTtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBzaGFwZVtrZXldLl96b2Q7XG4gICAgICAgICAgICBpZiAoZmllbGQudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlc1trZXldID8/IChwcm9wVmFsdWVzW2tleV0gPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBmaWVsZC52YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZXNba2V5XS5hZGQodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZXM7XG4gICAgfSk7XG4gICAgY29uc3QgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuICAgIGNvbnN0IGNhdGNoYWxsID0gZGVmLmNhdGNoYWxsO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHZhbHVlID8/ICh2YWx1ZSA9IF9ub3JtYWxpemVkLnZhbHVlKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWUuc2hhcGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWxPdXQgPSBlbC5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgICAgICAgICAgY29uc3QgciA9IGVsLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2goci50aGVuKChyKSA9PiBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUHJvcGVydHlSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaXNPcHRpb25hbE91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXRjaGFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21zLmxlbmd0aCA/IFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlQ2F0Y2hhbGwocHJvbXMsIGlucHV0LCBwYXlsb2FkLCBjdHgsIF9ub3JtYWxpemVkLnZhbHVlLCBpbnN0KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE9iamVjdEpJVCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kT2JqZWN0SklUXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyByZXF1aXJlcyBjYXN0IGJlY2F1c2UgdGVjaG5pY2FsbHkgJFpvZE9iamVjdCBkb2Vzbid0IGV4dGVuZFxuICAgICRab2RPYmplY3QuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IHN1cGVyUGFyc2UgPSBpbnN0Ll96b2QucGFyc2U7XG4gICAgY29uc3QgX25vcm1hbGl6ZWQgPSB1dGlsLmNhY2hlZCgoKSA9PiBub3JtYWxpemVEZWYoZGVmKSk7XG4gICAgY29uc3QgZ2VuZXJhdGVGYXN0cGFzcyA9IChzaGFwZSkgPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBuZXcgRG9jKFtcInNoYXBlXCIsIFwicGF5bG9hZFwiLCBcImN0eFwiXSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplZC52YWx1ZTtcbiAgICAgICAgY29uc3QgcGFyc2VTdHIgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrID0gdXRpbC5lc2Moa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBgc2hhcGVbJHtrfV0uX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRbJHtrfV0sIGlzc3VlczogW10gfSwgY3R4KWA7XG4gICAgICAgIH07XG4gICAgICAgIGRvYy53cml0ZShgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO2ApO1xuICAgICAgICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG5vcm1hbGl6ZWQua2V5cykge1xuICAgICAgICAgICAgaWRzW2tleV0gPSBga2V5XyR7Y291bnRlcisrfWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQTogcHJlc2VydmUga2V5IG9yZGVyIHtcbiAgICAgICAgZG9jLndyaXRlKGBjb25zdCBuZXdSZXN1bHQgPSB7fTtgKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGlkc1trZXldO1xuICAgICAgICAgICAgY29uc3QgayA9IHV0aWwuZXNjKGtleSk7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBzaGFwZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgaXNPcHRpb25hbE91dCA9IHNjaGVtYT8uX3pvZD8ub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gICAgICAgICAgICBkb2Mud3JpdGUoYGNvbnN0ICR7aWR9ID0gJHtwYXJzZVN0cihrZXkpfTtgKTtcbiAgICAgICAgICAgIGlmIChpc09wdGlvbmFsT3V0KSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9wdGlvbmFsLW91dCBzY2hlbWFzLCBpZ25vcmUgZXJyb3JzIG9uIGFic2VudCBrZXlzXG4gICAgICAgICAgICAgICAgZG9jLndyaXRlKGBcbiAgICAgICAgaWYgKCR7aWR9Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoJHtpZH0uaXNzdWVzLm1hcChpc3MgPT4gKHtcbiAgICAgICAgICAgICAgLi4uaXNzLFxuICAgICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2t9LCAuLi5pc3MucGF0aF0gOiBbJHtrfV1cbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoJHtpZH0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2Mud3JpdGUoYFxuICAgICAgICBpZiAoJHtpZH0uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gcGF5bG9hZC5pc3N1ZXMuY29uY2F0KCR7aWR9Lmlzc3Vlcy5tYXAoaXNzID0+ICh7XG4gICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2t9LCAuLi5pc3MucGF0aF0gOiBbJHtrfV1cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoJHtpZH0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9jLndyaXRlKGBwYXlsb2FkLnZhbHVlID0gbmV3UmVzdWx0O2ApO1xuICAgICAgICBkb2Mud3JpdGUoYHJldHVybiBwYXlsb2FkO2ApO1xuICAgICAgICBjb25zdCBmbiA9IGRvYy5jb21waWxlKCk7XG4gICAgICAgIHJldHVybiAocGF5bG9hZCwgY3R4KSA9PiBmbihzaGFwZSwgcGF5bG9hZCwgY3R4KTtcbiAgICB9O1xuICAgIGxldCBmYXN0cGFzcztcbiAgICBjb25zdCBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgY29uc3Qgaml0ID0gIWNvcmUuZ2xvYmFsQ29uZmlnLmppdGxlc3M7XG4gICAgY29uc3QgYWxsb3dzRXZhbCA9IHV0aWwuYWxsb3dzRXZhbDtcbiAgICBjb25zdCBmYXN0RW5hYmxlZCA9IGppdCAmJiBhbGxvd3NFdmFsLnZhbHVlOyAvLyAmJiAhZGVmLmNhdGNoYWxsO1xuICAgIGNvbnN0IGNhdGNoYWxsID0gZGVmLmNhdGNoYWxsO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHZhbHVlID8/ICh2YWx1ZSA9IF9ub3JtYWxpemVkLnZhbHVlKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaml0ICYmIGZhc3RFbmFibGVkICYmIGN0eD8uYXN5bmMgPT09IGZhbHNlICYmIGN0eC5qaXRsZXNzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgc3luY2hyb25vdXNcbiAgICAgICAgICAgIGlmICghZmFzdHBhc3MpXG4gICAgICAgICAgICAgICAgZmFzdHBhc3MgPSBnZW5lcmF0ZUZhc3RwYXNzKGRlZi5zaGFwZSk7XG4gICAgICAgICAgICBwYXlsb2FkID0gZmFzdHBhc3MocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmICghY2F0Y2hhbGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2F0Y2hhbGwoW10sIGlucHV0LCBwYXlsb2FkLCBjdHgsIHZhbHVlLCBpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXJQYXJzZShwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBmaW5hbCwgaW5zdCwgY3R4KSB7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZpbmFsLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vbmFib3J0ZWQgPSByZXN1bHRzLmZpbHRlcigocikgPT4gIXV0aWwuYWJvcnRlZChyKSk7XG4gICAgaWYgKG5vbmFib3J0ZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZpbmFsLnZhbHVlID0gbm9uYWJvcnRlZFswXS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5vbmFib3J0ZWRbMF07XG4gICAgfVxuICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgICAgIGlucHV0OiBmaW5hbC52YWx1ZSxcbiAgICAgICAgaW5zdCxcbiAgICAgICAgZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSksXG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbmFsO1xufVxuZXhwb3J0IGNvbnN0ICRab2RVbmlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHVuZGVmaW5lZCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLm9wdGlvbnMuc29tZSgobykgPT4gby5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHVuZGVmaW5lZCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICBpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC52YWx1ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldChkZWYub3B0aW9ucy5mbGF0TWFwKChvcHRpb24pID0+IEFycmF5LmZyb20ob3B0aW9uLl96b2QudmFsdWVzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5vcHRpb25zLmV2ZXJ5KChvKSA9PiBvLl96b2QucGF0dGVybikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5zID0gZGVmLm9wdGlvbnMubWFwKChvKSA9PiBvLl96b2QucGF0dGVybik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXigke3BhdHRlcm5zLm1hcCgocCkgPT4gdXRpbC5jbGVhblJlZ2V4KHAuc291cmNlKSkuam9pbihcInxcIil9KSRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGNvbnN0IHNpbmdsZSA9IGRlZi5vcHRpb25zLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBmaXJzdCA9IGRlZi5vcHRpb25zWzBdLl96b2QucnVuO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0KHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzeW5jID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fem9kLnJ1bih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFzeW5jKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVFeGNsdXNpdmVVbmlvblJlc3VsdHMocmVzdWx0cywgZmluYWwsIGluc3QsIGN0eCkge1xuICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IHJlc3VsdHMuZmlsdGVyKChyKSA9PiByLmlzc3Vlcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZpbmFsLnZhbHVlID0gc3VjY2Vzc2VzWzBdLnZhbHVlO1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgfVxuICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIE5vIG1hdGNoZXMgLSBzYW1lIGFzIHJlZ3VsYXIgdW5pb25cbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogZmluYWwudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgbWF0Y2hlcyAtIGV4Y2x1c2l2ZSB1bmlvbiBmYWlsdXJlXG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgICAgICAgICAgaW5wdXQ6IGZpbmFsLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsO1xufVxuZXhwb3J0IGNvbnN0ICRab2RYb3IgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFhvclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBkZWYuaW5jbHVzaXZlID0gZmFsc2U7XG4gICAgY29uc3Qgc2luZ2xlID0gZGVmLm9wdGlvbnMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IGZpcnN0ID0gZGVmLm9wdGlvbnNbMF0uX3pvZC5ydW47XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl96b2QucnVuKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeGNsdXNpdmVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeGNsdXNpdmVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2REaXNjcmltaW5hdGVkVW5pb24gPSBcbi8qQF9fUFVSRV9fKi9cbmNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZERpc2NyaW1pbmF0ZWRVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLmluY2x1c2l2ZSA9IGZhbHNlO1xuICAgICRab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgX3N1cGVyID0gaW5zdC5fem9kLnBhcnNlO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHB2ID0gb3B0aW9uLl96b2QucHJvcFZhbHVlcztcbiAgICAgICAgICAgIGlmICghcHYgfHwgT2JqZWN0LmtleXMocHYpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGlzY3JpbWluYXRlZCB1bmlvbiBvcHRpb24gYXQgaW5kZXggXCIke2RlZi5vcHRpb25zLmluZGV4T2Yob3B0aW9uKX1cImApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wVmFsdWVzW2tdKVxuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWVzW2tdID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlc1trXS5hZGQodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZXM7XG4gICAgfSk7XG4gICAgY29uc3QgZGlzYyA9IHV0aWwuY2FjaGVkKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGRlZi5vcHRpb25zO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiBvcHRzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvLl96b2QucHJvcFZhbHVlcz8uW2RlZi5kaXNjcmltaW5hdG9yXTtcbiAgICAgICAgICAgIGlmICghdmFsdWVzIHx8IHZhbHVlcy5zaXplID09PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaXNjcmltaW5hdGVkIHVuaW9uIG9wdGlvbiBhdCBpbmRleCBcIiR7ZGVmLm9wdGlvbnMuaW5kZXhPZihvKX1cImApO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChtYXAuaGFzKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGRpc2NyaW1pbmF0b3IgdmFsdWUgXCIke1N0cmluZyh2KX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXAuc2V0KHYsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghdXRpbC5pc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gZGlzYy52YWx1ZS5nZXQoaW5wdXQ/LltkZWYuZGlzY3JpbWluYXRvcl0pO1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0Ll96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi51bmlvbkZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgZGlzY3JpbWluYXRvclxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgIG5vdGU6IFwiTm8gbWF0Y2hpbmcgZGlzY3JpbWluYXRvclwiLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcjogZGVmLmRpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHBhdGg6IFtkZWYuZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJbnRlcnNlY3Rpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEludGVyc2VjdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZGVmLmxlZnQuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXQsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBkZWYucmlnaHQuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXQsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgY29uc3QgYXN5bmMgPSBsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCByaWdodCBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsZWZ0LCByaWdodF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIC8vIGNvbnN0IGFUeXBlID0gcGFyc2UudChhKTtcbiAgICAvLyBjb25zdCBiVHlwZSA9IHBhcnNlLnQoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlICYmICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGEpICYmIHV0aWwuaXNQbGFpbk9iamVjdChiKSkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gT2JqZWN0LmtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZUVycm9yUGF0aDogW2tleSwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVyZ2VFcnJvclBhdGg6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlRXJyb3JQYXRoOiBbaW5kZXgsIC4uLnNoYXJlZFZhbHVlLm1lcmdlRXJyb3JQYXRoXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXJnZUVycm9yUGF0aDogW10gfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocmVzdWx0LCBsZWZ0LCByaWdodCkge1xuICAgIC8vIFRyYWNrIHdoaWNoIHNpZGUocykgcmVwb3J0IGVhY2gga2V5IGFzIHVucmVjb2duaXplZFxuICAgIGNvbnN0IHVucmVjS2V5cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdW5yZWNJc3N1ZTtcbiAgICBmb3IgKGNvbnN0IGlzcyBvZiBsZWZ0Lmlzc3Vlcykge1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIikge1xuICAgICAgICAgICAgdW5yZWNJc3N1ZSA/PyAodW5yZWNJc3N1ZSA9IGlzcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgaXNzLmtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVucmVjS2V5cy5oYXMoaykpXG4gICAgICAgICAgICAgICAgICAgIHVucmVjS2V5cy5zZXQoaywge30pO1xuICAgICAgICAgICAgICAgIHVucmVjS2V5cy5nZXQoaykubCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaXNzdWVzLnB1c2goaXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlzcyBvZiByaWdodC5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBpc3Mua2V5cykge1xuICAgICAgICAgICAgICAgIGlmICghdW5yZWNLZXlzLmhhcyhrKSlcbiAgICAgICAgICAgICAgICAgICAgdW5yZWNLZXlzLnNldChrLCB7fSk7XG4gICAgICAgICAgICAgICAgdW5yZWNLZXlzLmdldChrKS5yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc3N1ZXMucHVzaChpc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlcG9ydCBvbmx5IGtleXMgdW5yZWNvZ25pemVkIGJ5IEJPVEggc2lkZXNcbiAgICBjb25zdCBib3RoS2V5cyA9IFsuLi51bnJlY0tleXNdLmZpbHRlcigoWywgZl0pID0+IGYubCAmJiBmLnIpLm1hcCgoW2tdKSA9PiBrKTtcbiAgICBpZiAoYm90aEtleXMubGVuZ3RoICYmIHVucmVjSXNzdWUpIHtcbiAgICAgICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKHsgLi4udW5yZWNJc3N1ZSwga2V5czogYm90aEtleXMgfSk7XG4gICAgfVxuICAgIGlmICh1dGlsLmFib3J0ZWQocmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhsZWZ0LnZhbHVlLCByaWdodC52YWx1ZSk7XG4gICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbm1lcmdhYmxlIGludGVyc2VjdGlvbi4gRXJyb3IgcGF0aDogYCArIGAke0pTT04uc3RyaW5naWZ5KG1lcmdlZC5tZXJnZUVycm9yUGF0aCl9YCk7XG4gICAgfVxuICAgIHJlc3VsdC52YWx1ZSA9IG1lcmdlZC5kYXRhO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFR1cGxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RUdXBsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IGl0ZW1zID0gZGVmLml0ZW1zO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IFtdO1xuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBjb25zdCByZXZlcnNlZEluZGV4ID0gWy4uLml0ZW1zXS5yZXZlcnNlKCkuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtLl96b2Qub3B0aW4gIT09IFwib3B0aW9uYWxcIik7XG4gICAgICAgIGNvbnN0IG9wdFN0YXJ0ID0gcmV2ZXJzZWRJbmRleCA9PT0gLTEgPyAwIDogaXRlbXMubGVuZ3RoIC0gcmV2ZXJzZWRJbmRleDtcbiAgICAgICAgaWYgKCFkZWYucmVzdCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQubGVuZ3RoID4gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5sZW5ndGggPCBvcHRTdGFydCAtIDE7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLih0b29CaWdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogaXRlbXMubGVuZ3RoLCBpbmNsdXNpdmU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvZGU6IFwidG9vX3NtYWxsXCIsIG1pbmltdW06IGl0ZW1zLmxlbmd0aCB9KSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPj0gaW5wdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGlmIChpID49IG9wdFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtpXSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucmVzdCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdCA9IGlucHV0LnNsaWNlKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHJlc3QpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLnJlc3QuX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgZmluYWwsIGluZGV4KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kUmVjb3JkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RSZWNvcmRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCF1dGlsLmlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlZi5rZXlUeXBlLl96b2QudmFsdWVzO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0ge307XG4gICAgICAgICAgICBjb25zdCByZWNvcmRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEtleXMuYWRkKHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIgPyBrZXkudG9TdHJpbmcoKSA6IGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdW5yZWNvZ25pemVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY29yZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWNvZ25pemVkID0gdW5yZWNvZ25pemVkID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICB1bnJlY29nbml6ZWQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bnJlY29nbml6ZWQgJiYgdW5yZWNvZ25pemVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAga2V5czogdW5yZWNvZ25pemVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBrZXlSZXN1bHQgPSBkZWYua2V5VHlwZS5fem9kLnJ1bih7IHZhbHVlOiBrZXksIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyBzY2hlbWFzIG5vdCBzdXBwb3J0ZWQgaW4gb2JqZWN0IGtleXMgY3VycmVudGx5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOdW1lcmljIHN0cmluZyBmYWxsYmFjazogaWYga2V5IGlzIGEgbnVtZXJpYyBzdHJpbmcgYW5kIGZhaWxlZCwgcmV0cnkgd2l0aCBOdW1iZXIoa2V5KVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB6Lm51bWJlcigpLCB6LmxpdGVyYWwoWzEsIDIsIDNdKSwgYW5kIHVuaW9ucyBjb250YWluaW5nIG51bWVyaWMgbGl0ZXJhbHNcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja051bWVyaWNLZXkgPSB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIHJlZ2V4ZXMubnVtYmVyLnRlc3Qoa2V5KSAmJiBrZXlSZXN1bHQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tOdW1lcmljS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5UmVzdWx0ID0gZGVmLmtleVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogTnVtYmVyKGtleSksIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgc2NoZW1hcyBub3Qgc3VwcG9ydGVkIGluIG9iamVjdCBrZXlzIGN1cnJlbnRseVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlSZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5UmVzdWx0ID0gcmV0cnlSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleVJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYubW9kZSA9PT0gXCJsb29zZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggdW5jaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBcInN0cmljdFwiIGJlaGF2aW9yOiBlcnJvciBvbiBpbnZhbGlkIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2tleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGtleVJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYudmFsdWVUeXBlLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleVJlc3VsdC52YWx1ZV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleVJlc3VsdC52YWx1ZV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE1hcCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTWFwXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpbnB1dCkge1xuICAgICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gZGVmLmtleVR5cGUuX3pvZC5ydW4oeyB2YWx1ZToga2V5LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChrZXlSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHZhbHVlUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2goUHJvbWlzZS5hbGwoW2tleVJlc3VsdCwgdmFsdWVSZXN1bHRdKS50aGVuKChba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTWFwUmVzdWx0KGtleVJlc3VsdCwgdmFsdWVSZXN1bHQsIHBheWxvYWQsIGtleSwgaW5wdXQsIGluc3QsIGN0eCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWFwUmVzdWx0KGtleVJlc3VsdCwgdmFsdWVSZXN1bHQsIHBheWxvYWQsIGtleSwgaW5wdXQsIGluc3QsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlTWFwUmVzdWx0KGtleVJlc3VsdCwgdmFsdWVSZXN1bHQsIGZpbmFsLCBrZXksIGlucHV0LCBpbnN0LCBjdHgpIHtcbiAgICBpZiAoa2V5UmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHV0aWwucHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGtleSkpIHtcbiAgICAgICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwga2V5UmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9rZXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGtleVJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlUmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHV0aWwucHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGtleSkpIHtcbiAgICAgICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgdmFsdWVSZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm1hcFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9lbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IHZhbHVlUmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbC52YWx1ZS5zZXQoa2V5UmVzdWx0LnZhbHVlLCB2YWx1ZVJlc3VsdC52YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgJFpvZFNldCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU2V0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJzZXRcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaXRlbSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZVNldFJlc3VsdChyZXN1bHQsIHBheWxvYWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlU2V0UmVzdWx0KHJlc3VsdCwgZmluYWwpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucmVzdWx0Lmlzc3Vlcyk7XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlLmFkZChyZXN1bHQudmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RFbnVtID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgdmFsdWVzID0gdXRpbC5nZXRFbnVtVmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgICBjb25zdCB2YWx1ZXNTZXQgPSBuZXcgU2V0KHZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnZhbHVlcyA9IHZhbHVlc1NldDtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IG5ldyBSZWdFeHAoYF4oJHt2YWx1ZXNcbiAgICAgICAgLmZpbHRlcigoaykgPT4gdXRpbC5wcm9wZXJ0eUtleVR5cGVzLmhhcyh0eXBlb2YgaykpXG4gICAgICAgIC5tYXAoKG8pID0+ICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIiA/IHV0aWwuZXNjYXBlUmVnZXgobykgOiBvLnRvU3RyaW5nKCkpKVxuICAgICAgICAuam9pbihcInxcIil9KSRgKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZXNTZXQuaGFzKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTGl0ZXJhbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGlmIChkZWYudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGxpdGVyYWwgc2NoZW1hIHdpdGggbm8gdmFsaWQgdmFsdWVzXCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KGRlZi52YWx1ZXMpO1xuICAgIGluc3QuX3pvZC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeKCR7ZGVmLnZhbHVlc1xuICAgICAgICAubWFwKChvKSA9PiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyB1dGlsLmVzY2FwZVJlZ2V4KG8pIDogbyA/IHV0aWwuZXNjYXBlUmVnZXgoby50b1N0cmluZygpKSA6IFN0cmluZyhvKSkpXG4gICAgICAgIC5qb2luKFwifFwiKX0pJGApO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlcy5oYXMoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWVzOiBkZWYudmFsdWVzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RGaWxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RGaWxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJmaWxlXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RUcmFuc2Zvcm0gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFRyYW5zZm9ybVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEVuY29kZUVycm9yKGluc3QuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX291dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgICAgIGlmIChjdHguYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlID8gX291dCA6IFByb21pc2UucmVzb2x2ZShfb3V0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gX291dDtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCAmJiBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGlzc3VlczogW10sIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kT3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICAgIGluc3QuX3pvZC5vcHRvdXQgPSBcIm9wdGlvbmFsXCI7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyA/IG5ldyBTZXQoWy4uLmRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMsIHVuZGVmaW5lZF0pIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBkZWYuaW5uZXJUeXBlLl96b2QucGF0dGVybjtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPyBuZXcgUmVnRXhwKGBeKCR7dXRpbC5jbGVhblJlZ2V4KHBhdHRlcm4uc291cmNlKX0pPyRgKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyKSA9PiBoYW5kbGVPcHRpb25hbFJlc3VsdChyLCBwYXlsb2FkLnZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRXhhY3RPcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRXhhY3RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gQ2FsbCBwYXJlbnQgaW5pdCAtIGluaGVyaXRzIG9wdGluL29wdG91dCA9IFwib3B0aW9uYWxcIlxuICAgICRab2RPcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gT3ZlcnJpZGUgdmFsdWVzL3BhdHRlcm4gdG8gTk9UIGFkZCB1bmRlZmluZWRcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm4pO1xuICAgIC8vIE92ZXJyaWRlIHBhcnNlIHRvIGp1c3QgZGVsZWdhdGUgKG5vIHVuZGVmaW5lZCBoYW5kbGluZylcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROdWxsYWJsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVsbGFibGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuICAgICAgICByZXR1cm4gcGF0dGVybiA/IG5ldyBSZWdFeHAoYF4oJHt1dGlsLmNsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfXxudWxsKSRgKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzID8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgbnVsbF0pIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb24gKGRlY29kZSk6IGFsbG93IG51bGwgdG8gcGFzcyB0aHJvdWdoXG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2REZWZhdWx0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gaW5zdC5fem9kLnFpbiA9IFwidHJ1ZVwiO1xuICAgIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb24gKGRlY29kZSk6IGFwcGx5IGRlZmF1bHRzIGZvciB1bmRlZmluZWQgaW5wdXRcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICRab2REZWZhdWx0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgaW1tZWRpYXRlbHkgaW4gZm9yd2FyZCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgKiBJdCBkb2Vzbid0IHBhc3MgdGhlIGRlZmF1bHQgdmFsdWUgaW50byB0aGUgdmFsaWRhdG9yIChcInByZWZhdWx0XCIpLiBUaGVyZSdzIG5vIHJlYXNvbiB0byBwYXNzIHRoZSBkZWZhdWx0IHZhbHVlIHRocm91Z2ggdmFsaWRhdGlvbi4gVGhlIHZhbGlkaXR5IG9mIHRoZSBkZWZhdWx0IGlzIGVuZm9yY2VkIGJ5IFR5cGVTY3JpcHQgc3RhdGljYWxseS4gT3RoZXJ3aXNlLCBpdCdzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlciB0byBlbnN1cmUgdGhlIGRlZmF1bHQgaXMgdmFsaWQuIEluIHRoZSBjYXNlIG9mIHBpcGVzIHdpdGggZGl2ZXJnZW50IGluL291dCB0eXBlcywgeW91IGNhbiBzcGVjaWZ5IHRoZSBkZWZhdWx0IG9uIHRoZSBgaW5gIHNjaGVtYSBvZiB5b3VyIFpvZFBpcGUgdG8gc2V0IGEgXCJwcmVmYXVsdFwiIGZvciB0aGUgcGlwZS4gICAqL1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb246IGNvbnRpbnVlIHdpdGggZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQsIGRlZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVEZWZhdWx0UmVzdWx0KHJlc3VsdCwgZGVmKTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVEZWZhdWx0UmVzdWx0KHBheWxvYWQsIGRlZikge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xufVxuZXhwb3J0IGNvbnN0ICRab2RQcmVmYXVsdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kUHJlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcndhcmQgZGlyZWN0aW9uIChkZWNvZGUpOiBhcHBseSBwcmVmYXVsdCBmb3IgdW5kZWZpbmVkIGlucHV0XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROb25PcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTm9uT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzO1xuICAgICAgICByZXR1cm4gdiA/IG5ldyBTZXQoWy4uLnZdLmZpbHRlcigoeCkgPT4geCAhPT0gdW5kZWZpbmVkKSkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgaW5zdCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocGF5bG9hZCwgaW5zdCkge1xuICAgIGlmICghcGF5bG9hZC5pc3N1ZXMubGVuZ3RoICYmIHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBleHBlY3RlZDogXCJub25vcHRpb25hbFwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFN1Y2Nlc3MgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN1Y2Nlc3NcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RFbmNvZGVFcnJvcihcIlpvZFN1Y2Nlc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2F0Y2ggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3J3YXJkIGRpcmVjdGlvbiAoZGVjb2RlKTogYXBwbHkgY2F0Y2ggbG9naWNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTmFOID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROYU5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc05hTihwYXlsb2FkLnZhbHVlKSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJuYW5cIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFBpcGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC52YWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmluLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vdXQuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC5wcm9wVmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZGVmLm91dC5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodC50aGVuKChyaWdodCkgPT4gaGFuZGxlUGlwZVJlc3VsdChyaWdodCwgZGVmLmluLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQaXBlUmVzdWx0KHJpZ2h0LCBkZWYuaW4sIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdCA9IGRlZi5pbi5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnRoZW4oKGxlZnQpID0+IGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLm91dCwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLm91dCwgY3R4KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIG5leHQsIGN0eCkge1xuICAgIGlmIChsZWZ0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcHJldmVudCBmdXJ0aGVyIGNoZWNrc1xuICAgICAgICBsZWZ0LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQuX3pvZC5ydW4oeyB2YWx1ZTogbGVmdC52YWx1ZSwgaXNzdWVzOiBsZWZ0Lmlzc3VlcyB9LCBjdHgpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RDb2RlYyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ29kZWNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC52YWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmluLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vdXQuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC5wcm9wVmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGN0eC5kaXJlY3Rpb24gfHwgXCJmb3J3YXJkXCI7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZGVmLmluLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC50aGVuKChsZWZ0KSA9PiBoYW5kbGVDb2RlY0FSZXN1bHQobGVmdCwgZGVmLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDb2RlY0FSZXN1bHQobGVmdCwgZGVmLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBkZWYub3V0Ll96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0LnRoZW4oKHJpZ2h0KSA9PiBoYW5kbGVDb2RlY0FSZXN1bHQocmlnaHQsIGRlZiwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ29kZWNBUmVzdWx0KHJpZ2h0LCBkZWYsIGN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVDb2RlY0FSZXN1bHQocmVzdWx0LCBkZWYsIGN0eCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAvLyBwcmV2ZW50IGZ1cnRoZXIgY2hlY2tzXG4gICAgICAgIHJlc3VsdC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gY3R4LmRpcmVjdGlvbiB8fCBcImZvcndhcmRcIjtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImZvcndhcmRcIikge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IGRlZi50cmFuc2Zvcm0ocmVzdWx0LnZhbHVlLCByZXN1bHQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQudGhlbigodmFsdWUpID0+IGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB2YWx1ZSwgZGVmLm91dCwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB0cmFuc2Zvcm1lZCwgZGVmLm91dCwgY3R4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gZGVmLnJldmVyc2VUcmFuc2Zvcm0ocmVzdWx0LnZhbHVlLCByZXN1bHQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQudGhlbigodmFsdWUpID0+IGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB2YWx1ZSwgZGVmLmluLCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlQ29kZWNUeFJlc3VsdChyZXN1bHQsIHRyYW5zZm9ybWVkLCBkZWYuaW4sIGN0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ29kZWNUeFJlc3VsdChsZWZ0LCB2YWx1ZSwgbmV4dFNjaGVtYSwgY3R4KSB7XG4gICAgLy8gQ2hlY2sgaWYgdHJhbnNmb3JtIGFkZGVkIGFueSBpc3N1ZXNcbiAgICBpZiAobGVmdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxlZnQuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IGxlZnQuaXNzdWVzIH0sIGN0eCk7XG59XG5leHBvcnQgY29uc3QgJFpvZFJlYWRvbmx5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RSZWFkb25seVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QucHJvcFZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlPy5fem9kPy5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZT8uX3pvZD8ub3B0b3V0KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGhhbmRsZVJlYWRvbmx5UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlUmVhZG9ubHlSZXN1bHQocmVzdWx0KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWFkb25seVJlc3VsdChwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC52YWx1ZSA9IE9iamVjdC5mcmVlemUocGF5bG9hZC52YWx1ZSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFRlbXBsYXRlTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVGVtcGxhdGVMaXRlcmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgcmVnZXhQYXJ0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBkZWYucGFydHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcIm9iamVjdFwiICYmIHBhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGlzIFpvZCBzY2hlbWFcbiAgICAgICAgICAgIGlmICghcGFydC5fem9kLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVtcGxhdGUgbGl0ZXJhbCBwYXJ0LCBubyBwYXR0ZXJuIGZvdW5kOiAke1suLi5wYXJ0Ll96b2QudHJhaXRzXS5zaGlmdCgpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gcGFydC5fem9kLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAgPyBwYXJ0Ll96b2QucGF0dGVybi5zb3VyY2UgOiBwYXJ0Ll96b2QucGF0dGVybjtcbiAgICAgICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZW1wbGF0ZSBsaXRlcmFsIHBhcnQ6ICR7cGFydC5fem9kLnRyYWl0c31gKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc291cmNlLnN0YXJ0c1dpdGgoXCJeXCIpID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzb3VyY2UuZW5kc1dpdGgoXCIkXCIpID8gc291cmNlLmxlbmd0aCAtIDEgOiBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgcmVnZXhQYXJ0cy5wdXNoKHNvdXJjZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gbnVsbCB8fCB1dGlsLnByaW1pdGl2ZVR5cGVzLmhhcyh0eXBlb2YgcGFydCkpIHtcbiAgICAgICAgICAgIHJlZ2V4UGFydHMucHVzaCh1dGlsLmVzY2FwZVJlZ2V4KGAke3BhcnR9YCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlIGxpdGVyYWwgcGFydDogJHtwYXJ0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gbmV3IFJlZ0V4cChgXiR7cmVnZXhQYXJ0cy5qb2luKFwiXCIpfSRgKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdC5fem9kLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKCFpbnN0Ll96b2QucGF0dGVybi50ZXN0KHBheWxvYWQudmFsdWUpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRlZi5mb3JtYXQgPz8gXCJ0ZW1wbGF0ZV9saXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogaW5zdC5fem9kLnBhdHRlcm4uc291cmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEZ1bmN0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RGdW5jdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX2RlZiA9IGRlZjtcbiAgICBpbnN0Ll96b2QuZGVmID0gZGVmO1xuICAgIGluc3QuaW1wbGVtZW50ID0gKGZ1bmMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcGxlbWVudCgpIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBpbnN0Ll9kZWYuaW5wdXQgPyBwYXJzZShpbnN0Ll9kZWYuaW5wdXQsIGFyZ3MpIDogYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZnVuYywgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICBpZiAoaW5zdC5fZGVmLm91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZShpbnN0Ll9kZWYub3V0cHV0LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGluc3QuaW1wbGVtZW50QXN5bmMgPSAoZnVuYykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50QXN5bmMoKSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gaW5zdC5fZGVmLmlucHV0ID8gYXdhaXQgcGFyc2VBc3luYyhpbnN0Ll9kZWYuaW5wdXQsIGFyZ3MpIDogYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFJlZmxlY3QuYXBwbHkoZnVuYywgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICBpZiAoaW5zdC5fZGVmLm91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwYXJzZUFzeW5jKGluc3QuX2RlZi5vdXRwdXQsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBvdXRwdXQgaXMgYSBwcm9taXNlIHR5cGUgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgYXN5bmMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgaGFzUHJvbWlzZU91dHB1dCA9IGluc3QuX2RlZi5vdXRwdXQgJiYgaW5zdC5fZGVmLm91dHB1dC5fem9kLmRlZi50eXBlID09PSBcInByb21pc2VcIjtcbiAgICAgICAgaWYgKGhhc1Byb21pc2VPdXRwdXQpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBpbnN0LmltcGxlbWVudEFzeW5jKHBheWxvYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGluc3QuaW1wbGVtZW50KHBheWxvYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG4gICAgaW5zdC5pbnB1dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IEYgPSBpbnN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IG5ldyAkWm9kVHVwbGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICByZXN0OiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG91dHB1dDogaW5zdC5fZGVmLm91dHB1dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRih7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogYXJnc1swXSxcbiAgICAgICAgICAgIG91dHB1dDogaW5zdC5fZGVmLm91dHB1dCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpbnN0Lm91dHB1dCA9IChvdXRwdXQpID0+IHtcbiAgICAgICAgY29uc3QgRiA9IGluc3QuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgRih7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogaW5zdC5fZGVmLmlucHV0LFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBpbnN0O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFByb21pc2UgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFByb21pc2VcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGF5bG9hZC52YWx1ZSkudGhlbigoaW5uZXIpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaW5uZXIsIGlzc3VlczogW10gfSwgY3R4KSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RMYXp5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RMYXp5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gbGV0IF9pbm5lclR5cGUhOiBhbnk7XG4gICAgLy8gdXRpbC5kZWZpbmVMYXp5KGRlZiwgXCJnZXR0ZXJcIiwgKCkgPT4ge1xuICAgIC8vICAgaWYgKCFfaW5uZXJUeXBlKSB7XG4gICAgLy8gICAgIF9pbm5lclR5cGUgPSBkZWYuZ2V0dGVyKCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gKCkgPT4gX2lubmVyVHlwZTtcbiAgICAvLyB9KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcImlubmVyVHlwZVwiLCAoKSA9PiBkZWYuZ2V0dGVyKCkpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiBpbnN0Ll96b2QuaW5uZXJUeXBlPy5fem9kPy5wYXR0ZXJuKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gaW5zdC5fem9kLmlubmVyVHlwZT8uX3pvZD8ucHJvcFZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBpbnN0Ll96b2QuaW5uZXJUeXBlPy5fem9kPy5vcHRpbiA/PyB1bmRlZmluZWQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGluc3QuX3pvZC5pbm5lclR5cGU/Ll96b2Q/Lm9wdG91dCA/PyB1bmRlZmluZWQpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBpbnN0Ll96b2QuaW5uZXJUeXBlO1xuICAgICAgICByZXR1cm4gaW5uZXIuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEN1c3RvbSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ3VzdG9tXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjaGVja3MuJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF8pID0+IHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHIgPSBkZWYuZm4oaW5wdXQpO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByLnRoZW4oKHIpID0+IGhhbmRsZVJlZmluZVJlc3VsdChyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVJlZmluZVJlc3VsdChyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWZpbmVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkge1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IF9pc3MgPSB7XG4gICAgICAgICAgICBjb2RlOiBcImN1c3RvbVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LCAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICAgICAgICBwYXRoOiBbLi4uKGluc3QuX3pvZC5kZWYucGF0aCA/PyBbXSldLCAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICAgICAgICBjb250aW51ZTogIWluc3QuX3pvZC5kZWYuYWJvcnQsXG4gICAgICAgICAgICAvLyBwYXJhbXM6IGluc3QuX3pvZC5kZWYucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5zdC5fem9kLmRlZi5wYXJhbXMpXG4gICAgICAgICAgICBfaXNzLnBhcmFtcyA9IGluc3QuX3pvZC5kZWYucGFyYW1zO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWwuaXNzdWUoX2lzcykpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuLi9jb3JlL3V0aWwuanNcIjtcbmNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgIGNvbnN0IFNpemFibGUgPSB7XG4gICAgICAgIHN0cmluZzogeyB1bml0OiBcImNoYXJhY3RlcnNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgZmlsZTogeyB1bml0OiBcImJ5dGVzXCIsIHZlcmI6IFwidG8gaGF2ZVwiIH0sXG4gICAgICAgIGFycmF5OiB7IHVuaXQ6IFwiaXRlbXNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgc2V0OiB7IHVuaXQ6IFwiaXRlbXNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgbWFwOiB7IHVuaXQ6IFwiZW50cmllc1wiLCB2ZXJiOiBcInRvIGhhdmVcIiB9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0U2l6aW5nKG9yaWdpbikge1xuICAgICAgICByZXR1cm4gU2l6YWJsZVtvcmlnaW5dID8/IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IEZvcm1hdERpY3Rpb25hcnkgPSB7XG4gICAgICAgIHJlZ2V4OiBcImlucHV0XCIsXG4gICAgICAgIGVtYWlsOiBcImVtYWlsIGFkZHJlc3NcIixcbiAgICAgICAgdXJsOiBcIlVSTFwiLFxuICAgICAgICBlbW9qaTogXCJlbW9qaVwiLFxuICAgICAgICB1dWlkOiBcIlVVSURcIixcbiAgICAgICAgdXVpZHY0OiBcIlVVSUR2NFwiLFxuICAgICAgICB1dWlkdjY6IFwiVVVJRHY2XCIsXG4gICAgICAgIG5hbm9pZDogXCJuYW5vaWRcIixcbiAgICAgICAgZ3VpZDogXCJHVUlEXCIsXG4gICAgICAgIGN1aWQ6IFwiY3VpZFwiLFxuICAgICAgICBjdWlkMjogXCJjdWlkMlwiLFxuICAgICAgICB1bGlkOiBcIlVMSURcIixcbiAgICAgICAgeGlkOiBcIlhJRFwiLFxuICAgICAgICBrc3VpZDogXCJLU1VJRFwiLFxuICAgICAgICBkYXRldGltZTogXCJJU08gZGF0ZXRpbWVcIixcbiAgICAgICAgZGF0ZTogXCJJU08gZGF0ZVwiLFxuICAgICAgICB0aW1lOiBcIklTTyB0aW1lXCIsXG4gICAgICAgIGR1cmF0aW9uOiBcIklTTyBkdXJhdGlvblwiLFxuICAgICAgICBpcHY0OiBcIklQdjQgYWRkcmVzc1wiLFxuICAgICAgICBpcHY2OiBcIklQdjYgYWRkcmVzc1wiLFxuICAgICAgICBtYWM6IFwiTUFDIGFkZHJlc3NcIixcbiAgICAgICAgY2lkcnY0OiBcIklQdjQgcmFuZ2VcIixcbiAgICAgICAgY2lkcnY2OiBcIklQdjYgcmFuZ2VcIixcbiAgICAgICAgYmFzZTY0OiBcImJhc2U2NC1lbmNvZGVkIHN0cmluZ1wiLFxuICAgICAgICBiYXNlNjR1cmw6IFwiYmFzZTY0dXJsLWVuY29kZWQgc3RyaW5nXCIsXG4gICAgICAgIGpzb25fc3RyaW5nOiBcIkpTT04gc3RyaW5nXCIsXG4gICAgICAgIGUxNjQ6IFwiRS4xNjQgbnVtYmVyXCIsXG4gICAgICAgIGp3dDogXCJKV1RcIixcbiAgICAgICAgdGVtcGxhdGVfbGl0ZXJhbDogXCJpbnB1dFwiLFxuICAgIH07XG4gICAgLy8gdHlwZSBuYW1lczogbWlzc2luZyBrZXlzID0gZG8gbm90IHRyYW5zbGF0ZSAodXNlIHJhdyB2YWx1ZSB2aWEgPz8gZmFsbGJhY2spXG4gICAgY29uc3QgVHlwZURpY3Rpb25hcnkgPSB7XG4gICAgICAgIC8vIENvbXBhdGliaWxpdHk6IFwibmFuXCIgLT4gXCJOYU5cIiBmb3IgZGlzcGxheVxuICAgICAgICBuYW46IFwiTmFOXCIsXG4gICAgICAgIC8vIEFsbCBvdGhlciB0eXBlIG5hbWVzIG9taXR0ZWQgLSB0aGV5IGZhbGwgYmFjayB0byByYXcgdmFsdWVzIHZpYSA/PyBvcGVyYXRvclxuICAgIH07XG4gICAgcmV0dXJuIChpc3N1ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3R5cGVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gVHlwZURpY3Rpb25hcnlbaXNzdWUuZXhwZWN0ZWRdID8/IGlzc3VlLmV4cGVjdGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHV0aWwucGFyc2VkVHlwZShpc3N1ZS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWQgPSBUeXBlRGljdGlvbmFyeVtyZWNlaXZlZFR5cGVdID8/IHJlY2VpdmVkVHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgaW5wdXQ6IGV4cGVjdGVkICR7ZXhwZWN0ZWR9LCByZWNlaXZlZCAke3JlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF92YWx1ZVwiOlxuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS52YWx1ZXMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgaW5wdXQ6IGV4cGVjdGVkICR7dXRpbC5zdHJpbmdpZnlQcmltaXRpdmUoaXNzdWUudmFsdWVzWzBdKX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBvcHRpb246IGV4cGVjdGVkIG9uZSBvZiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS52YWx1ZXMsIFwifFwiKX1gO1xuICAgICAgICAgICAgY2FzZSBcInRvb19iaWdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkaiA9IGlzc3VlLmluY2x1c2l2ZSA/IFwiPD1cIiA6IFwiPFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemluZyA9IGdldFNpemluZyhpc3N1ZS5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChzaXppbmcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgVG9vIGJpZzogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW4gPz8gXCJ2YWx1ZVwifSB0byBoYXZlICR7YWRqfSR7aXNzdWUubWF4aW11bS50b1N0cmluZygpfSAke3NpemluZy51bml0ID8/IFwiZWxlbWVudHNcIn1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBgVG9vIGJpZzogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW4gPz8gXCJ2YWx1ZVwifSB0byBiZSAke2Fkan0ke2lzc3VlLm1heGltdW0udG9TdHJpbmcoKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb19zbWFsbFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqID0gaXNzdWUuaW5jbHVzaXZlID8gXCI+PVwiIDogXCI+XCI7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6aW5nID0gZ2V0U2l6aW5nKGlzc3VlLm9yaWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKHNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFRvbyBzbWFsbDogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW59IHRvIGhhdmUgJHthZGp9JHtpc3N1ZS5taW5pbXVtLnRvU3RyaW5nKCl9ICR7c2l6aW5nLnVuaXR9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBUb28gc21hbGw6IGV4cGVjdGVkICR7aXNzdWUub3JpZ2lufSB0byBiZSAke2Fkan0ke2lzc3VlLm1pbmltdW0udG9TdHJpbmcoKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfaXNzdWUgPSBpc3N1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZvcm1hdCA9PT0gXCJzdGFydHNfd2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBzdHJpbmc6IG11c3Qgc3RhcnQgd2l0aCBcIiR7X2lzc3VlLnByZWZpeH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZm9ybWF0ID09PSBcImVuZHNfd2l0aFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgc3RyaW5nOiBtdXN0IGVuZCB3aXRoIFwiJHtfaXNzdWUuc3VmZml4fVwiYDtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZvcm1hdCA9PT0gXCJpbmNsdWRlc1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgc3RyaW5nOiBtdXN0IGluY2x1ZGUgXCIke19pc3N1ZS5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mb3JtYXQgPT09IFwicmVnZXhcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHN0cmluZzogbXVzdCBtYXRjaCBwYXR0ZXJuICR7X2lzc3VlLnBhdHRlcm59YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgJHtGb3JtYXREaWN0aW9uYXJ5W19pc3N1ZS5mb3JtYXRdID8/IGlzc3VlLmZvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm5vdF9tdWx0aXBsZV9vZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBudW1iZXI6IG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLmRpdmlzb3J9YDtcbiAgICAgICAgICAgIGNhc2UgXCJ1bnJlY29nbml6ZWRfa2V5c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgVW5yZWNvZ25pemVkIGtleSR7aXNzdWUua2V5cy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifTogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfa2V5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGtleSBpbiAke2lzc3VlLm9yaWdpbn1gO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfdW5pb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9lbGVtZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHZhbHVlIGluICR7aXNzdWUub3JpZ2lufWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGVFcnJvcjogZXJyb3IoKSxcbiAgICB9O1xufVxuIiwgInZhciBfYTtcbmV4cG9ydCBjb25zdCAkb3V0cHV0ID0gU3ltYm9sKFwiWm9kT3V0cHV0XCIpO1xuZXhwb3J0IGNvbnN0ICRpbnB1dCA9IFN5bWJvbChcIlpvZElucHV0XCIpO1xuZXhwb3J0IGNsYXNzICRab2RSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX2lkbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhZGQoc2NoZW1hLCAuLi5fbWV0YSkge1xuICAgICAgICBjb25zdCBtZXRhID0gX21ldGFbMF07XG4gICAgICAgIHRoaXMuX21hcC5zZXQoc2NoZW1hLCBtZXRhKTtcbiAgICAgICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIG1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkbWFwLnNldChtZXRhLmlkLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5faWRtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pZG1hcC5kZWxldGUobWV0YS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShzY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0KHNjaGVtYSkge1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5fbWFwLmdldChzY2hlbWEpIGFzIGFueTtcbiAgICAgICAgLy8gaW5oZXJpdCBtZXRhZGF0YVxuICAgICAgICBjb25zdCBwID0gc2NoZW1hLl96b2QucGFyZW50O1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgY29uc3QgcG0gPSB7IC4uLih0aGlzLmdldChwKSA/PyB7fSkgfTtcbiAgICAgICAgICAgIGRlbGV0ZSBwbS5pZDsgLy8gZG8gbm90IGluaGVyaXQgaWRcbiAgICAgICAgICAgIGNvbnN0IGYgPSB7IC4uLnBtLCAuLi50aGlzLl9tYXAuZ2V0KHNjaGVtYSkgfTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmKS5sZW5ndGggPyBmIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gICAgfVxuICAgIGhhcyhzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoc2NoZW1hKTtcbiAgICB9XG59XG4vLyByZWdpc3RyaWVzXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyAkWm9kUmVnaXN0cnkoKTtcbn1cbihfYSA9IGdsb2JhbFRoaXMpLl9fem9kX2dsb2JhbFJlZ2lzdHJ5ID8/IChfYS5fX3pvZF9nbG9iYWxSZWdpc3RyeSA9IHJlZ2lzdHJ5KCkpO1xuZXhwb3J0IGNvbnN0IGdsb2JhbFJlZ2lzdHJ5ID0gZ2xvYmFsVGhpcy5fX3pvZF9nbG9iYWxSZWdpc3RyeTtcbiIsICJpbXBvcnQgKiBhcyBjaGVja3MgZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgKiBhcyByZWdpc3RyaWVzIGZyb20gXCIuL3JlZ2lzdHJpZXMuanNcIjtcbmltcG9ydCAqIGFzIHNjaGVtYXMgZnJvbSBcIi4vc2NoZW1hcy5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdHJpbmcoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlZFN0cmluZyhDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2VtYWlsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImVtYWlsXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZ3VpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJndWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXVpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1dWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXVpZHY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInV1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IFwidjRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3V1aWR2NihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1dWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uOiBcInY2XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91dWlkdjcoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidXVpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgdmVyc2lvbjogXCJ2N1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXJsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInVybFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Vtb2ppKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImVtb2ppXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbmFub2lkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcIm5hbm9pZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2N1aWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiY3VpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2N1aWQyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImN1aWQyXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdWxpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1bGlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfeGlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInhpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2tzdWlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImtzdWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXB2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJpcHY0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXB2NihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJpcHY2XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWFjKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcIm1hY1wiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NpZHJ2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJjaWRydjRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jaWRydjYoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiY2lkcnY2XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImJhc2U2NFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Jhc2U2NHVybChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lMTY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImUxNjRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9qd3QoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiand0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFRpbWVQcmVjaXNpb24gPSB7XG4gICAgQW55OiBudWxsLFxuICAgIE1pbnV0ZTogLTEsXG4gICAgU2Vjb25kOiAwLFxuICAgIE1pbGxpc2Vjb25kOiAzLFxuICAgIE1pY3Jvc2Vjb25kOiA2LFxufTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lzb0RhdGVUaW1lKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImRhdGV0aW1lXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pc29EYXRlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImRhdGVcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXNvVGltZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ0aW1lXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXNvRHVyYXRpb24oQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZHVyYXRpb25cIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbnVtYmVyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWROdW1iZXIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcInNhZmVpbnRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Zsb2F0MzIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImZsb2F0MzJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Zsb2F0NjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImZsb2F0NjRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2ludDMyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJpbnQzMlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdWludDMyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJ1aW50MzJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Jvb2xlYW4oQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWRCb29sZWFuKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2JpZ2ludChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VkQmlnaW50KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaW50NjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBjaGVjazogXCJiaWdpbnRfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91aW50NjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBjaGVjazogXCJiaWdpbnRfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcInVpbnQ2NFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3ltYm9sKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VuZGVmaW5lZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9udWxsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudWxsXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9hbnkoQ2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJhbnlcIixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3Vua25vd24oQ2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9uZXZlcihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3ZvaWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInZvaWRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2RhdGUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWREYXRlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25hbihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibmFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sdCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTGVzc1RoYW4oe1xuICAgICAgICBjaGVjazogXCJsZXNzX3RoYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sdGUodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0xlc3NUaGFuKHtcbiAgICAgICAgY2hlY2s6IFwibGVzc190aGFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgeyBcbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHoubHRlKClgIGluc3RlYWQuICovXG5fbHRlIGFzIF9tYXgsIH07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ndCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrR3JlYXRlclRoYW4oe1xuICAgICAgICBjaGVjazogXCJncmVhdGVyX3RoYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ndGUodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0dyZWF0ZXJUaGFuKHtcbiAgICAgICAgY2hlY2s6IFwiZ3JlYXRlcl90aGFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgeyBcbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHouZ3RlKClgIGluc3RlYWQuICovXG5fZ3RlIGFzIF9taW4sIH07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9wb3NpdGl2ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gX2d0KDAsIHBhcmFtcyk7XG59XG4vLyBuZWdhdGl2ZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbmVnYXRpdmUocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9sdCgwLCBwYXJhbXMpO1xufVxuLy8gbm9ucG9zaXRpdmVcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25vbnBvc2l0aXZlKHBhcmFtcykge1xuICAgIHJldHVybiBfbHRlKDAsIHBhcmFtcyk7XG59XG4vLyBub25uZWdhdGl2ZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbm9ubmVnYXRpdmUocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9ndGUoMCwgcGFyYW1zKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX211bHRpcGxlT2YodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja011bHRpcGxlT2Yoe1xuICAgICAgICBjaGVjazogXCJtdWx0aXBsZV9vZlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB2YWx1ZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21heFNpemUobWF4aW11bSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTWF4U2l6ZSh7XG4gICAgICAgIGNoZWNrOiBcIm1heF9zaXplXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIG1heGltdW0sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9taW5TaXplKG1pbmltdW0sIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja01pblNpemUoe1xuICAgICAgICBjaGVjazogXCJtaW5fc2l6ZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBtaW5pbXVtLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc2l6ZShzaXplLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tTaXplRXF1YWxzKHtcbiAgICAgICAgY2hlY2s6IFwic2l6ZV9lcXVhbHNcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgc2l6ZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21heExlbmd0aChtYXhpbXVtLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjaCA9IG5ldyBjaGVja3MuJFpvZENoZWNrTWF4TGVuZ3RoKHtcbiAgICAgICAgY2hlY2s6IFwibWF4X2xlbmd0aFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBtYXhpbXVtLFxuICAgIH0pO1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21pbkxlbmd0aChtaW5pbXVtLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNaW5MZW5ndGgoe1xuICAgICAgICBjaGVjazogXCJtaW5fbGVuZ3RoXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIG1pbmltdW0sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sZW5ndGgobGVuZ3RoLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tMZW5ndGhFcXVhbHMoe1xuICAgICAgICBjaGVjazogXCJsZW5ndGhfZXF1YWxzXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIGxlbmd0aCxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3JlZ2V4KHBhdHRlcm4sIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1JlZ2V4KHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwicmVnZXhcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgcGF0dGVybixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xvd2VyY2FzZShwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tMb3dlckNhc2Uoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJsb3dlcmNhc2VcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VwcGVyY2FzZShwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tVcHBlckNhc2Uoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2luY2x1ZGVzKGluY2x1ZGVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tJbmNsdWRlcyh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcImluY2x1ZGVzXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIGluY2x1ZGVzLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3RhcnRzV2l0aChwcmVmaXgsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1N0YXJ0c1dpdGgoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJzdGFydHNfd2l0aFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBwcmVmaXgsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lbmRzV2l0aChzdWZmaXgsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0VuZHNXaXRoKHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZW5kc193aXRoXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHN1ZmZpeCxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3Byb3BlcnR5KHByb3BlcnR5LCBzY2hlbWEsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1Byb3BlcnR5KHtcbiAgICAgICAgY2hlY2s6IFwicHJvcGVydHlcIixcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21pbWUodHlwZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja01pbWVUeXBlKHtcbiAgICAgICAgY2hlY2s6IFwibWltZV90eXBlXCIsXG4gICAgICAgIG1pbWU6IHR5cGVzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfb3ZlcndyaXRlKHR4KSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrT3ZlcndyaXRlKHtcbiAgICAgICAgY2hlY2s6IFwib3ZlcndyaXRlXCIsXG4gICAgICAgIHR4LFxuICAgIH0pO1xufVxuLy8gbm9ybWFsaXplXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemUoZm9ybSkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gaW5wdXQubm9ybWFsaXplKGZvcm0pKTtcbn1cbi8vIHRyaW1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RyaW0oKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiBpbnB1dC50cmltKCkpO1xufVxuLy8gdG9Mb3dlckNhc2Vcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RvTG93ZXJDYXNlKCkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gaW5wdXQudG9Mb3dlckNhc2UoKSk7XG59XG4vLyB0b1VwcGVyQ2FzZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdG9VcHBlckNhc2UoKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiBpbnB1dC50b1VwcGVyQ2FzZSgpKTtcbn1cbi8vIHNsdWdpZnlcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3NsdWdpZnkoKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiB1dGlsLnNsdWdpZnkoaW5wdXQpKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2FycmF5KENsYXNzLCBlbGVtZW50LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICAvLyBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgLy8gICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VuaW9uKENsYXNzLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF94b3IoQ2xhc3MsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9kaXNjcmltaW5hdGVkVW5pb24oQ2xhc3MsIGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnRlcnNlY3Rpb24oQ2xhc3MsIGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgIH0pO1xufVxuLy8gZXhwb3J0IGZ1bmN0aW9uIF90dXBsZShcbi8vICAgQ2xhc3M6IHV0aWwuU2NoZW1hQ2xhc3M8c2NoZW1hcy4kWm9kVHVwbGU+LFxuLy8gICBpdGVtczogW10sXG4vLyAgIHBhcmFtcz86IHN0cmluZyB8ICRab2RUdXBsZVBhcmFtc1xuLy8gKTogc2NoZW1hcy4kWm9kVHVwbGU8W10sIG51bGw+O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdHVwbGUoQ2xhc3MsIGl0ZW1zLCBfcGFyYW1zT3JSZXN0LCBfcGFyYW1zKSB7XG4gICAgY29uc3QgaGFzUmVzdCA9IF9wYXJhbXNPclJlc3QgaW5zdGFuY2VvZiBzY2hlbWFzLiRab2RUeXBlO1xuICAgIGNvbnN0IHBhcmFtcyA9IGhhc1Jlc3QgPyBfcGFyYW1zIDogX3BhcmFtc09yUmVzdDtcbiAgICBjb25zdCByZXN0ID0gaGFzUmVzdCA/IF9wYXJhbXNPclJlc3QgOiBudWxsO1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICByZXN0LFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcmVjb3JkKENsYXNzLCBrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9tYXAoQ2xhc3MsIGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3NldChDbGFzcywgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZW51bShDbGFzcywgdmFsdWVzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gT2JqZWN0LmZyb21FbnRyaWVzKHZhbHVlcy5tYXAoKHYpID0+IFt2LCB2XSkpIDogdmFsdWVzO1xuICAgIC8vIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAvLyAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gICAgIGVudHJpZXNbdmFsdWVdID0gdmFsdWU7XG4gICAgLy8gICB9XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIE9iamVjdC5hc3NpZ24oZW50cmllcywgdmFsdWVzKTtcbiAgICAvLyB9XG4gICAgLy8gY29uc3QgZW50cmllczogdXRpbC5FbnVtTGlrZSA9IHt9O1xuICAgIC8vIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgIC8vICAgZW50cmllc1t2YWxdID0gdmFsO1xuICAgIC8vIH1cbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuLyoqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIG1lcmdlZCBpbnRvIGB6LmVudW0oKWAuIFVzZSBgei5lbnVtKClgIGluc3RlYWQuXG4gKlxuICogYGBgdHNcbiAqIGVudW0gQ29sb3JzIHsgcmVkLCBncmVlbiwgYmx1ZSB9XG4gKiB6LmVudW0oQ29sb3JzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gX25hdGl2ZUVudW0oQ2xhc3MsIGVudHJpZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xpdGVyYWwoQ2xhc3MsIHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gICAgICAgIHZhbHVlczogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9maWxlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90cmFuc2Zvcm0oQ2xhc3MsIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHRyYW5zZm9ybTogZm4sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9vcHRpb25hbChDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbnVsbGFibGUoQ2xhc3MsIGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2RlZmF1bHQoQ2xhc3MsIGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiB1dGlsLnNoYWxsb3dDbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbm9ub3B0aW9uYWwoQ2xhc3MsIGlubmVyVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3VjY2VzcyhDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaChDbGFzcywgaW5uZXJUeXBlLCBjYXRjaFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiY2F0Y2hcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgICAgICBjYXRjaFZhbHVlOiAodHlwZW9mIGNhdGNoVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhdGNoVmFsdWUgOiAoKSA9PiBjYXRjaFZhbHVlKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3BpcGUoQ2xhc3MsIGluXywgb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicGlwZVwiLFxuICAgICAgICBpbjogaW5fLFxuICAgICAgICBvdXQsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkb25seShDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdGVtcGxhdGVMaXRlcmFsKENsYXNzLCBwYXJ0cywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidGVtcGxhdGVfbGl0ZXJhbFwiLFxuICAgICAgICBwYXJ0cyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xhenkoQ2xhc3MsIGdldHRlcikge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImxhenlcIixcbiAgICAgICAgZ2V0dGVyLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcHJvbWlzZShDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicHJvbWlzZVwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jdXN0b20oQ2xhc3MsIGZuLCBfcGFyYW1zKSB7XG4gICAgY29uc3Qgbm9ybSA9IHV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpO1xuICAgIG5vcm0uYWJvcnQgPz8gKG5vcm0uYWJvcnQgPSB0cnVlKTsgLy8gZGVmYXVsdCB0byBhYm9ydDpmYWxzZVxuICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgICAgICBmbjogZm4sXG4gICAgICAgIC4uLm5vcm0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbi8vIHNhbWUgYXMgX2N1c3RvbSBidXQgZGVmYXVsdHMgdG8gYWJvcnQ6ZmFsc2Vcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3JlZmluZShDbGFzcywgZm4sIF9wYXJhbXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgZm46IGZuLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSxcbiAgICB9KTtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3VwZXJSZWZpbmUoZm4pIHtcbiAgICBjb25zdCBjaCA9IF9jaGVjaygocGF5bG9hZCkgPT4ge1xuICAgICAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKGlzc3VlLCBwYXlsb2FkLnZhbHVlLCBjaC5fem9kLmRlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIFpvZCAzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWU7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mYXRhbClcbiAgICAgICAgICAgICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmNvZGUgPz8gKF9pc3N1ZS5jb2RlID0gXCJjdXN0b21cIik7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuaW5zdCA/PyAoX2lzc3VlLmluc3QgPSBjaCk7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID8/IChfaXNzdWUuY29udGludWUgPSAhY2guX3pvZC5kZWYuYWJvcnQpOyAvLyBhYm9ydCBpcyBhbHdheXMgdW5kZWZpbmVkLCBzbyB0aGlzIGlzIGFsd2F5cyB0cnVlLi4uXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm4ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY2hlY2soZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2soe1xuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbiAgICBjaC5fem9kLmNoZWNrID0gZm47XG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2soeyBjaGVjazogXCJkZXNjcmliZVwiIH0pO1xuICAgIGNoLl96b2Qub25hdHRhY2ggPSBbXG4gICAgICAgIChpbnN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlZ2lzdHJpZXMuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpID8/IHt9O1xuICAgICAgICAgICAgcmVnaXN0cmllcy5nbG9iYWxSZWdpc3RyeS5hZGQoaW5zdCwgeyAuLi5leGlzdGluZywgZGVzY3JpcHRpb24gfSk7XG4gICAgICAgIH0sXG4gICAgXTtcbiAgICBjaC5fem9kLmNoZWNrID0gKCkgPT4geyB9OyAvLyBuby1vcCBjaGVja1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gbWV0YShtZXRhZGF0YSkge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2soeyBjaGVjazogXCJtZXRhXCIgfSk7XG4gICAgY2guX3pvZC5vbmF0dGFjaCA9IFtcbiAgICAgICAgKGluc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmVnaXN0cmllcy5nbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCkgPz8ge307XG4gICAgICAgICAgICByZWdpc3RyaWVzLmdsb2JhbFJlZ2lzdHJ5LmFkZChpbnN0LCB7IC4uLmV4aXN0aW5nLCAuLi5tZXRhZGF0YSB9KTtcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGNoLl96b2QuY2hlY2sgPSAoKSA9PiB7IH07IC8vIG5vLW9wIGNoZWNrXG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3RyaW5nYm9vbChDbGFzc2VzLCBfcGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyk7XG4gICAgbGV0IHRydXRoeUFycmF5ID0gcGFyYW1zLnRydXRoeSA/PyBbXCJ0cnVlXCIsIFwiMVwiLCBcInllc1wiLCBcIm9uXCIsIFwieVwiLCBcImVuYWJsZWRcIl07XG4gICAgbGV0IGZhbHN5QXJyYXkgPSBwYXJhbXMuZmFsc3kgPz8gW1wiZmFsc2VcIiwgXCIwXCIsIFwibm9cIiwgXCJvZmZcIiwgXCJuXCIsIFwiZGlzYWJsZWRcIl07XG4gICAgaWYgKHBhcmFtcy5jYXNlICE9PSBcInNlbnNpdGl2ZVwiKSB7XG4gICAgICAgIHRydXRoeUFycmF5ID0gdHJ1dGh5QXJyYXkubWFwKCh2KSA9PiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyB2LnRvTG93ZXJDYXNlKCkgOiB2KSk7XG4gICAgICAgIGZhbHN5QXJyYXkgPSBmYWxzeUFycmF5Lm1hcCgodikgPT4gKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdi50b0xvd2VyQ2FzZSgpIDogdikpO1xuICAgIH1cbiAgICBjb25zdCB0cnV0aHlTZXQgPSBuZXcgU2V0KHRydXRoeUFycmF5KTtcbiAgICBjb25zdCBmYWxzeVNldCA9IG5ldyBTZXQoZmFsc3lBcnJheSk7XG4gICAgY29uc3QgX0NvZGVjID0gQ2xhc3Nlcy5Db2RlYyA/PyBzY2hlbWFzLiRab2RDb2RlYztcbiAgICBjb25zdCBfQm9vbGVhbiA9IENsYXNzZXMuQm9vbGVhbiA/PyBzY2hlbWFzLiRab2RCb29sZWFuO1xuICAgIGNvbnN0IF9TdHJpbmcgPSBDbGFzc2VzLlN0cmluZyA/PyBzY2hlbWFzLiRab2RTdHJpbmc7XG4gICAgY29uc3Qgc3RyaW5nU2NoZW1hID0gbmV3IF9TdHJpbmcoeyB0eXBlOiBcInN0cmluZ1wiLCBlcnJvcjogcGFyYW1zLmVycm9yIH0pO1xuICAgIGNvbnN0IGJvb2xlYW5TY2hlbWEgPSBuZXcgX0Jvb2xlYW4oeyB0eXBlOiBcImJvb2xlYW5cIiwgZXJyb3I6IHBhcmFtcy5lcnJvciB9KTtcbiAgICBjb25zdCBjb2RlYyA9IG5ldyBfQ29kZWMoe1xuICAgICAgICB0eXBlOiBcInBpcGVcIixcbiAgICAgICAgaW46IHN0cmluZ1NjaGVtYSxcbiAgICAgICAgb3V0OiBib29sZWFuU2NoZW1hLFxuICAgICAgICB0cmFuc2Zvcm06ICgoaW5wdXQsIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW5wdXQ7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmNhc2UgIT09IFwic2Vuc2l0aXZlXCIpXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0cnV0aHlTZXQuaGFzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmYWxzeVNldC5oYXMoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInN0cmluZ2Jvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbLi4udHJ1dGh5U2V0LCAuLi5mYWxzeVNldF0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0OiBjb2RlYyxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm06ICgoaW5wdXQsIF9wYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1dGh5QXJyYXlbMF0gfHwgXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc3lBcnJheVswXSB8fCBcImZhbHNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yLFxuICAgIH0pO1xuICAgIHJldHVybiBjb2RlYztcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N0cmluZ0Zvcm1hdChDbGFzcywgZm9ybWF0LCBmbk9yUmVnZXgsIF9wYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpO1xuICAgIGNvbnN0IGRlZiA9IHtcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyksXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBmbjogdHlwZW9mIGZuT3JSZWdleCA9PT0gXCJmdW5jdGlvblwiID8gZm5PclJlZ2V4IDogKHZhbCkgPT4gZm5PclJlZ2V4LnRlc3QodmFsKSxcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgIH07XG4gICAgaWYgKGZuT3JSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBkZWYucGF0dGVybiA9IGZuT3JSZWdleDtcbiAgICB9XG4gICAgY29uc3QgaW5zdCA9IG5ldyBDbGFzcyhkZWYpO1xuICAgIHJldHVybiBpbnN0O1xufVxuIiwgImltcG9ydCB7IGdsb2JhbFJlZ2lzdHJ5IH0gZnJvbSBcIi4vcmVnaXN0cmllcy5qc1wiO1xuLy8gZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnRleHQ8VCBleHRlbmRzIHNjaGVtYXMuJFpvZFR5cGU+KGlucHV0czogSlNPTlNjaGVtYUdlbmVyYXRvclBhcmFtczxUPik6IFRvSlNPTlNjaGVtYUNvbnRleHQ8VD4ge1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHByb2Nlc3NvcjogaW5wdXRzLnByb2Nlc3Nvcixcbi8vICAgICBtZXRhZGF0YVJlZ2lzdHJ5OiBpbnB1dHMubWV0YWRhdGEgPz8gZ2xvYmFsUmVnaXN0cnksXG4vLyAgICAgdGFyZ2V0OiBpbnB1dHMudGFyZ2V0ID8/IFwiZHJhZnQtMjAyMC0xMlwiLFxuLy8gICAgIHVucmVwcmVzZW50YWJsZTogaW5wdXRzLnVucmVwcmVzZW50YWJsZSA/PyBcInRocm93XCIsXG4vLyAgIH07XG4vLyB9XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnRleHQocGFyYW1zKSB7XG4gICAgLy8gTm9ybWFsaXplIHRhcmdldDogY29udmVydCBvbGQgbm9uLWh5cGhlbmF0ZWQgdmVyc2lvbnMgdG8gaHlwaGVuYXRlZCB2ZXJzaW9uc1xuICAgIGxldCB0YXJnZXQgPSBwYXJhbXM/LnRhcmdldCA/PyBcImRyYWZ0LTIwMjAtMTJcIjtcbiAgICBpZiAodGFyZ2V0ID09PSBcImRyYWZ0LTRcIilcbiAgICAgICAgdGFyZ2V0ID0gXCJkcmFmdC0wNFwiO1xuICAgIGlmICh0YXJnZXQgPT09IFwiZHJhZnQtN1wiKVxuICAgICAgICB0YXJnZXQgPSBcImRyYWZ0LTA3XCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2Vzc29yczogcGFyYW1zLnByb2Nlc3NvcnMgPz8ge30sXG4gICAgICAgIG1ldGFkYXRhUmVnaXN0cnk6IHBhcmFtcz8ubWV0YWRhdGEgPz8gZ2xvYmFsUmVnaXN0cnksXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdW5yZXByZXNlbnRhYmxlOiBwYXJhbXM/LnVucmVwcmVzZW50YWJsZSA/PyBcInRocm93XCIsXG4gICAgICAgIG92ZXJyaWRlOiBwYXJhbXM/Lm92ZXJyaWRlID8/ICgoKSA9PiB7IH0pLFxuICAgICAgICBpbzogcGFyYW1zPy5pbyA/PyBcIm91dHB1dFwiLFxuICAgICAgICBjb3VudGVyOiAwLFxuICAgICAgICBzZWVuOiBuZXcgTWFwKCksXG4gICAgICAgIGN5Y2xlczogcGFyYW1zPy5jeWNsZXMgPz8gXCJyZWZcIixcbiAgICAgICAgcmV1c2VkOiBwYXJhbXM/LnJldXNlZCA/PyBcImlubGluZVwiLFxuICAgICAgICBleHRlcm5hbDogcGFyYW1zPy5leHRlcm5hbCA/PyB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzKHNjaGVtYSwgY3R4LCBfcGFyYW1zID0geyBwYXRoOiBbXSwgc2NoZW1hUGF0aDogW10gfSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgLy8gY2hlY2sgZm9yIHNjaGVtYSBpbiBzZWVuc1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBpZiAoc2Vlbikge1xuICAgICAgICBzZWVuLmNvdW50Kys7XG4gICAgICAgIC8vIGNoZWNrIGlmIGN5Y2xlXG4gICAgICAgIGNvbnN0IGlzQ3ljbGUgPSBfcGFyYW1zLnNjaGVtYVBhdGguaW5jbHVkZXMoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlzQ3ljbGUpIHtcbiAgICAgICAgICAgIHNlZW4uY3ljbGUgPSBfcGFyYW1zLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZW4uc2NoZW1hO1xuICAgIH1cbiAgICAvLyBpbml0aWFsaXplXG4gICAgY29uc3QgcmVzdWx0ID0geyBzY2hlbWE6IHt9LCBjb3VudDogMSwgY3ljbGU6IHVuZGVmaW5lZCwgcGF0aDogX3BhcmFtcy5wYXRoIH07XG4gICAgY3R4LnNlZW4uc2V0KHNjaGVtYSwgcmVzdWx0KTtcbiAgICAvLyBjdXN0b20gbWV0aG9kIG92ZXJyaWRlcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgY29uc3Qgb3ZlcnJpZGVTY2hlbWEgPSBzY2hlbWEuX3pvZC50b0pTT05TY2hlbWE/LigpO1xuICAgIGlmIChvdmVycmlkZVNjaGVtYSkge1xuICAgICAgICByZXN1bHQuc2NoZW1hID0gb3ZlcnJpZGVTY2hlbWE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi5fcGFyYW1zLFxuICAgICAgICAgICAgc2NoZW1hUGF0aDogWy4uLl9wYXJhbXMuc2NoZW1hUGF0aCwgc2NoZW1hXSxcbiAgICAgICAgICAgIHBhdGg6IF9wYXJhbXMucGF0aCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYS5fem9kLnByb2Nlc3NKU09OU2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWEuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYShjdHgsIHJlc3VsdC5zY2hlbWEsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBfanNvbiA9IHJlc3VsdC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzb3IgPSBjdHgucHJvY2Vzc29yc1tkZWYudHlwZV07XG4gICAgICAgICAgICBpZiAoIXByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW3RvSlNPTlNjaGVtYV06IE5vbi1yZXByZXNlbnRhYmxlIHR5cGUgZW5jb3VudGVyZWQ6ICR7ZGVmLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzb3Ioc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHNjaGVtYS5fem9kLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgLy8gQWxzbyBzZXQgcmVmIGlmIHByb2Nlc3NvciBkaWRuJ3QgKGZvciBpbmhlcml0YW5jZSlcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnJlZilcbiAgICAgICAgICAgICAgICByZXN1bHQucmVmID0gcGFyZW50O1xuICAgICAgICAgICAgcHJvY2VzcyhwYXJlbnQsIGN0eCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGN0eC5zZWVuLmdldChwYXJlbnQpLmlzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtZXRhZGF0YVxuICAgIGNvbnN0IG1ldGEgPSBjdHgubWV0YWRhdGFSZWdpc3RyeS5nZXQoc2NoZW1hKTtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuc2NoZW1hLCBtZXRhKTtcbiAgICBpZiAoY3R4LmlvID09PSBcImlucHV0XCIgJiYgaXNUcmFuc2Zvcm1pbmcoc2NoZW1hKSkge1xuICAgICAgICAvLyBleGFtcGxlcy9kZWZhdWx0cyBvbmx5IGFwcGx5IHRvIG91dHB1dCB0eXBlIG9mIHBpcGVcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zY2hlbWEuZXhhbXBsZXM7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuc2NoZW1hLmRlZmF1bHQ7XG4gICAgfVxuICAgIC8vIHNldCBwcmVmYXVsdCBhcyBkZWZhdWx0XG4gICAgaWYgKGN0eC5pbyA9PT0gXCJpbnB1dFwiICYmIHJlc3VsdC5zY2hlbWEuX3ByZWZhdWx0KVxuICAgICAgICAoX2EgPSByZXN1bHQuc2NoZW1hKS5kZWZhdWx0ID8/IChfYS5kZWZhdWx0ID0gcmVzdWx0LnNjaGVtYS5fcHJlZmF1bHQpO1xuICAgIGRlbGV0ZSByZXN1bHQuc2NoZW1hLl9wcmVmYXVsdDtcbiAgICAvLyBwdWxsaW5nIGZyZXNoIGZyb20gY3R4LnNlZW4gaW4gY2FzZSBpdCB3YXMgb3ZlcndyaXR0ZW5cbiAgICBjb25zdCBfcmVzdWx0ID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgcmV0dXJuIF9yZXN1bHQuc2NoZW1hO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3REZWZzKGN0eCwgc2NoZW1hXG4vLyBwYXJhbXM6IEVtaXRQYXJhbXNcbikge1xuICAgIC8vIGl0ZXJhdGUgb3ZlciBzZWVuIG1hcDtcbiAgICBjb25zdCByb290ID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgaWYgKCFyb290KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnByb2Nlc3NlZCBzY2hlbWEuIFRoaXMgaXMgYSBidWcgaW4gWm9kLlwiKTtcbiAgICAvLyBUcmFjayBpZHMgdG8gZGV0ZWN0IGR1cGxpY2F0ZXMgYWNyb3NzIGRpZmZlcmVudCBzY2hlbWFzXG4gICAgY29uc3QgaWRUb1NjaGVtYSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGN0eC5zZWVuLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBpZCA9IGN0eC5tZXRhZGF0YVJlZ2lzdHJ5LmdldChlbnRyeVswXSk/LmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gaWRUb1NjaGVtYS5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBlbnRyeVswXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIHNjaGVtYSBpZCBcIiR7aWR9XCIgZGV0ZWN0ZWQgZHVyaW5nIEpTT04gU2NoZW1hIGNvbnZlcnNpb24uIFR3byBkaWZmZXJlbnQgc2NoZW1hcyBjYW5ub3Qgc2hhcmUgdGhlIHNhbWUgaWQgd2hlbiBjb252ZXJ0ZWQgdG9nZXRoZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZFRvU2NoZW1hLnNldChpZCwgZW50cnlbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybnMgYSByZWYgdG8gdGhlIHNjaGVtYVxuICAgIC8vIGRlZklkIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHJlZiBwb2ludHMgdG8gYW4gZXh0ZXJuYWwgc2NoZW1hIChvciAjKVxuICAgIGNvbnN0IG1ha2VVUkkgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gY29tcGFyaW5nIHRoZSBzZWVuIG9iamVjdHMgYmVjYXVzZSBzb21ldGltZXNcbiAgICAgICAgLy8gbXVsdGlwbGUgc2NoZW1hcyBtYXAgdG8gdGhlIHNhbWUgc2VlbiBvYmplY3QuXG4gICAgICAgIC8vIGUuZy4gbGF6eVxuICAgICAgICAvLyBleHRlcm5hbCBpcyBjb25maWd1cmVkXG4gICAgICAgIGNvbnN0IGRlZnNTZWdtZW50ID0gY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcIiRkZWZzXCIgOiBcImRlZmluaXRpb25zXCI7XG4gICAgICAgIGlmIChjdHguZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsSWQgPSBjdHguZXh0ZXJuYWwucmVnaXN0cnkuZ2V0KGVudHJ5WzBdKT8uaWQ7IC8vID8/IFwiX19zaGFyZWRcIjsvLyBgX19zY2hlbWEke2N0eC5jb3VudGVyKyt9YDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNjaGVtYSBpcyBpbiB0aGUgZXh0ZXJuYWwgcmVnaXN0cnlcbiAgICAgICAgICAgIGNvbnN0IHVyaUdlbmVyYXRvciA9IGN0eC5leHRlcm5hbC51cmkgPz8gKChpZCkgPT4gaWQpO1xuICAgICAgICAgICAgaWYgKGV4dGVybmFsSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWY6IHVyaUdlbmVyYXRvcihleHRlcm5hbElkKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBhZGQgdG8gX19zaGFyZWRcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZW50cnlbMV0uZGVmSWQgPz8gZW50cnlbMV0uc2NoZW1hLmlkID8/IGBzY2hlbWEke2N0eC5jb3VudGVyKyt9YDtcbiAgICAgICAgICAgIGVudHJ5WzFdLmRlZklkID0gaWQ7IC8vIHNldCBkZWZJZCBzbyBpdCB3aWxsIGJlIHJldXNlZCBpZiBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybiB7IGRlZklkOiBpZCwgcmVmOiBgJHt1cmlHZW5lcmF0b3IoXCJfX3NoYXJlZFwiKX0jLyR7ZGVmc1NlZ21lbnR9LyR7aWR9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVsxXSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVmOiBcIiNcIiB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbGYtY29udGFpbmVkIHNjaGVtYVxuICAgICAgICBjb25zdCB1cmlQcmVmaXggPSBgI2A7XG4gICAgICAgIGNvbnN0IGRlZlVyaVByZWZpeCA9IGAke3VyaVByZWZpeH0vJHtkZWZzU2VnbWVudH0vYDtcbiAgICAgICAgY29uc3QgZGVmSWQgPSBlbnRyeVsxXS5zY2hlbWEuaWQgPz8gYF9fc2NoZW1hJHtjdHguY291bnRlcisrfWA7XG4gICAgICAgIHJldHVybiB7IGRlZklkLCByZWY6IGRlZlVyaVByZWZpeCArIGRlZklkIH07XG4gICAgfTtcbiAgICAvLyBzdG9yZWQgY2FjaGVkIHZlcnNpb24gaW4gYGRlZmAgcHJvcGVydHlcbiAgICAvLyByZW1vdmUgYWxsIHByb3BlcnRpZXMsIHNldCAkcmVmXG4gICAgY29uc3QgZXh0cmFjdFRvRGVmID0gKGVudHJ5KSA9PiB7XG4gICAgICAgIC8vIGlmIHRoZSBzY2hlbWEgaXMgYWxyZWFkeSBhIHJlZmVyZW5jZSwgZG8gbm90IGV4dHJhY3QgaXRcbiAgICAgICAgaWYgKGVudHJ5WzFdLnNjaGVtYS4kcmVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlbiA9IGVudHJ5WzFdO1xuICAgICAgICBjb25zdCB7IHJlZiwgZGVmSWQgfSA9IG1ha2VVUkkoZW50cnkpO1xuICAgICAgICBzZWVuLmRlZiA9IHsgLi4uc2Vlbi5zY2hlbWEgfTtcbiAgICAgICAgLy8gZGVmSWQgd29uJ3QgYmUgc2V0IGlmIHRoZSBzY2hlbWEgaXMgYSByZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgc2NoZW1hXG4gICAgICAgIC8vIG9yIGlmIHRoZSBzY2hlbWEgaXMgdGhlIHJvb3Qgc2NoZW1hXG4gICAgICAgIGlmIChkZWZJZClcbiAgICAgICAgICAgIHNlZW4uZGVmSWQgPSBkZWZJZDtcbiAgICAgICAgLy8gd2lwZSBhd2F5IGFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCAkcmVmXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHNlZW4uc2NoZW1hO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuJHJlZiA9IHJlZjtcbiAgICB9O1xuICAgIC8vIHRocm93IG9uIGN5Y2xlc1xuICAgIC8vIGJyZWFrIGN5Y2xlc1xuICAgIGlmIChjdHguY3ljbGVzID09PSBcInRocm93XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdHguc2Vlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIGlmIChzZWVuLmN5Y2xlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGUgZGV0ZWN0ZWQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgYCMvJHtzZWVuLmN5Y2xlPy5qb2luKFwiL1wiKX0vPHJvb3Q+YCArXG4gICAgICAgICAgICAgICAgICAgICdcXG5cXG5TZXQgdGhlIGBjeWNsZXNgIHBhcmFtZXRlciB0byBgXCJyZWZcImAgdG8gcmVzb2x2ZSBjeWNsaWNhbCBzY2hlbWFzIHdpdGggZGVmcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBleHRyYWN0IHNjaGVtYXMgaW50byAkZGVmc1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgY3R4LnNlZW4uZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBlbnRyeVsxXTtcbiAgICAgICAgLy8gY29udmVydCByb290IHNjaGVtYSB0byAjICRyZWZcbiAgICAgICAgaWYgKHNjaGVtYSA9PT0gZW50cnlbMF0pIHtcbiAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7IC8vIHRoaXMgaGFzIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZSByb290IHNjaGVtYVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0cmFjdCBzY2hlbWFzIHRoYXQgYXJlIGluIHRoZSBleHRlcm5hbCByZWdpc3RyeVxuICAgICAgICBpZiAoY3R4LmV4dGVybmFsKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSBjdHguZXh0ZXJuYWwucmVnaXN0cnkuZ2V0KGVudHJ5WzBdKT8uaWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICE9PSBlbnRyeVswXSAmJiBleHQpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0VG9EZWYoZW50cnkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4dHJhY3Qgc2NoZW1hcyB3aXRoIGBpZGAgbWV0YVxuICAgICAgICBjb25zdCBpZCA9IGN0eC5tZXRhZGF0YVJlZ2lzdHJ5LmdldChlbnRyeVswXSk/LmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBicmVhayBjeWNsZXNcbiAgICAgICAgaWYgKHNlZW4uY3ljbGUpIHtcbiAgICAgICAgICAgIC8vIGFueVxuICAgICAgICAgICAgZXh0cmFjdFRvRGVmKGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4dHJhY3QgcmV1c2VkIHNjaGVtYXNcbiAgICAgICAgaWYgKHNlZW4uY291bnQgPiAxKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnJldXNlZCA9PT0gXCJyZWZcIikge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7XG4gICAgICAgICAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZmluYWxpemUoY3R4LCBzY2hlbWEpIHtcbiAgICBjb25zdCByb290ID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgaWYgKCFyb290KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnByb2Nlc3NlZCBzY2hlbWEuIFRoaXMgaXMgYSBidWcgaW4gWm9kLlwiKTtcbiAgICAvLyBmbGF0dGVuIHJlZnMgLSBpbmhlcml0IHByb3BlcnRpZXMgZnJvbSBwYXJlbnQgc2NoZW1hc1xuICAgIGNvbnN0IGZsYXR0ZW5SZWYgPSAoem9kU2NoZW1hKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoem9kU2NoZW1hKTtcbiAgICAgICAgLy8gYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKHNlZW4ucmVmID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzZWVuLmRlZiA/PyBzZWVuLnNjaGVtYTtcbiAgICAgICAgY29uc3QgX2NhY2hlZCA9IHsgLi4uc2NoZW1hIH07XG4gICAgICAgIGNvbnN0IHJlZiA9IHNlZW4ucmVmO1xuICAgICAgICBzZWVuLnJlZiA9IG51bGw7IC8vIHByZXZlbnQgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5SZWYocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZlNlZW4gPSBjdHguc2Vlbi5nZXQocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZlNjaGVtYSA9IHJlZlNlZW4uc2NoZW1hO1xuICAgICAgICAgICAgLy8gbWVyZ2UgcmVmZXJlbmNlZCBzY2hlbWEgaW50byBjdXJyZW50XG4gICAgICAgICAgICBpZiAocmVmU2NoZW1hLiRyZWYgJiYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDdcIiB8fCBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSkge1xuICAgICAgICAgICAgICAgIC8vIG9sZGVyIGRyYWZ0cyBjYW4ndCBjb21iaW5lICRyZWYgd2l0aCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgc2NoZW1hLmFsbE9mID0gc2NoZW1hLmFsbE9mID8/IFtdO1xuICAgICAgICAgICAgICAgIHNjaGVtYS5hbGxPZi5wdXNoKHJlZlNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNjaGVtYSwgcmVmU2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgY2hpbGQncyBvd24gcHJvcGVydGllcyAoY2hpbGQgd2lucylcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBfY2FjaGVkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUGFyZW50UmVmID0gem9kU2NoZW1hLl96b2QucGFyZW50ID09PSByZWY7XG4gICAgICAgICAgICAvLyBGb3IgcGFyZW50IGNoYWluLCBjaGlsZCBpcyBhIHJlZmluZW1lbnQgLSByZW1vdmUgcGFyZW50LW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50UmVmKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiIHx8IGtleSA9PT0gXCJhbGxPZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBfY2FjaGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiByZWYgd2FzIGV4dHJhY3RlZCB0byAkZGVmcywgcmVtb3ZlIHByb3BlcnRpZXMgdGhhdCBtYXRjaCB0aGUgZGVmaW5pdGlvblxuICAgICAgICAgICAgaWYgKHJlZlNjaGVtYS4kcmVmICYmIHJlZlNlZW4uZGVmKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiIHx8IGtleSA9PT0gXCJhbGxPZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcmVmU2Vlbi5kZWYgJiYgSlNPTi5zdHJpbmdpZnkoc2NoZW1hW2tleV0pID09PSBKU09OLnN0cmluZ2lmeShyZWZTZWVuLmRlZltrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHBhcmVudCB3YXMgZXh0cmFjdGVkIChoYXMgJHJlZiksIHByb3BhZ2F0ZSAkcmVmIHRvIHRoaXMgc2NoZW1hXG4gICAgICAgIC8vIFRoaXMgaGFuZGxlcyBjYXNlcyBsaWtlOiByZWFkb25seSgpLm1ldGEoe2lkfSkuZGVzY3JpYmUoKVxuICAgICAgICAvLyB3aGVyZSBwcm9jZXNzb3Igc2V0cyByZWYgdG8gaW5uZXJUeXBlIGJ1dCBwYXJlbnQgc2hvdWxkIGJlIHJlZmVyZW5jZWRcbiAgICAgICAgY29uc3QgcGFyZW50ID0gem9kU2NoZW1hLl96b2QucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gcmVmKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcGFyZW50IGlzIHByb2Nlc3NlZCBmaXJzdCBzbyBpdHMgZGVmIGhhcyBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgZmxhdHRlblJlZihwYXJlbnQpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50U2VlbiA9IGN0eC5zZWVuLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFNlZW4/LnNjaGVtYS4kcmVmKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRyZWYgPSBwYXJlbnRTZWVuLnNjaGVtYS4kcmVmO1xuICAgICAgICAgICAgICAgIC8vIERlLWR1cGxpY2F0ZSB3aXRoIHBhcmVudCdzIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50U2Vlbi5kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIiB8fCBrZXkgPT09IFwiYWxsT2ZcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcGFyZW50U2Vlbi5kZWYgJiYgSlNPTi5zdHJpbmdpZnkoc2NoZW1hW2tleV0pID09PSBKU09OLnN0cmluZ2lmeShwYXJlbnRTZWVuLmRlZltrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleGVjdXRlIG92ZXJyaWRlc1xuICAgICAgICBjdHgub3ZlcnJpZGUoe1xuICAgICAgICAgICAgem9kU2NoZW1hOiB6b2RTY2hlbWEsXG4gICAgICAgICAgICBqc29uU2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICBwYXRoOiBzZWVuLnBhdGggPz8gW10sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBbLi4uY3R4LnNlZW4uZW50cmllcygpXS5yZXZlcnNlKCkpIHtcbiAgICAgICAgZmxhdHRlblJlZihlbnRyeVswXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIikge1xuICAgICAgICByZXN1bHQuJHNjaGVtYSA9IFwiaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAyMC0xMi9zY2hlbWFcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wN1wiKSB7XG4gICAgICAgIHJlc3VsdC4kc2NoZW1hID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiKSB7XG4gICAgICAgIHJlc3VsdC4kc2NoZW1hID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIC8vIE9wZW5BUEkgMy4wIHNjaGVtYSBvYmplY3RzIHNob3VsZCBub3QgaW5jbHVkZSBhICRzY2hlbWEgcHJvcGVydHlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEFyYml0cmFyeSBzdHJpbmcgdmFsdWVzIGFyZSBhbGxvd2VkIGJ1dCB3b24ndCBoYXZlIGEgJHNjaGVtYSBwcm9wZXJ0eSBzZXRcbiAgICB9XG4gICAgaWYgKGN0eC5leHRlcm5hbD8udXJpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gY3R4LmV4dGVybmFsLnJlZ2lzdHJ5LmdldChzY2hlbWEpPy5pZDtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGFuIGBpZGAgcHJvcGVydHlcIik7XG4gICAgICAgIHJlc3VsdC4kaWQgPSBjdHguZXh0ZXJuYWwudXJpKGlkKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHJvb3QuZGVmID8/IHJvb3Quc2NoZW1hKTtcbiAgICAvLyBidWlsZCBkZWZzIG9iamVjdFxuICAgIGNvbnN0IGRlZnMgPSBjdHguZXh0ZXJuYWw/LmRlZnMgPz8ge307XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdHguc2Vlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAoc2Vlbi5kZWYgJiYgc2Vlbi5kZWZJZCkge1xuICAgICAgICAgICAgZGVmc1tzZWVuLmRlZklkXSA9IHNlZW4uZGVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBkZWZpbml0aW9ucyBpbiByZXN1bHRcbiAgICBpZiAoY3R4LmV4dGVybmFsKSB7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LiRkZWZzID0gZGVmcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kZWZpbml0aW9ucyA9IGRlZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcyBcImZpbmFsaXplc1wiIHRoaXMgc2NoZW1hIGFuZCBlbnN1cmVzIGFsbCBjeWNsZXMgYXJlIHJlbW92ZWRcbiAgICAgICAgLy8gZWFjaCBjYWxsIHRvIGZpbmFsaXplKCkgaXMgZnVuY3Rpb25hbGx5IGluZGVwZW5kZW50XG4gICAgICAgIC8vIHRob3VnaCB0aGUgc2VlbiBtYXAgaXMgc2hhcmVkXG4gICAgICAgIGNvbnN0IGZpbmFsaXplZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaW5hbGl6ZWQsIFwifnN0YW5kYXJkXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgLi4uc2NoZW1hW1wifnN0YW5kYXJkXCJdLFxuICAgICAgICAgICAgICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChzY2hlbWEsIFwiaW5wdXRcIiwgY3R4LnByb2Nlc3NvcnMpLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChzY2hlbWEsIFwib3V0cHV0XCIsIGN0eC5wcm9jZXNzb3JzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplZDtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY29udmVydGluZyBzY2hlbWEgdG8gSlNPTi5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNUcmFuc2Zvcm1pbmcoX3NjaGVtYSwgX2N0eCkge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPz8geyBzZWVuOiBuZXcgU2V0KCkgfTtcbiAgICBpZiAoY3R4LnNlZW4uaGFzKF9zY2hlbWEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY3R4LnNlZW4uYWRkKF9zY2hlbWEpO1xuICAgIGNvbnN0IGRlZiA9IF9zY2hlbWEuX3pvZC5kZWY7XG4gICAgaWYgKGRlZi50eXBlID09PSBcInRyYW5zZm9ybVwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5lbGVtZW50LCBjdHgpO1xuICAgIGlmIChkZWYudHlwZSA9PT0gXCJzZXRcIilcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi52YWx1ZVR5cGUsIGN0eCk7XG4gICAgaWYgKGRlZi50eXBlID09PSBcImxhenlcIilcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5nZXR0ZXIoKSwgY3R4KTtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwicHJvbWlzZVwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcIm9wdGlvbmFsXCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwibm9ub3B0aW9uYWxcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJudWxsYWJsZVwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcInJlYWRvbmx5XCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwiZGVmYXVsdFwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcInByZWZhdWx0XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5pbm5lclR5cGUsIGN0eCk7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmxlZnQsIGN0eCkgfHwgaXNUcmFuc2Zvcm1pbmcoZGVmLnJpZ2h0LCBjdHgpO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwicmVjb3JkXCIgfHwgZGVmLnR5cGUgPT09IFwibWFwXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5rZXlUeXBlLCBjdHgpIHx8IGlzVHJhbnNmb3JtaW5nKGRlZi52YWx1ZVR5cGUsIGN0eCk7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJwaXBlXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5pbiwgY3R4KSB8fCBpc1RyYW5zZm9ybWluZyhkZWYub3V0LCBjdHgpO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVmLnNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1pbmcoZGVmLnNoYXBlW2tleV0sIGN0eCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwidW5pb25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtaW5nKG9wdGlvbiwgY3R4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkZWYuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybWluZyhpdGVtLCBjdHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucmVzdCAmJiBpc1RyYW5zZm9ybWluZyhkZWYucmVzdCwgY3R4KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRvSlNPTlNjaGVtYSBtZXRob2QgZm9yIGEgc2NoZW1hIGluc3RhbmNlLlxuICogVGhpcyBlbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIG9mIGluaXRpYWxpemluZyBjb250ZXh0LCBwcm9jZXNzaW5nLCBleHRyYWN0aW5nIGRlZnMsIGFuZCBmaW5hbGl6aW5nLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVG9KU09OU2NoZW1hTWV0aG9kID0gKHNjaGVtYSwgcHJvY2Vzc29ycyA9IHt9KSA9PiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gaW5pdGlhbGl6ZUNvbnRleHQoeyAuLi5wYXJhbXMsIHByb2Nlc3NvcnMgfSk7XG4gICAgcHJvY2VzcyhzY2hlbWEsIGN0eCk7XG4gICAgZXh0cmFjdERlZnMoY3R4LCBzY2hlbWEpO1xuICAgIHJldHVybiBmaW5hbGl6ZShjdHgsIHNjaGVtYSk7XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZCA9IChzY2hlbWEsIGlvLCBwcm9jZXNzb3JzID0ge30pID0+IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGxpYnJhcnlPcHRpb25zLCB0YXJnZXQgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICBjb25zdCBjdHggPSBpbml0aWFsaXplQ29udGV4dCh7IC4uLihsaWJyYXJ5T3B0aW9ucyA/PyB7fSksIHRhcmdldCwgaW8sIHByb2Nlc3NvcnMgfSk7XG4gICAgcHJvY2VzcyhzY2hlbWEsIGN0eCk7XG4gICAgZXh0cmFjdERlZnMoY3R4LCBzY2hlbWEpO1xuICAgIHJldHVybiBmaW5hbGl6ZShjdHgsIHNjaGVtYSk7XG59O1xuIiwgImltcG9ydCB7IGV4dHJhY3REZWZzLCBmaW5hbGl6ZSwgaW5pdGlhbGl6ZUNvbnRleHQsIHByb2Nlc3MsIH0gZnJvbSBcIi4vdG8tanNvbi1zY2hlbWEuanNcIjtcbmltcG9ydCB7IGdldEVudW1WYWx1ZXMgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5jb25zdCBmb3JtYXRNYXAgPSB7XG4gICAgZ3VpZDogXCJ1dWlkXCIsXG4gICAgdXJsOiBcInVyaVwiLFxuICAgIGRhdGV0aW1lOiBcImRhdGUtdGltZVwiLFxuICAgIGpzb25fc3RyaW5nOiBcImpzb24tc3RyaW5nXCIsXG4gICAgcmVnZXg6IFwiXCIsIC8vIGRvIG5vdCBzZXRcbn07XG4vLyA9PT09PT09PT09PT09PT09PT09PSBTSU1QTEUgVFlQRSBQUk9DRVNTT1JTID09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgY29uc3Qgc3RyaW5nUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBqc29uLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgIGNvbnN0IHsgbWluaW11bSwgbWF4aW11bSwgZm9ybWF0LCBwYXR0ZXJucywgY29udGVudEVuY29kaW5nIH0gPSBzY2hlbWEuX3pvZFxuICAgICAgICAuYmFnO1xuICAgIGlmICh0eXBlb2YgbWluaW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5taW5MZW5ndGggPSBtaW5pbXVtO1xuICAgIGlmICh0eXBlb2YgbWF4aW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tYXhMZW5ndGggPSBtYXhpbXVtO1xuICAgIC8vIGN1c3RvbSBwYXR0ZXJuIG92ZXJyaWRlcyBmb3JtYXRcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGpzb24uZm9ybWF0ID0gZm9ybWF0TWFwW2Zvcm1hdF0gPz8gZm9ybWF0O1xuICAgICAgICBpZiAoanNvbi5mb3JtYXQgPT09IFwiXCIpXG4gICAgICAgICAgICBkZWxldGUganNvbi5mb3JtYXQ7IC8vIGVtcHR5IGZvcm1hdCBpcyBub3QgdmFsaWRcbiAgICAgICAgLy8gSlNPTiBTY2hlbWEgZm9ybWF0OiBcInRpbWVcIiByZXF1aXJlcyBhIGZ1bGwgdGltZSB3aXRoIG9mZnNldCBvciBaXG4gICAgICAgIC8vIHouaXNvLnRpbWUoKSBkb2VzIG5vdCBpbmNsdWRlIHRpbWV6b25lIGluZm9ybWF0aW9uLCBzbyBmb3JtYXQ6IFwidGltZVwiIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUganNvbi5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRFbmNvZGluZylcbiAgICAgICAganNvbi5jb250ZW50RW5jb2RpbmcgPSBjb250ZW50RW5jb2Rpbmc7XG4gICAgaWYgKHBhdHRlcm5zICYmIHBhdHRlcm5zLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ZXMgPSBbLi4ucGF0dGVybnNdO1xuICAgICAgICBpZiAocmVnZXhlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBqc29uLnBhdHRlcm4gPSByZWdleGVzWzBdLnNvdXJjZTtcbiAgICAgICAgZWxzZSBpZiAocmVnZXhlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBqc29uLmFsbE9mID0gW1xuICAgICAgICAgICAgICAgIC4uLnJlZ2V4ZXMubWFwKChyZWdleCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDdcIiB8fCBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgdHlwZTogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogcmVnZXguc291cmNlLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG51bWJlclByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtLCBmb3JtYXQsIG11bHRpcGxlT2YsIGV4Y2x1c2l2ZU1heGltdW0sIGV4Y2x1c2l2ZU1pbmltdW0gfSA9IHNjaGVtYS5fem9kLmJhZztcbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gXCJzdHJpbmdcIiAmJiBmb3JtYXQuaW5jbHVkZXMoXCJpbnRcIikpXG4gICAgICAgIGpzb24udHlwZSA9IFwiaW50ZWdlclwiO1xuICAgIGVsc2VcbiAgICAgICAganNvbi50eXBlID0gXCJudW1iZXJcIjtcbiAgICBpZiAodHlwZW9mIGV4Y2x1c2l2ZU1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIiB8fCBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgICAgIGpzb24ubWluaW11bSA9IGV4Y2x1c2l2ZU1pbmltdW07XG4gICAgICAgICAgICBqc29uLmV4Y2x1c2l2ZU1pbmltdW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAganNvbi5leGNsdXNpdmVNaW5pbXVtID0gZXhjbHVzaXZlTWluaW11bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAganNvbi5taW5pbXVtID0gbWluaW11bTtcbiAgICAgICAgaWYgKHR5cGVvZiBleGNsdXNpdmVNaW5pbXVtID09PSBcIm51bWJlclwiICYmIGN0eC50YXJnZXQgIT09IFwiZHJhZnQtMDRcIikge1xuICAgICAgICAgICAgaWYgKGV4Y2x1c2l2ZU1pbmltdW0gPj0gbWluaW11bSlcbiAgICAgICAgICAgICAgICBkZWxldGUganNvbi5taW5pbXVtO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmV4Y2x1c2l2ZU1pbmltdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGNsdXNpdmVNYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgICAgICBqc29uLm1heGltdW0gPSBleGNsdXNpdmVNYXhpbXVtO1xuICAgICAgICAgICAganNvbi5leGNsdXNpdmVNYXhpbXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGpzb24uZXhjbHVzaXZlTWF4aW11bSA9IGV4Y2x1c2l2ZU1heGltdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGpzb24ubWF4aW11bSA9IG1heGltdW07XG4gICAgICAgIGlmICh0eXBlb2YgZXhjbHVzaXZlTWF4aW11bSA9PT0gXCJudW1iZXJcIiAmJiBjdHgudGFyZ2V0ICE9PSBcImRyYWZ0LTA0XCIpIHtcbiAgICAgICAgICAgIGlmIChleGNsdXNpdmVNYXhpbXVtIDw9IG1heGltdW0pXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpzb24ubWF4aW11bTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUganNvbi5leGNsdXNpdmVNYXhpbXVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbXVsdGlwbGVPZiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tdWx0aXBsZU9mID0gbXVsdGlwbGVPZjtcbn07XG5leHBvcnQgY29uc3QgYm9vbGVhblByb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAganNvbi50eXBlID0gXCJib29sZWFuXCI7XG59O1xuZXhwb3J0IGNvbnN0IGJpZ2ludFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaWdJbnQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc3ltYm9sUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bWJvbHMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbnVsbFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGpzb24ubnVsbGFibGUgPSB0cnVlO1xuICAgICAgICBqc29uLmVudW0gPSBbbnVsbF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uLnR5cGUgPSBcIm51bGxcIjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHVuZGVmaW5lZFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgdm9pZFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWb2lkIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG5ldmVyUHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBqc29uLm5vdCA9IHt9O1xufTtcbmV4cG9ydCBjb25zdCBhbnlQcm9jZXNzb3IgPSAoX3NjaGVtYSwgX2N0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICAvLyBlbXB0eSBzY2hlbWEgYWNjZXB0cyBhbnl0aGluZ1xufTtcbmV4cG9ydCBjb25zdCB1bmtub3duUHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgLy8gZW1wdHkgc2NoZW1hIGFjY2VwdHMgYW55dGhpbmdcbn07XG5leHBvcnQgY29uc3QgZGF0ZVByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGVudW1Qcm9jZXNzb3IgPSAoc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IHZhbHVlcyA9IGdldEVudW1WYWx1ZXMoZGVmLmVudHJpZXMpO1xuICAgIC8vIE51bWJlciBlbnVtcyBjYW4gaGF2ZSBib3RoIHN0cmluZyBhbmQgbnVtYmVyIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSlcbiAgICAgICAganNvbi50eXBlID0gXCJudW1iZXJcIjtcbiAgICBpZiAodmFsdWVzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikpXG4gICAgICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAganNvbi5lbnVtID0gdmFsdWVzO1xufTtcbmV4cG9ydCBjb25zdCBsaXRlcmFsUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IHZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBkZWYudmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxpdGVyYWwgYHVuZGVmaW5lZGAgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFkZCB0byB2YWxzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCBsaXRlcmFscyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxzLnB1c2goTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgKGFuIHVuZGVmaW5lZCBsaXRlcmFsIHdhcyBzdHJpcHBlZClcbiAgICB9XG4gICAgZWxzZSBpZiAodmFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdmFsc1swXTtcbiAgICAgICAganNvbi50eXBlID0gdmFsID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiIHx8IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICAgICAganNvbi5lbnVtID0gW3ZhbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqc29uLmNvbnN0ID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFscy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAganNvbi50eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgaWYgKHZhbHMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSlcbiAgICAgICAgICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGlmICh2YWxzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpKVxuICAgICAgICAgICAganNvbi50eXBlID0gXCJib29sZWFuXCI7XG4gICAgICAgIGlmICh2YWxzLmV2ZXJ5KCh2KSA9PiB2ID09PSBudWxsKSlcbiAgICAgICAgICAgIGpzb24udHlwZSA9IFwibnVsbFwiO1xuICAgICAgICBqc29uLmVudW0gPSB2YWxzO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbmFuUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hTiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0ZW1wbGF0ZUxpdGVyYWxQcm9jZXNzb3IgPSAoc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgX2pzb24gPSBqc29uO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEuX3pvZC5wYXR0ZXJuO1xuICAgIGlmICghcGF0dGVybilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBub3QgZm91bmQgaW4gdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICBfanNvbi50eXBlID0gXCJzdHJpbmdcIjtcbiAgICBfanNvbi5wYXR0ZXJuID0gcGF0dGVybi5zb3VyY2U7XG59O1xuZXhwb3J0IGNvbnN0IGZpbGVQcm9jZXNzb3IgPSAoc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgX2pzb24gPSBqc29uO1xuICAgIGNvbnN0IGZpbGUgPSB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJiaW5hcnlcIixcbiAgICAgICAgY29udGVudEVuY29kaW5nOiBcImJpbmFyeVwiLFxuICAgIH07XG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtLCBtaW1lIH0gPSBzY2hlbWEuX3pvZC5iYWc7XG4gICAgaWYgKG1pbmltdW0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgZmlsZS5taW5MZW5ndGggPSBtaW5pbXVtO1xuICAgIGlmIChtYXhpbXVtICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGZpbGUubWF4TGVuZ3RoID0gbWF4aW11bTtcbiAgICBpZiAobWltZSkge1xuICAgICAgICBpZiAobWltZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGZpbGUuY29udGVudE1lZGlhVHlwZSA9IG1pbWVbMF07XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF9qc29uLCBmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oX2pzb24sIGZpbGUpOyAvLyBzaGFyZWQgcHJvcHMgYXQgcm9vdFxuICAgICAgICAgICAgX2pzb24uYW55T2YgPSBtaW1lLm1hcCgobSkgPT4gKHsgY29udGVudE1lZGlhVHlwZTogbSB9KSk7IC8vIG9ubHkgY29udGVudE1lZGlhVHlwZSBkaWZmZXJzXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oX2pzb24sIGZpbGUpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc3VjY2Vzc1Byb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAganNvbi50eXBlID0gXCJib29sZWFuXCI7XG59O1xuZXhwb3J0IGNvbnN0IGN1c3RvbVByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXN0b20gdHlwZXMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZnVuY3Rpb25Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gdHlwZXMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdHJhbnNmb3JtUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zZm9ybXMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbWFwUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBzZXRQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0IGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuLy8gPT09PT09PT09PT09PT09PT09PT0gQ09NUE9TSVRFIFRZUEUgUFJPQ0VTU09SUyA9PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0IGNvbnN0IGFycmF5UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0gfSA9IHNjaGVtYS5fem9kLmJhZztcbiAgICBpZiAodHlwZW9mIG1pbmltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWluSXRlbXMgPSBtaW5pbXVtO1xuICAgIGlmICh0eXBlb2YgbWF4aW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tYXhJdGVtcyA9IG1heGltdW07XG4gICAganNvbi50eXBlID0gXCJhcnJheVwiO1xuICAgIGpzb24uaXRlbXMgPSBwcm9jZXNzKGRlZi5lbGVtZW50LCBjdHgsIHsgLi4ucGFyYW1zLCBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwiaXRlbXNcIl0gfSk7XG59O1xuZXhwb3J0IGNvbnN0IG9iamVjdFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAganNvbi50eXBlID0gXCJvYmplY3RcIjtcbiAgICBqc29uLnByb3BlcnRpZXMgPSB7fTtcbiAgICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgICBqc29uLnByb3BlcnRpZXNba2V5XSA9IHByb2Nlc3Moc2hhcGVba2V5XSwgY3R4LCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwicHJvcGVydGllc1wiLCBrZXldLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmVxdWlyZWQga2V5c1xuICAgIGNvbnN0IGFsbEtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHNoYXBlKSk7XG4gICAgY29uc3QgcmVxdWlyZWRLZXlzID0gbmV3IFNldChbLi4uYWxsS2V5c10uZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IGRlZi5zaGFwZVtrZXldLl96b2Q7XG4gICAgICAgIGlmIChjdHguaW8gPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHYub3B0aW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2Lm9wdG91dCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChyZXF1aXJlZEtleXMuc2l6ZSA+IDApIHtcbiAgICAgICAganNvbi5yZXF1aXJlZCA9IEFycmF5LmZyb20ocmVxdWlyZWRLZXlzKTtcbiAgICB9XG4gICAgLy8gY2F0Y2hhbGxcbiAgICBpZiAoZGVmLmNhdGNoYWxsPy5fem9kLmRlZi50eXBlID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgLy8gc3RyaWN0XG4gICAgICAgIGpzb24uYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWRlZi5jYXRjaGFsbCkge1xuICAgICAgICAvLyByZWd1bGFyXG4gICAgICAgIGlmIChjdHguaW8gPT09IFwib3V0cHV0XCIpXG4gICAgICAgICAgICBqc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jYXRjaGFsbCkge1xuICAgICAgICBqc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcHJvY2VzcyhkZWYuY2F0Y2hhbGwsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHVuaW9uUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgLy8gRXhjbHVzaXZlIHVuaW9ucyAoaW5jbHVzaXZlID09PSBmYWxzZSkgdXNlIG9uZU9mIChleGFjdGx5IG9uZSBtYXRjaCkgaW5zdGVhZCBvZiBhbnlPZiAob25lIG9yIG1vcmUgbWF0Y2hlcylcbiAgICAvLyBUaGlzIGluY2x1ZGVzIGJvdGggei54b3IoKSBhbmQgZGlzY3JpbWluYXRlZCB1bmlvbnNcbiAgICBjb25zdCBpc0V4Y2x1c2l2ZSA9IGRlZi5pbmNsdXNpdmUgPT09IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkZWYub3B0aW9ucy5tYXAoKHgsIGkpID0+IHByb2Nlc3MoeCwgY3R4LCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBpc0V4Y2x1c2l2ZSA/IFwib25lT2ZcIiA6IFwiYW55T2ZcIiwgaV0sXG4gICAgfSkpO1xuICAgIGlmIChpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBqc29uLm9uZU9mID0gb3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb24uYW55T2YgPSBvcHRpb25zO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgaW50ZXJzZWN0aW9uUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgYSA9IHByb2Nlc3MoZGVmLmxlZnQsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJhbGxPZlwiLCAwXSxcbiAgICB9KTtcbiAgICBjb25zdCBiID0gcHJvY2VzcyhkZWYucmlnaHQsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJhbGxPZlwiLCAxXSxcbiAgICB9KTtcbiAgICBjb25zdCBpc1NpbXBsZUludGVyc2VjdGlvbiA9ICh2YWwpID0+IFwiYWxsT2ZcIiBpbiB2YWwgJiYgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgYWxsT2YgPSBbXG4gICAgICAgIC4uLihpc1NpbXBsZUludGVyc2VjdGlvbihhKSA/IGEuYWxsT2YgOiBbYV0pLFxuICAgICAgICAuLi4oaXNTaW1wbGVJbnRlcnNlY3Rpb24oYikgPyBiLmFsbE9mIDogW2JdKSxcbiAgICBdO1xuICAgIGpzb24uYWxsT2YgPSBhbGxPZjtcbn07XG5leHBvcnQgY29uc3QgdHVwbGVQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGpzb24udHlwZSA9IFwiYXJyYXlcIjtcbiAgICBjb25zdCBwcmVmaXhQYXRoID0gY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcInByZWZpeEl0ZW1zXCIgOiBcIml0ZW1zXCI7XG4gICAgY29uc3QgcmVzdFBhdGggPSBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiaXRlbXNcIiA6IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIiA/IFwiaXRlbXNcIiA6IFwiYWRkaXRpb25hbEl0ZW1zXCI7XG4gICAgY29uc3QgcHJlZml4SXRlbXMgPSBkZWYuaXRlbXMubWFwKCh4LCBpKSA9PiBwcm9jZXNzKHgsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgcHJlZml4UGF0aCwgaV0sXG4gICAgfSkpO1xuICAgIGNvbnN0IHJlc3QgPSBkZWYucmVzdFxuICAgICAgICA/IHByb2Nlc3MoZGVmLnJlc3QsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCByZXN0UGF0aCwgLi4uKGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIiA/IFtkZWYuaXRlbXMubGVuZ3RoXSA6IFtdKV0sXG4gICAgICAgIH0pXG4gICAgICAgIDogbnVsbDtcbiAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIpIHtcbiAgICAgICAganNvbi5wcmVmaXhJdGVtcyA9IHByZWZpeEl0ZW1zO1xuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAganNvbi5pdGVtcyA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIGpzb24uaXRlbXMgPSB7XG4gICAgICAgICAgICBhbnlPZjogcHJlZml4SXRlbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICBqc29uLml0ZW1zLmFueU9mLnB1c2gocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAganNvbi5taW5JdGVtcyA9IHByZWZpeEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICBqc29uLm1heEl0ZW1zID0gcHJlZml4SXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uLml0ZW1zID0gcHJlZml4SXRlbXM7XG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICBqc29uLmFkZGl0aW9uYWxJdGVtcyA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGVuZ3RoXG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtIH0gPSBzY2hlbWEuX3pvZC5iYWc7XG4gICAgaWYgKHR5cGVvZiBtaW5pbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1pbkl0ZW1zID0gbWluaW11bTtcbiAgICBpZiAodHlwZW9mIG1heGltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWF4SXRlbXMgPSBtYXhpbXVtO1xufTtcbmV4cG9ydCBjb25zdCByZWNvcmRQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGpzb24udHlwZSA9IFwib2JqZWN0XCI7XG4gICAgLy8gRm9yIGxvb3NlUmVjb3JkIHdpdGggcmVnZXggcGF0dGVybnMsIHVzZSBwYXR0ZXJuUHJvcGVydGllc1xuICAgIC8vIFRoaXMgY29ycmVjdGx5IHJlcHJlc2VudHMgXCJvbmx5IHZhbGlkYXRlIGtleXMgbWF0Y2hpbmcgdGhlIHBhdHRlcm5cIiBzZW1hbnRpY3NcbiAgICAvLyBhbmQgY29tcG9zZXMgd2VsbCB3aXRoIGFsbE9mIChpbnRlcnNlY3Rpb25zKVxuICAgIGNvbnN0IGtleVR5cGUgPSBkZWYua2V5VHlwZTtcbiAgICBjb25zdCBrZXlCYWcgPSBrZXlUeXBlLl96b2QuYmFnO1xuICAgIGNvbnN0IHBhdHRlcm5zID0ga2V5QmFnPy5wYXR0ZXJucztcbiAgICBpZiAoZGVmLm1vZGUgPT09IFwibG9vc2VcIiAmJiBwYXR0ZXJucyAmJiBwYXR0ZXJucy5zaXplID4gMCkge1xuICAgICAgICAvLyBVc2UgcGF0dGVyblByb3BlcnRpZXMgZm9yIGxvb3NlUmVjb3JkIHdpdGggcmVnZXggcGF0dGVybnNcbiAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSBwcm9jZXNzKGRlZi52YWx1ZVR5cGUsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsIFwiKlwiXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGpzb24ucGF0dGVyblByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICBqc29uLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm4uc291cmNlXSA9IHZhbHVlU2NoZW1hO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiB1c2UgcHJvcGVydHlOYW1lcyArIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA3XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIpIHtcbiAgICAgICAgICAgIGpzb24ucHJvcGVydHlOYW1lcyA9IHByb2Nlc3MoZGVmLmtleVR5cGUsIGN0eCwge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwicHJvcGVydHlOYW1lc1wiXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGpzb24uYWRkaXRpb25hbFByb3BlcnRpZXMgPSBwcm9jZXNzKGRlZi52YWx1ZVR5cGUsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWRkIHJlcXVpcmVkIGZvciBrZXlzIHdpdGggZGlzY3JldGUgdmFsdWVzIChlbnVtLCBsaXRlcmFsLCBldGMuKVxuICAgIGNvbnN0IGtleVZhbHVlcyA9IGtleVR5cGUuX3pvZC52YWx1ZXM7XG4gICAgaWYgKGtleVZhbHVlcykge1xuICAgICAgICBjb25zdCB2YWxpZEtleVZhbHVlcyA9IFsuLi5rZXlWYWx1ZXNdLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpO1xuICAgICAgICBpZiAodmFsaWRLZXlWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAganNvbi5yZXF1aXJlZCA9IHZhbGlkS2V5VmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBudWxsYWJsZVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGlubmVyID0gcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIGlmIChjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgICAgICBqc29uLm51bGxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb24uYW55T2YgPSBbaW5uZXIsIHsgdHlwZTogXCJudWxsXCIgfV07XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBub25vcHRpb25hbFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xufTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbiAgICBqc29uLmRlZmF1bHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZi5kZWZhdWx0VmFsdWUpKTtcbn07XG5leHBvcnQgY29uc3QgcHJlZmF1bHRQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgIGlmIChjdHguaW8gPT09IFwiaW5wdXRcIilcbiAgICAgICAganNvbi5fcHJlZmF1bHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZi5kZWZhdWx0VmFsdWUpKTtcbn07XG5leHBvcnQgY29uc3QgY2F0Y2hQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgIGxldCBjYXRjaFZhbHVlO1xuICAgIHRyeSB7XG4gICAgICAgIGNhdGNoVmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgY2F0Y2ggdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbiAgICBqc29uLmRlZmF1bHQgPSBjYXRjaFZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBwaXBlUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGlubmVyVHlwZSA9IGN0eC5pbyA9PT0gXCJpbnB1dFwiID8gKGRlZi5pbi5fem9kLmRlZi50eXBlID09PSBcInRyYW5zZm9ybVwiID8gZGVmLm91dCA6IGRlZi5pbikgOiBkZWYub3V0O1xuICAgIHByb2Nlc3MoaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gaW5uZXJUeXBlO1xufTtcbmV4cG9ydCBjb25zdCByZWFkb25seVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG4gICAganNvbi5yZWFkT25seSA9IHRydWU7XG59O1xuZXhwb3J0IGNvbnN0IHByb21pc2VQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbn07XG5leHBvcnQgY29uc3Qgb3B0aW9uYWxQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbn07XG5leHBvcnQgY29uc3QgbGF6eVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGlubmVyVHlwZSA9IHNjaGVtYS5fem9kLmlubmVyVHlwZTtcbiAgICBwcm9jZXNzKGlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGlubmVyVHlwZTtcbn07XG4vLyA9PT09PT09PT09PT09PT09PT09PSBBTEwgUFJPQ0VTU09SUyA9PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0IGNvbnN0IGFsbFByb2Nlc3NvcnMgPSB7XG4gICAgc3RyaW5nOiBzdHJpbmdQcm9jZXNzb3IsXG4gICAgbnVtYmVyOiBudW1iZXJQcm9jZXNzb3IsXG4gICAgYm9vbGVhbjogYm9vbGVhblByb2Nlc3NvcixcbiAgICBiaWdpbnQ6IGJpZ2ludFByb2Nlc3NvcixcbiAgICBzeW1ib2w6IHN5bWJvbFByb2Nlc3NvcixcbiAgICBudWxsOiBudWxsUHJvY2Vzc29yLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkUHJvY2Vzc29yLFxuICAgIHZvaWQ6IHZvaWRQcm9jZXNzb3IsXG4gICAgbmV2ZXI6IG5ldmVyUHJvY2Vzc29yLFxuICAgIGFueTogYW55UHJvY2Vzc29yLFxuICAgIHVua25vd246IHVua25vd25Qcm9jZXNzb3IsXG4gICAgZGF0ZTogZGF0ZVByb2Nlc3NvcixcbiAgICBlbnVtOiBlbnVtUHJvY2Vzc29yLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxQcm9jZXNzb3IsXG4gICAgbmFuOiBuYW5Qcm9jZXNzb3IsXG4gICAgdGVtcGxhdGVfbGl0ZXJhbDogdGVtcGxhdGVMaXRlcmFsUHJvY2Vzc29yLFxuICAgIGZpbGU6IGZpbGVQcm9jZXNzb3IsXG4gICAgc3VjY2Vzczogc3VjY2Vzc1Byb2Nlc3NvcixcbiAgICBjdXN0b206IGN1c3RvbVByb2Nlc3NvcixcbiAgICBmdW5jdGlvbjogZnVuY3Rpb25Qcm9jZXNzb3IsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1Qcm9jZXNzb3IsXG4gICAgbWFwOiBtYXBQcm9jZXNzb3IsXG4gICAgc2V0OiBzZXRQcm9jZXNzb3IsXG4gICAgYXJyYXk6IGFycmF5UHJvY2Vzc29yLFxuICAgIG9iamVjdDogb2JqZWN0UHJvY2Vzc29yLFxuICAgIHVuaW9uOiB1bmlvblByb2Nlc3NvcixcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblByb2Nlc3NvcixcbiAgICB0dXBsZTogdHVwbGVQcm9jZXNzb3IsXG4gICAgcmVjb3JkOiByZWNvcmRQcm9jZXNzb3IsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlUHJvY2Vzc29yLFxuICAgIG5vbm9wdGlvbmFsOiBub25vcHRpb25hbFByb2Nlc3NvcixcbiAgICBkZWZhdWx0OiBkZWZhdWx0UHJvY2Vzc29yLFxuICAgIHByZWZhdWx0OiBwcmVmYXVsdFByb2Nlc3NvcixcbiAgICBjYXRjaDogY2F0Y2hQcm9jZXNzb3IsXG4gICAgcGlwZTogcGlwZVByb2Nlc3NvcixcbiAgICByZWFkb25seTogcmVhZG9ubHlQcm9jZXNzb3IsXG4gICAgcHJvbWlzZTogcHJvbWlzZVByb2Nlc3NvcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWxQcm9jZXNzb3IsXG4gICAgbGF6eTogbGF6eVByb2Nlc3Nvcixcbn07XG5leHBvcnQgZnVuY3Rpb24gdG9KU09OU2NoZW1hKGlucHV0LCBwYXJhbXMpIHtcbiAgICBpZiAoXCJfaWRtYXBcIiBpbiBpbnB1dCkge1xuICAgICAgICAvLyBSZWdpc3RyeSBjYXNlXG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IGluaXRpYWxpemVDb250ZXh0KHsgLi4ucGFyYW1zLCBwcm9jZXNzb3JzOiBhbGxQcm9jZXNzb3JzIH0pO1xuICAgICAgICBjb25zdCBkZWZzID0ge307XG4gICAgICAgIC8vIEZpcnN0IHBhc3M6IHByb2Nlc3MgYWxsIHNjaGVtYXMgdG8gYnVpbGQgdGhlIHNlZW4gbWFwXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVnaXN0cnkuX2lkbWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgW18sIHNjaGVtYV0gPSBlbnRyeTtcbiAgICAgICAgICAgIHByb2Nlc3Moc2NoZW1hLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaGVtYXMgPSB7fTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSB7XG4gICAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICAgIHVyaTogcGFyYW1zPy51cmksXG4gICAgICAgICAgICBkZWZzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRleHQgd2l0aCBleHRlcm5hbCBjb25maWd1cmF0aW9uXG4gICAgICAgIGN0eC5leHRlcm5hbCA9IGV4dGVybmFsO1xuICAgICAgICAvLyBTZWNvbmQgcGFzczogZW1pdCBlYWNoIHNjaGVtYVxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlZ2lzdHJ5Ll9pZG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHNjaGVtYV0gPSBlbnRyeTtcbiAgICAgICAgICAgIGV4dHJhY3REZWZzKGN0eCwgc2NoZW1hKTtcbiAgICAgICAgICAgIHNjaGVtYXNba2V5XSA9IGZpbmFsaXplKGN0eCwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmc1NlZ21lbnQgPSBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiJGRlZnNcIiA6IFwiZGVmaW5pdGlvbnNcIjtcbiAgICAgICAgICAgIHNjaGVtYXMuX19zaGFyZWQgPSB7XG4gICAgICAgICAgICAgICAgW2RlZnNTZWdtZW50XTogZGVmcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hcyB9O1xuICAgIH1cbiAgICAvLyBTaW5nbGUgc2NoZW1hIGNhc2VcbiAgICBjb25zdCBjdHggPSBpbml0aWFsaXplQ29udGV4dCh7IC4uLnBhcmFtcywgcHJvY2Vzc29yczogYWxsUHJvY2Vzc29ycyB9KTtcbiAgICBwcm9jZXNzKGlucHV0LCBjdHgpO1xuICAgIGV4dHJhY3REZWZzKGN0eCwgaW5wdXQpO1xuICAgIHJldHVybiBmaW5hbGl6ZShjdHgsIGlucHV0KTtcbn1cbiIsIG51bGwsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1dGlsIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCAqIGFzIHByb2Nlc3NvcnMgZnJvbSBcIi4uL2NvcmUvanNvbi1zY2hlbWEtcHJvY2Vzc29ycy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kLCBjcmVhdGVUb0pTT05TY2hlbWFNZXRob2QgfSBmcm9tIFwiLi4vY29yZS90by1qc29uLXNjaGVtYS5qc1wiO1xuaW1wb3J0ICogYXMgY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgaXNvIGZyb20gXCIuL2lzby5qc1wiO1xuaW1wb3J0ICogYXMgcGFyc2UgZnJvbSBcIi4vcGFyc2UuanNcIjtcbmV4cG9ydCBjb25zdCBab2RUeXBlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdFtcIn5zdGFuZGFyZFwiXSwge1xuICAgICAgICBqc29uU2NoZW1hOiB7XG4gICAgICAgICAgICBpbnB1dDogY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kKGluc3QsIFwiaW5wdXRcIiksXG4gICAgICAgICAgICBvdXRwdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChpbnN0LCBcIm91dHB1dFwiKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBpbnN0LnRvSlNPTlNjaGVtYSA9IGNyZWF0ZVRvSlNPTlNjaGVtYU1ldGhvZChpbnN0LCB7fSk7XG4gICAgaW5zdC5kZWYgPSBkZWY7XG4gICAgaW5zdC50eXBlID0gZGVmLnR5cGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX2RlZlwiLCB7IHZhbHVlOiBkZWYgfSk7XG4gICAgLy8gYmFzZSBtZXRob2RzXG4gICAgaW5zdC5jaGVjayA9ICguLi5jaGVja3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGluc3QuY2xvbmUodXRpbC5tZXJnZURlZnMoZGVmLCB7XG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi4oZGVmLmNoZWNrcyA/PyBbXSksXG4gICAgICAgICAgICAgICAgLi4uY2hlY2tzLm1hcCgoY2gpID0+IHR5cGVvZiBjaCA9PT0gXCJmdW5jdGlvblwiID8geyBfem9kOiB7IGNoZWNrOiBjaCwgZGVmOiB7IGNoZWNrOiBcImN1c3RvbVwiIH0sIG9uYXR0YWNoOiBbXSB9IH0gOiBjaCksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgcGFyZW50OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGluc3Qud2l0aCA9IGluc3QuY2hlY2s7XG4gICAgaW5zdC5jbG9uZSA9IChkZWYsIHBhcmFtcykgPT4gY29yZS5jbG9uZShpbnN0LCBkZWYsIHBhcmFtcyk7XG4gICAgaW5zdC5icmFuZCA9ICgpID0+IGluc3Q7XG4gICAgaW5zdC5yZWdpc3RlciA9ICgocmVnLCBtZXRhKSA9PiB7XG4gICAgICAgIHJlZy5hZGQoaW5zdCwgbWV0YSk7XG4gICAgICAgIHJldHVybiBpbnN0O1xuICAgIH0pO1xuICAgIC8vIHBhcnNpbmdcbiAgICBpbnN0LnBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UucGFyc2UoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZSB9KTtcbiAgICBpbnN0LnNhZmVQYXJzZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVQYXJzZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3QucGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZUFzeW5jIH0pO1xuICAgIGluc3Quc2FmZVBhcnNlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlUGFyc2VBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc3BhID0gaW5zdC5zYWZlUGFyc2VBc3luYztcbiAgICAvLyBlbmNvZGluZy9kZWNvZGluZ1xuICAgIGluc3QuZW5jb2RlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZW5jb2RlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5kZWNvZGUgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5kZWNvZGUoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LmVuY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZW5jb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LmRlY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZGVjb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnNhZmVFbmNvZGUgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlRW5jb2RlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zYWZlRGVjb2RlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZURlY29kZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc2FmZUVuY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZUVuY29kZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zYWZlRGVjb2RlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlRGVjb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICAvLyByZWZpbmVtZW50c1xuICAgIGluc3QucmVmaW5lID0gKGNoZWNrLCBwYXJhbXMpID0+IGluc3QuY2hlY2socmVmaW5lKGNoZWNrLCBwYXJhbXMpKTtcbiAgICBpbnN0LnN1cGVyUmVmaW5lID0gKHJlZmluZW1lbnQpID0+IGluc3QuY2hlY2soc3VwZXJSZWZpbmUocmVmaW5lbWVudCkpO1xuICAgIGluc3Qub3ZlcndyaXRlID0gKGZuKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5vdmVyd3JpdGUoZm4pKTtcbiAgICAvLyB3cmFwcGVyc1xuICAgIGluc3Qub3B0aW9uYWwgPSAoKSA9PiBvcHRpb25hbChpbnN0KTtcbiAgICBpbnN0LmV4YWN0T3B0aW9uYWwgPSAoKSA9PiBleGFjdE9wdGlvbmFsKGluc3QpO1xuICAgIGluc3QubnVsbGFibGUgPSAoKSA9PiBudWxsYWJsZShpbnN0KTtcbiAgICBpbnN0Lm51bGxpc2ggPSAoKSA9PiBvcHRpb25hbChudWxsYWJsZShpbnN0KSk7XG4gICAgaW5zdC5ub25vcHRpb25hbCA9IChwYXJhbXMpID0+IG5vbm9wdGlvbmFsKGluc3QsIHBhcmFtcyk7XG4gICAgaW5zdC5hcnJheSA9ICgpID0+IGFycmF5KGluc3QpO1xuICAgIGluc3Qub3IgPSAoYXJnKSA9PiB1bmlvbihbaW5zdCwgYXJnXSk7XG4gICAgaW5zdC5hbmQgPSAoYXJnKSA9PiBpbnRlcnNlY3Rpb24oaW5zdCwgYXJnKTtcbiAgICBpbnN0LnRyYW5zZm9ybSA9ICh0eCkgPT4gcGlwZShpbnN0LCB0cmFuc2Zvcm0odHgpKTtcbiAgICBpbnN0LmRlZmF1bHQgPSAoZGVmKSA9PiBfZGVmYXVsdChpbnN0LCBkZWYpO1xuICAgIGluc3QucHJlZmF1bHQgPSAoZGVmKSA9PiBwcmVmYXVsdChpbnN0LCBkZWYpO1xuICAgIC8vIGluc3QuY29hbGVzY2UgPSAoZGVmLCBwYXJhbXMpID0+IGNvYWxlc2NlKGluc3QsIGRlZiwgcGFyYW1zKTtcbiAgICBpbnN0LmNhdGNoID0gKHBhcmFtcykgPT4gX2NhdGNoKGluc3QsIHBhcmFtcyk7XG4gICAgaW5zdC5waXBlID0gKHRhcmdldCkgPT4gcGlwZShpbnN0LCB0YXJnZXQpO1xuICAgIGluc3QucmVhZG9ubHkgPSAoKSA9PiByZWFkb25seShpbnN0KTtcbiAgICAvLyBtZXRhXG4gICAgaW5zdC5kZXNjcmliZSA9IChkZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBjbCA9IGluc3QuY2xvbmUoKTtcbiAgICAgICAgY29yZS5nbG9iYWxSZWdpc3RyeS5hZGQoY2wsIHsgZGVzY3JpcHRpb24gfSk7XG4gICAgICAgIHJldHVybiBjbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpPy5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIGluc3QubWV0YSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgICAgICBjb3JlLmdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgYXJnc1swXSk7XG4gICAgICAgIHJldHVybiBjbDtcbiAgICB9O1xuICAgIC8vIGhlbHBlcnNcbiAgICBpbnN0LmlzT3B0aW9uYWwgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgaW5zdC5pc051bGxhYmxlID0gKCkgPT4gaW5zdC5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICBpbnN0LmFwcGx5ID0gKGZuKSA9PiBmbihpbnN0KTtcbiAgICByZXR1cm4gaW5zdDtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IF9ab2RTdHJpbmcgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiX1pvZFN0cmluZ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuc3RyaW5nUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgIGluc3QuZm9ybWF0ID0gYmFnLmZvcm1hdCA/PyBudWxsO1xuICAgIGluc3QubWluTGVuZ3RoID0gYmFnLm1pbmltdW0gPz8gbnVsbDtcbiAgICBpbnN0Lm1heExlbmd0aCA9IGJhZy5tYXhpbXVtID8/IG51bGw7XG4gICAgLy8gdmFsaWRhdGlvbnNcbiAgICBpbnN0LnJlZ2V4ID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLnJlZ2V4KC4uLmFyZ3MpKTtcbiAgICBpbnN0LmluY2x1ZGVzID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLmluY2x1ZGVzKC4uLmFyZ3MpKTtcbiAgICBpbnN0LnN0YXJ0c1dpdGggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3Muc3RhcnRzV2l0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5lbmRzV2l0aCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5lbmRzV2l0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5taW4gPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MubWluTGVuZ3RoKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lm1heCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tYXhMZW5ndGgoLi4uYXJncykpO1xuICAgIGluc3QubGVuZ3RoID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLmxlbmd0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5taW5MZW5ndGgoMSwgLi4uYXJncykpO1xuICAgIGluc3QubG93ZXJjYXNlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubG93ZXJjYXNlKHBhcmFtcykpO1xuICAgIGluc3QudXBwZXJjYXNlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MudXBwZXJjYXNlKHBhcmFtcykpO1xuICAgIC8vIHRyYW5zZm9ybXNcbiAgICBpbnN0LnRyaW0gPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy50cmltKCkpO1xuICAgIGluc3Qubm9ybWFsaXplID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLm5vcm1hbGl6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC50b0xvd2VyQ2FzZSA9ICgpID0+IGluc3QuY2hlY2soY2hlY2tzLnRvTG93ZXJDYXNlKCkpO1xuICAgIGluc3QudG9VcHBlckNhc2UgPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy50b1VwcGVyQ2FzZSgpKTtcbiAgICBpbnN0LnNsdWdpZnkgPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5zbHVnaWZ5KCkpO1xufSk7XG5leHBvcnQgY29uc3QgWm9kU3RyaW5nID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFN0cmluZ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbiAgICBfWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0LmVtYWlsID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9lbWFpbChab2RFbWFpbCwgcGFyYW1zKSk7XG4gICAgaW5zdC51cmwgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3VybChab2RVUkwsIHBhcmFtcykpO1xuICAgIGluc3Quand0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9qd3QoWm9kSldULCBwYXJhbXMpKTtcbiAgICBpbnN0LmVtb2ppID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9lbW9qaShab2RFbW9qaSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9ndWlkKFpvZEdVSUQsIHBhcmFtcykpO1xuICAgIGluc3QudXVpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXVpZChab2RVVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LnV1aWR2NCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXVpZHY0KFpvZFVVSUQsIHBhcmFtcykpO1xuICAgIGluc3QudXVpZHY2ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91dWlkdjYoWm9kVVVJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC51dWlkdjcgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3V1aWR2Nyhab2RVVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5hbm9pZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbmFub2lkKFpvZE5hbm9JRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9ndWlkKFpvZEdVSUQsIHBhcmFtcykpO1xuICAgIGluc3QuY3VpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fY3VpZChab2RDVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LmN1aWQyID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9jdWlkMihab2RDVUlEMiwgcGFyYW1zKSk7XG4gICAgaW5zdC51bGlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91bGlkKFpvZFVMSUQsIHBhcmFtcykpO1xuICAgIGluc3QuYmFzZTY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9iYXNlNjQoWm9kQmFzZTY0LCBwYXJhbXMpKTtcbiAgICBpbnN0LmJhc2U2NHVybCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fYmFzZTY0dXJsKFpvZEJhc2U2NFVSTCwgcGFyYW1zKSk7XG4gICAgaW5zdC54aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3hpZChab2RYSUQsIHBhcmFtcykpO1xuICAgIGluc3Qua3N1aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2tzdWlkKFpvZEtTVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LmlwdjQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2lwdjQoWm9kSVB2NCwgcGFyYW1zKSk7XG4gICAgaW5zdC5pcHY2ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9pcHY2KFpvZElQdjYsIHBhcmFtcykpO1xuICAgIGluc3QuY2lkcnY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9jaWRydjQoWm9kQ0lEUnY0LCBwYXJhbXMpKTtcbiAgICBpbnN0LmNpZHJ2NiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fY2lkcnY2KFpvZENJRFJ2NiwgcGFyYW1zKSk7XG4gICAgaW5zdC5lMTY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9lMTY0KFpvZEUxNjQsIHBhcmFtcykpO1xuICAgIC8vIGlzb1xuICAgIGluc3QuZGF0ZXRpbWUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGlzby5kYXRldGltZShwYXJhbXMpKTtcbiAgICBpbnN0LmRhdGUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGlzby5kYXRlKHBhcmFtcykpO1xuICAgIGluc3QudGltZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaXNvLnRpbWUocGFyYW1zKSk7XG4gICAgaW5zdC5kdXJhdGlvbiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaXNvLmR1cmF0aW9uKHBhcmFtcykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmcoWm9kU3RyaW5nLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFN0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgX1pvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCBab2RFbWFpbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RFbWFpbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RFbWFpbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGVtYWlsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9lbWFpbChab2RFbWFpbCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RHVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEdVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kR1VJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGd1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2d1aWQoWm9kR1VJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RVVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kVVVJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3V1aWQoWm9kVVVJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1dWlkdjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3V1aWR2NChab2RVVUlELCBwYXJhbXMpO1xufVxuLy8gWm9kVVVJRHY2XG5leHBvcnQgZnVuY3Rpb24gdXVpZHY2KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91dWlkdjYoWm9kVVVJRCwgcGFyYW1zKTtcbn1cbi8vIFpvZFVVSUR2N1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWR2NyhwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXVpZHY3KFpvZFVVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVVJMID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVSTFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RVUkwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1cmwocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VybChab2RVUkwsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaHR0cFVybChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXJsKFpvZFVSTCwge1xuICAgICAgICBwcm90b2NvbDogL15odHRwcz8kLyxcbiAgICAgICAgaG9zdG5hbWU6IGNvcmUucmVnZXhlcy5kb21haW4sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRW1vamkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRW1vamlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kRW1vamkuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBlbW9qaShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZW1vamkoWm9kRW1vamksIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTmFub0lEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE5hbm9JRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2ROYW5vSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBuYW5vaWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX25hbm9pZChab2ROYW5vSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZENVSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjdWlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jdWlkKFpvZENVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ1VJRDIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ1VJRDJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQ1VJRDIuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjdWlkMihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY3VpZDIoWm9kQ1VJRDIsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVUxJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVTElEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZFVMSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1bGlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91bGlkKFpvZFVMSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kWElEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFhJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RYSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB4aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3hpZChab2RYSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kS1NVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kS1NVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kS1NVSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBrc3VpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fa3N1aWQoWm9kS1NVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVB2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJUHY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZElQdjQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpcHY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pcHY0KFpvZElQdjQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTUFDID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE1BQ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RNQUMuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBtYWMocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX21hYyhab2RNQUMsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVB2NiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJUHY2XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZElQdjYuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpcHY2KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pcHY2KFpvZElQdjYsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ0lEUnY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENJRFJ2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQ0lEUnY0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gY2lkcnY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jaWRydjQoWm9kQ0lEUnY0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZENJRFJ2NiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDSURSdjZcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZENJRFJ2Ni5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGNpZHJ2NihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY2lkcnY2KFpvZENJRFJ2NiwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCYXNlNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQmFzZTY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEJhc2U2NC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYmFzZTY0KFpvZEJhc2U2NCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCYXNlNjRVUkwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQmFzZTY0VVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEJhc2U2NFVSTC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NHVybChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYmFzZTY0dXJsKFpvZEJhc2U2NFVSTCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RFMTY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEUxNjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kRTE2NC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGUxNjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2UxNjQoWm9kRTE2NCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RKV1QgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSldUXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEpXVC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGp3dChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fand0KFpvZEpXVCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RDdXN0b21TdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ3VzdG9tU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEN1c3RvbVN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zvcm1hdChmb3JtYXQsIGZuT3JSZWdleCwgX3BhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIGZvcm1hdCwgZm5PclJlZ2V4LCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBob3N0bmFtZShfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIFwiaG9zdG5hbWVcIiwgY29yZS5yZWdleGVzLmhvc3RuYW1lLCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXgoX3BhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmdGb3JtYXQoWm9kQ3VzdG9tU3RyaW5nRm9ybWF0LCBcImhleFwiLCBjb3JlLnJlZ2V4ZXMuaGV4LCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGFsZywgcGFyYW1zKSB7XG4gICAgY29uc3QgZW5jID0gcGFyYW1zPy5lbmMgPz8gXCJoZXhcIjtcbiAgICBjb25zdCBmb3JtYXQgPSBgJHthbGd9XyR7ZW5jfWA7XG4gICAgY29uc3QgcmVnZXggPSBjb3JlLnJlZ2V4ZXNbZm9ybWF0XTtcbiAgICBpZiAoIXJlZ2V4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZvcm1hdDogJHtmb3JtYXR9YCk7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIGZvcm1hdCwgcmVnZXgsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTnVtYmVyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE51bWJlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTnVtYmVyLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubnVtYmVyUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lmd0ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0KHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmd0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWluID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5sdCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdCh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5sdGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QuaW50ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpbnQocGFyYW1zKSk7XG4gICAgaW5zdC5zYWZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpbnQocGFyYW1zKSk7XG4gICAgaW5zdC5wb3NpdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0KDAsIHBhcmFtcykpO1xuICAgIGluc3Qubm9ubmVnYXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUoMCwgcGFyYW1zKSk7XG4gICAgaW5zdC5uZWdhdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0KDAsIHBhcmFtcykpO1xuICAgIGluc3Qubm9ucG9zaXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUoMCwgcGFyYW1zKSk7XG4gICAgaW5zdC5tdWx0aXBsZU9mID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm11bHRpcGxlT2YodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3Quc3RlcCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tdWx0aXBsZU9mKHZhbHVlLCBwYXJhbXMpKTtcbiAgICAvLyBpbnN0LmZpbml0ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5maW5pdGUocGFyYW1zKSk7XG4gICAgaW5zdC5maW5pdGUgPSAoKSA9PiBpbnN0O1xuICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgaW5zdC5taW5WYWx1ZSA9XG4gICAgICAgIE1hdGgubWF4KGJhZy5taW5pbXVtID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgYmFnLmV4Y2x1c2l2ZU1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSA/PyBudWxsO1xuICAgIGluc3QubWF4VmFsdWUgPVxuICAgICAgICBNYXRoLm1pbihiYWcubWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGJhZy5leGNsdXNpdmVNYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgPz8gbnVsbDtcbiAgICBpbnN0LmlzSW50ID0gKGJhZy5mb3JtYXQgPz8gXCJcIikuaW5jbHVkZXMoXCJpbnRcIikgfHwgTnVtYmVyLmlzU2FmZUludGVnZXIoYmFnLm11bHRpcGxlT2YgPz8gMC41KTtcbiAgICBpbnN0LmlzRmluaXRlID0gdHJ1ZTtcbiAgICBpbnN0LmZvcm1hdCA9IGJhZy5mb3JtYXQgPz8gbnVsbDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbnVtYmVyKFpvZE51bWJlciwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2ROdW1iZXJGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTnVtYmVyRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROdW1iZXJGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZE51bWJlci5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpbnQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ludChab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQzMihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZmxvYXQzMihab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQ2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZmxvYXQ2NChab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW50MzIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ludDMyKFpvZE51bWJlckZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50MzIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VpbnQzMihab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQm9vbGVhbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCb29sZWFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RCb29sZWFuLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYm9vbGVhblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBib29sZWFuKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9ib29sZWFuKFpvZEJvb2xlYW4sIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQmlnSW50ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEJpZ0ludFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQmlnSW50LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYmlnaW50UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lmd0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWluID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndCh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1pbiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubHQgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHQodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubHRlID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0LnBvc2l0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3QoQmlnSW50KDApLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5lZ2F0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHQoQmlnSW50KDApLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbnBvc2l0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKEJpZ0ludCgwKSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ub25uZWdhdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZShCaWdJbnQoMCksIHBhcmFtcykpO1xuICAgIGluc3QubXVsdGlwbGVPZiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tdWx0aXBsZU9mKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgIGluc3QubWluVmFsdWUgPSBiYWcubWluaW11bSA/PyBudWxsO1xuICAgIGluc3QubWF4VmFsdWUgPSBiYWcubWF4aW11bSA/PyBudWxsO1xuICAgIGluc3QuZm9ybWF0ID0gYmFnLmZvcm1hdCA/PyBudWxsO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYmlnaW50KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9iaWdpbnQoWm9kQmlnSW50LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEJpZ0ludEZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCaWdJbnRGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEJpZ0ludEZvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kQmlnSW50LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuLy8gaW50NjRcbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faW50NjQoWm9kQmlnSW50Rm9ybWF0LCBwYXJhbXMpO1xufVxuLy8gdWludDY0XG5leHBvcnQgZnVuY3Rpb24gdWludDY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91aW50NjQoWm9kQmlnSW50Rm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFN5bWJvbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTeW1ib2xcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN5bWJvbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnN5bWJvbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2wocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N5bWJvbChab2RTeW1ib2wsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVW5kZWZpbmVkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVuZGVmaW5lZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVW5kZWZpbmVkLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudW5kZWZpbmVkUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZnVuY3Rpb24gX3VuZGVmaW5lZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdW5kZWZpbmVkKFpvZFVuZGVmaW5lZCwgcGFyYW1zKTtcbn1cbmV4cG9ydCB7IF91bmRlZmluZWQgYXMgdW5kZWZpbmVkIH07XG5leHBvcnQgY29uc3QgWm9kTnVsbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROdWxsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROdWxsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubnVsbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmZ1bmN0aW9uIF9udWxsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9udWxsKFpvZE51bGwsIHBhcmFtcyk7XG59XG5leHBvcnQgeyBfbnVsbCBhcyBudWxsIH07XG5leHBvcnQgY29uc3QgWm9kQW55ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEFueVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQW55LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYW55UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGFueSgpIHtcbiAgICByZXR1cm4gY29yZS5fYW55KFpvZEFueSk7XG59XG5leHBvcnQgY29uc3QgWm9kVW5rbm93biA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RVbmtub3duLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudW5rbm93blByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1bmtub3duKCkge1xuICAgIHJldHVybiBjb3JlLl91bmtub3duKFpvZFVua25vd24pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE5ldmVyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROZXZlci5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm5ldmVyUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG5ldmVyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9uZXZlcihab2ROZXZlciwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RWb2lkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFZvaWRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFZvaWQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy52b2lkUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZnVuY3Rpb24gX3ZvaWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3ZvaWQoWm9kVm9pZCwgcGFyYW1zKTtcbn1cbmV4cG9ydCB7IF92b2lkIGFzIHZvaWQgfTtcbmV4cG9ydCBjb25zdCBab2REYXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZERhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZERhdGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5kYXRlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm1pbiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgY29uc3QgYyA9IGluc3QuX3pvZC5iYWc7XG4gICAgaW5zdC5taW5EYXRlID0gYy5taW5pbXVtID8gbmV3IERhdGUoYy5taW5pbXVtKSA6IG51bGw7XG4gICAgaW5zdC5tYXhEYXRlID0gYy5tYXhpbXVtID8gbmV3IERhdGUoYy5tYXhpbXVtKSA6IG51bGw7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkYXRlKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9kYXRlKFpvZERhdGUsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQXJyYXkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEFycmF5LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYXJyYXlQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuZWxlbWVudCA9IGRlZi5lbGVtZW50O1xuICAgIGluc3QubWluID0gKG1pbkxlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5taW5MZW5ndGgobWluTGVuZ3RoLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbmVtcHR5ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubWluTGVuZ3RoKDEsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKG1heExlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tYXhMZW5ndGgobWF4TGVuZ3RoLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmxlbmd0aCA9IChsZW4sIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubGVuZ3RoKGxlbiwgcGFyYW1zKSk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0LmVsZW1lbnQ7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBhcnJheShlbGVtZW50LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYXJyYXkoWm9kQXJyYXksIGVsZW1lbnQsIHBhcmFtcyk7XG59XG4vLyAua2V5b2ZcbmV4cG9ydCBmdW5jdGlvbiBrZXlvZihzY2hlbWEpIHtcbiAgICBjb25zdCBzaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICByZXR1cm4gX2VudW0oT2JqZWN0LmtleXMoc2hhcGUpKTtcbn1cbmV4cG9ydCBjb25zdCBab2RPYmplY3QgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kT2JqZWN0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RPYmplY3RKSVQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5vYmplY3RQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0LCBcInNoYXBlXCIsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlZi5zaGFwZTtcbiAgICB9KTtcbiAgICBpbnN0LmtleW9mID0gKCkgPT4gX2VudW0oT2JqZWN0LmtleXMoaW5zdC5fem9kLmRlZi5zaGFwZSkpO1xuICAgIGluc3QuY2F0Y2hhbGwgPSAoY2F0Y2hhbGwpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogY2F0Y2hhbGwgfSk7XG4gICAgaW5zdC5wYXNzdGhyb3VnaCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5rbm93bigpIH0pO1xuICAgIGluc3QubG9vc2UgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVua25vd24oKSB9KTtcbiAgICBpbnN0LnN0cmljdCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogbmV2ZXIoKSB9KTtcbiAgICBpbnN0LnN0cmlwID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB1bmRlZmluZWQgfSk7XG4gICAgaW5zdC5leHRlbmQgPSAoaW5jb21pbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKGluc3QsIGluY29taW5nKTtcbiAgICB9O1xuICAgIGluc3Quc2FmZUV4dGVuZCA9IChpbmNvbWluZykgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5zYWZlRXh0ZW5kKGluc3QsIGluY29taW5nKTtcbiAgICB9O1xuICAgIGluc3QubWVyZ2UgPSAob3RoZXIpID0+IHV0aWwubWVyZ2UoaW5zdCwgb3RoZXIpO1xuICAgIGluc3QucGljayA9IChtYXNrKSA9PiB1dGlsLnBpY2soaW5zdCwgbWFzayk7XG4gICAgaW5zdC5vbWl0ID0gKG1hc2spID0+IHV0aWwub21pdChpbnN0LCBtYXNrKTtcbiAgICBpbnN0LnBhcnRpYWwgPSAoLi4uYXJncykgPT4gdXRpbC5wYXJ0aWFsKFpvZE9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcbiAgICBpbnN0LnJlcXVpcmVkID0gKC4uLmFyZ3MpID0+IHV0aWwucmVxdWlyZWQoWm9kTm9uT3B0aW9uYWwsIGluc3QsIGFyZ3NbMF0pO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KHNoYXBlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBkZWYgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHNoYXBlOiBzaGFwZSA/PyB7fSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KGRlZik7XG59XG4vLyBzdHJpY3RPYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBzdHJpY3RPYmplY3Qoc2hhcGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIGNhdGNoYWxsOiBuZXZlcigpLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gbG9vc2VPYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBsb29zZU9iamVjdChzaGFwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgY2F0Y2hhbGw6IHVua25vd24oKSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RVbmlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy51bmlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5vcHRpb25zID0gZGVmLm9wdGlvbnM7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1bmlvbihvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFhvciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RYb3JcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RYb3IuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy51bmlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5vcHRpb25zID0gZGVmLm9wdGlvbnM7XG59KTtcbi8qKiBDcmVhdGVzIGFuIGV4Y2x1c2l2ZSB1bmlvbiAoWE9SKSB3aGVyZSBleGFjdGx5IG9uZSBvcHRpb24gbXVzdCBtYXRjaC5cbiAqIFVubGlrZSByZWd1bGFyIHVuaW9ucyB0aGF0IHN1Y2NlZWQgd2hlbiBhbnkgb3B0aW9uIG1hdGNoZXMsIHhvciBmYWlscyBpZlxuICogemVybyBvciBtb3JlIHRoYW4gb25lIG9wdGlvbiBtYXRjaGVzIHRoZSBpbnB1dC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4b3Iob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RYb3Ioe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkaXNjcmltaW5hdGVkVW5pb24oZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgLy8gY29uc3QgW29wdGlvbnMsIHBhcmFtc10gPSBhcmdzO1xuICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEludGVyc2VjdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEludGVyc2VjdGlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmludGVyc2VjdGlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIHR5cGU6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RUdXBsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RUdXBsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVHVwbGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy50dXBsZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5yZXN0ID0gKHJlc3QpID0+IGluc3QuY2xvbmUoe1xuICAgICAgICAuLi5pbnN0Ll96b2QuZGVmLFxuICAgICAgICByZXN0OiByZXN0LFxuICAgIH0pO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdHVwbGUoaXRlbXMsIF9wYXJhbXNPclJlc3QsIF9wYXJhbXMpIHtcbiAgICBjb25zdCBoYXNSZXN0ID0gX3BhcmFtc09yUmVzdCBpbnN0YW5jZW9mIGNvcmUuJFpvZFR5cGU7XG4gICAgY29uc3QgcGFyYW1zID0gaGFzUmVzdCA/IF9wYXJhbXMgOiBfcGFyYW1zT3JSZXN0O1xuICAgIGNvbnN0IHJlc3QgPSBoYXNSZXN0ID8gX3BhcmFtc09yUmVzdCA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICByZXN0LFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFJlY29yZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RSZWNvcmRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFJlY29yZC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnJlY29yZFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5rZXlUeXBlID0gZGVmLmtleVR5cGU7XG4gICAgaW5zdC52YWx1ZVR5cGUgPSBkZWYudmFsdWVUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIHR5cGUgYWxrc2pmID0gY29yZS5vdXRwdXQ8Y29yZS4kWm9kUmVjb3JkS2V5PjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsUmVjb3JkKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgayA9IGNvcmUuY2xvbmUoa2V5VHlwZSk7XG4gICAgay5fem9kLnZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgIGtleVR5cGU6IGssXG4gICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvb3NlUmVjb3JkKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgbW9kZTogXCJsb29zZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE1hcCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RNYXBcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE1hcC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm1hcFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5rZXlUeXBlID0gZGVmLmtleVR5cGU7XG4gICAgaW5zdC52YWx1ZVR5cGUgPSBkZWYudmFsdWVUeXBlO1xuICAgIGluc3QubWluID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSgxLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21heFNpemUoLi4uYXJncykpO1xuICAgIGluc3Quc2l6ZSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3NpemUoLi4uYXJncykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbWFwKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICBrZXlUeXBlOiBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RTZXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kU2V0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTZXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5zZXRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QubWluID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSgxLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21heFNpemUoLi4uYXJncykpO1xuICAgIGluc3Quc2l6ZSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3NpemUoLi4uYXJncykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc2V0KHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RFbnVtID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEVudW1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEVudW0uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5lbnVtUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LmVudW0gPSBkZWYuZW50cmllcztcbiAgICBpbnN0Lm9wdGlvbnMgPSBPYmplY3QudmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhkZWYuZW50cmllcykpO1xuICAgIGluc3QuZXh0cmFjdCA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBuZXdFbnRyaWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3RW50cmllc1t2YWx1ZV0gPSBkZWYuZW50cmllc1t2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHt2YWx1ZX0gbm90IGZvdW5kIGluIGVudW1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgICAgICBlbnRyaWVzOiBuZXdFbnRyaWVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGluc3QuZXhjbHVkZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5kZWYuZW50cmllcyB9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtleXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdFbnRyaWVzW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3ZhbHVlfSBub3QgZm91bmQgaW4gZW51bWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgICAgIGVudHJpZXM6IG5ld0VudHJpZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIF9lbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IE9iamVjdC5mcm9tRW50cmllcyh2YWx1ZXMubWFwKCh2KSA9PiBbdiwgdl0pKSA6IHZhbHVlcztcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IF9lbnVtIGFzIGVudW0gfTtcbi8qKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBtZXJnZWQgaW50byBgei5lbnVtKClgLiBVc2UgYHouZW51bSgpYCBpbnN0ZWFkLlxuICpcbiAqIGBgYHRzXG4gKiBlbnVtIENvbG9ycyB7IHJlZCwgZ3JlZW4sIGJsdWUgfVxuICogei5lbnVtKENvbG9ycyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hdGl2ZUVudW0oZW50cmllcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RMaXRlcmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RMaXRlcmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubGl0ZXJhbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC52YWx1ZXMgPSBuZXcgU2V0KGRlZi52YWx1ZXMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2NoZW1hIGNvbnRhaW5zIG11bHRpcGxlIHZhbGlkIGxpdGVyYWwgdmFsdWVzLiBVc2UgYC52YWx1ZXNgIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZi52YWx1ZXNbMF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xuICAgICAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICAgICAgdmFsdWVzOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RGaWxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEZpbGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEZpbGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5maWxlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm1pbiA9IChzaXplLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZShzaXplLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9IChzaXplLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWF4U2l6ZShzaXplLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1pbWUgPSAodHlwZXMsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW1lKEFycmF5LmlzQXJyYXkodHlwZXMpID8gdHlwZXMgOiBbdHlwZXNdLCBwYXJhbXMpKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ZpbGUoWm9kRmlsZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RUcmFuc2Zvcm0gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVHJhbnNmb3JtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RUcmFuc2Zvcm0uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy50cmFuc2Zvcm1Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChfY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kRW5jb2RlRXJyb3IoaW5zdC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKGlzc3VlLCBwYXlsb2FkLnZhbHVlLCBkZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvciBab2QgMyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIGNvbnN0IF9pc3N1ZSA9IGlzc3VlO1xuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZmF0YWwpXG4gICAgICAgICAgICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5jb2RlID8/IChfaXNzdWUuY29kZSA9IFwiY3VzdG9tXCIpO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5pbnB1dCA/PyAoX2lzc3VlLmlucHV0ID0gcGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gaW5zdCk7XG4gICAgICAgICAgICAgICAgLy8gX2lzc3VlLmNvbnRpbnVlID8/PSB0cnVlO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbC5pc3N1ZShfaXNzdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICByZXR1cm4gbmV3IFpvZFRyYW5zZm9ybSh7XG4gICAgICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHRyYW5zZm9ybTogZm4sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kT3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMub3B0aW9uYWxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbChpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RFeGFjdE9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEV4YWN0T3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEV4YWN0T3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5vcHRpb25hbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFeGFjdE9wdGlvbmFsKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2ROdWxsYWJsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTnVsbGFibGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5udWxsYWJsZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxhYmxlKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gbnVsbGlzaFxuZXhwb3J0IGZ1bmN0aW9uIG51bGxpc2goaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG9wdGlvbmFsKG51bGxhYmxlKGlubmVyVHlwZSkpO1xufVxuZXhwb3J0IGNvbnN0IFpvZERlZmF1bHQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRGVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRGVmYXVsdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmRlZmF1bHRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG4gICAgaW5zdC5yZW1vdmVEZWZhdWx0ID0gaW5zdC51bndyYXA7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBfZGVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IHV0aWwuc2hhbGxvd0Nsb25lKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kUHJlZmF1bHQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kUHJlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFByZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucHJlZmF1bHRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBwcmVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgWm9kUHJlZmF1bHQoe1xuICAgICAgICB0eXBlOiBcInByZWZhdWx0XCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogdXRpbC5zaGFsbG93Q2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2ROb25PcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROb25PcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTm9uT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5ub25vcHRpb25hbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG5vbm9wdGlvbmFsKGlubmVyVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2ROb25PcHRpb25hbCh7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kU3VjY2VzcyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTdWNjZXNzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTdWNjZXNzLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuc3VjY2Vzc1Byb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHN1Y2Nlc3MoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTdWNjZXNzKHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZENhdGNoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RDYXRjaC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmNhdGNoUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuICAgIGluc3QucmVtb3ZlQ2F0Y2ggPSBpbnN0LnVud3JhcDtcbn0pO1xuZnVuY3Rpb24gX2NhdGNoKGlubmVyVHlwZSwgY2F0Y2hWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICB0eXBlOiBcImNhdGNoXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgICAgICBjYXRjaFZhbHVlOiAodHlwZW9mIGNhdGNoVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhdGNoVmFsdWUgOiAoKSA9PiBjYXRjaFZhbHVlKSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IF9jYXRjaCBhcyBjYXRjaCB9O1xuZXhwb3J0IGNvbnN0IFpvZE5hTiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROYU5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE5hTi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm5hblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBuYW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX25hbihab2ROYU4sIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kUGlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RQaXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RQaXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucGlwZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5pbiA9IGRlZi5pbjtcbiAgICBpbnN0Lm91dCA9IGRlZi5vdXQ7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBwaXBlKGluXywgb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBab2RQaXBlKHtcbiAgICAgICAgdHlwZTogXCJwaXBlXCIsXG4gICAgICAgIGluOiBpbl8sXG4gICAgICAgIG91dDogb3V0LFxuICAgICAgICAvLyAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZENvZGVjID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENvZGVjXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBab2RQaXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RDb2RlYy5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjb2RlYyhpbl8sIG91dCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RDb2RlYyh7XG4gICAgICAgIHR5cGU6IFwicGlwZVwiLFxuICAgICAgICBpbjogaW5fLFxuICAgICAgICBvdXQ6IG91dCxcbiAgICAgICAgdHJhbnNmb3JtOiBwYXJhbXMuZGVjb2RlLFxuICAgICAgICByZXZlcnNlVHJhbnNmb3JtOiBwYXJhbXMuZW5jb2RlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFJlYWRvbmx5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RSZWFkb25seS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnJlYWRvbmx5UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcmVhZG9ubHkoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kVGVtcGxhdGVMaXRlcmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFRlbXBsYXRlTGl0ZXJhbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVGVtcGxhdGVMaXRlcmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudGVtcGxhdGVMaXRlcmFsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlTGl0ZXJhbChwYXJ0cywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RUZW1wbGF0ZUxpdGVyYWwoe1xuICAgICAgICB0eXBlOiBcInRlbXBsYXRlX2xpdGVyYWxcIixcbiAgICAgICAgcGFydHMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTGF6eSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RMYXp5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RMYXp5LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubGF6eVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmdldHRlcigpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbGF6eShnZXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICB0eXBlOiBcImxhenlcIixcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kUHJvbWlzZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RQcm9taXNlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RQcm9taXNlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucHJvbWlzZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2UoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogXCJwcm9taXNlXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEZ1bmN0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEZ1bmN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RGdW5jdGlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmZ1bmN0aW9uUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIF9mdW5jdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBpbnB1dDogQXJyYXkuaXNBcnJheShwYXJhbXM/LmlucHV0KSA/IHR1cGxlKHBhcmFtcz8uaW5wdXQpIDogKHBhcmFtcz8uaW5wdXQgPz8gYXJyYXkodW5rbm93bigpKSksXG4gICAgICAgIG91dHB1dDogcGFyYW1zPy5vdXRwdXQgPz8gdW5rbm93bigpLFxuICAgIH0pO1xufVxuZXhwb3J0IHsgX2Z1bmN0aW9uIGFzIGZ1bmN0aW9uIH07XG5leHBvcnQgY29uc3QgWm9kQ3VzdG9tID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEN1c3RvbVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQ3VzdG9tLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuY3VzdG9tUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuLy8gY3VzdG9tIGNoZWNrc1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrKGZuKSB7XG4gICAgY29uc3QgY2ggPSBuZXcgY29yZS4kWm9kQ2hlY2soe1xuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgLy8gLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbiAgICBjaC5fem9kLmNoZWNrID0gZm47XG4gICAgcmV0dXJuIGNoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbShmbiwgX3BhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jdXN0b20oWm9kQ3VzdG9tLCBmbiA/PyAoKCkgPT4gdHJ1ZSksIF9wYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZmluZShmbiwgX3BhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIGNvcmUuX3JlZmluZShab2RDdXN0b20sIGZuLCBfcGFyYW1zKTtcbn1cbi8vIHN1cGVyUmVmaW5lXG5leHBvcnQgZnVuY3Rpb24gc3VwZXJSZWZpbmUoZm4pIHtcbiAgICByZXR1cm4gY29yZS5fc3VwZXJSZWZpbmUoZm4pO1xufVxuLy8gUmUtZXhwb3J0IGRlc2NyaWJlIGFuZCBtZXRhIGZyb20gY29yZVxuZXhwb3J0IGNvbnN0IGRlc2NyaWJlID0gY29yZS5kZXNjcmliZTtcbmV4cG9ydCBjb25zdCBtZXRhID0gY29yZS5tZXRhO1xuZnVuY3Rpb24gX2luc3RhbmNlb2YoY2xzLCBwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGluc3QgPSBuZXcgWm9kQ3VzdG9tKHtcbiAgICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgICAgIGZuOiAoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscyxcbiAgICAgICAgYWJvcnQ6IHRydWUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmJhZy5DbGFzcyA9IGNscztcbiAgICAvLyBPdmVycmlkZSBjaGVjayB0byBlbWl0IGludmFsaWRfdHlwZSBpbnN0ZWFkIG9mIGN1c3RvbVxuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmICghKHBheWxvYWQudmFsdWUgaW5zdGFuY2VvZiBjbHMpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBjbHMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi4oaW5zdC5fem9kLmRlZi5wYXRoID8/IFtdKV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGluc3Q7XG59XG5leHBvcnQgeyBfaW5zdGFuY2VvZiBhcyBpbnN0YW5jZW9mIH07XG4vLyBzdHJpbmdib29sXG5leHBvcnQgY29uc3Qgc3RyaW5nYm9vbCA9ICguLi5hcmdzKSA9PiBjb3JlLl9zdHJpbmdib29sKHtcbiAgICBDb2RlYzogWm9kQ29kZWMsXG4gICAgQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBTdHJpbmc6IFpvZFN0cmluZyxcbn0sIC4uLmFyZ3MpO1xuZXhwb3J0IGZ1bmN0aW9uIGpzb24ocGFyYW1zKSB7XG4gICAgY29uc3QganNvblNjaGVtYSA9IGxhenkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdW5pb24oW3N0cmluZyhwYXJhbXMpLCBudW1iZXIoKSwgYm9vbGVhbigpLCBfbnVsbCgpLCBhcnJheShqc29uU2NoZW1hKSwgcmVjb3JkKHN0cmluZygpLCBqc29uU2NoZW1hKV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBqc29uU2NoZW1hO1xufVxuLy8gcHJlcHJvY2Vzc1xuLy8gLyoqIEBkZXByZWNhdGVkIFVzZSBgei5waXBlKClgIGFuZCBgei50cmFuc2Zvcm0oKWAgaW5zdGVhZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzKGZuLCBzY2hlbWEpIHtcbiAgICByZXR1cm4gcGlwZSh0cmFuc2Zvcm0oZm4pLCBzY2hlbWEpO1xufVxuIiwgImV4cG9ydCB7IF9sdCBhcyBsdCwgX2x0ZSBhcyBsdGUsIF9ndCBhcyBndCwgX2d0ZSBhcyBndGUsIF9wb3NpdGl2ZSBhcyBwb3NpdGl2ZSwgX25lZ2F0aXZlIGFzIG5lZ2F0aXZlLCBfbm9ucG9zaXRpdmUgYXMgbm9ucG9zaXRpdmUsIF9ub25uZWdhdGl2ZSBhcyBub25uZWdhdGl2ZSwgX211bHRpcGxlT2YgYXMgbXVsdGlwbGVPZiwgX21heFNpemUgYXMgbWF4U2l6ZSwgX21pblNpemUgYXMgbWluU2l6ZSwgX3NpemUgYXMgc2l6ZSwgX21heExlbmd0aCBhcyBtYXhMZW5ndGgsIF9taW5MZW5ndGggYXMgbWluTGVuZ3RoLCBfbGVuZ3RoIGFzIGxlbmd0aCwgX3JlZ2V4IGFzIHJlZ2V4LCBfbG93ZXJjYXNlIGFzIGxvd2VyY2FzZSwgX3VwcGVyY2FzZSBhcyB1cHBlcmNhc2UsIF9pbmNsdWRlcyBhcyBpbmNsdWRlcywgX3N0YXJ0c1dpdGggYXMgc3RhcnRzV2l0aCwgX2VuZHNXaXRoIGFzIGVuZHNXaXRoLCBfcHJvcGVydHkgYXMgcHJvcGVydHksIF9taW1lIGFzIG1pbWUsIF9vdmVyd3JpdGUgYXMgb3ZlcndyaXRlLCBfbm9ybWFsaXplIGFzIG5vcm1hbGl6ZSwgX3RyaW0gYXMgdHJpbSwgX3RvTG93ZXJDYXNlIGFzIHRvTG93ZXJDYXNlLCBfdG9VcHBlckNhc2UgYXMgdG9VcHBlckNhc2UsIF9zbHVnaWZ5IGFzIHNsdWdpZnksIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgKiBhcyBzY2hlbWFzIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmV4cG9ydCBjb25zdCBab2RJU09EYXRlVGltZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJU09EYXRlVGltZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSVNPRGF0ZVRpbWUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGV0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pc29EYXRlVGltZShab2RJU09EYXRlVGltZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJU09EYXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElTT0RhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZElTT0RhdGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lzb0RhdGUoWm9kSVNPRGF0ZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJU09UaW1lID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElTT1RpbWVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZElTT1RpbWUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lzb1RpbWUoWm9kSVNPVGltZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJU09EdXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJU09EdXJhdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSVNPRHVyYXRpb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGR1cmF0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pc29EdXJhdGlvbihab2RJU09EdXJhdGlvbiwgcGFyYW1zKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyAkWm9kRXJyb3IgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi4vY29yZS91dGlsLmpzXCI7XG5jb25zdCBpbml0aWFsaXplciA9IChpbnN0LCBpc3N1ZXMpID0+IHtcbiAgICAkWm9kRXJyb3IuaW5pdChpbnN0LCBpc3N1ZXMpO1xuICAgIGluc3QubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0LCB7XG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGNvcmUuZm9ybWF0RXJyb3IoaW5zdCwgbWFwcGVyKSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBmbGF0dGVuOiB7XG4gICAgICAgICAgICB2YWx1ZTogKG1hcHBlcikgPT4gY29yZS5mbGF0dGVuRXJyb3IoaW5zdCwgbWFwcGVyKSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBhZGRJc3N1ZToge1xuICAgICAgICAgICAgdmFsdWU6IChpc3N1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGluc3QuaXNzdWVzLnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgIGluc3QubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGluc3QuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGFkZElzc3Vlczoge1xuICAgICAgICAgICAgdmFsdWU6IChpc3N1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0Lmlzc3Vlcy5wdXNoKC4uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgaW5zdC5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoaW5zdC5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbXB0eToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiaXNFbXB0eVwiLCB7XG4gICAgLy8gICBnZXQoKSB7XG4gICAgLy8gICAgIHJldHVybiBpbnN0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgLy8gICB9LFxuICAgIC8vIH0pO1xufTtcbmV4cG9ydCBjb25zdCBab2RFcnJvciA9IGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIpO1xuZXhwb3J0IGNvbnN0IFpvZFJlYWxFcnJvciA9IGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIsIHtcbiAgICBQYXJlbnQ6IEVycm9yLFxufSk7XG4vLyAvKiogQGRlcHJlY2F0ZWQgVXNlIGB6LmNvcmUuJFpvZEVycm9yTWFwQ3R4YCBpbnN0ZWFkLiAqL1xuLy8gZXhwb3J0IHR5cGUgRXJyb3JNYXBDdHggPSBjb3JlLiRab2RFcnJvck1hcEN0eDtcbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBab2RSZWFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBjb25zdCBwYXJzZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9wYXJzZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fcGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVQYXJzZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlUGFyc2UoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlUGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlUGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuLy8gQ29kZWMgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZW5jb2RlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX2VuY29kZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9kZWNvZGUoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9lbmNvZGVBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IGRlY29kZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX2RlY29kZUFzeW5jKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZUVuY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRW5jb2RlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZURlY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRGVjb2RlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZUVuY29kZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVFbmNvZGVBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVEZWNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRGVjb2RlQXN5bmMoWm9kUmVhbEVycm9yKTtcbiIsICIvLyBab2QgMyBjb21wYXQgbGF5ZXJcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHJhdyBzdHJpbmcgbGl0ZXJhbCBjb2RlcyBpbnN0ZWFkLCBlLmcuIFwiaW52YWxpZF90eXBlXCIuICovXG5leHBvcnQgY29uc3QgWm9kSXNzdWVDb2RlID0ge1xuICAgIGludmFsaWRfdHlwZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICB0b29fYmlnOiBcInRvb19iaWdcIixcbiAgICB0b29fc21hbGw6IFwidG9vX3NtYWxsXCIsXG4gICAgaW52YWxpZF9mb3JtYXQ6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICBub3RfbXVsdGlwbGVfb2Y6IFwibm90X211bHRpcGxlX29mXCIsXG4gICAgdW5yZWNvZ25pemVkX2tleXM6IFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBpbnZhbGlkX3VuaW9uOiBcImludmFsaWRfdW5pb25cIixcbiAgICBpbnZhbGlkX2tleTogXCJpbnZhbGlkX2tleVwiLFxuICAgIGludmFsaWRfZWxlbWVudDogXCJpbnZhbGlkX2VsZW1lbnRcIixcbiAgICBpbnZhbGlkX3ZhbHVlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICBjdXN0b206IFwiY3VzdG9tXCIsXG59O1xuZXhwb3J0IHsgJGJyYW5kLCBjb25maWcgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBgei5jb25maWcocGFyYW1zKWAgaW5zdGVhZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBjb3JlLmNvbmZpZyh7XG4gICAgICAgIGN1c3RvbUVycm9yOiBtYXAsXG4gICAgfSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGB6LmNvbmZpZygpYCBpbnN0ZWFkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBjb3JlLmNvbmZpZygpLmN1c3RvbUVycm9yO1xufVxuLyoqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UuIFN0dWIgZGVmaW5pdGlvbiwgb25seSBpbmNsdWRlZCBmb3Igem9kLXRvLWpzb24tc2NoZW1hIGNvbXBhdGliaWxpdHkuICovXG5leHBvcnQgdmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG4iLCAiaW1wb3J0IHsgZ2xvYmFsUmVnaXN0cnkgfSBmcm9tIFwiLi4vY29yZS9yZWdpc3RyaWVzLmpzXCI7XG5pbXBvcnQgKiBhcyBfY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgX2lzbyBmcm9tIFwiLi9pc28uanNcIjtcbmltcG9ydCAqIGFzIF9zY2hlbWFzIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbi8vIExvY2FsIHogb2JqZWN0IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCAuLi9pbmRleC5qc1xuY29uc3QgeiA9IHtcbiAgICAuLi5fc2NoZW1hcyxcbiAgICAuLi5fY2hlY2tzLFxuICAgIGlzbzogX2lzbyxcbn07XG4vLyBLZXlzIHRoYXQgYXJlIHJlY29nbml6ZWQgYW5kIGhhbmRsZWQgYnkgdGhlIGNvbnZlcnNpb24gbG9naWNcbmNvbnN0IFJFQ09HTklaRURfS0VZUyA9IG5ldyBTZXQoW1xuICAgIC8vIFNjaGVtYSBpZGVudGlmaWNhdGlvblxuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJHJlZlwiLFxuICAgIFwiJGRlZnNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG4gICAgLy8gQ29yZSBzY2hlbWEga2V5d29yZHNcbiAgICBcIiRpZFwiLFxuICAgIFwiaWRcIixcbiAgICBcIiRjb21tZW50XCIsXG4gICAgXCIkYW5jaG9yXCIsXG4gICAgXCIkdm9jYWJ1bGFyeVwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG4gICAgLy8gVHlwZVxuICAgIFwidHlwZVwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiY29uc3RcIixcbiAgICAvLyBDb21wb3NpdGlvblxuICAgIFwiYW55T2ZcIixcbiAgICBcIm9uZU9mXCIsXG4gICAgXCJhbGxPZlwiLFxuICAgIFwibm90XCIsXG4gICAgLy8gT2JqZWN0XG4gICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgLy8gQXJyYXlcbiAgICBcIml0ZW1zXCIsXG4gICAgXCJwcmVmaXhJdGVtc1wiLFxuICAgIFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgXCJjb250YWluc1wiLFxuICAgIFwibWluQ29udGFpbnNcIixcbiAgICBcIm1heENvbnRhaW5zXCIsXG4gICAgLy8gU3RyaW5nXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heExlbmd0aFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgLy8gTnVtYmVyXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJleGNsdXNpdmVNaW5pbXVtXCIsXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCIsXG4gICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgLy8gQWxyZWFkeSBoYW5kbGVkIG1ldGFkYXRhXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIC8vIENvbnRlbnRcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudFNjaGVtYVwiLFxuICAgIC8vIFVuc3VwcG9ydGVkIChlcnJvci10aHJvd2luZylcbiAgICBcInVuZXZhbHVhdGVkSXRlbXNcIixcbiAgICBcInVuZXZhbHVhdGVkUHJvcGVydGllc1wiLFxuICAgIFwiaWZcIixcbiAgICBcInRoZW5cIixcbiAgICBcImVsc2VcIixcbiAgICBcImRlcGVuZGVudFNjaGVtYXNcIixcbiAgICBcImRlcGVuZGVudFJlcXVpcmVkXCIsXG4gICAgLy8gT3BlbkFQSVxuICAgIFwibnVsbGFibGVcIixcbiAgICBcInJlYWRPbmx5XCIsXG5dKTtcbmZ1bmN0aW9uIGRldGVjdFZlcnNpb24oc2NoZW1hLCBkZWZhdWx0VGFyZ2V0KSB7XG4gICAgY29uc3QgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgIGlmICgkc2NoZW1hID09PSBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZHJhZnQtMjAyMC0xMlwiO1xuICAgIH1cbiAgICBpZiAoJHNjaGVtYSA9PT0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIikge1xuICAgICAgICByZXR1cm4gXCJkcmFmdC03XCI7XG4gICAgfVxuICAgIGlmICgkc2NoZW1hID09PSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiKSB7XG4gICAgICAgIHJldHVybiBcImRyYWZ0LTRcIjtcbiAgICB9XG4gICAgLy8gVXNlIGRlZmF1bHRUYXJnZXQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBkZWZhdWx0IHRvIGRyYWZ0LTIwMjAtMTJcbiAgICByZXR1cm4gZGVmYXVsdFRhcmdldCA/PyBcImRyYWZ0LTIwMjAtMTJcIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWYocmVmLCBjdHgpIHtcbiAgICBpZiAoIXJlZi5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCAkcmVmIGlzIG5vdCBzdXBwb3J0ZWQsIG9ubHkgbG9jYWwgcmVmcyAoIy8uLi4pIGFyZSBhbGxvd2VkXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gcmVmLnNsaWNlKDEpLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgLy8gSGFuZGxlIHJvb3QgcmVmZXJlbmNlIFwiI1wiXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjdHgucm9vdFNjaGVtYTtcbiAgICB9XG4gICAgY29uc3QgZGVmc0tleSA9IGN0eC52ZXJzaW9uID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiJGRlZnNcIiA6IFwiZGVmaW5pdGlvbnNcIjtcbiAgICBpZiAocGF0aFswXSA9PT0gZGVmc0tleSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXRoWzFdO1xuICAgICAgICBpZiAoIWtleSB8fCAhY3R4LmRlZnNba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWZlcmVuY2Ugbm90IGZvdW5kOiAke3JlZn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LmRlZnNba2V5XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZWZlcmVuY2Ugbm90IGZvdW5kOiAke3JlZn1gKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCYXNlU2NoZW1hKHNjaGVtYSwgY3R4KSB7XG4gICAgLy8gSGFuZGxlIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gICAgaWYgKHNjaGVtYS5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHsgbm90OiB7fSB9IHJlcHJlc2VudHMgbmV2ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubm90ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHoubmV2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaXMgbm90IHN1cHBvcnRlZCBpbiBab2QgKGV4Y2VwdCB7IG5vdDoge30gfSBmb3IgbmV2ZXIpXCIpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLnVuZXZhbHVhdGVkSXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV2YWx1YXRlZEl0ZW1zIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuaWYgIT09IHVuZGVmaW5lZCB8fCBzY2hlbWEudGhlbiAhPT0gdW5kZWZpbmVkIHx8IHNjaGVtYS5lbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZGl0aW9uYWwgc2NoZW1hcyAoaWYvdGhlbi9lbHNlKSBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5kZXBlbmRlbnRTY2hlbWFzICE9PSB1bmRlZmluZWQgfHwgc2NoZW1hLmRlcGVuZGVudFJlcXVpcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVwZW5kZW50U2NoZW1hcyBhbmQgZGVwZW5kZW50UmVxdWlyZWQgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIC8vIEhhbmRsZSAkcmVmXG4gICAgaWYgKHNjaGVtYS4kcmVmKSB7XG4gICAgICAgIGNvbnN0IHJlZlBhdGggPSBzY2hlbWEuJHJlZjtcbiAgICAgICAgaWYgKGN0eC5yZWZzLmhhcyhyZWZQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5yZWZzLmdldChyZWZQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LnByb2Nlc3NpbmcuaGFzKHJlZlBhdGgpKSB7XG4gICAgICAgICAgICAvLyBDaXJjdWxhciByZWZlcmVuY2UgLSB1c2UgbGF6eVxuICAgICAgICAgICAgcmV0dXJuIHoubGF6eSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdHgucmVmcy5oYXMocmVmUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjdWxhciByZWZlcmVuY2Ugbm90IHJlc29sdmVkOiAke3JlZlBhdGh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucmVmcy5nZXQocmVmUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJvY2Vzc2luZy5hZGQocmVmUGF0aCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVJlZihyZWZQYXRoLCBjdHgpO1xuICAgICAgICBjb25zdCB6b2RTY2hlbWEgPSBjb252ZXJ0U2NoZW1hKHJlc29sdmVkLCBjdHgpO1xuICAgICAgICBjdHgucmVmcy5zZXQocmVmUGF0aCwgem9kU2NoZW1hKTtcbiAgICAgICAgY3R4LnByb2Nlc3NpbmcuZGVsZXRlKHJlZlBhdGgpO1xuICAgICAgICByZXR1cm4gem9kU2NoZW1hO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgZW51bVxuICAgIGlmIChzY2hlbWEuZW51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSBzY2hlbWEuZW51bTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBPcGVuQVBJIDMuMCBudWxsIHJlcHJlc2VudGF0aW9uIHsgdHlwZTogXCJzdHJpbmdcIiwgbnVsbGFibGU6IHRydWUsIGVudW06IFtudWxsXSB9XG4gICAgICAgIGlmIChjdHgudmVyc2lvbiA9PT0gXCJvcGVuYXBpLTMuMFwiICYmXG4gICAgICAgICAgICBzY2hlbWEubnVsbGFibGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGVudW1WYWx1ZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBlbnVtVmFsdWVzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gei5udWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudW1WYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5uZXZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnVtVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHoubGl0ZXJhbChlbnVtVmFsdWVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBhbGwgdmFsdWVzIGFyZSBzdHJpbmdzXG4gICAgICAgIGlmIChlbnVtVmFsdWVzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB6LmVudW0oZW51bVZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWl4ZWQgdHlwZXMgLSB1c2UgdW5pb24gb2YgbGl0ZXJhbHNcbiAgICAgICAgY29uc3QgbGl0ZXJhbFNjaGVtYXMgPSBlbnVtVmFsdWVzLm1hcCgodikgPT4gei5saXRlcmFsKHYpKTtcbiAgICAgICAgaWYgKGxpdGVyYWxTY2hlbWFzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsU2NoZW1hc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei51bmlvbihbbGl0ZXJhbFNjaGVtYXNbMF0sIGxpdGVyYWxTY2hlbWFzWzFdLCAuLi5saXRlcmFsU2NoZW1hcy5zbGljZSgyKV0pO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgY29uc3RcbiAgICBpZiAoc2NoZW1hLmNvbnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHoubGl0ZXJhbChzY2hlbWEuY29uc3QpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgdHlwZVxuICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAvLyBFeHBhbmQgdHlwZSBhcnJheSBpbnRvIGFueU9mIHVuaW9uXG4gICAgICAgIGNvbnN0IHR5cGVTY2hlbWFzID0gdHlwZS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVTY2hlbWEgPSB7IC4uLnNjaGVtYSwgdHlwZTogdCB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlU2NoZW1hKHR5cGVTY2hlbWEsIGN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZVNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5uZXZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlU2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlU2NoZW1hc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei51bmlvbih0eXBlU2NoZW1hcyk7XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgICAvLyBObyB0eXBlIHNwZWNpZmllZCAtIGVtcHR5IHNjaGVtYSAoYW55KVxuICAgICAgICByZXR1cm4gei5hbnkoKTtcbiAgICB9XG4gICAgbGV0IHpvZFNjaGVtYTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nU2NoZW1hID0gei5zdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGZvcm1hdCB1c2luZyAuY2hlY2soKSB3aXRoIFpvZCBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IHNjaGVtYS5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgLy8gTWFwIGNvbW1vbiBmb3JtYXRzIHRvIFpvZCBjaGVjayBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouZW1haWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ1cmlcIiB8fCBmb3JtYXQgPT09IFwidXJpLXJlZmVyZW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LnVybCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInV1aWRcIiB8fCBmb3JtYXQgPT09IFwiZ3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LnV1aWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJkYXRlLXRpbWVcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pc28uZGF0ZXRpbWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXNvLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXNvLnRpbWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lmlzby5kdXJhdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImlwdjRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pcHY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiaXB2NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmlwdjYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJtYWNcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5tYWMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouY2lkcnY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiY2lkci12NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmNpZHJ2NigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmJhc2U2NCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmJhc2U2NHVybCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImUxNjRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5lMTY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiand0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouand0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5lbW9qaSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lm5hbm9pZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5jdWlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5jdWlkMigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei51bGlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwieGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoueGlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwia3N1aWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5rc3VpZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90ZToganNvbi1zdHJpbmcgZm9ybWF0IGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IFpvZFxuICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBmb3JtYXRzIGFyZSBpZ25vcmVkIC0ga2VlcCBhcyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5MZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEubWluKHNjaGVtYS5taW5MZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4TGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLm1heChzY2hlbWEubWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEucGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIEpTT04gU2NoZW1hIHBhdHRlcm5zIGFyZSBub3QgaW1wbGljaXRseSBhbmNob3JlZCAobWF0Y2ggYW55d2hlcmUgaW4gc3RyaW5nKVxuICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5yZWdleChuZXcgUmVnRXhwKHNjaGVtYS5wYXR0ZXJuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSBzdHJpbmdTY2hlbWE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6IHtcbiAgICAgICAgICAgIGxldCBudW1iZXJTY2hlbWEgPSB0eXBlID09PSBcImludGVnZXJcIiA/IHoubnVtYmVyKCkuaW50KCkgOiB6Lm51bWJlcigpO1xuICAgICAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubWluKHNjaGVtYS5taW5pbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubWF4KHNjaGVtYS5tYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEuZ3Qoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09IHRydWUgJiYgdHlwZW9mIHNjaGVtYS5taW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLmd0KHNjaGVtYS5taW5pbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubHQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUgJiYgdHlwZW9mIHNjaGVtYS5tYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLmx0KHNjaGVtYS5tYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm11bHRpcGxlT2YgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubXVsdGlwbGVPZihzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSBudW1iZXJTY2hlbWE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiB7XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSB6LmJvb2xlYW4oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJudWxsXCI6IHtcbiAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoubnVsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRTZXQgPSBuZXcgU2V0KHNjaGVtYS5yZXF1aXJlZCB8fCBbXSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHByb3BlcnRpZXMgLSBtYXJrIG9wdGlvbmFsIG9uZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wWm9kU2NoZW1hID0gY29udmVydFNjaGVtYShwcm9wU2NoZW1hLCBjdHgpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBpbiByZXF1aXJlZCBhcnJheSwgbWFrZSBpdCBvcHRpb25hbFxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSByZXF1aXJlZFNldC5oYXMoa2V5KSA/IHByb3Bab2RTY2hlbWEgOiBwcm9wWm9kU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcHJvcGVydHlOYW1lc1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U2NoZW1hID0gY29udmVydFNjaGVtYShzY2hlbWEucHJvcGVydHlOYW1lcywgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVNjaGVtYSA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFNjaGVtYShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiB6LmFueSgpO1xuICAgICAgICAgICAgICAgIC8vIENhc2UgQTogTm8gcHJvcGVydGllcyAocHVyZSByZWNvcmQpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNoYXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei5yZWNvcmQoa2V5U2NoZW1hLCB2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDYXNlIEI6IFdpdGggcHJvcGVydGllcyAoaW50ZXJzZWN0aW9uIG9mIG9iamVjdCBhbmQgbG9vc2VSZWNvcmQpXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2NoZW1hID0gei5vYmplY3Qoc2hhcGUpLnBhc3N0aHJvdWdoKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkU2NoZW1hID0gei5sb29zZVJlY29yZChrZXlTY2hlbWEsIHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LmludGVyc2VjdGlvbihvYmplY3RTY2hlbWEsIHJlY29yZFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcGF0dGVyblByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXR0ZXJuUHJvcGVydGllczoga2V5cyBtYXRjaGluZyBwYXR0ZXJuIG11c3Qgc2F0aXNmeSBjb3JyZXNwb25kaW5nIHNjaGVtYVxuICAgICAgICAgICAgICAgIC8vIFVzZSBsb29zZSByZWNvcmRzIHNvIG5vbi1tYXRjaGluZyBrZXlzIHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Qcm9wcyA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuS2V5cyA9IE9iamVjdC5rZXlzKHBhdHRlcm5Qcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9vc2VSZWNvcmRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5LZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5WYWx1ZSA9IGNvbnZlcnRTY2hlbWEocGF0dGVyblByb3BzW3BhdHRlcm5dLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTY2hlbWEgPSB6LnN0cmluZygpLnJlZ2V4KG5ldyBSZWdFeHAocGF0dGVybikpO1xuICAgICAgICAgICAgICAgICAgICBsb29zZVJlY29yZHMucHVzaCh6Lmxvb3NlUmVjb3JkKGtleVNjaGVtYSwgcGF0dGVyblZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGludGVyc2VjdGlvbjogb2JqZWN0IHNjaGVtYSArIGFsbCBwYXR0ZXJuIHByb3BlcnR5IHJlY29yZHNcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFzVG9JbnRlcnNlY3QgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2hhcGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHBhc3N0aHJvdWdoIHNvIHBhdHRlcm5Qcm9wZXJ0aWVzIGNhbiB2YWxpZGF0ZSBhZGRpdGlvbmFsIGtleXNcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hc1RvSW50ZXJzZWN0LnB1c2goei5vYmplY3Qoc2hhcGUpLnBhc3N0aHJvdWdoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY2hlbWFzVG9JbnRlcnNlY3QucHVzaCguLi5sb29zZVJlY29yZHMpO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFzVG9JbnRlcnNlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWFzVG9JbnRlcnNlY3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHNjaGVtYXNUb0ludGVyc2VjdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoYWluIGludGVyc2VjdGlvbnM6IChBICYgQikgJiBDICYgRCAuLi5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHouaW50ZXJzZWN0aW9uKHNjaGVtYXNUb0ludGVyc2VjdFswXSwgc2NoZW1hc1RvSW50ZXJzZWN0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBzY2hlbWFzVG9JbnRlcnNlY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHouaW50ZXJzZWN0aW9uKHJlc3VsdCwgc2NoZW1hc1RvSW50ZXJzZWN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBJbiBKU09OIFNjaGVtYSwgYWRkaXRpb25hbFByb3BlcnRpZXMgZGVmYXVsdHMgdG8gdHJ1ZSAoYWxsb3cgYW55IGV4dHJhIHByb3BlcnRpZXMpXG4gICAgICAgICAgICAvLyBJbiBab2QsIG9iamVjdHMgc3RyaXAgdW5rbm93biBrZXlzIGJ5IGRlZmF1bHQsIHNvIHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXhwbGljaXRseVxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2NoZW1hID0gei5vYmplY3Qoc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpY3QgbW9kZSAtIG5vIGV4dHJhIHByb3BlcnRpZXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IG9iamVjdFNjaGVtYS5zdHJpY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYSBwcm9wZXJ0aWVzIG11c3QgbWF0Y2ggdGhlIHNwZWNpZmllZCBzY2hlbWFcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBvYmplY3RTY2hlbWEuY2F0Y2hhbGwoY29udmVydFNjaGVtYShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgdHJ1ZSBvciB1bmRlZmluZWQgLSBhbGxvdyBhbnkgZXh0cmEgcHJvcGVydGllcyAocGFzc3Rocm91Z2gpXG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gb2JqZWN0U2NoZW1hLnBhc3N0aHJvdWdoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYXJyYXlcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogdW5pcXVlSXRlbXMgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gVE9ETzogY29udGFpbnMvbWluQ29udGFpbnMvbWF4Q29udGFpbnMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB0dXBsZSAocHJlZml4SXRlbXMgb3IgaXRlbXMgYXMgYXJyYXkpXG4gICAgICAgICAgICBjb25zdCBwcmVmaXhJdGVtcyA9IHNjaGVtYS5wcmVmaXhJdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgaWYgKHByZWZpeEl0ZW1zICYmIEFycmF5LmlzQXJyYXkocHJlZml4SXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGUgd2l0aCBwcmVmaXhJdGVtcyAoZHJhZnQtMjAyMC0xMilcbiAgICAgICAgICAgICAgICBjb25zdCB0dXBsZUl0ZW1zID0gcHJlZml4SXRlbXMubWFwKChpdGVtKSA9PiBjb252ZXJ0U2NoZW1hKGl0ZW0sIGN0eCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBpdGVtcyAmJiB0eXBlb2YgaXRlbXMgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFNjaGVtYShpdGVtcywgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpLnJlc3QocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBtaW5JdGVtcy9tYXhJdGVtcyBjb25zdHJhaW50cyB0byB0dXBsZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5JdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuY2hlY2soei5taW5MZW5ndGgoc2NoZW1hLm1pbkl0ZW1zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heEl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5jaGVjayh6Lm1heExlbmd0aChzY2hlbWEubWF4SXRlbXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlIHdpdGggaXRlbXMgYXJyYXkgKGRyYWZ0LTcpXG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGVJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gY29udmVydFNjaGVtYShpdGVtLCBjdHgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyAmJiB0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDsgLy8gYWRkaXRpb25hbEl0ZW1zOiBmYWxzZSBtZWFucyBubyByZXN0LCBoYW5kbGVkIGJ5IGRlZmF1bHQgdHVwbGUgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpLnJlc3QocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBtaW5JdGVtcy9tYXhJdGVtcyBjb25zdHJhaW50cyB0byB0dXBsZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5JdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuY2hlY2soei5taW5MZW5ndGgoc2NoZW1hLm1pbkl0ZW1zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heEl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5jaGVjayh6Lm1heExlbmd0aChzY2hlbWEubWF4SXRlbXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb252ZXJ0U2NoZW1hKGl0ZW1zLCBjdHgpO1xuICAgICAgICAgICAgICAgIGxldCBhcnJheVNjaGVtYSA9IHouYXJyYXkoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5JdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVNjaGVtYSA9IGFycmF5U2NoZW1hLm1pbihzY2hlbWEubWluSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhJdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVNjaGVtYSA9IGFycmF5U2NoZW1hLm1heChzY2hlbWEubWF4SXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBhcnJheVNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGl0ZW1zIHNwZWNpZmllZCAtIGFycmF5IG9mIGFueVxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHouYXJyYXkoei5hbnkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIC8vIEFwcGx5IG1ldGFkYXRhXG4gICAgaWYgKHNjaGVtYS5kZXNjcmlwdGlvbikge1xuICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuZGVzY3JpYmUoc2NoZW1hLmRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmRlZmF1bHQoc2NoZW1hLmRlZmF1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gem9kU2NoZW1hO1xufVxuZnVuY3Rpb24gY29udmVydFNjaGVtYShzY2hlbWEsIGN0eCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hID8gei5hbnkoKSA6IHoubmV2ZXIoKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBiYXNlIHNjaGVtYSBmaXJzdCAoaWdub3JpbmcgY29tcG9zaXRpb24ga2V5d29yZHMpXG4gICAgbGV0IGJhc2VTY2hlbWEgPSBjb252ZXJ0QmFzZVNjaGVtYShzY2hlbWEsIGN0eCk7XG4gICAgY29uc3QgaGFzRXhwbGljaXRUeXBlID0gc2NoZW1hLnR5cGUgfHwgc2NoZW1hLmVudW0gIT09IHVuZGVmaW5lZCB8fCBzY2hlbWEuY29uc3QgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBQcm9jZXNzIGNvbXBvc2l0aW9uIGtleXdvcmRzIExBU1QgKHRoZXkgY2FuIGFwcGVhciB0b2dldGhlcilcbiAgICAvLyBIYW5kbGUgYW55T2YgLSB3cmFwIGJhc2Ugc2NoZW1hIHdpdGggdW5pb25cbiAgICBpZiAoc2NoZW1hLmFueU9mICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc2NoZW1hLmFueU9mLm1hcCgocykgPT4gY29udmVydFNjaGVtYShzLCBjdHgpKTtcbiAgICAgICAgY29uc3QgYW55T2ZVbmlvbiA9IHoudW5pb24ob3B0aW9ucyk7XG4gICAgICAgIGJhc2VTY2hlbWEgPSBoYXNFeHBsaWNpdFR5cGUgPyB6LmludGVyc2VjdGlvbihiYXNlU2NoZW1hLCBhbnlPZlVuaW9uKSA6IGFueU9mVW5pb247XG4gICAgfVxuICAgIC8vIEhhbmRsZSBvbmVPZiAtIGV4Y2x1c2l2ZSB1bmlvbiAoZXhhY3RseSBvbmUgbXVzdCBtYXRjaClcbiAgICBpZiAoc2NoZW1hLm9uZU9mICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc2NoZW1hLm9uZU9mLm1hcCgocykgPT4gY29udmVydFNjaGVtYShzLCBjdHgpKTtcbiAgICAgICAgY29uc3Qgb25lT2ZVbmlvbiA9IHoueG9yKG9wdGlvbnMpO1xuICAgICAgICBiYXNlU2NoZW1hID0gaGFzRXhwbGljaXRUeXBlID8gei5pbnRlcnNlY3Rpb24oYmFzZVNjaGVtYSwgb25lT2ZVbmlvbikgOiBvbmVPZlVuaW9uO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgYWxsT2YgLSB3cmFwIGJhc2Ugc2NoZW1hIHdpdGggaW50ZXJzZWN0aW9uXG4gICAgaWYgKHNjaGVtYS5hbGxPZiAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5hbGxPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGJhc2VTY2hlbWEgPSBoYXNFeHBsaWNpdFR5cGUgPyBiYXNlU2NoZW1hIDogei5hbnkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBoYXNFeHBsaWNpdFR5cGUgPyBiYXNlU2NoZW1hIDogY29udmVydFNjaGVtYShzY2hlbWEuYWxsT2ZbMF0sIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydElkeCA9IGhhc0V4cGxpY2l0VHlwZSA/IDAgOiAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWR4OyBpIDwgc2NoZW1hLmFsbE9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gei5pbnRlcnNlY3Rpb24ocmVzdWx0LCBjb252ZXJ0U2NoZW1hKHNjaGVtYS5hbGxPZltpXSwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlU2NoZW1hID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSBudWxsYWJsZSAoT3BlbkFQSSAzLjApXG4gICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSAmJiBjdHgudmVyc2lvbiA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIGJhc2VTY2hlbWEgPSB6Lm51bGxhYmxlKGJhc2VTY2hlbWEpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVhZE9ubHlcbiAgICBpZiAoc2NoZW1hLnJlYWRPbmx5ID09PSB0cnVlKSB7XG4gICAgICAgIGJhc2VTY2hlbWEgPSB6LnJlYWRvbmx5KGJhc2VTY2hlbWEpO1xuICAgIH1cbiAgICAvLyBDb2xsZWN0IG1ldGFkYXRhOiBjb3JlIHNjaGVtYSBrZXl3b3JkcyBhbmQgdW5yZWNvZ25pemVkIGtleXNcbiAgICBjb25zdCBleHRyYU1ldGEgPSB7fTtcbiAgICAvLyBDb3JlIHNjaGVtYSBrZXl3b3JkcyB0aGF0IHNob3VsZCBiZSBjYXB0dXJlZCBhcyBtZXRhZGF0YVxuICAgIGNvbnN0IGNvcmVNZXRhZGF0YUtleXMgPSBbXCIkaWRcIiwgXCJpZFwiLCBcIiRjb21tZW50XCIsIFwiJGFuY2hvclwiLCBcIiR2b2NhYnVsYXJ5XCIsIFwiJGR5bmFtaWNSZWZcIiwgXCIkZHluYW1pY0FuY2hvclwiXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBjb3JlTWV0YWRhdGFLZXlzKSB7XG4gICAgICAgIGlmIChrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBleHRyYU1ldGFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbnRlbnQga2V5d29yZHMgLSBzdG9yZSBhcyBtZXRhZGF0YVxuICAgIGNvbnN0IGNvbnRlbnRNZXRhZGF0YUtleXMgPSBbXCJjb250ZW50RW5jb2RpbmdcIiwgXCJjb250ZW50TWVkaWFUeXBlXCIsIFwiY29udGVudFNjaGVtYVwiXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBjb250ZW50TWV0YWRhdGFLZXlzKSB7XG4gICAgICAgIGlmIChrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBleHRyYU1ldGFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVucmVjb2duaXplZCBrZXlzIChjdXN0b20gbWV0YWRhdGEpXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hKSkge1xuICAgICAgICBpZiAoIVJFQ09HTklaRURfS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZXh0cmFNZXRhW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoZXh0cmFNZXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGN0eC5yZWdpc3RyeS5hZGQoYmFzZVNjaGVtYSwgZXh0cmFNZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VTY2hlbWE7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSlNPTiBTY2hlbWEgdG8gYSBab2Qgc2NoZW1hLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjb25zaWRlcmVkIHNlbWktZXhwZXJpbWVudGFsLiBJdCdzIGJlaGF2aW9yIGlzIGxpYWJsZSB0byBjaGFuZ2UuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUpTT05TY2hlbWEoc2NoZW1hLCBwYXJhbXMpIHtcbiAgICAvLyBIYW5kbGUgYm9vbGVhbiBzY2hlbWFzXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEgPyB6LmFueSgpIDogei5uZXZlcigpO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gZGV0ZWN0VmVyc2lvbihzY2hlbWEsIHBhcmFtcz8uZGVmYXVsdFRhcmdldCk7XG4gICAgY29uc3QgZGVmcyA9IChzY2hlbWEuJGRlZnMgfHwgc2NoZW1hLmRlZmluaXRpb25zIHx8IHt9KTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGRlZnMsXG4gICAgICAgIHJlZnM6IG5ldyBNYXAoKSxcbiAgICAgICAgcHJvY2Vzc2luZzogbmV3IFNldCgpLFxuICAgICAgICByb290U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHJlZ2lzdHJ5OiBwYXJhbXM/LnJlZ2lzdHJ5ID8/IGdsb2JhbFJlZ2lzdHJ5LFxuICAgIH07XG4gICAgcmV0dXJuIGNvbnZlcnRTY2hlbWEoc2NoZW1hLCBjdHgpO1xufVxuIiwgImV4cG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29tcGF0LmpzXCI7XG4vLyB6b2Qtc3BlY2lmaWVkXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IGVuIGZyb20gXCIuLi9sb2NhbGVzL2VuLmpzXCI7XG5jb25maWcoZW4oKSk7XG5leHBvcnQgeyBnbG9iYWxSZWdpc3RyeSwgcmVnaXN0cnksIGNvbmZpZywgJG91dHB1dCwgJGlucHV0LCAkYnJhbmQsIGNsb25lLCByZWdleGVzLCB0cmVlaWZ5RXJyb3IsIHByZXR0aWZ5RXJyb3IsIGZvcm1hdEVycm9yLCBmbGF0dGVuRXJyb3IsIFRpbWVQcmVjaXNpb24sIHV0aWwsIE5FVkVSLCB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5leHBvcnQgeyB0b0pTT05TY2hlbWEgfSBmcm9tIFwiLi4vY29yZS9qc29uLXNjaGVtYS1wcm9jZXNzb3JzLmpzXCI7XG5leHBvcnQgeyBmcm9tSlNPTlNjaGVtYSB9IGZyb20gXCIuL2Zyb20tanNvbi1zY2hlbWEuanNcIjtcbmV4cG9ydCAqIGFzIGxvY2FsZXMgZnJvbSBcIi4uL2xvY2FsZXMvaW5kZXguanNcIjtcbi8vIGlzb1xuLy8gbXVzdCBiZSBleHBvcnRlZCBmcm9tIHRvcC1sZXZlbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2lzc3Vlcy80NDkxXG5leHBvcnQgeyBab2RJU09EYXRlVGltZSwgWm9kSVNPRGF0ZSwgWm9kSVNPVGltZSwgWm9kSVNPRHVyYXRpb24gfSBmcm9tIFwiLi9pc28uanNcIjtcbmV4cG9ydCAqIGFzIGlzbyBmcm9tIFwiLi9pc28uanNcIjtcbmV4cG9ydCAqIGFzIGNvZXJjZSBmcm9tIFwiLi9jb2VyY2UuanNcIjtcbiIsIG51bGwsIG51bGwsICJleHBvcnQgY29uc3QgaWdub3JlT3ZlcnJpZGUgPSBTeW1ib2woXCJMZXQgem9kVG9Kc29uU2NoZW1hIGRlY2lkZSBvbiB3aGljaCBwYXJzZXIgdG8gdXNlXCIpO1xuZXhwb3J0IGNvbnN0IGpzb25EZXNjcmlwdGlvbiA9IChqc29uU2NoZW1hLCBkZWYpID0+IHtcbiAgICBpZiAoZGVmLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgLi4uSlNPTi5wYXJzZShkZWYuZGVzY3JpcHRpb24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb25TY2hlbWE7XG59O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAkcmVmU3RyYXRlZ3k6IFwicm9vdFwiLFxuICAgIGJhc2VQYXRoOiBbXCIjXCJdLFxuICAgIGVmZmVjdFN0cmF0ZWd5OiBcImlucHV0XCIsXG4gICAgcGlwZVN0cmF0ZWd5OiBcImFsbFwiLFxuICAgIGRhdGVTdHJhdGVneTogXCJmb3JtYXQ6ZGF0ZS10aW1lXCIsXG4gICAgbWFwU3RyYXRlZ3k6IFwiZW50cmllc1wiLFxuICAgIHJlbW92ZUFkZGl0aW9uYWxTdHJhdGVneTogXCJwYXNzdGhyb3VnaFwiLFxuICAgIGFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgICByZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICBkZWZpbml0aW9uUGF0aDogXCJkZWZpbml0aW9uc1wiLFxuICAgIHRhcmdldDogXCJqc29uU2NoZW1hN1wiLFxuICAgIHN0cmljdFVuaW9uczogZmFsc2UsXG4gICAgZGVmaW5pdGlvbnM6IHt9LFxuICAgIGVycm9yTWVzc2FnZXM6IGZhbHNlLFxuICAgIG1hcmtkb3duRGVzY3JpcHRpb246IGZhbHNlLFxuICAgIHBhdHRlcm5TdHJhdGVneTogXCJlc2NhcGVcIixcbiAgICBhcHBseVJlZ2V4RmxhZ3M6IGZhbHNlLFxuICAgIGVtYWlsU3RyYXRlZ3k6IFwiZm9ybWF0OmVtYWlsXCIsXG4gICAgYmFzZTY0U3RyYXRlZ3k6IFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiLFxuICAgIG5hbWVTdHJhdGVneTogXCJyZWZcIixcbiAgICBvcGVuQWlBbnlUeXBlTmFtZTogXCJPcGVuQWlBbnlUeXBlXCJcbn07XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdE9wdGlvbnMgPSAob3B0aW9ucykgPT4gKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiXG4gICAgPyB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBuYW1lOiBvcHRpb25zLFxuICAgIH1cbiAgICA6IHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4iLCAiaW1wb3J0IHsgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyB9IGZyb20gXCIuLi9lcnJvck1lc3NhZ2VzLmpzXCI7XG5sZXQgZW1vamlSZWdleCA9IHVuZGVmaW5lZDtcbi8qKlxuICogR2VuZXJhdGVkIGZyb20gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm91bmQgaGVyZSBhcyBvZiAyMDI0LTA1LTIyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2Jsb2IvbWFzdGVyL3NyYy90eXBlcy50cy5cbiAqXG4gKiBFeHByZXNzaW9ucyB3aXRoIC9pIGZsYWcgaGF2ZSBiZWVuIGNoYW5nZWQgYWNjb3JkaW5nbHkuXG4gKi9cbmV4cG9ydCBjb25zdCB6b2RQYXR0ZXJucyA9IHtcbiAgICAvKipcbiAgICAgKiBgY2Agd2FzIGNoYW5nZWQgdG8gYFtjQ11gIHRvIHJlcGxpY2F0ZSAvaSBmbGFnXG4gICAgICovXG4gICAgY3VpZDogL15bY0NdW15cXHMtXXs4LH0kLyxcbiAgICBjdWlkMjogL15bMC05YS16XSskLyxcbiAgICB1bGlkOiAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kLyxcbiAgICAvKipcbiAgICAgKiBgYS16YCB3YXMgYWRkZWQgdG8gcmVwbGljYXRlIC9pIGZsYWdcbiAgICAgKi9cbiAgICBlbWFpbDogL14oPyFcXC4pKD8hLipcXC5cXC4pKFthLXpBLVowLTlfJytcXC1cXC5dKilbYS16QS1aMC05XystXUAoW2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpcXC4pK1thLXpBLVpdezIsfSQvLFxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGVkIGEgdmFsaWQgVW5pY29kZSBSZWdFeHBcbiAgICAgKlxuICAgICAqIExhemlseSBpbnN0YW50aWF0ZSBzaW5jZSB0aGlzIHR5cGUgb2YgcmVnZXggaXNuJ3Qgc3VwcG9ydGVkXG4gICAgICogaW4gYWxsIGVudnMgKGUuZy4gUmVhY3QgTmF0aXZlKS5cbiAgICAgKlxuICAgICAqIFNlZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvaXNzdWVzLzI0MzNcbiAgICAgKiBGaXggaW4gWm9kOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9jb21taXQvOTM0MGZkNTFlNDg1NzZhNzVhZGM5MTliZmY2NWRiYzRhNWQ0Yzk5YlxuICAgICAqL1xuICAgIGVtb2ppOiAoKSA9PiB7XG4gICAgICAgIGlmIChlbW9qaVJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVtb2ppUmVnZXggPSBSZWdFeHAoXCJeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJFwiLCBcInVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtb2ppUmVnZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVbnVzZWRcbiAgICAgKi9cbiAgICB1dWlkOiAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvLFxuICAgIC8qKlxuICAgICAqIFVudXNlZFxuICAgICAqL1xuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC8sXG4gICAgaXB2NENpZHI6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvLFxuICAgIC8qKlxuICAgICAqIFVudXNlZFxuICAgICAqL1xuICAgIGlwdjY6IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvLFxuICAgIGlwdjZDaWRyOiAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvLFxuICAgIGJhc2U2NDogL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvLFxuICAgIGJhc2U2NHVybDogL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvLFxuICAgIG5hbm9pZDogL15bYS16QS1aMC05Xy1dezIxfSQvLFxuICAgIGp3dDogL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLyxcbn07XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdHJpbmdEZWYoZGVmLCByZWZzKSB7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIH07XG4gICAgaWYgKGRlZi5jaGVja3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiBkZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoZWNrLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbkxlbmd0aFwiLCB0eXBlb2YgcmVzLm1pbkxlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1heChyZXMubWluTGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heExlbmd0aFwiLCB0eXBlb2YgcmVzLm1heExlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1pbihyZXMubWF4TGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW1haWxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWZzLmVtYWlsU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6ZW1haWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1hdDppZG4tZW1haWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlkbi1lbWFpbFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5lbWFpbCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVybFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInVyaVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInV1aWRcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ1dWlkXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVnZXhcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIGNoZWNrLnJlZ2V4LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImN1aWRcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY3VpZDJcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0c1dpdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIFJlZ0V4cChgXiR7ZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpfWApLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZHNXaXRoXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoYCR7ZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpfSRgKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImRhdGUtdGltZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkYXRlXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidGltZVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInRpbWVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImR1cmF0aW9uXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbkxlbmd0aFwiLCB0eXBlb2YgcmVzLm1pbkxlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1heChyZXMubWluTGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhMZW5ndGhcIiwgdHlwZW9mIHJlcy5tYXhMZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImluY2x1ZGVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIFJlZ0V4cChlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcykpLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJpcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaXB2NFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlwdjZcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmJhc2U2NHVybCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJqd3RcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmp3dCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaWRyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmlwdjRDaWRyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuaXB2NkNpZHIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZW1vamlcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmVtb2ppKCksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidWxpZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy51bGlkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjoge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlZnMuYmFzZTY0U3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6YmluYXJ5XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImJpbmFyeVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RW5jb2Rpbmc6YmFzZTY0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJjb250ZW50RW5jb2RpbmdcIiwgXCJiYXNlNjRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGF0dGVybjp6b2RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibmFub2lkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLm5hbm9pZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b0xvd2VyQ2FzZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1VwcGVyQ2FzZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmltXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICgoXykgPT4geyB9KShjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGVzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGxpdGVyYWwsIHJlZnMpIHtcbiAgICByZXR1cm4gcmVmcy5wYXR0ZXJuU3RyYXRlZ3kgPT09IFwiZXNjYXBlXCJcbiAgICAgICAgPyBlc2NhcGVOb25BbHBoYU51bWVyaWMobGl0ZXJhbClcbiAgICAgICAgOiBsaXRlcmFsO1xufVxuY29uc3QgQUxQSEFfTlVNRVJJQyA9IG5ldyBTZXQoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnh5ejAxMjM0NTY3ODlcIik7XG5mdW5jdGlvbiBlc2NhcGVOb25BbHBoYU51bWVyaWMoc291cmNlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFBTFBIQV9OVU1FUklDLmhhcyhzb3VyY2VbaV0pKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHNvdXJjZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEFkZHMgYSBcImZvcm1hdFwiIGtleXdvcmQgdG8gdGhlIHNjaGVtYS4gSWYgYSBmb3JtYXQgZXhpc3RzLCBib3RoIGZvcm1hdHMgd2lsbCBiZSBqb2luZWQgaW4gYW4gYWxsT2Ytbm9kZSwgYWxvbmcgd2l0aCBzdWJzZXF1ZW50IG9uZXMuXG5mdW5jdGlvbiBhZGRGb3JtYXQoc2NoZW1hLCB2YWx1ZSwgbWVzc2FnZSwgcmVmcykge1xuICAgIGlmIChzY2hlbWEuZm9ybWF0IHx8IHNjaGVtYS5hbnlPZj8uc29tZSgoeCkgPT4geC5mb3JtYXQpKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmFueU9mKSB7XG4gICAgICAgICAgICBzY2hlbWEuYW55T2YgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgc2NoZW1hLmFueU9mLnB1c2goe1xuICAgICAgICAgICAgICAgIGZvcm1hdDogc2NoZW1hLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAuLi4oc2NoZW1hLmVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHsgZm9ybWF0OiBzY2hlbWEuZXJyb3JNZXNzYWdlLmZvcm1hdCB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgc2NoZW1hLmZvcm1hdDtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2UuZm9ybWF0O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZXJyb3JNZXNzYWdlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgICAgICAgIGZvcm1hdDogdmFsdWUsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7IGVycm9yTWVzc2FnZTogeyBmb3JtYXQ6IG1lc3NhZ2UgfSB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHNjaGVtYSwgXCJmb3JtYXRcIiwgdmFsdWUsIG1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbn1cbi8vIEFkZHMgYSBcInBhdHRlcm5cIiBrZXl3b3JkIHRvIHRoZSBzY2hlbWEuIElmIGEgcGF0dGVybiBleGlzdHMsIGJvdGggcGF0dGVybnMgd2lsbCBiZSBqb2luZWQgaW4gYW4gYWxsT2Ytbm9kZSwgYWxvbmcgd2l0aCBzdWJzZXF1ZW50IG9uZXMuXG5mdW5jdGlvbiBhZGRQYXR0ZXJuKHNjaGVtYSwgcmVnZXgsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgICBpZiAoc2NoZW1hLnBhdHRlcm4gfHwgc2NoZW1hLmFsbE9mPy5zb21lKCh4KSA9PiB4LnBhdHRlcm4pKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmFsbE9mKSB7XG4gICAgICAgICAgICBzY2hlbWEuYWxsT2YgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnBhdHRlcm4pIHtcbiAgICAgICAgICAgIHNjaGVtYS5hbGxPZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBzY2hlbWEucGF0dGVybixcbiAgICAgICAgICAgICAgICAuLi4oc2NoZW1hLmVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHsgcGF0dGVybjogc2NoZW1hLmVycm9yTWVzc2FnZS5wYXR0ZXJuIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucGF0dGVybjtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2UucGF0dGVybjtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hLmVycm9yTWVzc2FnZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICAgICAgICBwYXR0ZXJuOiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgcGF0dGVybjogbWVzc2FnZSB9IH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMoc2NoZW1hLCBcInBhdHRlcm5cIiwgc3RyaW5naWZ5UmVnRXhwV2l0aEZsYWdzKHJlZ2V4LCByZWZzKSwgbWVzc2FnZSwgcmVmcyk7XG4gICAgfVxufVxuLy8gTXV0YXRlIHouc3RyaW5nLnJlZ2V4KCkgaW4gYSBiZXN0IGF0dGVtcHQgdG8gYWNjb21tb2RhdGUgZm9yIHJlZ2V4IGZsYWdzIHdoZW4gYXBwbHlSZWdleEZsYWdzIGlzIHRydWVcbmZ1bmN0aW9uIHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcykge1xuICAgIGlmICghcmVmcy5hcHBseVJlZ2V4RmxhZ3MgfHwgIXJlZ2V4LmZsYWdzKSB7XG4gICAgICAgIHJldHVybiByZWdleC5zb3VyY2U7XG4gICAgfVxuICAgIC8vIEN1cnJlbnRseSBoYW5kbGVkIGZsYWdzXG4gICAgY29uc3QgZmxhZ3MgPSB7XG4gICAgICAgIGk6IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwiaVwiKSxcbiAgICAgICAgbTogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJtXCIpLFxuICAgICAgICBzOiByZWdleC5mbGFncy5pbmNsdWRlcyhcInNcIiksIC8vIGAuYCBtYXRjaGVzIG5ld2xpbmVzXG4gICAgfTtcbiAgICAvLyBUaGUgZ2VuZXJhbCBwcmluY2lwbGUgaGVyZSBpcyB0byBzdGVwIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIsIG9uZSBhdCBhIHRpbWUsIGFwcGx5aW5nIG11dGF0aW9ucyBhcyBmbGFncyByZXF1aXJlLiBXZSBrZWVwIHRyYWNrIHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGVzY2FwZWQsIGFuZCB3aGVuIGl0J3MgaW5zaWRlIGEgZ3JvdXAgL2xpa2UgW3RoaXNdLyBvciAoYWxzbykgYSByYW5nZSBsaWtlIC9bYS16XS8uIFRoZSBmb2xsb3dpbmcgaXMgZmFpcmx5IGJyaXR0bGUgaW1wZXJhdGl2ZSBjb2RlOyBlZGl0IGF0IHlvdXIgcGVyaWwhXG4gICAgY29uc3Qgc291cmNlID0gZmxhZ3MuaSA/IHJlZ2V4LnNvdXJjZS50b0xvd2VyQ2FzZSgpIDogcmVnZXguc291cmNlO1xuICAgIGxldCBwYXR0ZXJuID0gXCJcIjtcbiAgICBsZXQgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgbGV0IGluQ2hhckdyb3VwID0gZmFsc2U7XG4gICAgbGV0IGluQ2hhclJhbmdlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRXNjYXBlZCkge1xuICAgICAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncy5pKSB7XG4gICAgICAgICAgICBpZiAoaW5DaGFyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW2ldLm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkNoYXJSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAke3NvdXJjZVtpIC0gMl19LSR7c291cmNlW2ldfWAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ2hhclJhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlW2kgKyAxXSA9PT0gXCItXCIgJiYgc291cmNlW2kgKyAyXT8ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5DaGFyUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBgJHtzb3VyY2VbaV19JHtzb3VyY2VbaV0udG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVtpXS5tYXRjaCgvW2Etel0vKSkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYFske3NvdXJjZVtpXX0ke3NvdXJjZVtpXS50b1VwcGVyQ2FzZSgpfV1gO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncy5tKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW2ldID09PSBcIl5cIikge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYChefCg/PD1bXFxyXFxuXSkpYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVtpXSA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAoJHwoPz1bXFxyXFxuXSkpYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MucyAmJiBzb3VyY2VbaV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IGluQ2hhckdyb3VwID8gYCR7c291cmNlW2ldfVxcclxcbmAgOiBgWyR7c291cmNlW2ldfVxcclxcbl1gO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChzb3VyY2VbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBpc0VzY2FwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluQ2hhckdyb3VwICYmIHNvdXJjZVtpXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgIGluQ2hhckdyb3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluQ2hhckdyb3VwICYmIHNvdXJjZVtpXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgIGluQ2hhckdyb3VwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGNvbnZlcnQgcmVnZXggcGF0dGVybiBhdCAke3JlZnMuY3VycmVudFBhdGguam9pbihcIi9cIil9IHRvIGEgZmxhZy1pbmRlcGVuZGVudCBmb3JtISBGYWxsaW5nIGJhY2sgdG8gdGhlIGZsYWctaWdub3JhbnQgc291cmNlYCk7XG4gICAgICAgIHJldHVybiByZWdleC5zb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xufVxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKlxuICogU1BBUlFMIENsaWVudCBmb3IgTElOREFTL0ZlZGxleCBFbmRwb2ludFxuICogUHJvdmlkZXMgSFRUUCBhY2Nlc3MgdG8gdGhlIFN3aXNzIEZlZGVyYWwgTGlua2VkIERhdGEgU2VydmljZVxuICpcbiAqIEVuZHBvaW50OiBodHRwczovL2xkLmFkbWluLmNoL3F1ZXJ5XG4gKiBEb2N1bWVudGF0aW9uOiBodHRwczovL2xpbmRhcy5hZG1pbi5jaC9cbiAqL1xuXG5pbXBvcnQgeyBTUEFSUUxSZXN1bHQsIFNQQVJRTEJpbmRpbmcsIEZlZGxleEVycm9yIH0gZnJvbSAnLi90eXBlcy9sZWdpc2xhdGlvbi5qcyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIFNQQVJRTCBjbGllbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTUEFSUUxDbGllbnRDb25maWcge1xuICBlbmRwb2ludDogc3RyaW5nO1xuICB0aW1lb3V0OiBudW1iZXI7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgcmV0cnlEZWxheTogbnVtYmVyO1xuICB1c2VyQWdlbnQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09ORklHOiBTUEFSUUxDbGllbnRDb25maWcgPSB7XG4gIGVuZHBvaW50OiAnaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9zcGFycWxlbmRwb2ludCcsICAvLyBDb3JyZWN0IEZlZGxleCBTUEFSUUwgZW5kcG9pbnRcbiAgdGltZW91dDogMzAwMDAsICAgICAgICAvLyAzMCBzZWNvbmRzXG4gIG1heFJldHJpZXM6IDMsXG4gIHJldHJ5RGVsYXk6IDEwMDAsICAgICAgLy8gMSBzZWNvbmRcbiAgdXNlckFnZW50OiAnQmV0dGVyQ2FsbENsYXVkZS8yLjAuMSAoU3dpc3MgTGVnYWwgSW50ZWxsaWdlbmNlKScsXG59O1xuXG4vKipcbiAqIFNQQVJRTCBxdWVyeSBleGVjdXRpb24gb3B0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5T3B0aW9ucyB7XG4gIGZvcm1hdD86ICdqc29uJyB8ICd4bWwnO1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICBhY2NlcHRMYW5ndWFnZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTUEFSUUwgQ2xpZW50IGZvciBxdWVyeWluZyBMSU5EQVMvRmVkbGV4XG4gKi9cbmV4cG9ydCBjbGFzcyBTUEFSUUxDbGllbnQge1xuICBwcml2YXRlIGNvbmZpZzogU1BBUlFMQ2xpZW50Q29uZmlnO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxTUEFSUUxDbGllbnRDb25maWc+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBTUEFSUUwgU0VMRUNUIHF1ZXJ5XG4gICAqL1xuICBhc3luYyBxdWVyeShzcGFycWw6IHN0cmluZywgb3B0aW9uczogUXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPFNQQVJRTFJlc3VsdD4ge1xuICAgIGNvbnN0IHsgZm9ybWF0ID0gJ2pzb24nLCB0aW1lb3V0ID0gdGhpcy5jb25maWcudGltZW91dCwgYWNjZXB0TGFuZ3VhZ2UgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgJ0FjY2VwdCc6IGZvcm1hdCA9PT0gJ2pzb24nID8gJ2FwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK2pzb24nIDogJ2FwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK3htbCcsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAnVXNlci1BZ2VudCc6IHRoaXMuY29uZmlnLnVzZXJBZ2VudCxcbiAgICB9O1xuXG4gICAgaWYgKGFjY2VwdExhbmd1YWdlKSB7XG4gICAgICBoZWFkZXJzWydBY2NlcHQtTGFuZ3VhZ2UnXSA9IGFjY2VwdExhbmd1YWdlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIHF1ZXJ5OiBzcGFycWwsXG4gICAgfSk7XG5cbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuY29uZmlnLmVuZHBvaW50LCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5OiBib2R5LnRvU3RyaW5nKCksXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNQQVJRTCBxdWVyeSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCkgYXMgU1BBUlFMUmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvciBhcyBFcnJvcjtcblxuICAgICAgICAvLyBEb24ndCByZXRyeSBvbiBjbGllbnQgZXJyb3JzICg0eHgpXG4gICAgICAgIGlmIChsYXN0RXJyb3IubWVzc2FnZS5pbmNsdWRlcygnNCcpKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGZWRsZXhFcnJvcihsYXN0RXJyb3IsIHNwYXJxbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICBpZiAoYXR0ZW1wdCA8IHRoaXMuY29uZmlnLm1heFJldHJpZXMgLSAxKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5kZWxheSh0aGlzLmNvbmZpZy5yZXRyeURlbGF5ICogKGF0dGVtcHQgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUZlZGxleEVycm9yKGxhc3RFcnJvciEsIHNwYXJxbCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIFNQQVJRTCBBU0sgcXVlcnlcbiAgICovXG4gIGFzeW5jIGFzayhzcGFycWw6IHN0cmluZywgb3B0aW9uczogUXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5KHNwYXJxbCwgb3B0aW9ucyk7XG4gICAgLy8gQVNLIHF1ZXJpZXMgcmV0dXJuIGEgYm9vbGVhbiBpbiB0aGUgcmVzdWx0XG4gICAgcmV0dXJuIChyZXN1bHQgYXMgdW5rbm93biBhcyB7IGJvb2xlYW46IGJvb2xlYW4gfSkuYm9vbGVhbiA/PyBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgU1BBUlFMIERFU0NSSUJFIHF1ZXJ5XG4gICAqL1xuICBhc3luYyBkZXNjcmliZShzcGFycWw6IHN0cmluZywgb3B0aW9uczogUXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPFNQQVJRTFJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5KHNwYXJxbCwgeyAuLi5vcHRpb25zLCBmb3JtYXQ6ICdqc29uJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIGJpbmRpbmdzXG4gICAqL1xuICBleHRyYWN0VmFsdWUoYmluZGluZzogU1BBUlFMQmluZGluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGJpbmRpbmc/LnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IGEgbG9jYWxpemVkIHZhbHVlIGJhc2VkIG9uIGxhbmd1YWdlIHByZWZlcmVuY2VcbiAgICovXG4gIGV4dHJhY3RMb2NhbGl6ZWRWYWx1ZShcbiAgICBiaW5kaW5nczogQXJyYXk8UmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4+LFxuICAgIHZhcmlhYmxlTmFtZTogc3RyaW5nLFxuICAgIHByZWZlcnJlZExhbmc6IHN0cmluZyA9ICdkZSdcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBGaXJzdCB0cnkgdG8gZmluZCBleGFjdCBsYW5ndWFnZSBtYXRjaFxuICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBiaW5kaW5ncykge1xuICAgICAgY29uc3QgdmFsdWUgPSBiaW5kaW5nW3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJ3htbDpsYW5nJ10gPT09IHByZWZlcnJlZExhbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byBhbnkgYXZhaWxhYmxlIHZhbHVlXG4gICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGJpbmRpbmdbdmFyaWFibGVOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBtdWx0aWxpbmd1YWwgdmFsdWVzXG4gICAqL1xuICBleHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUoXG4gICAgYmluZGluZ3M6IEFycmF5PFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+PixcbiAgICB2YXJpYWJsZU5hbWU6IHN0cmluZ1xuICApOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBiaW5kaW5ncykge1xuICAgICAgY29uc3QgdmFsdWUgPSBiaW5kaW5nW3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJ3htbDpsYW5nJ10pIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlWyd4bWw6bGFuZyddXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiAhT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXNlIHZhbHVlIHdpdGhvdXQgbGFuZ3VhZ2UgdGFnIGlmIG5vIGxvY2FsaXplZCB2YWx1ZXMgZm91bmRcbiAgICAgICAgcmVzdWx0WydkZSddID0gdmFsdWUudmFsdWU7IC8vIERlZmF1bHQgdG8gR2VybWFuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZ3JvdXAgYmluZGluZ3MgYnkgYSBrZXkgdmFyaWFibGVcbiAgICovXG4gIGdyb3VwQmluZGluZ3MoXG4gICAgYmluZGluZ3M6IEFycmF5PFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+PixcbiAgICBrZXlWYXJpYWJsZTogc3RyaW5nXG4gICk6IE1hcDxzdHJpbmcsIEFycmF5PFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+Pj4ge1xuICAgIGNvbnN0IGdyb3VwcyA9IG5ldyBNYXA8c3RyaW5nLCBBcnJheTxSZWNvcmQ8c3RyaW5nLCBTUEFSUUxCaW5kaW5nPj4+KCk7XG5cbiAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXh0cmFjdFZhbHVlKGJpbmRpbmdba2V5VmFyaWFibGVdKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHMuZ2V0KGtleSkgfHwgW107XG4gICAgICAgIGdyb3VwLnB1c2goYmluZGluZyk7XG4gICAgICAgIGdyb3Vwcy5zZXQoa2V5LCBncm91cCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIFNQQVJRTCBxdWVyeSBzeW50YXggKGJhc2ljIGNoZWNrKVxuICAgKi9cbiAgdmFsaWRhdGVRdWVyeShzcGFycWw6IHN0cmluZyk6IHsgdmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xuICAgIC8vIEJhc2ljIHN5bnRheCBjaGVja3NcbiAgICBjb25zdCB0cmltbWVkID0gc3BhcnFsLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKCF0cmltbWVkLnN0YXJ0c1dpdGgoJ1NFTEVDVCcpICYmXG4gICAgICAgICF0cmltbWVkLnN0YXJ0c1dpdGgoJ0FTSycpICYmXG4gICAgICAgICF0cmltbWVkLnN0YXJ0c1dpdGgoJ0RFU0NSSUJFJykgJiZcbiAgICAgICAgIXRyaW1tZWQuc3RhcnRzV2l0aCgnQ09OU1RSVUNUJykgJiZcbiAgICAgICAgIXRyaW1tZWQuc3RhcnRzV2l0aCgnUFJFRklYJykpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdRdWVyeSBtdXN0IHN0YXJ0IHdpdGggU0VMRUNULCBBU0ssIERFU0NSSUJFLCBDT05TVFJVQ1QsIG9yIFBSRUZJWCcgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgYmFsYW5jZWQgYnJhY2VzXG4gICAgY29uc3Qgb3BlbkJyYWNlcyA9IChzcGFycWwubWF0Y2goL3svZykgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZUJyYWNlcyA9IChzcGFycWwubWF0Y2goL30vZykgfHwgW10pLmxlbmd0aDtcbiAgICBpZiAob3BlbkJyYWNlcyAhPT0gY2xvc2VCcmFjZXMpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdVbmJhbGFuY2VkIGJyYWNlcyBpbiBxdWVyeScgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEZlZGxleEVycm9yIGZyb20gYW4gRXJyb3JcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlRmVkbGV4RXJyb3IoZXJyb3I6IEVycm9yLCBxdWVyeT86IHN0cmluZyk6IEZlZGxleEVycm9yIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogJ1NQQVJRTF9FUlJPUicsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcXVlcnksXG4gICAgICBlbmRwb2ludDogdGhpcy5jb25maWcuZW5kcG9pbnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheSBoZWxwZXIgZm9yIHJldHJ5IGxvZ2ljXG4gICAqL1xuICBwcml2YXRlIGRlbGF5KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb25maWd1cmVkIGVuZHBvaW50IFVSTFxuICAgKi9cbiAgZ2V0RW5kcG9pbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnOiBQYXJ0aWFsPFNQQVJRTENsaWVudENvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcHJlLWNvbmZpZ3VyZWQgU1BBUlFMIGNsaWVudCBmb3IgRmVkbGV4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGZWRsZXhDbGllbnQoY29uZmlnPzogUGFydGlhbDxTUEFSUUxDbGllbnRDb25maWc+KTogU1BBUlFMQ2xpZW50IHtcbiAgcmV0dXJuIG5ldyBTUEFSUUxDbGllbnQoe1xuICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgIC4uLmNvbmZpZyxcbiAgfSk7XG59XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBmb3IgU1BBUlFMIHN0cmluZyBsaXRlcmFsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRm9yU1BBUlFMKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdmFsdWVcbiAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBGSUxURVIgY2xhdXNlIGZvciB0ZXh0IHNlYXJjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUZXh0RmlsdGVyKHZhcmlhYmxlOiBzdHJpbmcsIHNlYXJjaFRleHQ6IHN0cmluZywgbGFuZ3VhZ2U/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBlc2NhcGVkID0gZXNjYXBlRm9yU1BBUlFMKHNlYXJjaFRleHQpO1xuXG4gIGlmIChsYW5ndWFnZSkge1xuICAgIHJldHVybiBgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/JHt2YXJpYWJsZX0pKSwgTENBU0UoXCIke2VzY2FwZWR9XCIpKSAmJiBMQU5HKD8ke3ZhcmlhYmxlfSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYDtcbiAgfVxuXG4gIHJldHVybiBgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/JHt2YXJpYWJsZX0pKSwgTENBU0UoXCIke2VzY2FwZWR9XCIpKSlgO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgRklMVEVSIGNsYXVzZSBmb3IgU1IgbnVtYmVyIHBhdHRlcm4gbWF0Y2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU1JOdW1iZXJGaWx0ZXIodmFyaWFibGU6IHN0cmluZywgc3JOdW1iZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFNSIG51bWJlcnMgY2FuIGJlIHBhcnRpYWwgKGUuZy4sIFwiMlwiIG1hdGNoZXMgXCIyMTBcIiwgXCIyMjBcIiwgZXRjLilcbiAgY29uc3QgZXNjYXBlZCA9IGVzY2FwZUZvclNQQVJRTChzck51bWJlcik7XG4gIHJldHVybiBgRklMVEVSKFNUUlNUQVJUUyhTVFIoPyR7dmFyaWFibGV9KSwgXCIke2VzY2FwZWR9XCIpKWA7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUHJlZml4ZXMgZm9yIEZlZGxleCBRdWVyaWVzXG4gKiBDb21tb24gbmFtZXNwYWNlIHByZWZpeGVzIHVzZWQgaW4gdGhlIEZlZGxleCBTUEFSUUwgZW5kcG9pbnRcbiAqXG4gKiBOT1RFOiBGZWRsZXggdXNlcyB0aGUgSk9MVVggb250b2xvZ3kgKEZSQlItbGlrZSBtb2RlbCksIG5vdCBFTElcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiBlbnRpdHlcbiAqIC0gam9sdXg6RXhwcmVzc2lvbiA9IExhbmd1YWdlLXNwZWNpZmljIHZlcnNpb24gKHRpdGxlcyBoZXJlLCBOTyBsYW5ndWFnZSB0YWdzKVxuICogLSBqb2x1eDpNYW5pZmVzdGF0aW9uID0gUGh5c2ljYWwgZm9ybWF0IChQREYsIFhNTCwgZXRjLilcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqL1xuXG4vKipcbiAqIFN0YW5kYXJkIFJERiBwcmVmaXhlc1xuICovXG5leHBvcnQgY29uc3QgUkRGX1BSRUZJWEVTID0gYFxuUFJFRklYIHJkZjogPGh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyM+XG5QUkVGSVggcmRmczogPGh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDEvcmRmLXNjaGVtYSM+XG5QUkVGSVggeHNkOiA8aHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjPlxuUFJFRklYIG93bDogPGh0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsIz5cblBSRUZJWCBza29zOiA8aHR0cDovL3d3dy53My5vcmcvMjAwNC8wMi9za29zL2NvcmUjPlxuUFJFRklYIGRjdGVybXM6IDxodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvPlxuUFJFRklYIGRjYXQ6IDxodHRwOi8vd3d3LnczLm9yZy9ucy9kY2F0Iz5cbmA7XG5cbi8qKlxuICogRmVkbGV4LXNwZWNpZmljIHByZWZpeGVzXG4gKiAtIGpvbHV4OiBQcmltYXJ5IG9udG9sb2d5IHVzZWQgYnkgRmVkbGV4IChGUkJSIG1vZGVsKVxuICogLSBlbGk6IEV1cm9wZWFuIExlZ2lzbGF0aW9uIElkZW50aWZpZXIgKGxpbWl0ZWQgdXNlIGluIEZlZGxleClcbiAqL1xuZXhwb3J0IGNvbnN0IEZFRExFWF9QUkVGSVhFUyA9IGBcblBSRUZJWCBlbGk6IDxodHRwOi8vZGF0YS5ldXJvcGEuZXUvZWxpL29udG9sb2d5Iz5cblBSRUZJWCBqb2x1eDogPGh0dHA6Ly9kYXRhLmxlZ2lsdXgucHVibGljLmx1L3Jlc291cmNlL29udG9sb2d5L2pvbHV4Iz5cblBSRUZJWCBmZWRsZXg6IDxodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL3ZvY2FidWxhcnkvPlxuUFJFRklYIGZlZGxleC1lbGk6IDxodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS8+XG5QUkVGSVggZmVkbGV4LWNjOiA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9lbGkvY2MvPlxuUFJFRklYIHNjaGVtYTogPGh0dHA6Ly9zY2hlbWEub3JnLz5cbmA7XG5cbi8qKlxuICogTElOREFTLXNwZWNpZmljIHByZWZpeGVzIChsZWdhY3ksIGtlcHQgZm9yIGNvbXBhdGliaWxpdHkpXG4gKi9cbmV4cG9ydCBjb25zdCBMSU5EQVNfUFJFRklYRVMgPSBgXG5QUkVGSVggbGQ6IDxodHRwczovL2xkLmFkbWluLmNoLz5cblBSRUZJWCBjdWJlOiA8aHR0cHM6Ly9jdWJlLmxpbmsvPlxuUFJFRklYIHF1ZHQ6IDxodHRwOi8vcXVkdC5vcmcvc2NoZW1hL3F1ZHQvPlxuYDtcblxuLyoqXG4gKiBBbGwgcHJlZml4ZXMgY29tYmluZWQgZm9yIHVzZSBpbiBxdWVyaWVzXG4gKi9cbmV4cG9ydCBjb25zdCBBTExfUFJFRklYRVMgPSBgJHtSREZfUFJFRklYRVN9JHtGRURMRVhfUFJFRklYRVN9JHtMSU5EQVNfUFJFRklYRVN9YDtcblxuLyoqXG4gKiBDcmVhdGUgYSBxdWVyeSB3aXRoIHN0YW5kYXJkIHByZWZpeGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoUHJlZml4ZXMocXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtBTExfUFJFRklYRVN9XFxuJHtxdWVyeX1gO1xufVxuXG4vKipcbiAqIEZlZGxleCBFTEkgYmFzZSBVUklzXG4gKi9cbmV4cG9ydCBjb25zdCBGRURMRVhfQkFTRSA9IHtcbiAgQ0M6ICdodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS9jYy8nLCAgICAgICAgICAvLyBDbGFzc2lmaWVkIGNvbXBpbGF0aW9uXG4gIE9DOiAnaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9lbGkvb2MvJywgICAgICAgICAgLy8gT2ZmaWNpYWwgY29sbGVjdGlvblxuICBGR0E6ICdodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS9mZ2EvJywgICAgICAgIC8vIEZlZGVyYWwgR2F6ZXR0ZVxuICBUUkVBVFk6ICdodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS90cmVhdHkvJywgIC8vIEludGVybmF0aW9uYWwgdHJlYXRpZXNcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogQnVpbGQgYSBGZWRsZXggVVJJIGZyb20gU1IgbnVtYmVyXG4gKiBTUiBudW1iZXJzIGxpa2UgXCIyMTBcIiBiZWNvbWUgVVJJcyBsaWtlIFwiaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9lbGkvY2MvMjQvMjMzXzI0NV8yMzNcIlxuICogTm90ZTogVGhlIGFjdHVhbCBtYXBwaW5nIHJlcXVpcmVzIGxvb2tpbmcgdXAgdGhlIG9mZmljaWFsIFVSSVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGZWRsZXhTZWFyY2hVUkkoc3JOdW1iZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFNSIG51bWJlciBpcyB1c2VkIGZvciBzZWFyY2hpbmcsIG5vdCBkaXJlY3QgVVJJIGNvbnN0cnVjdGlvblxuICAvLyBUaGUgYWN0dWFsIG1hcHBpbmcgZnJvbSBTUiB0byBFTEkgVVJJIGlzIGRvbmUgdmlhIFNQQVJRTCBxdWVyeVxuICByZXR1cm4gc3JOdW1iZXI7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUXVlcmllcyBmb3IgU3RhdHV0ZSBMb29rdXBcbiAqIFF1ZXJpZXMgdG8gcmV0cmlldmUgbGVnYWwgYWN0cyBieSBTUiBudW1iZXIgdXNpbmcgSk9MVVggb250b2xvZ3lcbiAqXG4gKiBGZWRsZXggRGF0YSBNb2RlbCAoRlJCUi1iYXNlZCk6XG4gKiAtIGpvbHV4OkFjdCA9IFByaW1hcnkgbGVnaXNsYXRpb24gd29ya1xuICogLSBqb2x1eDpFeHByZXNzaW9uID0gTGFuZ3VhZ2Utc3BlY2lmaWMgcmVhbGl6YXRpb24gKHZpYSBqb2x1eDppc1JlYWxpemVkQnkpXG4gKiAtIGpvbHV4Ok1hbmlmZXN0YXRpb24gPSBQaHlzaWNhbCBmb3JtYXQgKHZpYSBqb2x1eDppc0VtYm9kaWVkQnkpXG4gKiAtIFNSIG51bWJlcnMgdmlhIHRheG9ub215OiBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5IFx1MjE5MiBza29zOm5vdGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgd2l0aFByZWZpeGVzIH0gZnJvbSAnLi9wcmVmaXhlcy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVGb3JTUEFSUUwgfSBmcm9tICcuLi9zcGFycWwtY2xpZW50LmpzJztcbmltcG9ydCB7IExhbmd1YWdlIH0gZnJvbSAnLi4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gbG9vayB1cCBhIGxlZ2FsIGFjdCBieSBTUiBudW1iZXJcbiAqIFNSIG51bWJlcnMgYXJlIGFjY2Vzc2VkIHZpYSB0YXhvbm9teSBjbGFzc2lmaWNhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rdXBTdGF0dXRlUXVlcnkoc3JOdW1iZXI6IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2luRm9yY2UgP2RhdGVJbkZvcmNlID9kYXRlRG9jdW1lbnQgP2FjdFR5cGVcbldIRVJFIHtcbiAgIyBGaW5kIGFjdCB2aWEgdGF4b25vbXkgY2xhc3NpZmljYXRpb25cbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gICMgR2V0IFNSIG51bWJlciBmcm9tIHRheG9ub215XG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgR2V0IHRpdGxlIGZyb20gdGF4b25vbXkgcHJlZkxhYmVsIChoYXMgbGFuZ3VhZ2UgdGFncylcbiAgP3RheG9ub215IHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG4gICR7bGFuZ0ZpbHRlcn1cblxuICAjIE9wdGlvbmFsIG1ldGFkYXRhXG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6ZGF0ZURvY3VtZW50ID9kYXRlRG9jdW1lbnQgfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6ZGF0ZUVudHJ5SW5Gb3JjZSA/ZGF0ZUluRm9yY2UgfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dHlwZURvY3VtZW50ID9hY3RUeXBlIH1cblxuICAjIENoZWNrIGlmIGN1cnJlbnRseSBpbiBmb3JjZVxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppbkZvcmNlID9pbkZvcmNlU3RhdHVzIC5cbiAgICBCSU5EKD9pbkZvcmNlU3RhdHVzID0gPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9lbmZvcmNlbWVudC1zdGF0dXMvMT4gQVMgP2luRm9yY2UpXG4gIH1cbn1cbk9SREVSIEJZID9zck51bWJlclxuTElNSVQgMTBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBsb29rIHVwIGEgbGVnYWwgYWN0IHdpdGggYXJ0aWNsZXNcbiAqIE5vdGU6IEFydGljbGUgc3RydWN0dXJlIGluIEpPTFVYIHVzZXMgam9sdXg6aGFzUGFydFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rdXBTdGF0dXRlV2l0aEFydGljbGVzUXVlcnkoc3JOdW1iZXI6IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2FydGljbGUgP2FydGljbGVOdW1iZXIgP2FydGljbGVUaXRsZSA/YXJ0aWNsZVRleHQgP2RhdGVJbkZvcmNlXG5XSEVSRSB7XG4gICMgRmluZCBtYWluIGFjdCB2aWEgdGF4b25vbXlcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgR2V0IHRpdGxlIGZyb20gdGF4b25vbXlcbiAgP3RheG9ub215IHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG4gICR7bGFuZ0ZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmRhdGVFbnRyeUluRm9yY2UgP2RhdGVJbkZvcmNlIH1cblxuICAjIEFydGljbGVzIChzdWJkaXZpc2lvbnMpIC0gSk9MVVggdXNlcyBoYXNQYXJ0XG4gIE9QVElPTkFMIHtcbiAgICA/YWN0IGpvbHV4Omhhc1BhcnQgP2FydGljbGUgLlxuICAgID9hcnRpY2xlIGpvbHV4Om51bWJlciA/YXJ0aWNsZU51bWJlciAuXG4gICAgT1BUSU9OQUwge1xuICAgICAgP2FydGljbGUgam9sdXg6aXNSZWFsaXplZEJ5ID9hcnRpY2xlRXhwciAuXG4gICAgICA/YXJ0aWNsZUV4cHIgam9sdXg6dGl0bGUgP2FydGljbGVUaXRsZSAuXG4gICAgfVxuICAgIE9QVElPTkFMIHsgP2FydGljbGUgam9sdXg6dGV4dCA/YXJ0aWNsZVRleHQgfVxuICB9XG59XG5PUkRFUiBCWSA/YXJ0aWNsZU51bWJlclxuTElNSVQgNTAwXG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3QgYnkgYWJicmV2aWF0aW9uIChlLmcuLCBcIk9SXCIsIFwiWkdCXCIsIFwiU3RHQlwiKVxuICogQWJicmV2aWF0aW9ucyBtYXkgYmUgaW4gdGF4b25vbXkgb3IgYWN0IHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTG9va3VwQnlBYmJyZXZpYXRpb25RdWVyeShhYmJyZXZpYXRpb246IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2luRm9yY2VcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gID90YXhvbm9teSBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBTZWFyY2ggZm9yIGFiYnJldmlhdGlvbiBpbiB2YXJpb3VzIHBsYWNlc1xuICB7XG4gICAgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gLlxuICAgIEZJTFRFUihVQ0FTRShTVFIoP2FiYnJldmlhdGlvbikpID0gXCIke2VzY2FwZUZvclNQQVJRTChhYmJyZXZpYXRpb24udG9VcHBlckNhc2UoKSl9XCIpXG4gIH0gVU5JT04ge1xuICAgID90YXhvbm9teSBza29zOmFsdExhYmVsID9hYmJyZXZpYXRpb24gLlxuICAgIEZJTFRFUihVQ0FTRShTVFIoP2FiYnJldmlhdGlvbikpID0gXCIke2VzY2FwZUZvclNQQVJRTChhYmJyZXZpYXRpb24udG9VcHBlckNhc2UoKSl9XCIpXG4gIH1cblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppbkZvcmNlID9pbkZvcmNlU3RhdHVzIC5cbiAgICBCSU5EKD9pbkZvcmNlU3RhdHVzID0gPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9lbmZvcmNlbWVudC1zdGF0dXMvMT4gQVMgP2luRm9yY2UpXG4gIH1cbn1cbk9SREVSIEJZID9zck51bWJlclxuTElNSVQgMTBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBjaGVjayBpZiBhbiBTUiBudW1iZXIgZXhpc3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4aXN0c1F1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcbkFTSyB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGFsbCBTUiBudW1iZXJzIGZvciBuYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExpc3RTUk51bWJlcnNRdWVyeShwcmVmaXg/OiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMDApOiBzdHJpbmcge1xuICBjb25zdCBwcmVmaXhGaWx0ZXIgPSBwcmVmaXhcbiAgICA/IGBGSUxURVIoU1RSU1RBUlRTKFNUUig/c3JOdW1iZXIpLCBcIiR7ZXNjYXBlRm9yU1BBUlFMKHByZWZpeCl9XCIpKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9zck51bWJlciA/dGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gIEZJTFRFUihMQU5HKD90aXRsZSkgPSBcImRlXCIpXG4gICR7cHJlZml4RmlsdGVyfVxufVxuT1JERVIgQlkgP3NyTnVtYmVyXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCB0aGUgY3VycmVudCBjb25zb2xpZGF0ZWQgdmVyc2lvbiBvZiBhbiBhY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ29uc29saWRhdGVkVmVyc2lvblF1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcsIGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP2NvbnNvbGlkYXRlZFZlcnNpb24gP3NyTnVtYmVyID90aXRsZSA/ZGF0ZUNvbnNvbGlkYXRpb25cbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBHZXQgdGhlIG1vc3QgcmVjZW50IGNvbnNvbGlkYXRlZCB2ZXJzaW9uXG4gIE9QVElPTkFMIHtcbiAgICA/YWN0IGpvbHV4OmlzUmVhbGl6ZWRCeSA/Y29uc29saWRhdGVkVmVyc2lvbiAuXG4gICAgP2NvbnNvbGlkYXRlZFZlcnNpb24gam9sdXg6ZGF0ZURvY3VtZW50ID9kYXRlQ29uc29saWRhdGlvbiAuXG4gIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGVDb25zb2xpZGF0aW9uKVxuTElNSVQgMVxuICBgKTtcbn1cbiIsICIvKipcbiAqIFNQQVJRTCBRdWVyaWVzIGZvciBBcnRpY2xlIFJldHJpZXZhbFxuICogUXVlcmllcyB0byByZXRyaWV2ZSBzcGVjaWZpYyBhcnRpY2xlcyB3aXRoaW4gbGVnYWwgYWN0cyB1c2luZyBKT0xVWCBvbnRvbG9neVxuICpcbiAqIEZlZGxleCBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6Q29uc29saWRhdGlvbkFic3RyYWN0ID0gQ29uc29saWRhdGVkIGxlZ2lzbGF0aW9uIHdvcmtcbiAqIC0gam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uID0gQXJ0aWNsZS9zdWJkaXZpc2lvbiBzdHJ1Y3R1cmVcbiAqIC0gam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSXNQYXJ0T2YgPSBpbnZlcnNlIHBhcmVudCByZWxhdGlvbnNoaXAgKGNoaWxkIFx1MjE5MiBwYXJlbnQpXG4gKiAtIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkhhc1N1YmRpdmlzaW9uSWRlbnRpZmljYXRpb25EZXRhaWwgXHUyMTkyIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkRldGFpbElkID0gQXJ0aWNsZSBudW1iZXJcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqIC0gVGl0bGVzOiB0YXhvbm9teSBza29zOnByZWZMYWJlbCAod2l0aCBsYW5ndWFnZSB0YWdzKVxuICpcbiAqIE5vdGU6IE9ubHkgbW9kaWZpZWQgYXJ0aWNsZXMgYXJlIHN0b3JlZCBpbiBGZWRsZXggKG5vdCBvcmlnaW5hbCBhcnRpY2xlcykuXG4gKiBBcnRpY2xlIFVSSXMgZm9sbG93IHBhdHRlcm46IC9lbGkvY2MvW2lkXS9hcnRfW251bWJlcl0vW2RhdGVdXG4gKi9cblxuaW1wb3J0IHsgd2l0aFByZWZpeGVzIH0gZnJvbSAnLi9wcmVmaXhlcy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVGb3JTUEFSUUwgfSBmcm9tICcuLi9zcGFycWwtY2xpZW50LmpzJztcbmltcG9ydCB7IExhbmd1YWdlIH0gZnJvbSAnLi4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGEgc3BlY2lmaWMgYXJ0aWNsZVxuICpcbiAqIEZlZGxleCBzdG9yZXMgYXJ0aWNsZXMgYXMgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIHdpdGggaW52ZXJzZSBwYXJlbnQgcmVsYXRpb25zaGlwLlxuICogQXJ0aWNsZSBudW1iZXJzIGFyZSBhY2Nlc3NlZCB2aWEgbGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR2V0QXJ0aWNsZVF1ZXJ5KFxuICBzck51bWJlcjogc3RyaW5nLFxuICBhcnRpY2xlTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2Vcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD9hY3RUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgLy8gTm9ybWFsaXplIGFydGljbGUgbnVtYmVyIChlLmcuLCBcIjk3XCIgb3IgXCJBcnQuIDk3XCIgLT4gXCI5N1wiKVxuICBjb25zdCBub3JtYWxpemVkQXJ0aWNsZSA9IGFydGljbGVOdW1iZXIucmVwbGFjZSgvXkFydFxcLj9cXHMqL2ksICcnKS50cmltKCk7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP2FjdFRpdGxlID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID9hcnRpY2xlVGl0bGUgP3RleHQgP3BhcmFncmFwaE51bSA/cGFyYWdyYXBoVGV4dFxuV0hFUkUge1xuICAjIEZpbmQgdGhlIGFjdCB2aWEgdGF4b25vbXkgKENvbnNvbGlkYXRpb25BYnN0cmFjdCBmb3IgY29uc29saWRhdGVkIGxhd3MpXG4gID9hY3QgYSBqb2x1eDpDb25zb2xpZGF0aW9uQWJzdHJhY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgO1xuICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP2FjdFRpdGxlIC5cblxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcbiAgJHtsYW5nRmlsdGVyfVxuXG4gICMgRmluZCBhcnRpY2xlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGFjdCAoaW52ZXJzZSByZWxhdGlvbnNoaXA6IGFydGljbGUgXHUyMTkyIHBhcmVudClcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgIyBHZXQgYXJ0aWNsZSBudW1iZXIgZnJvbSBzdWJkaXZpc2lvbiBkZXRhaWxcbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgIyBNYXRjaCBhcnRpY2xlIG51bWJlclxuICBGSUxURVIoXG4gICAgU1RSKD9hcnRpY2xlTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwobm9ybWFsaXplZEFydGljbGUpfVwiIHx8XG4gICAgUkVHRVgoU1RSKD9hcnRpY2xlTnVtYmVyKSwgXCJeJHtlc2NhcGVGb3JTUEFSUUwobm9ybWFsaXplZEFydGljbGUpfVthLXpdPyRcIiwgXCJpXCIpXG4gIClcblxuICAjIEFydGljbGUgdGl0bGUgKG1hcmdpbmFsIG5vdGUpIGZyb20gZXhwcmVzc2lvblxuICBPUFRJT05BTCB7XG4gICAgP2FydGljbGUgam9sdXg6aXNSZWFsaXplZEJ5ID9hcnRpY2xlRXhwciAuXG4gICAgP2FydGljbGVFeHByIGpvbHV4OnRpdGxlID9hcnRpY2xlVGl0bGUgLlxuICAgICR7bGFuZ3VhZ2UgPyBgRklMVEVSKExBTkcoP2FydGljbGVUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYCA6ICcnfVxuICB9XG5cbiAgIyBHZXQgdGV4dCBjb250ZW50IGZyb20gbWFuaWZlc3RhdGlvblxuICBPUFRJT05BTCB7XG4gICAgP2FydGljbGUgam9sdXg6aXNSZWFsaXplZEJ5ID9leHByIC5cbiAgICA/ZXhwciBqb2x1eDppc0VtYm9kaWVkQnkgP21hbmlmIC5cbiAgICA/bWFuaWYgam9sdXg6dGV4dCA/dGV4dCAuXG4gIH1cblxuICAjIFBhcmFncmFwaHMgKHN1Yi1zdWJkaXZpc2lvbnMpXG4gIE9QVElPTkFMIHtcbiAgICA/cGFyYWdyYXBoIGEgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIDtcbiAgICAgICAgICAgICAgIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbklzUGFydE9mID9hcnRpY2xlIC5cbiAgICA/cGFyYWdyYXBoIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkhhc1N1YmRpdmlzaW9uSWRlbnRpZmljYXRpb25EZXRhaWwgP3BEZXRhaWwgLlxuICAgID9wRGV0YWlsIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkRldGFpbElkID9wYXJhZ3JhcGhOdW0gLlxuXG4gICAgT1BUSU9OQUwge1xuICAgICAgP3BhcmFncmFwaCBqb2x1eDppc1JlYWxpemVkQnkgP3BFeHByIC5cbiAgICAgID9wRXhwciBqb2x1eDppc0VtYm9kaWVkQnkgP3BNYW5pZiAuXG4gICAgICA/cE1hbmlmIGpvbHV4OnRleHQgP3BhcmFncmFwaFRleHQgLlxuICAgIH1cbiAgfVxufVxuT1JERVIgQlkgP3BhcmFncmFwaE51bVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBhbiBhcnRpY2xlIHdpdGggc3BlY2lmaWMgcGFyYWdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdldEFydGljbGVQYXJhZ3JhcGhRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgYXJ0aWNsZU51bWJlcjogc3RyaW5nLFxuICBwYXJhZ3JhcGhOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZVxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICBjb25zdCBub3JtYWxpemVkQXJ0aWNsZSA9IGFydGljbGVOdW1iZXIucmVwbGFjZSgvXkFydFxcLj9cXHMqL2ksICcnKS50cmltKCk7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID9wYXJhZ3JhcGggP3BhcmFncmFwaE51bSA/dGV4dFxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6Q29uc29saWRhdGlvbkFic3RyYWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG4gICR7bGFuZ0ZpbHRlcn1cblxuICAjIEZpbmQgYXJ0aWNsZSB2aWEgaW52ZXJzZSByZWxhdGlvbnNoaXBcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgRklMVEVSKFxuICAgIFNUUig/YXJ0aWNsZU51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1cIiB8fFxuICAgIFJFR0VYKFNUUig/YXJ0aWNsZU51bWJlciksIFwiXiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1bYS16XT8kXCIsIFwiaVwiKVxuICApXG5cbiAgIyBGaW5kIHBhcmFncmFwaCB3aXRoaW4gYXJ0aWNsZVxuICA/cGFyYWdyYXBoIGEgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIDtcbiAgICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YXJ0aWNsZSAuXG5cbiAgP3BhcmFncmFwaCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25IYXNTdWJkaXZpc2lvbklkZW50aWZpY2F0aW9uRGV0YWlsID9wRGV0YWlsIC5cbiAgP3BEZXRhaWwgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uRGV0YWlsSWQgP3BhcmFncmFwaE51bSAuXG5cbiAgRklMVEVSKFNUUig/cGFyYWdyYXBoTnVtKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwocGFyYWdyYXBoTnVtYmVyKX1cIilcblxuICAjIEdldCBwYXJhZ3JhcGggdGV4dFxuICBPUFRJT05BTCB7XG4gICAgP3BhcmFncmFwaCBqb2x1eDppc1JlYWxpemVkQnkgP3BFeHByIC5cbiAgICA/cEV4cHIgam9sdXg6aXNFbWJvZGllZEJ5ID9wTWFuaWYgLlxuICAgID9wTWFuaWYgam9sdXg6dGV4dCA/dGV4dCAuXG4gIH1cbn1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBsaXN0IGFsbCBhcnRpY2xlcyBpbiBhbiBhY3RcbiAqXG4gKiBOb3RlOiBGZWRsZXggb25seSBzdG9yZXMgbW9kaWZpZWQgYXJ0aWNsZXMsIG5vdCBhbGwgYXJ0aWNsZXMuXG4gKiBUaGlzIHJldHVybnMgYXJ0aWNsZXMgdGhhdCBoYXZlIGJlZW4gYW1lbmRlZC9tb2RpZmllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGlzdEFydGljbGVzUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDAwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YWN0VGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID90aXRsZSA/YWN0VGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkNvbnNvbGlkYXRpb25BYnN0cmFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/YWN0VGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBGaW5kIGFsbCBhcnRpY2xlIHN1YmRpdmlzaW9ucyBiZWxvbmdpbmcgdG8gdGhpcyBhY3RcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgIyBHZXQgYXJ0aWNsZSBudW1iZXJcbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgIyBHZXQgYXJ0aWNsZSB0aXRsZSBpZiBhdmFpbGFibGVcbiAgT1BUSU9OQUwge1xuICAgID9hcnRpY2xlIGpvbHV4OmlzUmVhbGl6ZWRCeSA/YXJ0aWNsZUV4cHIgLlxuICAgID9hcnRpY2xlRXhwciBqb2x1eDp0aXRsZSA/dGl0bGUgLlxuICAgICR7bGFuZ3VhZ2UgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgIDogJyd9XG4gIH1cbn1cbk9SREVSIEJZIHhzZDppbnRlZ2VyKD9hcnRpY2xlTnVtYmVyKVxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBzZWFyY2ggZm9yIGFydGljbGVzIGNvbnRhaW5pbmcgc3BlY2lmaWMgdGV4dFxuICpcbiAqIFNlYXJjaGVzIGluIGFydGljbGUgdGl0bGVzIChtYXJnaW5hbCBub3RlcykgZnJvbSBleHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2VhcmNoQXJ0aWNsZXNRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgc2VhcmNoVGV4dDogc3RyaW5nLFxuICBsYW5ndWFnZT86IExhbmd1YWdlXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YWN0VGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID90aXRsZSA/YWN0VGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkNvbnNvbGlkYXRpb25BYnN0cmFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/YWN0VGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBGaW5kIGFydGljbGVzXG4gID9hcnRpY2xlIGEgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSXNQYXJ0T2YgP2FjdCA7XG4gICAgICAgICAgIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvblR5cGUgPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9zdWJkaXZpc2lvbi10eXBlL2FydD4gLlxuXG4gICMgR2V0IGFydGljbGUgbnVtYmVyXG4gID9hcnRpY2xlIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkhhc1N1YmRpdmlzaW9uSWRlbnRpZmljYXRpb25EZXRhaWwgP2RldGFpbCAuXG4gID9kZXRhaWwgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uRGV0YWlsSWQgP2FydGljbGVOdW1iZXIgLlxuXG4gICMgR2V0IGFydGljbGUgdGl0bGUgZm9yIHNlYXJjaFxuICA/YXJ0aWNsZSBqb2x1eDppc1JlYWxpemVkQnkgP2FydGljbGVFeHByIC5cbiAgP2FydGljbGVFeHByIGpvbHV4OnRpdGxlID90aXRsZSAuXG4gICR7bGFuZ3VhZ2UgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgIDogJyd9XG5cbiAgIyBTZWFyY2ggaW4gYXJ0aWNsZSB0aXRsZVxuICBGSUxURVIoQ09OVEFJTlMoTENBU0UoU1RSKD90aXRsZSkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKHNlYXJjaFRleHQpfVwiKSkpXG59XG5PUkRFUiBCWSB4c2Q6aW50ZWdlcig/YXJ0aWNsZU51bWJlcilcbkxJTUlUIDUwXG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGFydGljbGUgaGlzdG9yeSAodmVyc2lvbnMgb3ZlciB0aW1lKVxuICpcbiAqIEFydGljbGVzIGluIEZlZGxleCBoYXZlIHRlbXBvcmFsIHZlcnNpb25zIHZpYSBleHByZXNzaW9ucyB3aXRoIGRhdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBcnRpY2xlSGlzdG9yeVF1ZXJ5KFxuICBzck51bWJlcjogc3RyaW5nLFxuICBhcnRpY2xlTnVtYmVyOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBcnRpY2xlID0gYXJ0aWNsZU51bWJlci5yZXBsYWNlKC9eQXJ0XFwuP1xccyovaSwgJycpLnRyaW0oKTtcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YXJ0aWNsZSA/YXJ0aWNsZU51bWJlciA/dmVyc2lvbiA/ZGF0ZSA/bGFuZ3VhZ2VcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkNvbnNvbGlkYXRpb25BYnN0cmFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgIyBGaW5kIGFydGljbGVcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgRklMVEVSKFxuICAgIFNUUig/YXJ0aWNsZU51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1cIiB8fFxuICAgIFJFR0VYKFNUUig/YXJ0aWNsZU51bWJlciksIFwiXiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1bYS16XT8kXCIsIFwiaVwiKVxuICApXG5cbiAgIyBHZXQgdmVyc2lvbiBoaXN0b3J5IHZpYSBleHByZXNzaW9uc1xuICA/YXJ0aWNsZSBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuXG4gICMgR2V0IGRhdGUgYW5kIGxhbmd1YWdlIGZyb20gZXhwcmVzc2lvblxuICBPUFRJT05BTCB7ID92ZXJzaW9uIGpvbHV4OmRhdGVEb2N1bWVudCA/ZGF0ZSB9XG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6bGFuZ3VhZ2UgP2xhbmd1YWdlIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGUpID9sYW5ndWFnZVxuTElNSVQgNTBcbiAgYCk7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUXVlcmllcyBmb3IgTGVnaXNsYXRpb24gU2VhcmNoXG4gKiBGdWxsLXRleHQgYW5kIGZpbHRlcmVkIHNlYXJjaCBhY3Jvc3MgdGhlIGxlZ2lzbGF0aW9uIGNvcnB1cyB1c2luZyBKT0xVWCBvbnRvbG9neVxuICpcbiAqIEZlZGxleCBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiB3b3JrXG4gKiAtIFRpdGxlczogdGF4b25vbXkgc2tvczpwcmVmTGFiZWwgKHdpdGggbGFuZ3VhZ2UgdGFncykgT1IgRXhwcmVzc2lvbiBqb2x1eDp0aXRsZSAobm8gdGFncylcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqL1xuXG5pbXBvcnQgeyB3aXRoUHJlZml4ZXMgfSBmcm9tICcuL3ByZWZpeGVzLmpzJztcbmltcG9ydCB7IGVzY2FwZUZvclNQQVJRTCB9IGZyb20gJy4uL3NwYXJxbC1jbGllbnQuanMnO1xuaW1wb3J0IHsgTGFuZ3VhZ2UsIFNlYXJjaEZpbHRlcnMgfSBmcm9tICcuLi90eXBlcy9sZWdpc2xhdGlvbi5qcyc7XG5cbi8qKlxuICogQnVpbGQgYSBmdWxsLXRleHQgc2VhcmNoIHF1ZXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlYXJjaFF1ZXJ5KFxuICBzZWFyY2hUZXh0OiBzdHJpbmcsXG4gIGZpbHRlcnM6IFNlYXJjaEZpbHRlcnMgPSB7fVxuKTogc3RyaW5nIHtcbiAgY29uc3Qge1xuICAgIGxhbmd1YWdlLFxuICAgIGFjdFR5cGUsXG4gICAgLy8gc3RhdHVzIGZpbHRlciBub3QgeWV0IGltcGxlbWVudGVkIC0gRmVkbGV4IHVzZXMgam9sdXg6aW5Gb3JjZSB2b2NhYnVsYXJ5XG4gICAgc3JOdW1iZXJQcmVmaXgsXG4gICAgbGltaXQgPSA1MCxcbiAgICBvZmZzZXQgPSAwLFxuICB9ID0gZmlsdGVycztcblxuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIGNvbnN0IHNyUHJlZml4RmlsdGVyID0gc3JOdW1iZXJQcmVmaXhcbiAgICA/IGBGSUxURVIoU1RSU1RBUlRTKFNUUig/c3JOdW1iZXIpLCBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyUHJlZml4KX1cIikpYFxuICAgIDogJyc7XG5cbiAgY29uc3QgYWN0VHlwZUZpbHRlciA9IGFjdFR5cGUgJiYgYWN0VHlwZS5sZW5ndGggPiAwXG4gICAgPyBgRklMVEVSKD9hY3RUeXBlIElOICgke2FjdFR5cGUubWFwKHQgPT4gYFwiJHt0fVwiYCkuam9pbignLCAnKX0pKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9hY3RUeXBlID9kYXRlSW5Gb3JjZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgIyBHZXQgU1IgbnVtYmVyIGZyb20gdGF4b25vbXlcbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cblxuICAjIEdldCB0aXRsZSBmcm9tIHRheG9ub215IHByZWZMYWJlbCAoaGFzIGxhbmd1YWdlIHRhZ3MpXG4gID90YXhvbm9teSBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gICMgVGV4dCBzZWFyY2ggaW4gdGl0bGUgb3IgU1IgbnVtYmVyXG4gIEZJTFRFUihcbiAgICBDT05UQUlOUyhMQ0FTRShTVFIoP3RpdGxlKSksIExDQVNFKFwiJHtlc2NhcGVGb3JTUEFSUUwoc2VhcmNoVGV4dCl9XCIpKSB8fFxuICAgIENPTlRBSU5TKExDQVNFKFNUUig/c3JOdW1iZXIpKSwgTENBU0UoXCIke2VzY2FwZUZvclNQQVJRTChzZWFyY2hUZXh0KX1cIikpXG4gIClcblxuICAke2xhbmdGaWx0ZXJ9XG4gICR7c3JQcmVmaXhGaWx0ZXJ9XG4gICR7YWN0VHlwZUZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YWN0VHlwZSB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlRW50cnlJbkZvcmNlID9kYXRlSW5Gb3JjZSB9XG59XG5PUkRFUiBCWSA/c3JOdW1iZXJcbk9GRlNFVCAke29mZnNldH1cbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgc2VhcmNoIHF1ZXJ5IGZvciBjb3VudGluZyByZXN1bHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlYXJjaENvdW50UXVlcnkoXG4gIHNlYXJjaFRleHQ6IHN0cmluZyxcbiAgZmlsdGVyczogU2VhcmNoRmlsdGVycyA9IHt9XG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGxhbmd1YWdlLCBzck51bWJlclByZWZpeCwgYWN0VHlwZSB9ID0gZmlsdGVycztcblxuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIGNvbnN0IHNyUHJlZml4RmlsdGVyID0gc3JOdW1iZXJQcmVmaXhcbiAgICA/IGBGSUxURVIoU1RSU1RBUlRTKFNUUig/c3JOdW1iZXIpLCBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyUHJlZml4KX1cIikpYFxuICAgIDogJyc7XG5cbiAgY29uc3QgYWN0VHlwZUZpbHRlciA9IGFjdFR5cGUgJiYgYWN0VHlwZS5sZW5ndGggPiAwXG4gICAgPyBgRklMVEVSKD9hY3RUeXBlIElOICgke2FjdFR5cGUubWFwKHQgPT4gYFwiJHt0fVwiYCkuam9pbignLCAnKX0pKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIChDT1VOVChESVNUSU5DVCA/YWN0KSBBUyA/Y291bnQpXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgO1xuICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP3RpdGxlIC5cblxuICBGSUxURVIoXG4gICAgQ09OVEFJTlMoTENBU0UoU1RSKD90aXRsZSkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKHNlYXJjaFRleHQpfVwiKSkgfHxcbiAgICBDT05UQUlOUyhMQ0FTRShTVFIoP3NyTnVtYmVyKSksIExDQVNFKFwiJHtlc2NhcGVGb3JTUEFSUUwoc2VhcmNoVGV4dCl9XCIpKVxuICApXG5cbiAgJHtsYW5nRmlsdGVyfVxuICAke3NyUHJlZml4RmlsdGVyfVxuICAke2FjdFR5cGVGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YWN0VHlwZSB9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgc2VhcmNoIHF1ZXJ5IGJ5IGxlZ2FsIGRvbWFpbiAoU1IgbnVtYmVyIHByZWZpeClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2VhcmNoQnlEb21haW5RdWVyeShcbiAgZG9tYWluOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDBcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgLy8gRG9tYWluIGNvZGVzIG1hcCB0byBTUiBudW1iZXIgcHJlZml4ZXM6XG4gIC8vIDEgPSBDb25zdGl0dXRpb25hbCBsYXcsIDIgPSBQcml2YXRlIGxhdywgMyA9IENyaW1pbmFsIGxhdywgZXRjLlxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YWN0ID9zck51bWJlciA/dGl0bGUgP2FiYnJldmlhdGlvblxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUlNUQVJUUyhTVFIoP3NyTnVtYmVyKSwgXCIke2VzY2FwZUZvclNQQVJRTChkb21haW4pfVwiKSlcbiAgJHtsYW5nRmlsdGVyfVxuXG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gfVxufVxuT1JERVIgQlkgP3NyTnVtYmVyXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHNlYXJjaCBxdWVyeSBieSBkYXRlIHJhbmdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlYXJjaEJ5RGF0ZVF1ZXJ5KFxuICBkYXRlRnJvbT86IHN0cmluZyxcbiAgZGF0ZVRvPzogc3RyaW5nLFxuICBsYW5ndWFnZT86IExhbmd1YWdlLFxuICBsaW1pdDogbnVtYmVyID0gNTBcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgbGV0IGRhdGVGaWx0ZXIgPSAnJztcbiAgaWYgKGRhdGVGcm9tICYmIGRhdGVUbykge1xuICAgIGRhdGVGaWx0ZXIgPSBgRklMVEVSKD9kYXRlSW5Gb3JjZSA+PSBcIiR7ZGF0ZUZyb219XCJeXnhzZDpkYXRlICYmID9kYXRlSW5Gb3JjZSA8PSBcIiR7ZGF0ZVRvfVwiXl54c2Q6ZGF0ZSlgO1xuICB9IGVsc2UgaWYgKGRhdGVGcm9tKSB7XG4gICAgZGF0ZUZpbHRlciA9IGBGSUxURVIoP2RhdGVJbkZvcmNlID49IFwiJHtkYXRlRnJvbX1cIl5eeHNkOmRhdGUpYDtcbiAgfSBlbHNlIGlmIChkYXRlVG8pIHtcbiAgICBkYXRlRmlsdGVyID0gYEZJTFRFUig/ZGF0ZUluRm9yY2UgPD0gXCIke2RhdGVUb31cIl5eeHNkOmRhdGUpYDtcbiAgfVxuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9kYXRlSW5Gb3JjZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSA7XG4gICAgICAgam9sdXg6ZGF0ZUVudHJ5SW5Gb3JjZSA/ZGF0ZUluRm9yY2UgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gICR7ZGF0ZUZpbHRlcn1cbiAgJHtsYW5nRmlsdGVyfVxuXG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gfVxufVxuT1JERVIgQlkgREVTQyg/ZGF0ZUluRm9yY2UpXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHNlYXJjaCBxdWVyeSBmb3IgcmVjZW50bHkgbW9kaWZpZWQgbGVnaXNsYXRpb25cbiAqXG4gKiBVc2VzIGRjdGVybXM6bW9kaWZpZWQgd2hpY2ggaXMgdGhlIGFjdHVhbCBtb2RpZmljYXRpb24gdGltZXN0YW1wIGluIEZlZGxleC5cbiAqIFNlYXJjaGVzIGJvdGggam9sdXg6QWN0IChvZmZpY2lhbCBjb2xsZWN0aW9uKSBhbmQgam9sdXg6Q29uc29saWRhdGlvbkFic3RyYWN0IChjb25zb2xpZGF0ZWQgbGF3cykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJlY2VudGx5TW9kaWZpZWRRdWVyeShcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDIwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9kYXRlTW9kaWZpZWRcbldIRVJFIHtcbiAgIyBNYXRjaCBib3RoIEFjdCAob2ZmaWNpYWwgY29sbGVjdGlvbikgYW5kIENvbnNvbGlkYXRpb25BYnN0cmFjdCAoY29uc29saWRhdGVkKVxuICA/YWN0IGEgP2FjdFR5cGUgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IDtcbiAgICAgICBkY3Rlcm1zOm1vZGlmaWVkID9kYXRlTW9kaWZpZWQgLlxuXG4gIEZJTFRFUig/YWN0VHlwZSBJTiAoam9sdXg6QWN0LCBqb2x1eDpDb25zb2xpZGF0aW9uQWJzdHJhY3QpKVxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gICR7bGFuZ0ZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGVNb2RpZmllZClcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEga2V5d29yZCBzZWFyY2ggcXVlcnkgKHVzaW5nIFNLT1MgY29uY2VwdHMgZnJvbSB0YXhvbm9teSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkS2V5d29yZFNlYXJjaFF1ZXJ5KFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YWN0ID9zck51bWJlciA/dGl0bGUgP2FiYnJldmlhdGlvbiA/a2V5d29yZFxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgIyBTZWFyY2ggaW4gdGF4b25vbXkgYnJvYWRlciBjb25jZXB0cyBhbmQga2V5d29yZHNcbiAge1xuICAgID90YXhvbm9teSBza29zOmJyb2FkZXIqID9icm9hZGVyVGF4IC5cbiAgICA/YnJvYWRlclRheCBza29zOnByZWZMYWJlbCA/a2V5d29yZCAuXG4gICAgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/a2V5d29yZCkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKGtleXdvcmQpfVwiKSkpXG4gIH0gVU5JT04ge1xuICAgICMgU2VhcmNoIGluIHN1YmplY3Qva2V5d29yZCBhbm5vdGF0aW9uc1xuICAgID9hY3QgZGN0ZXJtczpzdWJqZWN0ID9zdWJqZWN0IC5cbiAgICA/c3ViamVjdCBza29zOnByZWZMYWJlbCA/a2V5d29yZCAuXG4gICAgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/a2V5d29yZCkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKGtleXdvcmQpfVwiKSkpXG4gIH1cblxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnRpdGxlU2hvcnQgP2FiYnJldmlhdGlvbiB9XG59XG5PUkRFUiBCWSA/c3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIExlZ2FsIGRvbWFpbiBtYXBwaW5nIChTUiBudW1iZXIgcHJlZml4ZXMpXG4gKi9cbmV4cG9ydCBjb25zdCBMRUdBTF9ET01BSU5TOiBSZWNvcmQ8c3RyaW5nLCB7IGRlOiBzdHJpbmc7IGZyOiBzdHJpbmc7IGl0OiBzdHJpbmcgfT4gPSB7XG4gICcxJzogeyBkZTogJ1N0YWF0IC0gVm9sayAtIEJlaFx1MDBGNnJkZW4nLCBmcjogJ1x1MDBDOXRhdCAtIFBldXBsZSAtIEF1dG9yaXRcdTAwRTlzJywgaXQ6ICdTdGF0byAtIFBvcG9sbyAtIEF1dG9yaXRcdTAwRTAnIH0sXG4gICcyJzogeyBkZTogJ1ByaXZhdHJlY2h0IC0gWml2aWxyZWNodHNwZmxlZ2UgLSBWb2xsc3RyZWNrdW5nJywgZnI6ICdEcm9pdCBwcml2XHUwMEU5IC0gUHJvY1x1MDBFOWR1cmUgY2l2aWxlIC0gRXhcdTAwRTljdXRpb24gZm9yY1x1MDBFOWUnLCBpdDogJ0Rpcml0dG8gcHJpdmF0byAtIFByb2NlZHVyYSBjaXZpbGUgLSBFc2VjdXppb25lJyB9LFxuICAnMyc6IHsgZGU6ICdTdHJhZnJlY2h0IC0gU3RyYWZyZWNodHNwZmxlZ2UgLSBTdHJhZnZvbGx6dWcnLCBmcjogJ0Ryb2l0IHBcdTAwRTluYWwgLSBQcm9jXHUwMEU5ZHVyZSBwXHUwMEU5bmFsZSAtIEV4XHUwMEU5Y3V0aW9uIGRlcyBwZWluZXMnLCBpdDogJ0Rpcml0dG8gcGVuYWxlIC0gUHJvY2VkdXJhIHBlbmFsZSAtIEVzZWN1emlvbmUgZGVsbGUgcGVuZScgfSxcbiAgJzQnOiB7IGRlOiAnU2NodWxlIC0gV2lzc2Vuc2NoYWZ0IC0gS3VsdHVyJywgZnI6ICdcdTAwQzljb2xlIC0gU2NpZW5jZSAtIEN1bHR1cmUnLCBpdDogJ1NjdW9sYSAtIFNjaWVuemEgLSBDdWx0dXJhJyB9LFxuICAnNSc6IHsgZGU6ICdMYW5kZXN2ZXJ0ZWlkaWd1bmcnLCBmcjogJ0RcdTAwRTlmZW5zZSBuYXRpb25hbGUnLCBpdDogJ0RpZmVzYSBuYXppb25hbGUnIH0sXG4gICc2JzogeyBkZTogJ0ZpbmFuemVuJywgZnI6ICdGaW5hbmNlcycsIGl0OiAnRmluYW56ZScgfSxcbiAgJzcnOiB7IGRlOiAnXHUwMEQ2ZmZlbnRsaWNoZSBXZXJrZSAtIEVuZXJnaWUgLSBWZXJrZWhyJywgZnI6ICdUcmF2YXV4IHB1YmxpY3MgLSBcdTAwQzluZXJnaWUgLSBUcmFuc3BvcnRzJywgaXQ6ICdMYXZvcmkgcHViYmxpY2kgLSBFbmVyZ2lhIC0gVHJhc3BvcnRpJyB9LFxuICAnOCc6IHsgZGU6ICdHZXN1bmRoZWl0IC0gQXJiZWl0IC0gU296aWFsZSBTaWNoZXJoZWl0JywgZnI6ICdTYW50XHUwMEU5IC0gVHJhdmFpbCAtIFNcdTAwRTljdXJpdFx1MDBFOSBzb2NpYWxlJywgaXQ6ICdTYW5pdFx1MDBFMCAtIExhdm9ybyAtIFNpY3VyZXp6YSBzb2NpYWxlJyB9LFxuICAnOSc6IHsgZGU6ICdXaXJ0c2NoYWZ0IC0gVGVjaG5pc2NoZSBadXNhbW1lbmFyYmVpdCcsIGZyOiAnXHUwMEM5Y29ub21pZSAtIENvb3BcdTAwRTlyYXRpb24gdGVjaG5pcXVlJywgaXQ6ICdFY29ub21pYSAtIENvb3BlcmF6aW9uZSB0ZWNuaWNhJyB9LFxufTtcbiIsICIvKipcbiAqIFNQQVJRTCBRdWVyaWVzIGZvciBSZWxhdGVkIExlZ2lzbGF0aW9uXG4gKiBRdWVyaWVzIHRvIGZpbmQgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGxlZ2FsIGFjdHMgdXNpbmcgSk9MVVggb250b2xvZ3lcbiAqXG4gKiBGZWRsZXggRGF0YSBNb2RlbCAoRlJCUi1iYXNlZCk6XG4gKiAtIGpvbHV4OkFjdCA9IFByaW1hcnkgbGVnaXNsYXRpb24gd29ya1xuICogLSBSZWxhdGlvbnNoaXBzOiBqb2x1eDpsZWdhbFJlc291cmNlTGVnYWxSZXNvdXJjZUFtZW5kZWRCeSwgZXRjLlxuICogLSBTUiBudW1iZXJzIHZpYSB0YXhvbm9teTogam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSBcdTIxOTIgc2tvczpub3RhdGlvblxuICpcbiAqIE5vdGU6IEpPTFVYIHVzZXMgZGlmZmVyZW50IHJlbGF0aW9uc2hpcCBwcmVkaWNhdGVzIHRoYW4gRUxJLlxuICogU29tZSByZWxhdGlvbnNoaXBzIGFyZSBtb2RlbGVkIHZpYSBjb25zb2xpZGF0aW9uIGxpbmtzIG9yIGltcGFjdCBlbnRyaWVzLlxuICovXG5cbmltcG9ydCB7IHdpdGhQcmVmaXhlcyB9IGZyb20gJy4vcHJlZml4ZXMuanMnO1xuaW1wb3J0IHsgZXNjYXBlRm9yU1BBUlFMIH0gZnJvbSAnLi4vc3BhcnFsLWNsaWVudC5qcyc7XG5pbXBvcnQgeyBMYW5ndWFnZSwgUmVsYXRpb25UeXBlIH0gZnJvbSAnLi4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3RzIHRoYXQgYW1lbmQgYSBzcGVjaWZpYyBhY3RcbiAqIEluIEpPTFVYLCBhbWVuZG1lbnRzIGFyZSB0cmFja2VkIHZpYSBjb25zb2xpZGF0aW9uL2ltcGFjdCBlbnRyaWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEZpbmRBbWVuZGluZ0FjdHNRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDUwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YW1lbmRpbmdUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FtZW5kaW5nQWN0ID9hbWVuZGluZ1NyTnVtYmVyID9hbWVuZGluZ1RpdGxlID9hbWVuZG1lbnREYXRlID9hbWVuZG1lbnRUeXBlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEZpbmQgYWN0cyB0aGF0IGFtZW5kIHRoaXMgYWN0IHZpYSBjb25zb2xpZGF0aW9uIGxpbmtzXG4gICMgSk9MVVggdXNlcyBsZWdhbFJlc291cmNlSW1wYWN0SGFzTGVnYWxSZXNvdXJjZSBvciBzaW1pbGFyIHByZWRpY2F0ZXNcbiAge1xuICAgID9pbXBhY3RFbnRyeSBqb2x1eDpsZWdhbFJlc291cmNlSW1wYWN0SGFzTGVnYWxSZXNvdXJjZSA/YWN0IC5cbiAgICA/aW1wYWN0RW50cnkgam9sdXg6aW1wYWN0RnJvbUxlZ2FsUmVzb3VyY2UgP2FtZW5kaW5nQWN0IC5cbiAgfSBVTklPTiB7XG4gICAgIyBBbHRlcm5hdGl2ZTogZGlyZWN0IGFtZW5kbWVudCByZWxhdGlvbnNoaXAgaWYgYXZhaWxhYmxlXG4gICAgP2FtZW5kaW5nQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQW1lbmRzID9hY3QgLlxuICB9XG5cbiAgP2FtZW5kaW5nQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP2FtZW5kaW5nVGF4IC5cblxuICA/YW1lbmRpbmdUYXggc2tvczpub3RhdGlvbiA/YW1lbmRpbmdTck51bWJlciA7XG4gICAgICAgICAgICAgICBza29zOnByZWZMYWJlbCA/YW1lbmRpbmdUaXRsZSAuXG5cbiAgJHtsYW5nRmlsdGVyfVxuXG4gIE9QVElPTkFMIHsgP2FtZW5kaW5nQWN0IGpvbHV4OmRhdGVEb2N1bWVudCA/YW1lbmRtZW50RGF0ZSB9XG4gIE9QVElPTkFMIHsgP2FtZW5kaW5nQWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YW1lbmRtZW50VHlwZSB9XG59XG5PUkRFUiBCWSBERVNDKD9hbWVuZG1lbnREYXRlKVxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBmaW5kIGFjdHMgYW1lbmRlZCBieSBhIHNwZWNpZmljIGFjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kQW1lbmRlZEFjdHNRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDUwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YW1lbmRlZFRpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YW1lbmRlZEFjdCA/YW1lbmRlZFNyTnVtYmVyID9hbWVuZGVkVGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgRmluZCBhY3RzIGFtZW5kZWQgYnkgdGhpcyBhY3RcbiAge1xuICAgID9pbXBhY3RFbnRyeSBqb2x1eDppbXBhY3RGcm9tTGVnYWxSZXNvdXJjZSA/YWN0IC5cbiAgICA/aW1wYWN0RW50cnkgam9sdXg6bGVnYWxSZXNvdXJjZUltcGFjdEhhc0xlZ2FsUmVzb3VyY2UgP2FtZW5kZWRBY3QgLlxuICB9IFVOSU9OIHtcbiAgICA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQW1lbmRzID9hbWVuZGVkQWN0IC5cbiAgfVxuXG4gID9hbWVuZGVkQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/YW1lbmRlZFRheCAuXG5cbiAgP2FtZW5kZWRUYXggc2tvczpub3RhdGlvbiA/YW1lbmRlZFNyTnVtYmVyIDtcbiAgICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP2FtZW5kZWRUaXRsZSAuXG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuT1JERVIgQlkgP2FtZW5kZWRTck51bWJlclxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBmaW5kIGFjdHMgdGhhdCByZWZlcmVuY2UgYSBzcGVjaWZpYyBhY3RcbiAqIEluIEpPTFVYLCByZWZlcmVuY2VzIGFyZSB0cmFja2VkIHZpYSBjaXRhdGlvbi9jcm9zcy1yZWZlcmVuY2UgZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kUmVmZXJlbmNpbmdBY3RzUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlZmVyZW5jaW5nVGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9yZWZlcmVuY2luZ0FjdCA/cmVmZXJlbmNpbmdTck51bWJlciA/cmVmZXJlbmNpbmdUaXRsZSA/cmVmZXJlbmNlVHlwZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgIyBGaW5kIGFjdHMgdGhhdCByZWZlcmVuY2UgdGhpcyBhY3QgdmlhIHZhcmlvdXMgcmVsYXRpb25zaGlwIHR5cGVzXG4gIHtcbiAgICA/cmVmZXJlbmNpbmdBY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VDaXRlcyA/YWN0IC5cbiAgICBCSU5EKFwiY2l0ZXNcIiBBUyA/cmVmZXJlbmNlVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgP3JlZmVyZW5jaW5nQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/YWN0IC5cbiAgICBCSU5EKFwiYmFzZWRfb25cIiBBUyA/cmVmZXJlbmNlVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgP3JlZmVyZW5jaW5nQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlSW1wbGVtZW50cyA/YWN0IC5cbiAgICBCSU5EKFwiaW1wbGVtZW50c1wiIEFTID9yZWZlcmVuY2VUeXBlKVxuICB9XG5cbiAgP3JlZmVyZW5jaW5nQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3JlZlRheCAuXG5cbiAgP3JlZlRheCBza29zOm5vdGF0aW9uID9yZWZlcmVuY2luZ1NyTnVtYmVyIDtcbiAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVmZXJlbmNpbmdUaXRsZSAuXG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuT1JERVIgQlkgP3JlZmVyZW5jaW5nU3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3RzIHJlZmVyZW5jZWQgYnkgYSBzcGVjaWZpYyBhY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRmluZFJlZmVyZW5jZWRBY3RzUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlZmVyZW5jZWRUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3JlZmVyZW5jZWRBY3QgP3JlZmVyZW5jZWRTck51bWJlciA/cmVmZXJlbmNlZFRpdGxlID9yZWZlcmVuY2VUeXBlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEZpbmQgYWN0cyByZWZlcmVuY2VkIGJ5IHRoaXMgYWN0XG4gIHtcbiAgICA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQ2l0ZXMgP3JlZmVyZW5jZWRBY3QgLlxuICAgIEJJTkQoXCJjaXRlc1wiIEFTID9yZWZlcmVuY2VUeXBlKVxuICB9IFVOSU9OIHtcbiAgICA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/cmVmZXJlbmNlZEFjdCAuXG4gICAgQklORChcImJhc2VkX29uXCIgQVMgP3JlZmVyZW5jZVR5cGUpXG4gIH0gVU5JT04ge1xuICAgID9hY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VJbXBsZW1lbnRzID9yZWZlcmVuY2VkQWN0IC5cbiAgICBCSU5EKFwiaW1wbGVtZW50c1wiIEFTID9yZWZlcmVuY2VUeXBlKVxuICB9XG5cbiAgP3JlZmVyZW5jZWRBY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgICAgICAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID9yZWZUYXggLlxuXG4gID9yZWZUYXggc2tvczpub3RhdGlvbiA/cmVmZXJlbmNlZFNyTnVtYmVyIDtcbiAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVmZXJlbmNlZFRpdGxlIC5cblxuICAke2xhbmdGaWx0ZXJ9XG59XG5PUkRFUiBCWSA/cmVmZXJlbmNlZFNyTnVtYmVyXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGZpbmQgcmVsYXRlZCBhY3RzIGluIHRoZSBzYW1lIGxlZ2FsIGRvbWFpblxuICogVXNlcyB0YXhvbm9teSBoaWVyYXJjaHkgZm9yIGRvbWFpbiBtYXRjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kUmVsYXRlZEJ5RG9tYWluUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAyMFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlbGF0ZWRUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3JlbGF0ZWRBY3QgP3JlbGF0ZWRTck51bWJlciA/cmVsYXRlZFRpdGxlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEdldCB0aGUgZG9tYWluIHByZWZpeCAoZmlyc3QgZGlnaXQocykgb2YgU1IgbnVtYmVyKVxuICBCSU5EKFJFUExBQ0UoU1RSKD9zck51bWJlciksIFwiXihbMC05XSspXFxcXFxcXFwuLipcIiwgXCIkMVwiKSBBUyA/ZG9tYWluUHJlZml4KVxuXG4gICMgRmluZCBhY3RzIGluIHRoZSBzYW1lIGRvbWFpbiB2aWEgdGF4b25vbXlcbiAgP3JlbGF0ZWRBY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgICAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID9yZWxhdGVkVGF4IC5cblxuICA/cmVsYXRlZFRheCBza29zOm5vdGF0aW9uID9yZWxhdGVkU3JOdW1iZXIgO1xuICAgICAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVsYXRlZFRpdGxlIC5cblxuICBGSUxURVIoP3JlbGF0ZWRBY3QgIT0gP2FjdClcbiAgRklMVEVSKFNUUlNUQVJUUyhTVFIoP3JlbGF0ZWRTck51bWJlciksID9kb21haW5QcmVmaXgpKVxuXG4gICR7bGFuZ0ZpbHRlcn1cbn1cbk9SREVSIEJZID9yZWxhdGVkU3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3RzIHdpdGggc2hhcmVkIGtleXdvcmRzL3N1YmplY3RzXG4gKiBVc2VzIHRheG9ub215IGJyb2FkZXIgY29uY2VwdHMgZm9yIHN1YmplY3QgbWF0Y2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRmluZFJlbGF0ZWRCeVN1YmplY3RRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDIwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/cmVsYXRlZFRpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/cmVsYXRlZEFjdCA/cmVsYXRlZFNyTnVtYmVyID9yZWxhdGVkVGl0bGUgP3NoYXJlZFN1YmplY3RcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgR2V0IHN1YmplY3QgdmlhIHRheG9ub215IG9yIGRjdGVybXM6c3ViamVjdFxuICB7XG4gICAgP3RheG9ub215IHNrb3M6YnJvYWRlciA/c3ViamVjdCAuXG4gIH0gVU5JT04ge1xuICAgID9hY3QgZGN0ZXJtczpzdWJqZWN0ID9zdWJqZWN0IC5cbiAgfVxuXG4gICMgRmluZCBhY3RzIHdpdGggdGhlIHNhbWUgc3ViamVjdFxuICB7XG4gICAgP3JlbGF0ZWRBY3Qgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/cmVsYXRlZFRheCAuXG4gICAgP3JlbGF0ZWRUYXggc2tvczpicm9hZGVyID9zdWJqZWN0IC5cbiAgfSBVTklPTiB7XG4gICAgP3JlbGF0ZWRBY3QgZGN0ZXJtczpzdWJqZWN0ID9zdWJqZWN0IC5cbiAgfVxuXG4gID9yZWxhdGVkQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/cmVsYXRlZFRheE1haW4gLlxuXG4gID9yZWxhdGVkVGF4TWFpbiBza29zOm5vdGF0aW9uID9yZWxhdGVkU3JOdW1iZXIgO1xuICAgICAgICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP3JlbGF0ZWRUaXRsZSAuXG5cbiAgRklMVEVSKD9yZWxhdGVkQWN0ICE9ID9hY3QpXG5cbiAgT1BUSU9OQUwgeyA/c3ViamVjdCBza29zOnByZWZMYWJlbCA/c2hhcmVkU3ViamVjdCB9XG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuT1JERVIgQlkgP3JlbGF0ZWRTck51bWJlclxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBjb21wcmVoZW5zaXZlIHF1ZXJ5IHRvIGZpbmQgYWxsIHJlbGF0ZWQgYWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kQWxsUmVsYXRlZFF1ZXJ5KFxuICBzck51bWJlcjogc3RyaW5nLFxuICByZWxhdGlvblR5cGU/OiBSZWxhdGlvblR5cGUsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlbGF0ZWRUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgLy8gSWYgc3BlY2lmaWMgcmVsYXRpb24gdHlwZSByZXF1ZXN0ZWQsIGJ1aWxkIHRhcmdldGVkIHF1ZXJ5XG4gIGlmIChyZWxhdGlvblR5cGUpIHtcbiAgICBzd2l0Y2ggKHJlbGF0aW9uVHlwZSkge1xuICAgICAgY2FzZSAnYW1lbmRzJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkRmluZEFtZW5kaW5nQWN0c1F1ZXJ5KHNyTnVtYmVyLCBsYW5ndWFnZSwgbGltaXQpO1xuICAgICAgY2FzZSAnYW1lbmRlZF9ieSc6XG4gICAgICAgIHJldHVybiBidWlsZEZpbmRBbWVuZGVkQWN0c1F1ZXJ5KHNyTnVtYmVyLCBsYW5ndWFnZSwgbGltaXQpO1xuICAgICAgY2FzZSAnY2l0ZXMnOlxuICAgICAgY2FzZSAnY2l0ZWRfYnknOlxuICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICBjYXNlICdpbXBsZW1lbnRlZF9ieSc6XG4gICAgICBjYXNlICdiYXNlZF9vbic6XG4gICAgICAgIHJldHVybiBidWlsZEZpbmRSZWZlcmVuY2luZ0FjdHNRdWVyeShzck51bWJlciwgbGFuZ3VhZ2UsIGxpbWl0KTtcbiAgICAgIGNhc2UgJ3NhbWVfZG9tYWluJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkRmluZFJlbGF0ZWRCeURvbWFpblF1ZXJ5KHNyTnVtYmVyLCBsYW5ndWFnZSwgbGltaXQpO1xuICAgICAgY2FzZSAnc2FtZV9zdWJqZWN0JzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkRmluZFJlbGF0ZWRCeVN1YmplY3RRdWVyeShzck51bWJlciwgbGFuZ3VhZ2UsIGxpbWl0KTtcbiAgICB9XG4gIH1cblxuICAvLyBEZWZhdWx0OiByZXR1cm4gYWxsIHJlbGF0aW9uc2hpcHMgdmlhIGltcGFjdC9jb25zb2xpZGF0aW9uIGxpbmtzXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9yZWxhdGVkQWN0ID9yZWxhdGVkU3JOdW1iZXIgP3JlbGF0ZWRUaXRsZSA/cmVsYXRpb25UeXBlID9yZWxhdGlvbkRhdGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gIHtcbiAgICAjIEFtZW5kaW5nIGFjdHMgKHZpYSBpbXBhY3QgZW50cmllcylcbiAgICA/aW1wYWN0RW50cnkgam9sdXg6aW1wYWN0RnJvbUxlZ2FsUmVzb3VyY2UgP3JlbGF0ZWRBY3QgLlxuICAgID9pbXBhY3RFbnRyeSBqb2x1eDpsZWdhbFJlc291cmNlSW1wYWN0SGFzTGVnYWxSZXNvdXJjZSA/YWN0IC5cbiAgICBCSU5EKFwiYW1lbmRzXCIgQVMgP3JlbGF0aW9uVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgIyBBbWVuZGVkIGFjdHNcbiAgICA/aW1wYWN0RW50cnkgam9sdXg6aW1wYWN0RnJvbUxlZ2FsUmVzb3VyY2UgP2FjdCAuXG4gICAgP2ltcGFjdEVudHJ5IGpvbHV4OmxlZ2FsUmVzb3VyY2VJbXBhY3RIYXNMZWdhbFJlc291cmNlID9yZWxhdGVkQWN0IC5cbiAgICBCSU5EKFwiYW1lbmRlZF9ieVwiIEFTID9yZWxhdGlvblR5cGUpXG4gIH0gVU5JT04ge1xuICAgICMgQ2l0aW5nIGFjdHNcbiAgICA/cmVsYXRlZEFjdCBqb2x1eDpsZWdhbFJlc291cmNlTGVnYWxSZXNvdXJjZUNpdGVzID9hY3QgLlxuICAgIEJJTkQoXCJjaXRlc1wiIEFTID9yZWxhdGlvblR5cGUpXG4gIH0gVU5JT04ge1xuICAgICMgQ2l0ZWQgYWN0c1xuICAgID9hY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VDaXRlcyA/cmVsYXRlZEFjdCAuXG4gICAgQklORChcImNpdGVkX2J5XCIgQVMgP3JlbGF0aW9uVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgIyBCYXNlZCBvblxuICAgID9yZWxhdGVkQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/YWN0IC5cbiAgICBCSU5EKFwiYmFzZWRfb25cIiBBUyA/cmVsYXRpb25UeXBlKVxuICB9XG5cbiAgP3JlbGF0ZWRBY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgICAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID9yZWxhdGVkVGF4IC5cblxuICA/cmVsYXRlZFRheCBza29zOm5vdGF0aW9uID9yZWxhdGVkU3JOdW1iZXIgO1xuICAgICAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVsYXRlZFRpdGxlIC5cblxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/cmVsYXRlZEFjdCBqb2x1eDpkYXRlRG9jdW1lbnQgP3JlbGF0aW9uRGF0ZSB9XG59XG5PUkRFUiBCWSA/cmVsYXRpb25UeXBlID9yZWxhdGVkU3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IHRoZSBsZWdpc2xhdGl2ZSBoaXN0b3J5IChjb25zb2xpZGF0aW9uIGNoYWluKVxuICogSW4gSk9MVVgsIGNvbnNvbGlkYXRpb25zIGFyZSB0cmFja2VkIHZpYSBqb2x1eDppc1JlYWxpemVkQnkgZXhwcmVzc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGVnaXNsYXRpdmVIaXN0b3J5UXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2Vcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3ZlcnNpb24gP2RhdGUgP3RpdGxlID9jaGFuZ2VEZXNjcmlwdGlvblxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG4gICR7bGFuZ0ZpbHRlcn1cblxuICAjIEdldCBhbGwgdmVyc2lvbnMvZXhwcmVzc2lvbnMgaW4gdGhlIGNvbnNvbGlkYXRpb25cbiAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuICA/dmVyc2lvbiBqb2x1eDpkYXRlRG9jdW1lbnQgP2RhdGUgLlxuXG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6dGl0bGUgP2NoYW5nZURlc2NyaXB0aW9uIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGUpXG5MSU1JVCAxMDBcbiAgYCk7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUXVlcmllcyBmb3IgTGVnaXNsYXRpb24gTWV0YWRhdGFcbiAqIFF1ZXJpZXMgdG8gcmV0cmlldmUgZGV0YWlsZWQgbWV0YWRhdGEgYWJvdXQgbGVnYWwgYWN0cyB1c2luZyBKT0xVWCBvbnRvbG9neVxuICpcbiAqIEZlZGxleCBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiB3b3JrXG4gKiAtIGpvbHV4OkV4cHJlc3Npb24gPSBMYW5ndWFnZS1zcGVjaWZpYyByZWFsaXphdGlvbiAodmlhIGpvbHV4OmlzUmVhbGl6ZWRCeSlcbiAqIC0gam9sdXg6TWFuaWZlc3RhdGlvbiA9IFBoeXNpY2FsIGZvcm1hdCAodmlhIGpvbHV4OmlzRW1ib2RpZWRCeSlcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqIC0gVGl0bGVzOiB0YXhvbm9teSBza29zOnByZWZMYWJlbCAod2l0aCBsYW5ndWFnZSB0YWdzKVxuICovXG5cbmltcG9ydCB7IHdpdGhQcmVmaXhlcyB9IGZyb20gJy4vcHJlZml4ZXMuanMnO1xuaW1wb3J0IHsgZXNjYXBlRm9yU1BBUlFMIH0gZnJvbSAnLi4vc3BhcnFsLWNsaWVudC5qcyc7XG5pbXBvcnQgeyBMYW5ndWFnZSB9IGZyb20gJy4uL3R5cGVzL2xlZ2lzbGF0aW9uLmpzJztcblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBjb21wcmVoZW5zaXZlIG1ldGFkYXRhIGZvciBhIGxlZ2FsIGFjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRNZXRhZGF0YVF1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcsIGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9hY3RUeXBlID9kYXRlRG9jdW1lbnQgP2RhdGVJbkZvcmNlXG4gICAgICAgP2RhdGVBYnJvZ2F0aW9uID9wdWJsaWNhdGlvblN0YXR1cyA/cmVzcG9uc2libGVBdXRob3JpdHkgP2xlZ2FsQmFzaXNcbiAgICAgICA/Y2xhc3NpZmljYXRpb25OdW1iZXIgP3ZlcnNpb24gP2V4cHJlc3Npb25MYW5ndWFnZSA/aW5Gb3JjZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG4gICR7bGFuZ0ZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YWN0VHlwZSB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlRG9jdW1lbnQgP2RhdGVEb2N1bWVudCB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlRW50cnlJbkZvcmNlID9kYXRlSW5Gb3JjZSB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlTm9Mb25nZXJJbkZvcmNlID9kYXRlQWJyb2dhdGlvbiB9XG5cbiAgIyBJbiBmb3JjZSBzdGF0dXNcbiAgT1BUSU9OQUwge1xuICAgID9hY3Qgam9sdXg6aW5Gb3JjZSA/aW5Gb3JjZVN0YXR1cyAuXG4gICAgQklORCg/aW5Gb3JjZVN0YXR1cyA9IDxodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL3ZvY2FidWxhcnkvZW5mb3JjZW1lbnQtc3RhdHVzLzE+IEFTID9pbkZvcmNlKVxuICB9XG5cbiAgIyBBdXRob3JpdHkgYW5kIGJhc2lzXG4gIE9QVElPTkFMIHsgP2FjdCBkY3Rlcm1zOmNyZWF0b3IgP3Jlc3BvbnNpYmxlQXV0aG9yaXR5IH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/bGVnYWxCYXNpcyB9XG5cbiAgIyBDbGFzc2lmaWNhdGlvbiBudW1iZXIgKHNhbWUgYXMgU1IpXG4gIEJJTkQoP3NyTnVtYmVyIEFTID9jbGFzc2lmaWNhdGlvbk51bWJlcilcblxuICAjIFZlcnNpb24gaW5mbyB2aWEgRXhwcmVzc2lvblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuICAgID92ZXJzaW9uIGpvbHV4Omxhbmd1YWdlID9leHByZXNzaW9uTGFuZ3VhZ2UgLlxuICB9XG59XG5MSU1JVCA1MFxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBhbGwgYXZhaWxhYmxlIGxhbmd1YWdlcyBmb3IgYSBsZWdhbCBhY3RcbiAqIFVzZXMgdGF4b25vbXkgcHJlZkxhYmVsIGxhbmd1YWdlIHRhZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR2V0TGFuZ3VhZ2VzUXVlcnkoc3JOdW1iZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9sYW5ndWFnZSA/dGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gIEJJTkQoTEFORyg/dGl0bGUpIEFTID9sYW5ndWFnZSlcbiAgRklMVEVSKEJPVU5EKD9sYW5ndWFnZSkgJiYgP2xhbmd1YWdlICE9IFwiXCIpXG59XG5PUkRFUiBCWSA/bGFuZ3VhZ2VcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgcHVibGljYXRpb24gaW5mb3JtYXRpb25cbiAqIEluIEpPTFVYLCBwdWJsaWNhdGlvbnMgYXJlIHRyYWNrZWQgdmlhIEV4cHJlc3Npb25zIGFuZCBNYW5pZmVzdGF0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRQdWJsaWNhdGlvbkluZm9RdWVyeShzck51bWJlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3B1YmxpY2F0aW9uID9wdWJsaWNhdGlvblR5cGUgP3B1YmxpY2F0aW9uRGF0ZSA/cHVibGljYXRpb25SZWZlcmVuY2UgP2NvbGxlY3Rpb25cbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgUHVibGljYXRpb24gaW5mbyB2aWEgRXhwcmVzc2lvblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3B1YmxpY2F0aW9uIC5cbiAgICBPUFRJT05BTCB7ID9wdWJsaWNhdGlvbiBqb2x1eDp0eXBlRG9jdW1lbnQgP3B1YmxpY2F0aW9uVHlwZSB9XG4gICAgT1BUSU9OQUwgeyA/cHVibGljYXRpb24gam9sdXg6ZGF0ZURvY3VtZW50ID9wdWJsaWNhdGlvbkRhdGUgfVxuICAgIE9QVElPTkFMIHsgP3B1YmxpY2F0aW9uIGpvbHV4OnB1YmxpY2F0aW9uUmVmZXJlbmNlID9wdWJsaWNhdGlvblJlZmVyZW5jZSB9XG4gIH1cblxuICAjIENvbGxlY3Rpb24gbWVtYmVyc2hpcCB2aWEgdGF4b25vbXkgaGllcmFyY2h5XG4gIE9QVElPTkFMIHtcbiAgICA/dGF4b25vbXkgc2tvczpicm9hZGVyID9jb2xsZWN0aW9uIC5cbiAgfVxufVxuT1JERVIgQlkgREVTQyg/cHVibGljYXRpb25EYXRlKVxuTElNSVQgMjBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgc3ViamVjdHMva2V5d29yZHMgZm9yIGEgbGVnYWwgYWN0XG4gKiBVc2VzIHRheG9ub215IGJyb2FkZXIgY29uY2VwdHMgYW5kIGRjdGVybXM6c3ViamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRTdWJqZWN0c1F1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcsIGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoIUJPVU5EKD9sYWJlbCkgfHwgTEFORyg/bGFiZWwpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9zdWJqZWN0ID9sYWJlbCA/c2NoZW1lXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEdldCBzdWJqZWN0cyBmcm9tIHRheG9ub215IGhpZXJhcmNoeSBvciBkY3Rlcm1zOnN1YmplY3RcbiAge1xuICAgID90YXhvbm9teSBza29zOmJyb2FkZXIgP3N1YmplY3QgLlxuICB9IFVOSU9OIHtcbiAgICA/YWN0IGRjdGVybXM6c3ViamVjdCA/c3ViamVjdCAuXG4gIH1cblxuICBPUFRJT05BTCB7ID9zdWJqZWN0IHNrb3M6cHJlZkxhYmVsID9sYWJlbCB9XG4gIE9QVElPTkFMIHsgP3N1YmplY3Qgc2tvczppblNjaGVtZSA/c2NoZW1lIH1cblxuICAke2xhbmdGaWx0ZXJ9XG59XG5PUkRFUiBCWSA/bGFiZWxcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgcmVzcG9uc2libGUgYXV0aG9yaXR5L2NyZWF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR2V0QXV0aG9yaXR5UXVlcnkoc3JOdW1iZXI6IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUighQk9VTkQoP2F1dGhvcml0eU5hbWUpIHx8IExBTkcoP2F1dGhvcml0eU5hbWUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hdXRob3JpdHkgP2F1dGhvcml0eU5hbWUgP2F1dGhvcml0eVR5cGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gIHtcbiAgICA/YWN0IGRjdGVybXM6Y3JlYXRvciA/YXV0aG9yaXR5IC5cbiAgfSBVTklPTiB7XG4gICAgP2FjdCBqb2x1eDpyZXNwb25zaWJsZURlcGFydG1lbnQgP2F1dGhvcml0eSAuXG4gIH1cblxuICBPUFRJT05BTCB7ID9hdXRob3JpdHkgcmRmczpsYWJlbCA/YXV0aG9yaXR5TmFtZSB9XG4gIE9QVElPTkFMIHsgP2F1dGhvcml0eSBza29zOnByZWZMYWJlbCA/YXV0aG9yaXR5TmFtZSB9XG4gIE9QVElPTkFMIHsgP2F1dGhvcml0eSBhID9hdXRob3JpdHlUeXBlIH1cblxuICAke2xhbmdGaWx0ZXJ9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IHZlcnNpb24gaGlzdG9yeVxuICogSW4gSk9MVVgsIHZlcnNpb25zIGFyZSB0cmFja2VkIHZpYSBFeHByZXNzaW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRWZXJzaW9uSGlzdG9yeVF1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/dmVyc2lvbiA/dmVyc2lvbkRhdGUgP3ZlcnNpb25UeXBlID90aXRsZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuXG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6ZGF0ZURvY3VtZW50ID92ZXJzaW9uRGF0ZSB9XG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6dHlwZURvY3VtZW50ID92ZXJzaW9uVHlwZSB9XG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6dGl0bGUgP3RpdGxlIH1cbn1cbk9SREVSIEJZIERFU0MoP3ZlcnNpb25EYXRlKVxuTElNSVQgNTBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgbGVnYWwgZWZmZWN0L3N0YXR1cyBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRMZWdhbFN0YXR1c1F1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/c3RhdHVzID9pbkZvcmNlID9kYXRlSW5Gb3JjZSA/ZGF0ZUFicm9nYXRpb24gP2Ficm9nYXRlZEJ5XG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppbkZvcmNlID9pbkZvcmNlU3RhdHVzIC5cbiAgICBCSU5EKD9pbkZvcmNlU3RhdHVzID0gPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9lbmZvcmNlbWVudC1zdGF0dXMvMT4gQVMgP2luRm9yY2UpXG4gIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmRhdGVFbnRyeUluRm9yY2UgP2RhdGVJbkZvcmNlIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmRhdGVOb0xvbmdlckluRm9yY2UgP2RhdGVBYnJvZ2F0aW9uIH1cblxuICAjIENoZWNrIGlmIGFicm9nYXRlZCBieSBhbm90aGVyIGFjdFxuICBPUFRJT05BTCB7XG4gICAgP2Ficm9nYXRpbmdBY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VSZXBlYWxzID9hY3QgLlxuICAgID9hYnJvZ2F0aW5nQWN0IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP2Ficm9nYXRpbmdUYXggLlxuICAgID9hYnJvZ2F0aW5nVGF4IHNrb3M6bm90YXRpb24gP2Ficm9nYXRlZEJ5IC5cbiAgfVxuXG4gIEJJTkQoXG4gICAgSUYoQk9VTkQoP2RhdGVBYnJvZ2F0aW9uKSwgXCJhYnJvZ2F0ZWRcIixcbiAgICAgIElGKEJPVU5EKD9kYXRlSW5Gb3JjZSksIFwiaW5fZm9yY2VcIiwgXCJwZW5kaW5nXCIpXG4gICAgKSBBUyA/c3RhdHVzXG4gIClcbn1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgZG9jdW1lbnQgc3RydWN0dXJlICh0YWJsZSBvZiBjb250ZW50cylcbiAqIFVzZXMgam9sdXg6aGFzUGFydCBmb3IgaGllcmFyY2hpY2FsIHN0cnVjdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRTdHJ1Y3R1cmVRdWVyeShzck51bWJlcjogc3RyaW5nLCBsYW5ndWFnZT86IExhbmd1YWdlKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKCFCT1VORCg/cGFydFRpdGxlKSB8fCBMQU5HKD9wYXJ0VGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9wYXJ0ID9wYXJ0TnVtYmVyID9wYXJ0VGl0bGUgP3BhcnRUeXBlID9wYXJlbnRQYXJ0XG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEdldCBzdHJ1Y3R1cmFsIHBhcnRzIChjaGFwdGVycywgc2VjdGlvbnMsIGFydGljbGVzKVxuICA/YWN0IGpvbHV4Omhhc1BhcnQrID9wYXJ0IC5cblxuICA/cGFydCBqb2x1eDpudW1iZXIgP3BhcnROdW1iZXIgLlxuXG4gIE9QVElPTkFMIHtcbiAgICA/cGFydCBqb2x1eDppc1JlYWxpemVkQnkgP3BhcnRFeHByIC5cbiAgICA/cGFydEV4cHIgam9sdXg6dGl0bGUgP3BhcnRUaXRsZSAuXG4gIH1cbiAgT1BUSU9OQUwgeyA/cGFydCBhID9wYXJ0VHlwZSB9XG5cbiAgIyBHZXQgcGFyZW50IHJlbGF0aW9uc2hpcCBmb3IgaGllcmFyY2h5XG4gIE9QVElPTkFMIHtcbiAgICA/cGFyZW50UGFydCBqb2x1eDpoYXNQYXJ0ID9wYXJ0IC5cbiAgICBGSUxURVIoP3BhcmVudFBhcnQgIT0gP2FjdClcbiAgfVxuXG4gICR7bGFuZ0ZpbHRlcn1cbn1cbk9SREVSIEJZID9wYXJ0TnVtYmVyXG5MSU1JVCA1MDBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgZG9jdW1lbnQgZm9ybWF0L2VuY29kaW5nIGluZm9ybWF0aW9uXG4gKiBJbiBKT0xVWCwgZm9ybWF0cyBhcmUgdmlhIE1hbmlmZXN0YXRpb25zIChqb2x1eDppc0VtYm9kaWVkQnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdldEZvcm1hdEluZm9RdWVyeShzck51bWJlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2Zvcm1hdCA/Zm9ybWF0VHlwZSA/ZW5jb2RpbmcgP2ZpbGVTaXplID9kb3dubG9hZFVybFxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgIyBFeHByZXNzaW9uIC0+IE1hbmlmZXN0YXRpb24gY2hhaW5cbiAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP2V4cHJlc3Npb24gLlxuICA/ZXhwcmVzc2lvbiBqb2x1eDppc0VtYm9kaWVkQnkgP21hbmlmZXN0YXRpb24gLlxuXG4gIE9QVElPTkFMIHsgP21hbmlmZXN0YXRpb24gZGN0ZXJtczpmb3JtYXQgP2Zvcm1hdCB9XG4gIE9QVElPTkFMIHsgP2Zvcm1hdCBkY3Rlcm1zOnR5cGUgP2Zvcm1hdFR5cGUgfVxuICBPUFRJT05BTCB7ID9mb3JtYXQgZGN0ZXJtczplbmNvZGluZyA/ZW5jb2RpbmcgfVxuICBPUFRJT05BTCB7ID9tYW5pZmVzdGF0aW9uIHNjaGVtYTpjb250ZW50U2l6ZSA/ZmlsZVNpemUgfVxuICBPUFRJT05BTCB7ID9tYW5pZmVzdGF0aW9uIHNjaGVtYTpjb250ZW50VXJsID9kb3dubG9hZFVybCB9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IHN0YXRpc3RpY2FsIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdldFN0YXRpc3RpY3NRdWVyeShzck51bWJlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgP2FydGljbGVDb3VudCA/cGFydENvdW50XG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIENvdW50IGFydGljbGVzIChkaXJlY3QgcGFydHMpXG4gIHtcbiAgICBTRUxFQ1QgKENPVU5UKERJU1RJTkNUID9hcnRpY2xlKSBBUyA/YXJ0aWNsZUNvdW50KVxuICAgIFdIRVJFIHtcbiAgICAgID9hY3Qgam9sdXg6aGFzUGFydCA/YXJ0aWNsZSAuXG4gICAgICA/YXJ0aWNsZSBqb2x1eDpudW1iZXIgP251bSAuXG4gICAgfVxuICB9XG5cbiAgIyBDb3VudCBhbGwgcGFydHMgKHJlY3Vyc2l2ZSlcbiAge1xuICAgIFNFTEVDVCAoQ09VTlQoRElTVElOQ1QgP3BhcnQpIEFTID9wYXJ0Q291bnQpXG4gICAgV0hFUkUge1xuICAgICAgP2FjdCBqb2x1eDpoYXNQYXJ0KyA/cGFydCAuXG4gICAgfVxuICB9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGFsbCBhdmFpbGFibGUgU1IgbnVtYmVycyB3aXRoIHRoZWlyIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExpc3RBbGxBY3RzUXVlcnkoXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDAsXG4gIG9mZnNldDogbnVtYmVyID0gMFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2FjdFR5cGUgP2RhdGVJbkZvcmNlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgO1xuICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP3RpdGxlIC5cblxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnRpdGxlU2hvcnQgP2FiYnJldmlhdGlvbiB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0eXBlRG9jdW1lbnQgP2FjdFR5cGUgfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6ZGF0ZUVudHJ5SW5Gb3JjZSA/ZGF0ZUluRm9yY2UgfVxufVxuT1JERVIgQlkgP3NyTnVtYmVyXG5PRkZTRVQgJHtvZmZzZXR9XG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBhY3QgdHlwZXMgYXZhaWxhYmxlIGluIHRoZSBzeXN0ZW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGlzdEFjdFR5cGVzUXVlcnkobGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90eXBlTGFiZWwpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3RUeXBlID90eXBlTGFiZWwgKENPVU5UKD9hY3QpIEFTID9jb3VudClcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6dHlwZURvY3VtZW50ID9hY3RUeXBlIC5cblxuICBPUFRJT05BTCB7ID9hY3RUeXBlIHJkZnM6bGFiZWwgP3R5cGVMYWJlbCB9XG4gIE9QVElPTkFMIHsgP2FjdFR5cGUgc2tvczpwcmVmTGFiZWwgP3R5cGVMYWJlbCB9XG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuR1JPVVAgQlkgP2FjdFR5cGUgP3R5cGVMYWJlbFxuT1JERVIgQlkgREVTQyg/Y291bnQpXG4gIGApO1xufVxuIiwgIiMhL3Vzci9iaW4vZW52IG5vZGVcblxuLyoqXG4gKiBGZWRsZXggU1BBUlFMIE1DUCBTZXJ2ZXJcbiAqXG4gKiBQcm92aWRlcyBhY2Nlc3MgdG8gU3dpc3MgRmVkZXJhbCBMZWdpc2xhdGlvbiB2aWEgdGhlIEZlZGxleCBTUEFSUUwgZW5kcG9pbnQuXG4gKiBVc2VzIHRoZSBKT0xVWCBvbnRvbG9neSAoYmFzZWQgb24gRlJCUiBtb2RlbCkgZm9yIHN0cnVjdHVyZWQgbGVnYWwgZGF0YS5cbiAqXG4gKiBFbmRwb2ludDogaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9zcGFycWxlbmRwb2ludFxuICogRGF0YTogfjIyOCw1MDAgbGVnYWwgb2JqZWN0cyBpbmNsdWRpbmcgU1IvUlMgY2xhc3NpZmllZCBsZWdpc2xhdGlvblxuICogTGljZW5zZTogQ0MgQlktTkMtU0EgNC4wXG4gKlxuICogRGF0YSBNb2RlbCAoRlJCUi1iYXNlZCk6XG4gKiAtIGpvbHV4OkFjdCA9IFByaW1hcnkgbGVnaXNsYXRpb24gd29ya1xuICogLSBqb2x1eDpFeHByZXNzaW9uID0gTGFuZ3VhZ2Utc3BlY2lmaWMgcmVhbGl6YXRpb24gKHZpYSBqb2x1eDppc1JlYWxpemVkQnkpXG4gKiAtIGpvbHV4Ok1hbmlmZXN0YXRpb24gPSBQaHlzaWNhbCBmb3JtYXQgKHZpYSBqb2x1eDppc0VtYm9kaWVkQnkpXG4gKiAtIFNSIG51bWJlcnMgdmlhIHRheG9ub215OiBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5IFx1MjE5MiBza29zOm5vdGF0aW9uXG4gKiAtIFRpdGxlczogdGF4b25vbXkgc2tvczpwcmVmTGFiZWwgKHdpdGggbGFuZ3VhZ2UgdGFncylcbiAqXG4gKiBUb29sczpcbiAqIC0gbG9va3VwX3N0YXR1dGU6IExvb2sgdXAgYSBsZWdhbCBhY3QgYnkgU1IgbnVtYmVyIG9yIGFiYnJldmlhdGlvblxuICogLSBnZXRfYXJ0aWNsZTogUmV0cmlldmUgc3BlY2lmaWMgYXJ0aWNsZXMgd2l0aGluIGEgbGVnYWwgYWN0XG4gKiAtIHNlYXJjaF9sZWdpc2xhdGlvbjogRnVsbC10ZXh0IGFuZCBmaWx0ZXJlZCBzZWFyY2ggYWNyb3NzIGxlZ2lzbGF0aW9uXG4gKiAtIGZpbmRfcmVsYXRlZDogRmluZCByZWxhdGVkIGxlZ2lzbGF0aW9uIChhbWVuZG1lbnRzLCBjaXRhdGlvbnMsIHNhbWUgZG9tYWluKVxuICogLSBnZXRfbWV0YWRhdGE6IEdldCBjb21wcmVoZW5zaXZlIG1ldGFkYXRhIGFib3V0IGEgbGVnYWwgYWN0XG4gKi9cblxuaW1wb3J0IHsgU2VydmVyIH0gZnJvbSBcIkBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBTdGRpb1NlcnZlclRyYW5zcG9ydCB9IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NlcnZlci9zdGRpby5qc1wiO1xuaW1wb3J0IHtcbiAgQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLFxuICBMaXN0VG9vbHNSZXF1ZXN0U2NoZW1hLFxufSBmcm9tIFwiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay90eXBlcy5qc1wiO1xuXG5pbXBvcnQgeyBTUEFSUUxDbGllbnQsIGNyZWF0ZUZlZGxleENsaWVudCB9IGZyb20gJy4vc3BhcnFsLWNsaWVudC5qcyc7XG5pbXBvcnQge1xuICBidWlsZExvb2t1cFN0YXR1dGVRdWVyeSxcbiAgYnVpbGRMb29rdXBCeUFiYnJldmlhdGlvblF1ZXJ5LFxuICBidWlsZEdldEFydGljbGVRdWVyeSxcbiAgYnVpbGRHZXRBcnRpY2xlUGFyYWdyYXBoUXVlcnksXG4gIC8vIGJ1aWxkTGlzdEFydGljbGVzUXVlcnksIC8vIFJlc2VydmVkIGZvciBmdXR1cmUgYXJ0aWNsZSBsaXN0aW5nIGVuZHBvaW50XG4gIGJ1aWxkU2VhcmNoUXVlcnksXG4gIGJ1aWxkU2VhcmNoQ291bnRRdWVyeSxcbiAgYnVpbGRTZWFyY2hCeURvbWFpblF1ZXJ5LFxuICBidWlsZFNlYXJjaEJ5RGF0ZVF1ZXJ5LFxuICBidWlsZEZpbmRBbGxSZWxhdGVkUXVlcnksXG4gIGJ1aWxkTGVnaXNsYXRpdmVIaXN0b3J5UXVlcnksXG4gIGJ1aWxkR2V0TWV0YWRhdGFRdWVyeSxcbiAgYnVpbGRHZXRMYW5ndWFnZXNRdWVyeSxcbiAgYnVpbGRHZXRTdWJqZWN0c1F1ZXJ5LFxuICBidWlsZEdldFZlcnNpb25IaXN0b3J5UXVlcnksXG4gIGJ1aWxkR2V0TGVnYWxTdGF0dXNRdWVyeSxcbiAgYnVpbGRHZXRTdHJ1Y3R1cmVRdWVyeSxcbiAgTEVHQUxfRE9NQUlOUyxcbn0gZnJvbSAnLi9xdWVyaWVzL2luZGV4LmpzJztcblxuaW1wb3J0IHR5cGUge1xuICBMYW5ndWFnZSxcbiAgTGVnYWxBY3QsXG4gIEFydGljbGUsXG4gIFJlbGF0ZWRBY3QsXG4gIFNlYXJjaEZpbHRlcnMsXG4gIExvb2t1cFN0YXR1dGVJbnB1dCxcbiAgTG9va3VwU3RhdHV0ZVJlc3VsdCxcbiAgR2V0QXJ0aWNsZUlucHV0LFxuICBHZXRBcnRpY2xlUmVzdWx0LFxuICBTZWFyY2hMZWdpc2xhdGlvbklucHV0LFxuICBTZWFyY2hMZWdpc2xhdGlvblJlc3VsdCxcbiAgRmluZFJlbGF0ZWRJbnB1dCxcbiAgRmluZFJlbGF0ZWRSZXN1bHQsXG4gIEdldE1ldGFkYXRhSW5wdXQsXG4gIEdldE1ldGFkYXRhUmVzdWx0LFxuICBTUEFSUUxCaW5kaW5nLFxuICBSZWxhdGlvblR5cGUsXG59IGZyb20gJy4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEdsb2JhbCBTUEFSUUwgY2xpZW50IGluc3RhbmNlXG4gKi9cbmxldCBzcGFycWxDbGllbnQ6IFNQQVJRTENsaWVudDtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBTUEFSUUwgY2xpZW50XG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDbGllbnQoKTogdm9pZCB7XG4gIHNwYXJxbENsaWVudCA9IGNyZWF0ZUZlZGxleENsaWVudCh7XG4gICAgdGltZW91dDogNjAwMDAsIC8vIDYwIHNlY29uZHMgZm9yIGNvbXBsZXggcXVlcmllc1xuICAgIG1heFJldHJpZXM6IDMsXG4gICAgcmV0cnlEZWxheTogMjAwMCxcbiAgfSk7XG5cbiAgY29uc29sZS5lcnJvcihgRmVkbGV4IFNQQVJRTCBjbGllbnQgaW5pdGlhbGl6ZWQgLSBlbmRwb2ludDogJHtzcGFycWxDbGllbnQuZ2V0RW5kcG9pbnQoKX1gKTtcbn1cblxuLyoqXG4gKiBMb29rIHVwIGEgbGVnYWwgYWN0IGJ5IFNSIG51bWJlciBvciBhYmJyZXZpYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9va3VwU3RhdHV0ZShpbnB1dDogTG9va3VwU3RhdHV0ZUlucHV0KTogUHJvbWlzZTxMb29rdXBTdGF0dXRlUmVzdWx0PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgcXVlcnk6IHN0cmluZztcbiAgICBsZXQgc2VhcmNoVHlwZTogJ3NyTnVtYmVyJyB8ICdhYmJyZXZpYXRpb24nO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIGlucHV0IGlzIFNSIG51bWJlciBvciBhYmJyZXZpYXRpb25cbiAgICBpZiAoL15cXGQvLnRlc3QoaW5wdXQuaWRlbnRpZmllcikpIHtcbiAgICAgIC8vIFN0YXJ0cyB3aXRoIGRpZ2l0IFx1MjE5MiBTUiBudW1iZXJcbiAgICAgIHF1ZXJ5ID0gYnVpbGRMb29rdXBTdGF0dXRlUXVlcnkoaW5wdXQuaWRlbnRpZmllciwgaW5wdXQubGFuZ3VhZ2UpO1xuICAgICAgc2VhcmNoVHlwZSA9ICdzck51bWJlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpa2VseSBhYmJyZXZpYXRpb24gKGUuZy4sIFwiT1JcIiwgXCJaR0JcIilcbiAgICAgIHF1ZXJ5ID0gYnVpbGRMb29rdXBCeUFiYnJldmlhdGlvblF1ZXJ5KGlucHV0LmlkZW50aWZpZXIsIGlucHV0Lmxhbmd1YWdlKTtcbiAgICAgIHNlYXJjaFR5cGUgPSAnYWJicmV2aWF0aW9uJztcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBzcGFycWxDbGllbnQucXVlcnkocXVlcnkpO1xuICAgIGNvbnN0IGJpbmRpbmdzID0gcmVzdWx0LnJlc3VsdHMuYmluZGluZ3M7XG5cbiAgICBpZiAoYmluZGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZDogZmFsc2UsXG4gICAgICAgIHNlYXJjaFRpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gR3JvdXAgYnkgYWN0IFVSSSB0byBoYW5kbGUgbXVsdGlwbGUgbGFuZ3VhZ2UgdmVyc2lvbnNcbiAgICBjb25zdCBhY3RHcm91cHMgPSBzcGFycWxDbGllbnQuZ3JvdXBCaW5kaW5ncyhiaW5kaW5ncywgJ2FjdCcpO1xuICAgIGNvbnN0IGFjdHM6IExlZ2FsQWN0W10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2FjdFVyaSwgYWN0QmluZGluZ3NdIG9mIGFjdEdyb3Vwcykge1xuICAgICAgY29uc3QgZmlyc3RCaW5kaW5nID0gYWN0QmluZGluZ3NbMF07XG5cbiAgICAgIGNvbnN0IGFjdDogTGVnYWxBY3QgPSB7XG4gICAgICAgIHVyaTogYWN0VXJpLFxuICAgICAgICBzck51bWJlcjogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuc3JOdW1iZXIpIHx8ICcnLFxuICAgICAgICB0aXRsZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RNdWx0aWxpbmd1YWxWYWx1ZShhY3RCaW5kaW5ncywgJ3RpdGxlJyksXG4gICAgICAgIGFiYnJldmlhdGlvbjogc3BhcnFsQ2xpZW50LmV4dHJhY3RNdWx0aWxpbmd1YWxWYWx1ZShhY3RCaW5kaW5ncywgJ2FiYnJldmlhdGlvbicpLFxuICAgICAgICBhY3RUeXBlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5hY3RUeXBlKSxcbiAgICAgICAgZGF0ZURvY3VtZW50OiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5kYXRlRG9jdW1lbnQpLFxuICAgICAgICBkYXRlSW5Gb3JjZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuZGF0ZUluRm9yY2UpLFxuICAgICAgICBzdGF0dXM6IGZpcnN0QmluZGluZy5pbkZvcmNlID8gJ2luX2ZvcmNlJyA6ICd1bmtub3duJyxcbiAgICAgIH07XG5cbiAgICAgIGFjdHMucHVzaChhY3QpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgIGFjdHMsXG4gICAgICBzZWFyY2hUeXBlLFxuICAgICAgc2VhcmNoVGltZU1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignTG9va3VwIHN0YXR1dGUgZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBhIHNwZWNpZmljIGFydGljbGUgd2l0aGluIGEgbGVnYWwgYWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEFydGljbGUoaW5wdXQ6IEdldEFydGljbGVJbnB1dCk6IFByb21pc2U8R2V0QXJ0aWNsZVJlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgbGV0IHF1ZXJ5OiBzdHJpbmc7XG5cbiAgICBpZiAoaW5wdXQucGFyYWdyYXBoKSB7XG4gICAgICBxdWVyeSA9IGJ1aWxkR2V0QXJ0aWNsZVBhcmFncmFwaFF1ZXJ5KFxuICAgICAgICBpbnB1dC5zck51bWJlcixcbiAgICAgICAgaW5wdXQuYXJ0aWNsZU51bWJlcixcbiAgICAgICAgaW5wdXQucGFyYWdyYXBoLFxuICAgICAgICBpbnB1dC5sYW5ndWFnZVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcXVlcnkgPSBidWlsZEdldEFydGljbGVRdWVyeShcbiAgICAgICAgaW5wdXQuc3JOdW1iZXIsXG4gICAgICAgIGlucHV0LmFydGljbGVOdW1iZXIsXG4gICAgICAgIGlucHV0Lmxhbmd1YWdlXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNwYXJxbENsaWVudC5xdWVyeShxdWVyeSk7XG4gICAgY29uc3QgYmluZGluZ3MgPSByZXN1bHQucmVzdWx0cy5iaW5kaW5ncztcblxuICAgIGlmIChiaW5kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgc2VhcmNoVGltZU1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBFeHRyYWN0IGFjdCBpbmZvcm1hdGlvblxuICAgIGNvbnN0IGZpcnN0QmluZGluZyA9IGJpbmRpbmdzWzBdO1xuICAgIGNvbnN0IGFjdEluZm8gPSB7XG4gICAgICB1cmk6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmFjdCkgfHwgJycsXG4gICAgICBzck51bWJlcjogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuc3JOdW1iZXIpIHx8ICcnLFxuICAgICAgdGl0bGU6IHNwYXJxbENsaWVudC5leHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUoYmluZGluZ3MsICdhY3RUaXRsZScpLFxuICAgIH07XG5cbiAgICAvLyBHcm91cCBieSBhcnRpY2xlIHRvIGhhbmRsZSBwYXJhZ3JhcGhzIGFuZCBsZXR0ZXJzXG4gICAgY29uc3QgYXJ0aWNsZUdyb3VwcyA9IHNwYXJxbENsaWVudC5ncm91cEJpbmRpbmdzKGJpbmRpbmdzLCAnYXJ0aWNsZScpO1xuICAgIGNvbnN0IGFydGljbGVzOiBBcnRpY2xlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgW2FydGljbGVVcmksIGFydGljbGVCaW5kaW5nc10gb2YgYXJ0aWNsZUdyb3Vwcykge1xuICAgICAgY29uc3QgYXJ0aWNsZUZpcnN0ID0gYXJ0aWNsZUJpbmRpbmdzWzBdO1xuXG4gICAgICAvLyBFeHRyYWN0IHBhcmFncmFwaHNcbiAgICAgIGNvbnN0IHBhcmFncmFwaHM6IEFycmF5PHtcbiAgICAgICAgbnVtYmVyOiBzdHJpbmc7XG4gICAgICAgIHRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICAgICAgICBsZXR0ZXJzPzogQXJyYXk8eyBsaXRlcmFsOiBzdHJpbmc7IHRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0+O1xuICAgICAgfT4gPSBbXTtcblxuICAgICAgY29uc3QgcGFyYWdyYXBoR3JvdXBzID0gc3BhcnFsQ2xpZW50Lmdyb3VwQmluZGluZ3MoYXJ0aWNsZUJpbmRpbmdzLCAncGFyYWdyYXBoTnVtJyk7XG4gICAgICBmb3IgKGNvbnN0IFtwYXJhZ3JhcGhOdW0sIHBhcmFncmFwaEJpbmRpbmdzXSBvZiBwYXJhZ3JhcGhHcm91cHMpIHtcbiAgICAgICAgaWYgKCFwYXJhZ3JhcGhOdW0pIGNvbnRpbnVlO1xuXG4gICAgICAgIC8vIEV4dHJhY3QgbGV0dGVycyB3aXRoaW4gcGFyYWdyYXBoXG4gICAgICAgIGNvbnN0IGxldHRlcnM6IEFycmF5PHsgbGl0ZXJhbDogc3RyaW5nOyB0ZXh0PzogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB9PiA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgcGFyYWdyYXBoQmluZGluZ3MpIHtcbiAgICAgICAgICBjb25zdCBsZXR0ZXJMaXQgPSBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcubGV0dGVyTGl0KTtcbiAgICAgICAgICBpZiAobGV0dGVyTGl0KSB7XG4gICAgICAgICAgICBsZXR0ZXJzLnB1c2goe1xuICAgICAgICAgICAgICBsaXRlcmFsOiBsZXR0ZXJMaXQsXG4gICAgICAgICAgICAgIHRleHQ6IGJpbmRpbmcubGV0dGVyVGV4dCA/IHsgW2JpbmRpbmcubGV0dGVyVGV4dFsneG1sOmxhbmcnXSB8fCAnZGUnXTogYmluZGluZy5sZXR0ZXJUZXh0LnZhbHVlIH0gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhZ3JhcGhzLnB1c2goe1xuICAgICAgICAgIG51bWJlcjogcGFyYWdyYXBoTnVtLFxuICAgICAgICAgIHRleHQ6IHNwYXJxbENsaWVudC5leHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUocGFyYWdyYXBoQmluZGluZ3MsICdwYXJhZ3JhcGhUZXh0JyksXG4gICAgICAgICAgbGV0dGVyczogbGV0dGVycy5sZW5ndGggPiAwID8gbGV0dGVycyA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFydGljbGU6IEFydGljbGUgPSB7XG4gICAgICAgIHVyaTogYXJ0aWNsZVVyaSxcbiAgICAgICAgbnVtYmVyOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGFydGljbGVGaXJzdC5hcnRpY2xlTnVtYmVyKSB8fCAnJyxcbiAgICAgICAgdGl0bGU6IHNwYXJxbENsaWVudC5leHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUoYXJ0aWNsZUJpbmRpbmdzLCAnYXJ0aWNsZVRpdGxlJyksXG4gICAgICAgIHRleHQ6IHNwYXJxbENsaWVudC5leHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUoYXJ0aWNsZUJpbmRpbmdzLCAnYXJ0aWNsZVRleHQnKSxcbiAgICAgICAgcGFyYWdyYXBoczogcGFyYWdyYXBocy5sZW5ndGggPiAwID8gcGFyYWdyYXBocyA6IHVuZGVmaW5lZCxcbiAgICAgIH07XG5cbiAgICAgIGFydGljbGVzLnB1c2goYXJ0aWNsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgYWN0OiBhY3RJbmZvLFxuICAgICAgYXJ0aWNsZXMsXG4gICAgICBzZWFyY2hUaW1lTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdHZXQgYXJ0aWNsZSBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogU2VhcmNoIGFjcm9zcyBsZWdpc2xhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBzZWFyY2hMZWdpc2xhdGlvbihpbnB1dDogU2VhcmNoTGVnaXNsYXRpb25JbnB1dCk6IFByb21pc2U8U2VhcmNoTGVnaXNsYXRpb25SZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIGNvbnN0IGZpbHRlcnM6IFNlYXJjaEZpbHRlcnMgPSB7XG4gICAgICBsYW5ndWFnZTogaW5wdXQubGFuZ3VhZ2UsXG4gICAgICBhY3RUeXBlOiBpbnB1dC5hY3RUeXBlLFxuICAgICAgc3RhdHVzOiBpbnB1dC5zdGF0dXMsXG4gICAgICBzck51bWJlclByZWZpeDogaW5wdXQuc3JOdW1iZXJQcmVmaXgsXG4gICAgICBsaW1pdDogaW5wdXQubGltaXQgfHwgNTAsXG4gICAgICBvZmZzZXQ6IGlucHV0Lm9mZnNldCB8fCAwLFxuICAgIH07XG5cbiAgICAvLyBCdWlsZCBhcHByb3ByaWF0ZSBxdWVyeSBiYXNlZCBvbiBzZWFyY2ggdHlwZVxuICAgIGxldCBxdWVyeTogc3RyaW5nO1xuICAgIGxldCBjb3VudFF1ZXJ5OiBzdHJpbmcgfCB1bmRlZmluZWQ7XG5cbiAgICBpZiAoaW5wdXQuZG9tYWluICYmICFpbnB1dC5xdWVyeSkge1xuICAgICAgLy8gRG9tYWluLW9ubHkgc2VhcmNoXG4gICAgICBxdWVyeSA9IGJ1aWxkU2VhcmNoQnlEb21haW5RdWVyeShpbnB1dC5kb21haW4sIGlucHV0Lmxhbmd1YWdlLCBmaWx0ZXJzLmxpbWl0KTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LmRhdGVGcm9tIHx8IGlucHV0LmRhdGVUbykge1xuICAgICAgLy8gRGF0ZSByYW5nZSBzZWFyY2hcbiAgICAgIHF1ZXJ5ID0gYnVpbGRTZWFyY2hCeURhdGVRdWVyeShpbnB1dC5kYXRlRnJvbSwgaW5wdXQuZGF0ZVRvLCBpbnB1dC5sYW5ndWFnZSwgZmlsdGVycy5saW1pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZ1bGwtdGV4dCBzZWFyY2hcbiAgICAgIHF1ZXJ5ID0gYnVpbGRTZWFyY2hRdWVyeShpbnB1dC5xdWVyeSB8fCAnJywgZmlsdGVycyk7XG4gICAgICBjb3VudFF1ZXJ5ID0gYnVpbGRTZWFyY2hDb3VudFF1ZXJ5KGlucHV0LnF1ZXJ5IHx8ICcnLCBmaWx0ZXJzKTtcbiAgICB9XG5cbiAgICAvLyBFeGVjdXRlIHNlYXJjaCBxdWVyeVxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNwYXJxbENsaWVudC5xdWVyeShxdWVyeSk7XG4gICAgY29uc3QgYmluZGluZ3MgPSByZXN1bHQucmVzdWx0cy5iaW5kaW5ncztcblxuICAgIC8vIEV4ZWN1dGUgY291bnQgcXVlcnkgaWYgYXZhaWxhYmxlXG4gICAgbGV0IHRvdGFsQ291bnQgPSBiaW5kaW5ncy5sZW5ndGg7XG4gICAgaWYgKGNvdW50UXVlcnkpIHtcbiAgICAgIGNvbnN0IGNvdW50UmVzdWx0ID0gYXdhaXQgc3BhcnFsQ2xpZW50LnF1ZXJ5KGNvdW50UXVlcnkpO1xuICAgICAgaWYgKGNvdW50UmVzdWx0LnJlc3VsdHMuYmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBjb3VudFZhbHVlID0gc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShjb3VudFJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzWzBdLmNvdW50KTtcbiAgICAgICAgdG90YWxDb3VudCA9IGNvdW50VmFsdWUgPyBwYXJzZUludChjb3VudFZhbHVlLCAxMCkgOiBiaW5kaW5ncy5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgcmVzdWx0c1xuICAgIGNvbnN0IGFjdHM6IExlZ2FsQWN0W10gPSBiaW5kaW5ncy5tYXAoKGJpbmRpbmc6IFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+KSA9PiAoe1xuICAgICAgdXJpOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcuYWN0KSB8fCAnJyxcbiAgICAgIHNyTnVtYmVyOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcuc3JOdW1iZXIpIHx8ICcnLFxuICAgICAgdGl0bGU6IGJpbmRpbmcudGl0bGUgPyB7IFtiaW5kaW5nLnRpdGxlWyd4bWw6bGFuZyddIHx8ICdkZSddOiBiaW5kaW5nLnRpdGxlLnZhbHVlIH0gOiB7fSxcbiAgICAgIGFiYnJldmlhdGlvbjogYmluZGluZy5hYmJyZXZpYXRpb24gPyB7IFtiaW5kaW5nLmFiYnJldmlhdGlvblsneG1sOmxhbmcnXSB8fCAnZGUnXTogYmluZGluZy5hYmJyZXZpYXRpb24udmFsdWUgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGFjdFR5cGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5hY3RUeXBlKSxcbiAgICAgIGRhdGVJbkZvcmNlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcuZGF0ZUluRm9yY2UpLFxuICAgIH0pKTtcblxuICAgIC8vIEdyb3VwIGJ5IFNSIG51bWJlciBwcmVmaXggZm9yIGRvbWFpbiBmYWNldHNcbiAgICBjb25zdCBkb21haW5GYWNldHM6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGFjdCBvZiBhY3RzKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSBhY3Quc3JOdW1iZXIuc3BsaXQoJy4nKVswXTtcbiAgICAgIGlmIChwcmVmaXggJiYgTEVHQUxfRE9NQUlOU1twcmVmaXhdKSB7XG4gICAgICAgIGRvbWFpbkZhY2V0c1twcmVmaXhdID0gKGRvbWFpbkZhY2V0c1twcmVmaXhdIHx8IDApICsgMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYWN0cyxcbiAgICAgIHRvdGFsQ291bnQsXG4gICAgICBoYXNNb3JlOiAoZmlsdGVycy5vZmZzZXQgfHwgMCkgKyBhY3RzLmxlbmd0aCA8IHRvdGFsQ291bnQsXG4gICAgICBmYWNldHM6IHtcbiAgICAgICAgYnlEb21haW46IGRvbWFpbkZhY2V0cyxcbiAgICAgIH0sXG4gICAgICBzZWFyY2hUaW1lTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdTZWFyY2ggbGVnaXNsYXRpb24gZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEZpbmQgcmVsYXRlZCBsZWdpc2xhdGlvblxuICovXG5hc3luYyBmdW5jdGlvbiBmaW5kUmVsYXRlZChpbnB1dDogRmluZFJlbGF0ZWRJbnB1dCk6IFByb21pc2U8RmluZFJlbGF0ZWRSZXN1bHQ+IHtcbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICB0cnkge1xuICAgIC8vIEdldCBhbGwgcmVsYXRlZCBhY3RzXG4gICAgY29uc3QgcXVlcnkgPSBidWlsZEZpbmRBbGxSZWxhdGVkUXVlcnkoXG4gICAgICBpbnB1dC5zck51bWJlcixcbiAgICAgIGlucHV0LnJlbGF0aW9uVHlwZSBhcyBSZWxhdGlvblR5cGUsXG4gICAgICBpbnB1dC5sYW5ndWFnZSxcbiAgICAgIGlucHV0LmxpbWl0IHx8IDUwXG4gICAgKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNwYXJxbENsaWVudC5xdWVyeShxdWVyeSk7XG4gICAgY29uc3QgYmluZGluZ3MgPSByZXN1bHQucmVzdWx0cy5iaW5kaW5ncztcblxuICAgIC8vIFBhcnNlIHJlbGF0ZWQgYWN0c1xuICAgIGNvbnN0IHJlbGF0ZWRBY3RzOiBSZWxhdGVkQWN0W10gPSBiaW5kaW5ncy5tYXAoKGJpbmRpbmc6IFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+KSA9PiAoe1xuICAgICAgdXJpOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcucmVsYXRlZEFjdCkgfHwgJycsXG4gICAgICBzck51bWJlcjogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiaW5kaW5nLnJlbGF0ZWRTck51bWJlcikgfHwgJycsXG4gICAgICB0aXRsZTogYmluZGluZy5yZWxhdGVkVGl0bGUgPyB7IFtiaW5kaW5nLnJlbGF0ZWRUaXRsZVsneG1sOmxhbmcnXSB8fCAnZGUnXTogYmluZGluZy5yZWxhdGVkVGl0bGUudmFsdWUgfSA6IHt9LFxuICAgICAgcmVsYXRpb25UeXBlOiAoc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiaW5kaW5nLnJlbGF0aW9uVHlwZSkgYXMgUmVsYXRpb25UeXBlKSB8fCAnc2FtZV9kb21haW4nLFxuICAgICAgcmVsYXRpb25EYXRlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcucmVsYXRpb25EYXRlKSxcbiAgICB9KSk7XG5cbiAgICAvLyBHcm91cCBieSByZWxhdGlvbiB0eXBlIGZvciBzdW1tYXJ5XG4gICAgY29uc3QgYnlSZWxhdGlvblR5cGU6IFJlY29yZDxzdHJpbmcsIG51bWJlcj4gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGFjdCBvZiByZWxhdGVkQWN0cykge1xuICAgICAgY29uc3QgcmVsVHlwZSA9IGFjdC5yZWxhdGlvblR5cGUgfHwgJ3Vua25vd24nO1xuICAgICAgYnlSZWxhdGlvblR5cGVbcmVsVHlwZV0gPSAoYnlSZWxhdGlvblR5cGVbcmVsVHlwZV0gfHwgMCkgKyAxO1xuICAgIH1cblxuICAgIC8vIEdldCBsZWdpc2xhdGl2ZSBoaXN0b3J5IGlmIHJlcXVlc3RlZFxuICAgIGxldCBsZWdpc2xhdGl2ZUhpc3Rvcnk6IEFycmF5PHsgZGF0ZTogc3RyaW5nOyBkZXNjcmlwdGlvbj86IHN0cmluZyB9PiB8IHVuZGVmaW5lZDtcbiAgICBpZiAoaW5wdXQuaW5jbHVkZUhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IGhpc3RvcnlRdWVyeSA9IGJ1aWxkTGVnaXNsYXRpdmVIaXN0b3J5UXVlcnkoaW5wdXQuc3JOdW1iZXIsIGlucHV0Lmxhbmd1YWdlKTtcbiAgICAgIGNvbnN0IGhpc3RvcnlSZXN1bHQgPSBhd2FpdCBzcGFycWxDbGllbnQucXVlcnkoaGlzdG9yeVF1ZXJ5KTtcblxuICAgICAgbGVnaXNsYXRpdmVIaXN0b3J5ID0gaGlzdG9yeVJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzLm1hcCgoYmluZGluZzogUmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4pID0+ICh7XG4gICAgICAgIGRhdGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5kYXRlKSB8fCAnJyxcbiAgICAgICAgZGVzY3JpcHRpb246IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5jaGFuZ2VEZXNjcmlwdGlvbiksXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHNyTnVtYmVyOiBpbnB1dC5zck51bWJlcixcbiAgICAgIHJlbGF0ZWRBY3RzLFxuICAgICAgYnlSZWxhdGlvblR5cGUsXG4gICAgICBsZWdpc2xhdGl2ZUhpc3RvcnksXG4gICAgICBzZWFyY2hUaW1lTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdGaW5kIHJlbGF0ZWQgZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBjb21wcmVoZW5zaXZlIG1ldGFkYXRhIGFib3V0IGEgbGVnYWwgYWN0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldE1ldGFkYXRhKGlucHV0OiBHZXRNZXRhZGF0YUlucHV0KTogUHJvbWlzZTxHZXRNZXRhZGF0YVJlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgLy8gRmV0Y2ggbWV0YWRhdGEgaW4gcGFyYWxsZWxcbiAgICBjb25zdCBbXG4gICAgICBtZXRhZGF0YVJlc3VsdCxcbiAgICAgIGxhbmd1YWdlc1Jlc3VsdCxcbiAgICAgIHN1YmplY3RzUmVzdWx0LFxuICAgICAgaGlzdG9yeVJlc3VsdCxcbiAgICAgIHN0YXR1c1Jlc3VsdCxcbiAgICAgIHN0cnVjdHVyZVJlc3VsdCxcbiAgICBdID0gYXdhaXQgUHJvbWlzZS5hbGwoW1xuICAgICAgc3BhcnFsQ2xpZW50LnF1ZXJ5KGJ1aWxkR2V0TWV0YWRhdGFRdWVyeShpbnB1dC5zck51bWJlciwgaW5wdXQubGFuZ3VhZ2UpKSxcbiAgICAgIHNwYXJxbENsaWVudC5xdWVyeShidWlsZEdldExhbmd1YWdlc1F1ZXJ5KGlucHV0LnNyTnVtYmVyKSksXG4gICAgICBzcGFycWxDbGllbnQucXVlcnkoYnVpbGRHZXRTdWJqZWN0c1F1ZXJ5KGlucHV0LnNyTnVtYmVyLCBpbnB1dC5sYW5ndWFnZSkpLFxuICAgICAgc3BhcnFsQ2xpZW50LnF1ZXJ5KGJ1aWxkR2V0VmVyc2lvbkhpc3RvcnlRdWVyeShpbnB1dC5zck51bWJlcikpLFxuICAgICAgc3BhcnFsQ2xpZW50LnF1ZXJ5KGJ1aWxkR2V0TGVnYWxTdGF0dXNRdWVyeShpbnB1dC5zck51bWJlcikpLFxuICAgICAgaW5wdXQuaW5jbHVkZVN0cnVjdHVyZVxuICAgICAgICA/IHNwYXJxbENsaWVudC5xdWVyeShidWlsZEdldFN0cnVjdHVyZVF1ZXJ5KGlucHV0LnNyTnVtYmVyLCBpbnB1dC5sYW5ndWFnZSkpXG4gICAgICAgIDogUHJvbWlzZS5yZXNvbHZlKHsgcmVzdWx0czogeyBiaW5kaW5nczogW10gfSB9KSxcbiAgICBdKTtcblxuICAgIGNvbnN0IG1ldGFkYXRhQmluZGluZ3MgPSBtZXRhZGF0YVJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzO1xuXG4gICAgaWYgKG1ldGFkYXRhQmluZGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBmb3VuZDogZmFsc2UsXG4gICAgICAgIHNlYXJjaFRpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgZmlyc3RCaW5kaW5nID0gbWV0YWRhdGFCaW5kaW5nc1swXTtcblxuICAgIC8vIFBhcnNlIGJhc2ljIG1ldGFkYXRhXG4gICAgY29uc3QgbWV0YWRhdGE6IEdldE1ldGFkYXRhUmVzdWx0WydtZXRhZGF0YSddID0ge1xuICAgICAgdXJpOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5hY3QpIHx8ICcnLFxuICAgICAgc3JOdW1iZXI6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLnNyTnVtYmVyKSB8fCAnJyxcbiAgICAgIHRpdGxlOiBzcGFycWxDbGllbnQuZXh0cmFjdE11bHRpbGluZ3VhbFZhbHVlKG1ldGFkYXRhQmluZGluZ3MsICd0aXRsZScpLFxuICAgICAgYWJicmV2aWF0aW9uOiBzcGFycWxDbGllbnQuZXh0cmFjdE11bHRpbGluZ3VhbFZhbHVlKG1ldGFkYXRhQmluZGluZ3MsICdhYmJyZXZpYXRpb24nKSxcbiAgICAgIGFjdFR5cGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmFjdFR5cGUpLFxuICAgICAgZGF0ZURvY3VtZW50OiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5kYXRlRG9jdW1lbnQpLFxuICAgICAgZGF0ZUluRm9yY2U6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmRhdGVJbkZvcmNlKSxcbiAgICAgIGRhdGVBYnJvZ2F0aW9uOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5kYXRlQWJyb2dhdGlvbiksXG4gICAgICBzdGF0dXM6ICd1bmtub3duJyxcbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgbGFuZ3VhZ2VzXG4gICAgbWV0YWRhdGEuYXZhaWxhYmxlTGFuZ3VhZ2VzID0gbGFuZ3VhZ2VzUmVzdWx0LnJlc3VsdHMuYmluZGluZ3NcbiAgICAgIC5tYXAoKGI6IFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+KSA9PiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIubGFuZ3VhZ2UpKVxuICAgICAgLmZpbHRlcigobGFuZyk6IGxhbmcgaXMgc3RyaW5nID0+ICEhbGFuZykgYXMgTGFuZ3VhZ2VbXTtcblxuICAgIC8vIFBhcnNlIHN1YmplY3RzL2tleXdvcmRzXG4gICAgY29uc3Qgc3ViamVjdHMgPSBzdWJqZWN0c1Jlc3VsdC5yZXN1bHRzLmJpbmRpbmdzXG4gICAgICAubWFwKChiOiBSZWNvcmQ8c3RyaW5nLCBTUEFSUUxCaW5kaW5nPikgPT4gc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiLmxhYmVsKSlcbiAgICAgIC5maWx0ZXIoKHMpOiBzIGlzIHN0cmluZyA9PiAhIXMpO1xuICAgIGlmIChzdWJqZWN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXRhZGF0YS5zdWJqZWN0cyA9IHN1YmplY3RzO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHZlcnNpb24gaGlzdG9yeVxuICAgIGNvbnN0IHZlcnNpb25zID0gaGlzdG9yeVJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzLm1hcCgoYjogUmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4pID0+ICh7XG4gICAgICBkYXRlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIudmVyc2lvbkRhdGUpIHx8ICcnLFxuICAgICAgdHlwZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiLnZlcnNpb25UeXBlKSxcbiAgICAgIGRlc2NyaXB0aW9uOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIuY2hhbmdlRGVzY3JpcHRpb24pLFxuICAgIH0pKTtcbiAgICBpZiAodmVyc2lvbnMubGVuZ3RoID4gMCkge1xuICAgICAgbWV0YWRhdGEudmVyc2lvbkhpc3RvcnkgPSB2ZXJzaW9ucztcbiAgICB9XG5cbiAgICAvLyBQYXJzZSBsZWdhbCBzdGF0dXNcbiAgICBpZiAoc3RhdHVzUmVzdWx0LnJlc3VsdHMuYmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc3RhdHVzQmluZGluZyA9IHN0YXR1c1Jlc3VsdC5yZXN1bHRzLmJpbmRpbmdzWzBdO1xuICAgICAgY29uc3Qgc3RhdHVzID0gc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShzdGF0dXNCaW5kaW5nLnN0YXR1cyk7XG4gICAgICBpZiAoc3RhdHVzID09PSAnaW5fZm9yY2UnIHx8IHN0YXR1cyA9PT0gJ2Ficm9nYXRlZCcgfHwgc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgbWV0YWRhdGEuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgfVxuICAgICAgbWV0YWRhdGEuYWJyb2dhdGVkQnkgPSBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKHN0YXR1c0JpbmRpbmcuYWJyb2dhdGVkQnkpO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIHN0cnVjdHVyZSAodGFibGUgb2YgY29udGVudHMpXG4gICAgaWYgKGlucHV0LmluY2x1ZGVTdHJ1Y3R1cmUgJiYgc3RydWN0dXJlUmVzdWx0LnJlc3VsdHMuYmluZGluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgbWV0YWRhdGEuc3RydWN0dXJlID0gc3RydWN0dXJlUmVzdWx0LnJlc3VsdHMuYmluZGluZ3MubWFwKChiOiBSZWNvcmQ8c3RyaW5nLCBTUEFSUUxCaW5kaW5nPikgPT4gKHtcbiAgICAgICAgcGFydE51bWJlcjogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiLnBhcnROdW1iZXIpIHx8ICcnLFxuICAgICAgICBwYXJ0VGl0bGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYi5wYXJ0VGl0bGUpLFxuICAgICAgICBwYXJ0VHlwZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiLnBhcnRUeXBlKSxcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgbGVnYWwgZG9tYWluIGluZm9cbiAgICBjb25zdCBkb21haW5QcmVmaXggPSBpbnB1dC5zck51bWJlci5zcGxpdCgnLicpWzBdO1xuICAgIGlmIChMRUdBTF9ET01BSU5TW2RvbWFpblByZWZpeF0pIHtcbiAgICAgIG1ldGFkYXRhLmxlZ2FsRG9tYWluID0gTEVHQUxfRE9NQUlOU1tkb21haW5QcmVmaXhdO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBmb3VuZDogdHJ1ZSxcbiAgICAgIG1ldGFkYXRhLFxuICAgICAgc2VhcmNoVGltZU1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignR2V0IG1ldGFkYXRhIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBNYWluIHNlcnZlciBzZXR1cFxuICovXG5hc3luYyBmdW5jdGlvbiBtYWluKCkge1xuICAvLyBJbml0aWFsaXplIFNQQVJRTCBjbGllbnRcbiAgaW5pdGlhbGl6ZUNsaWVudCgpO1xuXG4gIGNvbnN0IHNlcnZlciA9IG5ldyBTZXJ2ZXIoXG4gICAge1xuICAgICAgbmFtZTogXCJmZWRsZXgtc3BhcnFsXCIsXG4gICAgICB2ZXJzaW9uOiBcIjIuMC4xXCIsXG4gICAgfSxcbiAgICB7XG4gICAgICBjYXBhYmlsaXRpZXM6IHtcbiAgICAgICAgdG9vbHM6IHt9LFxuICAgICAgfSxcbiAgICB9XG4gICk7XG5cbiAgLy8gTGlzdCBhdmFpbGFibGUgdG9vbHNcbiAgc2VydmVyLnNldFJlcXVlc3RIYW5kbGVyKExpc3RUb29sc1JlcXVlc3RTY2hlbWEsIGFzeW5jICgpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdG9vbHM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwibG9va3VwX3N0YXR1dGVcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgIFwiTG9vayB1cCBhIFN3aXNzIGZlZGVyYWwgbGVnYWwgYWN0IGJ5IFNSIG51bWJlciAoZS5nLiwgJzIyMCcgZm9yIE9SKSBvciBhYmJyZXZpYXRpb24gKGUuZy4sICdPUicsICdaR0InKS4gUmV0dXJucyBiYXNpYyBpbmZvcm1hdGlvbiBpbmNsdWRpbmcgdGl0bGUsIHR5cGUsIGFuZCBzdGF0dXMgaW4gbXVsdGlwbGUgbGFuZ3VhZ2VzIChERS9GUi9JVCkuXCIsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIGlkZW50aWZpZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgICAgICAgXCJTUiBudW1iZXIgKGUuZy4sICcyMjAnLCAnMjEwJykgb3IgYWJicmV2aWF0aW9uIChlLmcuLCAnT1InLCAnWkdCJywgJ1N0R0InKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZW51bTogW1wiZGVcIiwgXCJmclwiLCBcIml0XCIsIFwicm1cIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUHJlZmVycmVkIGxhbmd1YWdlIGZvciByZXN1bHRzIChkZT1HZXJtYW4sIGZyPUZyZW5jaCwgaXQ9SXRhbGlhbiwgcm09Um9tYW5zaClcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wiaWRlbnRpZmllclwiXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJnZXRfYXJ0aWNsZVwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgXCJSZXRyaWV2ZSBhIHNwZWNpZmljIGFydGljbGUgd2l0aGluIGEgU3dpc3MgbGVnYWwgYWN0LiBSZXR1cm5zIGFydGljbGUgdGV4dCwgbWFyZ2luYWwgbm90ZXMsIHBhcmFncmFwaHMgKEFic1x1MDBFNHR6ZSksIGFuZCBsZXR0ZXJzIChCdWNoc3RhYmVuKSBpbiBzdHJ1Y3R1cmVkIGZvcm1hdC5cIixcbiAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgc3JOdW1iZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlNSIG51bWJlciBvZiB0aGUgbGVnYWwgYWN0IChlLmcuLCAnMjIwJyBmb3IgT1IpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFydGljbGVOdW1iZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkFydGljbGUgbnVtYmVyIChlLmcuLCAnOTcnLCAnNDEnLCAnQXJ0LiA5NycpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHBhcmFncmFwaDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU3BlY2lmaWMgcGFyYWdyYXBoL0Fic2F0eiBudW1iZXIgKG9wdGlvbmFsKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZW51bTogW1wiZGVcIiwgXCJmclwiLCBcIml0XCIsIFwicm1cIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUHJlZmVycmVkIGxhbmd1YWdlIGZvciBhcnRpY2xlIHRleHRcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wic3JOdW1iZXJcIiwgXCJhcnRpY2xlTnVtYmVyXCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcInNlYXJjaF9sZWdpc2xhdGlvblwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgXCJTZWFyY2ggYWNyb3NzIFN3aXNzIGZlZGVyYWwgbGVnaXNsYXRpb24gd2l0aCBmdWxsLXRleHQgc2VhcmNoIGFuZCBmaWx0ZXJzLiBTdXBwb3J0cyBmaWx0ZXJpbmcgYnkgbGVnYWwgZG9tYWluLCBkYXRlIHJhbmdlLCBhY3QgdHlwZSwgYW5kIGxhbmd1YWdlLlwiLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBxdWVyeToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiRnVsbC10ZXh0IHNlYXJjaCBxdWVyeSAoc2VhcmNoZXMgdGl0bGUgYW5kIFNSIG51bWJlcilcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZG9tYWluOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBlbnVtOiBbXCIxXCIsIFwiMlwiLCBcIjNcIiwgXCI0XCIsIFwiNVwiLCBcIjZcIiwgXCI3XCIsIFwiOFwiLCBcIjlcIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgICAgICBcIkxlZ2FsIGRvbWFpbiBmaWx0ZXIgYnkgU1IgcHJlZml4OiAxPVN0YXRlL0NvbnN0aXR1dGlvbmFsLCAyPVByaXZhdGUvQ2l2aWwsIDM9Q3JpbWluYWwsIDQ9RWR1Y2F0aW9uL0N1bHR1cmUsIDU9RGVmZW5zZSwgNj1GaW5hbmNlLCA3PVB1YmxpYyBXb3Jrcy9UcmFuc3BvcnQsIDg9SGVhbHRoL0xhYm9yL1NvY2lhbCBTZWN1cml0eSwgOT1FY29ub215XCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHNyTnVtYmVyUHJlZml4OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGaWx0ZXIgYnkgU1IgbnVtYmVyIHByZWZpeCAoZS5nLiwgJzIyJyBmb3IgY29udHJhY3QgbGF3KVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkYXRlRnJvbToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGaWx0ZXIgYWN0cyBpbiBmb3JjZSBmcm9tIHRoaXMgZGF0ZSAoSVNPIDg2MDE6IFlZWVktTU0tREQpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRhdGVUbzoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGaWx0ZXIgYWN0cyBpbiBmb3JjZSB1bnRpbCB0aGlzIGRhdGUgKElTTyA4NjAxOiBZWVlZLU1NLUREKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBhY3RUeXBlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIGl0ZW1zOiB7IHR5cGU6IFwic3RyaW5nXCIgfSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGaWx0ZXIgYnkgYWN0IHR5cGVzIChlLmcuLCAnQnVuZGVzZ2VzZXR6JywgJ1Zlcm9yZG51bmcnKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZW51bTogW1wiZGVcIiwgXCJmclwiLCBcIml0XCIsIFwicm1cIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiTGFuZ3VhZ2UgZmlsdGVyIGZvciByZXN1bHRzXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgICAgIG1heGltdW06IDEwMCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJNYXhpbXVtIG51bWJlciBvZiByZXN1bHRzXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIG9mZnNldDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiAwLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk9mZnNldCBmb3IgcGFnaW5hdGlvblwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJmaW5kX3JlbGF0ZWRcIixcbiAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgIFwiRmluZCBsZWdpc2xhdGlvbiByZWxhdGVkIHRvIGEgc3BlY2lmaWMgYWN0IHRocm91Z2ggYW1lbmRtZW50cywgY2l0YXRpb25zLCByZWZlcmVuY2VzLCBvciBzaGFyZWQgbGVnYWwgZG9tYWluLiBPcHRpb25hbGx5IGluY2x1ZGVzIGxlZ2lzbGF0aXZlIGhpc3RvcnkgKGNvbnNvbGlkYXRpb24gY2hhaW4pLlwiLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBzck51bWJlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU1IgbnVtYmVyIG9mIHRoZSBsZWdhbCBhY3QgKGUuZy4sICcyMjAnIGZvciBPUilcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVsYXRpb25UeXBlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBlbnVtOiBbXG4gICAgICAgICAgICAgICAgICBcImFtZW5kc1wiLFxuICAgICAgICAgICAgICAgICAgXCJhbWVuZGVkX2J5XCIsXG4gICAgICAgICAgICAgICAgICBcImNpdGVzXCIsXG4gICAgICAgICAgICAgICAgICBcImNpdGVkX2J5XCIsXG4gICAgICAgICAgICAgICAgICBcImltcGxlbWVudHNcIixcbiAgICAgICAgICAgICAgICAgIFwiaW1wbGVtZW50ZWRfYnlcIixcbiAgICAgICAgICAgICAgICAgIFwiYmFzZWRfb25cIixcbiAgICAgICAgICAgICAgICAgIFwic2FtZV9kb21haW5cIixcbiAgICAgICAgICAgICAgICAgIFwic2FtZV9zdWJqZWN0XCIsXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGaWx0ZXIgYnkgc3BlY2lmaWMgcmVsYXRpb24gdHlwZSAob3B0aW9uYWwgLSByZXR1cm5zIGFsbCBpZiBub3Qgc3BlY2lmaWVkKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbmNsdWRlSGlzdG9yeToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkluY2x1ZGUgbGVnaXNsYXRpdmUgaGlzdG9yeSAoY29uc29saWRhdGlvbiBjaGFpbilcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGVudW06IFtcImRlXCIsIFwiZnJcIiwgXCJpdFwiLCBcInJtXCJdLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlByZWZlcnJlZCBsYW5ndWFnZSBmb3IgcmVzdWx0c1wiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsaW1pdDoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgbWluaW11bTogMSxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiAxMDAsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogNTAsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiTWF4aW11bSBudW1iZXIgb2YgcmVsYXRlZCBhY3RzXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFtcInNyTnVtYmVyXCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImdldF9tZXRhZGF0YVwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgXCJHZXQgY29tcHJlaGVuc2l2ZSBtZXRhZGF0YSBhYm91dCBhIGxlZ2FsIGFjdCBpbmNsdWRpbmcgcHVibGljYXRpb24gaW5mbywgc3ViamVjdHMva2V5d29yZHMsIHZlcnNpb24gaGlzdG9yeSwgbGVnYWwgc3RhdHVzLCBhdmFpbGFibGUgbGFuZ3VhZ2VzLCBhbmQgb3B0aW9uYWxseSB0aGUgZG9jdW1lbnQgc3RydWN0dXJlICh0YWJsZSBvZiBjb250ZW50cykuXCIsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHNyTnVtYmVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTUiBudW1iZXIgb2YgdGhlIGxlZ2FsIGFjdCAoZS5nLiwgJzIyMCcgZm9yIE9SKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBpbmNsdWRlU3RydWN0dXJlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5jbHVkZSBkb2N1bWVudCBzdHJ1Y3R1cmUgKHRhYmxlIG9mIGNvbnRlbnRzIHdpdGggY2hhcHRlcnMsIHNlY3Rpb25zLCBhcnRpY2xlcylcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGFuZ3VhZ2U6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGVudW06IFtcImRlXCIsIFwiZnJcIiwgXCJpdFwiLCBcInJtXCJdLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlByZWZlcnJlZCBsYW5ndWFnZSBmb3IgbWV0YWRhdGEgdGV4dFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJzck51bWJlclwiXSxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgXSxcbiAgICB9O1xuICB9KTtcblxuICAvLyBIYW5kbGUgdG9vbCBjYWxsc1xuICBzZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoQ2FsbFRvb2xSZXF1ZXN0U2NoZW1hLCBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgIGNvbnN0IHsgbmFtZSwgYXJndW1lbnRzOiBhcmdzIH0gPSByZXF1ZXN0LnBhcmFtcztcblxuICAgIHRyeSB7XG4gICAgICBpZiAobmFtZSA9PT0gXCJsb29rdXBfc3RhdHV0ZVwiKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXJncyBhcyB1bmtub3duIGFzIExvb2t1cFN0YXR1dGVJbnB1dDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbG9va3VwU3RhdHV0ZShpbnB1dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IFwiZ2V0X2FydGljbGVcIikge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGFyZ3MgYXMgdW5rbm93biBhcyBHZXRBcnRpY2xlSW5wdXQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGdldEFydGljbGUoaW5wdXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSBcInNlYXJjaF9sZWdpc2xhdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXJncyBhcyB1bmtub3duIGFzIFNlYXJjaExlZ2lzbGF0aW9uSW5wdXQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNlYXJjaExlZ2lzbGF0aW9uKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gXCJmaW5kX3JlbGF0ZWRcIikge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGFyZ3MgYXMgdW5rbm93biBhcyBGaW5kUmVsYXRlZElucHV0O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmaW5kUmVsYXRlZChpbnB1dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IFwiZ2V0X21ldGFkYXRhXCIpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhcmdzIGFzIHVua25vd24gYXMgR2V0TWV0YWRhdGFJbnB1dDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0TWV0YWRhdGEoaW5wdXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biB0b29sOiAke25hbWV9YCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvci5tZXNzYWdlIDogU3RyaW5nKGVycm9yKTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoYFRvb2wgZXhlY3V0aW9uIGZhaWxlZDogJHtuYW1lfWAsIGVycm9yKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29udGVudDogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoeyBlcnJvcjogZXJyb3JNZXNzYWdlIH0sIG51bGwsIDIpLFxuICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RhcnQgc2VydmVyIHdpdGggc3RkaW8gdHJhbnNwb3J0XG4gIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBTdGRpb1NlcnZlclRyYW5zcG9ydCgpO1xuICBhd2FpdCBzZXJ2ZXIuY29ubmVjdCh0cmFuc3BvcnQpO1xuXG4gIGNvbnNvbGUuZXJyb3IoXCJGZWRsZXggU1BBUlFMIE1DUCBzZXJ2ZXIgcnVubmluZyBvbiBzdGRpb1wiKTtcbn1cblxubWFpbigpLmNhdGNoKChlcnJvcikgPT4ge1xuICBjb25zb2xlLmVycm9yKFwiRmF0YWwgZXJyb3IgaW4gbWFpbigpOlwiLCBlcnJvcik7XG4gIHByb2Nlc3MuZXhp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QVM7QUFDWCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sU0FBUyxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzNFO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFDQSxPQUFPLFNBQVM7QUFDWixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sVUFBVSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzVFO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFDQSxNQUFNLFNBQVM7QUFDWCxXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sU0FBUyxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzNFO0FBQUEsRUFDQSxLQUFLLFNBQVM7QUFDVixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sUUFBUSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzFFO0FBQUEsRUFDQSxPQUFPLFNBQVM7QUFDWixXQUFPLEtBQUssVUFBVSxFQUFFLE1BQU0sVUFBVSxHQUFHLFVBQVUsU0FBUyxPQUFPLEVBQUUsQ0FBQztBQUFBLEVBQzVFO0FBQUEsRUFDQSxVQUFVLFNBQVM7QUFFZixXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLEdBQUcsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLE9BQU8sR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUN6RTtBQUFBLEVBQ0EsR0FBRyxTQUFTO0FBQ1IsV0FBTyxLQUFLLFVB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QyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsVUFBVTtBQUFBLEVBQ2pFO0FBQUEsRUFDQSxJQUFJLFVBQVU7QUFDVixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLEVBQzlEO0FBQUEsRUFDQSxJQUFJLFFBQVE7QUFDUixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsS0FBSztBQUFBLEVBQzVEO0FBQUEsRUFDQSxJQUFJLFVBQVU7QUFDVixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLEVBQzlEO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQzdEO0FBQUEsRUFDQSxJQUFJLFdBQVc7QUFDWCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsUUFBUTtBQUFBLEVBQy9EO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQzdEO0FBQUEsRUFDQSxJQUFJLFVBQVU7QUFDVixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsT0FBTztBQUFBLEVBQzlEO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQzdEO0FBQUEsRUFDQSxJQUFJLE9BQU87QUFDUCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsSUFBSTtBQUFBLEVBQzNEO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsTUFBTTtBQUFBLEVBQzdEO0FBQUEsRUFDQSxJQUFJLFdBQVc7QUFDWCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsUUFBUTtBQUFBLEVBQy9EO0FBQUEsRUFDQSxJQUFJLGNBQWM7QUFFZCxXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsV0FBVztBQUFBLEVBQ2xFO0FBQUEsRUFDQSxJQUFJLFlBQVk7QUFDWixRQUFJLE1BQU07QUFDVixhQUFXLE1BQU0sS0FBSyxLQUFLO0FBQ3ZCLE1BQUksR0FBRyxTQUFTLFVBQ1IsUUFBUSxRQUFRLEdBQUcsUUFBUSxTQUMzQixNQUFNLEdBQUc7QUFHckIsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLElBQUksWUFBWTtBQUNaLFFBQUksTUFBTTtBQUNWLGFBQVcsTUFBTSxLQUFLLEtBQUs7QUFDdkIsTUFBSSxHQUFHLFNBQVMsVUFDUixRQUFRLFFBQVEsR0FBRyxRQUFRLFNBQzNCLE1BQU0sR0FBRztBQUdyQixXQUFPO0FBQUEsRUFDWDtBQUNKO0FBQ0EsVUFBVSxTQUFTLENBQUMsV0FDVCxJQUFJLFVBQVU7QUFBQSxFQUNqQixRQUFRLENBQUM7QUFBQSxFQUNULFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsUUFBUSxRQUFRLFVBQVU7QUFBQSxFQUMxQixHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFHTCxTQUFTLG1CQUFtQixLQUFLLE1BQU07QUFDbkMsTUFBTSxlQUFlLElBQUksU0FBUyxFQUFFLE1BQU0sR0FBRyxFQUFFLENBQUMsS0FBSyxJQUFJLFFBQ25ELGdCQUFnQixLQUFLLFNBQVMsRUFBRSxNQUFNLEdBQUcsRUFBRSxDQUFDLEtBQUssSUFBSSxRQUNyRCxXQUFXLGNBQWMsZUFBZSxjQUFjLGNBQ3RELFNBQVMsT0FBTyxTQUFTLElBQUksUUFBUSxRQUFRLEVBQUUsUUFBUSxLQUFLLEVBQUUsQ0FBQyxHQUMvRCxVQUFVLE9BQU8sU0FBUyxLQUFLLFFBQVEsUUFBUSxFQUFFLFFBQVEsS0FBSyxFQUFFLENBQUM7QUFDdkUsU0FBUSxTQUFTLFVBQVcsTUFBTTtBQUN0QztBQUNPLElBQU0sWUFBTixNQUFNLG1CQUFrQixRQUFRO0FBQUEsRUFDbkMsY0FBYztBQUNWLFVBQU0sR0FBRyxTQUFTLEdBQ2xCLEtBQUssTUFBTSxLQUFLLEtBQ2hCLEtBQUssTUFBTSxLQUFLLEtBQ2hCLEtBQUssT0FBTyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLE9BQU8sT0FBTztBQUtWLFFBSkksS0FBSyxLQUFLLFdBQ1YsTUFBTSxPQUFPLE9BQU8sTUFBTSxJQUFJLElBRWYsS0FBSyxTQUFTLEtBQUssTUFDbkIsY0FBYyxRQUFRO0FBQ3JDLFVBQU1DLE9BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0JBLE1BQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVQSxLQUFJO0FBQUEsTUFDbEIsQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUNBLFFBQUksS0FDRSxTQUFTLElBQUksWUFBWTtBQUMvQixhQUFXTixVQUFTLEtBQUssS0FBSztBQUMxQixNQUFJQSxPQUFNLFNBQVMsUUFDVixLQUFLLFVBQVUsTUFBTSxJQUFJLE1BQzFCLE1BQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHLEdBQ3JDLGtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsVUFBVTtBQUFBLFFBQ1YsVUFBVTtBQUFBLFFBQ1YsU0FBU0EsT0FBTTtBQUFBLE1BQ25CLENBQUMsR0FDRCxPQUFPLE1BQU0sS0FHWkEsT0FBTSxTQUFTLFNBQ0hBLE9BQU0sWUFBWSxNQUFNLE9BQU9BLE9BQU0sUUFBUSxNQUFNLFFBQVFBLE9BQU0sV0FFOUUsTUFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUcsR0FDckMsa0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixTQUFTQSxPQUFNO0FBQUEsUUFDZixNQUFNO0FBQUEsUUFDTixXQUFXQSxPQUFNO0FBQUEsUUFDakIsT0FBTztBQUFBLFFBQ1AsU0FBU0EsT0FBTTtBQUFBLE1BQ25CLENBQUMsR0FDRCxPQUFPLE1BQU0sS0FHWkEsT0FBTSxTQUFTLFNBQ0xBLE9BQU0sWUFBWSxNQUFNLE9BQU9BLE9BQU0sUUFBUSxNQUFNLFFBQVFBLE9BQU0sV0FFNUUsTUFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUcsR0FDckMsa0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixTQUFTQSxPQUFNO0FBQUEsUUFDZixNQUFNO0FBQUEsUUFDTixXQUFXQSxPQUFNO0FBQUEsUUFDakIsT0FBTztBQUFBLFFBQ1AsU0FBU0EsT0FBTTtBQUFBLE1BQ25CLENBQUMsR0FDRCxPQUFPLE1BQU0sS0FHWkEsT0FBTSxTQUFTLGVBQ2hCLG1CQUFtQixNQUFNLE1BQU1BLE9BQU0sS0FBSyxNQUFNLE1BQ2hELE1BQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHLEdBQ3JDLGtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsWUFBWUEsT0FBTTtBQUFBLFFBQ2xCLFNBQVNBLE9BQU07QUFBQSxNQUNuQixDQUFDLEdBQ0QsT0FBTyxNQUFNLEtBR1pBLE9BQU0sU0FBUyxXQUNmLE9BQU8sU0FBUyxNQUFNLElBQUksTUFDM0IsTUFBTSxLQUFLLGdCQUFnQixPQUFPLEdBQUcsR0FDckMsa0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixTQUFTQSxPQUFNO0FBQUEsTUFDbkIsQ0FBQyxHQUNELE9BQU8sTUFBTSxLQUlqQixLQUFLLFlBQVlBLE1BQUs7QUFHOUIsV0FBTyxFQUFFLFFBQVEsT0FBTyxPQUFPLE9BQU8sTUFBTSxLQUFLO0FBQUEsRUFDckQ7QUFBQSxFQUNBLElBQUksT0FBTyxTQUFTO0FBQ2hCLFdBQU8sS0FBSyxTQUFTLE9BQU8sT0FBTyxJQUFNLFVBQVUsU0FBUyxPQUFPLENBQUM7QUFBQSxFQUN4RTtBQUFBLEVBQ0EsR0FBRyxPQUFPLFNBQVM7QUFDZixXQUFPLEtBQUssU0FBUyxPQUFPLE9BQU8sSUFBTyxVQUFVLFNBQVMsT0FBTyxDQUFDO0FBQUEsRUFDekU7QUFBQSxFQUNBLElBQUksT0FBTyxTQUFTO0FBQ2hCLFdBQU8sS0FBSyxTQUFTLE9BQU8sT0FBTyxJQUFNLFVBQVUsU0FBUyxPQUFPLENBQUM7QUFBQSxFQUN4RTtBQUFBLEVBQ0EsR0FBRyxPQUFPLFNBQVM7QUFDZixXQUFPLEtBQUssU0FBUyxPQUFPLE9BQU8sSUFBTyxVQUFVLFNBQVMsT0FBTyxDQUFDO0FBQUEsRUFDekU7QUFBQSxFQUNBLFNBQVMsTUFBTSxPQUFPLFdBQVcsU0FBUztBQUN0QyxXQUFPLElBQUksV0FBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsUUFBUTtBQUFBLFFBQ0osR0FBRyxLQUFLLEtBQUs7QUFBQSxRQUNiO0FBQUEsVUFDSTtBQUFBLFVBQ0E7QUFBQSxVQUNBO0FBQUEsVUFDQSxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsUUFDdkM7QUFBQSxNQUNKO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsVUFBVUEsUUFBTztBQUNiLFdBQU8sSUFBSSxXQUFVO0FBQUEsTUFDakIsR0FBRyxLQUFLO0FBQUEsTUFDUixRQUFRLENBQUMsR0FBRyxLQUFLLEtBQUssUUFBUUEsTUFBSztBQUFBLElBQ3ZDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsU0FBUyxTQUFTO0FBQ2QsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxXQUFXO0FBQUEsTUFDWCxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFNBQVMsU0FBUztBQUNkLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sT0FBTztBQUFBLE1BQ1AsV0FBVztBQUFBLE1BQ1gsU0FBUyxVQUFVLFNBQVMsT0FBTztBQUFBLElBQ3ZDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxZQUFZLFNBQVM7QUFDakIsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixPQUFPO0FBQUEsTUFDUCxXQUFXO0FBQUEsTUFDWCxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFlBQVksU0FBUztBQUNqQixXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLE9BQU87QUFBQSxNQUNQLFdBQVc7QUFBQSxNQUNYLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsV0FBVyxPQUFPLFNBQVM7QUFDdkIsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0EsU0FBUyxVQUFVLFNBQVMsT0FBTztBQUFBLElBQ3ZDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxPQUFPLFNBQVM7QUFDWixXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxPQUFPLE9BQU87QUFBQSxNQUNkLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUN2QyxDQUFDLEVBQUUsVUFBVTtBQUFBLE1BQ1QsTUFBTTtBQUFBLE1BQ04sV0FBVztBQUFBLE1BQ1gsT0FBTyxPQUFPO0FBQUEsTUFDZCxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUksV0FBVztBQUNYLFFBQUksTUFBTTtBQUNWLGFBQVcsTUFBTSxLQUFLLEtBQUs7QUFDdkIsTUFBSSxHQUFHLFNBQVMsVUFDUixRQUFRLFFBQVEsR0FBRyxRQUFRLFNBQzNCLE1BQU0sR0FBRztBQUdyQixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQ1gsUUFBSSxNQUFNO0FBQ1YsYUFBVyxNQUFNLEtBQUssS0FBSztBQUN2QixNQUFJLEdBQUcsU0FBUyxVQUNSLFFBQVEsUUFBUSxHQUFHLFFBQVEsU0FDM0IsTUFBTSxHQUFHO0FBR3JCLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxJQUFJLFFBQVE7QUFDUixXQUFPLENBQUMsQ0FBQyxLQUFLLEtBQUssT0FBTyxLQUFLLENBQUMsT0FBTyxHQUFHLFNBQVMsU0FBVSxHQUFHLFNBQVMsZ0JBQWdCLEtBQUssVUFBVSxHQUFHLEtBQUssQ0FBRTtBQUFBLEVBQ3RIO0FBQUEsRUFDQSxJQUFJLFdBQVc7QUFDWCxRQUFJLE1BQU0sTUFDTixNQUFNO0FBQ1YsYUFBVyxNQUFNLEtBQUssS0FBSyxRQUFRO0FBQy9CLFVBQUksR0FBRyxTQUFTLFlBQVksR0FBRyxTQUFTLFNBQVMsR0FBRyxTQUFTO0FBQ3pELGVBQU87QUFFTixNQUFJLEdBQUcsU0FBUyxTQUNiLFFBQVEsUUFBUSxHQUFHLFFBQVEsU0FDM0IsTUFBTSxHQUFHLFNBRVIsR0FBRyxTQUFTLFVBQ2IsUUFBUSxRQUFRLEdBQUcsUUFBUSxTQUMzQixNQUFNLEdBQUc7QUFBQSxJQUVyQjtBQUNBLFdBQU8sT0FBTyxTQUFTLEdBQUcsS0FBSyxPQUFPLFNBQVMsR0FBRztBQUFBLEVBQ3REO0FBQ0o7QUFDQSxVQUFVLFNBQVMsQ0FBQyxXQUNULElBQUksVUFBVTtBQUFBLEVBQ2pCLFFBQVEsQ0FBQztBQUFBLEVBQ1QsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxRQUFRLFFBQVEsVUFBVTtBQUFBLEVBQzFCLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVFLElBQU0sWUFBTixNQUFNLG1CQUFrQixRQUFRO0FBQUEsRUFDbkMsY0FBYztBQUNWLFVBQU0sR0FBRyxTQUFTLEdBQ2xCLEtBQUssTUFBTSxLQUFLLEtBQ2hCLEtBQUssTUFBTSxLQUFLO0FBQUEsRUFDcEI7QUFBQSxFQUNBLE9BQU8sT0FBTztBQUNWLFFBQUksS0FBSyxLQUFLO0FBQ1YsVUFBSTtBQUNBLGNBQU0sT0FBTyxPQUFPLE1BQU0sSUFBSTtBQUFBLE1BQ2xDLFFBQ007QUFDRixlQUFPLEtBQUssaUJBQWlCLEtBQUs7QUFBQSxNQUN0QztBQUdKLFFBRG1CLEtBQUssU0FBUyxLQUFLLE1BQ25CLGNBQWM7QUFDN0IsYUFBTyxLQUFLLGlCQUFpQixLQUFLO0FBRXRDLFFBQUksS0FDRSxTQUFTLElBQUksWUFBWTtBQUMvQixhQUFXQSxVQUFTLEtBQUssS0FBSztBQUMxQixNQUFJQSxPQUFNLFNBQVMsU0FDRUEsT0FBTSxZQUFZLE1BQU0sT0FBT0EsT0FBTSxRQUFRLE1BQU0sUUFBUUEsT0FBTSxXQUU5RSxNQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRyxHQUNyQyxrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLE1BQU07QUFBQSxRQUNOLFNBQVNBLE9BQU07QUFBQSxRQUNmLFdBQVdBLE9BQU07QUFBQSxRQUNqQixTQUFTQSxPQUFNO0FBQUEsTUFDbkIsQ0FBQyxHQUNELE9BQU8sTUFBTSxLQUdaQSxPQUFNLFNBQVMsU0FDTEEsT0FBTSxZQUFZLE1BQU0sT0FBT0EsT0FBTSxRQUFRLE1BQU0sUUFBUUEsT0FBTSxXQUU1RSxNQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRyxHQUNyQyxrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLE1BQU07QUFBQSxRQUNOLFNBQVNBLE9BQU07QUFBQSxRQUNmLFdBQVdBLE9BQU07QUFBQSxRQUNqQixTQUFTQSxPQUFNO0FBQUEsTUFDbkIsQ0FBQyxHQUNELE9BQU8sTUFBTSxLQUdaQSxPQUFNLFNBQVMsZUFDaEIsTUFBTSxPQUFPQSxPQUFNLFVBQVUsT0FBTyxDQUFDLE1BQ3JDLE1BQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHLEdBQ3JDLGtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsWUFBWUEsT0FBTTtBQUFBLFFBQ2xCLFNBQVNBLE9BQU07QUFBQSxNQUNuQixDQUFDLEdBQ0QsT0FBTyxNQUFNLEtBSWpCLEtBQUssWUFBWUEsTUFBSztBQUc5QixXQUFPLEVBQUUsUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNLEtBQUs7QUFBQSxFQUNyRDtBQUFBLEVBQ0EsaUJBQWlCLE9BQU87QUFDcEIsUUFBTSxNQUFNLEtBQUssZ0JBQWdCLEtBQUs7QUFDdEMsNkJBQWtCLEtBQUs7QUFBQSxNQUNuQixNQUFNLGFBQWE7QUFBQSxNQUNuQixVQUFVLGNBQWM7QUFBQSxNQUN4QixVQUFVLElBQUk7QUFBQSxJQUNsQixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQUEsRUFDQSxJQUFJLE9BQU8sU0FBUztBQUNoQixXQUFPLEtBQUssU0FBUyxPQUFPLE9BQU8sSUFBTSxVQUFVLFNBQVMsT0FBTyxDQUFDO0FBQUEsRUFDeEU7QUFBQSxFQUNBLEdBQUcsT0FBTyxTQUFTO0FBQ2YsV0FBTyxLQUFLLFNBQVMsT0FBTyxPQUFPLElBQU8sVUFBVSxTQUFTLE9BQU8sQ0FBQztBQUFBLEVBQ3pFO0FBQUEsRUFDQSxJQUFJLE9BQU8sU0FBUztBQUNoQixXQUFPLEtBQUssU0FBUyxPQUFPLE9BQU8sSUFBTSxVQUFVLFNBQVMsT0FBTyxDQUFDO0FBQUEsRUFDeEU7QUFBQSxFQUNBLEdBQUcsT0FBTyxTQUFTO0FBQ2YsV0FBTyxLQUFLLFNBQVMsT0FBTyxPQUFPLElBQU8sVUFBVSxTQUFTLE9BQU8sQ0FBQztBQUFBLEVBQ3pFO0FBQUEsRUFDQSxTQUFTLE1BQU0sT0FBTyxXQUFXLFNBQVM7QUFDdEMsV0FBTyxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLFFBQVE7QUFBQSxRQUNKLEdBQUcsS0FBSyxLQUFLO0FBQUEsUUFDYjtBQUFBLFVBQ0k7QUFBQSxVQUNBO0FBQUEsVUFDQTtBQUFBLFVBQ0EsU0FBUyxVQUFVLFNBQVMsT0FBTztBQUFBLFFBQ3ZDO0FBQUEsTUFDSjtBQUFBLElBQ0osQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFVBQVVBLFFBQU87QUFDYixXQUFPLElBQUksV0FBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsUUFBUSxDQUFDLEdBQUcsS0FBSyxLQUFLLFFBQVFBLE1BQUs7QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsU0FBUyxTQUFTO0FBQ2QsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixPQUFPLE9BQU8sQ0FBQztBQUFBLE1BQ2YsV0FBVztBQUFBLE1BQ1gsU0FBUyxVQUFVLFNBQVMsT0FBTztBQUFBLElBQ3ZDLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxTQUFTLFNBQVM7QUFDZCxXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLE9BQU8sT0FBTyxDQUFDO0FBQUEsTUFDZixXQUFXO0FBQUEsTUFDWCxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFlBQVksU0FBUztBQUNqQixXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLE9BQU8sT0FBTyxDQUFDO0FBQUEsTUFDZixXQUFXO0FBQUEsTUFDWCxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFlBQVksU0FBUztBQUNqQixXQUFPLEtBQUssVUFBVTtBQUFBLE1BQ2xCLE1BQU07QUFBQSxNQUNOLE9BQU8sT0FBTyxDQUFDO0FBQUEsTUFDZixXQUFXO0FBQUEsTUFDWCxTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFdBQVcsT0FBTyxTQUFTO0FBQ3ZCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLFNBQVMsVUFBVSxTQUFTLE9BQU87QUFBQSxJQUN2QyxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQ1gsUUFBSSxNQUFNO0FBQ1YsYUFBVyxNQUFNLEtBQUssS0FBSztBQUN2QixNQUFJLEdBQUcsU0FBUyxVQUNSLFFBQVEsUUFBUSxHQUFHLFFBQVEsU0FDM0IsTUFBTSxHQUFHO0FBR3JCLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxJQUFJLFdBQVc7QUFDWCxRQUFJLE1BQU07QUFDVixhQUFXLE1BQU0sS0FBSyxLQUFLO0FBQ3ZCLE1BQUksR0FBRyxTQUFTLFVBQ1IsUUFBUSxRQUFRLEdBQUcsUUFBUSxTQUMzQixNQUFNLEdBQUc7QUFHckIsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUNBLFVBQVUsU0FBUyxDQUFDLFdBQ1QsSUFBSSxVQUFVO0FBQUEsRUFDakIsUUFBUSxDQUFDO0FBQUEsRUFDVCxVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLFFBQVEsUUFBUSxVQUFVO0FBQUEsRUFDMUIsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUUsSUFBTSxhQUFOLGNBQXlCLFFBQVE7QUFBQSxFQUNwQyxPQUFPLE9BQU87QUFLVixRQUpJLEtBQUssS0FBSyxXQUNWLE1BQU0sT0FBTyxFQUFRLE1BQU0sT0FFWixLQUFLLFNBQVMsS0FBSyxNQUNuQixjQUFjLFNBQVM7QUFDdEMsVUFBTSxNQUFNLEtBQUssZ0JBQWdCLEtBQUs7QUFDdEMsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVLElBQUk7QUFBQSxNQUNsQixDQUFDLEdBQ007QUFBQSxJQUNYO0FBQ0EsV0FBTyxHQUFHLE1BQU0sSUFBSTtBQUFBLEVBQ3hCO0FBQ0o7QUFDQSxXQUFXLFNBQVMsQ0FBQyxXQUNWLElBQUksV0FBVztBQUFBLEVBQ2xCLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsUUFBUSxRQUFRLFVBQVU7QUFBQSxFQUMxQixHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFVBQU4sTUFBTSxpQkFBZ0IsUUFBUTtBQUFBLEVBQ2pDLE9BQU8sT0FBTztBQUtWLFFBSkksS0FBSyxLQUFLLFdBQ1YsTUFBTSxPQUFPLElBQUksS0FBSyxNQUFNLElBQUksSUFFakIsS0FBSyxTQUFTLEtBQUssTUFDbkIsY0FBYyxNQUFNO0FBQ25DLFVBQU1NLE9BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0JBLE1BQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVQSxLQUFJO0FBQUEsTUFDbEIsQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUNBLFFBQUksT0FBTyxNQUFNLE1BQU0sS0FBSyxRQUFRLENBQUMsR0FBRztBQUNwQyxVQUFNQSxPQUFNLEtBQUssZ0JBQWdCLEtBQUs7QUFDdEMsK0JBQWtCQSxNQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsTUFDdkIsQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUNBLFFBQU0sU0FBUyxJQUFJLFlBQVksR0FDM0I7QUFDSixhQUFXTixVQUFTLEtBQUssS0FBSztBQUMxQixNQUFJQSxPQUFNLFNBQVMsUUFDWCxNQUFNLEtBQUssUUFBUSxJQUFJQSxPQUFNLFVBQzdCLE1BQU0sS0FBSyxnQkFBZ0IsT0FBTyxHQUFHLEdBQ3JDLGtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsU0FBU0EsT0FBTTtBQUFBLFFBQ2YsV0FBVztBQUFBLFFBQ1gsT0FBTztBQUFBLFFBQ1AsU0FBU0EsT0FBTTtBQUFBLFFBQ2YsTUFBTTtBQUFBLE1BQ1YsQ0FBQyxHQUNELE9BQU8sTUFBTSxLQUdaQSxPQUFNLFNBQVMsUUFDaEIsTUFBTSxLQUFLLFFBQVEsSUFBSUEsT0FBTSxVQUM3QixNQUFNLEtBQUssZ0JBQWdCLE9BQU8sR0FBRyxHQUNyQyxrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFNBQVNBLE9BQU07QUFBQSxRQUNmLFdBQVc7QUFBQSxRQUNYLE9BQU87QUFBQSxRQUNQLFNBQVNBLE9BQU07QUFBQSxRQUNmLE1BQU07QUFBQSxNQUNWLENBQUMsR0FDRCxPQUFPLE1BQU0sS0FJakIsS0FBSyxZQUFZQSxNQUFLO0FBRzlCLFdBQU87QUFBQSxNQUNILFFBQVEsT0FBTztBQUFBLE1BQ2YsT0FBTyxJQUFJLEtBQUssTUFBTSxLQUFLLFFBQVEsQ0FBQztBQUFBLElBQ3hDO0FBQUEsRUFDSjtBQUFBLEVBQ0EsVUFBVUEsUUFBTztBQUNiLFdBQU8sSUFBSSxTQUFRO0FBQUEsTUFDZixHQUFHLEtBQUs7QUFBQSxNQUNSLFFBQVEsQ0FBQyxHQUFHLEtBQUssS0FBSyxRQUFRQSxNQUFLO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUksU0FBUyxTQUFTO0FBQ2xCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sT0FBTyxRQUFRLFFBQVE7QUFBQSxNQUN2QixTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUksU0FBUyxTQUFTO0FBQ2xCLFdBQU8sS0FBSyxVQUFVO0FBQUEsTUFDbEIsTUFBTTtBQUFBLE1BQ04sT0FBTyxRQUFRLFFBQVE7QUFBQSxNQUN2QixTQUFTLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDdkMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFFBQUksTUFBTTtBQUNWLGFBQVcsTUFBTSxLQUFLLEtBQUs7QUFDdkIsTUFBSSxHQUFHLFNBQVMsVUFDUixRQUFRLFFBQVEsR0FBRyxRQUFRLFNBQzNCLE1BQU0sR0FBRztBQUdyQixXQUFPLE9BQU8sT0FBTyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQUEsRUFDekM7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFFBQUksTUFBTTtBQUNWLGFBQVcsTUFBTSxLQUFLLEtBQUs7QUFDdkIsTUFBSSxHQUFHLFNBQVMsVUFDUixRQUFRLFFBQVEsR0FBRyxRQUFRLFNBQzNCLE1BQU0sR0FBRztBQUdyQixXQUFPLE9BQU8sT0FBTyxJQUFJLEtBQUssR0FBRyxJQUFJO0FBQUEsRUFDekM7QUFDSjtBQUNBLFFBQVEsU0FBUyxDQUFDLFdBQ1AsSUFBSSxRQUFRO0FBQUEsRUFDZixRQUFRLENBQUM7QUFBQSxFQUNULFFBQVEsUUFBUSxVQUFVO0FBQUEsRUFDMUIsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFlBQU4sY0FBd0IsUUFBUTtBQUFBLEVBQ25DLE9BQU8sT0FBTztBQUVWLFFBRG1CLEtBQUssU0FBUyxLQUFLLE1BQ25CLGNBQWMsUUFBUTtBQUNyQyxVQUFNLE1BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFDSjtBQUNBLFVBQVUsU0FBUyxDQUFDLFdBQ1QsSUFBSSxVQUFVO0FBQUEsRUFDakIsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLGVBQU4sY0FBMkIsUUFBUTtBQUFBLEVBQ3RDLE9BQU8sT0FBTztBQUVWLFFBRG1CLEtBQUssU0FBUyxLQUFLLE1BQ25CLGNBQWMsV0FBVztBQUN4QyxVQUFNLE1BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFDSjtBQUNBLGFBQWEsU0FBUyxDQUFDLFdBQ1osSUFBSSxhQUFhO0FBQUEsRUFDcEIsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFVBQU4sY0FBc0IsUUFBUTtBQUFBLEVBQ2pDLE9BQU8sT0FBTztBQUVWLFFBRG1CLEtBQUssU0FBUyxLQUFLLE1BQ25CLGNBQWMsTUFBTTtBQUNuQyxVQUFNLE1BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFDSjtBQUNBLFFBQVEsU0FBUyxDQUFDLFdBQ1AsSUFBSSxRQUFRO0FBQUEsRUFDZixVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVFLElBQU0sU0FBTixjQUFxQixRQUFRO0FBQUEsRUFDaEMsY0FBYztBQUNWLFVBQU0sR0FBRyxTQUFTLEdBRWxCLEtBQUssT0FBTztBQUFBLEVBQ2hCO0FBQUEsRUFDQSxPQUFPLE9BQU87QUFDVixXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFDSjtBQUNBLE9BQU8sU0FBUyxDQUFDLFdBQ04sSUFBSSxPQUFPO0FBQUEsRUFDZCxVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVFLElBQU0sYUFBTixjQUF5QixRQUFRO0FBQUEsRUFDcEMsY0FBYztBQUNWLFVBQU0sR0FBRyxTQUFTLEdBRWxCLEtBQUssV0FBVztBQUFBLEVBQ3BCO0FBQUEsRUFDQSxPQUFPLE9BQU87QUFDVixXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFDSjtBQUNBLFdBQVcsU0FBUyxDQUFDLFdBQ1YsSUFBSSxXQUFXO0FBQUEsRUFDbEIsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFdBQU4sY0FBdUIsUUFBUTtBQUFBLEVBQ2xDLE9BQU8sT0FBTztBQUNWLFFBQU0sTUFBTSxLQUFLLGdCQUFnQixLQUFLO0FBQ3RDLDZCQUFrQixLQUFLO0FBQUEsTUFDbkIsTUFBTSxhQUFhO0FBQUEsTUFDbkIsVUFBVSxjQUFjO0FBQUEsTUFDeEIsVUFBVSxJQUFJO0FBQUEsSUFDbEIsQ0FBQyxHQUNNO0FBQUEsRUFDWDtBQUNKO0FBQ0EsU0FBUyxTQUFTLENBQUMsV0FDUixJQUFJLFNBQVM7QUFBQSxFQUNoQixVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVFLElBQU0sVUFBTixjQUFzQixRQUFRO0FBQUEsRUFDakMsT0FBTyxPQUFPO0FBRVYsUUFEbUIsS0FBSyxTQUFTLEtBQUssTUFDbkIsY0FBYyxXQUFXO0FBQ3hDLFVBQU0sTUFBTSxLQUFLLGdCQUFnQixLQUFLO0FBQ3RDLCtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsVUFBVSxjQUFjO0FBQUEsUUFDeEIsVUFBVSxJQUFJO0FBQUEsTUFDbEIsQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUNBLFdBQU8sR0FBRyxNQUFNLElBQUk7QUFBQSxFQUN4QjtBQUNKO0FBQ0EsUUFBUSxTQUFTLENBQUMsV0FDUCxJQUFJLFFBQVE7QUFBQSxFQUNmLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUUsSUFBTSxXQUFOLE1BQU0sa0JBQWlCLFFBQVE7QUFBQSxFQUNsQyxPQUFPLE9BQU87QUFDVixRQUFNLEVBQUUsS0FBSyxPQUFPLElBQUksS0FBSyxvQkFBb0IsS0FBSyxHQUNoRCxNQUFNLEtBQUs7QUFDakIsUUFBSSxJQUFJLGVBQWUsY0FBYztBQUNqQywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUVYLFFBQUksSUFBSSxnQkFBZ0IsTUFBTTtBQUMxQixVQUFNLFNBQVMsSUFBSSxLQUFLLFNBQVMsSUFBSSxZQUFZLE9BQzNDLFdBQVcsSUFBSSxLQUFLLFNBQVMsSUFBSSxZQUFZO0FBQ25ELE9BQUksVUFBVSxjQUNWLGtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxTQUFTLGFBQWEsVUFBVSxhQUFhO0FBQUEsUUFDbkQsU0FBVSxXQUFXLElBQUksWUFBWSxRQUFRO0FBQUEsUUFDN0MsU0FBVSxTQUFTLElBQUksWUFBWSxRQUFRO0FBQUEsUUFDM0MsTUFBTTtBQUFBLFFBQ04sV0FBVztBQUFBLFFBQ1gsT0FBTztBQUFBLFFBQ1AsU0FBUyxJQUFJLFlBQVk7QUFBQSxNQUM3QixDQUFDLEdBQ0QsT0FBTyxNQUFNO0FBQUEsSUFFckI7QUEyQkEsUUExQkksSUFBSSxjQUFjLFFBQ2QsSUFBSSxLQUFLLFNBQVMsSUFBSSxVQUFVLFVBQ2hDLGtCQUFrQixLQUFLO0FBQUEsTUFDbkIsTUFBTSxhQUFhO0FBQUEsTUFDbkIsU0FBUyxJQUFJLFVBQVU7QUFBQSxNQUN2QixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxTQUFTLElBQUksVUFBVTtBQUFBLElBQzNCLENBQUMsR0FDRCxPQUFPLE1BQU0sSUFHakIsSUFBSSxjQUFjLFFBQ2QsSUFBSSxLQUFLLFNBQVMsSUFBSSxVQUFVLFVBQ2hDLGtCQUFrQixLQUFLO0FBQUEsTUFDbkIsTUFBTSxhQUFhO0FBQUEsTUFDbkIsU0FBUyxJQUFJLFVBQVU7QUFBQSxNQUN2QixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxTQUFTLElBQUksVUFBVTtBQUFBLElBQzNCLENBQUMsR0FDRCxPQUFPLE1BQU0sSUFHakIsSUFBSSxPQUFPO0FBQ1gsYUFBTyxRQUFRLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLE1BQ2pDLElBQUksS0FBSyxZQUFZLElBQUksbUJBQW1CLEtBQUssTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQzdFLENBQUMsRUFBRSxLQUFLLENBQUNPLFlBQ0MsWUFBWSxXQUFXLFFBQVFBLE9BQU0sQ0FDL0M7QUFFTCxRQUFNLFNBQVMsQ0FBQyxHQUFHLElBQUksSUFBSSxFQUFFLElBQUksQ0FBQyxNQUFNLE1BQzdCLElBQUksS0FBSyxXQUFXLElBQUksbUJBQW1CLEtBQUssTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQzVFO0FBQ0QsV0FBTyxZQUFZLFdBQVcsUUFBUSxNQUFNO0FBQUEsRUFDaEQ7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLElBQUksV0FBVyxTQUFTO0FBQ3BCLFdBQU8sSUFBSSxVQUFTO0FBQUEsTUFDaEIsR0FBRyxLQUFLO0FBQUEsTUFDUixXQUFXLEVBQUUsT0FBTyxXQUFXLFNBQVMsVUFBVSxTQUFTLE9BQU8sRUFBRTtBQUFBLElBQ3hFLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxJQUFJLFdBQVcsU0FBUztBQUNwQixXQUFPLElBQUksVUFBUztBQUFBLE1BQ2hCLEdBQUcsS0FBSztBQUFBLE1BQ1IsV0FBVyxFQUFFLE9BQU8sV0FBVyxTQUFTLFVBQVUsU0FBUyxPQUFPLEVBQUU7QUFBQSxJQUN4RSxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsT0FBTyxLQUFLLFNBQVM7QUFDakIsV0FBTyxJQUFJLFVBQVM7QUFBQSxNQUNoQixHQUFHLEtBQUs7QUFBQSxNQUNSLGFBQWEsRUFBRSxPQUFPLEtBQUssU0FBUyxVQUFVLFNBQVMsT0FBTyxFQUFFO0FBQUEsSUFDcEUsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLFNBQVMsU0FBUztBQUNkLFdBQU8sS0FBSyxJQUFJLEdBQUcsT0FBTztBQUFBLEVBQzlCO0FBQ0o7QUFDQSxTQUFTLFNBQVMsQ0FBQyxRQUFRLFdBQ2hCLElBQUksU0FBUztBQUFBLEVBQ2hCLE1BQU07QUFBQSxFQUNOLFdBQVc7QUFBQSxFQUNYLFdBQVc7QUFBQSxFQUNYLGFBQWE7QUFBQSxFQUNiLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUwsU0FBUyxlQUFlLFFBQVE7QUFDNUIsTUFBSSxrQkFBa0IsV0FBVztBQUM3QixRQUFNLFdBQVcsQ0FBQztBQUNsQixhQUFXLE9BQU8sT0FBTyxPQUFPO0FBQzVCLFVBQU0sY0FBYyxPQUFPLE1BQU0sR0FBRztBQUNwQyxlQUFTLEdBQUcsSUFBSSxZQUFZLE9BQU8sZUFBZSxXQUFXLENBQUM7QUFBQSxJQUNsRTtBQUNBLFdBQU8sSUFBSSxVQUFVO0FBQUEsTUFDakIsR0FBRyxPQUFPO0FBQUEsTUFDVixPQUFPLE1BQU07QUFBQSxJQUNqQixDQUFDO0FBQUEsRUFDTCxNQUNLLFFBQUksa0JBQWtCLFdBQ2hCLElBQUksU0FBUztBQUFBLElBQ2hCLEdBQUcsT0FBTztBQUFBLElBQ1YsTUFBTSxlQUFlLE9BQU8sT0FBTztBQUFBLEVBQ3ZDLENBQUMsSUFFSSxrQkFBa0IsY0FDaEIsWUFBWSxPQUFPLGVBQWUsT0FBTyxPQUFPLENBQUMsQ0FBQyxJQUVwRCxrQkFBa0IsY0FDaEIsWUFBWSxPQUFPLGVBQWUsT0FBTyxPQUFPLENBQUMsQ0FBQyxJQUVwRCxrQkFBa0IsV0FDaEIsU0FBUyxPQUFPLE9BQU8sTUFBTSxJQUFJLENBQUMsU0FBUyxlQUFlLElBQUksQ0FBQyxDQUFDLElBR2hFO0FBRWY7QUFDTyxJQUFNLFlBQU4sTUFBTSxtQkFBa0IsUUFBUTtBQUFBLEVBQ25DLGNBQWM7QUFDVixVQUFNLEdBQUcsU0FBUyxHQUNsQixLQUFLLFVBQVUsTUFLZixLQUFLLFlBQVksS0FBSyxhQXFDdEIsS0FBSyxVQUFVLEtBQUs7QUFBQSxFQUN4QjtBQUFBLEVBQ0EsYUFBYTtBQUNULFFBQUksS0FBSyxZQUFZO0FBQ2pCLGFBQU8sS0FBSztBQUNoQixRQUFNLFFBQVEsS0FBSyxLQUFLLE1BQU0sR0FDeEIsT0FBTyxLQUFLLFdBQVcsS0FBSztBQUNsQyxnQkFBSyxVQUFVLEVBQUUsT0FBTyxLQUFLLEdBQ3RCLEtBQUs7QUFBQSxFQUNoQjtBQUFBLEVBQ0EsT0FBTyxPQUFPO0FBRVYsUUFEbUIsS0FBSyxTQUFTLEtBQUssTUFDbkIsY0FBYyxRQUFRO0FBQ3JDLFVBQU1ELE9BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0JBLE1BQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVQSxLQUFJO0FBQUEsTUFDbEIsQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUNBLFFBQU0sRUFBRSxRQUFRLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLLEdBQ2hELEVBQUUsT0FBTyxNQUFNLFVBQVUsSUFBSSxLQUFLLFdBQVcsR0FDN0MsWUFBWSxDQUFDO0FBQ25CLFFBQUksRUFBRSxLQUFLLEtBQUssb0JBQW9CLFlBQVksS0FBSyxLQUFLLGdCQUFnQjtBQUN0RSxlQUFXLE9BQU8sSUFBSTtBQUNsQixRQUFLLFVBQVUsU0FBUyxHQUFHLEtBQ3ZCLFVBQVUsS0FBSyxHQUFHO0FBSTlCLFFBQU0sUUFBUSxDQUFDO0FBQ2YsYUFBVyxPQUFPLFdBQVc7QUFDekIsVUFBTSxlQUFlLE1BQU0sR0FBRyxHQUN4QixRQUFRLElBQUksS0FBSyxHQUFHO0FBQzFCLFlBQU0sS0FBSztBQUFBLFFBQ1AsS0FBSyxFQUFFLFFBQVEsU0FBUyxPQUFPLElBQUk7QUFBQSxRQUNuQyxPQUFPLGFBQWEsT0FBTyxJQUFJLG1CQUFtQixLQUFLLE9BQU8sSUFBSSxNQUFNLEdBQUcsQ0FBQztBQUFBLFFBQzVFLFdBQVcsT0FBTyxJQUFJO0FBQUEsTUFDMUIsQ0FBQztBQUFBLElBQ0w7QUFDQSxRQUFJLEtBQUssS0FBSyxvQkFBb0IsVUFBVTtBQUN4QyxVQUFNLGNBQWMsS0FBSyxLQUFLO0FBQzlCLFVBQUksZ0JBQWdCO0FBQ2hCLGlCQUFXLE9BQU87QUFDZCxnQkFBTSxLQUFLO0FBQUEsWUFDUCxLQUFLLEVBQUUsUUFBUSxTQUFTLE9BQU8sSUFBSTtBQUFBLFlBQ25DLE9BQU8sRUFBRSxRQUFRLFNBQVMsT0FBTyxJQUFJLEtBQUssR0FBRyxFQUFFO0FBQUEsVUFDbkQsQ0FBQztBQUFBLGVBR0EsZ0JBQWdCO0FBQ3JCLFFBQUksVUFBVSxTQUFTLE1BQ25CLGtCQUFrQixLQUFLO0FBQUEsVUFDbkIsTUFBTSxhQUFhO0FBQUEsVUFDbkIsTUFBTTtBQUFBLFFBQ1YsQ0FBQyxHQUNELE9BQU8sTUFBTTtBQUFBLGVBR1osZ0JBQWdCO0FBR3JCLGNBQU0sSUFBSSxNQUFNLHNEQUFzRDtBQUFBLElBRTlFLE9BQ0s7QUFFRCxVQUFNLFdBQVcsS0FBSyxLQUFLO0FBQzNCLGVBQVcsT0FBTyxXQUFXO0FBQ3pCLFlBQU0sUUFBUSxJQUFJLEtBQUssR0FBRztBQUMxQixjQUFNLEtBQUs7QUFBQSxVQUNQLEtBQUssRUFBRSxRQUFRLFNBQVMsT0FBTyxJQUFJO0FBQUEsVUFDbkMsT0FBTyxTQUFTO0FBQUEsWUFBTyxJQUFJLG1CQUFtQixLQUFLLE9BQU8sSUFBSSxNQUFNLEdBQUc7QUFBQTtBQUFBLFVBQ3ZFO0FBQUEsVUFDQSxXQUFXLE9BQU8sSUFBSTtBQUFBLFFBQzFCLENBQUM7QUFBQSxNQUNMO0FBQUEsSUFDSjtBQUNBLFdBQUksSUFBSSxPQUFPLFFBQ0osUUFBUSxRQUFRLEVBQ2xCLEtBQUssWUFBWTtBQUNsQixVQUFNLFlBQVksQ0FBQztBQUNuQixlQUFXLFFBQVEsT0FBTztBQUN0QixZQUFNLE1BQU0sTUFBTSxLQUFLLEtBQ2pCLFFBQVEsTUFBTSxLQUFLO0FBQ3pCLGtCQUFVLEtBQUs7QUFBQSxVQUNYO0FBQUEsVUFDQTtBQUFBLFVBQ0EsV0FBVyxLQUFLO0FBQUEsUUFDcEIsQ0FBQztBQUFBLE1BQ0w7QUFDQSxhQUFPO0FBQUEsSUFDWCxDQUFDLEVBQ0ksS0FBSyxDQUFDLGNBQ0EsWUFBWSxnQkFBZ0IsUUFBUSxTQUFTLENBQ3ZELElBR00sWUFBWSxnQkFBZ0IsUUFBUSxLQUFLO0FBQUEsRUFFeEQ7QUFBQSxFQUNBLElBQUksUUFBUTtBQUNSLFdBQU8sS0FBSyxLQUFLLE1BQU07QUFBQSxFQUMzQjtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1oscUJBQVUsVUFDSCxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLGFBQWE7QUFBQSxNQUNiLEdBQUksWUFBWSxTQUNWO0FBQUEsUUFDRSxVQUFVLENBQUNFLFFBQU8sUUFBUTtBQUN0QixjQUFNLGVBQWUsS0FBSyxLQUFLLFdBQVdBLFFBQU8sR0FBRyxFQUFFLFdBQVcsSUFBSTtBQUNyRSxpQkFBSUEsT0FBTSxTQUFTLHNCQUNSO0FBQUEsWUFDSCxTQUFTLFVBQVUsU0FBUyxPQUFPLEVBQUUsV0FBVztBQUFBLFVBQ3BELElBQ0c7QUFBQSxZQUNILFNBQVM7QUFBQSxVQUNiO0FBQUEsUUFDSjtBQUFBLE1BQ0osSUFDRSxDQUFDO0FBQUEsSUFDWCxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsUUFBUTtBQUNKLFdBQU8sSUFBSSxXQUFVO0FBQUEsTUFDakIsR0FBRyxLQUFLO0FBQUEsTUFDUixhQUFhO0FBQUEsSUFDakIsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLGNBQWM7QUFDVixXQUFPLElBQUksV0FBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsYUFBYTtBQUFBLElBQ2pCLENBQUM7QUFBQSxFQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBa0JBLE9BQU8sY0FBYztBQUNqQixXQUFPLElBQUksV0FBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsT0FBTyxPQUFPO0FBQUEsUUFDVixHQUFHLEtBQUssS0FBSyxNQUFNO0FBQUEsUUFDbkIsR0FBRztBQUFBLE1BQ1A7QUFBQSxJQUNKLENBQUM7QUFBQSxFQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBTUEsTUFBTSxTQUFTO0FBVVgsV0FUZSxJQUFJLFdBQVU7QUFBQSxNQUN6QixhQUFhLFFBQVEsS0FBSztBQUFBLE1BQzFCLFVBQVUsUUFBUSxLQUFLO0FBQUEsTUFDdkIsT0FBTyxPQUFPO0FBQUEsUUFDVixHQUFHLEtBQUssS0FBSyxNQUFNO0FBQUEsUUFDbkIsR0FBRyxRQUFRLEtBQUssTUFBTTtBQUFBLE1BQzFCO0FBQUEsTUFDQSxVQUFVLHNCQUFzQjtBQUFBLElBQ3BDLENBQUM7QUFBQSxFQUVMO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBb0NBLE9BQU8sS0FBSyxRQUFRO0FBQ2hCLFdBQU8sS0FBSyxRQUFRLEVBQUUsQ0FBQyxHQUFHLEdBQUcsT0FBTyxDQUFDO0FBQUEsRUFDekM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQXNCQSxTQUFTLE9BQU87QUFDWixXQUFPLElBQUksV0FBVTtBQUFBLE1BQ2pCLEdBQUcsS0FBSztBQUFBLE1BQ1IsVUFBVTtBQUFBLElBQ2QsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLEtBQUssTUFBTTtBQUNQLFFBQU0sUUFBUSxDQUFDO0FBQ2YsYUFBVyxPQUFPLEtBQUssV0FBVyxJQUFJO0FBQ2xDLE1BQUksS0FBSyxHQUFHLEtBQUssS0FBSyxNQUFNLEdBQUcsTUFDM0IsTUFBTSxHQUFHLElBQUksS0FBSyxNQUFNLEdBQUc7QUFHbkMsV0FBTyxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLE9BQU8sTUFBTTtBQUFBLElBQ2pCLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxLQUFLLE1BQU07QUFDUCxRQUFNLFFBQVEsQ0FBQztBQUNmLGFBQVcsT0FBTyxLQUFLLFdBQVcsS0FBSyxLQUFLO0FBQ3hDLE1BQUssS0FBSyxHQUFHLE1BQ1QsTUFBTSxHQUFHLElBQUksS0FBSyxNQUFNLEdBQUc7QUFHbkMsV0FBTyxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLE9BQU8sTUFBTTtBQUFBLElBQ2pCLENBQUM7QUFBQSxFQUNMO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFJQSxjQUFjO0FBQ1YsV0FBTyxlQUFlLElBQUk7QUFBQSxFQUM5QjtBQUFBLEVBQ0EsUUFBUSxNQUFNO0FBQ1YsUUFBTSxXQUFXLENBQUM7QUFDbEIsYUFBVyxPQUFPLEtBQUssV0FBVyxLQUFLLEtBQUssR0FBRztBQUMzQyxVQUFNLGNBQWMsS0FBSyxNQUFNLEdBQUc7QUFDbEMsTUFBSSxRQUFRLENBQUMsS0FBSyxHQUFHLElBQ2pCLFNBQVMsR0FBRyxJQUFJLGNBR2hCLFNBQVMsR0FBRyxJQUFJLFlBQVksU0FBUztBQUFBLElBRTdDO0FBQ0EsV0FBTyxJQUFJLFdBQVU7QUFBQSxNQUNqQixHQUFHLEtBQUs7QUFBQSxNQUNSLE9BQU8sTUFBTTtBQUFBLElBQ2pCLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxTQUFTLE1BQU07QUFDWCxRQUFNLFdBQVcsQ0FBQztBQUNsQixhQUFXLE9BQU8sS0FBSyxXQUFXLEtBQUssS0FBSztBQUN4QyxVQUFJLFFBQVEsQ0FBQyxLQUFLLEdBQUc7QUFDakIsaUJBQVMsR0FBRyxJQUFJLEtBQUssTUFBTSxHQUFHO0FBQUEsV0FFN0I7QUFFRCxZQUFJLFdBRGdCLEtBQUssTUFBTSxHQUFHO0FBRWxDLGVBQU8sb0JBQW9CO0FBQ3ZCLHFCQUFXLFNBQVMsS0FBSztBQUU3QixpQkFBUyxHQUFHLElBQUk7QUFBQSxNQUNwQjtBQUVKLFdBQU8sSUFBSSxXQUFVO0FBQUEsTUFDakIsR0FBRyxLQUFLO0FBQUEsTUFDUixPQUFPLE1BQU07QUFBQSxJQUNqQixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsUUFBUTtBQUNKLFdBQU8sY0FBYyxLQUFLLFdBQVcsS0FBSyxLQUFLLENBQUM7QUFBQSxFQUNwRDtBQUNKO0FBQ0EsVUFBVSxTQUFTLENBQUMsT0FBTyxXQUNoQixJQUFJLFVBQVU7QUFBQSxFQUNqQixPQUFPLE1BQU07QUFBQSxFQUNiLGFBQWE7QUFBQSxFQUNiLFVBQVUsU0FBUyxPQUFPO0FBQUEsRUFDMUIsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFTCxVQUFVLGVBQWUsQ0FBQyxPQUFPLFdBQ3RCLElBQUksVUFBVTtBQUFBLEVBQ2pCLE9BQU8sTUFBTTtBQUFBLEVBQ2IsYUFBYTtBQUFBLEVBQ2IsVUFBVSxTQUFTLE9BQU87QUFBQSxFQUMxQixVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVMLFVBQVUsYUFBYSxDQUFDLE9BQU8sV0FDcEIsSUFBSSxVQUFVO0FBQUEsRUFDakI7QUFBQSxFQUNBLGFBQWE7QUFBQSxFQUNiLFVBQVUsU0FBUyxPQUFPO0FBQUEsRUFDMUIsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFdBQU4sY0FBdUIsUUFBUTtBQUFBLEVBQ2xDLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxJQUFJLElBQUksS0FBSyxvQkFBb0IsS0FBSyxHQUN4QyxVQUFVLEtBQUssS0FBSztBQUMxQixhQUFTLGNBQWMsU0FBUztBQUU1QixlQUFXLFVBQVU7QUFDakIsWUFBSSxPQUFPLE9BQU8sV0FBVztBQUN6QixpQkFBTyxPQUFPO0FBR3RCLGVBQVcsVUFBVTtBQUNqQixZQUFJLE9BQU8sT0FBTyxXQUFXO0FBRXpCLHFCQUFJLE9BQU8sT0FBTyxLQUFLLEdBQUcsT0FBTyxJQUFJLE9BQU8sTUFBTSxHQUMzQyxPQUFPO0FBSXRCLFVBQU0sY0FBYyxRQUFRLElBQUksQ0FBQyxXQUFXLElBQUksU0FBUyxPQUFPLElBQUksT0FBTyxNQUFNLENBQUM7QUFDbEYsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQjtBQUFBLE1BQ0osQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUNBLFFBQUksSUFBSSxPQUFPO0FBQ1gsYUFBTyxRQUFRLElBQUksUUFBUSxJQUFJLE9BQU8sV0FBVztBQUM3QyxZQUFNLFdBQVc7QUFBQSxVQUNiLEdBQUc7QUFBQSxVQUNILFFBQVE7QUFBQSxZQUNKLEdBQUcsSUFBSTtBQUFBLFlBQ1AsUUFBUSxDQUFDO0FBQUEsVUFDYjtBQUFBLFVBQ0EsUUFBUTtBQUFBLFFBQ1o7QUFDQSxlQUFPO0FBQUEsVUFDSCxRQUFRLE1BQU0sT0FBTyxZQUFZO0FBQUEsWUFDN0IsTUFBTSxJQUFJO0FBQUEsWUFDVixNQUFNLElBQUk7QUFBQSxZQUNWLFFBQVE7QUFBQSxVQUNaLENBQUM7QUFBQSxVQUNELEtBQUs7QUFBQSxRQUNUO0FBQUEsTUFDSixDQUFDLENBQUMsRUFBRSxLQUFLLGFBQWE7QUFFckI7QUFDRCxVQUFJLE9BQ0UsU0FBUyxDQUFDO0FBQ2hCLGVBQVcsVUFBVSxTQUFTO0FBQzFCLFlBQU0sV0FBVztBQUFBLFVBQ2IsR0FBRztBQUFBLFVBQ0gsUUFBUTtBQUFBLFlBQ0osR0FBRyxJQUFJO0FBQUEsWUFDUCxRQUFRLENBQUM7QUFBQSxVQUNiO0FBQUEsVUFDQSxRQUFRO0FBQUEsUUFDWixHQUNNLFNBQVMsT0FBTyxXQUFXO0FBQUEsVUFDN0IsTUFBTSxJQUFJO0FBQUEsVUFDVixNQUFNLElBQUk7QUFBQSxVQUNWLFFBQVE7QUFBQSxRQUNaLENBQUM7QUFDRCxZQUFJLE9BQU8sV0FBVztBQUNsQixpQkFBTztBQUVOLFFBQUksT0FBTyxXQUFXLFdBQVcsQ0FBQyxVQUNuQyxRQUFRLEVBQUUsUUFBUSxLQUFLLFNBQVMsSUFFaEMsU0FBUyxPQUFPLE9BQU8sVUFDdkIsT0FBTyxLQUFLLFNBQVMsT0FBTyxNQUFNO0FBQUEsTUFFMUM7QUFDQSxVQUFJO0FBQ0EsbUJBQUksT0FBTyxPQUFPLEtBQUssR0FBRyxNQUFNLElBQUksT0FBTyxNQUFNLEdBQzFDLE1BQU07QUFFakIsVUFBTSxjQUFjLE9BQU8sSUFBSSxDQUFDQyxZQUFXLElBQUksU0FBU0EsT0FBTSxDQUFDO0FBQy9ELCtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkI7QUFBQSxNQUNKLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFBQSxFQUNKO0FBQUEsRUFDQSxJQUFJLFVBQVU7QUFDVixXQUFPLEtBQUssS0FBSztBQUFBLEVBQ3JCO0FBQ0o7QUFDQSxTQUFTLFNBQVMsQ0FBQyxPQUFPLFdBQ2YsSUFBSSxTQUFTO0FBQUEsRUFDaEIsU0FBUztBQUFBLEVBQ1QsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFTTCxJQUFNLG1CQUFtQixDQUFDLFNBQ2xCLGdCQUFnQixVQUNULGlCQUFpQixLQUFLLE1BQU0sSUFFOUIsZ0JBQWdCLGFBQ2QsaUJBQWlCLEtBQUssVUFBVSxDQUFDLElBRW5DLGdCQUFnQixhQUNkLENBQUMsS0FBSyxLQUFLLElBRWIsZ0JBQWdCLFVBQ2QsS0FBSyxVQUVQLGdCQUFnQixnQkFFZCxLQUFLLGFBQWEsS0FBSyxJQUFJLElBRTdCLGdCQUFnQixhQUNkLGlCQUFpQixLQUFLLEtBQUssU0FBUyxJQUV0QyxnQkFBZ0IsZUFDZCxDQUFDLE1BQVMsSUFFWixnQkFBZ0IsVUFDZCxDQUFDLElBQUksSUFFUCxnQkFBZ0IsY0FDZCxDQUFDLFFBQVcsR0FBRyxpQkFBaUIsS0FBSyxPQUFPLENBQUMsQ0FBQyxJQUVoRCxnQkFBZ0IsY0FDZCxDQUFDLE1BQU0sR0FBRyxpQkFBaUIsS0FBSyxPQUFPLENBQUMsQ0FBQyxJQUUzQyxnQkFBZ0IsY0FHaEIsZ0JBQWdCLGNBRmQsaUJBQWlCLEtBQUssT0FBTyxDQUFDLElBS2hDLGdCQUFnQixXQUNkLGlCQUFpQixLQUFLLEtBQUssU0FBUyxJQUdwQyxDQUFDLEdBR0gsd0JBQU4sTUFBTSwrQkFBOEIsUUFBUTtBQUFBLEVBQy9DLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxJQUFJLElBQUksS0FBSyxvQkFBb0IsS0FBSztBQUM5QyxRQUFJLElBQUksZUFBZSxjQUFjO0FBQ2pDLCtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsVUFBVSxjQUFjO0FBQUEsUUFDeEIsVUFBVSxJQUFJO0FBQUEsTUFDbEIsQ0FBQyxHQUNNO0FBRVgsUUFBTSxnQkFBZ0IsS0FBSyxlQUNyQixxQkFBcUIsSUFBSSxLQUFLLGFBQWEsR0FDM0MsU0FBUyxLQUFLLFdBQVcsSUFBSSxrQkFBa0I7QUFDckQsV0FBSyxTQVFELElBQUksT0FBTyxRQUNKLE9BQU8sWUFBWTtBQUFBLE1BQ3RCLE1BQU0sSUFBSTtBQUFBLE1BQ1YsTUFBTSxJQUFJO0FBQUEsTUFDVixRQUFRO0FBQUEsSUFDWixDQUFDLElBR00sT0FBTyxXQUFXO0FBQUEsTUFDckIsTUFBTSxJQUFJO0FBQUEsTUFDVixNQUFNLElBQUk7QUFBQSxNQUNWLFFBQVE7QUFBQSxJQUNaLENBQUMsS0FuQkQsa0JBQWtCLEtBQUs7QUFBQSxNQUNuQixNQUFNLGFBQWE7QUFBQSxNQUNuQixTQUFTLE1BQU0sS0FBSyxLQUFLLFdBQVcsS0FBSyxDQUFDO0FBQUEsTUFDMUMsTUFBTSxDQUFDLGFBQWE7QUFBQSxJQUN4QixDQUFDLEdBQ007QUFBQSxFQWdCZjtBQUFBLEVBQ0EsSUFBSSxnQkFBZ0I7QUFDaEIsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsSUFBSSxhQUFhO0FBQ2IsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQVNBLE9BQU8sT0FBTyxlQUFlLFNBQVMsUUFBUTtBQUUxQyxRQUFNLGFBQWEsb0JBQUksSUFBSTtBQUUzQixhQUFXLFFBQVEsU0FBUztBQUN4QixVQUFNLHNCQUFzQixpQkFBaUIsS0FBSyxNQUFNLGFBQWEsQ0FBQztBQUN0RSxVQUFJLENBQUMsb0JBQW9CO0FBQ3JCLGNBQU0sSUFBSSxNQUFNLG1DQUFtQyxhQUFhLG1EQUFtRDtBQUV2SCxlQUFXLFNBQVMscUJBQXFCO0FBQ3JDLFlBQUksV0FBVyxJQUFJLEtBQUs7QUFDcEIsZ0JBQU0sSUFBSSxNQUFNLDBCQUEwQixPQUFPLGFBQWEsQ0FBQyx3QkFBd0IsT0FBTyxLQUFLLENBQUMsRUFBRTtBQUUxRyxtQkFBVyxJQUFJLE9BQU8sSUFBSTtBQUFBLE1BQzlCO0FBQUEsSUFDSjtBQUNBLFdBQU8sSUFBSSx1QkFBc0I7QUFBQSxNQUM3QixVQUFVLHNCQUFzQjtBQUFBLE1BQ2hDO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBLEdBQUcsb0JBQW9CLE1BQU07QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUNKO0FBQ0EsU0FBUyxZQUFZLEdBQUcsR0FBRztBQUN2QixNQUFNLFFBQVEsY0FBYyxDQUFDLEdBQ3ZCLFFBQVEsY0FBYyxDQUFDO0FBQzdCLE1BQUksTUFBTTtBQUNOLFdBQU8sRUFBRSxPQUFPLElBQU0sTUFBTSxFQUFFO0FBRTdCLE1BQUksVUFBVSxjQUFjLFVBQVUsVUFBVSxjQUFjLFFBQVE7QUFDdkUsUUFBTSxRQUFRLEtBQUssV0FBVyxDQUFDLEdBQ3pCLGFBQWEsS0FBSyxXQUFXLENBQUMsRUFBRSxPQUFPLENBQUMsUUFBUSxNQUFNLFFBQVEsR0FBRyxNQUFNLEVBQUUsR0FDekUsU0FBUyxFQUFFLEdBQUcsR0FBRyxHQUFHLEVBQUU7QUFDNUIsYUFBVyxPQUFPLFlBQVk7QUFDMUIsVUFBTSxjQUFjLFlBQVksRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUM7QUFDOUMsVUFBSSxDQUFDLFlBQVk7QUFDYixlQUFPLEVBQUUsT0FBTyxHQUFNO0FBRTFCLGFBQU8sR0FBRyxJQUFJLFlBQVk7QUFBQSxJQUM5QjtBQUNBLFdBQU8sRUFBRSxPQUFPLElBQU0sTUFBTSxPQUFPO0FBQUEsRUFDdkMsV0FDUyxVQUFVLGNBQWMsU0FBUyxVQUFVLGNBQWMsT0FBTztBQUNyRSxRQUFJLEVBQUUsV0FBVyxFQUFFO0FBQ2YsYUFBTyxFQUFFLE9BQU8sR0FBTTtBQUUxQixRQUFNLFdBQVcsQ0FBQztBQUNsQixhQUFTLFFBQVEsR0FBRyxRQUFRLEVBQUUsUUFBUSxTQUFTO0FBQzNDLFVBQU0sUUFBUSxFQUFFLEtBQUssR0FDZixRQUFRLEVBQUUsS0FBSyxHQUNmLGNBQWMsWUFBWSxPQUFPLEtBQUs7QUFDNUMsVUFBSSxDQUFDLFlBQVk7QUFDYixlQUFPLEVBQUUsT0FBTyxHQUFNO0FBRTFCLGVBQVMsS0FBSyxZQUFZLElBQUk7QUFBQSxJQUNsQztBQUNBLFdBQU8sRUFBRSxPQUFPLElBQU0sTUFBTSxTQUFTO0FBQUEsRUFDekMsTUFDSyxRQUFJLFVBQVUsY0FBYyxRQUFRLFVBQVUsY0FBYyxRQUFRLENBQUMsS0FBTSxDQUFDLElBQ3RFLEVBQUUsT0FBTyxJQUFNLE1BQU0sRUFBRSxJQUd2QixFQUFFLE9BQU8sR0FBTTtBQUU5QjtBQUNPLElBQU0sa0JBQU4sY0FBOEIsUUFBUTtBQUFBLEVBQ3pDLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxRQUFRLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLLEdBQ2hELGVBQWUsQ0FBQyxZQUFZLGdCQUFnQjtBQUM5QyxVQUFJLFVBQVUsVUFBVSxLQUFLLFVBQVUsV0FBVztBQUM5QyxlQUFPO0FBRVgsVUFBTSxTQUFTLFlBQVksV0FBVyxPQUFPLFlBQVksS0FBSztBQUM5RCxhQUFLLE9BQU8sVUFNUixRQUFRLFVBQVUsS0FBSyxRQUFRLFdBQVcsTUFDMUMsT0FBTyxNQUFNLEdBRVYsRUFBRSxRQUFRLE9BQU8sT0FBTyxPQUFPLE9BQU8sS0FBSyxNQVI5QyxrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLE1BQ3ZCLENBQUMsR0FDTTtBQUFBLElBTWY7QUFDQSxXQUFJLElBQUksT0FBTyxRQUNKLFFBQVEsSUFBSTtBQUFBLE1BQ2YsS0FBSyxLQUFLLEtBQUssWUFBWTtBQUFBLFFBQ3ZCLE1BQU0sSUFBSTtBQUFBLFFBQ1YsTUFBTSxJQUFJO0FBQUEsUUFDVixRQUFRO0FBQUEsTUFDWixDQUFDO0FBQUEsTUFDRCxLQUFLLEtBQUssTUFBTSxZQUFZO0FBQUEsUUFDeEIsTUFBTSxJQUFJO0FBQUEsUUFDVixNQUFNLElBQUk7QUFBQSxRQUNWLFFBQVE7QUFBQSxNQUNaLENBQUM7QUFBQSxJQUNMLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQyxNQUFNLEtBQUssTUFBTSxhQUFhLE1BQU0sS0FBSyxDQUFDLElBRzdDLGFBQWEsS0FBSyxLQUFLLEtBQUssV0FBVztBQUFBLE1BQzFDLE1BQU0sSUFBSTtBQUFBLE1BQ1YsTUFBTSxJQUFJO0FBQUEsTUFDVixRQUFRO0FBQUEsSUFDWixDQUFDLEdBQUcsS0FBSyxLQUFLLE1BQU0sV0FBVztBQUFBLE1BQzNCLE1BQU0sSUFBSTtBQUFBLE1BQ1YsTUFBTSxJQUFJO0FBQUEsTUFDVixRQUFRO0FBQUEsSUFDWixDQUFDLENBQUM7QUFBQSxFQUVWO0FBQ0o7QUFDQSxnQkFBZ0IsU0FBUyxDQUFDLE1BQU0sT0FBTyxXQUM1QixJQUFJLGdCQUFnQjtBQUFBLEVBQ3ZCO0FBQUEsRUFDQTtBQUFBLEVBQ0EsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFHRSxJQUFNLFdBQU4sTUFBTSxrQkFBaUIsUUFBUTtBQUFBLEVBQ2xDLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxRQUFRLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBQ3RELFFBQUksSUFBSSxlQUFlLGNBQWM7QUFDakMsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVLElBQUk7QUFBQSxNQUNsQixDQUFDLEdBQ007QUFFWCxRQUFJLElBQUksS0FBSyxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQ2xDLCtCQUFrQixLQUFLO0FBQUEsUUFDbkIsTUFBTSxhQUFhO0FBQUEsUUFDbkIsU0FBUyxLQUFLLEtBQUssTUFBTTtBQUFBLFFBQ3pCLFdBQVc7QUFBQSxRQUNYLE9BQU87QUFBQSxRQUNQLE1BQU07QUFBQSxNQUNWLENBQUMsR0FDTTtBQUdYLElBQUksQ0FEUyxLQUFLLEtBQUssUUFDVixJQUFJLEtBQUssU0FBUyxLQUFLLEtBQUssTUFBTSxXQUMzQyxrQkFBa0IsS0FBSztBQUFBLE1BQ25CLE1BQU0sYUFBYTtBQUFBLE1BQ25CLFNBQVMsS0FBSyxLQUFLLE1BQU07QUFBQSxNQUN6QixXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxNQUFNO0FBQUEsSUFDVixDQUFDLEdBQ0QsT0FBTyxNQUFNO0FBRWpCLFFBQU0sUUFBUSxDQUFDLEdBQUcsSUFBSSxJQUFJLEVBQ3JCLElBQUksQ0FBQyxNQUFNLGNBQWM7QUFDMUIsVUFBTSxTQUFTLEtBQUssS0FBSyxNQUFNLFNBQVMsS0FBSyxLQUFLLEtBQUs7QUFDdkQsYUFBSyxTQUVFLE9BQU8sT0FBTyxJQUFJLG1CQUFtQixLQUFLLE1BQU0sSUFBSSxNQUFNLFNBQVMsQ0FBQyxJQURoRTtBQUFBLElBRWYsQ0FBQyxFQUNJLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQ3RCLFdBQUksSUFBSSxPQUFPLFFBQ0osUUFBUSxJQUFJLEtBQUssRUFBRSxLQUFLLENBQUMsWUFDckIsWUFBWSxXQUFXLFFBQVEsT0FBTyxDQUNoRCxJQUdNLFlBQVksV0FBVyxRQUFRLEtBQUs7QUFBQSxFQUVuRDtBQUFBLEVBQ0EsSUFBSSxRQUFRO0FBQ1IsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsS0FBSyxNQUFNO0FBQ1AsV0FBTyxJQUFJLFVBQVM7QUFBQSxNQUNoQixHQUFHLEtBQUs7QUFBQSxNQUNSO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUNKO0FBQ0EsU0FBUyxTQUFTLENBQUMsU0FBUyxXQUFXO0FBQ25DLE1BQUksQ0FBQyxNQUFNLFFBQVEsT0FBTztBQUN0QixVQUFNLElBQUksTUFBTSx1REFBdUQ7QUFFM0UsU0FBTyxJQUFJLFNBQVM7QUFBQSxJQUNoQixPQUFPO0FBQUEsSUFDUCxVQUFVLHNCQUFzQjtBQUFBLElBQ2hDLE1BQU07QUFBQSxJQUNOLEdBQUcsb0JBQW9CLE1BQU07QUFBQSxFQUNqQyxDQUFDO0FBQ0w7QUFDTyxJQUFNLFlBQU4sTUFBTSxtQkFBa0IsUUFBUTtBQUFBLEVBQ25DLElBQUksWUFBWTtBQUNaLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLElBQUksY0FBYztBQUNkLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxRQUFRLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBQ3RELFFBQUksSUFBSSxlQUFlLGNBQWM7QUFDakMsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVLElBQUk7QUFBQSxNQUNsQixDQUFDLEdBQ007QUFFWCxRQUFNLFFBQVEsQ0FBQyxHQUNULFVBQVUsS0FBSyxLQUFLLFNBQ3BCLFlBQVksS0FBSyxLQUFLO0FBQzVCLGFBQVcsT0FBTyxJQUFJO0FBQ2xCLFlBQU0sS0FBSztBQUFBLFFBQ1AsS0FBSyxRQUFRLE9BQU8sSUFBSSxtQkFBbUIsS0FBSyxLQUFLLElBQUksTUFBTSxHQUFHLENBQUM7QUFBQSxRQUNuRSxPQUFPLFVBQVUsT0FBTyxJQUFJLG1CQUFtQixLQUFLLElBQUksS0FBSyxHQUFHLEdBQUcsSUFBSSxNQUFNLEdBQUcsQ0FBQztBQUFBLFFBQ2pGLFdBQVcsT0FBTyxJQUFJO0FBQUEsTUFDMUIsQ0FBQztBQUVMLFdBQUksSUFBSSxPQUFPLFFBQ0osWUFBWSxpQkFBaUIsUUFBUSxLQUFLLElBRzFDLFlBQVksZ0JBQWdCLFFBQVEsS0FBSztBQUFBLEVBRXhEO0FBQUEsRUFDQSxJQUFJLFVBQVU7QUFDVixXQUFPLEtBQUssS0FBSztBQUFBLEVBQ3JCO0FBQUEsRUFDQSxPQUFPLE9BQU8sT0FBTyxRQUFRLE9BQU87QUFDaEMsV0FBSSxrQkFBa0IsVUFDWCxJQUFJLFdBQVU7QUFBQSxNQUNqQixTQUFTO0FBQUEsTUFDVCxXQUFXO0FBQUEsTUFDWCxVQUFVLHNCQUFzQjtBQUFBLE1BQ2hDLEdBQUcsb0JBQW9CLEtBQUs7QUFBQSxJQUNoQyxDQUFDLElBRUUsSUFBSSxXQUFVO0FBQUEsTUFDakIsU0FBUyxVQUFVLE9BQU87QUFBQSxNQUMxQixXQUFXO0FBQUEsTUFDWCxVQUFVLHNCQUFzQjtBQUFBLE1BQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFBQSxJQUNqQyxDQUFDO0FBQUEsRUFDTDtBQUNKLEdBQ2EsU0FBTixjQUFxQixRQUFRO0FBQUEsRUFDaEMsSUFBSSxZQUFZO0FBQ1osV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsSUFBSSxjQUFjO0FBQ2QsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsT0FBTyxPQUFPO0FBQ1YsUUFBTSxFQUFFLFFBQVEsSUFBSSxJQUFJLEtBQUssb0JBQW9CLEtBQUs7QUFDdEQsUUFBSSxJQUFJLGVBQWUsY0FBYztBQUNqQywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUVYLFFBQU0sVUFBVSxLQUFLLEtBQUssU0FDcEIsWUFBWSxLQUFLLEtBQUssV0FDdEIsUUFBUSxDQUFDLEdBQUcsSUFBSSxLQUFLLFFBQVEsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDLEtBQUssS0FBSyxHQUFHLFdBQzlDO0FBQUEsTUFDSCxLQUFLLFFBQVEsT0FBTyxJQUFJLG1CQUFtQixLQUFLLEtBQUssSUFBSSxNQUFNLENBQUMsT0FBTyxLQUFLLENBQUMsQ0FBQztBQUFBLE1BQzlFLE9BQU8sVUFBVSxPQUFPLElBQUksbUJBQW1CLEtBQUssT0FBTyxJQUFJLE1BQU0sQ0FBQyxPQUFPLE9BQU8sQ0FBQyxDQUFDO0FBQUEsSUFDMUYsRUFDSDtBQUNELFFBQUksSUFBSSxPQUFPLE9BQU87QUFDbEIsVUFBTSxXQUFXLG9CQUFJLElBQUk7QUFDekIsYUFBTyxRQUFRLFFBQVEsRUFBRSxLQUFLLFlBQVk7QUFDdEMsaUJBQVcsUUFBUSxPQUFPO0FBQ3RCLGNBQU0sTUFBTSxNQUFNLEtBQUssS0FDakIsUUFBUSxNQUFNLEtBQUs7QUFDekIsY0FBSSxJQUFJLFdBQVcsYUFBYSxNQUFNLFdBQVc7QUFDN0MsbUJBQU87QUFFWCxXQUFJLElBQUksV0FBVyxXQUFXLE1BQU0sV0FBVyxZQUMzQyxPQUFPLE1BQU0sR0FFakIsU0FBUyxJQUFJLElBQUksT0FBTyxNQUFNLEtBQUs7QUFBQSxRQUN2QztBQUNBLGVBQU8sRUFBRSxRQUFRLE9BQU8sT0FBTyxPQUFPLFNBQVM7QUFBQSxNQUNuRCxDQUFDO0FBQUEsSUFDTCxPQUNLO0FBQ0QsVUFBTSxXQUFXLG9CQUFJLElBQUk7QUFDekIsZUFBVyxRQUFRLE9BQU87QUFDdEIsWUFBTSxNQUFNLEtBQUssS0FDWCxRQUFRLEtBQUs7QUFDbkIsWUFBSSxJQUFJLFdBQVcsYUFBYSxNQUFNLFdBQVc7QUFDN0MsaUJBQU87QUFFWCxTQUFJLElBQUksV0FBVyxXQUFXLE1BQU0sV0FBVyxZQUMzQyxPQUFPLE1BQU0sR0FFakIsU0FBUyxJQUFJLElBQUksT0FBTyxNQUFNLEtBQUs7QUFBQSxNQUN2QztBQUNBLGFBQU8sRUFBRSxRQUFRLE9BQU8sT0FBTyxPQUFPLFNBQVM7QUFBQSxJQUNuRDtBQUFBLEVBQ0o7QUFDSjtBQUNBLE9BQU8sU0FBUyxDQUFDLFNBQVMsV0FBVyxXQUMxQixJQUFJLE9BQU87QUFBQSxFQUNkO0FBQUEsRUFDQTtBQUFBLEVBQ0EsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFNBQU4sTUFBTSxnQkFBZSxRQUFRO0FBQUEsRUFDaEMsT0FBTyxPQUFPO0FBQ1YsUUFBTSxFQUFFLFFBQVEsSUFBSSxJQUFJLEtBQUssb0JBQW9CLEtBQUs7QUFDdEQsUUFBSSxJQUFJLGVBQWUsY0FBYztBQUNqQywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUVYLFFBQU0sTUFBTSxLQUFLO0FBQ2pCLElBQUksSUFBSSxZQUFZLFFBQ1osSUFBSSxLQUFLLE9BQU8sSUFBSSxRQUFRLFVBQzVCLGtCQUFrQixLQUFLO0FBQUEsTUFDbkIsTUFBTSxhQUFhO0FBQUEsTUFDbkIsU0FBUyxJQUFJLFFBQVE7QUFBQSxNQUNyQixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxTQUFTLElBQUksUUFBUTtBQUFBLElBQ3pCLENBQUMsR0FDRCxPQUFPLE1BQU0sSUFHakIsSUFBSSxZQUFZLFFBQ1osSUFBSSxLQUFLLE9BQU8sSUFBSSxRQUFRLFVBQzVCLGtCQUFrQixLQUFLO0FBQUEsTUFDbkIsTUFBTSxhQUFhO0FBQUEsTUFDbkIsU0FBUyxJQUFJLFFBQVE7QUFBQSxNQUNyQixNQUFNO0FBQUEsTUFDTixXQUFXO0FBQUEsTUFDWCxPQUFPO0FBQUEsTUFDUCxTQUFTLElBQUksUUFBUTtBQUFBLElBQ3pCLENBQUMsR0FDRCxPQUFPLE1BQU07QUFHckIsUUFBTSxZQUFZLEtBQUssS0FBSztBQUM1QixhQUFTLFlBQVlDLFdBQVU7QUFDM0IsVUFBTSxZQUFZLG9CQUFJLElBQUk7QUFDMUIsZUFBVyxXQUFXQSxXQUFVO0FBQzVCLFlBQUksUUFBUSxXQUFXO0FBQ25CLGlCQUFPO0FBQ1gsUUFBSSxRQUFRLFdBQVcsV0FDbkIsT0FBTyxNQUFNLEdBQ2pCLFVBQVUsSUFBSSxRQUFRLEtBQUs7QUFBQSxNQUMvQjtBQUNBLGFBQU8sRUFBRSxRQUFRLE9BQU8sT0FBTyxPQUFPLFVBQVU7QUFBQSxJQUNwRDtBQUNBLFFBQU0sV0FBVyxDQUFDLEdBQUcsSUFBSSxLQUFLLE9BQU8sQ0FBQyxFQUFFLElBQUksQ0FBQyxNQUFNLE1BQU0sVUFBVSxPQUFPLElBQUksbUJBQW1CLEtBQUssTUFBTSxJQUFJLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDekgsV0FBSSxJQUFJLE9BQU8sUUFDSixRQUFRLElBQUksUUFBUSxFQUFFLEtBQUssQ0FBQ0EsY0FBYSxZQUFZQSxTQUFRLENBQUMsSUFHOUQsWUFBWSxRQUFRO0FBQUEsRUFFbkM7QUFBQSxFQUNBLElBQUksU0FBUyxTQUFTO0FBQ2xCLFdBQU8sSUFBSSxRQUFPO0FBQUEsTUFDZCxHQUFHLEtBQUs7QUFBQSxNQUNSLFNBQVMsRUFBRSxPQUFPLFNBQVMsU0FBUyxVQUFVLFNBQVMsT0FBTyxFQUFFO0FBQUEsSUFDcEUsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUksU0FBUyxTQUFTO0FBQ2xCLFdBQU8sSUFBSSxRQUFPO0FBQUEsTUFDZCxHQUFHLEtBQUs7QUFBQSxNQUNSLFNBQVMsRUFBRSxPQUFPLFNBQVMsU0FBUyxVQUFVLFNBQVMsT0FBTyxFQUFFO0FBQUEsSUFDcEUsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLEtBQUssTUFBTSxTQUFTO0FBQ2hCLFdBQU8sS0FBSyxJQUFJLE1BQU0sT0FBTyxFQUFFLElBQUksTUFBTSxPQUFPO0FBQUEsRUFDcEQ7QUFBQSxFQUNBLFNBQVMsU0FBUztBQUNkLFdBQU8sS0FBSyxJQUFJLEdBQUcsT0FBTztBQUFBLEVBQzlCO0FBQ0o7QUFDQSxPQUFPLFNBQVMsQ0FBQyxXQUFXLFdBQ2pCLElBQUksT0FBTztBQUFBLEVBQ2Q7QUFBQSxFQUNBLFNBQVM7QUFBQSxFQUNULFNBQVM7QUFBQSxFQUNULFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUUsSUFBTSxjQUFOLE1BQU0scUJBQW9CLFFBQVE7QUFBQSxFQUNyQyxjQUFjO0FBQ1YsVUFBTSxHQUFHLFNBQVMsR0FDbEIsS0FBSyxXQUFXLEtBQUs7QUFBQSxFQUN6QjtBQUFBLEVBQ0EsT0FBTyxPQUFPO0FBQ1YsUUFBTSxFQUFFLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBQzlDLFFBQUksSUFBSSxlQUFlLGNBQWM7QUFDakMsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLGNBQWM7QUFBQSxRQUN4QixVQUFVLElBQUk7QUFBQSxNQUNsQixDQUFDLEdBQ007QUFFWCxhQUFTLGNBQWMsTUFBTVosUUFBTztBQUNoQyxhQUFPLFVBQVU7QUFBQSxRQUNiLE1BQU07QUFBQSxRQUNOLE1BQU0sSUFBSTtBQUFBLFFBQ1YsV0FBVyxDQUFDLElBQUksT0FBTyxvQkFBb0IsSUFBSSxnQkFBZ0IsWUFBWSxHQUFHLFVBQWUsRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztBQUFBLFFBQ2hILFdBQVc7QUFBQSxVQUNQLE1BQU0sYUFBYTtBQUFBLFVBQ25CLGdCQUFnQkE7QUFBQSxRQUNwQjtBQUFBLE1BQ0osQ0FBQztBQUFBLElBQ0w7QUFDQSxhQUFTLGlCQUFpQixTQUFTQSxRQUFPO0FBQ3RDLGFBQU8sVUFBVTtBQUFBLFFBQ2IsTUFBTTtBQUFBLFFBQ04sTUFBTSxJQUFJO0FBQUEsUUFDVixXQUFXLENBQUMsSUFBSSxPQUFPLG9CQUFvQixJQUFJLGdCQUFnQixZQUFZLEdBQUcsVUFBZSxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO0FBQUEsUUFDaEgsV0FBVztBQUFBLFVBQ1AsTUFBTSxhQUFhO0FBQUEsVUFDbkIsaUJBQWlCQTtBQUFBLFFBQ3JCO0FBQUEsTUFDSixDQUFDO0FBQUEsSUFDTDtBQUNBLFFBQU0sU0FBUyxFQUFFLFVBQVUsSUFBSSxPQUFPLG1CQUFtQixHQUNuRCxLQUFLLElBQUk7QUFDZixRQUFJLEtBQUssS0FBSyxtQkFBbUIsWUFBWTtBQUl6QyxVQUFNLEtBQUs7QUFDWCxhQUFPLEdBQUcsa0JBQW1CLE1BQU07QUFDL0IsWUFBTUEsU0FBUSxJQUFJLFNBQVMsQ0FBQyxDQUFDLEdBQ3ZCLGFBQWEsTUFBTSxHQUFHLEtBQUssS0FBSyxXQUFXLE1BQU0sTUFBTSxFQUFFLE1BQU0sQ0FBQyxNQUFNO0FBQ3hFLGdCQUFBQSxPQUFNLFNBQVMsY0FBYyxNQUFNLENBQUMsQ0FBQyxHQUMvQkE7QUFBQSxRQUNWLENBQUMsR0FDSyxTQUFTLE1BQU0sUUFBUSxNQUFNLElBQUksTUFBTSxVQUFVO0FBT3ZELGVBTnNCLE1BQU0sR0FBRyxLQUFLLFFBQVEsS0FBSyxLQUM1QyxXQUFXLFFBQVEsTUFBTSxFQUN6QixNQUFNLENBQUMsTUFBTTtBQUNkLGdCQUFBQSxPQUFNLFNBQVMsaUJBQWlCLFFBQVEsQ0FBQyxDQUFDLEdBQ3BDQTtBQUFBLFFBQ1YsQ0FBQztBQUFBLE1BRUwsQ0FBQztBQUFBLElBQ0wsT0FDSztBQUlELFVBQU0sS0FBSztBQUNYLGFBQU8sR0FBRyxZQUFhLE1BQU07QUFDekIsWUFBTSxhQUFhLEdBQUcsS0FBSyxLQUFLLFVBQVUsTUFBTSxNQUFNO0FBQ3RELFlBQUksQ0FBQyxXQUFXO0FBQ1osZ0JBQU0sSUFBSSxTQUFTLENBQUMsY0FBYyxNQUFNLFdBQVcsS0FBSyxDQUFDLENBQUM7QUFFOUQsWUFBTSxTQUFTLFFBQVEsTUFBTSxJQUFJLE1BQU0sV0FBVyxJQUFJLEdBQ2hELGdCQUFnQixHQUFHLEtBQUssUUFBUSxVQUFVLFFBQVEsTUFBTTtBQUM5RCxZQUFJLENBQUMsY0FBYztBQUNmLGdCQUFNLElBQUksU0FBUyxDQUFDLGlCQUFpQixRQUFRLGNBQWMsS0FBSyxDQUFDLENBQUM7QUFFdEUsZUFBTyxjQUFjO0FBQUEsTUFDekIsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQUEsRUFDQSxhQUFhO0FBQ1QsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsYUFBYTtBQUNULFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLFFBQVEsT0FBTztBQUNYLFdBQU8sSUFBSSxhQUFZO0FBQUEsTUFDbkIsR0FBRyxLQUFLO0FBQUEsTUFDUixNQUFNLFNBQVMsT0FBTyxLQUFLLEVBQUUsS0FBSyxXQUFXLE9BQU8sQ0FBQztBQUFBLElBQ3pELENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxRQUFRLFlBQVk7QUFDaEIsV0FBTyxJQUFJLGFBQVk7QUFBQSxNQUNuQixHQUFHLEtBQUs7QUFBQSxNQUNSLFNBQVM7QUFBQSxJQUNiLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxVQUFVLE1BQU07QUFFWixXQURzQixLQUFLLE1BQU0sSUFBSTtBQUFBLEVBRXpDO0FBQUEsRUFDQSxnQkFBZ0IsTUFBTTtBQUVsQixXQURzQixLQUFLLE1BQU0sSUFBSTtBQUFBLEVBRXpDO0FBQUEsRUFDQSxPQUFPLE9BQU8sTUFBTSxTQUFTLFFBQVE7QUFDakMsV0FBTyxJQUFJLGFBQVk7QUFBQSxNQUNuQixNQUFPLFFBQWMsU0FBUyxPQUFPLENBQUMsQ0FBQyxFQUFFLEtBQUssV0FBVyxPQUFPLENBQUM7QUFBQSxNQUNqRSxTQUFTLFdBQVcsV0FBVyxPQUFPO0FBQUEsTUFDdEMsVUFBVSxzQkFBc0I7QUFBQSxNQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQUEsSUFDakMsQ0FBQztBQUFBLEVBQ0w7QUFDSixHQUNhLFVBQU4sY0FBc0IsUUFBUTtBQUFBLEVBQ2pDLElBQUksU0FBUztBQUNULFdBQU8sS0FBSyxLQUFLLE9BQU87QUFBQSxFQUM1QjtBQUFBLEVBQ0EsT0FBTyxPQUFPO0FBQ1YsUUFBTSxFQUFFLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBRTlDLFdBRG1CLEtBQUssS0FBSyxPQUFPLEVBQ2xCLE9BQU8sRUFBRSxNQUFNLElBQUksTUFBTSxNQUFNLElBQUksTUFBTSxRQUFRLElBQUksQ0FBQztBQUFBLEVBQzVFO0FBQ0o7QUFDQSxRQUFRLFNBQVMsQ0FBQyxRQUFRLFdBQ2YsSUFBSSxRQUFRO0FBQUEsRUFDZjtBQUFBLEVBQ0EsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLGFBQU4sY0FBeUIsUUFBUTtBQUFBLEVBQ3BDLE9BQU8sT0FBTztBQUNWLFFBQUksTUFBTSxTQUFTLEtBQUssS0FBSyxPQUFPO0FBQ2hDLFVBQU0sTUFBTSxLQUFLLGdCQUFnQixLQUFLO0FBQ3RDLCtCQUFrQixLQUFLO0FBQUEsUUFDbkIsVUFBVSxJQUFJO0FBQUEsUUFDZCxNQUFNLGFBQWE7QUFBQSxRQUNuQixVQUFVLEtBQUssS0FBSztBQUFBLE1BQ3hCLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEVBQUUsUUFBUSxTQUFTLE9BQU8sTUFBTSxLQUFLO0FBQUEsRUFDaEQ7QUFBQSxFQUNBLElBQUksUUFBUTtBQUNSLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFDSjtBQUNBLFdBQVcsU0FBUyxDQUFDLE9BQU8sV0FDakIsSUFBSSxXQUFXO0FBQUEsRUFDbEI7QUFBQSxFQUNBLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUwsU0FBUyxjQUFjLFFBQVEsUUFBUTtBQUNuQyxTQUFPLElBQUksUUFBUTtBQUFBLElBQ2Y7QUFBQSxJQUNBLFVBQVUsc0JBQXNCO0FBQUEsSUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUFBLEVBQ2pDLENBQUM7QUFDTDtBQUNPLElBQU0sVUFBTixNQUFNLGlCQUFnQixRQUFRO0FBQUEsRUFDakMsT0FBTyxPQUFPO0FBQ1YsUUFBSSxPQUFPLE1BQU0sUUFBUyxVQUFVO0FBQ2hDLFVBQU0sTUFBTSxLQUFLLGdCQUFnQixLQUFLLEdBQ2hDLGlCQUFpQixLQUFLLEtBQUs7QUFDakMsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixVQUFVLEtBQUssV0FBVyxjQUFjO0FBQUEsUUFDeEMsVUFBVSxJQUFJO0FBQUEsUUFDZCxNQUFNLGFBQWE7QUFBQSxNQUN2QixDQUFDLEdBQ007QUFBQSxJQUNYO0FBSUEsUUFISyxLQUFLLFdBQ04sS0FBSyxTQUFTLElBQUksSUFBSSxLQUFLLEtBQUssTUFBTSxJQUV0QyxDQUFDLEtBQUssT0FBTyxJQUFJLE1BQU0sSUFBSSxHQUFHO0FBQzlCLFVBQU0sTUFBTSxLQUFLLGdCQUFnQixLQUFLLEdBQ2hDLGlCQUFpQixLQUFLLEtBQUs7QUFDakMsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixVQUFVLElBQUk7QUFBQSxRQUNkLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFNBQVM7QUFBQSxNQUNiLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFBQSxFQUNBLElBQUksT0FBTztBQUNQLFFBQU0sYUFBYSxDQUFDO0FBQ3BCLGFBQVcsT0FBTyxLQUFLLEtBQUs7QUFDeEIsaUJBQVcsR0FBRyxJQUFJO0FBRXRCLFdBQU87QUFBQSxFQUNYO0FBQUEsRUFDQSxJQUFJLFNBQVM7QUFDVCxRQUFNLGFBQWEsQ0FBQztBQUNwQixhQUFXLE9BQU8sS0FBSyxLQUFLO0FBQ3hCLGlCQUFXLEdBQUcsSUFBSTtBQUV0QixXQUFPO0FBQUEsRUFDWDtBQUFBLEVBQ0EsSUFBSSxPQUFPO0FBQ1AsUUFBTSxhQUFhLENBQUM7QUFDcEIsYUFBVyxPQUFPLEtBQUssS0FBSztBQUN4QixpQkFBVyxHQUFHLElBQUk7QUFFdEIsV0FBTztBQUFBLEVBQ1g7QUFBQSxFQUNBLFFBQVEsUUFBUSxTQUFTLEtBQUssTUFBTTtBQUNoQyxXQUFPLFNBQVEsT0FBTyxRQUFRO0FBQUEsTUFDMUIsR0FBRyxLQUFLO0FBQUEsTUFDUixHQUFHO0FBQUEsSUFDUCxDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsUUFBUSxRQUFRLFNBQVMsS0FBSyxNQUFNO0FBQ2hDLFdBQU8sU0FBUSxPQUFPLEtBQUssUUFBUSxPQUFPLENBQUMsUUFBUSxDQUFDLE9BQU8sU0FBUyxHQUFHLENBQUMsR0FBRztBQUFBLE1BQ3ZFLEdBQUcsS0FBSztBQUFBLE1BQ1IsR0FBRztBQUFBLElBQ1AsQ0FBQztBQUFBLEVBQ0w7QUFDSjtBQUNBLFFBQVEsU0FBUztBQUNWLElBQU0sZ0JBQU4sY0FBNEIsUUFBUTtBQUFBLEVBQ3ZDLE9BQU8sT0FBTztBQUNWLFFBQU0sbUJBQW1CLEtBQUssbUJBQW1CLEtBQUssS0FBSyxNQUFNLEdBQzNELE1BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QyxRQUFJLElBQUksZUFBZSxjQUFjLFVBQVUsSUFBSSxlQUFlLGNBQWMsUUFBUTtBQUNwRixVQUFNLGlCQUFpQixLQUFLLGFBQWEsZ0JBQWdCO0FBQ3pELCtCQUFrQixLQUFLO0FBQUEsUUFDbkIsVUFBVSxLQUFLLFdBQVcsY0FBYztBQUFBLFFBQ3hDLFVBQVUsSUFBSTtBQUFBLFFBQ2QsTUFBTSxhQUFhO0FBQUEsTUFDdkIsQ0FBQyxHQUNNO0FBQUEsSUFDWDtBQUlBLFFBSEssS0FBSyxXQUNOLEtBQUssU0FBUyxJQUFJLElBQUksS0FBSyxtQkFBbUIsS0FBSyxLQUFLLE1BQU0sQ0FBQyxJQUUvRCxDQUFDLEtBQUssT0FBTyxJQUFJLE1BQU0sSUFBSSxHQUFHO0FBQzlCLFVBQU0saUJBQWlCLEtBQUssYUFBYSxnQkFBZ0I7QUFDekQsK0JBQWtCLEtBQUs7QUFBQSxRQUNuQixVQUFVLElBQUk7QUFBQSxRQUNkLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFNBQVM7QUFBQSxNQUNiLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEdBQUcsTUFBTSxJQUFJO0FBQUEsRUFDeEI7QUFBQSxFQUNBLElBQUksT0FBTztBQUNQLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFDSjtBQUNBLGNBQWMsU0FBUyxDQUFDLFFBQVEsV0FDckIsSUFBSSxjQUFjO0FBQUEsRUFDckI7QUFBQSxFQUNBLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUUsSUFBTSxhQUFOLGNBQXlCLFFBQVE7QUFBQSxFQUNwQyxTQUFTO0FBQ0wsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsT0FBTyxPQUFPO0FBQ1YsUUFBTSxFQUFFLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBQzlDLFFBQUksSUFBSSxlQUFlLGNBQWMsV0FBVyxJQUFJLE9BQU8sVUFBVTtBQUNqRSwrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUVYLFFBQU0sY0FBYyxJQUFJLGVBQWUsY0FBYyxVQUFVLElBQUksT0FBTyxRQUFRLFFBQVEsSUFBSSxJQUFJO0FBQ2xHLFdBQU8sR0FBRyxZQUFZLEtBQUssQ0FBQyxTQUNqQixLQUFLLEtBQUssS0FBSyxXQUFXLE1BQU07QUFBQSxNQUNuQyxNQUFNLElBQUk7QUFBQSxNQUNWLFVBQVUsSUFBSSxPQUFPO0FBQUEsSUFDekIsQ0FBQyxDQUNKLENBQUM7QUFBQSxFQUNOO0FBQ0o7QUFDQSxXQUFXLFNBQVMsQ0FBQyxRQUFRLFdBQ2xCLElBQUksV0FBVztBQUFBLEVBQ2xCLE1BQU07QUFBQSxFQUNOLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsR0FBRyxvQkFBb0IsTUFBTTtBQUNqQyxDQUFDO0FBRUUsSUFBTSxhQUFOLGNBQXlCLFFBQVE7QUFBQSxFQUNwQyxZQUFZO0FBQ1IsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUFBLEVBQ0EsYUFBYTtBQUNULFdBQU8sS0FBSyxLQUFLLE9BQU8sS0FBSyxhQUFhLHNCQUFzQixhQUMxRCxLQUFLLEtBQUssT0FBTyxXQUFXLElBQzVCLEtBQUssS0FBSztBQUFBLEVBQ3BCO0FBQUEsRUFDQSxPQUFPLE9BQU87QUFDVixRQUFNLEVBQUUsUUFBUSxJQUFJLElBQUksS0FBSyxvQkFBb0IsS0FBSyxHQUNoRCxTQUFTLEtBQUssS0FBSyxVQUFVLE1BQzdCLFdBQVc7QUFBQSxNQUNiLFVBQVUsQ0FBQyxRQUFRO0FBQ2YsMEJBQWtCLEtBQUssR0FBRyxHQUN0QixJQUFJLFFBQ0osT0FBTyxNQUFNLElBR2IsT0FBTyxNQUFNO0FBQUEsTUFFckI7QUFBQSxNQUNBLElBQUksT0FBTztBQUNQLGVBQU8sSUFBSTtBQUFBLE1BQ2Y7QUFBQSxJQUNKO0FBRUEsUUFEQSxTQUFTLFdBQVcsU0FBUyxTQUFTLEtBQUssUUFBUSxHQUMvQyxPQUFPLFNBQVMsY0FBYztBQUM5QixVQUFNLFlBQVksT0FBTyxVQUFVLElBQUksTUFBTSxRQUFRO0FBQ3JELFVBQUksSUFBSSxPQUFPO0FBQ1gsZUFBTyxRQUFRLFFBQVEsU0FBUyxFQUFFLEtBQUssT0FBT2EsZUFBYztBQUN4RCxjQUFJLE9BQU8sVUFBVTtBQUNqQixtQkFBTztBQUNYLGNBQU0sU0FBUyxNQUFNLEtBQUssS0FBSyxPQUFPLFlBQVk7QUFBQSxZQUM5QyxNQUFNQTtBQUFBLFlBQ04sTUFBTSxJQUFJO0FBQUEsWUFDVixRQUFRO0FBQUEsVUFDWixDQUFDO0FBQ0QsaUJBQUksT0FBTyxXQUFXLFlBQ1gsVUFDUCxPQUFPLFdBQVcsVUFDWCxNQUFNLE9BQU8sS0FBSyxJQUN6QixPQUFPLFVBQVUsVUFDVixNQUFNLE9BQU8sS0FBSyxJQUN0QjtBQUFBLFFBQ1gsQ0FBQztBQUVBO0FBQ0QsWUFBSSxPQUFPLFVBQVU7QUFDakIsaUJBQU87QUFDWCxZQUFNLFNBQVMsS0FBSyxLQUFLLE9BQU8sV0FBVztBQUFBLFVBQ3ZDLE1BQU07QUFBQSxVQUNOLE1BQU0sSUFBSTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFFBQ1osQ0FBQztBQUNELGVBQUksT0FBTyxXQUFXLFlBQ1gsVUFDUCxPQUFPLFdBQVcsVUFDWCxNQUFNLE9BQU8sS0FBSyxJQUN6QixPQUFPLFVBQVUsVUFDVixNQUFNLE9BQU8sS0FBSyxJQUN0QjtBQUFBLE1BQ1g7QUFBQSxJQUNKO0FBQ0EsUUFBSSxPQUFPLFNBQVMsY0FBYztBQUM5QixVQUFNLG9CQUFvQixDQUFDLFFBQVE7QUFDL0IsWUFBTSxTQUFTLE9BQU8sV0FBVyxLQUFLLFFBQVE7QUFDOUMsWUFBSSxJQUFJLE9BQU87QUFDWCxpQkFBTyxRQUFRLFFBQVEsTUFBTTtBQUVqQyxZQUFJLGtCQUFrQjtBQUNsQixnQkFBTSxJQUFJLE1BQU0sMkZBQTJGO0FBRS9HLGVBQU87QUFBQSxNQUNYO0FBQ0EsVUFBSSxJQUFJLE9BQU8sVUFBVSxJQUFPO0FBQzVCLFlBQU0sUUFBUSxLQUFLLEtBQUssT0FBTyxXQUFXO0FBQUEsVUFDdEMsTUFBTSxJQUFJO0FBQUEsVUFDVixNQUFNLElBQUk7QUFBQSxVQUNWLFFBQVE7QUFBQSxRQUNaLENBQUM7QUFDRCxlQUFJLE1BQU0sV0FBVyxZQUNWLFdBQ1AsTUFBTSxXQUFXLFdBQ2pCLE9BQU8sTUFBTSxHQUVqQixrQkFBa0IsTUFBTSxLQUFLLEdBQ3RCLEVBQUUsUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNLE1BQU07QUFBQSxNQUN0RDtBQUVJLGVBQU8sS0FBSyxLQUFLLE9BQU8sWUFBWSxFQUFFLE1BQU0sSUFBSSxNQUFNLE1BQU0sSUFBSSxNQUFNLFFBQVEsSUFBSSxDQUFDLEVBQUUsS0FBSyxDQUFDLFVBQ25GLE1BQU0sV0FBVyxZQUNWLFdBQ1AsTUFBTSxXQUFXLFdBQ2pCLE9BQU8sTUFBTSxHQUNWLGtCQUFrQixNQUFNLEtBQUssRUFBRSxLQUFLLE9BQ2hDLEVBQUUsUUFBUSxPQUFPLE9BQU8sT0FBTyxNQUFNLE1BQU0sRUFDckQsRUFDSjtBQUFBLElBRVQ7QUFDQSxRQUFJLE9BQU8sU0FBUztBQUNoQixVQUFJLElBQUksT0FBTyxVQUFVLElBQU87QUFDNUIsWUFBTSxPQUFPLEtBQUssS0FBSyxPQUFPLFdBQVc7QUFBQSxVQUNyQyxNQUFNLElBQUk7QUFBQSxVQUNWLE1BQU0sSUFBSTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFFBQ1osQ0FBQztBQUNELFlBQUksQ0FBQyxRQUFRLElBQUk7QUFDYixpQkFBTztBQUNYLFlBQU0sU0FBUyxPQUFPLFVBQVUsS0FBSyxPQUFPLFFBQVE7QUFDcEQsWUFBSSxrQkFBa0I7QUFDbEIsZ0JBQU0sSUFBSSxNQUFNLGlHQUFpRztBQUVySCxlQUFPLEVBQUUsUUFBUSxPQUFPLE9BQU8sT0FBTyxPQUFPO0FBQUEsTUFDakQ7QUFFSSxlQUFPLEtBQUssS0FBSyxPQUFPLFlBQVksRUFBRSxNQUFNLElBQUksTUFBTSxNQUFNLElBQUksTUFBTSxRQUFRLElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQyxTQUNsRixRQUFRLElBQUksSUFFVixRQUFRLFFBQVEsT0FBTyxVQUFVLEtBQUssT0FBTyxRQUFRLENBQUMsRUFBRSxLQUFLLENBQUMsWUFBWTtBQUFBLFVBQzdFLFFBQVEsT0FBTztBQUFBLFVBQ2YsT0FBTztBQUFBLFFBQ1gsRUFBRSxJQUpTLE9BS2Q7QUFHVCxTQUFLLFlBQVksTUFBTTtBQUFBLEVBQzNCO0FBQ0o7QUFDQSxXQUFXLFNBQVMsQ0FBQyxRQUFRLFFBQVEsV0FDMUIsSUFBSSxXQUFXO0FBQUEsRUFDbEI7QUFBQSxFQUNBLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEM7QUFBQSxFQUNBLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVMLFdBQVcsdUJBQXVCLENBQUNDLGFBQVksUUFBUSxXQUM1QyxJQUFJLFdBQVc7QUFBQSxFQUNsQjtBQUFBLEVBQ0EsUUFBUSxFQUFFLE1BQU0sY0FBYyxXQUFXQSxZQUFXO0FBQUEsRUFDcEQsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFHRSxJQUFNLGNBQU4sY0FBMEIsUUFBUTtBQUFBLEVBQ3JDLE9BQU8sT0FBTztBQUVWLFdBRG1CLEtBQUssU0FBUyxLQUFLLE1BQ25CLGNBQWMsWUFDdEIsR0FBRyxNQUFTLElBRWhCLEtBQUssS0FBSyxVQUFVLE9BQU8sS0FBSztBQUFBLEVBQzNDO0FBQUEsRUFDQSxTQUFTO0FBQ0wsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUNKO0FBQ0EsWUFBWSxTQUFTLENBQUMsTUFBTSxXQUNqQixJQUFJLFlBQVk7QUFBQSxFQUNuQixXQUFXO0FBQUEsRUFDWCxVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVFLElBQU0sY0FBTixjQUEwQixRQUFRO0FBQUEsRUFDckMsT0FBTyxPQUFPO0FBRVYsV0FEbUIsS0FBSyxTQUFTLEtBQUssTUFDbkIsY0FBYyxPQUN0QixHQUFHLElBQUksSUFFWCxLQUFLLEtBQUssVUFBVSxPQUFPLEtBQUs7QUFBQSxFQUMzQztBQUFBLEVBQ0EsU0FBUztBQUNMLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFDSjtBQUNBLFlBQVksU0FBUyxDQUFDLE1BQU0sV0FDakIsSUFBSSxZQUFZO0FBQUEsRUFDbkIsV0FBVztBQUFBLEVBQ1gsVUFBVSxzQkFBc0I7QUFBQSxFQUNoQyxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLGFBQU4sY0FBeUIsUUFBUTtBQUFBLEVBQ3BDLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxJQUFJLElBQUksS0FBSyxvQkFBb0IsS0FBSyxHQUMxQyxPQUFPLElBQUk7QUFDZixXQUFJLElBQUksZUFBZSxjQUFjLGNBQ2pDLE9BQU8sS0FBSyxLQUFLLGFBQWEsSUFFM0IsS0FBSyxLQUFLLFVBQVUsT0FBTztBQUFBLE1BQzlCO0FBQUEsTUFDQSxNQUFNLElBQUk7QUFBQSxNQUNWLFFBQVE7QUFBQSxJQUNaLENBQUM7QUFBQSxFQUNMO0FBQUEsRUFDQSxnQkFBZ0I7QUFDWixXQUFPLEtBQUssS0FBSztBQUFBLEVBQ3JCO0FBQ0o7QUFDQSxXQUFXLFNBQVMsQ0FBQyxNQUFNLFdBQ2hCLElBQUksV0FBVztBQUFBLEVBQ2xCLFdBQVc7QUFBQSxFQUNYLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsY0FBYyxPQUFPLE9BQU8sV0FBWSxhQUFhLE9BQU8sVUFBVSxNQUFNLE9BQU87QUFBQSxFQUNuRixHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFdBQU4sY0FBdUIsUUFBUTtBQUFBLEVBQ2xDLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxJQUFJLElBQUksS0FBSyxvQkFBb0IsS0FBSyxHQUV4QyxTQUFTO0FBQUEsTUFDWCxHQUFHO0FBQUEsTUFDSCxRQUFRO0FBQUEsUUFDSixHQUFHLElBQUk7QUFBQSxRQUNQLFFBQVEsQ0FBQztBQUFBLE1BQ2I7QUFBQSxJQUNKLEdBQ00sU0FBUyxLQUFLLEtBQUssVUFBVSxPQUFPO0FBQUEsTUFDdEMsTUFBTSxPQUFPO0FBQUEsTUFDYixNQUFNLE9BQU87QUFBQSxNQUNiLFFBQVE7QUFBQSxRQUNKLEdBQUc7QUFBQSxNQUNQO0FBQUEsSUFDSixDQUFDO0FBQ0QsV0FBSSxRQUFRLE1BQU0sSUFDUCxPQUFPLEtBQUssQ0FBQ0MsYUFDVDtBQUFBLE1BQ0gsUUFBUTtBQUFBLE1BQ1IsT0FBT0EsUUFBTyxXQUFXLFVBQ25CQSxRQUFPLFFBQ1AsS0FBSyxLQUFLLFdBQVc7QUFBQSxRQUNuQixJQUFJLFFBQVE7QUFDUixpQkFBTyxJQUFJLFNBQVMsT0FBTyxPQUFPLE1BQU07QUFBQSxRQUM1QztBQUFBLFFBQ0EsT0FBTyxPQUFPO0FBQUEsTUFDbEIsQ0FBQztBQUFBLElBQ1QsRUFDSCxJQUdNO0FBQUEsTUFDSCxRQUFRO0FBQUEsTUFDUixPQUFPLE9BQU8sV0FBVyxVQUNuQixPQUFPLFFBQ1AsS0FBSyxLQUFLLFdBQVc7QUFBQSxRQUNuQixJQUFJLFFBQVE7QUFDUixpQkFBTyxJQUFJLFNBQVMsT0FBTyxPQUFPLE1BQU07QUFBQSxRQUM1QztBQUFBLFFBQ0EsT0FBTyxPQUFPO0FBQUEsTUFDbEIsQ0FBQztBQUFBLElBQ1Q7QUFBQSxFQUVSO0FBQUEsRUFDQSxjQUFjO0FBQ1YsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUNKO0FBQ0EsU0FBUyxTQUFTLENBQUMsTUFBTSxXQUNkLElBQUksU0FBUztBQUFBLEVBQ2hCLFdBQVc7QUFBQSxFQUNYLFVBQVUsc0JBQXNCO0FBQUEsRUFDaEMsWUFBWSxPQUFPLE9BQU8sU0FBVSxhQUFhLE9BQU8sUUFBUSxNQUFNLE9BQU87QUFBQSxFQUM3RSxHQUFHLG9CQUFvQixNQUFNO0FBQ2pDLENBQUM7QUFFRSxJQUFNLFNBQU4sY0FBcUIsUUFBUTtBQUFBLEVBQ2hDLE9BQU8sT0FBTztBQUVWLFFBRG1CLEtBQUssU0FBUyxLQUFLLE1BQ25CLGNBQWMsS0FBSztBQUNsQyxVQUFNLE1BQU0sS0FBSyxnQkFBZ0IsS0FBSztBQUN0QywrQkFBa0IsS0FBSztBQUFBLFFBQ25CLE1BQU0sYUFBYTtBQUFBLFFBQ25CLFVBQVUsY0FBYztBQUFBLFFBQ3hCLFVBQVUsSUFBSTtBQUFBLE1BQ2xCLENBQUMsR0FDTTtBQUFBLElBQ1g7QUFDQSxXQUFPLEVBQUUsUUFBUSxTQUFTLE9BQU8sTUFBTSxLQUFLO0FBQUEsRUFDaEQ7QUFDSjtBQUNBLE9BQU8sU0FBUyxDQUFDLFdBQ04sSUFBSSxPQUFPO0FBQUEsRUFDZCxVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQUVFLElBQU0sUUFBUSxPQUFPLFdBQVcsR0FDMUIsYUFBTixjQUF5QixRQUFRO0FBQUEsRUFDcEMsT0FBTyxPQUFPO0FBQ1YsUUFBTSxFQUFFLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLLEdBQ3hDLE9BQU8sSUFBSTtBQUNqQixXQUFPLEtBQUssS0FBSyxLQUFLLE9BQU87QUFBQSxNQUN6QjtBQUFBLE1BQ0EsTUFBTSxJQUFJO0FBQUEsTUFDVixRQUFRO0FBQUEsSUFDWixDQUFDO0FBQUEsRUFDTDtBQUFBLEVBQ0EsU0FBUztBQUNMLFdBQU8sS0FBSyxLQUFLO0FBQUEsRUFDckI7QUFDSixHQUNhLGNBQU4sTUFBTSxxQkFBb0IsUUFBUTtBQUFBLEVBQ3JDLE9BQU8sT0FBTztBQUNWLFFBQU0sRUFBRSxRQUFRLElBQUksSUFBSSxLQUFLLG9CQUFvQixLQUFLO0FBQ3RELFFBQUksSUFBSSxPQUFPO0FBcUJYLGNBcEJvQixZQUFZO0FBQzVCLFlBQU0sV0FBVyxNQUFNLEtBQUssS0FBSyxHQUFHLFlBQVk7QUFBQSxVQUM1QyxNQUFNLElBQUk7QUFBQSxVQUNWLE1BQU0sSUFBSTtBQUFBLFVBQ1YsUUFBUTtBQUFBLFFBQ1osQ0FBQztBQUNELGVBQUksU0FBUyxXQUFXLFlBQ2IsVUFDUCxTQUFTLFdBQVcsV0FDcEIsT0FBTyxNQUFNLEdBQ04sTUFBTSxTQUFTLEtBQUssS0FHcEIsS0FBSyxLQUFLLElBQUksWUFBWTtBQUFBLFVBQzdCLE1BQU0sU0FBUztBQUFBLFVBQ2YsTUFBTSxJQUFJO0FBQUEsVUFDVixRQUFRO0FBQUEsUUFDWixDQUFDO0FBQUEsTUFFVCxHQUNtQjtBQUVsQjtBQUNELFVBQU0sV0FBVyxLQUFLLEtBQUssR0FBRyxXQUFXO0FBQUEsUUFDckMsTUFBTSxJQUFJO0FBQUEsUUFDVixNQUFNLElBQUk7QUFBQSxRQUNWLFFBQVE7QUFBQSxNQUNaLENBQUM7QUFDRCxhQUFJLFNBQVMsV0FBVyxZQUNiLFVBQ1AsU0FBUyxXQUFXLFdBQ3BCLE9BQU8sTUFBTSxHQUNOO0FBQUEsUUFDSCxRQUFRO0FBQUEsUUFDUixPQUFPLFNBQVM7QUFBQSxNQUNwQixLQUdPLEtBQUssS0FBSyxJQUFJLFdBQVc7QUFBQSxRQUM1QixNQUFNLFNBQVM7QUFBQSxRQUNmLE1BQU0sSUFBSTtBQUFBLFFBQ1YsUUFBUTtBQUFBLE1BQ1osQ0FBQztBQUFBLElBRVQ7QUFBQSxFQUNKO0FBQUEsRUFDQSxPQUFPLE9BQU8sR0FBRyxHQUFHO0FBQ2hCLFdBQU8sSUFBSSxhQUFZO0FBQUEsTUFDbkIsSUFBSTtBQUFBLE1BQ0osS0FBSztBQUFBLE1BQ0wsVUFBVSxzQkFBc0I7QUFBQSxJQUNwQyxDQUFDO0FBQUEsRUFDTDtBQUNKLEdBQ2EsY0FBTixjQUEwQixRQUFRO0FBQUEsRUFDckMsT0FBTyxPQUFPO0FBQ1YsUUFBTSxTQUFTLEtBQUssS0FBSyxVQUFVLE9BQU8sS0FBSyxHQUN6QyxTQUFTLENBQUMsVUFDUixRQUFRLElBQUksTUFDWixLQUFLLFFBQVEsT0FBTyxPQUFPLEtBQUssS0FBSyxJQUVsQztBQUVYLFdBQU8sUUFBUSxNQUFNLElBQUksT0FBTyxLQUFLLENBQUMsU0FBUyxPQUFPLElBQUksQ0FBQyxJQUFJLE9BQU8sTUFBTTtBQUFBLEVBQ2hGO0FBQUEsRUFDQSxTQUFTO0FBQ0wsV0FBTyxLQUFLLEtBQUs7QUFBQSxFQUNyQjtBQUNKO0FBQ0EsWUFBWSxTQUFTLENBQUMsTUFBTSxXQUNqQixJQUFJLFlBQVk7QUFBQSxFQUNuQixXQUFXO0FBQUEsRUFDWCxVQUFVLHNCQUFzQjtBQUFBLEVBQ2hDLEdBQUcsb0JBQW9CLE1BQU07QUFDakMsQ0FBQztBQWdERSxJQUFNLE9BQU87QUFBQSxFQUNoQixRQUFRLFVBQVU7QUFDdEIsR0FDVztBQUFBLENBQ1YsU0FBVUMsd0JBQXVCO0FBQzlCLEVBQUFBLHVCQUFzQixZQUFlLGFBQ3JDQSx1QkFBc0IsWUFBZSxhQUNyQ0EsdUJBQXNCLFNBQVksVUFDbENBLHVCQUFzQixZQUFlLGFBQ3JDQSx1QkFBc0IsYUFBZ0IsY0FDdENBLHVCQUFzQixVQUFhLFdBQ25DQSx1QkFBc0IsWUFBZSxhQUNyQ0EsdUJBQXNCLGVBQWtCLGdCQUN4Q0EsdUJBQXNCLFVBQWEsV0FDbkNBLHVCQUFzQixTQUFZLFVBQ2xDQSx1QkFBc0IsYUFBZ0IsY0FDdENBLHVCQUFzQixXQUFjLFlBQ3BDQSx1QkFBc0IsVUFBYSxXQUNuQ0EsdUJBQXNCLFdBQWMsWUFDcENBLHVCQUFzQixZQUFlLGFBQ3JDQSx1QkFBc0IsV0FBYyxZQUNwQ0EsdUJBQXNCLHdCQUEyQix5QkFDakRBLHVCQUFzQixrQkFBcUIsbUJBQzNDQSx1QkFBc0IsV0FBYyxZQUNwQ0EsdUJBQXNCLFlBQWUsYUFDckNBLHVCQUFzQixTQUFZLFVBQ2xDQSx1QkFBc0IsU0FBWSxVQUNsQ0EsdUJBQXNCLGNBQWlCLGVBQ3ZDQSx1QkFBc0IsVUFBYSxXQUNuQ0EsdUJBQXNCLGFBQWdCLGNBQ3RDQSx1QkFBc0IsVUFBYSxXQUNuQ0EsdUJBQXNCLGFBQWdCLGNBQ3RDQSx1QkFBc0IsZ0JBQW1CLGlCQUN6Q0EsdUJBQXNCLGNBQWlCLGVBQ3ZDQSx1QkFBc0IsY0FBaUIsZUFDdkNBLHVCQUFzQixhQUFnQixjQUN0Q0EsdUJBQXNCLFdBQWMsWUFDcENBLHVCQUFzQixhQUFnQixjQUN0Q0EsdUJBQXNCLGFBQWdCLGNBQ3RDQSx1QkFBc0IsY0FBaUIsZUFDdkNBLHVCQUFzQixjQUFpQjtBQUMzQyxHQUFHLDBCQUEwQix3QkFBd0IsQ0FBQyxFQUFFO0FBVXhELElBQU0sYUFBYSxVQUFVLFFBQ3ZCLGFBQWEsVUFBVSxRQUN2QixVQUFVLE9BQU8sUUFDakIsYUFBYSxVQUFVLFFBQ3ZCLGNBQWMsV0FBVyxRQUN6QixXQUFXLFFBQVEsUUFDbkIsYUFBYSxVQUFVLFFBQ3ZCLGdCQUFnQixhQUFhLFFBQzdCLFdBQVcsUUFBUSxRQUNuQixVQUFVLE9BQU8sUUFDakIsY0FBYyxXQUFXLFFBQ3pCLFlBQVksU0FBUyxRQUNyQixXQUFXLFFBQVEsUUFDbkIsWUFBWSxTQUFTLFFBQ3JCLGFBQWEsVUFBVSxRQUN2QixtQkFBbUIsVUFBVSxjQUM3QixZQUFZLFNBQVMsUUFDckIseUJBQXlCLHNCQUFzQixRQUMvQyxtQkFBbUIsZ0JBQWdCLFFBQ25DLFlBQVksU0FBUyxRQUNyQixhQUFhLFVBQVUsUUFDdkIsVUFBVSxPQUFPLFFBQ2pCLFVBQVUsT0FBTyxRQUNqQixlQUFlLFlBQVksUUFDM0IsV0FBVyxRQUFRLFFBQ25CLGNBQWMsV0FBVyxRQUN6QixXQUFXLFFBQVEsUUFDbkIsaUJBQWlCLGNBQWMsUUFDL0IsY0FBYyxXQUFXLFFBQ3pCLGNBQWMsV0FBVyxRQUN6QixlQUFlLFlBQVksUUFDM0IsZUFBZSxZQUFZLFFBQzNCLGlCQUFpQixXQUFXLHNCQUM1QixlQUFlLFlBQVk7OztBQzlsSDFCLElBQU0sUUFBUSxPQUFPLE9BQU87QUFBQSxFQUMvQixRQUFRO0FBQ1osQ0FBQztBQUFBO0FBQytCLFNBQVMsYUFBYSxNQUFNQyxjQUFhLFFBQVE7QUFDN0UsV0FBUyxLQUFLLE1BQU0sS0FBSztBQVdyQixRQVZLLEtBQUssUUFDTixPQUFPLGVBQWUsTUFBTSxRQUFRO0FBQUEsTUFDaEMsT0FBTztBQUFBLFFBQ0g7QUFBQSxRQUNBLFFBQVE7QUFBQSxRQUNSLFFBQVEsb0JBQUksSUFBSTtBQUFBLE1BQ3BCO0FBQUEsTUFDQSxZQUFZO0FBQUEsSUFDaEIsQ0FBQyxHQUVELEtBQUssS0FBSyxPQUFPLElBQUksSUFBSTtBQUN6QjtBQUVKLFNBQUssS0FBSyxPQUFPLElBQUksSUFBSSxHQUN6QkEsYUFBWSxNQUFNLEdBQUc7QUFFckIsUUFBTSxRQUFRLEVBQUUsV0FDVixPQUFPLE9BQU8sS0FBSyxLQUFLO0FBQzlCLGFBQVMsSUFBSSxHQUFHLElBQUksS0FBSyxRQUFRLEtBQUs7QUFDbEMsVUFBTSxJQUFJLEtBQUssQ0FBQztBQUNoQixNQUFNLEtBQUssU0FDUCxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsRUFBRSxLQUFLLElBQUk7QUFBQSxJQUVwQztBQUFBLEVBQ0o7QUFFQSxNQUFNLFNBQVMsUUFBUSxVQUFVO0FBQUEsRUFDakMsTUFBTSxtQkFBbUIsT0FBTztBQUFBLEVBQ2hDO0FBQ0EsU0FBTyxlQUFlLFlBQVksUUFBUSxFQUFFLE9BQU8sS0FBSyxDQUFDO0FBQ3pELFdBQVMsRUFBRSxLQUFLO0FBQ1osUUFBSUM7QUFDSixRQUFNLE9BQU8sUUFBUSxTQUFTLElBQUksV0FBVyxJQUFJO0FBQ2pELFNBQUssTUFBTSxHQUFHLElBQ2JBLE1BQUssS0FBSyxNQUFNLGFBQWFBLElBQUcsV0FBVyxDQUFDO0FBQzdDLGFBQVcsTUFBTSxLQUFLLEtBQUs7QUFDdkIsU0FBRztBQUVQLFdBQU87QUFBQSxFQUNYO0FBQ0EsZ0JBQU8sZUFBZSxHQUFHLFFBQVEsRUFBRSxPQUFPLEtBQUssQ0FBQyxHQUNoRCxPQUFPLGVBQWUsR0FBRyxPQUFPLGFBQWE7QUFBQSxJQUN6QyxPQUFPLENBQUMsU0FDQSxRQUFRLFVBQVUsZ0JBQWdCLE9BQU8sU0FDbEMsS0FDSixNQUFNLE1BQU0sUUFBUSxJQUFJLElBQUk7QUFBQSxFQUUzQyxDQUFDLEdBQ0QsT0FBTyxlQUFlLEdBQUcsUUFBUSxFQUFFLE9BQU8sS0FBSyxDQUFDLEdBQ3pDO0FBQ1g7QUFFTyxJQUFNLFNBQVMsT0FBTyxXQUFXLEdBQzNCLGlCQUFOLGNBQTZCLE1BQU07QUFBQSxFQUN0QyxjQUFjO0FBQ1YsVUFBTSwwRUFBMEU7QUFBQSxFQUNwRjtBQUNKLEdBQ2Esa0JBQU4sY0FBOEIsTUFBTTtBQUFBLEVBQ3ZDLFlBQVksTUFBTTtBQUNkLFVBQU0sdURBQXVELElBQUksRUFBRSxHQUNuRSxLQUFLLE9BQU87QUFBQSxFQUNoQjtBQUNKLEdBQ2EsZUFBZSxDQUFDO0FBQ3RCLFNBQVMsT0FBTyxXQUFXO0FBQzlCLFNBQUksYUFDQSxPQUFPLE9BQU8sY0FBYyxTQUFTLEdBQ2xDO0FBQ1g7OztBQzNFQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw0QkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLHVCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ08sU0FBUyxZQUFZLEtBQUs7QUFDN0IsU0FBTztBQUNYO0FBQ08sU0FBUyxlQUFlLEtBQUs7QUFDaEMsU0FBTztBQUNYO0FBQ08sU0FBUyxTQUFTLE1BQU07QUFBRTtBQUMxQixTQUFTLFlBQVksSUFBSTtBQUM1QixRQUFNLElBQUksTUFBTSxzQ0FBc0M7QUFDMUQ7QUFDTyxTQUFTLE9BQU8sR0FBRztBQUFFO0FBQ3JCLFNBQVMsY0FBYyxTQUFTO0FBQ25DLE1BQU0sZ0JBQWdCLE9BQU8sT0FBTyxPQUFPLEVBQUUsT0FBTyxDQUFDLE1BQU0sT0FBTyxLQUFNLFFBQVE7QUFJaEYsU0FIZSxPQUFPLFFBQVEsT0FBTyxFQUNoQyxPQUFPLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxjQUFjLFFBQVEsQ0FBQyxDQUFDLE1BQU0sRUFBRSxFQUNuRCxJQUFJLENBQUMsQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDO0FBRTFCO0FBQ08sU0FBUyxXQUFXQyxRQUFPLFlBQVksS0FBSztBQUMvQyxTQUFPQSxPQUFNLElBQUksQ0FBQyxRQUFRLG1CQUFtQixHQUFHLENBQUMsRUFBRSxLQUFLLFNBQVM7QUFDckU7QUFDTyxTQUFTLHNCQUFzQixHQUFHLE9BQU87QUFDNUMsU0FBSSxPQUFPLFNBQVUsV0FDVixNQUFNLFNBQVMsSUFDbkI7QUFDWDtBQUNPLFNBQVMsT0FBTyxRQUFRO0FBRTNCLFNBQU87QUFBQSxJQUNILElBQUksUUFBUTtBQUNFO0FBQ04sWUFBTSxRQUFRLE9BQU87QUFDckIsc0JBQU8sZUFBZSxNQUFNLFNBQVMsRUFBRSxNQUFNLENBQUMsR0FDdkM7QUFBQSxNQUNYO0FBQ0EsWUFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBQUEsSUFDOUM7QUFBQSxFQUNKO0FBQ0o7QUFDTyxTQUFTLFFBQVEsT0FBTztBQUMzQixTQUFPLFNBQVU7QUFDckI7QUFDTyxTQUFTLFdBQVcsUUFBUTtBQUMvQixNQUFNLFFBQVEsT0FBTyxXQUFXLEdBQUcsSUFBSSxJQUFJLEdBQ3JDLE1BQU0sT0FBTyxTQUFTLEdBQUcsSUFBSSxPQUFPLFNBQVMsSUFBSSxPQUFPO0FBQzlELFNBQU8sT0FBTyxNQUFNLE9BQU8sR0FBRztBQUNsQztBQUNPLFNBQVNGLG9CQUFtQixLQUFLLE1BQU07QUFDMUMsTUFBTSxlQUFlLElBQUksU0FBUyxFQUFFLE1BQU0sR0FBRyxFQUFFLENBQUMsS0FBSyxJQUFJLFFBQ25ELGFBQWEsS0FBSyxTQUFTLEdBQzdCLGdCQUFnQixXQUFXLE1BQU0sR0FBRyxFQUFFLENBQUMsS0FBSyxJQUFJO0FBQ3BELE1BQUksaUJBQWlCLEtBQUssV0FBVyxLQUFLLFVBQVUsR0FBRztBQUNuRCxRQUFNLFFBQVEsV0FBVyxNQUFNLFlBQVk7QUFDM0MsSUFBSSxRQUFRLENBQUMsTUFDVCxlQUFlLE9BQU8sU0FBUyxNQUFNLENBQUMsQ0FBQztBQUFBLEVBRS9DO0FBQ0EsTUFBTSxXQUFXLGNBQWMsZUFBZSxjQUFjLGNBQ3RELFNBQVMsT0FBTyxTQUFTLElBQUksUUFBUSxRQUFRLEVBQUUsUUFBUSxLQUFLLEVBQUUsQ0FBQyxHQUMvRCxVQUFVLE9BQU8sU0FBUyxLQUFLLFFBQVEsUUFBUSxFQUFFLFFBQVEsS0FBSyxFQUFFLENBQUM7QUFDdkUsU0FBUSxTQUFTLFVBQVcsTUFBTTtBQUN0QztBQUNBLElBQU0sYUFBYSxPQUFPLFlBQVk7QUFDL0IsU0FBUyxXQUFXRyxTQUFRLEtBQUssUUFBUTtBQUM1QyxNQUFJO0FBQ0osU0FBTyxlQUFlQSxTQUFRLEtBQUs7QUFBQSxJQUMvQixNQUFNO0FBQ0YsVUFBSSxVQUFVO0FBSWQsZUFBSSxVQUFVLFdBQ1YsUUFBUSxZQUNSLFFBQVEsT0FBTyxJQUVaO0FBQUEsSUFDWDtBQUFBLElBQ0EsSUFBSSxHQUFHO0FBQ0gsYUFBTyxlQUFlQSxTQUFRLEtBQUs7QUFBQSxRQUMvQixPQUFPO0FBQUE7QUFBQSxNQUVYLENBQUM7QUFBQSxJQUVMO0FBQUEsSUFDQSxjQUFjO0FBQUEsRUFDbEIsQ0FBQztBQUNMO0FBQ08sU0FBUyxZQUFZLEtBQUs7QUFDN0IsU0FBTyxPQUFPLE9BQU8sT0FBTyxlQUFlLEdBQUcsR0FBRyxPQUFPLDBCQUEwQixHQUFHLENBQUM7QUFDMUY7QUFDTyxTQUFTLFdBQVcsUUFBUSxNQUFNLE9BQU87QUFDNUMsU0FBTyxlQUFlLFFBQVEsTUFBTTtBQUFBLElBQ2hDO0FBQUEsSUFDQSxVQUFVO0FBQUEsSUFDVixZQUFZO0FBQUEsSUFDWixjQUFjO0FBQUEsRUFDbEIsQ0FBQztBQUNMO0FBQ08sU0FBUyxhQUFhLE1BQU07QUFDL0IsTUFBTSxvQkFBb0IsQ0FBQztBQUMzQixXQUFXLE9BQU8sTUFBTTtBQUNwQixRQUFNLGNBQWMsT0FBTywwQkFBMEIsR0FBRztBQUN4RCxXQUFPLE9BQU8sbUJBQW1CLFdBQVc7QUFBQSxFQUNoRDtBQUNBLFNBQU8sT0FBTyxpQkFBaUIsQ0FBQyxHQUFHLGlCQUFpQjtBQUN4RDtBQUNPLFNBQVMsU0FBUyxRQUFRO0FBQzdCLFNBQU8sVUFBVSxPQUFPLEtBQUssR0FBRztBQUNwQztBQUNPLFNBQVMsaUJBQWlCLEtBQUssTUFBTTtBQUN4QyxTQUFLLE9BRUUsS0FBSyxPQUFPLENBQUMsS0FBSyxRQUFRLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFEckM7QUFFZjtBQUNPLFNBQVMsaUJBQWlCLGFBQWE7QUFDMUMsTUFBTSxPQUFPLE9BQU8sS0FBSyxXQUFXLEdBQzlCLFdBQVcsS0FBSyxJQUFJLENBQUMsUUFBUSxZQUFZLEdBQUcsQ0FBQztBQUNuRCxTQUFPLFFBQVEsSUFBSSxRQUFRLEVBQUUsS0FBSyxDQUFDLFlBQVk7QUFDM0MsUUFBTSxjQUFjLENBQUM7QUFDckIsYUFBUyxJQUFJLEdBQUcsSUFBSSxLQUFLLFFBQVE7QUFDN0Isa0JBQVksS0FBSyxDQUFDLENBQUMsSUFBSSxRQUFRLENBQUM7QUFFcEMsV0FBTztBQUFBLEVBQ1gsQ0FBQztBQUNMO0FBQ08sU0FBUyxhQUFhLFNBQVMsSUFBSTtBQUN0QyxNQUFNLFFBQVEsOEJBQ1YsTUFBTTtBQUNWLFdBQVMsSUFBSSxHQUFHLElBQUksUUFBUTtBQUN4QixXQUFPLE1BQU0sS0FBSyxNQUFNLEtBQUssT0FBTyxJQUFJLE1BQU0sTUFBTSxDQUFDO0FBRXpELFNBQU87QUFDWDtBQUNPLFNBQVMsSUFBSSxLQUFLO0FBQ3JCLFNBQU8sS0FBSyxVQUFVLEdBQUc7QUFDN0I7QUFDTyxTQUFTLFFBQVEsT0FBTztBQUMzQixTQUFPLE1BQ0YsWUFBWSxFQUNaLEtBQUssRUFDTCxRQUFRLGFBQWEsRUFBRSxFQUN2QixRQUFRLFlBQVksR0FBRyxFQUN2QixRQUFRLFlBQVksRUFBRTtBQUMvQjtBQUNPLElBQU0sb0JBQXFCLHVCQUF1QixRQUFRLE1BQU0sb0JBQW9CLElBQUksVUFBVTtBQUFFO0FBQ3BHLFNBQVMsU0FBUyxNQUFNO0FBQzNCLFNBQU8sT0FBTyxRQUFTLFlBQVksU0FBUyxRQUFRLENBQUMsTUFBTSxRQUFRLElBQUk7QUFDM0U7QUFDTyxJQUFNLGFBQWEsT0FBTyxNQUFNO0FBRW5DLE1BQUksT0FBTyxZQUFjLE9BQWUsV0FBVyxXQUFXLFNBQVMsWUFBWTtBQUMvRSxXQUFPO0FBRVgsTUFBSTtBQUNBLFFBQU0sSUFBSTtBQUNWLGVBQUksRUFBRSxFQUFFLEdBQ0Q7QUFBQSxFQUNYLFFBQ1U7QUFDTixXQUFPO0FBQUEsRUFDWDtBQUNKLENBQUM7QUFDTSxTQUFTLGNBQWMsR0FBRztBQUM3QixNQUFJLFNBQVMsQ0FBQyxNQUFNO0FBQ2hCLFdBQU87QUFFWCxNQUFNLE9BQU8sRUFBRTtBQUdmLE1BRkksU0FBUyxVQUVULE9BQU8sUUFBUztBQUNoQixXQUFPO0FBRVgsTUFBTSxPQUFPLEtBQUs7QUFJbEIsU0FISSxXQUFTLElBQUksTUFBTSxNQUduQixPQUFPLFVBQVUsZUFBZSxLQUFLLE1BQU0sZUFBZSxNQUFNO0FBSXhFO0FBQ08sU0FBUyxhQUFhLEdBQUc7QUFDNUIsU0FBSSxjQUFjLENBQUMsSUFDUixFQUFFLEdBQUcsRUFBRSxJQUNkLE1BQU0sUUFBUSxDQUFDLElBQ1IsQ0FBQyxHQUFHLENBQUMsSUFDVDtBQUNYO0FBQ08sU0FBUyxRQUFRLE1BQU07QUFDMUIsTUFBSSxXQUFXO0FBQ2YsV0FBVyxPQUFPO0FBQ2QsSUFBSSxPQUFPLFVBQVUsZUFBZSxLQUFLLE1BQU0sR0FBRyxLQUM5QztBQUdSLFNBQU87QUFDWDtBQUNPLElBQU1GLGlCQUFnQixDQUFDLFNBQVM7QUFDbkMsTUFBTSxJQUFJLE9BQU87QUFDakIsVUFBUSxHQUFHO0FBQUEsSUFDUCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPLE9BQU8sTUFBTSxJQUFJLElBQUksUUFBUTtBQUFBLElBQ3hDLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBTztBQUFBLElBQ1gsS0FBSztBQUNELGFBQU87QUFBQSxJQUNYLEtBQUs7QUFDRCxhQUFPO0FBQUEsSUFDWCxLQUFLO0FBQ0QsYUFBSSxNQUFNLFFBQVEsSUFBSSxJQUNYLFVBRVAsU0FBUyxPQUNGLFNBRVAsS0FBSyxRQUFRLE9BQU8sS0FBSyxRQUFTLGNBQWMsS0FBSyxTQUFTLE9BQU8sS0FBSyxTQUFVLGFBQzdFLFlBRVAsT0FBTyxNQUFRLE9BQWUsZ0JBQWdCLE1BQ3ZDLFFBRVAsT0FBTyxNQUFRLE9BQWUsZ0JBQWdCLE1BQ3ZDLFFBRVAsT0FBTyxPQUFTLE9BQWUsZ0JBQWdCLE9BQ3hDLFNBR1AsT0FBTyxPQUFTLE9BQWUsZ0JBQWdCLE9BQ3hDLFNBRUo7QUFBQSxJQUNYO0FBQ0ksWUFBTSxJQUFJLE1BQU0sc0JBQXNCLENBQUMsRUFBRTtBQUFBLEVBQ2pEO0FBQ0osR0FDYSxtQkFBbUIsb0JBQUksSUFBSSxDQUFDLFVBQVUsVUFBVSxRQUFRLENBQUMsR0FDekQsaUJBQWlCLG9CQUFJLElBQUksQ0FBQyxVQUFVLFVBQVUsVUFBVSxXQUFXLFVBQVUsV0FBVyxDQUFDO0FBQy9GLFNBQVMsWUFBWSxLQUFLO0FBQzdCLFNBQU8sSUFBSSxRQUFRLHVCQUF1QixNQUFNO0FBQ3BEO0FBRU8sU0FBUyxNQUFNLE1BQU0sS0FBSyxRQUFRO0FBQ3JDLE1BQU0sS0FBSyxJQUFJLEtBQUssS0FBSyxPQUFPLE9BQU8sS0FBSyxLQUFLLEdBQUc7QUFDcEQsVUFBSSxDQUFDLE9BQU8sUUFBUSxZQUNoQixHQUFHLEtBQUssU0FBUyxPQUNkO0FBQ1g7QUFDTyxTQUFTLGdCQUFnQixTQUFTO0FBQ3JDLE1BQU0sU0FBUztBQUNmLE1BQUksQ0FBQztBQUNELFdBQU8sQ0FBQztBQUNaLE1BQUksT0FBTyxVQUFXO0FBQ2xCLFdBQU8sRUFBRSxPQUFPLE1BQU0sT0FBTztBQUNqQyxNQUFJLFFBQVEsWUFBWSxRQUFXO0FBQy9CLFFBQUksUUFBUSxVQUFVO0FBQ2xCLFlBQU0sSUFBSSxNQUFNLGtEQUFrRDtBQUN0RSxXQUFPLFFBQVEsT0FBTztBQUFBLEVBQzFCO0FBRUEsU0FEQSxPQUFPLE9BQU8sU0FDVixPQUFPLE9BQU8sU0FBVSxXQUNqQixFQUFFLEdBQUcsUUFBUSxPQUFPLE1BQU0sT0FBTyxNQUFNLElBQzNDO0FBQ1g7QUFDTyxTQUFTLHVCQUF1QixRQUFRO0FBQzNDLE1BQUk7QUFDSixTQUFPLElBQUksTUFBTSxDQUFDLEdBQUc7QUFBQSxJQUNqQixJQUFJLEdBQUcsTUFBTSxVQUFVO0FBQ25CLHdCQUFXLFNBQVMsT0FBTyxJQUNwQixRQUFRLElBQUksUUFBUSxNQUFNLFFBQVE7QUFBQSxJQUM3QztBQUFBLElBQ0EsSUFBSSxHQUFHLE1BQU0sT0FBTyxVQUFVO0FBQzFCLHdCQUFXLFNBQVMsT0FBTyxJQUNwQixRQUFRLElBQUksUUFBUSxNQUFNLE9BQU8sUUFBUTtBQUFBLElBQ3BEO0FBQUEsSUFDQSxJQUFJLEdBQUcsTUFBTTtBQUNULHdCQUFXLFNBQVMsT0FBTyxJQUNwQixRQUFRLElBQUksUUFBUSxJQUFJO0FBQUEsSUFDbkM7QUFBQSxJQUNBLGVBQWUsR0FBRyxNQUFNO0FBQ3BCLHdCQUFXLFNBQVMsT0FBTyxJQUNwQixRQUFRLGVBQWUsUUFBUSxJQUFJO0FBQUEsSUFDOUM7QUFBQSxJQUNBLFFBQVEsR0FBRztBQUNQLHdCQUFXLFNBQVMsT0FBTyxJQUNwQixRQUFRLFFBQVEsTUFBTTtBQUFBLElBQ2pDO0FBQUEsSUFDQSx5QkFBeUIsR0FBRyxNQUFNO0FBQzlCLHdCQUFXLFNBQVMsT0FBTyxJQUNwQixRQUFRLHlCQUF5QixRQUFRLElBQUk7QUFBQSxJQUN4RDtBQUFBLElBQ0EsZUFBZSxHQUFHLE1BQU0sWUFBWTtBQUNoQyx3QkFBVyxTQUFTLE9BQU8sSUFDcEIsUUFBUSxlQUFlLFFBQVEsTUFBTSxVQUFVO0FBQUEsSUFDMUQ7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUNPLFNBQVMsbUJBQW1CLE9BQU87QUFDdEMsU0FBSSxPQUFPLFNBQVUsV0FDVixNQUFNLFNBQVMsSUFBSSxNQUMxQixPQUFPLFNBQVUsV0FDVixJQUFJLEtBQUssTUFDYixHQUFHLEtBQUs7QUFDbkI7QUFDTyxTQUFTLGFBQWEsT0FBTztBQUNoQyxTQUFPLE9BQU8sS0FBSyxLQUFLLEVBQUUsT0FBTyxDQUFDLE1BQ3ZCLE1BQU0sQ0FBQyxFQUFFLEtBQUssVUFBVSxjQUFjLE1BQU0sQ0FBQyxFQUFFLEtBQUssV0FBVyxVQUN6RTtBQUNMO0FBQ08sSUFBTSx1QkFBdUI7QUFBQSxFQUNoQyxTQUFTLENBQUMsT0FBTyxrQkFBa0IsT0FBTyxnQkFBZ0I7QUFBQSxFQUMxRCxPQUFPLENBQUMsYUFBYSxVQUFVO0FBQUEsRUFDL0IsUUFBUSxDQUFDLEdBQUcsVUFBVTtBQUFBLEVBQ3RCLFNBQVMsQ0FBQyx1QkFBd0Isb0JBQXFCO0FBQUEsRUFDdkQsU0FBUyxDQUFDLENBQUMsT0FBTyxXQUFXLE9BQU8sU0FBUztBQUNqRCxHQUNhLHVCQUF1QjtBQUFBLEVBQ2hDLE9BQU8sQ0FBZ0IsdUJBQU8sc0JBQXNCLEdBQWtCLHVCQUFPLHFCQUFxQixDQUFDO0FBQUEsRUFDbkcsUUFBUSxDQUFnQix1QkFBTyxDQUFDLEdBQWtCLHVCQUFPLHNCQUFzQixDQUFDO0FBQ3BGO0FBQ08sU0FBUyxLQUFLLFFBQVEsTUFBTTtBQUMvQixNQUFNLFVBQVUsT0FBTyxLQUFLLEtBQ3RCLFNBQVMsUUFBUTtBQUV2QixNQURrQixVQUFVLE9BQU8sU0FBUztBQUV4QyxVQUFNLElBQUksTUFBTSxpRUFBaUU7QUFFckYsTUFBTSxNQUFNLFVBQVUsT0FBTyxLQUFLLEtBQUs7QUFBQSxJQUNuQyxJQUFJLFFBQVE7QUFDUixVQUFNLFdBQVcsQ0FBQztBQUNsQixlQUFXLE9BQU8sTUFBTTtBQUNwQixZQUFJLEVBQUUsT0FBTyxRQUFRO0FBQ2pCLGdCQUFNLElBQUksTUFBTSxzQkFBc0IsR0FBRyxHQUFHO0FBRWhELFFBQUssS0FBSyxHQUFHLE1BRWIsU0FBUyxHQUFHLElBQUksUUFBUSxNQUFNLEdBQUc7QUFBQSxNQUNyQztBQUNBLHdCQUFXLE1BQU0sU0FBUyxRQUFRLEdBQzNCO0FBQUEsSUFDWDtBQUFBLElBQ0EsUUFBUSxDQUFDO0FBQUEsRUFDYixDQUFDO0FBQ0QsU0FBTyxNQUFNLFFBQVEsR0FBRztBQUM1QjtBQUNPLFNBQVMsS0FBSyxRQUFRLE1BQU07QUFDL0IsTUFBTSxVQUFVLE9BQU8sS0FBSyxLQUN0QixTQUFTLFFBQVE7QUFFdkIsTUFEa0IsVUFBVSxPQUFPLFNBQVM7QUFFeEMsVUFBTSxJQUFJLE1BQU0saUVBQWlFO0FBRXJGLE1BQU0sTUFBTSxVQUFVLE9BQU8sS0FBSyxLQUFLO0FBQUEsSUFDbkMsSUFBSSxRQUFRO0FBQ1IsVUFBTSxXQUFXLEVBQUUsR0FBRyxPQUFPLEtBQUssSUFBSSxNQUFNO0FBQzVDLGVBQVcsT0FBTyxNQUFNO0FBQ3BCLFlBQUksRUFBRSxPQUFPLFFBQVE7QUFDakIsZ0JBQU0sSUFBSSxNQUFNLHNCQUFzQixHQUFHLEdBQUc7QUFFaEQsUUFBSyxLQUFLLEdBQUcsS0FFYixPQUFPLFNBQVMsR0FBRztBQUFBLE1BQ3ZCO0FBQ0Esd0JBQVcsTUFBTSxTQUFTLFFBQVEsR0FDM0I7QUFBQSxJQUNYO0FBQUEsSUFDQSxRQUFRLENBQUM7QUFBQSxFQUNiLENBQUM7QUFDRCxTQUFPLE1BQU0sUUFBUSxHQUFHO0FBQzVCO0FBQ08sU0FBUyxPQUFPLFFBQVEsT0FBTztBQUNsQyxNQUFJLENBQUMsY0FBYyxLQUFLO0FBQ3BCLFVBQU0sSUFBSSxNQUFNLGtEQUFrRDtBQUV0RSxNQUFNLFNBQVMsT0FBTyxLQUFLLElBQUk7QUFFL0IsTUFEa0IsVUFBVSxPQUFPLFNBQVMsR0FDN0I7QUFHWCxRQUFNLGdCQUFnQixPQUFPLEtBQUssSUFBSTtBQUN0QyxhQUFXLE9BQU87QUFDZCxVQUFJLE9BQU8seUJBQXlCLGVBQWUsR0FBRyxNQUFNO0FBQ3hELGNBQU0sSUFBSSxNQUFNLDhGQUE4RjtBQUFBLEVBRzFIO0FBQ0EsTUFBTSxNQUFNLFVBQVUsT0FBTyxLQUFLLEtBQUs7QUFBQSxJQUNuQyxJQUFJLFFBQVE7QUFDUixVQUFNLFNBQVMsRUFBRSxHQUFHLE9BQU8sS0FBSyxJQUFJLE9BQU8sR0FBRyxNQUFNO0FBQ3BELHdCQUFXLE1BQU0sU0FBUyxNQUFNLEdBQ3pCO0FBQUEsSUFDWDtBQUFBLEVBQ0osQ0FBQztBQUNELFNBQU8sTUFBTSxRQUFRLEdBQUc7QUFDNUI7QUFDTyxTQUFTLFdBQVcsUUFBUSxPQUFPO0FBQ3RDLE1BQUksQ0FBQyxjQUFjLEtBQUs7QUFDcEIsVUFBTSxJQUFJLE1BQU0sc0RBQXNEO0FBRTFFLE1BQU0sTUFBTSxVQUFVLE9BQU8sS0FBSyxLQUFLO0FBQUEsSUFDbkMsSUFBSSxRQUFRO0FBQ1IsVUFBTSxTQUFTLEVBQUUsR0FBRyxPQUFPLEtBQUssSUFBSSxPQUFPLEdBQUcsTUFBTTtBQUNwRCx3QkFBVyxNQUFNLFNBQVMsTUFBTSxHQUN6QjtBQUFBLElBQ1g7QUFBQSxFQUNKLENBQUM7QUFDRCxTQUFPLE1BQU0sUUFBUSxHQUFHO0FBQzVCO0FBQ08sU0FBUyxNQUFNLEdBQUcsR0FBRztBQUN4QixNQUFNLE1BQU0sVUFBVSxFQUFFLEtBQUssS0FBSztBQUFBLElBQzlCLElBQUksUUFBUTtBQUNSLFVBQU0sU0FBUyxFQUFFLEdBQUcsRUFBRSxLQUFLLElBQUksT0FBTyxHQUFHLEVBQUUsS0FBSyxJQUFJLE1BQU07QUFDMUQsd0JBQVcsTUFBTSxTQUFTLE1BQU0sR0FDekI7QUFBQSxJQUNYO0FBQUEsSUFDQSxJQUFJLFdBQVc7QUFDWCxhQUFPLEVBQUUsS0FBSyxJQUFJO0FBQUEsSUFDdEI7QUFBQSxJQUNBLFFBQVEsQ0FBQztBQUFBO0FBQUEsRUFDYixDQUFDO0FBQ0QsU0FBTyxNQUFNLEdBQUcsR0FBRztBQUN2QjtBQUNPLFNBQVMsUUFBUUcsUUFBTyxRQUFRLE1BQU07QUFFekMsTUFBTSxTQURVLE9BQU8sS0FBSyxJQUNMO0FBRXZCLE1BRGtCLFVBQVUsT0FBTyxTQUFTO0FBRXhDLFVBQU0sSUFBSSxNQUFNLG9FQUFvRTtBQUV4RixNQUFNLE1BQU0sVUFBVSxPQUFPLEtBQUssS0FBSztBQUFBLElBQ25DLElBQUksUUFBUTtBQUNSLFVBQU0sV0FBVyxPQUFPLEtBQUssSUFBSSxPQUMzQixRQUFRLEVBQUUsR0FBRyxTQUFTO0FBQzVCLFVBQUk7QUFDQSxpQkFBVyxPQUFPLE1BQU07QUFDcEIsY0FBSSxFQUFFLE9BQU87QUFDVCxrQkFBTSxJQUFJLE1BQU0sc0JBQXNCLEdBQUcsR0FBRztBQUVoRCxVQUFLLEtBQUssR0FBRyxNQUdiLE1BQU0sR0FBRyxJQUFJQSxTQUNQLElBQUlBLE9BQU07QUFBQSxZQUNSLE1BQU07QUFBQSxZQUNOLFdBQVcsU0FBUyxHQUFHO0FBQUEsVUFDM0IsQ0FBQyxJQUNDLFNBQVMsR0FBRztBQUFBLFFBQ3RCO0FBQUE7QUFHQSxpQkFBVyxPQUFPO0FBRWQsZ0JBQU0sR0FBRyxJQUFJQSxTQUNQLElBQUlBLE9BQU07QUFBQSxZQUNSLE1BQU07QUFBQSxZQUNOLFdBQVcsU0FBUyxHQUFHO0FBQUEsVUFDM0IsQ0FBQyxJQUNDLFNBQVMsR0FBRztBQUcxQix3QkFBVyxNQUFNLFNBQVMsS0FBSyxHQUN4QjtBQUFBLElBQ1g7QUFBQSxJQUNBLFFBQVEsQ0FBQztBQUFBLEVBQ2IsQ0FBQztBQUNELFNBQU8sTUFBTSxRQUFRLEdBQUc7QUFDNUI7QUFDTyxTQUFTLFNBQVNBLFFBQU8sUUFBUSxNQUFNO0FBQzFDLE1BQU0sTUFBTSxVQUFVLE9BQU8sS0FBSyxLQUFLO0FBQUEsSUFDbkMsSUFBSSxRQUFRO0FBQ1IsVUFBTSxXQUFXLE9BQU8sS0FBSyxJQUFJLE9BQzNCLFFBQVEsRUFBRSxHQUFHLFNBQVM7QUFDNUIsVUFBSTtBQUNBLGlCQUFXLE9BQU8sTUFBTTtBQUNwQixjQUFJLEVBQUUsT0FBTztBQUNULGtCQUFNLElBQUksTUFBTSxzQkFBc0IsR0FBRyxHQUFHO0FBRWhELFVBQUssS0FBSyxHQUFHLE1BR2IsTUFBTSxHQUFHLElBQUksSUFBSUEsT0FBTTtBQUFBLFlBQ25CLE1BQU07QUFBQSxZQUNOLFdBQVcsU0FBUyxHQUFHO0FBQUEsVUFDM0IsQ0FBQztBQUFBLFFBQ0w7QUFBQTtBQUdBLGlCQUFXLE9BQU87QUFFZCxnQkFBTSxHQUFHLElBQUksSUFBSUEsT0FBTTtBQUFBLFlBQ25CLE1BQU07QUFBQSxZQUNOLFdBQVcsU0FBUyxHQUFHO0FBQUEsVUFDM0IsQ0FBQztBQUdULHdCQUFXLE1BQU0sU0FBUyxLQUFLLEdBQ3hCO0FBQUEsSUFDWDtBQUFBLEVBQ0osQ0FBQztBQUNELFNBQU8sTUFBTSxRQUFRLEdBQUc7QUFDNUI7QUFFTyxTQUFTLFFBQVEsR0FBRyxhQUFhLEdBQUc7QUFDdkMsTUFBSSxFQUFFLFlBQVk7QUFDZCxXQUFPO0FBQ1gsV0FBUyxJQUFJLFlBQVksSUFBSSxFQUFFLE9BQU8sUUFBUTtBQUMxQyxRQUFJLEVBQUUsT0FBTyxDQUFDLEdBQUcsYUFBYTtBQUMxQixhQUFPO0FBR2YsU0FBTztBQUNYO0FBQ08sU0FBUyxhQUFhLE1BQU0sUUFBUTtBQUN2QyxTQUFPLE9BQU8sSUFBSSxDQUFDLFFBQVE7QUFDdkIsUUFBSUM7QUFDSixZQUFDQSxNQUFLLEtBQUssU0FBU0EsSUFBRyxPQUFPLENBQUMsSUFDL0IsSUFBSSxLQUFLLFFBQVEsSUFBSSxHQUNkO0FBQUEsRUFDWCxDQUFDO0FBQ0w7QUFDTyxTQUFTLGNBQWMsU0FBUztBQUNuQyxTQUFPLE9BQU8sV0FBWSxXQUFXLFVBQVUsU0FBUztBQUM1RDtBQUNPLFNBQVMsY0FBYyxLQUFLLEtBQUtDLFNBQVE7QUFDNUMsTUFBTSxPQUFPLEVBQUUsR0FBRyxLQUFLLE1BQU0sSUFBSSxRQUFRLENBQUMsRUFBRTtBQUU1QyxNQUFJLENBQUMsSUFBSSxTQUFTO0FBQ2QsUUFBTSxVQUFVLGNBQWMsSUFBSSxNQUFNLEtBQUssS0FBSyxRQUFRLEdBQUcsQ0FBQyxLQUMxRCxjQUFjLEtBQUssUUFBUSxHQUFHLENBQUMsS0FDL0IsY0FBY0EsUUFBTyxjQUFjLEdBQUcsQ0FBQyxLQUN2QyxjQUFjQSxRQUFPLGNBQWMsR0FBRyxDQUFDLEtBQ3ZDO0FBQ0osU0FBSyxVQUFVO0FBQUEsRUFDbkI7QUFFQSxnQkFBTyxLQUFLLE1BQ1osT0FBTyxLQUFLLFVBQ1AsS0FBSyxlQUNOLE9BQU8sS0FBSyxPQUVUO0FBQ1g7QUFDTyxTQUFTLGlCQUFpQixPQUFPO0FBQ3BDLFNBQUksaUJBQWlCLE1BQ1YsUUFDUCxpQkFBaUIsTUFDVixRQUVQLGlCQUFpQixPQUNWLFNBQ0o7QUFDWDtBQUNPLFNBQVMsb0JBQW9CLE9BQU87QUFDdkMsU0FBSSxNQUFNLFFBQVEsS0FBSyxJQUNaLFVBQ1AsT0FBTyxTQUFVLFdBQ1YsV0FDSjtBQUNYO0FBQ08sU0FBUyxXQUFXLE1BQU07QUFDN0IsTUFBTSxJQUFJLE9BQU87QUFDakIsVUFBUSxHQUFHO0FBQUEsSUFDUCxLQUFLO0FBQ0QsYUFBTyxPQUFPLE1BQU0sSUFBSSxJQUFJLFFBQVE7QUFBQSxJQUV4QyxLQUFLLFVBQVU7QUFDWCxVQUFJLFNBQVM7QUFDVCxlQUFPO0FBRVgsVUFBSSxNQUFNLFFBQVEsSUFBSTtBQUNsQixlQUFPO0FBRVgsVUFBTSxNQUFNO0FBQ1osVUFBSSxPQUFPLE9BQU8sZUFBZSxHQUFHLE1BQU0sT0FBTyxhQUFhLGlCQUFpQixPQUFPLElBQUk7QUFDdEYsZUFBTyxJQUFJLFlBQVk7QUFBQSxJQUUvQjtBQUFBLEVBQ0o7QUFDQSxTQUFPO0FBQ1g7QUFDTyxTQUFTLFNBQVMsTUFBTTtBQUMzQixNQUFNLENBQUMsS0FBSyxPQUFPLElBQUksSUFBSTtBQUMzQixTQUFJLE9BQU8sT0FBUSxXQUNSO0FBQUEsSUFDSCxTQUFTO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxFQUNKLElBRUcsRUFBRSxHQUFHLElBQUk7QUFDcEI7QUFDTyxTQUFTLFVBQVUsS0FBSztBQUMzQixTQUFPLE9BQU8sUUFBUSxHQUFHLEVBQ3BCLE9BQU8sQ0FBQyxDQUFDLEdBQUcsQ0FBQyxNQUVQLE9BQU8sTUFBTSxPQUFPLFNBQVMsR0FBRyxFQUFFLENBQUMsQ0FDN0MsRUFDSSxJQUFJLENBQUMsT0FBTyxHQUFHLENBQUMsQ0FBQztBQUMxQjtBQUVPLFNBQVMsbUJBQW1CQyxTQUFRO0FBQ3ZDLE1BQU0sZUFBZSxLQUFLQSxPQUFNLEdBQzFCLFFBQVEsSUFBSSxXQUFXLGFBQWEsTUFBTTtBQUNoRCxXQUFTLElBQUksR0FBRyxJQUFJLGFBQWEsUUFBUTtBQUNyQyxVQUFNLENBQUMsSUFBSSxhQUFhLFdBQVcsQ0FBQztBQUV4QyxTQUFPO0FBQ1g7QUFDTyxTQUFTLG1CQUFtQixPQUFPO0FBQ3RDLE1BQUksZUFBZTtBQUNuQixXQUFTLElBQUksR0FBRyxJQUFJLE1BQU0sUUFBUTtBQUM5QixvQkFBZ0IsT0FBTyxhQUFhLE1BQU0sQ0FBQyxDQUFDO0FBRWhELFNBQU8sS0FBSyxZQUFZO0FBQzVCO0FBQ08sU0FBUyxzQkFBc0JDLFlBQVc7QUFDN0MsTUFBTUQsVUFBU0MsV0FBVSxRQUFRLE1BQU0sR0FBRyxFQUFFLFFBQVEsTUFBTSxHQUFHLEdBQ3ZELFVBQVUsSUFBSSxRQUFRLElBQUtELFFBQU8sU0FBUyxLQUFNLENBQUM7QUFDeEQsU0FBTyxtQkFBbUJBLFVBQVMsT0FBTztBQUM5QztBQUNPLFNBQVMsc0JBQXNCLE9BQU87QUFDekMsU0FBTyxtQkFBbUIsS0FBSyxFQUFFLFFBQVEsT0FBTyxHQUFHLEVBQUUsUUFBUSxPQUFPLEdBQUcsRUFBRSxRQUFRLE1BQU0sRUFBRTtBQUM3RjtBQUNPLFNBQVMsZ0JBQWdCRSxNQUFLO0FBQ2pDLE1BQU0sV0FBV0EsS0FBSSxRQUFRLE9BQU8sRUFBRTtBQUN0QyxNQUFJLFNBQVMsU0FBUyxNQUFNO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLDJCQUEyQjtBQUUvQyxNQUFNLFFBQVEsSUFBSSxXQUFXLFNBQVMsU0FBUyxDQUFDO0FBQ2hELFdBQVMsSUFBSSxHQUFHLElBQUksU0FBUyxRQUFRLEtBQUs7QUFDdEMsVUFBTSxJQUFJLENBQUMsSUFBSSxPQUFPLFNBQVMsU0FBUyxNQUFNLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRTtBQUUvRCxTQUFPO0FBQ1g7QUFDTyxTQUFTLGdCQUFnQixPQUFPO0FBQ25DLFNBQU8sTUFBTSxLQUFLLEtBQUssRUFDbEIsSUFBSSxDQUFDLE1BQU0sRUFBRSxTQUFTLEVBQUUsRUFBRSxTQUFTLEdBQUcsR0FBRyxDQUFDLEVBQzFDLEtBQUssRUFBRTtBQUNoQjtBQUVPLElBQU0sUUFBTixNQUFZO0FBQUEsRUFDZixlQUFlLE9BQU87QUFBQSxFQUFFO0FBQzVCOzs7QUN4b0JBLElBQU0sY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUMvQixPQUFLLE9BQU8sYUFDWixPQUFPLGVBQWUsTUFBTSxRQUFRO0FBQUEsSUFDaEMsT0FBTyxLQUFLO0FBQUEsSUFDWixZQUFZO0FBQUEsRUFDaEIsQ0FBQyxHQUNELE9BQU8sZUFBZSxNQUFNLFVBQVU7QUFBQSxJQUNsQyxPQUFPO0FBQUEsSUFDUCxZQUFZO0FBQUEsRUFDaEIsQ0FBQyxHQUNELEtBQUssVUFBVSxLQUFLLFVBQVUsS0FBVSx1QkFBdUIsQ0FBQyxHQUNoRSxPQUFPLGVBQWUsTUFBTSxZQUFZO0FBQUEsSUFDcEMsT0FBTyxNQUFNLEtBQUs7QUFBQSxJQUNsQixZQUFZO0FBQUEsRUFDaEIsQ0FBQztBQUNMLEdBQ2EsWUFBWSxhQUFhLGFBQWEsV0FBVyxHQUNqRCxnQkFBZ0IsYUFBYSxhQUFhLGFBQWEsRUFBRSxRQUFRLE1BQU0sQ0FBQztBQUM5RSxTQUFTLGFBQWFDLFFBQU8sU0FBUyxDQUFDQyxXQUFVQSxPQUFNLFNBQVM7QUFDbkUsTUFBTSxjQUFjLENBQUMsR0FDZixhQUFhLENBQUM7QUFDcEIsV0FBVyxPQUFPRCxPQUFNO0FBQ3BCLElBQUksSUFBSSxLQUFLLFNBQVMsS0FDbEIsWUFBWSxJQUFJLEtBQUssQ0FBQyxDQUFDLElBQUksWUFBWSxJQUFJLEtBQUssQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUN4RCxZQUFZLElBQUksS0FBSyxDQUFDLENBQUMsRUFBRSxLQUFLLE9BQU8sR0FBRyxDQUFDLEtBR3pDLFdBQVcsS0FBSyxPQUFPLEdBQUcsQ0FBQztBQUduQyxTQUFPLEVBQUUsWUFBWSxZQUFZO0FBQ3JDO0FBQ08sU0FBUyxZQUFZQSxRQUFPLFNBQVMsQ0FBQ0MsV0FBVUEsT0FBTSxTQUFTO0FBQ2xFLE1BQU0sY0FBYyxFQUFFLFNBQVMsQ0FBQyxFQUFFLEdBQzVCLGVBQWUsQ0FBQ0QsV0FBVTtBQUM1QixhQUFXQyxVQUFTRCxPQUFNO0FBQ3RCLFVBQUlDLE9BQU0sU0FBUyxtQkFBbUJBLE9BQU0sT0FBTztBQUMvQyxRQUFBQSxPQUFNLE9BQU8sSUFBSSxDQUFDLFdBQVcsYUFBYSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0FBQUEsZUFFaERBLE9BQU0sU0FBUztBQUNwQixxQkFBYSxFQUFFLFFBQVFBLE9BQU0sT0FBTyxDQUFDO0FBQUEsZUFFaENBLE9BQU0sU0FBUztBQUNwQixxQkFBYSxFQUFFLFFBQVFBLE9BQU0sT0FBTyxDQUFDO0FBQUEsZUFFaENBLE9BQU0sS0FBSyxXQUFXO0FBQzNCLG9CQUFZLFFBQVEsS0FBSyxPQUFPQSxNQUFLLENBQUM7QUFBQSxXQUVyQztBQUNELFlBQUksT0FBTyxhQUNQLElBQUk7QUFDUixlQUFPLElBQUlBLE9BQU0sS0FBSyxVQUFRO0FBQzFCLGNBQU0sS0FBS0EsT0FBTSxLQUFLLENBQUM7QUFFdkIsVUFEaUIsTUFBTUEsT0FBTSxLQUFLLFNBQVMsS0FLdkMsS0FBSyxFQUFFLElBQUksS0FBSyxFQUFFLEtBQUssRUFBRSxTQUFTLENBQUMsRUFBRSxHQUNyQyxLQUFLLEVBQUUsRUFBRSxRQUFRLEtBQUssT0FBT0EsTUFBSyxDQUFDLEtBSm5DLEtBQUssRUFBRSxJQUFJLEtBQUssRUFBRSxLQUFLLEVBQUUsU0FBUyxDQUFDLEVBQUUsR0FNekMsT0FBTyxLQUFLLEVBQUUsR0FDZDtBQUFBLFFBQ0o7QUFBQSxNQUNKO0FBQUEsRUFFUjtBQUNBLHNCQUFhRCxNQUFLLEdBQ1g7QUFDWDs7O0FDcEVPLElBQU0sU0FBUyxDQUFDLFNBQVMsQ0FBQyxRQUFRLE9BQU8sTUFBTSxZQUFZO0FBQzlELE1BQU0sTUFBTSxPQUFPLE9BQU8sT0FBTyxNQUFNLEVBQUUsT0FBTyxHQUFNLENBQUMsSUFBSSxFQUFFLE9BQU8sR0FBTSxHQUNwRSxTQUFTLE9BQU8sS0FBSyxJQUFJLEVBQUUsT0FBTyxRQUFRLENBQUMsRUFBRSxHQUFHLEdBQUc7QUFDekQsTUFBSSxrQkFBa0I7QUFDbEIsVUFBTSxJQUFTLGVBQWU7QUFFbEMsTUFBSSxPQUFPLE9BQU8sUUFBUTtBQUN0QixRQUFNLElBQUksS0FBSyxTQUFTLE9BQU8sTUFBTSxPQUFPLE9BQU8sSUFBSSxDQUFDLFFBQWEsY0FBYyxLQUFLLEtBQVUsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUM1RyxVQUFLLGtCQUFrQixHQUFHLFNBQVMsTUFBTSxHQUNuQztBQUFBLEVBQ1Y7QUFDQSxTQUFPLE9BQU87QUFDbEIsR0FDYSxRQUF1Qix1QkFBYyxhQUFhLEdBQ2xELGNBQWMsQ0FBQyxTQUFTLE9BQU8sUUFBUSxPQUFPLE1BQU0sV0FBVztBQUN4RSxNQUFNLE1BQU0sT0FBTyxPQUFPLE9BQU8sTUFBTSxFQUFFLE9BQU8sR0FBSyxDQUFDLElBQUksRUFBRSxPQUFPLEdBQUssR0FDcEUsU0FBUyxPQUFPLEtBQUssSUFBSSxFQUFFLE9BQU8sUUFBUSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBR3ZELE1BRkksa0JBQWtCLFlBQ2xCLFNBQVMsTUFBTSxTQUNmLE9BQU8sT0FBTyxRQUFRO0FBQ3RCLFFBQU0sSUFBSSxLQUFLLFFBQVEsT0FBTyxNQUFNLE9BQU8sT0FBTyxJQUFJLENBQUMsUUFBYSxjQUFjLEtBQUssS0FBVSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQzNHLFVBQUssa0JBQWtCLEdBQUcsUUFBUSxNQUFNLEdBQ2xDO0FBQUEsRUFDVjtBQUNBLFNBQU8sT0FBTztBQUNsQixHQUNhLGFBQTRCLDRCQUFtQixhQUFhLEdBQzVELGFBQWEsQ0FBQyxTQUFTLENBQUMsUUFBUSxPQUFPLFNBQVM7QUFDekQsTUFBTSxNQUFNLE9BQU8sRUFBRSxHQUFHLE1BQU0sT0FBTyxHQUFNLElBQUksRUFBRSxPQUFPLEdBQU0sR0FDeEQsU0FBUyxPQUFPLEtBQUssSUFBSSxFQUFFLE9BQU8sUUFBUSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBQ3pELE1BQUksa0JBQWtCO0FBQ2xCLFVBQU0sSUFBUyxlQUFlO0FBRWxDLFNBQU8sT0FBTyxPQUFPLFNBQ2Y7QUFBQSxJQUNFLFNBQVM7QUFBQSxJQUNULE9BQU8sS0FBSyxRQUFlLFdBQVcsT0FBTyxPQUFPLElBQUksQ0FBQyxRQUFhLGNBQWMsS0FBSyxLQUFVLE9BQU8sQ0FBQyxDQUFDLENBQUM7QUFBQSxFQUNqSCxJQUNFLEVBQUUsU0FBUyxJQUFNLE1BQU0sT0FBTyxNQUFNO0FBQzlDLEdBQ2EsWUFBMkIsMkJBQWtCLGFBQWEsR0FDMUQsa0JBQWtCLENBQUMsU0FBUyxPQUFPLFFBQVEsT0FBTyxTQUFTO0FBQ3BFLE1BQU0sTUFBTSxPQUFPLE9BQU8sT0FBTyxNQUFNLEVBQUUsT0FBTyxHQUFLLENBQUMsSUFBSSxFQUFFLE9BQU8sR0FBSyxHQUNwRSxTQUFTLE9BQU8sS0FBSyxJQUFJLEVBQUUsT0FBTyxRQUFRLENBQUMsRUFBRSxHQUFHLEdBQUc7QUFDdkQsU0FBSSxrQkFBa0IsWUFDbEIsU0FBUyxNQUFNLFNBQ1osT0FBTyxPQUFPLFNBQ2Y7QUFBQSxJQUNFLFNBQVM7QUFBQSxJQUNULE9BQU8sSUFBSSxLQUFLLE9BQU8sT0FBTyxJQUFJLENBQUMsUUFBYSxjQUFjLEtBQUssS0FBVSxPQUFPLENBQUMsQ0FBQyxDQUFDO0FBQUEsRUFDM0YsSUFDRSxFQUFFLFNBQVMsSUFBTSxNQUFNLE9BQU8sTUFBTTtBQUM5QyxHQUNhLGlCQUFnQyxnQ0FBdUIsYUFBYSxHQUNwRSxVQUFVLENBQUMsU0FBUyxDQUFDLFFBQVEsT0FBTyxTQUFTO0FBQ3RELE1BQU0sTUFBTSxPQUFPLE9BQU8sT0FBTyxNQUFNLEVBQUUsV0FBVyxXQUFXLENBQUMsSUFBSSxFQUFFLFdBQVcsV0FBVztBQUM1RixTQUFPLE9BQU8sSUFBSSxFQUFFLFFBQVEsT0FBTyxHQUFHO0FBQzFDO0FBRU8sSUFBTSxVQUFVLENBQUMsU0FBUyxDQUFDLFFBQVEsT0FBTyxTQUN0QyxPQUFPLElBQUksRUFBRSxRQUFRLE9BQU8sSUFBSTtBQUdwQyxJQUFNLGVBQWUsQ0FBQyxTQUFTLE9BQU8sUUFBUSxPQUFPLFNBQVM7QUFDakUsTUFBTSxNQUFNLE9BQU8sT0FBTyxPQUFPLE1BQU0sRUFBRSxXQUFXLFdBQVcsQ0FBQyxJQUFJLEVBQUUsV0FBVyxXQUFXO0FBQzVGLFNBQU8sWUFBWSxJQUFJLEVBQUUsUUFBUSxPQUFPLEdBQUc7QUFDL0M7QUFFTyxJQUFNLGVBQWUsQ0FBQyxTQUFTLE9BQU8sUUFBUSxPQUFPLFNBQ2pELFlBQVksSUFBSSxFQUFFLFFBQVEsT0FBTyxJQUFJO0FBR3pDLElBQU0sY0FBYyxDQUFDLFNBQVMsQ0FBQyxRQUFRLE9BQU8sU0FBUztBQUMxRCxNQUFNLE1BQU0sT0FBTyxPQUFPLE9BQU8sTUFBTSxFQUFFLFdBQVcsV0FBVyxDQUFDLElBQUksRUFBRSxXQUFXLFdBQVc7QUFDNUYsU0FBTyxXQUFXLElBQUksRUFBRSxRQUFRLE9BQU8sR0FBRztBQUM5QztBQUVPLElBQU0sY0FBYyxDQUFDLFNBQVMsQ0FBQyxRQUFRLE9BQU8sU0FDMUMsV0FBVyxJQUFJLEVBQUUsUUFBUSxPQUFPLElBQUk7QUFHeEMsSUFBTSxtQkFBbUIsQ0FBQyxTQUFTLE9BQU8sUUFBUSxPQUFPLFNBQVM7QUFDckUsTUFBTSxNQUFNLE9BQU8sT0FBTyxPQUFPLE1BQU0sRUFBRSxXQUFXLFdBQVcsQ0FBQyxJQUFJLEVBQUUsV0FBVyxXQUFXO0FBQzVGLFNBQU8sZ0JBQWdCLElBQUksRUFBRSxRQUFRLE9BQU8sR0FBRztBQUNuRDtBQUVPLElBQU0sbUJBQW1CLENBQUMsU0FBUyxPQUFPLFFBQVEsT0FBTyxTQUNyRCxnQkFBZ0IsSUFBSSxFQUFFLFFBQVEsT0FBTyxJQUFJOzs7QUMxRnBEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ08sSUFBTSxPQUFPLG9CQUNQLFFBQVEsZUFDUixPQUFPLHlDQUNQLE1BQU0scUJBQ04sUUFBUSxxQkFDUixTQUFTLHVCQUVULFdBQVcsaUdBRVgsbUJBQW1CLDRTQUVuQixPQUFPLG1GQUlQLE9BQU8sQ0FBQ0UsYUFDWkEsV0FFRSxJQUFJLE9BQU8sbUNBQW1DQSxRQUFPLHlEQUF5RCxJQUQxRywwS0FHRixRQUFzQixxQkFBSyxDQUFDLEdBQzVCLFFBQXNCLHFCQUFLLENBQUMsR0FDNUIsUUFBc0IscUJBQUssQ0FBQyxHQUU1QixRQUFRLG9HQUVSLGFBQWEsd0lBRWIsZUFBZSwwSkFFZixlQUFlLGtDQUNmLFdBQVcsY0FDWCxlQUFlLHdJQUV0QixTQUFTO0FBQ1IsU0FBUyxRQUFRO0FBQ3BCLFNBQU8sSUFBSSxPQUFPLFFBQVEsR0FBRztBQUNqQztBQUNPLElBQU0sT0FBTyx1SEFDUCxPQUFPLGdZQUNQLE1BQU0sQ0FBQyxjQUFjO0FBQzlCLE1BQU0sZUFBb0IsWUFBWSxhQUFhLEdBQUc7QUFDdEQsU0FBTyxJQUFJLE9BQU8sa0JBQWtCLFlBQVksbUNBQW1DLFlBQVksa0JBQWtCO0FBQ3JILEdBQ2EsU0FBUyw0SUFDVCxTQUFTLGtJQUVULFNBQVMsK0VBQ1QsWUFBWSxvQkFHWixXQUFXLDBIQUNYLFNBQVMsb0VBR1QsT0FBTyxxQkFFZCxhQUFhLHVOQUNOLE9BQXFCLG9CQUFJLE9BQU8sSUFBSSxVQUFVLEdBQUc7QUFDOUQsU0FBUyxXQUFXLE1BQU07QUFDdEIsTUFBTSxPQUFPO0FBUWIsU0FQYyxPQUFPLEtBQUssYUFBYyxXQUNsQyxLQUFLLGNBQWMsS0FDZixHQUFHLElBQUksS0FDUCxLQUFLLGNBQWMsSUFDZixHQUFHLElBQUksY0FDUCxHQUFHLElBQUksbUJBQW1CLEtBQUssU0FBUyxNQUNoRCxHQUFHLElBQUk7QUFFakI7QUFDTyxTQUFTLEtBQUssTUFBTTtBQUN2QixTQUFPLElBQUksT0FBTyxJQUFJLFdBQVcsSUFBSSxDQUFDLEdBQUc7QUFDN0M7QUFFTyxTQUFTLFNBQVMsTUFBTTtBQUMzQixNQUFNQyxRQUFPLFdBQVcsRUFBRSxXQUFXLEtBQUssVUFBVSxDQUFDLEdBQy9DLE9BQU8sQ0FBQyxHQUFHO0FBQ2pCLEVBQUksS0FBSyxTQUNMLEtBQUssS0FBSyxFQUFFLEdBRVosS0FBSyxVQUNMLEtBQUssS0FBSyxtQ0FBbUM7QUFDakQsTUFBTUMsYUFBWSxHQUFHRCxLQUFJLE1BQU0sS0FBSyxLQUFLLEdBQUcsQ0FBQztBQUM3QyxTQUFPLElBQUksT0FBTyxJQUFJLFVBQVUsT0FBT0MsVUFBUyxJQUFJO0FBQ3hEO0FBQ08sSUFBTSxTQUFTLENBQUMsV0FBVztBQUM5QixNQUFNLFFBQVEsU0FBUyxZQUFZLFFBQVEsV0FBVyxDQUFDLElBQUksUUFBUSxXQUFXLEVBQUUsTUFBTTtBQUN0RixTQUFPLElBQUksT0FBTyxJQUFJLEtBQUssR0FBRztBQUNsQyxHQUNhLFNBQVMsYUFDVCxVQUFVLFdBQ1YsU0FBUyxxQkFDVCxVQUFVLHFCQUNqQixRQUFRO0FBRWQsSUFBTSxhQUFhO0FBR1osSUFBTSxZQUFZLGFBRVosWUFBWSxhQUVaLE1BQU07QUFHbkIsU0FBUyxZQUFZLFlBQVksU0FBUztBQUN0QyxTQUFPLElBQUksT0FBTyxrQkFBa0IsVUFBVSxJQUFJLE9BQU8sR0FBRztBQUNoRTtBQUVBLFNBQVMsZUFBZSxRQUFRO0FBQzVCLFNBQU8sSUFBSSxPQUFPLGtCQUFrQixNQUFNLElBQUk7QUFDbEQ7QUFFTyxJQUFNLFVBQVUscUJBQ1YsYUFBMkIsNEJBQVksSUFBSSxJQUFJLEdBQy9DLGdCQUE4QiwrQkFBZSxFQUFFLEdBRS9DLFdBQVcscUJBQ1gsY0FBNEIsNEJBQVksSUFBSSxHQUFHLEdBQy9DLGlCQUErQiwrQkFBZSxFQUFFLEdBRWhELGFBQWEscUJBQ2IsZ0JBQThCLDRCQUFZLElBQUksR0FBRyxHQUNqRCxtQkFBaUMsK0JBQWUsRUFBRSxHQUVsRCxhQUFhLHFCQUNiLGdCQUE4Qiw0QkFBWSxJQUFJLEVBQUUsR0FDaEQsbUJBQWlDLCtCQUFlLEVBQUUsR0FFbEQsYUFBYSxzQkFDYixnQkFBOEIsNEJBQVksSUFBSSxJQUFJLEdBQ2xELG1CQUFpQywrQkFBZSxFQUFFOzs7QUNoSXhELElBQU0sWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLE1BQUlDO0FBQ0osT0FBSyxTQUFTLEtBQUssT0FBTyxDQUFDLElBQzNCLEtBQUssS0FBSyxNQUFNLE1BQ2ZBLE1BQUssS0FBSyxNQUFNLGFBQWFBLElBQUcsV0FBVyxDQUFDO0FBQ2pELENBQUMsR0FDSyxtQkFBbUI7QUFBQSxFQUNyQixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQUEsRUFDUixRQUFRO0FBQ1osR0FDYSxvQkFBa0MsZ0JBQUssYUFBYSxxQkFBcUIsQ0FBQyxNQUFNLFFBQVE7QUFDakcsWUFBVSxLQUFLLE1BQU0sR0FBRztBQUN4QixNQUFNLFNBQVMsaUJBQWlCLE9BQU8sSUFBSSxLQUFLO0FBQ2hELE9BQUssS0FBSyxTQUFTLEtBQUssQ0FBQ0MsVUFBUztBQUM5QixRQUFNLE1BQU1BLE1BQUssS0FBSyxLQUNoQixRQUFRLElBQUksWUFBWSxJQUFJLFVBQVUsSUFBSSxxQkFBcUIsT0FBTztBQUM1RSxJQUFJLElBQUksUUFBUSxTQUNSLElBQUksWUFDSixJQUFJLFVBQVUsSUFBSSxRQUVsQixJQUFJLG1CQUFtQixJQUFJO0FBQUEsRUFFdkMsQ0FBQyxHQUNELEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixLQUFJLElBQUksWUFBWSxRQUFRLFNBQVMsSUFBSSxRQUFRLFFBQVEsUUFBUSxJQUFJLFVBR3JFLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxNQUNBLE1BQU07QUFBQSxNQUNOLFNBQVMsT0FBTyxJQUFJLFNBQVUsV0FBVyxJQUFJLE1BQU0sUUFBUSxJQUFJLElBQUk7QUFBQSxNQUNuRSxPQUFPLFFBQVE7QUFBQSxNQUNmLFdBQVcsSUFBSTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBQ0w7QUFDSixDQUFDLEdBQ1ksdUJBQXFDLGdCQUFLLGFBQWEsd0JBQXdCLENBQUMsTUFBTSxRQUFRO0FBQ3ZHLFlBQVUsS0FBSyxNQUFNLEdBQUc7QUFDeEIsTUFBTSxTQUFTLGlCQUFpQixPQUFPLElBQUksS0FBSztBQUNoRCxPQUFLLEtBQUssU0FBUyxLQUFLLENBQUNBLFVBQVM7QUFDOUIsUUFBTSxNQUFNQSxNQUFLLEtBQUssS0FDaEIsUUFBUSxJQUFJLFlBQVksSUFBSSxVQUFVLElBQUkscUJBQXFCLE9BQU87QUFDNUUsSUFBSSxJQUFJLFFBQVEsU0FDUixJQUFJLFlBQ0osSUFBSSxVQUFVLElBQUksUUFFbEIsSUFBSSxtQkFBbUIsSUFBSTtBQUFBLEVBRXZDLENBQUMsR0FDRCxLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsS0FBSSxJQUFJLFlBQVksUUFBUSxTQUFTLElBQUksUUFBUSxRQUFRLFFBQVEsSUFBSSxVQUdyRSxRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxNQUFNO0FBQUEsTUFDTixTQUFTLE9BQU8sSUFBSSxTQUFVLFdBQVcsSUFBSSxNQUFNLFFBQVEsSUFBSSxJQUFJO0FBQUEsTUFDbkUsT0FBTyxRQUFRO0FBQUEsTUFDZixXQUFXLElBQUk7QUFBQSxNQUNmO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQyxHQUNZLHNCQUNDLGdCQUFLLGFBQWEsdUJBQXVCLENBQUMsTUFBTSxRQUFRO0FBQ2xFLFlBQVUsS0FBSyxNQUFNLEdBQUcsR0FDeEIsS0FBSyxLQUFLLFNBQVMsS0FBSyxDQUFDQSxVQUFTO0FBQzlCLFFBQUlEO0FBQ0osS0FBQ0EsTUFBS0MsTUFBSyxLQUFLLEtBQUssZUFBZUQsSUFBRyxhQUFhLElBQUk7QUFBQSxFQUM1RCxDQUFDLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLFFBQUksT0FBTyxRQUFRLFNBQVUsT0FBTyxJQUFJO0FBQ3BDLFlBQU0sSUFBSSxNQUFNLG9EQUFvRDtBQUl4RSxLQUhtQixPQUFPLFFBQVEsU0FBVSxXQUN0QyxRQUFRLFFBQVEsSUFBSSxVQUFVLE9BQU8sQ0FBQyxJQUNqQ0Usb0JBQW1CLFFBQVEsT0FBTyxJQUFJLEtBQUssTUFBTSxNQUc1RCxRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFFBQVEsT0FBTyxRQUFRO0FBQUEsTUFDdkIsTUFBTTtBQUFBLE1BQ04sU0FBUyxJQUFJO0FBQUEsTUFDYixPQUFPLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQyxHQUNZLHdCQUFzQyxnQkFBSyxhQUFhLHlCQUF5QixDQUFDLE1BQU0sUUFBUTtBQUN6RyxZQUFVLEtBQUssTUFBTSxHQUFHLEdBQ3hCLElBQUksU0FBUyxJQUFJLFVBQVU7QUFDM0IsTUFBTSxRQUFRLElBQUksUUFBUSxTQUFTLEtBQUssR0FDbEMsU0FBUyxRQUFRLFFBQVEsVUFDekIsQ0FBQyxTQUFTLE9BQU8sSUFBUyxxQkFBcUIsSUFBSSxNQUFNO0FBQy9ELE9BQUssS0FBSyxTQUFTLEtBQUssQ0FBQ0QsVUFBUztBQUM5QixRQUFNLE1BQU1BLE1BQUssS0FBSztBQUN0QixRQUFJLFNBQVMsSUFBSSxRQUNqQixJQUFJLFVBQVUsU0FDZCxJQUFJLFVBQVUsU0FDVixVQUNBLElBQUksVUFBa0I7QUFBQSxFQUM5QixDQUFDLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFFBQUksT0FBTztBQUNQLFVBQUksQ0FBQyxPQUFPLFVBQVUsS0FBSyxHQUFHO0FBVTFCLGdCQUFRLE9BQU8sS0FBSztBQUFBLFVBQ2hCLFVBQVU7QUFBQSxVQUNWLFFBQVEsSUFBSTtBQUFBLFVBQ1osTUFBTTtBQUFBLFVBQ04sVUFBVTtBQUFBLFVBQ1Y7QUFBQSxVQUNBO0FBQUEsUUFDSixDQUFDO0FBQ0Q7QUFBQSxNQVNKO0FBQ0EsVUFBSSxDQUFDLE9BQU8sY0FBYyxLQUFLLEdBQUc7QUFDOUIsUUFBSSxRQUFRLElBRVIsUUFBUSxPQUFPLEtBQUs7QUFBQSxVQUNoQjtBQUFBLFVBQ0EsTUFBTTtBQUFBLFVBQ04sU0FBUyxPQUFPO0FBQUEsVUFDaEIsTUFBTTtBQUFBLFVBQ047QUFBQSxVQUNBO0FBQUEsVUFDQSxXQUFXO0FBQUEsVUFDWCxVQUFVLENBQUMsSUFBSTtBQUFBLFFBQ25CLENBQUMsSUFJRCxRQUFRLE9BQU8sS0FBSztBQUFBLFVBQ2hCO0FBQUEsVUFDQSxNQUFNO0FBQUEsVUFDTixTQUFTLE9BQU87QUFBQSxVQUNoQixNQUFNO0FBQUEsVUFDTjtBQUFBLFVBQ0E7QUFBQSxVQUNBLFdBQVc7QUFBQSxVQUNYLFVBQVUsQ0FBQyxJQUFJO0FBQUEsUUFDbkIsQ0FBQztBQUVMO0FBQUEsTUFDSjtBQUFBLElBQ0o7QUFDQSxJQUFJLFFBQVEsV0FDUixRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFFBQVE7QUFBQSxNQUNSO0FBQUEsTUFDQSxNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0EsV0FBVztBQUFBLE1BQ1g7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQyxHQUVELFFBQVEsV0FDUixRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFFBQVE7QUFBQSxNQUNSO0FBQUEsTUFDQSxNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0EsV0FBVztBQUFBLE1BQ1g7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBRVQ7QUFDSixDQUFDLEdBQ1ksd0JBQXNDLGdCQUFLLGFBQWEseUJBQXlCLENBQUMsTUFBTSxRQUFRO0FBQ3pHLFlBQVUsS0FBSyxNQUFNLEdBQUc7QUFDeEIsTUFBTSxDQUFDLFNBQVMsT0FBTyxJQUFTLHFCQUFxQixJQUFJLE1BQU07QUFDL0QsT0FBSyxLQUFLLFNBQVMsS0FBSyxDQUFDQSxVQUFTO0FBQzlCLFFBQU0sTUFBTUEsTUFBSyxLQUFLO0FBQ3RCLFFBQUksU0FBUyxJQUFJLFFBQ2pCLElBQUksVUFBVSxTQUNkLElBQUksVUFBVTtBQUFBLEVBQ2xCLENBQUMsR0FDRCxLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsUUFBTSxRQUFRLFFBQVE7QUFDdEIsSUFBSSxRQUFRLFdBQ1IsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixRQUFRO0FBQUEsTUFDUjtBQUFBLE1BQ0EsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLFdBQVc7QUFBQSxNQUNYO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUMsR0FFRCxRQUFRLFdBQ1IsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixRQUFRO0FBQUEsTUFDUjtBQUFBLE1BQ0EsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLFdBQVc7QUFBQSxNQUNYO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUVUO0FBQ0osQ0FBQyxHQUNZLG1CQUFpQyxnQkFBSyxhQUFhLG9CQUFvQixDQUFDLE1BQU0sUUFBUTtBQUMvRixNQUFJRDtBQUNKLFlBQVUsS0FBSyxNQUFNLEdBQUcsSUFDdkJBLE1BQUssS0FBSyxLQUFLLEtBQUssU0FBU0EsSUFBRyxPQUFPLENBQUMsWUFBWTtBQUNqRCxRQUFNLE1BQU0sUUFBUTtBQUNwQixXQUFPLENBQU0sUUFBUSxHQUFHLEtBQUssSUFBSSxTQUFTO0FBQUEsRUFDOUMsSUFDQSxLQUFLLEtBQUssU0FBUyxLQUFLLENBQUNDLFVBQVM7QUFDOUIsUUFBTSxPQUFRQSxNQUFLLEtBQUssSUFBSSxXQUFXLE9BQU87QUFDOUMsSUFBSSxJQUFJLFVBQVUsU0FDZEEsTUFBSyxLQUFLLElBQUksVUFBVSxJQUFJO0FBQUEsRUFDcEMsQ0FBQyxHQUNELEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixRQUFNLFFBQVEsUUFBUTtBQUV0QixJQURhLE1BQU0sUUFDUCxJQUFJLFdBRWhCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsUUFBYSxpQkFBaUIsS0FBSztBQUFBLE1BQ25DLE1BQU07QUFBQSxNQUNOLFNBQVMsSUFBSTtBQUFBLE1BQ2IsV0FBVztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQyxHQUNZLG1CQUFpQyxnQkFBSyxhQUFhLG9CQUFvQixDQUFDLE1BQU0sUUFBUTtBQUMvRixNQUFJRDtBQUNKLFlBQVUsS0FBSyxNQUFNLEdBQUcsSUFDdkJBLE1BQUssS0FBSyxLQUFLLEtBQUssU0FBU0EsSUFBRyxPQUFPLENBQUMsWUFBWTtBQUNqRCxRQUFNLE1BQU0sUUFBUTtBQUNwQixXQUFPLENBQU0sUUFBUSxHQUFHLEtBQUssSUFBSSxTQUFTO0FBQUEsRUFDOUMsSUFDQSxLQUFLLEtBQUssU0FBUyxLQUFLLENBQUNDLFVBQVM7QUFDOUIsUUFBTSxPQUFRQSxNQUFLLEtBQUssSUFBSSxXQUFXLE9BQU87QUFDOUMsSUFBSSxJQUFJLFVBQVUsU0FDZEEsTUFBSyxLQUFLLElBQUksVUFBVSxJQUFJO0FBQUEsRUFDcEMsQ0FBQyxHQUNELEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixRQUFNLFFBQVEsUUFBUTtBQUV0QixJQURhLE1BQU0sUUFDUCxJQUFJLFdBRWhCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsUUFBYSxpQkFBaUIsS0FBSztBQUFBLE1BQ25DLE1BQU07QUFBQSxNQUNOLFNBQVMsSUFBSTtBQUFBLE1BQ2IsV0FBVztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQyxHQUNZLHNCQUFvQyxnQkFBSyxhQUFhLHVCQUF1QixDQUFDLE1BQU0sUUFBUTtBQUNyRyxNQUFJRDtBQUNKLFlBQVUsS0FBSyxNQUFNLEdBQUcsSUFDdkJBLE1BQUssS0FBSyxLQUFLLEtBQUssU0FBU0EsSUFBRyxPQUFPLENBQUMsWUFBWTtBQUNqRCxRQUFNLE1BQU0sUUFBUTtBQUNwQixXQUFPLENBQU0sUUFBUSxHQUFHLEtBQUssSUFBSSxTQUFTO0FBQUEsRUFDOUMsSUFDQSxLQUFLLEtBQUssU0FBUyxLQUFLLENBQUNDLFVBQVM7QUFDOUIsUUFBTSxNQUFNQSxNQUFLLEtBQUs7QUFDdEIsUUFBSSxVQUFVLElBQUksTUFDbEIsSUFBSSxVQUFVLElBQUksTUFDbEIsSUFBSSxPQUFPLElBQUk7QUFBQSxFQUNuQixDQUFDLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLFFBQU0sUUFBUSxRQUFRLE9BQ2hCLE9BQU8sTUFBTTtBQUNuQixRQUFJLFNBQVMsSUFBSTtBQUNiO0FBQ0osUUFBTSxTQUFTLE9BQU8sSUFBSTtBQUMxQixZQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFFBQWEsaUJBQWlCLEtBQUs7QUFBQSxNQUNuQyxHQUFJLFNBQVMsRUFBRSxNQUFNLFdBQVcsU0FBUyxJQUFJLEtBQUssSUFBSSxFQUFFLE1BQU0sYUFBYSxTQUFTLElBQUksS0FBSztBQUFBLE1BQzdGLFdBQVc7QUFBQSxNQUNYLE9BQU87QUFBQSxNQUNQLE9BQU8sUUFBUTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBQ0w7QUFDSixDQUFDLEdBQ1kscUJBQW1DLGdCQUFLLGFBQWEsc0JBQXNCLENBQUMsTUFBTSxRQUFRO0FBQ25HLE1BQUlEO0FBQ0osWUFBVSxLQUFLLE1BQU0sR0FBRyxJQUN2QkEsTUFBSyxLQUFLLEtBQUssS0FBSyxTQUFTQSxJQUFHLE9BQU8sQ0FBQyxZQUFZO0FBQ2pELFFBQU0sTUFBTSxRQUFRO0FBQ3BCLFdBQU8sQ0FBTSxRQUFRLEdBQUcsS0FBSyxJQUFJLFdBQVc7QUFBQSxFQUNoRCxJQUNBLEtBQUssS0FBSyxTQUFTLEtBQUssQ0FBQ0MsVUFBUztBQUM5QixRQUFNLE9BQVFBLE1BQUssS0FBSyxJQUFJLFdBQVcsT0FBTztBQUM5QyxJQUFJLElBQUksVUFBVSxTQUNkQSxNQUFLLEtBQUssSUFBSSxVQUFVLElBQUk7QUFBQSxFQUNwQyxDQUFDLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLFFBQU0sUUFBUSxRQUFRO0FBRXRCLFFBRGUsTUFBTSxVQUNQLElBQUk7QUFDZDtBQUNKLFFBQU0sU0FBYyxvQkFBb0IsS0FBSztBQUM3QyxZQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCO0FBQUEsTUFDQSxNQUFNO0FBQUEsTUFDTixTQUFTLElBQUk7QUFBQSxNQUNiLFdBQVc7QUFBQSxNQUNYO0FBQUEsTUFDQTtBQUFBLE1BQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxJQUNuQixDQUFDO0FBQUEsRUFDTDtBQUNKLENBQUMsR0FDWSxxQkFBbUMsZ0JBQUssYUFBYSxzQkFBc0IsQ0FBQyxNQUFNLFFBQVE7QUFDbkcsTUFBSUQ7QUFDSixZQUFVLEtBQUssTUFBTSxHQUFHLElBQ3ZCQSxNQUFLLEtBQUssS0FBSyxLQUFLLFNBQVNBLElBQUcsT0FBTyxDQUFDLFlBQVk7QUFDakQsUUFBTSxNQUFNLFFBQVE7QUFDcEIsV0FBTyxDQUFNLFFBQVEsR0FBRyxLQUFLLElBQUksV0FBVztBQUFBLEVBQ2hELElBQ0EsS0FBSyxLQUFLLFNBQVMsS0FBSyxDQUFDQyxVQUFTO0FBQzlCLFFBQU0sT0FBUUEsTUFBSyxLQUFLLElBQUksV0FBVyxPQUFPO0FBQzlDLElBQUksSUFBSSxVQUFVLFNBQ2RBLE1BQUssS0FBSyxJQUFJLFVBQVUsSUFBSTtBQUFBLEVBQ3BDLENBQUMsR0FDRCxLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsUUFBTSxRQUFRLFFBQVE7QUFFdEIsUUFEZSxNQUFNLFVBQ1AsSUFBSTtBQUNkO0FBQ0osUUFBTSxTQUFjLG9CQUFvQixLQUFLO0FBQzdDLFlBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxNQUNBLE1BQU07QUFBQSxNQUNOLFNBQVMsSUFBSTtBQUFBLE1BQ2IsV0FBVztBQUFBLE1BQ1g7QUFBQSxNQUNBO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQyxHQUNZLHdCQUFzQyxnQkFBSyxhQUFhLHlCQUF5QixDQUFDLE1BQU0sUUFBUTtBQUN6RyxNQUFJRDtBQUNKLFlBQVUsS0FBSyxNQUFNLEdBQUcsSUFDdkJBLE1BQUssS0FBSyxLQUFLLEtBQUssU0FBU0EsSUFBRyxPQUFPLENBQUMsWUFBWTtBQUNqRCxRQUFNLE1BQU0sUUFBUTtBQUNwQixXQUFPLENBQU0sUUFBUSxHQUFHLEtBQUssSUFBSSxXQUFXO0FBQUEsRUFDaEQsSUFDQSxLQUFLLEtBQUssU0FBUyxLQUFLLENBQUNDLFVBQVM7QUFDOUIsUUFBTSxNQUFNQSxNQUFLLEtBQUs7QUFDdEIsUUFBSSxVQUFVLElBQUksUUFDbEIsSUFBSSxVQUFVLElBQUksUUFDbEIsSUFBSSxTQUFTLElBQUk7QUFBQSxFQUNyQixDQUFDLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLFFBQU0sUUFBUSxRQUFRLE9BQ2hCLFNBQVMsTUFBTTtBQUNyQixRQUFJLFdBQVcsSUFBSTtBQUNmO0FBQ0osUUFBTSxTQUFjLG9CQUFvQixLQUFLLEdBQ3ZDLFNBQVMsU0FBUyxJQUFJO0FBQzVCLFlBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEI7QUFBQSxNQUNBLEdBQUksU0FBUyxFQUFFLE1BQU0sV0FBVyxTQUFTLElBQUksT0FBTyxJQUFJLEVBQUUsTUFBTSxhQUFhLFNBQVMsSUFBSSxPQUFPO0FBQUEsTUFDakcsV0FBVztBQUFBLE1BQ1gsT0FBTztBQUFBLE1BQ1AsT0FBTyxRQUFRO0FBQUEsTUFDZjtBQUFBLE1BQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxJQUNuQixDQUFDO0FBQUEsRUFDTDtBQUNKLENBQUMsR0FDWSx3QkFBc0MsZ0JBQUssYUFBYSx5QkFBeUIsQ0FBQyxNQUFNLFFBQVE7QUFDekcsTUFBSUQsS0FBSTtBQUNSLFlBQVUsS0FBSyxNQUFNLEdBQUcsR0FDeEIsS0FBSyxLQUFLLFNBQVMsS0FBSyxDQUFDQyxVQUFTO0FBQzlCLFFBQU0sTUFBTUEsTUFBSyxLQUFLO0FBQ3RCLFFBQUksU0FBUyxJQUFJLFFBQ2IsSUFBSSxZQUNKLElBQUksYUFBYSxJQUFJLFdBQVcsb0JBQUksSUFBSSxJQUN4QyxJQUFJLFNBQVMsSUFBSSxJQUFJLE9BQU87QUFBQSxFQUVwQyxDQUFDLEdBQ0csSUFBSSxXQUNIRCxNQUFLLEtBQUssTUFBTSxVQUFVQSxJQUFHLFFBQVEsQ0FBQyxZQUFZO0FBRS9DLElBREEsSUFBSSxRQUFRLFlBQVksR0FDcEIsS0FBSSxRQUFRLEtBQUssUUFBUSxLQUFLLEtBRWxDLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sUUFBUSxJQUFJO0FBQUEsTUFDWixPQUFPLFFBQVE7QUFBQSxNQUNmLEdBQUksSUFBSSxVQUFVLEVBQUUsU0FBUyxJQUFJLFFBQVEsU0FBUyxFQUFFLElBQUksQ0FBQztBQUFBLE1BQ3pEO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMLE1BRUMsS0FBSyxLQUFLLE1BQU0sVUFBVSxHQUFHLFFBQVEsTUFBTTtBQUFBLEVBQUU7QUFDdEQsQ0FBQyxHQUNZLGlCQUErQixnQkFBSyxhQUFhLGtCQUFrQixDQUFDLE1BQU0sUUFBUTtBQUMzRix3QkFBc0IsS0FBSyxNQUFNLEdBQUcsR0FDcEMsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBRTNCLElBREEsSUFBSSxRQUFRLFlBQVksR0FDcEIsS0FBSSxRQUFRLEtBQUssUUFBUSxLQUFLLEtBRWxDLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsUUFBUTtBQUFBLE1BQ1IsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLE1BQ1IsT0FBTyxRQUFRO0FBQUEsTUFDZixTQUFTLElBQUksUUFBUSxTQUFTO0FBQUEsTUFDOUI7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBQ0w7QUFDSixDQUFDLEdBQ1kscUJBQW1DLGdCQUFLLGFBQWEsc0JBQXNCLENBQUMsTUFBTSxRQUFRO0FBQ25HLE1BQUksWUFBWSxJQUFJLFVBQWtCLFlBQ3RDLHNCQUFzQixLQUFLLE1BQU0sR0FBRztBQUN4QyxDQUFDLEdBQ1kscUJBQW1DLGdCQUFLLGFBQWEsc0JBQXNCLENBQUMsTUFBTSxRQUFRO0FBQ25HLE1BQUksWUFBWSxJQUFJLFVBQWtCLFlBQ3RDLHNCQUFzQixLQUFLLE1BQU0sR0FBRztBQUN4QyxDQUFDLEdBQ1ksb0JBQWtDLGdCQUFLLGFBQWEscUJBQXFCLENBQUMsTUFBTSxRQUFRO0FBQ2pHLFlBQVUsS0FBSyxNQUFNLEdBQUc7QUFDeEIsTUFBTSxlQUFvQixZQUFZLElBQUksUUFBUSxHQUM1QyxVQUFVLElBQUksT0FBTyxPQUFPLElBQUksWUFBYSxXQUFXLE1BQU0sSUFBSSxRQUFRLElBQUksWUFBWSxLQUFLLFlBQVk7QUFDakgsTUFBSSxVQUFVLFNBQ2QsS0FBSyxLQUFLLFNBQVMsS0FBSyxDQUFDQyxVQUFTO0FBQzlCLFFBQU0sTUFBTUEsTUFBSyxLQUFLO0FBQ3RCLFFBQUksYUFBYSxJQUFJLFdBQVcsb0JBQUksSUFBSSxJQUN4QyxJQUFJLFNBQVMsSUFBSSxPQUFPO0FBQUEsRUFDNUIsQ0FBQyxHQUNELEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixJQUFJLFFBQVEsTUFBTSxTQUFTLElBQUksVUFBVSxJQUFJLFFBQVEsS0FFckQsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixVQUFVLElBQUk7QUFBQSxNQUNkLE9BQU8sUUFBUTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBQ0w7QUFDSixDQUFDLEdBQ1ksc0JBQW9DLGdCQUFLLGFBQWEsdUJBQXVCLENBQUMsTUFBTSxRQUFRO0FBQ3JHLFlBQVUsS0FBSyxNQUFNLEdBQUc7QUFDeEIsTUFBTSxVQUFVLElBQUksT0FBTyxJQUFTLFlBQVksSUFBSSxNQUFNLENBQUMsSUFBSTtBQUMvRCxNQUFJLFlBQVksSUFBSSxVQUFVLFVBQzlCLEtBQUssS0FBSyxTQUFTLEtBQUssQ0FBQ0EsVUFBUztBQUM5QixRQUFNLE1BQU1BLE1BQUssS0FBSztBQUN0QixRQUFJLGFBQWEsSUFBSSxXQUFXLG9CQUFJLElBQUksSUFDeEMsSUFBSSxTQUFTLElBQUksT0FBTztBQUFBLEVBQzVCLENBQUMsR0FDRCxLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsSUFBSSxRQUFRLE1BQU0sV0FBVyxJQUFJLE1BQU0sS0FFdkMsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixRQUFRLElBQUk7QUFBQSxNQUNaLE9BQU8sUUFBUTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBQ0w7QUFDSixDQUFDLEdBQ1ksb0JBQWtDLGdCQUFLLGFBQWEscUJBQXFCLENBQUMsTUFBTSxRQUFRO0FBQ2pHLFlBQVUsS0FBSyxNQUFNLEdBQUc7QUFDeEIsTUFBTSxVQUFVLElBQUksT0FBTyxLQUFVLFlBQVksSUFBSSxNQUFNLENBQUMsR0FBRztBQUMvRCxNQUFJLFlBQVksSUFBSSxVQUFVLFVBQzlCLEtBQUssS0FBSyxTQUFTLEtBQUssQ0FBQ0EsVUFBUztBQUM5QixRQUFNLE1BQU1BLE1BQUssS0FBSztBQUN0QixRQUFJLGFBQWEsSUFBSSxXQUFXLG9CQUFJLElBQUksSUFDeEMsSUFBSSxTQUFTLElBQUksT0FBTztBQUFBLEVBQzVCLENBQUMsR0FDRCxLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsSUFBSSxRQUFRLE1BQU0sU0FBUyxJQUFJLE1BQU0sS0FFckMsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixRQUFRO0FBQUEsTUFDUixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixRQUFRLElBQUk7QUFBQSxNQUNaLE9BQU8sUUFBUTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsSUFDbkIsQ0FBQztBQUFBLEVBQ0w7QUFDSixDQUFDO0FBSUQsU0FBUywwQkFBMEIsUUFBUSxTQUFTLFVBQVU7QUFDMUQsRUFBSSxPQUFPLE9BQU8sVUFDZCxRQUFRLE9BQU8sS0FBSyxHQUFRLGFBQWEsVUFBVSxPQUFPLE1BQU0sQ0FBQztBQUV6RTtBQUNPLElBQU0sb0JBQWtDLGdCQUFLLGFBQWEscUJBQXFCLENBQUMsTUFBTSxRQUFRO0FBQ2pHLFlBQVUsS0FBSyxNQUFNLEdBQUcsR0FDeEIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLFFBQU0sU0FBUyxJQUFJLE9BQU8sS0FBSyxJQUFJO0FBQUEsTUFDL0IsT0FBTyxRQUFRLE1BQU0sSUFBSSxRQUFRO0FBQUEsTUFDakMsUUFBUSxDQUFDO0FBQUEsSUFDYixHQUFHLENBQUMsQ0FBQztBQUNMLFFBQUksa0JBQWtCO0FBQ2xCLGFBQU8sT0FBTyxLQUFLLENBQUNFLFlBQVcsMEJBQTBCQSxTQUFRLFNBQVMsSUFBSSxRQUFRLENBQUM7QUFFM0YsOEJBQTBCLFFBQVEsU0FBUyxJQUFJLFFBQVE7QUFBQSxFQUUzRDtBQUNKLENBQUMsR0FDWSxvQkFBa0MsZ0JBQUssYUFBYSxxQkFBcUIsQ0FBQyxNQUFNLFFBQVE7QUFDakcsWUFBVSxLQUFLLE1BQU0sR0FBRztBQUN4QixNQUFNLFVBQVUsSUFBSSxJQUFJLElBQUksSUFBSTtBQUNoQyxPQUFLLEtBQUssU0FBUyxLQUFLLENBQUNGLFVBQVM7QUFDOUIsSUFBQUEsTUFBSyxLQUFLLElBQUksT0FBTyxJQUFJO0FBQUEsRUFDN0IsQ0FBQyxHQUNELEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixJQUFJLFFBQVEsSUFBSSxRQUFRLE1BQU0sSUFBSSxLQUVsQyxRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLE1BQU07QUFBQSxNQUNOLFFBQVEsSUFBSTtBQUFBLE1BQ1osT0FBTyxRQUFRLE1BQU07QUFBQSxNQUNyQjtBQUFBLE1BQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxJQUNuQixDQUFDO0FBQUEsRUFDTDtBQUNKLENBQUMsR0FDWSxxQkFBbUMsZ0JBQUssYUFBYSxzQkFBc0IsQ0FBQyxNQUFNLFFBQVE7QUFDbkcsWUFBVSxLQUFLLE1BQU0sR0FBRyxHQUN4QixLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsWUFBUSxRQUFRLElBQUksR0FBRyxRQUFRLEtBQUs7QUFBQSxFQUN4QztBQUNKLENBQUM7OztBQzlqQk0sSUFBTSxNQUFOLE1BQVU7QUFBQSxFQUNiLFlBQVksT0FBTyxDQUFDLEdBQUc7QUFDbkIsU0FBSyxVQUFVLENBQUMsR0FDaEIsS0FBSyxTQUFTLEdBQ1YsU0FDQSxLQUFLLE9BQU87QUFBQSxFQUNwQjtBQUFBLEVBQ0EsU0FBUyxJQUFJO0FBQ1QsU0FBSyxVQUFVLEdBQ2YsR0FBRyxJQUFJLEdBQ1AsS0FBSyxVQUFVO0FBQUEsRUFDbkI7QUFBQSxFQUNBLE1BQU0sS0FBSztBQUNQLFFBQUksT0FBTyxPQUFRLFlBQVk7QUFDM0IsVUFBSSxNQUFNLEVBQUUsV0FBVyxPQUFPLENBQUMsR0FDL0IsSUFBSSxNQUFNLEVBQUUsV0FBVyxRQUFRLENBQUM7QUFDaEM7QUFBQSxJQUNKO0FBRUEsUUFBTSxRQURVLElBQ00sTUFBTTtBQUFBLENBQUksRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDLEdBQzNDLFlBQVksS0FBSyxJQUFJLEdBQUcsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLFNBQVMsRUFBRSxVQUFVLEVBQUUsTUFBTSxDQUFDLEdBQ3pFLFdBQVcsTUFBTSxJQUFJLENBQUMsTUFBTSxFQUFFLE1BQU0sU0FBUyxDQUFDLEVBQUUsSUFBSSxDQUFDLE1BQU0sSUFBSSxPQUFPLEtBQUssU0FBUyxDQUFDLElBQUksQ0FBQztBQUNoRyxhQUFXLFFBQVE7QUFDZixXQUFLLFFBQVEsS0FBSyxJQUFJO0FBQUEsRUFFOUI7QUFBQSxFQUNBLFVBQVU7QUFDTixRQUFNLElBQUksVUFDSixPQUFPLE1BQU0sTUFFYixRQUFRLENBQUMsSUFEQyxNQUFNLFdBQVcsQ0FBQyxFQUFFLEdBQ1YsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsQ0FBQztBQUU5QyxXQUFPLElBQUksRUFBRSxHQUFHLE1BQU0sTUFBTSxLQUFLO0FBQUEsQ0FBSSxDQUFDO0FBQUEsRUFDMUM7QUFDSjs7O0FDbENPLElBQU0sVUFBVTtBQUFBLEVBQ25CLE9BQU87QUFBQSxFQUNQLE9BQU87QUFBQSxFQUNQLE9BQU87QUFDWDs7O0FDR08sSUFBTSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsTUFBSUc7QUFDSixXQUFTLE9BQU8sQ0FBQyxJQUNqQixLQUFLLEtBQUssTUFBTSxLQUNoQixLQUFLLEtBQUssTUFBTSxLQUFLLEtBQUssT0FBTyxDQUFDLEdBQ2xDLEtBQUssS0FBSyxVQUFVO0FBQ3BCLE1BQU0sU0FBUyxDQUFDLEdBQUksS0FBSyxLQUFLLElBQUksVUFBVSxDQUFDLENBQUU7QUFFL0MsRUFBSSxLQUFLLEtBQUssT0FBTyxJQUFJLFdBQVcsS0FDaEMsT0FBTyxRQUFRLElBQUk7QUFFdkIsV0FBVyxNQUFNO0FBQ2IsYUFBVyxNQUFNLEdBQUcsS0FBSztBQUNyQixTQUFHLElBQUk7QUFHZixNQUFJLE9BQU8sV0FBVztBQUdsQixLQUFDQSxNQUFLLEtBQUssTUFBTSxhQUFhQSxJQUFHLFdBQVcsQ0FBQyxJQUM3QyxLQUFLLEtBQUssVUFBVSxLQUFLLE1BQU07QUFDM0IsV0FBSyxLQUFLLE1BQU0sS0FBSyxLQUFLO0FBQUEsSUFDOUIsQ0FBQztBQUFBLE9BRUE7QUFDRCxRQUFNLFlBQVksQ0FBQyxTQUFTQyxTQUFRLFFBQVE7QUFDeEMsVUFBSUMsYUFBaUIsUUFBUSxPQUFPLEdBQ2hDO0FBQ0osZUFBVyxNQUFNRCxTQUFRO0FBQ3JCLFlBQUksR0FBRyxLQUFLLElBQUk7QUFFWixjQUFJLENBRGMsR0FBRyxLQUFLLElBQUksS0FBSyxPQUFPO0FBRXRDO0FBQUEsbUJBRUNDO0FBQ0w7QUFFSixZQUFNLFVBQVUsUUFBUSxPQUFPLFFBQ3pCLElBQUksR0FBRyxLQUFLLE1BQU0sT0FBTztBQUMvQixZQUFJLGFBQWEsV0FBVyxLQUFLLFVBQVU7QUFDdkMsZ0JBQU0sSUFBUyxlQUFlO0FBRWxDLFlBQUksZUFBZSxhQUFhO0FBQzVCLHlCQUFlLGVBQWUsUUFBUSxRQUFRLEdBQUcsS0FBSyxZQUFZO0FBRzlELFlBRkEsTUFBTSxHQUNVLFFBQVEsT0FBTyxXQUNmLFlBRVhBLGVBQ0RBLGFBQWlCLFFBQVEsU0FBUyxPQUFPO0FBQUEsVUFDakQsQ0FBQztBQUFBLGFBRUE7QUFFRCxjQURnQixRQUFRLE9BQU8sV0FDZjtBQUNaO0FBQ0osVUFBS0EsZUFDREEsYUFBaUIsUUFBUSxTQUFTLE9BQU87QUFBQSxRQUNqRDtBQUFBLE1BQ0o7QUFDQSxhQUFJLGNBQ08sWUFBWSxLQUFLLE1BQ2IsT0FDVixJQUVFO0FBQUEsSUFDWCxHQUNNLHFCQUFxQixDQUFDLFFBQVEsU0FBUyxRQUFRO0FBRWpELFVBQVMsUUFBUSxNQUFNO0FBQ25CLHNCQUFPLFVBQVUsSUFDVjtBQUdYLFVBQU0sY0FBYyxVQUFVLFNBQVMsUUFBUSxHQUFHO0FBQ2xELFVBQUksdUJBQXVCLFNBQVM7QUFDaEMsWUFBSSxJQUFJLFVBQVU7QUFDZCxnQkFBTSxJQUFTLGVBQWU7QUFDbEMsZUFBTyxZQUFZLEtBQUssQ0FBQ0MsaUJBQWdCLEtBQUssS0FBSyxNQUFNQSxjQUFhLEdBQUcsQ0FBQztBQUFBLE1BQzlFO0FBQ0EsYUFBTyxLQUFLLEtBQUssTUFBTSxhQUFhLEdBQUc7QUFBQSxJQUMzQztBQUNBLFNBQUssS0FBSyxNQUFNLENBQUMsU0FBUyxRQUFRO0FBQzlCLFVBQUksSUFBSTtBQUNKLGVBQU8sS0FBSyxLQUFLLE1BQU0sU0FBUyxHQUFHO0FBRXZDLFVBQUksSUFBSSxjQUFjLFlBQVk7QUFHOUIsWUFBTSxTQUFTLEtBQUssS0FBSyxNQUFNLEVBQUUsT0FBTyxRQUFRLE9BQU8sUUFBUSxDQUFDLEVBQUUsR0FBRyxFQUFFLEdBQUcsS0FBSyxZQUFZLEdBQUssQ0FBQztBQUNqRyxlQUFJLGtCQUFrQixVQUNYLE9BQU8sS0FBSyxDQUFDQyxZQUNULG1CQUFtQkEsU0FBUSxTQUFTLEdBQUcsQ0FDakQsSUFFRSxtQkFBbUIsUUFBUSxTQUFTLEdBQUc7QUFBQSxNQUNsRDtBQUVBLFVBQU0sU0FBUyxLQUFLLEtBQUssTUFBTSxTQUFTLEdBQUc7QUFDM0MsVUFBSSxrQkFBa0IsU0FBUztBQUMzQixZQUFJLElBQUksVUFBVTtBQUNkLGdCQUFNLElBQVMsZUFBZTtBQUNsQyxlQUFPLE9BQU8sS0FBSyxDQUFDQyxZQUFXLFVBQVVBLFNBQVEsUUFBUSxHQUFHLENBQUM7QUFBQSxNQUNqRTtBQUNBLGFBQU8sVUFBVSxRQUFRLFFBQVEsR0FBRztBQUFBLElBQ3hDO0FBQUEsRUFDSjtBQUVBLEVBQUssV0FBVyxNQUFNLGFBQWEsT0FBTztBQUFBLElBQ3RDLFVBQVUsQ0FBQyxVQUFVO0FBQ2pCLFVBQUk7QUFDQSxZQUFNLElBQUksVUFBVSxNQUFNLEtBQUs7QUFDL0IsZUFBTyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsS0FBSyxJQUFJLEVBQUUsUUFBUSxFQUFFLE9BQU8sT0FBTztBQUFBLE1BQ3JFLFFBQ1U7QUFDTixlQUFPLGVBQWUsTUFBTSxLQUFLLEVBQUUsS0FBSyxDQUFDLE1BQU8sRUFBRSxVQUFVLEVBQUUsT0FBTyxFQUFFLEtBQUssSUFBSSxFQUFFLFFBQVEsRUFBRSxPQUFPLE9BQU8sQ0FBRTtBQUFBLE1BQ2hIO0FBQUEsSUFDSjtBQUFBLElBQ0EsUUFBUTtBQUFBLElBQ1IsU0FBUztBQUFBLEVBQ2IsRUFBRTtBQUNOLENBQUMsR0FFWSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssVUFBVSxDQUFDLEdBQUksTUFBTSxLQUFLLEtBQUssWUFBWSxDQUFDLENBQUUsRUFBRSxJQUFJLEtBQWEsT0FBTyxLQUFLLEtBQUssR0FBRyxHQUMvRixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsTUFBTTtBQUM5QixRQUFJLElBQUk7QUFDSixVQUFJO0FBQ0EsZ0JBQVEsUUFBUSxPQUFPLFFBQVEsS0FBSztBQUFBLE1BQ3hDLFFBQ1U7QUFBQSxNQUFFO0FBQ2hCLFdBQUksT0FBTyxRQUFRLFNBQVUsWUFFN0IsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixPQUFPLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLG1CQUFpQyxnQkFBSyxhQUFhLG9CQUFvQixDQUFDLE1BQU0sUUFBUTtBQUUvRixFQUFPLHNCQUFzQixLQUFLLE1BQU0sR0FBRyxHQUMzQyxXQUFXLEtBQUssTUFBTSxHQUFHO0FBQzdCLENBQUMsR0FDWSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsTUFBSSxZQUFZLElBQUksVUFBa0IsT0FDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHO0FBQ25DLENBQUMsR0FDWSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsTUFBSSxJQUFJLFNBQVM7QUFXYixRQUFNLElBVmE7QUFBQSxNQUNmLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxNQUNKLElBQUk7QUFBQSxJQUNSLEVBQ3FCLElBQUksT0FBTztBQUNoQyxRQUFJLE1BQU07QUFDTixZQUFNLElBQUksTUFBTSwwQkFBMEIsSUFBSSxPQUFPLEdBQUc7QUFDNUQsUUFBSSxZQUFZLElBQUksVUFBa0IsS0FBSyxDQUFDO0FBQUEsRUFDaEQ7QUFFSSxRQUFJLFlBQVksSUFBSSxVQUFrQixLQUFLO0FBQy9DLG1CQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLE1BQUksWUFBWSxJQUFJLFVBQWtCLFFBQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksVUFBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBQzdFLG1CQUFpQixLQUFLLE1BQU0sR0FBRyxHQUMvQixLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsUUFBSTtBQUVBLFVBQU0sVUFBVSxRQUFRLE1BQU0sS0FBSyxHQUU3QkMsT0FBTSxJQUFJLElBQUksT0FBTztBQUMzQixNQUFJLElBQUksYUFDSixJQUFJLFNBQVMsWUFBWSxHQUNwQixJQUFJLFNBQVMsS0FBS0EsS0FBSSxRQUFRLEtBQy9CLFFBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEIsTUFBTTtBQUFBLFFBQ04sUUFBUTtBQUFBLFFBQ1IsTUFBTTtBQUFBLFFBQ04sU0FBUyxJQUFJLFNBQVM7QUFBQSxRQUN0QixPQUFPLFFBQVE7QUFBQSxRQUNmO0FBQUEsUUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLE1BQ25CLENBQUMsSUFHTCxJQUFJLGFBQ0osSUFBSSxTQUFTLFlBQVksR0FDcEIsSUFBSSxTQUFTLEtBQUtBLEtBQUksU0FBUyxTQUFTLEdBQUcsSUFBSUEsS0FBSSxTQUFTLE1BQU0sR0FBRyxFQUFFLElBQUlBLEtBQUksUUFBUSxLQUN4RixRQUFRLE9BQU8sS0FBSztBQUFBLFFBQ2hCLE1BQU07QUFBQSxRQUNOLFFBQVE7QUFBQSxRQUNSLE1BQU07QUFBQSxRQUNOLFNBQVMsSUFBSSxTQUFTO0FBQUEsUUFDdEIsT0FBTyxRQUFRO0FBQUEsUUFDZjtBQUFBLFFBQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxNQUNuQixDQUFDLElBSUwsSUFBSSxZQUVKLFFBQVEsUUFBUUEsS0FBSSxPQUlwQixRQUFRLFFBQVE7QUFFcEI7QUFBQSxJQUNKLFFBQ1U7QUFDTixjQUFRLE9BQU8sS0FBSztBQUFBLFFBQ2hCLE1BQU07QUFBQSxRQUNOLFFBQVE7QUFBQSxRQUNSLE9BQU8sUUFBUTtBQUFBLFFBQ2Y7QUFBQSxRQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsTUFDbkIsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQ0osQ0FBQyxHQUNZLFlBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUNqRixNQUFJLFlBQVksSUFBSSxVQUFrQixNQUFNLElBQzVDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksYUFBMkIsZ0JBQUssYUFBYSxjQUFjLENBQUMsTUFBTSxRQUFRO0FBQ25GLE1BQUksWUFBWSxJQUFJLFVBQWtCLFNBQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksV0FBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBQy9FLE1BQUksWUFBWSxJQUFJLFVBQWtCLE9BQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLE1BQUksWUFBWSxJQUFJLFVBQWtCLFFBQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksV0FBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBQy9FLE1BQUksWUFBWSxJQUFJLFVBQWtCLE9BQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksVUFBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBQzdFLE1BQUksWUFBWSxJQUFJLFVBQWtCLE1BQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLE1BQUksWUFBWSxJQUFJLFVBQWtCLFFBQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRztBQUNuQyxDQUFDLEdBQ1ksa0JBQWdDLGdCQUFLLGFBQWEsbUJBQW1CLENBQUMsTUFBTSxRQUFRO0FBQzdGLE1BQUksWUFBWSxJQUFJLFVBQWtCLFNBQVMsR0FBRyxJQUNsRCxpQkFBaUIsS0FBSyxNQUFNLEdBQUc7QUFDbkMsQ0FBQyxHQUNZLGNBQTRCLGdCQUFLLGFBQWEsZUFBZSxDQUFDLE1BQU0sUUFBUTtBQUNyRixNQUFJLFlBQVksSUFBSSxVQUFrQixPQUN0QyxpQkFBaUIsS0FBSyxNQUFNLEdBQUc7QUFDbkMsQ0FBQyxHQUNZLGNBQTRCLGdCQUFLLGFBQWEsZUFBZSxDQUFDLE1BQU0sUUFBUTtBQUNyRixNQUFJLFlBQVksSUFBSSxVQUFrQixLQUFLLEdBQUcsSUFDOUMsaUJBQWlCLEtBQUssTUFBTSxHQUFHO0FBQ25DLENBQUMsR0FDWSxrQkFBZ0MsZ0JBQUssYUFBYSxtQkFBbUIsQ0FBQyxNQUFNLFFBQVE7QUFDN0YsTUFBSSxZQUFZLElBQUksVUFBa0IsV0FDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHO0FBQ25DLENBQUMsR0FDWSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsTUFBSSxZQUFZLElBQUksVUFBa0IsT0FDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHLEdBQy9CLEtBQUssS0FBSyxJQUFJLFNBQVM7QUFDM0IsQ0FBQyxHQUNZLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxNQUFJLFlBQVksSUFBSSxVQUFrQixPQUN0QyxpQkFBaUIsS0FBSyxNQUFNLEdBQUcsR0FDL0IsS0FBSyxLQUFLLElBQUksU0FBUyxRQUN2QixLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsUUFBSTtBQUVBLFVBQUksSUFBSSxXQUFXLFFBQVEsS0FBSyxHQUFHO0FBQUEsSUFFdkMsUUFDTTtBQUNGLGNBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEIsTUFBTTtBQUFBLFFBQ04sUUFBUTtBQUFBLFFBQ1IsT0FBTyxRQUFRO0FBQUEsUUFDZjtBQUFBLFFBQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxNQUNuQixDQUFDO0FBQUEsSUFDTDtBQUFBLEVBQ0o7QUFDSixDQUFDLEdBQ1ksVUFBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBQzdFLE1BQUksWUFBWSxJQUFJLFVBQWtCLElBQUksSUFBSSxTQUFTLElBQ3ZELGlCQUFpQixLQUFLLE1BQU0sR0FBRyxHQUMvQixLQUFLLEtBQUssSUFBSSxTQUFTO0FBQzNCLENBQUMsR0FDWSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsTUFBSSxZQUFZLElBQUksVUFBa0IsU0FDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHO0FBQ25DLENBQUMsR0FDWSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsTUFBSSxZQUFZLElBQUksVUFBa0IsU0FDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHLEdBQy9CLEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixRQUFNLFFBQVEsUUFBUSxNQUFNLE1BQU0sR0FBRztBQUNyQyxRQUFJO0FBQ0EsVUFBSSxNQUFNLFdBQVc7QUFDakIsY0FBTSxJQUFJLE1BQU07QUFDcEIsVUFBTSxDQUFDLFNBQVMsTUFBTSxJQUFJO0FBQzFCLFVBQUksQ0FBQztBQUNELGNBQU0sSUFBSSxNQUFNO0FBQ3BCLFVBQU0sWUFBWSxPQUFPLE1BQU07QUFDL0IsVUFBSSxHQUFHLFNBQVMsT0FBTztBQUNuQixjQUFNLElBQUksTUFBTTtBQUNwQixVQUFJLFlBQVksS0FBSyxZQUFZO0FBQzdCLGNBQU0sSUFBSSxNQUFNO0FBRXBCLFVBQUksSUFBSSxXQUFXLE9BQU8sR0FBRztBQUFBLElBQ2pDLFFBQ007QUFDRixjQUFRLE9BQU8sS0FBSztBQUFBLFFBQ2hCLE1BQU07QUFBQSxRQUNOLFFBQVE7QUFBQSxRQUNSLE9BQU8sUUFBUTtBQUFBLFFBQ2Y7QUFBQSxRQUNBLFVBQVUsQ0FBQyxJQUFJO0FBQUEsTUFDbkIsQ0FBQztBQUFBLElBQ0w7QUFBQSxFQUNKO0FBQ0osQ0FBQztBQUVNLFNBQVMsY0FBYyxNQUFNO0FBQ2hDLE1BQUksU0FBUztBQUNULFdBQU87QUFDWCxNQUFJLEtBQUssU0FBUyxNQUFNO0FBQ3BCLFdBQU87QUFDWCxNQUFJO0FBRUEsZ0JBQUssSUFBSSxHQUNGO0FBQUEsRUFDWCxRQUNNO0FBQ0YsV0FBTztBQUFBLEVBQ1g7QUFDSjtBQUNPLElBQU0sYUFBMkIsZ0JBQUssYUFBYSxjQUFjLENBQUMsTUFBTSxRQUFRO0FBQ25GLE1BQUksWUFBWSxJQUFJLFVBQWtCLFNBQ3RDLGlCQUFpQixLQUFLLE1BQU0sR0FBRyxHQUMvQixLQUFLLEtBQUssSUFBSSxrQkFBa0IsVUFDaEMsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLElBQUksY0FBYyxRQUFRLEtBQUssS0FFL0IsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixPQUFPLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQztBQUVNLFNBQVMsaUJBQWlCLE1BQU07QUFDbkMsTUFBSSxDQUFTLFVBQVUsS0FBSyxJQUFJO0FBQzVCLFdBQU87QUFDWCxNQUFNQyxVQUFTLEtBQUssUUFBUSxTQUFTLENBQUMsTUFBTyxNQUFNLE1BQU0sTUFBTSxHQUFJLEdBQzdELFNBQVNBLFFBQU8sT0FBTyxLQUFLLEtBQUtBLFFBQU8sU0FBUyxDQUFDLElBQUksR0FBRyxHQUFHO0FBQ2xFLFNBQU8sY0FBYyxNQUFNO0FBQy9CO0FBQ08sSUFBTSxnQkFBOEIsZ0JBQUssYUFBYSxpQkFBaUIsQ0FBQyxNQUFNLFFBQVE7QUFDekYsTUFBSSxZQUFZLElBQUksVUFBa0IsWUFDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHLEdBQy9CLEtBQUssS0FBSyxJQUFJLGtCQUFrQixhQUNoQyxLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDM0IsSUFBSSxpQkFBaUIsUUFBUSxLQUFLLEtBRWxDLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLE1BQ1IsT0FBTyxRQUFRO0FBQUEsTUFDZjtBQUFBLE1BQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxJQUNuQixDQUFDO0FBQUEsRUFDTDtBQUNKLENBQUMsR0FDWSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsTUFBSSxZQUFZLElBQUksVUFBa0IsT0FDdEMsaUJBQWlCLEtBQUssTUFBTSxHQUFHO0FBQ25DLENBQUM7QUFFTSxTQUFTQyxZQUFXLE9BQU8sWUFBWSxNQUFNO0FBQ2hELE1BQUk7QUFDQSxRQUFNLGNBQWMsTUFBTSxNQUFNLEdBQUc7QUFDbkMsUUFBSSxZQUFZLFdBQVc7QUFDdkIsYUFBTztBQUNYLFFBQU0sQ0FBQyxNQUFNLElBQUk7QUFDakIsUUFBSSxDQUFDO0FBQ0QsYUFBTztBQUVYLFFBQU0sZUFBZSxLQUFLLE1BQU0sS0FBSyxNQUFNLENBQUM7QUFLNUMsV0FKSSxXQUFTLGdCQUFnQixjQUFjLFFBQVEsU0FFL0MsQ0FBQyxhQUFhLE9BRWQsY0FBYyxFQUFFLFNBQVMsaUJBQWlCLGFBQWEsUUFBUTtBQUFBLEVBR3ZFLFFBQ007QUFDRixXQUFPO0FBQUEsRUFDWDtBQUNKO0FBQ08sSUFBTSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsbUJBQWlCLEtBQUssTUFBTSxHQUFHLEdBQy9CLEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixJQUFJQSxZQUFXLFFBQVEsT0FBTyxJQUFJLEdBQUcsS0FFckMsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixNQUFNO0FBQUEsTUFDTixRQUFRO0FBQUEsTUFDUixPQUFPLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQSxVQUFVLENBQUMsSUFBSTtBQUFBLElBQ25CLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQyxHQUNZLHlCQUF1QyxnQkFBSyxhQUFhLDBCQUEwQixDQUFDLE1BQU0sUUFBUTtBQUMzRyxtQkFBaUIsS0FBSyxNQUFNLEdBQUcsR0FDL0IsS0FBSyxLQUFLLFFBQVEsQ0FBQyxZQUFZO0FBQzNCLElBQUksSUFBSSxHQUFHLFFBQVEsS0FBSyxLQUV4QixRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLE1BQU07QUFBQSxNQUNOLFFBQVEsSUFBSTtBQUFBLE1BQ1osT0FBTyxRQUFRO0FBQUEsTUFDZjtBQUFBLE1BQ0EsVUFBVSxDQUFDLElBQUk7QUFBQSxJQUNuQixDQUFDO0FBQUEsRUFDTDtBQUNKLENBQUMsR0FDWSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssVUFBVSxLQUFLLEtBQUssSUFBSSxXQUFtQixRQUNyRCxLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsU0FBUztBQUNqQyxRQUFJLElBQUk7QUFDSixVQUFJO0FBQ0EsZ0JBQVEsUUFBUSxPQUFPLFFBQVEsS0FBSztBQUFBLE1BQ3hDLFFBQ1U7QUFBQSxNQUFFO0FBQ2hCLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFFBQUksT0FBTyxTQUFVLFlBQVksQ0FBQyxPQUFPLE1BQU0sS0FBSyxLQUFLLE9BQU8sU0FBUyxLQUFLO0FBQzFFLGFBQU87QUFFWCxRQUFNLFdBQVcsT0FBTyxTQUFVLFdBQzVCLE9BQU8sTUFBTSxLQUFLLElBQ2QsUUFDQyxPQUFPLFNBQVMsS0FBSyxJQUVsQixTQURBLGFBRVI7QUFDTixtQkFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxNQUNBLEdBQUksV0FBVyxFQUFFLFNBQVMsSUFBSSxDQUFDO0FBQUEsSUFDbkMsQ0FBQyxHQUNNO0FBQUEsRUFDWDtBQUNKLENBQUMsR0FDWSxtQkFBaUMsZ0JBQUssYUFBYSxvQkFBb0IsQ0FBQyxNQUFNLFFBQVE7QUFDL0YsRUFBTyxzQkFBc0IsS0FBSyxNQUFNLEdBQUcsR0FDM0MsV0FBVyxLQUFLLE1BQU0sR0FBRztBQUM3QixDQUFDLEdBQ1ksY0FBNEIsZ0JBQUssYUFBYSxlQUFlLENBQUMsTUFBTSxRQUFRO0FBQ3JGLFdBQVMsS0FBSyxNQUFNLEdBQUcsR0FDdkIsS0FBSyxLQUFLLFVBQWtCLFNBQzVCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxTQUFTO0FBQ2pDLFFBQUksSUFBSTtBQUNKLFVBQUk7QUFDQSxnQkFBUSxRQUFRLEVBQVEsUUFBUTtBQUFBLE1BQ3BDLFFBQ1U7QUFBQSxNQUFFO0FBQ2hCLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFdBQUksT0FBTyxTQUFVLGFBRXJCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLGFBQTJCLGdCQUFLLGFBQWEsY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUNuRixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxVQUFrQixRQUM1QixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsU0FBUztBQUNqQyxRQUFJLElBQUk7QUFDSixVQUFJO0FBQ0EsZ0JBQVEsUUFBUSxPQUFPLFFBQVEsS0FBSztBQUFBLE1BQ3hDLFFBQ1U7QUFBQSxNQUFFO0FBQ2hCLFdBQUksT0FBTyxRQUFRLFNBQVUsWUFFN0IsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixVQUFVO0FBQUEsTUFDVixNQUFNO0FBQUEsTUFDTixPQUFPLFFBQVE7QUFBQSxNQUNmO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLG1CQUFpQyxnQkFBSyxhQUFhLG9CQUFvQixDQUFDLE1BQU0sUUFBUTtBQUMvRixFQUFPLHNCQUFzQixLQUFLLE1BQU0sR0FBRyxHQUMzQyxXQUFXLEtBQUssTUFBTSxHQUFHO0FBQzdCLENBQUMsR0FDWSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsU0FBUztBQUNqQyxRQUFNLFFBQVEsUUFBUTtBQUN0QixXQUFJLE9BQU8sU0FBVSxZQUVyQixRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFVBQVU7QUFBQSxNQUNWLE1BQU07QUFBQSxNQUNOO0FBQUEsTUFDQTtBQUFBLElBQ0osQ0FBQyxHQUNNO0FBQUEsRUFDWDtBQUNKLENBQUMsR0FDWSxnQkFBOEIsZ0JBQUssYUFBYSxpQkFBaUIsQ0FBQyxNQUFNLFFBQVE7QUFDekYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssVUFBa0IsWUFDNUIsS0FBSyxLQUFLLFNBQVMsb0JBQUksSUFBSSxDQUFDLE1BQVMsQ0FBQyxHQUN0QyxLQUFLLEtBQUssUUFBUSxZQUNsQixLQUFLLEtBQUssU0FBUyxZQUNuQixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsU0FBUztBQUNqQyxRQUFNLFFBQVEsUUFBUTtBQUN0QixXQUFJLE9BQU8sUUFBVSxPQUVyQixRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFVBQVU7QUFBQSxNQUNWLE1BQU07QUFBQSxNQUNOO0FBQUEsTUFDQTtBQUFBLElBQ0osQ0FBQyxHQUNNO0FBQUEsRUFDWDtBQUNKLENBQUMsR0FDWSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssVUFBa0IsT0FDNUIsS0FBSyxLQUFLLFNBQVMsb0JBQUksSUFBSSxDQUFDLElBQUksQ0FBQyxHQUNqQyxLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsU0FBUztBQUNqQyxRQUFNLFFBQVEsUUFBUTtBQUN0QixXQUFJLFVBQVUsUUFFZCxRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLFVBQVU7QUFBQSxNQUNWLE1BQU07QUFBQSxNQUNOO0FBQUEsTUFDQTtBQUFBLElBQ0osQ0FBQyxHQUNNO0FBQUEsRUFDWDtBQUNKLENBQUMsR0FDWSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssUUFBUSxDQUFDLFlBQVk7QUFDbkMsQ0FBQyxHQUNZLGNBQTRCLGdCQUFLLGFBQWEsZUFBZSxDQUFDLE1BQU0sUUFBUTtBQUNyRixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUNuQyxDQUFDLEdBQ1ksWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLFdBQVMsS0FBSyxNQUFNLEdBQUcsR0FDdkIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFVBQ3hCLFFBQVEsT0FBTyxLQUFLO0FBQUEsSUFDaEIsVUFBVTtBQUFBLElBQ1YsTUFBTTtBQUFBLElBQ04sT0FBTyxRQUFRO0FBQUEsSUFDZjtBQUFBLEVBQ0osQ0FBQyxHQUNNO0FBRWYsQ0FBQyxHQUNZLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxTQUFTO0FBQ2pDLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFdBQUksT0FBTyxRQUFVLE9BRXJCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxTQUFTO0FBQ2pDLFFBQUksSUFBSTtBQUNKLFVBQUk7QUFDQSxnQkFBUSxRQUFRLElBQUksS0FBSyxRQUFRLEtBQUs7QUFBQSxNQUMxQyxRQUNhO0FBQUEsTUFBRTtBQUVuQixRQUFNLFFBQVEsUUFBUSxPQUNoQixTQUFTLGlCQUFpQjtBQUVoQyxXQURvQixVQUFVLENBQUMsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFDLEtBRzNELFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBLEdBQUksU0FBUyxFQUFFLFVBQVUsZUFBZSxJQUFJLENBQUM7QUFBQSxNQUM3QztBQUFBLElBQ0osQ0FBQyxHQUNNO0FBQUEsRUFDWDtBQUNKLENBQUM7QUFDRCxTQUFTLGtCQUFrQixRQUFRLE9BQU8sT0FBTztBQUM3QyxFQUFJLE9BQU8sT0FBTyxVQUNkLE1BQU0sT0FBTyxLQUFLLEdBQVEsYUFBYSxPQUFPLE9BQU8sTUFBTSxDQUFDLEdBRWhFLE1BQU0sTUFBTSxLQUFLLElBQUksT0FBTztBQUNoQztBQUNPLElBQU0sWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLFdBQVMsS0FBSyxNQUFNLEdBQUcsR0FDdkIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDaEMsUUFBTSxRQUFRLFFBQVE7QUFDdEIsUUFBSSxDQUFDLE1BQU0sUUFBUSxLQUFLO0FBQ3BCLHFCQUFRLE9BQU8sS0FBSztBQUFBLFFBQ2hCLFVBQVU7QUFBQSxRQUNWLE1BQU07QUFBQSxRQUNOO0FBQUEsUUFDQTtBQUFBLE1BQ0osQ0FBQyxHQUNNO0FBRVgsWUFBUSxRQUFRLE1BQU0sTUFBTSxNQUFNO0FBQ2xDLFFBQU0sUUFBUSxDQUFDO0FBQ2YsYUFBUyxJQUFJLEdBQUcsSUFBSSxNQUFNLFFBQVEsS0FBSztBQUNuQyxVQUFNLE9BQU8sTUFBTSxDQUFDLEdBQ2QsU0FBUyxJQUFJLFFBQVEsS0FBSyxJQUFJO0FBQUEsUUFDaEMsT0FBTztBQUFBLFFBQ1AsUUFBUSxDQUFDO0FBQUEsTUFDYixHQUFHLEdBQUc7QUFDTixNQUFJLGtCQUFrQixVQUNsQixNQUFNLEtBQUssT0FBTyxLQUFLLENBQUNILFlBQVcsa0JBQWtCQSxTQUFRLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFHekUsa0JBQWtCLFFBQVEsU0FBUyxDQUFDO0FBQUEsSUFFNUM7QUFDQSxXQUFJLE1BQU0sU0FDQyxRQUFRLElBQUksS0FBSyxFQUFFLEtBQUssTUFBTSxPQUFPLElBRXpDO0FBQUEsRUFDWDtBQUNKLENBQUM7QUFDRCxTQUFTLHFCQUFxQixRQUFRLE9BQU8sS0FBSyxPQUFPLGVBQWU7QUFDcEUsTUFBSSxPQUFPLE9BQU8sUUFBUTtBQUV0QixRQUFJLGlCQUFpQixFQUFFLE9BQU87QUFDMUI7QUFFSixVQUFNLE9BQU8sS0FBSyxHQUFRLGFBQWEsS0FBSyxPQUFPLE1BQU0sQ0FBQztBQUFBLEVBQzlEO0FBQ0EsRUFBSSxPQUFPLFVBQVUsU0FDYixPQUFPLFVBQ1AsTUFBTSxNQUFNLEdBQUcsSUFBSSxVQUl2QixNQUFNLE1BQU0sR0FBRyxJQUFJLE9BQU87QUFFbEM7QUFDQSxTQUFTLGFBQWEsS0FBSztBQUN2QixNQUFNLE9BQU8sT0FBTyxLQUFLLElBQUksS0FBSztBQUNsQyxXQUFXLEtBQUs7QUFDWixRQUFJLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRyxNQUFNLFFBQVEsSUFBSSxVQUFVO0FBQzdDLFlBQU0sSUFBSSxNQUFNLDJCQUEyQixDQUFDLDBCQUEwQjtBQUc5RSxNQUFNLFFBQWEsYUFBYSxJQUFJLEtBQUs7QUFDekMsU0FBTztBQUFBLElBQ0gsR0FBRztBQUFBLElBQ0g7QUFBQSxJQUNBLFFBQVEsSUFBSSxJQUFJLElBQUk7QUFBQSxJQUNwQixTQUFTLEtBQUs7QUFBQSxJQUNkLGNBQWMsSUFBSSxJQUFJLEtBQUs7QUFBQSxFQUMvQjtBQUNKO0FBQ0EsU0FBUyxlQUFlLE9BQU8sT0FBTyxTQUFTLEtBQUssS0FBSyxNQUFNO0FBQzNELE1BQU0sZUFBZSxDQUFDLEdBRWhCLFNBQVMsSUFBSSxRQUNiLFlBQVksSUFBSSxTQUFTLE1BQ3pCLElBQUksVUFBVSxJQUFJLE1BQ2xCLGdCQUFnQixVQUFVLFdBQVc7QUFDM0MsV0FBVyxPQUFPLE9BQU87QUFDckIsUUFBSSxPQUFPLElBQUksR0FBRztBQUNkO0FBQ0osUUFBSSxNQUFNLFNBQVM7QUFDZixtQkFBYSxLQUFLLEdBQUc7QUFDckI7QUFBQSxJQUNKO0FBQ0EsUUFBTSxJQUFJLFVBQVUsSUFBSSxFQUFFLE9BQU8sTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBQzlELElBQUksYUFBYSxVQUNiLE1BQU0sS0FBSyxFQUFFLEtBQUssQ0FBQ0ksT0FBTSxxQkFBcUJBLElBQUcsU0FBUyxLQUFLLE9BQU8sYUFBYSxDQUFDLENBQUMsSUFHckYscUJBQXFCLEdBQUcsU0FBUyxLQUFLLE9BQU8sYUFBYTtBQUFBLEVBRWxFO0FBU0EsU0FSSSxhQUFhLFVBQ2IsUUFBUSxPQUFPLEtBQUs7QUFBQSxJQUNoQixNQUFNO0FBQUEsSUFDTixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxFQUNKLENBQUMsR0FFQSxNQUFNLFNBRUosUUFBUSxJQUFJLEtBQUssRUFBRSxLQUFLLE1BQ3BCLE9BQ1YsSUFIVTtBQUlmO0FBQ08sSUFBTSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFLbkYsTUFIQSxTQUFTLEtBQUssTUFBTSxHQUFHLEdBR25CLENBRFMsT0FBTyx5QkFBeUIsS0FBSyxPQUFPLEdBQzlDLEtBQUs7QUFDWixRQUFNLEtBQUssSUFBSTtBQUNmLFdBQU8sZUFBZSxLQUFLLFNBQVM7QUFBQSxNQUNoQyxLQUFLLE1BQU07QUFDUCxZQUFNLFFBQVEsRUFBRSxHQUFHLEdBQUc7QUFDdEIsc0JBQU8sZUFBZSxLQUFLLFNBQVM7QUFBQSxVQUNoQyxPQUFPO0FBQUEsUUFDWCxDQUFDLEdBQ007QUFBQSxNQUNYO0FBQUEsSUFDSixDQUFDO0FBQUEsRUFDTDtBQUNBLE1BQU0sY0FBbUIsT0FBTyxNQUFNLGFBQWEsR0FBRyxDQUFDO0FBQ3ZELEVBQUssV0FBVyxLQUFLLE1BQU0sY0FBYyxNQUFNO0FBQzNDLFFBQU0sUUFBUSxJQUFJLE9BQ1osYUFBYSxDQUFDO0FBQ3BCLGFBQVcsT0FBTyxPQUFPO0FBQ3JCLFVBQU0sUUFBUSxNQUFNLEdBQUcsRUFBRTtBQUN6QixVQUFJLE1BQU0sUUFBUTtBQUNkLG1CQUFXLEdBQUcsTUFBTSxXQUFXLEdBQUcsSUFBSSxvQkFBSSxJQUFJO0FBQzlDLGlCQUFXLEtBQUssTUFBTTtBQUNsQixxQkFBVyxHQUFHLEVBQUUsSUFBSSxDQUFDO0FBQUEsTUFDN0I7QUFBQSxJQUNKO0FBQ0EsV0FBTztBQUFBLEVBQ1gsQ0FBQztBQUNELE1BQU1DLFlBQWdCLFVBQ2hCLFdBQVcsSUFBSSxVQUNqQjtBQUNKLE9BQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLGNBQVUsUUFBUSxZQUFZO0FBQzlCLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFFBQUksQ0FBQ0EsVUFBUyxLQUFLO0FBQ2YscUJBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEIsVUFBVTtBQUFBLFFBQ1YsTUFBTTtBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsTUFDSixDQUFDLEdBQ007QUFFWCxZQUFRLFFBQVEsQ0FBQztBQUNqQixRQUFNLFFBQVEsQ0FBQyxHQUNULFFBQVEsTUFBTTtBQUNwQixhQUFXLE9BQU8sTUFBTSxNQUFNO0FBQzFCLFVBQU0sS0FBSyxNQUFNLEdBQUcsR0FDZCxnQkFBZ0IsR0FBRyxLQUFLLFdBQVcsWUFDbkMsSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFLE9BQU8sTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBQzVELE1BQUksYUFBYSxVQUNiLE1BQU0sS0FBSyxFQUFFLEtBQUssQ0FBQ0QsT0FBTSxxQkFBcUJBLElBQUcsU0FBUyxLQUFLLE9BQU8sYUFBYSxDQUFDLENBQUMsSUFHckYscUJBQXFCLEdBQUcsU0FBUyxLQUFLLE9BQU8sYUFBYTtBQUFBLElBRWxFO0FBQ0EsV0FBSyxXQUdFLGVBQWUsT0FBTyxPQUFPLFNBQVMsS0FBSyxZQUFZLE9BQU8sSUFBSSxJQUY5RCxNQUFNLFNBQVMsUUFBUSxJQUFJLEtBQUssRUFBRSxLQUFLLE1BQU0sT0FBTyxJQUFJO0FBQUEsRUFHdkU7QUFDSixDQUFDLEdBQ1ksZ0JBQThCLGdCQUFLLGFBQWEsaUJBQWlCLENBQUMsTUFBTSxRQUFRO0FBRXpGLGFBQVcsS0FBSyxNQUFNLEdBQUc7QUFDekIsTUFBTSxhQUFhLEtBQUssS0FBSyxPQUN2QixjQUFtQixPQUFPLE1BQU0sYUFBYSxHQUFHLENBQUMsR0FDakQsbUJBQW1CLENBQUMsVUFBVTtBQUNoQyxRQUFNLE1BQU0sSUFBSSxJQUFJLENBQUMsU0FBUyxXQUFXLEtBQUssQ0FBQyxHQUN6QyxhQUFhLFlBQVksT0FDekIsV0FBVyxDQUFDLFFBQVE7QUFDdEIsVUFBTSxJQUFTLElBQUksR0FBRztBQUN0QixhQUFPLFNBQVMsQ0FBQyw2QkFBNkIsQ0FBQztBQUFBLElBQ25EO0FBQ0EsUUFBSSxNQUFNLDhCQUE4QjtBQUN4QyxRQUFNLE1BQU0sdUJBQU8sT0FBTyxJQUFJLEdBQzFCLFVBQVU7QUFDZCxhQUFXLE9BQU8sV0FBVztBQUN6QixVQUFJLEdBQUcsSUFBSSxPQUFPLFNBQVM7QUFHL0IsUUFBSSxNQUFNLHVCQUF1QjtBQUNqQyxhQUFXLE9BQU8sV0FBVyxNQUFNO0FBQy9CLFVBQU0sS0FBSyxJQUFJLEdBQUcsR0FDWixJQUFTLElBQUksR0FBRyxHQUVoQixnQkFEUyxNQUFNLEdBQUcsR0FDTSxNQUFNLFdBQVc7QUFDL0MsVUFBSSxNQUFNLFNBQVMsRUFBRSxNQUFNLFNBQVMsR0FBRyxDQUFDLEdBQUcsR0FDdkMsZ0JBRUEsSUFBSSxNQUFNO0FBQUEsY0FDWixFQUFFO0FBQUEsZ0JBQ0EsQ0FBQztBQUFBLHFEQUNvQyxFQUFFO0FBQUE7QUFBQSxrQ0FFckIsQ0FBQyxxQkFBcUIsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FLM0MsRUFBRTtBQUFBLGdCQUNBLENBQUM7QUFBQSx3QkFDTyxDQUFDO0FBQUE7QUFBQTtBQUFBLHNCQUdILENBQUMsT0FBTyxFQUFFO0FBQUE7QUFBQTtBQUFBLE9BR3pCLElBR1MsSUFBSSxNQUFNO0FBQUEsY0FDWixFQUFFO0FBQUEsbURBQ21DLEVBQUU7QUFBQTtBQUFBLGdDQUVyQixDQUFDLHFCQUFxQixDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FJekMsRUFBRTtBQUFBLGdCQUNBLENBQUM7QUFBQSx3QkFDTyxDQUFDO0FBQUE7QUFBQTtBQUFBLHNCQUdILENBQUMsT0FBTyxFQUFFO0FBQUE7QUFBQTtBQUFBLE9BR3pCO0FBQUEsSUFFQztBQUNBLFFBQUksTUFBTSw0QkFBNEIsR0FDdEMsSUFBSSxNQUFNLGlCQUFpQjtBQUMzQixRQUFNLEtBQUssSUFBSSxRQUFRO0FBQ3ZCLFdBQU8sQ0FBQyxTQUFTLFFBQVEsR0FBRyxPQUFPLFNBQVMsR0FBRztBQUFBLEVBQ25ELEdBQ0ksVUFDRUMsWUFBZ0IsVUFDaEIsTUFBTSxDQUFNLGFBQWEsU0FFekIsY0FBYyxPQURJLFdBQ2MsT0FDaEMsV0FBVyxJQUFJLFVBQ2pCO0FBQ0osT0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDaEMsY0FBVSxRQUFRLFlBQVk7QUFDOUIsUUFBTSxRQUFRLFFBQVE7QUFDdEIsV0FBS0EsVUFBUyxLQUFLLElBU2YsT0FBTyxlQUFlLEtBQUssVUFBVSxNQUFTLElBQUksWUFBWSxNQUV6RCxhQUNELFdBQVcsaUJBQWlCLElBQUksS0FBSyxJQUN6QyxVQUFVLFNBQVMsU0FBUyxHQUFHLEdBQzFCLFdBRUUsZUFBZSxDQUFDLEdBQUcsT0FBTyxTQUFTLEtBQUssT0FBTyxJQUFJLElBRC9DLFdBR1IsV0FBVyxTQUFTLEdBQUcsS0FqQjFCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQVlmO0FBQ0osQ0FBQztBQUNELFNBQVMsbUJBQW1CLFNBQVMsT0FBTyxNQUFNLEtBQUs7QUFDbkQsV0FBVyxVQUFVO0FBQ2pCLFFBQUksT0FBTyxPQUFPLFdBQVc7QUFDekIsbUJBQU0sUUFBUSxPQUFPLE9BQ2Q7QUFHZixNQUFNLGFBQWEsUUFBUSxPQUFPLENBQUMsTUFBTSxDQUFNLFFBQVEsQ0FBQyxDQUFDO0FBQ3pELFNBQUksV0FBVyxXQUFXLEtBQ3RCLE1BQU0sUUFBUSxXQUFXLENBQUMsRUFBRSxPQUNyQixXQUFXLENBQUMsTUFFdkIsTUFBTSxPQUFPLEtBQUs7QUFBQSxJQUNkLE1BQU07QUFBQSxJQUNOLE9BQU8sTUFBTTtBQUFBLElBQ2I7QUFBQSxJQUNBLFFBQVEsUUFBUSxJQUFJLENBQUMsV0FBVyxPQUFPLE9BQU8sSUFBSSxDQUFDLFFBQWEsY0FBYyxLQUFLLEtBQVUsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUFBLEVBQzNHLENBQUMsR0FDTTtBQUNYO0FBQ08sSUFBTSxZQUEwQixnQkFBSyxhQUFhLGFBQWEsQ0FBQyxNQUFNLFFBQVE7QUFDakYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUNsQixXQUFXLEtBQUssTUFBTSxTQUFTLE1BQU0sSUFBSSxRQUFRLEtBQUssQ0FBQyxNQUFNLEVBQUUsS0FBSyxVQUFVLFVBQVUsSUFBSSxhQUFhLE1BQVMsR0FDbEgsV0FBVyxLQUFLLE1BQU0sVUFBVSxNQUFNLElBQUksUUFBUSxLQUFLLENBQUMsTUFBTSxFQUFFLEtBQUssV0FBVyxVQUFVLElBQUksYUFBYSxNQUFTLEdBQ3BILFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTTtBQUN2QyxRQUFJLElBQUksUUFBUSxNQUFNLENBQUMsTUFBTSxFQUFFLEtBQUssTUFBTTtBQUN0QyxhQUFPLElBQUksSUFBSSxJQUFJLFFBQVEsUUFBUSxDQUFDLFdBQVcsTUFBTSxLQUFLLE9BQU8sS0FBSyxNQUFNLENBQUMsQ0FBQztBQUFBLEVBR3RGLENBQUMsR0FDSSxXQUFXLEtBQUssTUFBTSxXQUFXLE1BQU07QUFDeEMsUUFBSSxJQUFJLFFBQVEsTUFBTSxDQUFDLE1BQU0sRUFBRSxLQUFLLE9BQU8sR0FBRztBQUMxQyxVQUFNLFdBQVcsSUFBSSxRQUFRLElBQUksQ0FBQyxNQUFNLEVBQUUsS0FBSyxPQUFPO0FBQ3RELGFBQU8sSUFBSSxPQUFPLEtBQUssU0FBUyxJQUFJLENBQUMsTUFBVyxXQUFXLEVBQUUsTUFBTSxDQUFDLEVBQUUsS0FBSyxHQUFHLENBQUMsSUFBSTtBQUFBLElBQ3ZGO0FBQUEsRUFFSixDQUFDO0FBQ0QsTUFBTSxTQUFTLElBQUksUUFBUSxXQUFXLEdBQ2hDLFFBQVEsSUFBSSxRQUFRLENBQUMsRUFBRSxLQUFLO0FBQ2xDLE9BQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLFFBQUk7QUFDQSxhQUFPLE1BQU0sU0FBUyxHQUFHO0FBRTdCLFFBQUksUUFBUSxJQUNOLFVBQVUsQ0FBQztBQUNqQixhQUFXLFVBQVUsSUFBSSxTQUFTO0FBQzlCLFVBQU0sU0FBUyxPQUFPLEtBQUssSUFBSTtBQUFBLFFBQzNCLE9BQU8sUUFBUTtBQUFBLFFBQ2YsUUFBUSxDQUFDO0FBQUEsTUFDYixHQUFHLEdBQUc7QUFDTixVQUFJLGtCQUFrQjtBQUNsQixnQkFBUSxLQUFLLE1BQU0sR0FDbkIsUUFBUTtBQUFBLFdBRVA7QUFDRCxZQUFJLE9BQU8sT0FBTyxXQUFXO0FBQ3pCLGlCQUFPO0FBQ1gsZ0JBQVEsS0FBSyxNQUFNO0FBQUEsTUFDdkI7QUFBQSxJQUNKO0FBQ0EsV0FBSyxRQUVFLFFBQVEsSUFBSSxPQUFPLEVBQUUsS0FBSyxDQUFDQyxhQUN2QixtQkFBbUJBLFVBQVMsU0FBUyxNQUFNLEdBQUcsQ0FDeEQsSUFIVSxtQkFBbUIsU0FBUyxTQUFTLE1BQU0sR0FBRztBQUFBLEVBSTdEO0FBQ0osQ0FBQztBQUNELFNBQVMsNEJBQTRCLFNBQVMsT0FBTyxNQUFNLEtBQUs7QUFDNUQsTUFBTSxZQUFZLFFBQVEsT0FBTyxDQUFDLE1BQU0sRUFBRSxPQUFPLFdBQVcsQ0FBQztBQUM3RCxTQUFJLFVBQVUsV0FBVyxLQUNyQixNQUFNLFFBQVEsVUFBVSxDQUFDLEVBQUUsT0FDcEIsVUFFUCxVQUFVLFdBQVcsSUFFckIsTUFBTSxPQUFPLEtBQUs7QUFBQSxJQUNkLE1BQU07QUFBQSxJQUNOLE9BQU8sTUFBTTtBQUFBLElBQ2I7QUFBQSxJQUNBLFFBQVEsUUFBUSxJQUFJLENBQUMsV0FBVyxPQUFPLE9BQU8sSUFBSSxDQUFDLFFBQWEsY0FBYyxLQUFLLEtBQVUsT0FBTyxDQUFDLENBQUMsQ0FBQztBQUFBLEVBQzNHLENBQUMsSUFJRCxNQUFNLE9BQU8sS0FBSztBQUFBLElBQ2QsTUFBTTtBQUFBLElBQ04sT0FBTyxNQUFNO0FBQUEsSUFDYjtBQUFBLElBQ0EsUUFBUSxDQUFDO0FBQUEsSUFDVCxXQUFXO0FBQUEsRUFDZixDQUFDLEdBRUU7QUFDWDtBQUNPLElBQU0sVUFBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBQzdFLFlBQVUsS0FBSyxNQUFNLEdBQUcsR0FDeEIsSUFBSSxZQUFZO0FBQ2hCLE1BQU0sU0FBUyxJQUFJLFFBQVEsV0FBVyxHQUNoQyxRQUFRLElBQUksUUFBUSxDQUFDLEVBQUUsS0FBSztBQUNsQyxPQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUNoQyxRQUFJO0FBQ0EsYUFBTyxNQUFNLFNBQVMsR0FBRztBQUU3QixRQUFJLFFBQVEsSUFDTixVQUFVLENBQUM7QUFDakIsYUFBVyxVQUFVLElBQUksU0FBUztBQUM5QixVQUFNLFNBQVMsT0FBTyxLQUFLLElBQUk7QUFBQSxRQUMzQixPQUFPLFFBQVE7QUFBQSxRQUNmLFFBQVEsQ0FBQztBQUFBLE1BQ2IsR0FBRyxHQUFHO0FBQ04sTUFBSSxrQkFBa0IsV0FDbEIsUUFBUSxLQUFLLE1BQU0sR0FDbkIsUUFBUSxNQUdSLFFBQVEsS0FBSyxNQUFNO0FBQUEsSUFFM0I7QUFDQSxXQUFLLFFBRUUsUUFBUSxJQUFJLE9BQU8sRUFBRSxLQUFLLENBQUNBLGFBQ3ZCLDRCQUE0QkEsVUFBUyxTQUFTLE1BQU0sR0FBRyxDQUNqRSxJQUhVLDRCQUE0QixTQUFTLFNBQVMsTUFBTSxHQUFHO0FBQUEsRUFJdEU7QUFDSixDQUFDLEdBQ1kseUJBRWIsZ0JBQUssYUFBYSwwQkFBMEIsQ0FBQyxNQUFNLFFBQVE7QUFDdkQsTUFBSSxZQUFZLElBQ2hCLFVBQVUsS0FBSyxNQUFNLEdBQUc7QUFDeEIsTUFBTSxTQUFTLEtBQUssS0FBSztBQUN6QixFQUFLLFdBQVcsS0FBSyxNQUFNLGNBQWMsTUFBTTtBQUMzQyxRQUFNLGFBQWEsQ0FBQztBQUNwQixhQUFXLFVBQVUsSUFBSSxTQUFTO0FBQzlCLFVBQU0sS0FBSyxPQUFPLEtBQUs7QUFDdkIsVUFBSSxDQUFDLE1BQU0sT0FBTyxLQUFLLEVBQUUsRUFBRSxXQUFXO0FBQ2xDLGNBQU0sSUFBSSxNQUFNLGdEQUFnRCxJQUFJLFFBQVEsUUFBUSxNQUFNLENBQUMsR0FBRztBQUNsRyxlQUFXLENBQUMsR0FBRyxDQUFDLEtBQUssT0FBTyxRQUFRLEVBQUUsR0FBRztBQUNyQyxRQUFLLFdBQVcsQ0FBQyxNQUNiLFdBQVcsQ0FBQyxJQUFJLG9CQUFJLElBQUk7QUFDNUIsaUJBQVcsT0FBTztBQUNkLHFCQUFXLENBQUMsRUFBRSxJQUFJLEdBQUc7QUFBQSxNQUU3QjtBQUFBLElBQ0o7QUFDQSxXQUFPO0FBQUEsRUFDWCxDQUFDO0FBQ0QsTUFBTSxPQUFZLE9BQU8sTUFBTTtBQUMzQixRQUFNLE9BQU8sSUFBSSxTQUNYQyxPQUFNLG9CQUFJLElBQUk7QUFDcEIsYUFBVyxLQUFLLE1BQU07QUFDbEIsVUFBTSxTQUFTLEVBQUUsS0FBSyxhQUFhLElBQUksYUFBYTtBQUNwRCxVQUFJLENBQUMsVUFBVSxPQUFPLFNBQVM7QUFDM0IsY0FBTSxJQUFJLE1BQU0sZ0RBQWdELElBQUksUUFBUSxRQUFRLENBQUMsQ0FBQyxHQUFHO0FBQzdGLGVBQVcsS0FBSyxRQUFRO0FBQ3BCLFlBQUlBLEtBQUksSUFBSSxDQUFDO0FBQ1QsZ0JBQU0sSUFBSSxNQUFNLGtDQUFrQyxPQUFPLENBQUMsQ0FBQyxHQUFHO0FBRWxFLFFBQUFBLEtBQUksSUFBSSxHQUFHLENBQUM7QUFBQSxNQUNoQjtBQUFBLElBQ0o7QUFDQSxXQUFPQTtBQUFBLEVBQ1gsQ0FBQztBQUNELE9BQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFFBQUksQ0FBTSxTQUFTLEtBQUs7QUFDcEIscUJBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEIsTUFBTTtBQUFBLFFBQ04sVUFBVTtBQUFBLFFBQ1Y7QUFBQSxRQUNBO0FBQUEsTUFDSixDQUFDLEdBQ007QUFFWCxRQUFNLE1BQU0sS0FBSyxNQUFNLElBQUksUUFBUSxJQUFJLGFBQWEsQ0FBQztBQUNyRCxXQUFJLE1BQ08sSUFBSSxLQUFLLElBQUksU0FBUyxHQUFHLElBRWhDLElBQUksZ0JBQ0csT0FBTyxTQUFTLEdBQUcsS0FHOUIsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixNQUFNO0FBQUEsTUFDTixRQUFRLENBQUM7QUFBQSxNQUNULE1BQU07QUFBQSxNQUNOLGVBQWUsSUFBSTtBQUFBLE1BQ25CO0FBQUEsTUFDQSxNQUFNLENBQUMsSUFBSSxhQUFhO0FBQUEsTUFDeEI7QUFBQSxJQUNKLENBQUMsR0FDTTtBQUFBLEVBQ1g7QUFDSixDQUFDLEdBQ1ksbUJBQWlDLGdCQUFLLGFBQWEsb0JBQW9CLENBQUMsTUFBTSxRQUFRO0FBQy9GLFdBQVMsS0FBSyxNQUFNLEdBQUcsR0FDdkIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDaEMsUUFBTSxRQUFRLFFBQVEsT0FDaEIsT0FBTyxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUUsT0FBTyxPQUFPLFFBQVEsQ0FBQyxFQUFFLEdBQUcsR0FBRyxHQUMxRCxRQUFRLElBQUksTUFBTSxLQUFLLElBQUksRUFBRSxPQUFPLE9BQU8sUUFBUSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBRWxFLFdBRGMsZ0JBQWdCLFdBQVcsaUJBQWlCLFVBRS9DLFFBQVEsSUFBSSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUNDLE9BQU1DLE1BQUssTUFDekMsMEJBQTBCLFNBQVNELE9BQU1DLE1BQUssQ0FDeEQsSUFFRSwwQkFBMEIsU0FBUyxNQUFNLEtBQUs7QUFBQSxFQUN6RDtBQUNKLENBQUM7QUFDRCxTQUFTQyxhQUFZLEdBQUcsR0FBRztBQUd2QixNQUFJLE1BQU07QUFDTixXQUFPLEVBQUUsT0FBTyxJQUFNLE1BQU0sRUFBRTtBQUVsQyxNQUFJLGFBQWEsUUFBUSxhQUFhLFFBQVEsQ0FBQyxLQUFNLENBQUM7QUFDbEQsV0FBTyxFQUFFLE9BQU8sSUFBTSxNQUFNLEVBQUU7QUFFbEMsTUFBUyxjQUFjLENBQUMsS0FBVSxjQUFjLENBQUMsR0FBRztBQUNoRCxRQUFNLFFBQVEsT0FBTyxLQUFLLENBQUMsR0FDckIsYUFBYSxPQUFPLEtBQUssQ0FBQyxFQUFFLE9BQU8sQ0FBQyxRQUFRLE1BQU0sUUFBUSxHQUFHLE1BQU0sRUFBRSxHQUNyRSxTQUFTLEVBQUUsR0FBRyxHQUFHLEdBQUcsRUFBRTtBQUM1QixhQUFXLE9BQU8sWUFBWTtBQUMxQixVQUFNLGNBQWNBLGFBQVksRUFBRSxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQUM7QUFDOUMsVUFBSSxDQUFDLFlBQVk7QUFDYixlQUFPO0FBQUEsVUFDSCxPQUFPO0FBQUEsVUFDUCxnQkFBZ0IsQ0FBQyxLQUFLLEdBQUcsWUFBWSxjQUFjO0FBQUEsUUFDdkQ7QUFFSixhQUFPLEdBQUcsSUFBSSxZQUFZO0FBQUEsSUFDOUI7QUFDQSxXQUFPLEVBQUUsT0FBTyxJQUFNLE1BQU0sT0FBTztBQUFBLEVBQ3ZDO0FBQ0EsTUFBSSxNQUFNLFFBQVEsQ0FBQyxLQUFLLE1BQU0sUUFBUSxDQUFDLEdBQUc7QUFDdEMsUUFBSSxFQUFFLFdBQVcsRUFBRTtBQUNmLGFBQU8sRUFBRSxPQUFPLElBQU8sZ0JBQWdCLENBQUMsRUFBRTtBQUU5QyxRQUFNLFdBQVcsQ0FBQztBQUNsQixhQUFTLFFBQVEsR0FBRyxRQUFRLEVBQUUsUUFBUSxTQUFTO0FBQzNDLFVBQU0sUUFBUSxFQUFFLEtBQUssR0FDZixRQUFRLEVBQUUsS0FBSyxHQUNmLGNBQWNBLGFBQVksT0FBTyxLQUFLO0FBQzVDLFVBQUksQ0FBQyxZQUFZO0FBQ2IsZUFBTztBQUFBLFVBQ0gsT0FBTztBQUFBLFVBQ1AsZ0JBQWdCLENBQUMsT0FBTyxHQUFHLFlBQVksY0FBYztBQUFBLFFBQ3pEO0FBRUosZUFBUyxLQUFLLFlBQVksSUFBSTtBQUFBLElBQ2xDO0FBQ0EsV0FBTyxFQUFFLE9BQU8sSUFBTSxNQUFNLFNBQVM7QUFBQSxFQUN6QztBQUNBLFNBQU8sRUFBRSxPQUFPLElBQU8sZ0JBQWdCLENBQUMsRUFBRTtBQUM5QztBQUNBLFNBQVMsMEJBQTBCLFFBQVEsTUFBTSxPQUFPO0FBRXBELE1BQU0sWUFBWSxvQkFBSSxJQUFJLEdBQ3RCO0FBQ0osV0FBVyxPQUFPLEtBQUs7QUFDbkIsUUFBSSxJQUFJLFNBQVMscUJBQXFCO0FBQ2xDLHFCQUFlLGFBQWE7QUFDNUIsZUFBVyxLQUFLLElBQUk7QUFDaEIsUUFBSyxVQUFVLElBQUksQ0FBQyxLQUNoQixVQUFVLElBQUksR0FBRyxDQUFDLENBQUMsR0FDdkIsVUFBVSxJQUFJLENBQUMsRUFBRSxJQUFJO0FBQUEsSUFFN0I7QUFFSSxhQUFPLE9BQU8sS0FBSyxHQUFHO0FBRzlCLFdBQVcsT0FBTyxNQUFNO0FBQ3BCLFFBQUksSUFBSSxTQUFTO0FBQ2IsZUFBVyxLQUFLLElBQUk7QUFDaEIsUUFBSyxVQUFVLElBQUksQ0FBQyxLQUNoQixVQUFVLElBQUksR0FBRyxDQUFDLENBQUMsR0FDdkIsVUFBVSxJQUFJLENBQUMsRUFBRSxJQUFJO0FBQUE7QUFJekIsYUFBTyxPQUFPLEtBQUssR0FBRztBQUk5QixNQUFNLFdBQVcsQ0FBQyxHQUFHLFNBQVMsRUFBRSxPQUFPLENBQUMsQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLEtBQUssRUFBRSxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7QUFJNUUsTUFISSxTQUFTLFVBQVUsY0FDbkIsT0FBTyxPQUFPLEtBQUssRUFBRSxHQUFHLFlBQVksTUFBTSxTQUFTLENBQUMsR0FFL0MsUUFBUSxNQUFNO0FBQ25CLFdBQU87QUFDWCxNQUFNLFNBQVNBLGFBQVksS0FBSyxPQUFPLE1BQU0sS0FBSztBQUNsRCxNQUFJLENBQUMsT0FBTztBQUNSLFVBQU0sSUFBSSxNQUFNLHdDQUE2QyxLQUFLLFVBQVUsT0FBTyxjQUFjLENBQUMsRUFBRTtBQUV4RyxnQkFBTyxRQUFRLE9BQU8sTUFDZjtBQUNYO0FBQ08sSUFBTSxZQUEwQixnQkFBSyxhQUFhLGFBQWEsQ0FBQyxNQUFNLFFBQVE7QUFDakYsV0FBUyxLQUFLLE1BQU0sR0FBRztBQUN2QixNQUFNLFFBQVEsSUFBSTtBQUNsQixPQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUNoQyxRQUFNLFFBQVEsUUFBUTtBQUN0QixRQUFJLENBQUMsTUFBTSxRQUFRLEtBQUs7QUFDcEIscUJBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEI7QUFBQSxRQUNBO0FBQUEsUUFDQSxVQUFVO0FBQUEsUUFDVixNQUFNO0FBQUEsTUFDVixDQUFDLEdBQ007QUFFWCxZQUFRLFFBQVEsQ0FBQztBQUNqQixRQUFNLFFBQVEsQ0FBQyxHQUNULGdCQUFnQixDQUFDLEdBQUcsS0FBSyxFQUFFLFFBQVEsRUFBRSxVQUFVLENBQUMsU0FBUyxLQUFLLEtBQUssVUFBVSxVQUFVLEdBQ3ZGLFdBQVcsa0JBQWtCLEtBQUssSUFBSSxNQUFNLFNBQVM7QUFDM0QsUUFBSSxDQUFDLElBQUksTUFBTTtBQUNYLFVBQU0sU0FBUyxNQUFNLFNBQVMsTUFBTSxRQUM5QixXQUFXLE1BQU0sU0FBUyxXQUFXO0FBQzNDLFVBQUksVUFBVTtBQUNWLHVCQUFRLE9BQU8sS0FBSztBQUFBLFVBQ2hCLEdBQUksU0FDRSxFQUFFLE1BQU0sV0FBVyxTQUFTLE1BQU0sUUFBUSxXQUFXLEdBQUssSUFDMUQsRUFBRSxNQUFNLGFBQWEsU0FBUyxNQUFNLE9BQU87QUFBQSxVQUNqRDtBQUFBLFVBQ0E7QUFBQSxVQUNBLFFBQVE7QUFBQSxRQUNaLENBQUMsR0FDTTtBQUFBLElBRWY7QUFDQSxRQUFJLElBQUk7QUFDUixhQUFXLFFBQVEsT0FBTztBQUV0QixVQURBLEtBQ0ksS0FBSyxNQUFNLFVBQ1AsS0FBSztBQUNMO0FBQ1IsVUFBTSxTQUFTLEtBQUssS0FBSyxJQUFJO0FBQUEsUUFDekIsT0FBTyxNQUFNLENBQUM7QUFBQSxRQUNkLFFBQVEsQ0FBQztBQUFBLE1BQ2IsR0FBRyxHQUFHO0FBQ04sTUFBSSxrQkFBa0IsVUFDbEIsTUFBTSxLQUFLLE9BQU8sS0FBSyxDQUFDVixZQUFXLGtCQUFrQkEsU0FBUSxTQUFTLENBQUMsQ0FBQyxDQUFDLElBR3pFLGtCQUFrQixRQUFRLFNBQVMsQ0FBQztBQUFBLElBRTVDO0FBQ0EsUUFBSSxJQUFJLE1BQU07QUFDVixVQUFNLE9BQU8sTUFBTSxNQUFNLE1BQU0sTUFBTTtBQUNyQyxlQUFXLE1BQU0sTUFBTTtBQUNuQjtBQUNBLFlBQU0sU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJO0FBQUEsVUFDN0IsT0FBTztBQUFBLFVBQ1AsUUFBUSxDQUFDO0FBQUEsUUFDYixHQUFHLEdBQUc7QUFDTixRQUFJLGtCQUFrQixVQUNsQixNQUFNLEtBQUssT0FBTyxLQUFLLENBQUNBLFlBQVcsa0JBQWtCQSxTQUFRLFNBQVMsQ0FBQyxDQUFDLENBQUMsSUFHekUsa0JBQWtCLFFBQVEsU0FBUyxDQUFDO0FBQUEsTUFFNUM7QUFBQSxJQUNKO0FBQ0EsV0FBSSxNQUFNLFNBQ0MsUUFBUSxJQUFJLEtBQUssRUFBRSxLQUFLLE1BQU0sT0FBTyxJQUN6QztBQUFBLEVBQ1g7QUFDSixDQUFDO0FBQ0QsU0FBUyxrQkFBa0IsUUFBUSxPQUFPLE9BQU87QUFDN0MsRUFBSSxPQUFPLE9BQU8sVUFDZCxNQUFNLE9BQU8sS0FBSyxHQUFRLGFBQWEsT0FBTyxPQUFPLE1BQU0sQ0FBQyxHQUVoRSxNQUFNLE1BQU0sS0FBSyxJQUFJLE9BQU87QUFDaEM7QUFDTyxJQUFNLGFBQTJCLGdCQUFLLGFBQWEsY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUNuRixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFFBQUksQ0FBTSxjQUFjLEtBQUs7QUFDekIscUJBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEIsVUFBVTtBQUFBLFFBQ1YsTUFBTTtBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsTUFDSixDQUFDLEdBQ007QUFFWCxRQUFNLFFBQVEsQ0FBQyxHQUNULFNBQVMsSUFBSSxRQUFRLEtBQUs7QUFDaEMsUUFBSSxRQUFRO0FBQ1IsY0FBUSxRQUFRLENBQUM7QUFDakIsVUFBTSxhQUFhLG9CQUFJLElBQUk7QUFDM0IsZUFBVyxPQUFPO0FBQ2QsWUFBSSxPQUFPLE9BQVEsWUFBWSxPQUFPLE9BQVEsWUFBWSxPQUFPLE9BQVEsVUFBVTtBQUMvRSxxQkFBVyxJQUFJLE9BQU8sT0FBUSxXQUFXLElBQUksU0FBUyxJQUFJLEdBQUc7QUFDN0QsY0FBTSxTQUFTLElBQUksVUFBVSxLQUFLLElBQUksRUFBRSxPQUFPLE1BQU0sR0FBRyxHQUFHLFFBQVEsQ0FBQyxFQUFFLEdBQUcsR0FBRztBQUM1RSxVQUFJLGtCQUFrQixVQUNsQixNQUFNLEtBQUssT0FBTyxLQUFLLENBQUNBLFlBQVc7QUFDL0IsWUFBSUEsUUFBTyxPQUFPLFVBQ2QsUUFBUSxPQUFPLEtBQUssR0FBUSxhQUFhLEtBQUtBLFFBQU8sTUFBTSxDQUFDLEdBRWhFLFFBQVEsTUFBTSxHQUFHLElBQUlBLFFBQU87QUFBQSxVQUNoQyxDQUFDLENBQUMsS0FHRSxPQUFPLE9BQU8sVUFDZCxRQUFRLE9BQU8sS0FBSyxHQUFRLGFBQWEsS0FBSyxPQUFPLE1BQU0sQ0FBQyxHQUVoRSxRQUFRLE1BQU0sR0FBRyxJQUFJLE9BQU87QUFBQSxRQUVwQztBQUVKLFVBQUk7QUFDSixlQUFXLE9BQU87QUFDZCxRQUFLLFdBQVcsSUFBSSxHQUFHLE1BQ25CLGVBQWUsZ0JBQWdCLENBQUMsR0FDaEMsYUFBYSxLQUFLLEdBQUc7QUFHN0IsTUFBSSxnQkFBZ0IsYUFBYSxTQUFTLEtBQ3RDLFFBQVEsT0FBTyxLQUFLO0FBQUEsUUFDaEIsTUFBTTtBQUFBLFFBQ047QUFBQSxRQUNBO0FBQUEsUUFDQSxNQUFNO0FBQUEsTUFDVixDQUFDO0FBQUEsSUFFVCxPQUNLO0FBQ0QsY0FBUSxRQUFRLENBQUM7QUFDakIsZUFBVyxPQUFPLFFBQVEsUUFBUSxLQUFLLEdBQUc7QUFDdEMsWUFBSSxRQUFRO0FBQ1I7QUFDSixZQUFJLFlBQVksSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFLE9BQU8sS0FBSyxRQUFRLENBQUMsRUFBRSxHQUFHLEdBQUc7QUFDcEUsWUFBSSxxQkFBcUI7QUFDckIsZ0JBQU0sSUFBSSxNQUFNLHNEQUFzRDtBQUsxRSxZQUR3QixPQUFPLE9BQVEsWUFBb0IsT0FBTyxLQUFLLEdBQUcsS0FBSyxVQUFVLE9BQU8sUUFDM0U7QUFDakIsY0FBTSxjQUFjLElBQUksUUFBUSxLQUFLLElBQUksRUFBRSxPQUFPLE9BQU8sR0FBRyxHQUFHLFFBQVEsQ0FBQyxFQUFFLEdBQUcsR0FBRztBQUNoRixjQUFJLHVCQUF1QjtBQUN2QixrQkFBTSxJQUFJLE1BQU0sc0RBQXNEO0FBRTFFLFVBQUksWUFBWSxPQUFPLFdBQVcsTUFDOUIsWUFBWTtBQUFBLFFBRXBCO0FBQ0EsWUFBSSxVQUFVLE9BQU8sUUFBUTtBQUN6QixVQUFJLElBQUksU0FBUyxVQUViLFFBQVEsTUFBTSxHQUFHLElBQUksTUFBTSxHQUFHLElBSTlCLFFBQVEsT0FBTyxLQUFLO0FBQUEsWUFDaEIsTUFBTTtBQUFBLFlBQ04sUUFBUTtBQUFBLFlBQ1IsUUFBUSxVQUFVLE9BQU8sSUFBSSxDQUFDLFFBQWEsY0FBYyxLQUFLLEtBQVUsT0FBTyxDQUFDLENBQUM7QUFBQSxZQUNqRixPQUFPO0FBQUEsWUFDUCxNQUFNLENBQUMsR0FBRztBQUFBLFlBQ1Y7QUFBQSxVQUNKLENBQUM7QUFFTDtBQUFBLFFBQ0o7QUFDQSxZQUFNLFNBQVMsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFLE9BQU8sTUFBTSxHQUFHLEdBQUcsUUFBUSxDQUFDLEVBQUUsR0FBRyxHQUFHO0FBQzVFLFFBQUksa0JBQWtCLFVBQ2xCLE1BQU0sS0FBSyxPQUFPLEtBQUssQ0FBQ0EsWUFBVztBQUMvQixVQUFJQSxRQUFPLE9BQU8sVUFDZCxRQUFRLE9BQU8sS0FBSyxHQUFRLGFBQWEsS0FBS0EsUUFBTyxNQUFNLENBQUMsR0FFaEUsUUFBUSxNQUFNLFVBQVUsS0FBSyxJQUFJQSxRQUFPO0FBQUEsUUFDNUMsQ0FBQyxDQUFDLEtBR0UsT0FBTyxPQUFPLFVBQ2QsUUFBUSxPQUFPLEtBQUssR0FBUSxhQUFhLEtBQUssT0FBTyxNQUFNLENBQUMsR0FFaEUsUUFBUSxNQUFNLFVBQVUsS0FBSyxJQUFJLE9BQU87QUFBQSxNQUVoRDtBQUFBLElBQ0o7QUFDQSxXQUFJLE1BQU0sU0FDQyxRQUFRLElBQUksS0FBSyxFQUFFLEtBQUssTUFBTSxPQUFPLElBRXpDO0FBQUEsRUFDWDtBQUNKLENBQUMsR0FDWSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUNoQyxRQUFNLFFBQVEsUUFBUTtBQUN0QixRQUFJLEVBQUUsaUJBQWlCO0FBQ25CLHFCQUFRLE9BQU8sS0FBSztBQUFBLFFBQ2hCLFVBQVU7QUFBQSxRQUNWLE1BQU07QUFBQSxRQUNOO0FBQUEsUUFDQTtBQUFBLE1BQ0osQ0FBQyxHQUNNO0FBRVgsUUFBTSxRQUFRLENBQUM7QUFDZixZQUFRLFFBQVEsb0JBQUksSUFBSTtBQUN4QixhQUFXLENBQUMsS0FBSyxLQUFLLEtBQUssT0FBTztBQUM5QixVQUFNLFlBQVksSUFBSSxRQUFRLEtBQUssSUFBSSxFQUFFLE9BQU8sS0FBSyxRQUFRLENBQUMsRUFBRSxHQUFHLEdBQUcsR0FDaEUsY0FBYyxJQUFJLFVBQVUsS0FBSyxJQUFJLEVBQUUsT0FBYyxRQUFRLENBQUMsRUFBRSxHQUFHLEdBQUc7QUFDNUUsTUFBSSxxQkFBcUIsV0FBVyx1QkFBdUIsVUFDdkQsTUFBTSxLQUFLLFFBQVEsSUFBSSxDQUFDLFdBQVcsV0FBVyxDQUFDLEVBQUUsS0FBSyxDQUFDLENBQUNXLFlBQVdDLFlBQVcsTUFBTTtBQUNoRix3QkFBZ0JELFlBQVdDLGNBQWEsU0FBUyxLQUFLLE9BQU8sTUFBTSxHQUFHO0FBQUEsTUFDMUUsQ0FBQyxDQUFDLElBR0YsZ0JBQWdCLFdBQVcsYUFBYSxTQUFTLEtBQUssT0FBTyxNQUFNLEdBQUc7QUFBQSxJQUU5RTtBQUNBLFdBQUksTUFBTSxTQUNDLFFBQVEsSUFBSSxLQUFLLEVBQUUsS0FBSyxNQUFNLE9BQU8sSUFDekM7QUFBQSxFQUNYO0FBQ0osQ0FBQztBQUNELFNBQVMsZ0JBQWdCLFdBQVcsYUFBYSxPQUFPLEtBQUssT0FBTyxNQUFNLEtBQUs7QUFDM0UsRUFBSSxVQUFVLE9BQU8sV0FDUixpQkFBaUIsSUFBSSxPQUFPLEdBQUcsSUFDcEMsTUFBTSxPQUFPLEtBQUssR0FBUSxhQUFhLEtBQUssVUFBVSxNQUFNLENBQUMsSUFHN0QsTUFBTSxPQUFPLEtBQUs7QUFBQSxJQUNkLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSO0FBQUEsSUFDQTtBQUFBLElBQ0EsUUFBUSxVQUFVLE9BQU8sSUFBSSxDQUFDLFFBQWEsY0FBYyxLQUFLLEtBQVUsT0FBTyxDQUFDLENBQUM7QUFBQSxFQUNyRixDQUFDLElBR0wsWUFBWSxPQUFPLFdBQ1YsaUJBQWlCLElBQUksT0FBTyxHQUFHLElBQ3BDLE1BQU0sT0FBTyxLQUFLLEdBQVEsYUFBYSxLQUFLLFlBQVksTUFBTSxDQUFDLElBRy9ELE1BQU0sT0FBTyxLQUFLO0FBQUEsSUFDZCxRQUFRO0FBQUEsSUFDUixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBO0FBQUEsSUFDQSxRQUFRLFlBQVksT0FBTyxJQUFJLENBQUMsUUFBYSxjQUFjLEtBQUssS0FBVSxPQUFPLENBQUMsQ0FBQztBQUFBLEVBQ3ZGLENBQUMsSUFHVCxNQUFNLE1BQU0sSUFBSSxVQUFVLE9BQU8sWUFBWSxLQUFLO0FBQ3REO0FBQ08sSUFBTSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUNoQyxRQUFNLFFBQVEsUUFBUTtBQUN0QixRQUFJLEVBQUUsaUJBQWlCO0FBQ25CLHFCQUFRLE9BQU8sS0FBSztBQUFBLFFBQ2hCO0FBQUEsUUFDQTtBQUFBLFFBQ0EsVUFBVTtBQUFBLFFBQ1YsTUFBTTtBQUFBLE1BQ1YsQ0FBQyxHQUNNO0FBRVgsUUFBTSxRQUFRLENBQUM7QUFDZixZQUFRLFFBQVEsb0JBQUksSUFBSTtBQUN4QixhQUFXLFFBQVEsT0FBTztBQUN0QixVQUFNLFNBQVMsSUFBSSxVQUFVLEtBQUssSUFBSSxFQUFFLE9BQU8sTUFBTSxRQUFRLENBQUMsRUFBRSxHQUFHLEdBQUc7QUFDdEUsTUFBSSxrQkFBa0IsVUFDbEIsTUFBTSxLQUFLLE9BQU8sS0FBSyxDQUFDWixZQUFXLGdCQUFnQkEsU0FBUSxPQUFPLENBQUMsQ0FBQyxJQUdwRSxnQkFBZ0IsUUFBUSxPQUFPO0FBQUEsSUFDdkM7QUFDQSxXQUFJLE1BQU0sU0FDQyxRQUFRLElBQUksS0FBSyxFQUFFLEtBQUssTUFBTSxPQUFPLElBQ3pDO0FBQUEsRUFDWDtBQUNKLENBQUM7QUFDRCxTQUFTLGdCQUFnQixRQUFRLE9BQU87QUFDcEMsRUFBSSxPQUFPLE9BQU8sVUFDZCxNQUFNLE9BQU8sS0FBSyxHQUFHLE9BQU8sTUFBTSxHQUV0QyxNQUFNLE1BQU0sSUFBSSxPQUFPLEtBQUs7QUFDaEM7QUFDTyxJQUFNLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxXQUFTLEtBQUssTUFBTSxHQUFHO0FBQ3ZCLE1BQU0sU0FBYyxjQUFjLElBQUksT0FBTyxHQUN2QyxZQUFZLElBQUksSUFBSSxNQUFNO0FBQ2hDLE9BQUssS0FBSyxTQUFTLFdBQ25CLEtBQUssS0FBSyxVQUFVLElBQUksT0FBTyxLQUFLLE9BQy9CLE9BQU8sQ0FBQyxNQUFXLGlCQUFpQixJQUFJLE9BQU8sQ0FBQyxDQUFDLEVBQ2pELElBQUksQ0FBQyxNQUFPLE9BQU8sS0FBTSxXQUFnQixZQUFZLENBQUMsSUFBSSxFQUFFLFNBQVMsQ0FBRSxFQUN2RSxLQUFLLEdBQUcsQ0FBQyxJQUFJLEdBQ2xCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxTQUFTO0FBQ2pDLFFBQU0sUUFBUSxRQUFRO0FBQ3RCLFdBQUksVUFBVSxJQUFJLEtBQUssS0FHdkIsUUFBUSxPQUFPLEtBQUs7QUFBQSxNQUNoQixNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLGNBQTRCLGdCQUFLLGFBQWEsZUFBZSxDQUFDLE1BQU0sUUFBUTtBQUVyRixNQURBLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDbkIsSUFBSSxPQUFPLFdBQVc7QUFDdEIsVUFBTSxJQUFJLE1BQU0sbURBQW1EO0FBRXZFLE1BQU0sU0FBUyxJQUFJLElBQUksSUFBSSxNQUFNO0FBQ2pDLE9BQUssS0FBSyxTQUFTLFFBQ25CLEtBQUssS0FBSyxVQUFVLElBQUksT0FBTyxLQUFLLElBQUksT0FDbkMsSUFBSSxDQUFDLE1BQU8sT0FBTyxLQUFNLFdBQWdCLFlBQVksQ0FBQyxJQUFJLElBQVMsWUFBWSxFQUFFLFNBQVMsQ0FBQyxJQUFJLE9BQU8sQ0FBQyxDQUFFLEVBQ3pHLEtBQUssR0FBRyxDQUFDLElBQUksR0FDbEIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFNBQVM7QUFDakMsUUFBTSxRQUFRLFFBQVE7QUFDdEIsV0FBSSxPQUFPLElBQUksS0FBSyxLQUdwQixRQUFRLE9BQU8sS0FBSztBQUFBLE1BQ2hCLE1BQU07QUFBQSxNQUNOLFFBQVEsSUFBSTtBQUFBLE1BQ1o7QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxTQUFTO0FBQ2pDLFFBQU0sUUFBUSxRQUFRO0FBRXRCLFdBQUksaUJBQWlCLFFBRXJCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsVUFBVTtBQUFBLE1BQ1YsTUFBTTtBQUFBLE1BQ047QUFBQSxNQUNBO0FBQUEsSUFDSixDQUFDLEdBQ007QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLGdCQUE4QixnQkFBSyxhQUFhLGlCQUFpQixDQUFDLE1BQU0sUUFBUTtBQUN6RixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLFFBQUksSUFBSSxjQUFjO0FBQ2xCLFlBQU0sSUFBUyxnQkFBZ0IsS0FBSyxZQUFZLElBQUk7QUFFeEQsUUFBTSxPQUFPLElBQUksVUFBVSxRQUFRLE9BQU8sT0FBTztBQUNqRCxRQUFJLElBQUk7QUFFSixjQURlLGdCQUFnQixVQUFVLE9BQU8sUUFBUSxRQUFRLElBQUksR0FDdEQsS0FBSyxDQUFDYSxhQUNoQixRQUFRLFFBQVFBLFNBQ1QsUUFDVjtBQUVMLFFBQUksZ0JBQWdCO0FBQ2hCLFlBQU0sSUFBUyxlQUFlO0FBRWxDLG1CQUFRLFFBQVEsTUFDVDtBQUFBLEVBQ1g7QUFDSixDQUFDO0FBQ0QsU0FBUyxxQkFBcUIsUUFBUSxPQUFPO0FBQ3pDLFNBQUksT0FBTyxPQUFPLFVBQVUsVUFBVSxTQUMzQixFQUFFLFFBQVEsQ0FBQyxHQUFHLE9BQU8sT0FBVSxJQUVuQztBQUNYO0FBQ08sSUFBTSxlQUE2QixnQkFBSyxhQUFhLGdCQUFnQixDQUFDLE1BQU0sUUFBUTtBQUN2RixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLFlBQ2xCLEtBQUssS0FBSyxTQUFTLFlBQ2QsV0FBVyxLQUFLLE1BQU0sVUFBVSxNQUMxQixJQUFJLFVBQVUsS0FBSyxTQUFTLG9CQUFJLElBQUksQ0FBQyxHQUFHLElBQUksVUFBVSxLQUFLLFFBQVEsTUFBUyxDQUFDLElBQUksTUFDM0YsR0FDSSxXQUFXLEtBQUssTUFBTSxXQUFXLE1BQU07QUFDeEMsUUFBTSxVQUFVLElBQUksVUFBVSxLQUFLO0FBQ25DLFdBQU8sVUFBVSxJQUFJLE9BQU8sS0FBVSxXQUFXLFFBQVEsTUFBTSxDQUFDLEtBQUssSUFBSTtBQUFBLEVBQzdFLENBQUMsR0FDRCxLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUNoQyxRQUFJLElBQUksVUFBVSxLQUFLLFVBQVUsWUFBWTtBQUN6QyxVQUFNLFNBQVMsSUFBSSxVQUFVLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFDbEQsYUFBSSxrQkFBa0IsVUFDWCxPQUFPLEtBQUssQ0FBQyxNQUFNLHFCQUFxQixHQUFHLFFBQVEsS0FBSyxDQUFDLElBQzdELHFCQUFxQixRQUFRLFFBQVEsS0FBSztBQUFBLElBQ3JEO0FBQ0EsV0FBSSxRQUFRLFVBQVUsU0FDWCxVQUVKLElBQUksVUFBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBQUEsRUFDOUM7QUFDSixDQUFDLEdBQ1ksb0JBQWtDLGdCQUFLLGFBQWEscUJBQXFCLENBQUMsTUFBTSxRQUFRO0FBRWpHLGVBQWEsS0FBSyxNQUFNLEdBQUcsR0FFdEIsV0FBVyxLQUFLLE1BQU0sVUFBVSxNQUFNLElBQUksVUFBVSxLQUFLLE1BQU0sR0FDL0QsV0FBVyxLQUFLLE1BQU0sV0FBVyxNQUFNLElBQUksVUFBVSxLQUFLLE9BQU8sR0FFdEUsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQ2pCLElBQUksVUFBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBRWxELENBQUMsR0FDWSxlQUE2QixnQkFBSyxhQUFhLGdCQUFnQixDQUFDLE1BQU0sUUFBUTtBQUN2RixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ2xCLFdBQVcsS0FBSyxNQUFNLFNBQVMsTUFBTSxJQUFJLFVBQVUsS0FBSyxLQUFLLEdBQzdELFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTSxJQUFJLFVBQVUsS0FBSyxNQUFNLEdBQy9ELFdBQVcsS0FBSyxNQUFNLFdBQVcsTUFBTTtBQUN4QyxRQUFNLFVBQVUsSUFBSSxVQUFVLEtBQUs7QUFDbkMsV0FBTyxVQUFVLElBQUksT0FBTyxLQUFVLFdBQVcsUUFBUSxNQUFNLENBQUMsU0FBUyxJQUFJO0FBQUEsRUFDakYsQ0FBQyxHQUNJLFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFDMUIsSUFBSSxVQUFVLEtBQUssU0FBUyxvQkFBSSxJQUFJLENBQUMsR0FBRyxJQUFJLFVBQVUsS0FBSyxRQUFRLElBQUksQ0FBQyxJQUFJLE1BQ3RGLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBRXBCLFFBQVEsVUFBVSxPQUNYLFVBQ0osSUFBSSxVQUFVLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFFbEQsQ0FBQyxHQUNZLGNBQTRCLGdCQUFLLGFBQWEsZUFBZSxDQUFDLE1BQU0sUUFBUTtBQUNyRixXQUFTLEtBQUssTUFBTSxHQUFHLEdBRXZCLEtBQUssS0FBSyxRQUFRLFlBQ2IsV0FBVyxLQUFLLE1BQU0sVUFBVSxNQUFNLElBQUksVUFBVSxLQUFLLE1BQU0sR0FDcEUsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDaEMsUUFBSSxJQUFJLGNBQWM7QUFDbEIsYUFBTyxJQUFJLFVBQVUsS0FBSyxJQUFJLFNBQVMsR0FBRztBQUc5QyxRQUFJLFFBQVEsVUFBVTtBQUNsQixxQkFBUSxRQUFRLElBQUksY0FJYjtBQUdYLFFBQU0sU0FBUyxJQUFJLFVBQVUsS0FBSyxJQUFJLFNBQVMsR0FBRztBQUNsRCxXQUFJLGtCQUFrQixVQUNYLE9BQU8sS0FBSyxDQUFDYixZQUFXLG9CQUFvQkEsU0FBUSxHQUFHLENBQUMsSUFFNUQsb0JBQW9CLFFBQVEsR0FBRztBQUFBLEVBQzFDO0FBQ0osQ0FBQztBQUNELFNBQVMsb0JBQW9CLFNBQVMsS0FBSztBQUN2QyxTQUFJLFFBQVEsVUFBVSxXQUNsQixRQUFRLFFBQVEsSUFBSSxlQUVqQjtBQUNYO0FBQ08sSUFBTSxlQUE2QixnQkFBSyxhQUFhLGdCQUFnQixDQUFDLE1BQU0sUUFBUTtBQUN2RixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLFlBQ2IsV0FBVyxLQUFLLE1BQU0sVUFBVSxNQUFNLElBQUksVUFBVSxLQUFLLE1BQU0sR0FDcEUsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFNBQ3BCLElBQUksY0FBYyxjQUlsQixRQUFRLFVBQVUsV0FDbEIsUUFBUSxRQUFRLElBQUksZUFFakIsSUFBSSxVQUFVLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFFbEQsQ0FBQyxHQUNZLGtCQUFnQyxnQkFBSyxhQUFhLG1CQUFtQixDQUFDLE1BQU0sUUFBUTtBQUM3RixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ2xCLFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTTtBQUN2QyxRQUFNLElBQUksSUFBSSxVQUFVLEtBQUs7QUFDN0IsV0FBTyxJQUFJLElBQUksSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLE1BQU0sTUFBUyxDQUFDLElBQUk7QUFBQSxFQUNoRSxDQUFDLEdBQ0QsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDaEMsUUFBTSxTQUFTLElBQUksVUFBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBQ2xELFdBQUksa0JBQWtCLFVBQ1gsT0FBTyxLQUFLLENBQUNBLFlBQVcsd0JBQXdCQSxTQUFRLElBQUksQ0FBQyxJQUVqRSx3QkFBd0IsUUFBUSxJQUFJO0FBQUEsRUFDL0M7QUFDSixDQUFDO0FBQ0QsU0FBUyx3QkFBd0IsU0FBUyxNQUFNO0FBQzVDLFNBQUksQ0FBQyxRQUFRLE9BQU8sVUFBVSxRQUFRLFVBQVUsVUFDNUMsUUFBUSxPQUFPLEtBQUs7QUFBQSxJQUNoQixNQUFNO0FBQUEsSUFDTixVQUFVO0FBQUEsSUFDVixPQUFPLFFBQVE7QUFBQSxJQUNmO0FBQUEsRUFDSixDQUFDLEdBRUU7QUFDWDtBQUNPLElBQU0sY0FBNEIsZ0JBQUssYUFBYSxlQUFlLENBQUMsTUFBTSxRQUFRO0FBQ3JGLFdBQVMsS0FBSyxNQUFNLEdBQUcsR0FDdkIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQVE7QUFDaEMsUUFBSSxJQUFJLGNBQWM7QUFDbEIsWUFBTSxJQUFTLGdCQUFnQixZQUFZO0FBRS9DLFFBQU0sU0FBUyxJQUFJLFVBQVUsS0FBSyxJQUFJLFNBQVMsR0FBRztBQUNsRCxXQUFJLGtCQUFrQixVQUNYLE9BQU8sS0FBSyxDQUFDQSxhQUNoQixRQUFRLFFBQVFBLFFBQU8sT0FBTyxXQUFXLEdBQ2xDLFFBQ1YsS0FFTCxRQUFRLFFBQVEsT0FBTyxPQUFPLFdBQVcsR0FDbEM7QUFBQSxFQUNYO0FBQ0osQ0FBQyxHQUNZLFlBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUNqRixXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ2xCLFdBQVcsS0FBSyxNQUFNLFNBQVMsTUFBTSxJQUFJLFVBQVUsS0FBSyxLQUFLLEdBQzdELFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTSxJQUFJLFVBQVUsS0FBSyxNQUFNLEdBQy9ELFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTSxJQUFJLFVBQVUsS0FBSyxNQUFNLEdBQ3BFLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLFFBQUksSUFBSSxjQUFjO0FBQ2xCLGFBQU8sSUFBSSxVQUFVLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFHOUMsUUFBTSxTQUFTLElBQUksVUFBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBQ2xELFdBQUksa0JBQWtCLFVBQ1gsT0FBTyxLQUFLLENBQUNBLGFBQ2hCLFFBQVEsUUFBUUEsUUFBTyxPQUNuQkEsUUFBTyxPQUFPLFdBQ2QsUUFBUSxRQUFRLElBQUksV0FBVztBQUFBLE1BQzNCLEdBQUc7QUFBQSxNQUNILE9BQU87QUFBQSxRQUNILFFBQVFBLFFBQU8sT0FBTyxJQUFJLENBQUMsUUFBYSxjQUFjLEtBQUssS0FBVSxPQUFPLENBQUMsQ0FBQztBQUFBLE1BQ2xGO0FBQUEsTUFDQSxPQUFPLFFBQVE7QUFBQSxJQUNuQixDQUFDLEdBQ0QsUUFBUSxTQUFTLENBQUMsSUFFZixRQUNWLEtBRUwsUUFBUSxRQUFRLE9BQU8sT0FDbkIsT0FBTyxPQUFPLFdBQ2QsUUFBUSxRQUFRLElBQUksV0FBVztBQUFBLE1BQzNCLEdBQUc7QUFBQSxNQUNILE9BQU87QUFBQSxRQUNILFFBQVEsT0FBTyxPQUFPLElBQUksQ0FBQyxRQUFhLGNBQWMsS0FBSyxLQUFVLE9BQU8sQ0FBQyxDQUFDO0FBQUEsTUFDbEY7QUFBQSxNQUNBLE9BQU8sUUFBUTtBQUFBLElBQ25CLENBQUMsR0FDRCxRQUFRLFNBQVMsQ0FBQyxJQUVmO0FBQUEsRUFDWDtBQUNKLENBQUMsR0FDWSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsV0FDcEIsT0FBTyxRQUFRLFNBQVUsWUFBWSxDQUFDLE9BQU8sTUFBTSxRQUFRLEtBQUssTUFDaEUsUUFBUSxPQUFPLEtBQUs7QUFBQSxJQUNoQixPQUFPLFFBQVE7QUFBQSxJQUNmO0FBQUEsSUFDQSxVQUFVO0FBQUEsSUFDVixNQUFNO0FBQUEsRUFDVixDQUFDLEdBQ007QUFJbkIsQ0FBQyxHQUNZLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxXQUFTLEtBQUssTUFBTSxHQUFHLEdBQ2xCLFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTSxJQUFJLEdBQUcsS0FBSyxNQUFNLEdBQ3hELFdBQVcsS0FBSyxNQUFNLFNBQVMsTUFBTSxJQUFJLEdBQUcsS0FBSyxLQUFLLEdBQ3RELFdBQVcsS0FBSyxNQUFNLFVBQVUsTUFBTSxJQUFJLElBQUksS0FBSyxNQUFNLEdBQ3pELFdBQVcsS0FBSyxNQUFNLGNBQWMsTUFBTSxJQUFJLEdBQUcsS0FBSyxVQUFVLEdBQ3JFLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxRQUFRO0FBQ2hDLFFBQUksSUFBSSxjQUFjLFlBQVk7QUFDOUIsVUFBTSxRQUFRLElBQUksSUFBSSxLQUFLLElBQUksU0FBUyxHQUFHO0FBQzNDLGFBQUksaUJBQWlCLFVBQ1YsTUFBTSxLQUFLLENBQUNTLFdBQVUsaUJBQWlCQSxRQUFPLElBQUksSUFBSSxHQUFHLENBQUMsSUFFOUQsaUJBQWlCLE9BQU8sSUFBSSxJQUFJLEdBQUc7QUFBQSxJQUM5QztBQUNBLFFBQU0sT0FBTyxJQUFJLEdBQUcsS0FBSyxJQUFJLFNBQVMsR0FBRztBQUN6QyxXQUFJLGdCQUFnQixVQUNULEtBQUssS0FBSyxDQUFDRCxVQUFTLGlCQUFpQkEsT0FBTSxJQUFJLEtBQUssR0FBRyxDQUFDLElBRTVELGlCQUFpQixNQUFNLElBQUksS0FBSyxHQUFHO0FBQUEsRUFDOUM7QUFDSixDQUFDO0FBQ0QsU0FBUyxpQkFBaUIsTUFBTSxNQUFNLEtBQUs7QUFDdkMsU0FBSSxLQUFLLE9BQU8sVUFFWixLQUFLLFVBQVUsSUFDUixRQUVKLEtBQUssS0FBSyxJQUFJLEVBQUUsT0FBTyxLQUFLLE9BQU8sUUFBUSxLQUFLLE9BQU8sR0FBRyxHQUFHO0FBQ3hFO0FBQ08sSUFBTSxZQUEwQixnQkFBSyxhQUFhLGFBQWEsQ0FBQyxNQUFNLFFBQVE7QUFDakYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUNsQixXQUFXLEtBQUssTUFBTSxVQUFVLE1BQU0sSUFBSSxHQUFHLEtBQUssTUFBTSxHQUN4RCxXQUFXLEtBQUssTUFBTSxTQUFTLE1BQU0sSUFBSSxHQUFHLEtBQUssS0FBSyxHQUN0RCxXQUFXLEtBQUssTUFBTSxVQUFVLE1BQU0sSUFBSSxJQUFJLEtBQUssTUFBTSxHQUN6RCxXQUFXLEtBQUssTUFBTSxjQUFjLE1BQU0sSUFBSSxHQUFHLEtBQUssVUFBVSxHQUNyRSxLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUVoQyxTQURrQixJQUFJLGFBQWEsZUFDakIsV0FBVztBQUN6QixVQUFNLE9BQU8sSUFBSSxHQUFHLEtBQUssSUFBSSxTQUFTLEdBQUc7QUFDekMsYUFBSSxnQkFBZ0IsVUFDVCxLQUFLLEtBQUssQ0FBQ0EsVUFBUyxtQkFBbUJBLE9BQU0sS0FBSyxHQUFHLENBQUMsSUFFMUQsbUJBQW1CLE1BQU0sS0FBSyxHQUFHO0FBQUEsSUFDNUMsT0FDSztBQUNELFVBQU0sUUFBUSxJQUFJLElBQUksS0FBSyxJQUFJLFNBQVMsR0FBRztBQUMzQyxhQUFJLGlCQUFpQixVQUNWLE1BQU0sS0FBSyxDQUFDQyxXQUFVLG1CQUFtQkEsUUFBTyxLQUFLLEdBQUcsQ0FBQyxJQUU3RCxtQkFBbUIsT0FBTyxLQUFLLEdBQUc7QUFBQSxJQUM3QztBQUFBLEVBQ0o7QUFDSixDQUFDO0FBQ0QsU0FBUyxtQkFBbUIsUUFBUSxLQUFLLEtBQUs7QUFDMUMsTUFBSSxPQUFPLE9BQU87QUFFZCxrQkFBTyxVQUFVLElBQ1Y7QUFHWCxPQURrQixJQUFJLGFBQWEsZUFDakIsV0FBVztBQUN6QixRQUFNLGNBQWMsSUFBSSxVQUFVLE9BQU8sT0FBTyxNQUFNO0FBQ3RELFdBQUksdUJBQXVCLFVBQ2hCLFlBQVksS0FBSyxDQUFDLFVBQVUsb0JBQW9CLFFBQVEsT0FBTyxJQUFJLEtBQUssR0FBRyxDQUFDLElBRWhGLG9CQUFvQixRQUFRLGFBQWEsSUFBSSxLQUFLLEdBQUc7QUFBQSxFQUNoRSxPQUNLO0FBQ0QsUUFBTSxjQUFjLElBQUksaUJBQWlCLE9BQU8sT0FBTyxNQUFNO0FBQzdELFdBQUksdUJBQXVCLFVBQ2hCLFlBQVksS0FBSyxDQUFDLFVBQVUsb0JBQW9CLFFBQVEsT0FBTyxJQUFJLElBQUksR0FBRyxDQUFDLElBRS9FLG9CQUFvQixRQUFRLGFBQWEsSUFBSSxJQUFJLEdBQUc7QUFBQSxFQUMvRDtBQUNKO0FBQ0EsU0FBUyxvQkFBb0IsTUFBTSxPQUFPLFlBQVksS0FBSztBQUV2RCxTQUFJLEtBQUssT0FBTyxVQUNaLEtBQUssVUFBVSxJQUNSLFFBRUosV0FBVyxLQUFLLElBQUksRUFBRSxPQUFPLFFBQVEsS0FBSyxPQUFPLEdBQUcsR0FBRztBQUNsRTtBQUNPLElBQU0sZUFBNkIsZ0JBQUssYUFBYSxnQkFBZ0IsQ0FBQyxNQUFNLFFBQVE7QUFDdkYsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQUNsQixXQUFXLEtBQUssTUFBTSxjQUFjLE1BQU0sSUFBSSxVQUFVLEtBQUssVUFBVSxHQUN2RSxXQUFXLEtBQUssTUFBTSxVQUFVLE1BQU0sSUFBSSxVQUFVLEtBQUssTUFBTSxHQUMvRCxXQUFXLEtBQUssTUFBTSxTQUFTLE1BQU0sSUFBSSxXQUFXLE1BQU0sS0FBSyxHQUMvRCxXQUFXLEtBQUssTUFBTSxVQUFVLE1BQU0sSUFBSSxXQUFXLE1BQU0sTUFBTSxHQUN0RSxLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsUUFBUTtBQUNoQyxRQUFJLElBQUksY0FBYztBQUNsQixhQUFPLElBQUksVUFBVSxLQUFLLElBQUksU0FBUyxHQUFHO0FBRTlDLFFBQU0sU0FBUyxJQUFJLFVBQVUsS0FBSyxJQUFJLFNBQVMsR0FBRztBQUNsRCxXQUFJLGtCQUFrQixVQUNYLE9BQU8sS0FBSyxvQkFBb0IsSUFFcEMscUJBQXFCLE1BQU07QUFBQSxFQUN0QztBQUNKLENBQUM7QUFDRCxTQUFTLHFCQUFxQixTQUFTO0FBQ25DLGlCQUFRLFFBQVEsT0FBTyxPQUFPLFFBQVEsS0FBSyxHQUNwQztBQUNYO0FBQ08sSUFBTSxzQkFBb0MsZ0JBQUssYUFBYSx1QkFBdUIsQ0FBQyxNQUFNLFFBQVE7QUFDckcsV0FBUyxLQUFLLE1BQU0sR0FBRztBQUN2QixNQUFNLGFBQWEsQ0FBQztBQUNwQixXQUFXLFFBQVEsSUFBSTtBQUNuQixRQUFJLE9BQU8sUUFBUyxZQUFZLFNBQVMsTUFBTTtBQUUzQyxVQUFJLENBQUMsS0FBSyxLQUFLO0FBRVgsY0FBTSxJQUFJLE1BQU0sb0RBQW9ELENBQUMsR0FBRyxLQUFLLEtBQUssTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUFFO0FBRXZHLFVBQU0sU0FBUyxLQUFLLEtBQUssbUJBQW1CLFNBQVMsS0FBSyxLQUFLLFFBQVEsU0FBUyxLQUFLLEtBQUs7QUFDMUYsVUFBSSxDQUFDO0FBQ0QsY0FBTSxJQUFJLE1BQU0sa0NBQWtDLEtBQUssS0FBSyxNQUFNLEVBQUU7QUFDeEUsVUFBTSxRQUFRLE9BQU8sV0FBVyxHQUFHLElBQUksSUFBSSxHQUNyQyxNQUFNLE9BQU8sU0FBUyxHQUFHLElBQUksT0FBTyxTQUFTLElBQUksT0FBTztBQUM5RCxpQkFBVyxLQUFLLE9BQU8sTUFBTSxPQUFPLEdBQUcsQ0FBQztBQUFBLElBQzVDLFdBQ1MsU0FBUyxRQUFhLGVBQWUsSUFBSSxPQUFPLElBQUk7QUFDekQsaUJBQVcsS0FBVSxZQUFZLEdBQUcsSUFBSSxFQUFFLENBQUM7QUFBQTtBQUczQyxZQUFNLElBQUksTUFBTSxrQ0FBa0MsSUFBSSxFQUFFO0FBR2hFLE9BQUssS0FBSyxVQUFVLElBQUksT0FBTyxJQUFJLFdBQVcsS0FBSyxFQUFFLENBQUMsR0FBRyxHQUN6RCxLQUFLLEtBQUssUUFBUSxDQUFDLFNBQVMsU0FDcEIsT0FBTyxRQUFRLFNBQVUsWUFDekIsUUFBUSxPQUFPLEtBQUs7QUFBQSxJQUNoQixPQUFPLFFBQVE7QUFBQSxJQUNmO0FBQUEsSUFDQSxVQUFVO0FBQUEsSUFDVixNQUFNO0FBQUEsRUFDVixDQUFDLEdBQ00sWUFFWCxLQUFLLEtBQUssUUFBUSxZQUFZLEdBQ3pCLEtBQUssS0FBSyxRQUFRLEtBQUssUUFBUSxLQUFLLEtBQ3JDLFFBQVEsT0FBTyxLQUFLO0FBQUEsSUFDaEIsT0FBTyxRQUFRO0FBQUEsSUFDZjtBQUFBLElBQ0EsTUFBTTtBQUFBLElBQ04sUUFBUSxJQUFJLFVBQVU7QUFBQSxJQUN0QixTQUFTLEtBQUssS0FBSyxRQUFRO0FBQUEsRUFDL0IsQ0FBQyxHQUNNO0FBSW5CLENBQUMsR0FDWSxlQUE2QixnQkFBSyxhQUFhLGdCQUFnQixDQUFDLE1BQU0sU0FDL0UsU0FBUyxLQUFLLE1BQU0sR0FBRyxHQUN2QixLQUFLLE9BQU8sS0FDWixLQUFLLEtBQUssTUFBTSxLQUNoQixLQUFLLFlBQVksQ0FBQyxTQUFTO0FBQ3ZCLE1BQUksT0FBTyxRQUFTO0FBQ2hCLFVBQU0sSUFBSSxNQUFNLDRDQUE0QztBQUVoRSxTQUFPLFlBQWEsTUFBTTtBQUN0QixRQUFNLGFBQWEsS0FBSyxLQUFLLFFBQVEsTUFBTSxLQUFLLEtBQUssT0FBTyxJQUFJLElBQUksTUFDOUQsU0FBUyxRQUFRLE1BQU0sTUFBTSxNQUFNLFVBQVU7QUFDbkQsV0FBSSxLQUFLLEtBQUssU0FDSCxNQUFNLEtBQUssS0FBSyxRQUFRLE1BQU0sSUFFbEM7QUFBQSxFQUNYO0FBQ0osR0FDQSxLQUFLLGlCQUFpQixDQUFDLFNBQVM7QUFDNUIsTUFBSSxPQUFPLFFBQVM7QUFDaEIsVUFBTSxJQUFJLE1BQU0saURBQWlEO0FBRXJFLFNBQU8sa0JBQW1CLE1BQU07QUFDNUIsUUFBTSxhQUFhLEtBQUssS0FBSyxRQUFRLE1BQU0sV0FBVyxLQUFLLEtBQUssT0FBTyxJQUFJLElBQUksTUFDekUsU0FBUyxNQUFNLFFBQVEsTUFBTSxNQUFNLE1BQU0sVUFBVTtBQUN6RCxXQUFJLEtBQUssS0FBSyxTQUNILE1BQU0sV0FBVyxLQUFLLEtBQUssUUFBUSxNQUFNLElBRTdDO0FBQUEsRUFDWDtBQUNKLEdBQ0EsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFNBQ3BCLE9BQU8sUUFBUSxTQUFVLGNBQ3pCLFFBQVEsT0FBTyxLQUFLO0FBQUEsRUFDaEIsTUFBTTtBQUFBLEVBQ04sVUFBVTtBQUFBLEVBQ1YsT0FBTyxRQUFRO0FBQUEsRUFDZjtBQUNKLENBQUMsR0FDTSxZQUdjLEtBQUssS0FBSyxVQUFVLEtBQUssS0FBSyxPQUFPLEtBQUssSUFBSSxTQUFTLFlBRTVFLFFBQVEsUUFBUSxLQUFLLGVBQWUsUUFBUSxLQUFLLElBR2pELFFBQVEsUUFBUSxLQUFLLFVBQVUsUUFBUSxLQUFLLEdBRXpDLFVBRVgsS0FBSyxRQUFRLElBQUksU0FBUztBQUN0QixNQUFNLElBQUksS0FBSztBQUNmLFNBQUksTUFBTSxRQUFRLEtBQUssQ0FBQyxDQUFDLElBQ2QsSUFBSSxFQUFFO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixPQUFPLElBQUksVUFBVTtBQUFBLE1BQ2pCLE1BQU07QUFBQSxNQUNOLE9BQU8sS0FBSyxDQUFDO0FBQUEsTUFDYixNQUFNLEtBQUssQ0FBQztBQUFBLElBQ2hCLENBQUM7QUFBQSxJQUNELFFBQVEsS0FBSyxLQUFLO0FBQUEsRUFDdEIsQ0FBQyxJQUVFLElBQUksRUFBRTtBQUFBLElBQ1QsTUFBTTtBQUFBLElBQ04sT0FBTyxLQUFLLENBQUM7QUFBQSxJQUNiLFFBQVEsS0FBSyxLQUFLO0FBQUEsRUFDdEIsQ0FBQztBQUNMLEdBQ0EsS0FBSyxTQUFTLENBQUMsV0FBVztBQUN0QixNQUFNLElBQUksS0FBSztBQUNmLFNBQU8sSUFBSSxFQUFFO0FBQUEsSUFDVCxNQUFNO0FBQUEsSUFDTixPQUFPLEtBQUssS0FBSztBQUFBLElBQ2pCO0FBQUEsRUFDSixDQUFDO0FBQ0wsR0FDTyxLQUNWLEdBQ1ksY0FBNEIsZ0JBQUssYUFBYSxlQUFlLENBQUMsTUFBTSxRQUFRO0FBQ3JGLFdBQVMsS0FBSyxNQUFNLEdBQUcsR0FDdkIsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQ2pCLFFBQVEsUUFBUSxRQUFRLEtBQUssRUFBRSxLQUFLLENBQUMsVUFBVSxJQUFJLFVBQVUsS0FBSyxJQUFJLEVBQUUsT0FBTyxPQUFPLFFBQVEsQ0FBQyxFQUFFLEdBQUcsR0FBRyxDQUFDO0FBRXZILENBQUMsR0FDWSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFDL0UsV0FBUyxLQUFLLE1BQU0sR0FBRyxHQVFsQixXQUFXLEtBQUssTUFBTSxhQUFhLE1BQU0sSUFBSSxPQUFPLENBQUMsR0FDckQsV0FBVyxLQUFLLE1BQU0sV0FBVyxNQUFNLEtBQUssS0FBSyxXQUFXLE1BQU0sT0FBTyxHQUN6RSxXQUFXLEtBQUssTUFBTSxjQUFjLE1BQU0sS0FBSyxLQUFLLFdBQVcsTUFBTSxVQUFVLEdBQy9FLFdBQVcsS0FBSyxNQUFNLFNBQVMsTUFBTSxLQUFLLEtBQUssV0FBVyxNQUFNLFNBQVMsTUFBUyxHQUNsRixXQUFXLEtBQUssTUFBTSxVQUFVLE1BQU0sS0FBSyxLQUFLLFdBQVcsTUFBTSxVQUFVLE1BQVMsR0FDekYsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFFBQ1YsS0FBSyxLQUFLLFVBQ1gsS0FBSyxJQUFJLFNBQVMsR0FBRztBQUUxQyxDQUFDLEdBQ1ksYUFBMkIsZ0JBQUssYUFBYSxjQUFjLENBQUMsTUFBTSxRQUFRO0FBQ25GLEVBQU8sVUFBVSxLQUFLLE1BQU0sR0FBRyxHQUMvQixTQUFTLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLEtBQUssS0FBSyxRQUFRLENBQUMsU0FBUyxNQUNqQixTQUVYLEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixRQUFNLFFBQVEsUUFBUSxPQUNoQixJQUFJLElBQUksR0FBRyxLQUFLO0FBQ3RCLFFBQUksYUFBYTtBQUNiLGFBQU8sRUFBRSxLQUFLLENBQUNMLE9BQU0sbUJBQW1CQSxJQUFHLFNBQVMsT0FBTyxJQUFJLENBQUM7QUFFcEUsdUJBQW1CLEdBQUcsU0FBUyxPQUFPLElBQUk7QUFBQSxFQUU5QztBQUNKLENBQUM7QUFDRCxTQUFTLG1CQUFtQixRQUFRLFNBQVMsT0FBTyxNQUFNO0FBQ3RELE1BQUksQ0FBQyxRQUFRO0FBQ1QsUUFBTSxPQUFPO0FBQUEsTUFDVCxNQUFNO0FBQUEsTUFDTjtBQUFBLE1BQ0E7QUFBQTtBQUFBLE1BQ0EsTUFBTSxDQUFDLEdBQUksS0FBSyxLQUFLLElBQUksUUFBUSxDQUFDLENBQUU7QUFBQTtBQUFBLE1BQ3BDLFVBQVUsQ0FBQyxLQUFLLEtBQUssSUFBSTtBQUFBO0FBQUEsSUFFN0I7QUFDQSxJQUFJLEtBQUssS0FBSyxJQUFJLFdBQ2QsS0FBSyxTQUFTLEtBQUssS0FBSyxJQUFJLFNBQ2hDLFFBQVEsT0FBTyxLQUFVLE1BQU0sSUFBSSxDQUFDO0FBQUEsRUFDeEM7QUFDSjs7O0FDM2lFQSxJQUFNLFFBQVEsTUFBTTtBQUNoQixNQUFNLFVBQVU7QUFBQSxJQUNaLFFBQVEsRUFBRSxNQUFNLGNBQWMsTUFBTSxVQUFVO0FBQUEsSUFDOUMsTUFBTSxFQUFFLE1BQU0sU0FBUyxNQUFNLFVBQVU7QUFBQSxJQUN2QyxPQUFPLEVBQUUsTUFBTSxTQUFTLE1BQU0sVUFBVTtBQUFBLElBQ3hDLEtBQUssRUFBRSxNQUFNLFNBQVMsTUFBTSxVQUFVO0FBQUEsSUFDdEMsS0FBSyxFQUFFLE1BQU0sV0FBVyxNQUFNLFVBQVU7QUFBQSxFQUM1QztBQUNBLFdBQVMsVUFBVSxRQUFRO0FBQ3ZCLFdBQU8sUUFBUSxNQUFNLEtBQUs7QUFBQSxFQUM5QjtBQUNBLE1BQU0sbUJBQW1CO0FBQUEsSUFDckIsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsT0FBTztBQUFBLElBQ1AsVUFBVTtBQUFBLElBQ1YsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sVUFBVTtBQUFBLElBQ1YsTUFBTTtBQUFBLElBQ04sTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsUUFBUTtBQUFBLElBQ1IsV0FBVztBQUFBLElBQ1gsYUFBYTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sS0FBSztBQUFBLElBQ0wsa0JBQWtCO0FBQUEsRUFDdEIsR0FFTSxpQkFBaUI7QUFBQTtBQUFBLElBRW5CLEtBQUs7QUFBQTtBQUFBLEVBRVQ7QUFDQSxTQUFPLENBQUNVLFdBQVU7QUFDZCxZQUFRQSxPQUFNLE1BQU07QUFBQSxNQUNoQixLQUFLLGdCQUFnQjtBQUNqQixZQUFNLFdBQVcsZUFBZUEsT0FBTSxRQUFRLEtBQUtBLE9BQU0sVUFDbkQsZUFBb0IsV0FBV0EsT0FBTSxLQUFLLEdBQzFDLFdBQVcsZUFBZSxZQUFZLEtBQUs7QUFDakQsZUFBTywyQkFBMkIsUUFBUSxjQUFjLFFBQVE7QUFBQSxNQUNwRTtBQUFBLE1BQ0EsS0FBSztBQUNELGVBQUlBLE9BQU0sT0FBTyxXQUFXLElBQ2pCLDJCQUFnQyxtQkFBbUJBLE9BQU0sT0FBTyxDQUFDLENBQUMsQ0FBQyxLQUN2RSxtQ0FBd0MsV0FBV0EsT0FBTSxRQUFRLEdBQUcsQ0FBQztBQUFBLE1BQ2hGLEtBQUssV0FBVztBQUNaLFlBQU0sTUFBTUEsT0FBTSxZQUFZLE9BQU8sS0FDL0IsU0FBUyxVQUFVQSxPQUFNLE1BQU07QUFDckMsZUFBSSxTQUNPLHFCQUFxQkEsT0FBTSxVQUFVLE9BQU8sWUFBWSxHQUFHLEdBQUdBLE9BQU0sUUFBUSxTQUFTLENBQUMsSUFBSSxPQUFPLFFBQVEsVUFBVSxLQUN2SCxxQkFBcUJBLE9BQU0sVUFBVSxPQUFPLFVBQVUsR0FBRyxHQUFHQSxPQUFNLFFBQVEsU0FBUyxDQUFDO0FBQUEsTUFDL0Y7QUFBQSxNQUNBLEtBQUssYUFBYTtBQUNkLFlBQU0sTUFBTUEsT0FBTSxZQUFZLE9BQU8sS0FDL0IsU0FBUyxVQUFVQSxPQUFNLE1BQU07QUFDckMsZUFBSSxTQUNPLHVCQUF1QkEsT0FBTSxNQUFNLFlBQVksR0FBRyxHQUFHQSxPQUFNLFFBQVEsU0FBUyxDQUFDLElBQUksT0FBTyxJQUFJLEtBRWhHLHVCQUF1QkEsT0FBTSxNQUFNLFVBQVUsR0FBRyxHQUFHQSxPQUFNLFFBQVEsU0FBUyxDQUFDO0FBQUEsTUFDdEY7QUFBQSxNQUNBLEtBQUssa0JBQWtCO0FBQ25CLFlBQU0sU0FBU0E7QUFDZixlQUFJLE9BQU8sV0FBVyxnQkFDWCxvQ0FBb0MsT0FBTyxNQUFNLE1BRXhELE9BQU8sV0FBVyxjQUNYLGtDQUFrQyxPQUFPLE1BQU0sTUFDdEQsT0FBTyxXQUFXLGFBQ1gsaUNBQWlDLE9BQU8sUUFBUSxNQUN2RCxPQUFPLFdBQVcsVUFDWCxzQ0FBc0MsT0FBTyxPQUFPLEtBQ3hELFdBQVcsaUJBQWlCLE9BQU8sTUFBTSxLQUFLQSxPQUFNLE1BQU07QUFBQSxNQUNyRTtBQUFBLE1BQ0EsS0FBSztBQUNELGVBQU8seUNBQXlDQSxPQUFNLE9BQU87QUFBQSxNQUNqRSxLQUFLO0FBQ0QsZUFBTyxtQkFBbUJBLE9BQU0sS0FBSyxTQUFTLElBQUksTUFBTSxFQUFFLEtBQVUsV0FBV0EsT0FBTSxNQUFNLElBQUksQ0FBQztBQUFBLE1BQ3BHLEtBQUs7QUFDRCxlQUFPLGtCQUFrQkEsT0FBTSxNQUFNO0FBQUEsTUFDekMsS0FBSztBQUNELGVBQU87QUFBQSxNQUNYLEtBQUs7QUFDRCxlQUFPLG9CQUFvQkEsT0FBTSxNQUFNO0FBQUEsTUFDM0M7QUFDSSxlQUFPO0FBQUEsSUFDZjtBQUFBLEVBQ0o7QUFDSjtBQUNlLFNBQVJDLGNBQW9CO0FBQ3ZCLFNBQU87QUFBQSxJQUNILGFBQWEsTUFBTTtBQUFBLEVBQ3ZCO0FBQ0o7OztBQzVHQSxJQUFJLElBQ1MsVUFBVSxPQUFPLFdBQVcsR0FDNUIsU0FBUyxPQUFPLFVBQVUsR0FDMUIsZUFBTixNQUFtQjtBQUFBLEVBQ3RCLGNBQWM7QUFDVixTQUFLLE9BQU8sb0JBQUksUUFBUSxHQUN4QixLQUFLLFNBQVMsb0JBQUksSUFBSTtBQUFBLEVBQzFCO0FBQUEsRUFDQSxJQUFJLFdBQVcsT0FBTztBQUNsQixRQUFNQyxRQUFPLE1BQU0sQ0FBQztBQUNwQixnQkFBSyxLQUFLLElBQUksUUFBUUEsS0FBSSxHQUN0QkEsU0FBUSxPQUFPQSxTQUFTLFlBQVksUUFBUUEsU0FDNUMsS0FBSyxPQUFPLElBQUlBLE1BQUssSUFBSSxNQUFNLEdBRTVCO0FBQUEsRUFDWDtBQUFBLEVBQ0EsUUFBUTtBQUNKLGdCQUFLLE9BQU8sb0JBQUksUUFBUSxHQUN4QixLQUFLLFNBQVMsb0JBQUksSUFBSSxHQUNmO0FBQUEsRUFDWDtBQUFBLEVBQ0EsT0FBTyxRQUFRO0FBQ1gsUUFBTUEsUUFBTyxLQUFLLEtBQUssSUFBSSxNQUFNO0FBQ2pDLFdBQUlBLFNBQVEsT0FBT0EsU0FBUyxZQUFZLFFBQVFBLFNBQzVDLEtBQUssT0FBTyxPQUFPQSxNQUFLLEVBQUUsR0FFOUIsS0FBSyxLQUFLLE9BQU8sTUFBTSxHQUNoQjtBQUFBLEVBQ1g7QUFBQSxFQUNBLElBQUksUUFBUTtBQUdSLFFBQU0sSUFBSSxPQUFPLEtBQUs7QUFDdEIsUUFBSSxHQUFHO0FBQ0gsVUFBTSxLQUFLLEVBQUUsR0FBSSxLQUFLLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRztBQUNwQyxhQUFPLEdBQUc7QUFDVixVQUFNLElBQUksRUFBRSxHQUFHLElBQUksR0FBRyxLQUFLLEtBQUssSUFBSSxNQUFNLEVBQUU7QUFDNUMsYUFBTyxPQUFPLEtBQUssQ0FBQyxFQUFFLFNBQVMsSUFBSTtBQUFBLElBQ3ZDO0FBQ0EsV0FBTyxLQUFLLEtBQUssSUFBSSxNQUFNO0FBQUEsRUFDL0I7QUFBQSxFQUNBLElBQUksUUFBUTtBQUNSLFdBQU8sS0FBSyxLQUFLLElBQUksTUFBTTtBQUFBLEVBQy9CO0FBQ0o7QUFFTyxTQUFTLFdBQVc7QUFDdkIsU0FBTyxJQUFJLGFBQWE7QUFDNUI7QUFBQSxDQUNDLEtBQUssWUFBWSx5QkFBeUIsR0FBRyx1QkFBdUIsU0FBUztBQUN2RSxJQUFNLGlCQUFpQixXQUFXOzs7O0FDN0NsQyxTQUFTLFFBQVFDLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7O0FBVU8sU0FBUyxPQUFPQyxRQUFPLFFBQVE7QUFDbEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLE1BQU1BLFFBQU8sUUFBUTtBQUNqQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsTUFBTUEsUUFBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxRQUFRQSxRQUFPLFFBQVE7QUFDbkMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxTQUFTO0FBQUEsSUFDVCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFFBQVFBLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLFNBQVM7QUFBQSxJQUNULEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsUUFBUUEsUUFBTyxRQUFRO0FBQ25DLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsU0FBUztBQUFBLElBQ1QsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxLQUFLQSxRQUFPLFFBQVE7QUFDaEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTQyxRQUFPRCxRQUFPLFFBQVE7QUFDbEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFFBQVFBLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsTUFBTUEsUUFBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxPQUFPQSxRQUFPLFFBQVE7QUFDbEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLE1BQU1BLFFBQU8sUUFBUTtBQUNqQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsS0FBS0EsUUFBTyxRQUFRO0FBQ2hDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxPQUFPQSxRQUFPLFFBQVE7QUFDbEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLE1BQU1BLFFBQU8sUUFBUTtBQUNqQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsTUFBTUEsUUFBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxLQUFLQSxRQUFPLFFBQVE7QUFDaEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFFBQVFBLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsUUFBUUEsUUFBTyxRQUFRO0FBQ25DLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxRQUFRQSxRQUFPLFFBQVE7QUFDbkMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFdBQVdBLFFBQU8sUUFBUTtBQUN0QyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsTUFBTUEsUUFBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxLQUFLQSxRQUFPLFFBQVE7QUFDaEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMOztBQVNPLFNBQVMsYUFBYUUsUUFBTyxRQUFRO0FBQ3hDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsV0FBVztBQUFBLElBQ1gsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxTQUFTQSxRQUFPLFFBQVE7QUFDcEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRO0FBQUEsSUFDUixPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFNBQVNBLFFBQU8sUUFBUTtBQUNwQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLE9BQU87QUFBQSxJQUNQLFdBQVc7QUFBQSxJQUNYLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsYUFBYUEsUUFBTyxRQUFRO0FBQ3hDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sUUFBUTtBQUFBLElBQ1IsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxRQUFRQSxRQUFPLFFBQVE7QUFDbkMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixRQUFRLENBQUM7QUFBQSxJQUNULEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7O0FBV08sU0FBUyxLQUFLQyxRQUFPLFFBQVE7QUFDaEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFNBQVNBLFFBQU8sUUFBUTtBQUNwQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsU0FBU0EsUUFBTyxRQUFRO0FBQ3BDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sT0FBTztBQUFBLElBQ1AsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxPQUFPQSxRQUFPLFFBQVE7QUFDbEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFFBQVFBLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsU0FBU0EsUUFBTyxRQUFRO0FBQ3BDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDs7QUFVTyxTQUFTLFFBQVFDLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7O0FBVU8sU0FBUyxPQUFPQyxRQUFPLFFBQVE7QUFDbEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUCxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFFBQVFBLFFBQU8sUUFBUTtBQUNuQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsUUFBUUEsUUFBTyxRQUFRO0FBQ25DLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBU0MsWUFBV0QsUUFBTyxRQUFRO0FBQ3RDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBU0UsT0FBTUYsUUFBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxLQUFLQSxRQUFPO0FBQ3hCLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLEVBQ1YsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFNBQVNBLFFBQU87QUFDNUIsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsRUFDVixDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsT0FBT0EsUUFBTyxRQUFRO0FBQ2xDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxNQUFNQSxRQUFPLFFBQVE7QUFDakMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLE1BQU1BLFFBQU8sUUFBUTtBQUNqQyxTQUFPLElBQUlBLE9BQU07QUFBQSxJQUNiLE1BQU07QUFBQSxJQUNOLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7O0FBVU8sU0FBUyxLQUFLRyxRQUFPLFFBQVE7QUFDaEMsU0FBTyxJQUFJQSxPQUFNO0FBQUEsSUFDYixNQUFNO0FBQUEsSUFDTixHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLElBQUksT0FBTyxRQUFRO0FBQy9CLFNBQU8sSUFBVyxrQkFBa0I7QUFBQSxJQUNoQyxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsSUFDOUI7QUFBQSxJQUNBLFdBQVc7QUFBQSxFQUNmLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxLQUFLLE9BQU8sUUFBUTtBQUNoQyxTQUFPLElBQVcsa0JBQWtCO0FBQUEsSUFDaEMsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLElBQzlCO0FBQUEsSUFDQSxXQUFXO0FBQUEsRUFDZixDQUFDO0FBQ0w7O0FBS08sU0FBUyxJQUFJLE9BQU8sUUFBUTtBQUMvQixTQUFPLElBQVcscUJBQXFCO0FBQUEsSUFDbkMsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLElBQzlCO0FBQUEsSUFDQSxXQUFXO0FBQUEsRUFDZixDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsS0FBSyxPQUFPLFFBQVE7QUFDaEMsU0FBTyxJQUFXLHFCQUFxQjtBQUFBLElBQ25DLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxJQUM5QjtBQUFBLElBQ0EsV0FBVztBQUFBLEVBQ2YsQ0FBQztBQUNMOztBQUtPLFNBQVMsVUFBVSxRQUFRO0FBQzlCLFNBQU8sb0JBQUksR0FBRyxNQUFNO0FBQ3hCO0FBQUE7QUFHTyxTQUFTLFVBQVUsUUFBUTtBQUM5QixTQUFPLG9CQUFJLEdBQUcsTUFBTTtBQUN4QjtBQUFBO0FBR08sU0FBUyxhQUFhLFFBQVE7QUFDakMsU0FBTyxxQkFBSyxHQUFHLE1BQU07QUFDekI7QUFBQTtBQUdPLFNBQVMsYUFBYSxRQUFRO0FBQ2pDLFNBQU8scUJBQUssR0FBRyxNQUFNO0FBQ3pCO0FBQUE7QUFFTyxTQUFTLFlBQVksT0FBTyxRQUFRO0FBQ3ZDLFNBQU8sSUFBVyxvQkFBb0I7QUFBQSxJQUNsQyxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsSUFDOUI7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxTQUFTLFNBQVMsUUFBUTtBQUN0QyxTQUFPLElBQVcsaUJBQWlCO0FBQUEsSUFDL0IsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLElBQzlCO0FBQUEsRUFDSixDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsU0FBUyxTQUFTLFFBQVE7QUFDdEMsU0FBTyxJQUFXLGlCQUFpQjtBQUFBLElBQy9CLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxJQUM5QjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLE1BQU0sTUFBTSxRQUFRO0FBQ2hDLFNBQU8sSUFBVyxvQkFBb0I7QUFBQSxJQUNsQyxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsSUFDOUI7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxXQUFXLFNBQVMsUUFBUTtBQU14QyxTQUxXLElBQVcsbUJBQW1CO0FBQUEsSUFDckMsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLElBQzlCO0FBQUEsRUFDSixDQUFDO0FBRUw7QUFBQTtBQUVPLFNBQVMsV0FBVyxTQUFTLFFBQVE7QUFDeEMsU0FBTyxJQUFXLG1CQUFtQjtBQUFBLElBQ2pDLE9BQU87QUFBQSxJQUNQLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxJQUM5QjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFFBQVEsUUFBUSxRQUFRO0FBQ3BDLFNBQU8sSUFBVyxzQkFBc0I7QUFBQSxJQUNwQyxPQUFPO0FBQUEsSUFDUCxHQUFRLGdCQUFnQixNQUFNO0FBQUEsSUFDOUI7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxPQUFPLFNBQVMsUUFBUTtBQUNwQyxTQUFPLElBQVcsZUFBZTtBQUFBLElBQzdCLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxJQUM5QjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFdBQVcsUUFBUTtBQUMvQixTQUFPLElBQVcsbUJBQW1CO0FBQUEsSUFDakMsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxXQUFXLFFBQVE7QUFDL0IsU0FBTyxJQUFXLG1CQUFtQjtBQUFBLElBQ2pDLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsVUFBVSxVQUFVLFFBQVE7QUFDeEMsU0FBTyxJQUFXLGtCQUFrQjtBQUFBLElBQ2hDLE9BQU87QUFBQSxJQUNQLFFBQVE7QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxJQUM5QjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFlBQVksUUFBUSxRQUFRO0FBQ3hDLFNBQU8sSUFBVyxvQkFBb0I7QUFBQSxJQUNsQyxPQUFPO0FBQUEsSUFDUCxRQUFRO0FBQUEsSUFDUixHQUFRLGdCQUFnQixNQUFNO0FBQUEsSUFDOUI7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUFBO0FBRU8sU0FBUyxVQUFVLFFBQVEsUUFBUTtBQUN0QyxTQUFPLElBQVcsa0JBQWtCO0FBQUEsSUFDaEMsT0FBTztBQUFBLElBQ1AsUUFBUTtBQUFBLElBQ1IsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLElBQzlCO0FBQUEsRUFDSixDQUFDO0FBQ0w7QUFBQTtBQUVPLFNBQVMsVUFBVSxVQUFVLFFBQVEsUUFBUTtBQUNoRCxTQUFPLElBQVcsa0JBQWtCO0FBQUEsSUFDaEMsT0FBTztBQUFBLElBQ1A7QUFBQSxJQUNBO0FBQUEsSUFDQSxHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLE1BQU0sT0FBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBVyxrQkFBa0I7QUFBQSxJQUNoQyxPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTixHQUFRLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQUE7QUFFTyxTQUFTLFdBQVcsSUFBSTtBQUMzQixTQUFPLElBQVcsbUJBQW1CO0FBQUEsSUFDakMsT0FBTztBQUFBLElBQ1A7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUFBO0FBR08sU0FBUyxXQUFXLE1BQU07QUFDN0IsU0FBTywyQkFBVyxDQUFDLFVBQVUsTUFBTSxVQUFVLElBQUksQ0FBQztBQUN0RDtBQUFBO0FBR08sU0FBUyxRQUFRO0FBQ3BCLFNBQU8sMkJBQVcsQ0FBQyxVQUFVLE1BQU0sS0FBSyxDQUFDO0FBQzdDO0FBQUE7QUFHTyxTQUFTLGVBQWU7QUFDM0IsU0FBTywyQkFBVyxDQUFDLFVBQVUsTUFBTSxZQUFZLENBQUM7QUFDcEQ7QUFBQTtBQUdPLFNBQVMsZUFBZTtBQUMzQixTQUFPLDJCQUFXLENBQUMsVUFBVSxNQUFNLFlBQVksQ0FBQztBQUNwRDtBQUFBO0FBR08sU0FBUyxXQUFXO0FBQ3ZCLFNBQU8sMkJBQVcsQ0FBQyxVQUFlLFFBQVEsS0FBSyxDQUFDO0FBQ3BEO0FBQUE7QUFFTyxTQUFTLE9BQU9DLFFBQU8sU0FBUyxRQUFRO0FBQzNDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ047QUFBQTtBQUFBO0FBQUE7QUFBQSxJQUlBLEdBQVEsZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7O0FBeUhPLFNBQVMsTUFBTUMsUUFBTyxRQUFRO0FBQ2pDLFNBQU8sSUFBSUEsT0FBTTtBQUFBLElBQ2IsTUFBTTtBQUFBLElBQ04sR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDs7QUE2Rk8sU0FBUyxRQUFRQyxRQUFPLElBQUksU0FBUztBQUN4QyxNQUFNLE9BQVksZ0JBQWdCLE9BQU87QUFDekMsY0FBSyxVQUFVLEtBQUssUUFBUSxLQUNiLElBQUlBLE9BQU07QUFBQSxJQUNyQixNQUFNO0FBQUEsSUFDTixPQUFPO0FBQUEsSUFDUDtBQUFBLElBQ0EsR0FBRztBQUFBLEVBQ1AsQ0FBQztBQUVMO0FBQUE7QUFHTyxTQUFTLFFBQVFBLFFBQU8sSUFBSSxTQUFTO0FBT3hDLFNBTmUsSUFBSUEsT0FBTTtBQUFBLElBQ3JCLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQO0FBQUEsSUFDQSxHQUFRLGdCQUFnQixPQUFPO0FBQUEsRUFDbkMsQ0FBQztBQUVMO0FBQUE7QUFFTyxTQUFTLGFBQWEsSUFBSTtBQUM3QixNQUFNLEtBQUssdUJBQU8sQ0FBQyxhQUNmLFFBQVEsV0FBVyxDQUFDQyxXQUFVO0FBQzFCLFFBQUksT0FBT0EsVUFBVTtBQUNqQixjQUFRLE9BQU8sS0FBVSxNQUFNQSxRQUFPLFFBQVEsT0FBTyxHQUFHLEtBQUssR0FBRyxDQUFDO0FBQUEsU0FFaEU7QUFFRCxVQUFNLFNBQVNBO0FBQ2YsTUFBSSxPQUFPLFVBQ1AsT0FBTyxXQUFXLEtBQ3RCLE9BQU8sU0FBUyxPQUFPLE9BQU8sV0FDOUIsT0FBTyxVQUFVLE9BQU8sUUFBUSxRQUFRLFFBQ3hDLE9BQU8sU0FBUyxPQUFPLE9BQU8sS0FDOUIsT0FBTyxhQUFhLE9BQU8sV0FBVyxDQUFDLEdBQUcsS0FBSyxJQUFJLFFBQ25ELFFBQVEsT0FBTyxLQUFVLE1BQU0sTUFBTSxDQUFDO0FBQUEsSUFDMUM7QUFBQSxFQUNKLEdBQ08sR0FBRyxRQUFRLE9BQU8sT0FBTyxFQUNuQztBQUNELFNBQU87QUFDWDtBQUFBO0FBRU8sU0FBUyxPQUFPLElBQUksUUFBUTtBQUMvQixNQUFNLEtBQUssSUFBVyxVQUFVO0FBQUEsSUFDNUIsT0FBTztBQUFBLElBQ1AsR0FBUSxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDRCxZQUFHLEtBQUssUUFBUSxJQUNUO0FBQ1g7QUFBQTtBQUVPLFNBQVMsU0FBUyxhQUFhO0FBQ2xDLE1BQU0sS0FBSyxJQUFXLFVBQVUsRUFBRSxPQUFPLFdBQVcsQ0FBQztBQUNyRCxZQUFHLEtBQUssV0FBVztBQUFBLElBQ2YsQ0FBQyxTQUFTO0FBQ04sVUFBTSxXQUFzQixlQUFlLElBQUksSUFBSSxLQUFLLENBQUM7QUFDekQsTUFBVyxlQUFlLElBQUksTUFBTSxFQUFFLEdBQUcsVUFBVSxZQUFZLENBQUM7QUFBQSxJQUNwRTtBQUFBLEVBQ0osR0FDQSxHQUFHLEtBQUssUUFBUSxNQUFNO0FBQUEsRUFBRSxHQUNqQjtBQUNYO0FBQUE7QUFFTyxTQUFTLEtBQUssVUFBVTtBQUMzQixNQUFNLEtBQUssSUFBVyxVQUFVLEVBQUUsT0FBTyxPQUFPLENBQUM7QUFDakQsWUFBRyxLQUFLLFdBQVc7QUFBQSxJQUNmLENBQUMsU0FBUztBQUNOLFVBQU0sV0FBc0IsZUFBZSxJQUFJLElBQUksS0FBSyxDQUFDO0FBQ3pELE1BQVcsZUFBZSxJQUFJLE1BQU0sRUFBRSxHQUFHLFVBQVUsR0FBRyxTQUFTLENBQUM7QUFBQSxJQUNwRTtBQUFBLEVBQ0osR0FDQSxHQUFHLEtBQUssUUFBUSxNQUFNO0FBQUEsRUFBRSxHQUNqQjtBQUNYO0FBQUE7QUFFTyxTQUFTLFlBQVksU0FBUyxTQUFTO0FBQzFDLE1BQU0sU0FBYyxnQkFBZ0IsT0FBTyxHQUN2QyxjQUFjLE9BQU8sVUFBVSxDQUFDLFFBQVEsS0FBSyxPQUFPLE1BQU0sS0FBSyxTQUFTLEdBQ3hFLGFBQWEsT0FBTyxTQUFTLENBQUMsU0FBUyxLQUFLLE1BQU0sT0FBTyxLQUFLLFVBQVU7QUFDNUUsRUFBSSxPQUFPLFNBQVMsZ0JBQ2hCLGNBQWMsWUFBWSxJQUFJLENBQUMsTUFBTyxPQUFPLEtBQU0sV0FBVyxFQUFFLFlBQVksSUFBSSxDQUFFLEdBQ2xGLGFBQWEsV0FBVyxJQUFJLENBQUMsTUFBTyxPQUFPLEtBQU0sV0FBVyxFQUFFLFlBQVksSUFBSSxDQUFFO0FBRXBGLE1BQU0sWUFBWSxJQUFJLElBQUksV0FBVyxHQUMvQixXQUFXLElBQUksSUFBSSxVQUFVLEdBQzdCLFNBQVMsUUFBUSxTQUFpQixXQUNsQyxXQUFXLFFBQVEsV0FBbUIsYUFDdEMsVUFBVSxRQUFRLFVBQWtCLFlBQ3BDLGVBQWUsSUFBSSxRQUFRLEVBQUUsTUFBTSxVQUFVLE9BQU8sT0FBTyxNQUFNLENBQUMsR0FDbEUsZ0JBQWdCLElBQUksU0FBUyxFQUFFLE1BQU0sV0FBVyxPQUFPLE9BQU8sTUFBTSxDQUFDLEdBQ3JFQyxTQUFRLElBQUksT0FBTztBQUFBLElBQ3JCLE1BQU07QUFBQSxJQUNOLElBQUk7QUFBQSxJQUNKLEtBQUs7QUFBQSxJQUNMLFdBQVksQ0FBQyxPQUFPLFlBQVk7QUFDNUIsVUFBSSxPQUFPO0FBR1gsYUFGSSxPQUFPLFNBQVMsZ0JBQ2hCLE9BQU8sS0FBSyxZQUFZLElBQ3hCLFVBQVUsSUFBSSxJQUFJLElBQ1gsS0FFRixTQUFTLElBQUksSUFBSSxJQUNmLE1BR1AsUUFBUSxPQUFPLEtBQUs7QUFBQSxRQUNoQixNQUFNO0FBQUEsUUFDTixVQUFVO0FBQUEsUUFDVixRQUFRLENBQUMsR0FBRyxXQUFXLEdBQUcsUUFBUTtBQUFBLFFBQ2xDLE9BQU8sUUFBUTtBQUFBLFFBQ2YsTUFBTUE7QUFBQSxRQUNOLFVBQVU7QUFBQSxNQUNkLENBQUMsR0FDTSxDQUFDO0FBQUEsSUFFaEI7QUFBQSxJQUNBLGtCQUFtQixDQUFDLE9BQU8sYUFDbkIsVUFBVSxLQUNILFlBQVksQ0FBQyxLQUFLLFNBR2xCLFdBQVcsQ0FBQyxLQUFLO0FBQUEsSUFHaEMsT0FBTyxPQUFPO0FBQUEsRUFDbEIsQ0FBQztBQUNELFNBQU9BO0FBQ1g7QUFBQTtBQUVPLFNBQVMsY0FBY0YsUUFBTyxRQUFRLFdBQVcsVUFBVSxDQUFDLEdBQUc7QUFDbEUsTUFBTSxTQUFjLGdCQUFnQixPQUFPLEdBQ3JDLE1BQU07QUFBQSxJQUNSLEdBQVEsZ0JBQWdCLE9BQU87QUFBQSxJQUMvQixPQUFPO0FBQUEsSUFDUCxNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0EsSUFBSSxPQUFPLGFBQWMsYUFBYSxZQUFZLENBQUMsUUFBUSxVQUFVLEtBQUssR0FBRztBQUFBLElBQzdFLEdBQUc7QUFBQSxFQUNQO0FBQ0EsU0FBSSxxQkFBcUIsV0FDckIsSUFBSSxVQUFVLFlBRUwsSUFBSUEsT0FBTSxHQUFHO0FBRTlCOzs7QUNoakNPLFNBQVMsa0JBQWtCLFFBQVE7QUFFdEMsTUFBSSxTQUFTLFFBQVEsVUFBVTtBQUMvQixTQUFJLFdBQVcsY0FDWCxTQUFTLGFBQ1QsV0FBVyxjQUNYLFNBQVMsYUFDTjtBQUFBLElBQ0gsWUFBWSxPQUFPLGNBQWMsQ0FBQztBQUFBLElBQ2xDLGtCQUFrQixRQUFRLFlBQVk7QUFBQSxJQUN0QztBQUFBLElBQ0EsaUJBQWlCLFFBQVEsbUJBQW1CO0FBQUEsSUFDNUMsVUFBVSxRQUFRLGFBQWEsTUFBTTtBQUFBLElBQUU7QUFBQSxJQUN2QyxJQUFJLFFBQVEsTUFBTTtBQUFBLElBQ2xCLFNBQVM7QUFBQSxJQUNULE1BQU0sb0JBQUksSUFBSTtBQUFBLElBQ2QsUUFBUSxRQUFRLFVBQVU7QUFBQSxJQUMxQixRQUFRLFFBQVEsVUFBVTtBQUFBLElBQzFCLFVBQVUsUUFBUSxZQUFZO0FBQUEsRUFDbEM7QUFDSjtBQUNPLFNBQVNHLFNBQVEsUUFBUSxLQUFLLFVBQVUsRUFBRSxNQUFNLENBQUMsR0FBRyxZQUFZLENBQUMsRUFBRSxHQUFHO0FBQ3pFLE1BQUlDO0FBQ0osTUFBTSxNQUFNLE9BQU8sS0FBSyxLQUVsQixPQUFPLElBQUksS0FBSyxJQUFJLE1BQU07QUFDaEMsTUFBSTtBQUNBLGdCQUFLLFNBRVcsUUFBUSxXQUFXLFNBQVMsTUFBTSxNQUU5QyxLQUFLLFFBQVEsUUFBUSxPQUVsQixLQUFLO0FBR2hCLE1BQU0sU0FBUyxFQUFFLFFBQVEsQ0FBQyxHQUFHLE9BQU8sR0FBRyxPQUFPLFFBQVcsTUFBTSxRQUFRLEtBQUs7QUFDNUUsTUFBSSxLQUFLLElBQUksUUFBUSxNQUFNO0FBRTNCLE1BQU0saUJBQWlCLE9BQU8sS0FBSyxlQUFlO0FBQ2xELE1BQUk7QUFDQSxXQUFPLFNBQVM7QUFBQSxPQUVmO0FBQ0QsUUFBTSxTQUFTO0FBQUEsTUFDWCxHQUFHO0FBQUEsTUFDSCxZQUFZLENBQUMsR0FBRyxRQUFRLFlBQVksTUFBTTtBQUFBLE1BQzFDLE1BQU0sUUFBUTtBQUFBLElBQ2xCO0FBQ0EsUUFBSSxPQUFPLEtBQUs7QUFDWixhQUFPLEtBQUssa0JBQWtCLEtBQUssT0FBTyxRQUFRLE1BQU07QUFBQSxTQUV2RDtBQUNELFVBQU0sUUFBUSxPQUFPLFFBQ2YsWUFBWSxJQUFJLFdBQVcsSUFBSSxJQUFJO0FBQ3pDLFVBQUksQ0FBQztBQUNELGNBQU0sSUFBSSxNQUFNLHVEQUF1RCxJQUFJLElBQUksRUFBRTtBQUVyRixnQkFBVSxRQUFRLEtBQUssT0FBTyxNQUFNO0FBQUEsSUFDeEM7QUFDQSxRQUFNLFNBQVMsT0FBTyxLQUFLO0FBQzNCLElBQUksV0FFSyxPQUFPLFFBQ1IsT0FBTyxNQUFNLFNBQ2pCRCxTQUFRLFFBQVEsS0FBSyxNQUFNLEdBQzNCLElBQUksS0FBSyxJQUFJLE1BQU0sRUFBRSxXQUFXO0FBQUEsRUFFeEM7QUFFQSxNQUFNRSxRQUFPLElBQUksaUJBQWlCLElBQUksTUFBTTtBQUM1QyxTQUFJQSxTQUNBLE9BQU8sT0FBTyxPQUFPLFFBQVFBLEtBQUksR0FDakMsSUFBSSxPQUFPLFdBQVcsZUFBZSxNQUFNLE1BRTNDLE9BQU8sT0FBTyxPQUFPLFVBQ3JCLE9BQU8sT0FBTyxPQUFPLFVBR3JCLElBQUksT0FBTyxXQUFXLE9BQU8sT0FBTyxlQUNuQ0QsTUFBSyxPQUFPLFFBQVEsWUFBWUEsSUFBRyxVQUFVLE9BQU8sT0FBTyxhQUNoRSxPQUFPLE9BQU8sT0FBTyxXQUVMLElBQUksS0FBSyxJQUFJLE1BQU0sRUFDcEI7QUFDbkI7QUFDTyxTQUFTLFlBQVksS0FBSyxRQUUvQjtBQUVFLE1BQU0sT0FBTyxJQUFJLEtBQUssSUFBSSxNQUFNO0FBQ2hDLE1BQUksQ0FBQztBQUNELFVBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUUvRCxNQUFNLGFBQWEsb0JBQUksSUFBSTtBQUMzQixXQUFXLFNBQVMsSUFBSSxLQUFLLFFBQVEsR0FBRztBQUNwQyxRQUFNLEtBQUssSUFBSSxpQkFBaUIsSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHO0FBQy9DLFFBQUksSUFBSTtBQUNKLFVBQU0sV0FBVyxXQUFXLElBQUksRUFBRTtBQUNsQyxVQUFJLFlBQVksYUFBYSxNQUFNLENBQUM7QUFDaEMsY0FBTSxJQUFJLE1BQU0sd0JBQXdCLEVBQUUsbUhBQW1IO0FBRWpLLGlCQUFXLElBQUksSUFBSSxNQUFNLENBQUMsQ0FBQztBQUFBLElBQy9CO0FBQUEsRUFDSjtBQUdBLE1BQU0sVUFBVSxDQUFDLFVBQVU7QUFLdkIsUUFBTSxjQUFjLElBQUksV0FBVyxrQkFBa0IsVUFBVTtBQUMvRCxRQUFJLElBQUksVUFBVTtBQUNkLFVBQU0sYUFBYSxJQUFJLFNBQVMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFFbEQsZUFBZSxJQUFJLFNBQVMsUUFBUSxDQUFDRSxRQUFPQTtBQUNsRCxVQUFJO0FBQ0EsZUFBTyxFQUFFLEtBQUssYUFBYSxVQUFVLEVBQUU7QUFHM0MsVUFBTSxLQUFLLE1BQU0sQ0FBQyxFQUFFLFNBQVMsTUFBTSxDQUFDLEVBQUUsT0FBTyxNQUFNLFNBQVMsSUFBSSxTQUFTO0FBQ3pFLG1CQUFNLENBQUMsRUFBRSxRQUFRLElBQ1YsRUFBRSxPQUFPLElBQUksS0FBSyxHQUFHLGFBQWEsVUFBVSxDQUFDLEtBQUssV0FBVyxJQUFJLEVBQUUsR0FBRztBQUFBLElBQ2pGO0FBQ0EsUUFBSSxNQUFNLENBQUMsTUFBTTtBQUNiLGFBQU8sRUFBRSxLQUFLLElBQUk7QUFJdEIsUUFBTSxlQUFlLEtBQWdCLFdBQVcsS0FDMUMsUUFBUSxNQUFNLENBQUMsRUFBRSxPQUFPLE1BQU0sV0FBVyxJQUFJLFNBQVM7QUFDNUQsV0FBTyxFQUFFLE9BQU8sS0FBSyxlQUFlLE1BQU07QUFBQSxFQUM5QyxHQUdNLGVBQWUsQ0FBQyxVQUFVO0FBRTVCLFFBQUksTUFBTSxDQUFDLEVBQUUsT0FBTztBQUNoQjtBQUVKLFFBQU0sT0FBTyxNQUFNLENBQUMsR0FDZCxFQUFFLEtBQUssTUFBTSxJQUFJLFFBQVEsS0FBSztBQUNwQyxTQUFLLE1BQU0sRUFBRSxHQUFHLEtBQUssT0FBTyxHQUd4QixVQUNBLEtBQUssUUFBUTtBQUVqQixRQUFNQyxVQUFTLEtBQUs7QUFDcEIsYUFBVyxPQUFPQTtBQUNkLGFBQU9BLFFBQU8sR0FBRztBQUVyQixJQUFBQSxRQUFPLE9BQU87QUFBQSxFQUNsQjtBQUdBLE1BQUksSUFBSSxXQUFXO0FBQ2YsYUFBVyxTQUFTLElBQUksS0FBSyxRQUFRLEdBQUc7QUFDcEMsVUFBTSxPQUFPLE1BQU0sQ0FBQztBQUNwQixVQUFJLEtBQUs7QUFDTCxjQUFNLElBQUksTUFBTSxxQkFDUCxLQUFLLE9BQU8sS0FBSyxHQUFHLENBQUM7QUFBQTtBQUFBLGlGQUN3RDtBQUFBLElBRTlGO0FBR0osV0FBVyxTQUFTLElBQUksS0FBSyxRQUFRLEdBQUc7QUFDcEMsUUFBTSxPQUFPLE1BQU0sQ0FBQztBQUVwQixRQUFJLFdBQVcsTUFBTSxDQUFDLEdBQUc7QUFDckIsbUJBQWEsS0FBSztBQUNsQjtBQUFBLElBQ0o7QUFFQSxRQUFJLElBQUksVUFBVTtBQUNkLFVBQU0sTUFBTSxJQUFJLFNBQVMsU0FBUyxJQUFJLE1BQU0sQ0FBQyxDQUFDLEdBQUc7QUFDakQsVUFBSSxXQUFXLE1BQU0sQ0FBQyxLQUFLLEtBQUs7QUFDNUIscUJBQWEsS0FBSztBQUNsQjtBQUFBLE1BQ0o7QUFBQSxJQUNKO0FBR0EsUUFEVyxJQUFJLGlCQUFpQixJQUFJLE1BQU0sQ0FBQyxDQUFDLEdBQUcsSUFDdkM7QUFDSixtQkFBYSxLQUFLO0FBQ2xCO0FBQUEsSUFDSjtBQUVBLFFBQUksS0FBSyxPQUFPO0FBRVosbUJBQWEsS0FBSztBQUNsQjtBQUFBLElBQ0o7QUFFQSxRQUFJLEtBQUssUUFBUSxLQUNULElBQUksV0FBVyxPQUFPO0FBQ3RCLG1CQUFhLEtBQUs7QUFFbEI7QUFBQSxJQUNKO0FBQUEsRUFFUjtBQUNKO0FBQ08sU0FBUyxTQUFTLEtBQUssUUFBUTtBQUNsQyxNQUFNLE9BQU8sSUFBSSxLQUFLLElBQUksTUFBTTtBQUNoQyxNQUFJLENBQUM7QUFDRCxVQUFNLElBQUksTUFBTSwyQ0FBMkM7QUFFL0QsTUFBTSxhQUFhLENBQUMsY0FBYztBQUM5QixRQUFNLE9BQU8sSUFBSSxLQUFLLElBQUksU0FBUztBQUVuQyxRQUFJLEtBQUssUUFBUTtBQUNiO0FBQ0osUUFBTUEsVUFBUyxLQUFLLE9BQU8sS0FBSyxRQUMxQixVQUFVLEVBQUUsR0FBR0EsUUFBTyxHQUN0QixNQUFNLEtBQUs7QUFFakIsUUFEQSxLQUFLLE1BQU0sTUFDUCxLQUFLO0FBQ0wsaUJBQVcsR0FBRztBQUNkLFVBQU0sVUFBVSxJQUFJLEtBQUssSUFBSSxHQUFHLEdBQzFCLFlBQVksUUFBUTtBQWMxQixVQVpJLFVBQVUsU0FBUyxJQUFJLFdBQVcsY0FBYyxJQUFJLFdBQVcsY0FBYyxJQUFJLFdBQVcsa0JBRTVGQSxRQUFPLFFBQVFBLFFBQU8sU0FBUyxDQUFDLEdBQ2hDQSxRQUFPLE1BQU0sS0FBSyxTQUFTLEtBRzNCLE9BQU8sT0FBT0EsU0FBUSxTQUFTLEdBR25DLE9BQU8sT0FBT0EsU0FBUSxPQUFPLEdBQ1QsVUFBVSxLQUFLLFdBQVc7QUFHMUMsaUJBQVcsT0FBT0E7QUFDZCxVQUFJLFFBQVEsVUFBVSxRQUFRLFdBRXhCLE9BQU8sV0FDVCxPQUFPQSxRQUFPLEdBQUc7QUFLN0IsVUFBSSxVQUFVLFFBQVEsUUFBUTtBQUMxQixpQkFBVyxPQUFPQTtBQUNkLFVBQUksUUFBUSxVQUFVLFFBQVEsV0FFMUIsT0FBTyxRQUFRLE9BQU8sS0FBSyxVQUFVQSxRQUFPLEdBQUcsQ0FBQyxNQUFNLEtBQUssVUFBVSxRQUFRLElBQUksR0FBRyxDQUFDLEtBQ3JGLE9BQU9BLFFBQU8sR0FBRztBQUFBLElBSWpDO0FBSUEsUUFBTSxTQUFTLFVBQVUsS0FBSztBQUM5QixRQUFJLFVBQVUsV0FBVyxLQUFLO0FBRTFCLGlCQUFXLE1BQU07QUFDakIsVUFBTSxhQUFhLElBQUksS0FBSyxJQUFJLE1BQU07QUFDdEMsVUFBSSxZQUFZLE9BQU8sU0FDbkJBLFFBQU8sT0FBTyxXQUFXLE9BQU8sTUFFNUIsV0FBVztBQUNYLGlCQUFXLE9BQU9BO0FBQ2QsVUFBSSxRQUFRLFVBQVUsUUFBUSxXQUUxQixPQUFPLFdBQVcsT0FBTyxLQUFLLFVBQVVBLFFBQU8sR0FBRyxDQUFDLE1BQU0sS0FBSyxVQUFVLFdBQVcsSUFBSSxHQUFHLENBQUMsS0FDM0YsT0FBT0EsUUFBTyxHQUFHO0FBQUEsSUFLckM7QUFFQSxRQUFJLFNBQVM7QUFBQSxNQUNUO0FBQUEsTUFDQSxZQUFZQTtBQUFBLE1BQ1osTUFBTSxLQUFLLFFBQVEsQ0FBQztBQUFBLElBQ3hCLENBQUM7QUFBQSxFQUNMO0FBQ0EsV0FBVyxTQUFTLENBQUMsR0FBRyxJQUFJLEtBQUssUUFBUSxDQUFDLEVBQUUsUUFBUTtBQUNoRCxlQUFXLE1BQU0sQ0FBQyxDQUFDO0FBRXZCLE1BQU0sU0FBUyxDQUFDO0FBZ0JoQixNQWZJLElBQUksV0FBVyxrQkFDZixPQUFPLFVBQVUsaURBRVosSUFBSSxXQUFXLGFBQ3BCLE9BQU8sVUFBVSw0Q0FFWixJQUFJLFdBQVcsYUFDcEIsT0FBTyxVQUFVLDRDQUVaLElBQUksUUFNVCxJQUFJLFVBQVUsS0FBSztBQUNuQixRQUFNLEtBQUssSUFBSSxTQUFTLFNBQVMsSUFBSSxNQUFNLEdBQUc7QUFDOUMsUUFBSSxDQUFDO0FBQ0QsWUFBTSxJQUFJLE1BQU0sb0NBQW9DO0FBQ3hELFdBQU8sTUFBTSxJQUFJLFNBQVMsSUFBSSxFQUFFO0FBQUEsRUFDcEM7QUFDQSxTQUFPLE9BQU8sUUFBUSxLQUFLLE9BQU8sS0FBSyxNQUFNO0FBRTdDLE1BQU0sT0FBTyxJQUFJLFVBQVUsUUFBUSxDQUFDO0FBQ3BDLFdBQVcsU0FBUyxJQUFJLEtBQUssUUFBUSxHQUFHO0FBQ3BDLFFBQU0sT0FBTyxNQUFNLENBQUM7QUFDcEIsSUFBSSxLQUFLLE9BQU8sS0FBSyxVQUNqQixLQUFLLEtBQUssS0FBSyxJQUFJLEtBQUs7QUFBQSxFQUVoQztBQUVBLEVBQUksSUFBSSxZQUdBLE9BQU8sS0FBSyxJQUFJLEVBQUUsU0FBUyxNQUN2QixJQUFJLFdBQVcsa0JBQ2YsT0FBTyxRQUFRLE9BR2YsT0FBTyxjQUFjO0FBSWpDLE1BQUk7QUFJQSxRQUFNLFlBQVksS0FBSyxNQUFNLEtBQUssVUFBVSxNQUFNLENBQUM7QUFDbkQsa0JBQU8sZUFBZSxXQUFXLGFBQWE7QUFBQSxNQUMxQyxPQUFPO0FBQUEsUUFDSCxHQUFHLE9BQU8sV0FBVztBQUFBLFFBQ3JCLFlBQVk7QUFBQSxVQUNSLE9BQU8sK0JBQStCLFFBQVEsU0FBUyxJQUFJLFVBQVU7QUFBQSxVQUNyRSxRQUFRLCtCQUErQixRQUFRLFVBQVUsSUFBSSxVQUFVO0FBQUEsUUFDM0U7QUFBQSxNQUNKO0FBQUEsTUFDQSxZQUFZO0FBQUEsTUFDWixVQUFVO0FBQUEsSUFDZCxDQUFDLEdBQ007QUFBQSxFQUNYLFFBQ2E7QUFDVCxVQUFNLElBQUksTUFBTSxrQ0FBa0M7QUFBQSxFQUN0RDtBQUNKO0FBQ0EsU0FBUyxlQUFlLFNBQVMsTUFBTTtBQUNuQyxNQUFNLE1BQU0sUUFBUSxFQUFFLE1BQU0sb0JBQUksSUFBSSxFQUFFO0FBQ3RDLE1BQUksSUFBSSxLQUFLLElBQUksT0FBTztBQUNwQixXQUFPO0FBQ1gsTUFBSSxLQUFLLElBQUksT0FBTztBQUNwQixNQUFNLE1BQU0sUUFBUSxLQUFLO0FBQ3pCLE1BQUksSUFBSSxTQUFTO0FBQ2IsV0FBTztBQUNYLE1BQUksSUFBSSxTQUFTO0FBQ2IsV0FBTyxlQUFlLElBQUksU0FBUyxHQUFHO0FBQzFDLE1BQUksSUFBSSxTQUFTO0FBQ2IsV0FBTyxlQUFlLElBQUksV0FBVyxHQUFHO0FBQzVDLE1BQUksSUFBSSxTQUFTO0FBQ2IsV0FBTyxlQUFlLElBQUksT0FBTyxHQUFHLEdBQUc7QUFDM0MsTUFBSSxJQUFJLFNBQVMsYUFDYixJQUFJLFNBQVMsY0FDYixJQUFJLFNBQVMsaUJBQ2IsSUFBSSxTQUFTLGNBQ2IsSUFBSSxTQUFTLGNBQ2IsSUFBSSxTQUFTLGFBQ2IsSUFBSSxTQUFTO0FBQ2IsV0FBTyxlQUFlLElBQUksV0FBVyxHQUFHO0FBRTVDLE1BQUksSUFBSSxTQUFTO0FBQ2IsV0FBTyxlQUFlLElBQUksTUFBTSxHQUFHLEtBQUssZUFBZSxJQUFJLE9BQU8sR0FBRztBQUV6RSxNQUFJLElBQUksU0FBUyxZQUFZLElBQUksU0FBUztBQUN0QyxXQUFPLGVBQWUsSUFBSSxTQUFTLEdBQUcsS0FBSyxlQUFlLElBQUksV0FBVyxHQUFHO0FBRWhGLE1BQUksSUFBSSxTQUFTO0FBQ2IsV0FBTyxlQUFlLElBQUksSUFBSSxHQUFHLEtBQUssZUFBZSxJQUFJLEtBQUssR0FBRztBQUVyRSxNQUFJLElBQUksU0FBUyxVQUFVO0FBQ3ZCLGFBQVcsT0FBTyxJQUFJO0FBQ2xCLFVBQUksZUFBZSxJQUFJLE1BQU0sR0FBRyxHQUFHLEdBQUc7QUFDbEMsZUFBTztBQUVmLFdBQU87QUFBQSxFQUNYO0FBQ0EsTUFBSSxJQUFJLFNBQVMsU0FBUztBQUN0QixhQUFXLFVBQVUsSUFBSTtBQUNyQixVQUFJLGVBQWUsUUFBUSxHQUFHO0FBQzFCLGVBQU87QUFFZixXQUFPO0FBQUEsRUFDWDtBQUNBLE1BQUksSUFBSSxTQUFTLFNBQVM7QUFDdEIsYUFBVyxRQUFRLElBQUk7QUFDbkIsVUFBSSxlQUFlLE1BQU0sR0FBRztBQUN4QixlQUFPO0FBRWYsV0FBSSxPQUFJLFFBQVEsZUFBZSxJQUFJLE1BQU0sR0FBRztBQUFBLEVBR2hEO0FBQ0EsU0FBTztBQUNYO0FBS08sSUFBTSwyQkFBMkIsQ0FBQyxRQUFRLGFBQWEsQ0FBQyxNQUFNLENBQUMsV0FBVztBQUM3RSxNQUFNLE1BQU0sa0JBQWtCLEVBQUUsR0FBRyxRQUFRLFdBQVcsQ0FBQztBQUN2RCxTQUFBSixTQUFRLFFBQVEsR0FBRyxHQUNuQixZQUFZLEtBQUssTUFBTSxHQUNoQixTQUFTLEtBQUssTUFBTTtBQUMvQixHQUNhLGlDQUFpQyxDQUFDLFFBQVEsSUFBSSxhQUFhLENBQUMsTUFBTSxDQUFDLFdBQVc7QUFDdkYsTUFBTSxFQUFFLGdCQUFnQixPQUFPLElBQUksVUFBVSxDQUFDLEdBQ3hDLE1BQU0sa0JBQWtCLEVBQUUsR0FBSSxrQkFBa0IsQ0FBQyxHQUFJLFFBQVEsSUFBSSxXQUFXLENBQUM7QUFDbkYsU0FBQUEsU0FBUSxRQUFRLEdBQUcsR0FDbkIsWUFBWSxLQUFLLE1BQU0sR0FDaEIsU0FBUyxLQUFLLE1BQU07QUFDL0I7OztBQ2xiQSxJQUFNLFlBQVk7QUFBQSxFQUNkLE1BQU07QUFBQSxFQUNOLEtBQUs7QUFBQSxFQUNMLFVBQVU7QUFBQSxFQUNWLGFBQWE7QUFBQSxFQUNiLE9BQU87QUFBQTtBQUNYLEdBRWEsa0JBQWtCLENBQUMsUUFBUSxLQUFLLE9BQU8sWUFBWTtBQUM1RCxNQUFNSyxRQUFPO0FBQ2IsRUFBQUEsTUFBSyxPQUFPO0FBQ1osTUFBTSxFQUFFLFNBQVMsU0FBUyxRQUFRLFVBQVUsZ0JBQWdCLElBQUksT0FBTyxLQUNsRTtBQWtCTCxNQWpCSSxPQUFPLFdBQVksYUFDbkJBLE1BQUssWUFBWSxVQUNqQixPQUFPLFdBQVksYUFDbkJBLE1BQUssWUFBWSxVQUVqQixXQUNBQSxNQUFLLFNBQVMsVUFBVSxNQUFNLEtBQUssUUFDL0JBLE1BQUssV0FBVyxNQUNoQixPQUFPQSxNQUFLLFFBR1osV0FBVyxVQUNYLE9BQU9BLE1BQUssU0FHaEIsb0JBQ0FBLE1BQUssa0JBQWtCLGtCQUN2QixZQUFZLFNBQVMsT0FBTyxHQUFHO0FBQy9CLFFBQU0sVUFBVSxDQUFDLEdBQUcsUUFBUTtBQUM1QixJQUFJLFFBQVEsV0FBVyxJQUNuQkEsTUFBSyxVQUFVLFFBQVEsQ0FBQyxFQUFFLFNBQ3JCLFFBQVEsU0FBUyxNQUN0QkEsTUFBSyxRQUFRO0FBQUEsTUFDVCxHQUFHLFFBQVEsSUFBSSxDQUFDLFdBQVc7QUFBQSxRQUN2QixHQUFJLElBQUksV0FBVyxjQUFjLElBQUksV0FBVyxjQUFjLElBQUksV0FBVyxnQkFDdkUsRUFBRSxNQUFNLFNBQVMsSUFDakIsQ0FBQztBQUFBLFFBQ1AsU0FBUyxNQUFNO0FBQUEsTUFDbkIsRUFBRTtBQUFBLElBQ047QUFBQSxFQUVSO0FBQ0osR0FDYSxrQkFBa0IsQ0FBQyxRQUFRLEtBQUssT0FBTyxZQUFZO0FBQzVELE1BQU1BLFFBQU8sT0FDUCxFQUFFLFNBQVMsU0FBUyxRQUFRLFlBQVksa0JBQWtCLGlCQUFpQixJQUFJLE9BQU8sS0FBSztBQUNqRyxFQUFJLE9BQU8sVUFBVyxZQUFZLE9BQU8sU0FBUyxLQUFLLElBQ25EQSxNQUFLLE9BQU8sWUFFWkEsTUFBSyxPQUFPLFVBQ1osT0FBTyxvQkFBcUIsYUFDeEIsSUFBSSxXQUFXLGNBQWMsSUFBSSxXQUFXLGlCQUM1Q0EsTUFBSyxVQUFVLGtCQUNmQSxNQUFLLG1CQUFtQixNQUd4QkEsTUFBSyxtQkFBbUIsbUJBRzVCLE9BQU8sV0FBWSxhQUNuQkEsTUFBSyxVQUFVLFNBQ1gsT0FBTyxvQkFBcUIsWUFBWSxJQUFJLFdBQVcsZUFDbkQsb0JBQW9CLFVBQ3BCLE9BQU9BLE1BQUssVUFFWixPQUFPQSxNQUFLLG9CQUdwQixPQUFPLG9CQUFxQixhQUN4QixJQUFJLFdBQVcsY0FBYyxJQUFJLFdBQVcsaUJBQzVDQSxNQUFLLFVBQVUsa0JBQ2ZBLE1BQUssbUJBQW1CLE1BR3hCQSxNQUFLLG1CQUFtQixtQkFHNUIsT0FBTyxXQUFZLGFBQ25CQSxNQUFLLFVBQVUsU0FDWCxPQUFPLG9CQUFxQixZQUFZLElBQUksV0FBVyxlQUNuRCxvQkFBb0IsVUFDcEIsT0FBT0EsTUFBSyxVQUVaLE9BQU9BLE1BQUssb0JBR3BCLE9BQU8sY0FBZSxhQUN0QkEsTUFBSyxhQUFhO0FBQzFCLEdBQ2EsbUJBQW1CLENBQUMsU0FBUyxNQUFNQSxPQUFNLFlBQVk7QUFDOUQsRUFBQUEsTUFBSyxPQUFPO0FBQ2hCLEdBQ2Esa0JBQWtCLENBQUMsU0FBUyxLQUFLLE9BQU8sWUFBWTtBQUM3RCxNQUFJLElBQUksb0JBQW9CO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLDZDQUE2QztBQUVyRSxHQUNhLGtCQUFrQixDQUFDLFNBQVMsS0FBSyxPQUFPLFlBQVk7QUFDN0QsTUFBSSxJQUFJLG9CQUFvQjtBQUN4QixVQUFNLElBQUksTUFBTSw4Q0FBOEM7QUFFdEUsR0FDYSxnQkFBZ0IsQ0FBQyxTQUFTLEtBQUtBLE9BQU0sWUFBWTtBQUMxRCxFQUFJLElBQUksV0FBVyxpQkFDZkEsTUFBSyxPQUFPLFVBQ1pBLE1BQUssV0FBVyxJQUNoQkEsTUFBSyxPQUFPLENBQUMsSUFBSSxLQUdqQkEsTUFBSyxPQUFPO0FBRXBCLEdBQ2EscUJBQXFCLENBQUMsU0FBUyxLQUFLLE9BQU8sWUFBWTtBQUNoRSxNQUFJLElBQUksb0JBQW9CO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLGdEQUFnRDtBQUV4RSxHQUNhLGdCQUFnQixDQUFDLFNBQVMsS0FBSyxPQUFPLFlBQVk7QUFDM0QsTUFBSSxJQUFJLG9CQUFvQjtBQUN4QixVQUFNLElBQUksTUFBTSwyQ0FBMkM7QUFFbkUsR0FDYSxpQkFBaUIsQ0FBQyxTQUFTLE1BQU1BLE9BQU0sWUFBWTtBQUM1RCxFQUFBQSxNQUFLLE1BQU0sQ0FBQztBQUNoQixHQUNhLGVBQWUsQ0FBQyxTQUFTLE1BQU0sT0FBTyxZQUFZO0FBRS9ELEdBQ2EsbUJBQW1CLENBQUMsU0FBUyxNQUFNLE9BQU8sWUFBWTtBQUVuRSxHQUNhLGdCQUFnQixDQUFDLFNBQVMsS0FBSyxPQUFPLFlBQVk7QUFDM0QsTUFBSSxJQUFJLG9CQUFvQjtBQUN4QixVQUFNLElBQUksTUFBTSwyQ0FBMkM7QUFFbkUsR0FDYSxnQkFBZ0IsQ0FBQyxRQUFRLE1BQU1BLE9BQU0sWUFBWTtBQUMxRCxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQ2xCLFNBQVMsY0FBYyxJQUFJLE9BQU87QUFFeEMsRUFBSSxPQUFPLE1BQU0sQ0FBQyxNQUFNLE9BQU8sS0FBTSxRQUFRLE1BQ3pDQSxNQUFLLE9BQU8sV0FDWixPQUFPLE1BQU0sQ0FBQyxNQUFNLE9BQU8sS0FBTSxRQUFRLE1BQ3pDQSxNQUFLLE9BQU8sV0FDaEJBLE1BQUssT0FBTztBQUNoQixHQUNhLG1CQUFtQixDQUFDLFFBQVEsS0FBS0EsT0FBTSxZQUFZO0FBQzVELE1BQU0sTUFBTSxPQUFPLEtBQUssS0FDbEIsT0FBTyxDQUFDO0FBQ2QsV0FBVyxPQUFPLElBQUk7QUFDbEIsUUFBSSxRQUFRO0FBQ1IsVUFBSSxJQUFJLG9CQUFvQjtBQUN4QixjQUFNLElBQUksTUFBTSwwREFBMEQ7QUFBQSxlQU16RSxPQUFPLE9BQVEsVUFBVTtBQUM5QixVQUFJLElBQUksb0JBQW9CO0FBQ3hCLGNBQU0sSUFBSSxNQUFNLHNEQUFzRDtBQUd0RSxXQUFLLEtBQUssT0FBTyxHQUFHLENBQUM7QUFBQSxJQUU3QjtBQUVJLFdBQUssS0FBSyxHQUFHO0FBR3JCLE1BQUksS0FBSyxXQUFXO0FBR2YsUUFBSSxLQUFLLFdBQVcsR0FBRztBQUN4QixVQUFNLE1BQU0sS0FBSyxDQUFDO0FBQ2xCLE1BQUFBLE1BQUssT0FBTyxRQUFRLE9BQU8sU0FBUyxPQUFPLEtBQ3ZDLElBQUksV0FBVyxjQUFjLElBQUksV0FBVyxnQkFDNUNBLE1BQUssT0FBTyxDQUFDLEdBQUcsSUFHaEJBLE1BQUssUUFBUTtBQUFBLElBRXJCO0FBRUksTUFBSSxLQUFLLE1BQU0sQ0FBQyxNQUFNLE9BQU8sS0FBTSxRQUFRLE1BQ3ZDQSxNQUFLLE9BQU8sV0FDWixLQUFLLE1BQU0sQ0FBQyxNQUFNLE9BQU8sS0FBTSxRQUFRLE1BQ3ZDQSxNQUFLLE9BQU8sV0FDWixLQUFLLE1BQU0sQ0FBQyxNQUFNLE9BQU8sS0FBTSxTQUFTLE1BQ3hDQSxNQUFLLE9BQU8sWUFDWixLQUFLLE1BQU0sQ0FBQyxNQUFNLE1BQU0sSUFBSSxNQUM1QkEsTUFBSyxPQUFPLFNBQ2hCQSxNQUFLLE9BQU87QUFFcEIsR0FDYSxlQUFlLENBQUMsU0FBUyxLQUFLLE9BQU8sWUFBWTtBQUMxRCxNQUFJLElBQUksb0JBQW9CO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUVsRSxHQUNhLDJCQUEyQixDQUFDLFFBQVEsTUFBTUEsT0FBTSxZQUFZO0FBQ3JFLE1BQU0sUUFBUUEsT0FDUixVQUFVLE9BQU8sS0FBSztBQUM1QixNQUFJLENBQUM7QUFDRCxVQUFNLElBQUksTUFBTSx1Q0FBdUM7QUFDM0QsUUFBTSxPQUFPLFVBQ2IsTUFBTSxVQUFVLFFBQVE7QUFDNUIsR0FDYSxnQkFBZ0IsQ0FBQyxRQUFRLE1BQU1BLE9BQU0sWUFBWTtBQUMxRCxNQUFNLFFBQVFBLE9BQ1JDLFFBQU87QUFBQSxJQUNULE1BQU07QUFBQSxJQUNOLFFBQVE7QUFBQSxJQUNSLGlCQUFpQjtBQUFBLEVBQ3JCLEdBQ00sRUFBRSxTQUFTLFNBQVMsS0FBSyxJQUFJLE9BQU8sS0FBSztBQUMvQyxFQUFJLFlBQVksV0FDWkEsTUFBSyxZQUFZLFVBQ2pCLFlBQVksV0FDWkEsTUFBSyxZQUFZLFVBQ2pCLE9BQ0ksS0FBSyxXQUFXLEtBQ2hCQSxNQUFLLG1CQUFtQixLQUFLLENBQUMsR0FDOUIsT0FBTyxPQUFPLE9BQU9BLEtBQUksTUFHekIsT0FBTyxPQUFPLE9BQU9BLEtBQUksR0FDekIsTUFBTSxRQUFRLEtBQUssSUFBSSxDQUFDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxFQUFFLEtBSTNELE9BQU8sT0FBTyxPQUFPQSxLQUFJO0FBRWpDLEdBQ2EsbUJBQW1CLENBQUMsU0FBUyxNQUFNRCxPQUFNLFlBQVk7QUFDOUQsRUFBQUEsTUFBSyxPQUFPO0FBQ2hCLEdBQ2Esa0JBQWtCLENBQUMsU0FBUyxLQUFLLE9BQU8sWUFBWTtBQUM3RCxNQUFJLElBQUksb0JBQW9CO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLG1EQUFtRDtBQUUzRSxHQUNhLG9CQUFvQixDQUFDLFNBQVMsS0FBSyxPQUFPLFlBQVk7QUFDL0QsTUFBSSxJQUFJLG9CQUFvQjtBQUN4QixVQUFNLElBQUksTUFBTSxxREFBcUQ7QUFFN0UsR0FDYSxxQkFBcUIsQ0FBQyxTQUFTLEtBQUssT0FBTyxZQUFZO0FBQ2hFLE1BQUksSUFBSSxvQkFBb0I7QUFDeEIsVUFBTSxJQUFJLE1BQU0saURBQWlEO0FBRXpFLEdBQ2EsZUFBZSxDQUFDLFNBQVMsS0FBSyxPQUFPLFlBQVk7QUFDMUQsTUFBSSxJQUFJLG9CQUFvQjtBQUN4QixVQUFNLElBQUksTUFBTSwwQ0FBMEM7QUFFbEUsR0FDYSxlQUFlLENBQUMsU0FBUyxLQUFLLE9BQU8sWUFBWTtBQUMxRCxNQUFJLElBQUksb0JBQW9CO0FBQ3hCLFVBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUVsRSxHQUVhLGlCQUFpQixDQUFDLFFBQVEsS0FBSyxPQUFPLFdBQVc7QUFDMUQsTUFBTUEsUUFBTyxPQUNQLE1BQU0sT0FBTyxLQUFLLEtBQ2xCLEVBQUUsU0FBUyxRQUFRLElBQUksT0FBTyxLQUFLO0FBQ3pDLEVBQUksT0FBTyxXQUFZLGFBQ25CQSxNQUFLLFdBQVcsVUFDaEIsT0FBTyxXQUFZLGFBQ25CQSxNQUFLLFdBQVcsVUFDcEJBLE1BQUssT0FBTyxTQUNaQSxNQUFLLFFBQVFFLFNBQVEsSUFBSSxTQUFTLEtBQUssRUFBRSxHQUFHLFFBQVEsTUFBTSxDQUFDLEdBQUcsT0FBTyxNQUFNLE9BQU8sRUFBRSxDQUFDO0FBQ3pGLEdBQ2Esa0JBQWtCLENBQUMsUUFBUSxLQUFLLE9BQU8sV0FBVztBQUMzRCxNQUFNRixRQUFPLE9BQ1AsTUFBTSxPQUFPLEtBQUs7QUFDeEIsRUFBQUEsTUFBSyxPQUFPLFVBQ1pBLE1BQUssYUFBYSxDQUFDO0FBQ25CLE1BQU0sUUFBUSxJQUFJO0FBQ2xCLFdBQVcsT0FBTztBQUNkLElBQUFBLE1BQUssV0FBVyxHQUFHLElBQUlFLFNBQVEsTUFBTSxHQUFHLEdBQUcsS0FBSztBQUFBLE1BQzVDLEdBQUc7QUFBQSxNQUNILE1BQU0sQ0FBQyxHQUFHLE9BQU8sTUFBTSxjQUFjLEdBQUc7QUFBQSxJQUM1QyxDQUFDO0FBR0wsTUFBTSxVQUFVLElBQUksSUFBSSxPQUFPLEtBQUssS0FBSyxDQUFDLEdBQ3BDLGVBQWUsSUFBSSxJQUFJLENBQUMsR0FBRyxPQUFPLEVBQUUsT0FBTyxDQUFDLFFBQVE7QUFDdEQsUUFBTSxJQUFJLElBQUksTUFBTSxHQUFHLEVBQUU7QUFDekIsV0FBSSxJQUFJLE9BQU8sVUFDSixFQUFFLFVBQVUsU0FHWixFQUFFLFdBQVc7QUFBQSxFQUU1QixDQUFDLENBQUM7QUFDRixFQUFJLGFBQWEsT0FBTyxNQUNwQkYsTUFBSyxXQUFXLE1BQU0sS0FBSyxZQUFZLElBR3ZDLElBQUksVUFBVSxLQUFLLElBQUksU0FBUyxVQUVoQ0EsTUFBSyx1QkFBdUIsS0FFdEIsSUFBSSxXQUtMLElBQUksYUFDVEEsTUFBSyx1QkFBdUJFLFNBQVEsSUFBSSxVQUFVLEtBQUs7QUFBQSxJQUNuRCxHQUFHO0FBQUEsSUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0sc0JBQXNCO0FBQUEsRUFDakQsQ0FBQyxLQVBHLElBQUksT0FBTyxhQUNYRixNQUFLLHVCQUF1QjtBQVF4QyxHQUNhLGlCQUFpQixDQUFDLFFBQVEsS0FBS0EsT0FBTSxXQUFXO0FBQ3pELE1BQU0sTUFBTSxPQUFPLEtBQUssS0FHbEIsY0FBYyxJQUFJLGNBQWMsSUFDaEMsVUFBVSxJQUFJLFFBQVEsSUFBSSxDQUFDLEdBQUcsTUFBTUUsU0FBUSxHQUFHLEtBQUs7QUFBQSxJQUN0RCxHQUFHO0FBQUEsSUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0sY0FBYyxVQUFVLFNBQVMsQ0FBQztBQUFBLEVBQzdELENBQUMsQ0FBQztBQUNGLEVBQUksY0FDQUYsTUFBSyxRQUFRLFVBR2JBLE1BQUssUUFBUTtBQUVyQixHQUNhLHdCQUF3QixDQUFDLFFBQVEsS0FBS0EsT0FBTSxXQUFXO0FBQ2hFLE1BQU0sTUFBTSxPQUFPLEtBQUssS0FDbEIsSUFBSUUsU0FBUSxJQUFJLE1BQU0sS0FBSztBQUFBLElBQzdCLEdBQUc7QUFBQSxJQUNILE1BQU0sQ0FBQyxHQUFHLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFBQSxFQUNyQyxDQUFDLEdBQ0ssSUFBSUEsU0FBUSxJQUFJLE9BQU8sS0FBSztBQUFBLElBQzlCLEdBQUc7QUFBQSxJQUNILE1BQU0sQ0FBQyxHQUFHLE9BQU8sTUFBTSxTQUFTLENBQUM7QUFBQSxFQUNyQyxDQUFDLEdBQ0ssdUJBQXVCLENBQUMsUUFBUSxXQUFXLE9BQU8sT0FBTyxLQUFLLEdBQUcsRUFBRSxXQUFXLEdBQzlFLFFBQVE7QUFBQSxJQUNWLEdBQUkscUJBQXFCLENBQUMsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO0FBQUEsSUFDMUMsR0FBSSxxQkFBcUIsQ0FBQyxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFBQSxFQUM5QztBQUNBLEVBQUFGLE1BQUssUUFBUTtBQUNqQixHQUNhLGlCQUFpQixDQUFDLFFBQVEsS0FBSyxPQUFPLFdBQVc7QUFDMUQsTUFBTUEsUUFBTyxPQUNQLE1BQU0sT0FBTyxLQUFLO0FBQ3hCLEVBQUFBLE1BQUssT0FBTztBQUNaLE1BQU0sYUFBYSxJQUFJLFdBQVcsa0JBQWtCLGdCQUFnQixTQUM5RCxXQUFXLElBQUksV0FBVyxtQkFBNEIsSUFBSSxXQUFXLGdCQUF6QixVQUFtRCxtQkFDL0YsY0FBYyxJQUFJLE1BQU0sSUFBSSxDQUFDLEdBQUcsTUFBTUUsU0FBUSxHQUFHLEtBQUs7QUFBQSxJQUN4RCxHQUFHO0FBQUEsSUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0sWUFBWSxDQUFDO0FBQUEsRUFDeEMsQ0FBQyxDQUFDLEdBQ0ksT0FBTyxJQUFJLE9BQ1hBLFNBQVEsSUFBSSxNQUFNLEtBQUs7QUFBQSxJQUNyQixHQUFHO0FBQUEsSUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0sVUFBVSxHQUFJLElBQUksV0FBVyxnQkFBZ0IsQ0FBQyxJQUFJLE1BQU0sTUFBTSxJQUFJLENBQUMsQ0FBRTtBQUFBLEVBQ2hHLENBQUMsSUFDQztBQUNOLEVBQUksSUFBSSxXQUFXLG1CQUNmRixNQUFLLGNBQWMsYUFDZixTQUNBQSxNQUFLLFFBQVEsU0FHWixJQUFJLFdBQVcsaUJBQ3BCQSxNQUFLLFFBQVE7QUFBQSxJQUNULE9BQU87QUFBQSxFQUNYLEdBQ0ksUUFDQUEsTUFBSyxNQUFNLE1BQU0sS0FBSyxJQUFJLEdBRTlCQSxNQUFLLFdBQVcsWUFBWSxRQUN2QixTQUNEQSxNQUFLLFdBQVcsWUFBWSxZQUloQ0EsTUFBSyxRQUFRLGFBQ1QsU0FDQUEsTUFBSyxrQkFBa0I7QUFJL0IsTUFBTSxFQUFFLFNBQVMsUUFBUSxJQUFJLE9BQU8sS0FBSztBQUN6QyxFQUFJLE9BQU8sV0FBWSxhQUNuQkEsTUFBSyxXQUFXLFVBQ2hCLE9BQU8sV0FBWSxhQUNuQkEsTUFBSyxXQUFXO0FBQ3hCLEdBQ2Esa0JBQWtCLENBQUMsUUFBUSxLQUFLLE9BQU8sV0FBVztBQUMzRCxNQUFNQSxRQUFPLE9BQ1AsTUFBTSxPQUFPLEtBQUs7QUFDeEIsRUFBQUEsTUFBSyxPQUFPO0FBSVosTUFBTSxVQUFVLElBQUksU0FFZCxXQURTLFFBQVEsS0FBSyxLQUNIO0FBQ3pCLE1BQUksSUFBSSxTQUFTLFdBQVcsWUFBWSxTQUFTLE9BQU8sR0FBRztBQUV2RCxRQUFNLGNBQWNFLFNBQVEsSUFBSSxXQUFXLEtBQUs7QUFBQSxNQUM1QyxHQUFHO0FBQUEsTUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0scUJBQXFCLEdBQUc7QUFBQSxJQUNuRCxDQUFDO0FBQ0QsSUFBQUYsTUFBSyxvQkFBb0IsQ0FBQztBQUMxQixhQUFXLFdBQVc7QUFDbEIsTUFBQUEsTUFBSyxrQkFBa0IsUUFBUSxNQUFNLElBQUk7QUFBQSxFQUVqRDtBQUdJLEtBQUksSUFBSSxXQUFXLGNBQWMsSUFBSSxXQUFXLHFCQUM1Q0EsTUFBSyxnQkFBZ0JFLFNBQVEsSUFBSSxTQUFTLEtBQUs7QUFBQSxNQUMzQyxHQUFHO0FBQUEsTUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0sZUFBZTtBQUFBLElBQzFDLENBQUMsSUFFTEYsTUFBSyx1QkFBdUJFLFNBQVEsSUFBSSxXQUFXLEtBQUs7QUFBQSxNQUNwRCxHQUFHO0FBQUEsTUFDSCxNQUFNLENBQUMsR0FBRyxPQUFPLE1BQU0sc0JBQXNCO0FBQUEsSUFDakQsQ0FBQztBQUdMLE1BQU0sWUFBWSxRQUFRLEtBQUs7QUFDL0IsTUFBSSxXQUFXO0FBQ1gsUUFBTSxpQkFBaUIsQ0FBQyxHQUFHLFNBQVMsRUFBRSxPQUFPLENBQUMsTUFBTSxPQUFPLEtBQU0sWUFBWSxPQUFPLEtBQU0sUUFBUTtBQUNsRyxJQUFJLGVBQWUsU0FBUyxNQUN4QkYsTUFBSyxXQUFXO0FBQUEsRUFFeEI7QUFDSixHQUNhLG9CQUFvQixDQUFDLFFBQVEsS0FBS0EsT0FBTSxXQUFXO0FBQzVELE1BQU0sTUFBTSxPQUFPLEtBQUssS0FDbEIsUUFBUUUsU0FBUSxJQUFJLFdBQVcsS0FBSyxNQUFNLEdBQzFDLE9BQU8sSUFBSSxLQUFLLElBQUksTUFBTTtBQUNoQyxFQUFJLElBQUksV0FBVyxpQkFDZixLQUFLLE1BQU0sSUFBSSxXQUNmRixNQUFLLFdBQVcsTUFHaEJBLE1BQUssUUFBUSxDQUFDLE9BQU8sRUFBRSxNQUFNLE9BQU8sQ0FBQztBQUU3QyxHQUNhLHVCQUF1QixDQUFDLFFBQVEsS0FBSyxPQUFPLFdBQVc7QUFDaEUsTUFBTSxNQUFNLE9BQU8sS0FBSztBQUN4QixFQUFBRSxTQUFRLElBQUksV0FBVyxLQUFLLE1BQU07QUFDbEMsTUFBTSxPQUFPLElBQUksS0FBSyxJQUFJLE1BQU07QUFDaEMsT0FBSyxNQUFNLElBQUk7QUFDbkIsR0FDYSxtQkFBbUIsQ0FBQyxRQUFRLEtBQUtGLE9BQU0sV0FBVztBQUMzRCxNQUFNLE1BQU0sT0FBTyxLQUFLO0FBQ3hCLEVBQUFFLFNBQVEsSUFBSSxXQUFXLEtBQUssTUFBTTtBQUNsQyxNQUFNLE9BQU8sSUFBSSxLQUFLLElBQUksTUFBTTtBQUNoQyxPQUFLLE1BQU0sSUFBSSxXQUNmRixNQUFLLFVBQVUsS0FBSyxNQUFNLEtBQUssVUFBVSxJQUFJLFlBQVksQ0FBQztBQUM5RCxHQUNhLG9CQUFvQixDQUFDLFFBQVEsS0FBS0EsT0FBTSxXQUFXO0FBQzVELE1BQU0sTUFBTSxPQUFPLEtBQUs7QUFDeEIsRUFBQUUsU0FBUSxJQUFJLFdBQVcsS0FBSyxNQUFNO0FBQ2xDLE1BQU0sT0FBTyxJQUFJLEtBQUssSUFBSSxNQUFNO0FBQ2hDLE9BQUssTUFBTSxJQUFJLFdBQ1gsSUFBSSxPQUFPLFlBQ1hGLE1BQUssWUFBWSxLQUFLLE1BQU0sS0FBSyxVQUFVLElBQUksWUFBWSxDQUFDO0FBQ3BFLEdBQ2EsaUJBQWlCLENBQUMsUUFBUSxLQUFLQSxPQUFNLFdBQVc7QUFDekQsTUFBTSxNQUFNLE9BQU8sS0FBSztBQUN4QixFQUFBRSxTQUFRLElBQUksV0FBVyxLQUFLLE1BQU07QUFDbEMsTUFBTSxPQUFPLElBQUksS0FBSyxJQUFJLE1BQU07QUFDaEMsT0FBSyxNQUFNLElBQUk7QUFDZixNQUFJO0FBQ0osTUFBSTtBQUNBLGlCQUFhLElBQUksV0FBVyxNQUFTO0FBQUEsRUFDekMsUUFDTTtBQUNGLFVBQU0sSUFBSSxNQUFNLHVEQUF1RDtBQUFBLEVBQzNFO0FBQ0EsRUFBQUYsTUFBSyxVQUFVO0FBQ25CLEdBQ2EsZ0JBQWdCLENBQUMsUUFBUSxLQUFLLE9BQU8sV0FBVztBQUN6RCxNQUFNLE1BQU0sT0FBTyxLQUFLLEtBQ2xCLFlBQVksSUFBSSxPQUFPLFVBQVcsSUFBSSxHQUFHLEtBQUssSUFBSSxTQUFTLGNBQWMsSUFBSSxNQUFNLElBQUksS0FBTSxJQUFJO0FBQ3ZHLEVBQUFFLFNBQVEsV0FBVyxLQUFLLE1BQU07QUFDOUIsTUFBTSxPQUFPLElBQUksS0FBSyxJQUFJLE1BQU07QUFDaEMsT0FBSyxNQUFNO0FBQ2YsR0FDYSxvQkFBb0IsQ0FBQyxRQUFRLEtBQUtGLE9BQU0sV0FBVztBQUM1RCxNQUFNLE1BQU0sT0FBTyxLQUFLO0FBQ3hCLEVBQUFFLFNBQVEsSUFBSSxXQUFXLEtBQUssTUFBTTtBQUNsQyxNQUFNLE9BQU8sSUFBSSxLQUFLLElBQUksTUFBTTtBQUNoQyxPQUFLLE1BQU0sSUFBSSxXQUNmRixNQUFLLFdBQVc7QUFDcEIsR0FDYSxtQkFBbUIsQ0FBQyxRQUFRLEtBQUssT0FBTyxXQUFXO0FBQzVELE1BQU0sTUFBTSxPQUFPLEtBQUs7QUFDeEIsRUFBQUUsU0FBUSxJQUFJLFdBQVcsS0FBSyxNQUFNO0FBQ2xDLE1BQU0sT0FBTyxJQUFJLEtBQUssSUFBSSxNQUFNO0FBQ2hDLE9BQUssTUFBTSxJQUFJO0FBQ25CLEdBQ2Esb0JBQW9CLENBQUMsUUFBUSxLQUFLLE9BQU8sV0FBVztBQUM3RCxNQUFNLE1BQU0sT0FBTyxLQUFLO0FBQ3hCLEVBQUFBLFNBQVEsSUFBSSxXQUFXLEtBQUssTUFBTTtBQUNsQyxNQUFNLE9BQU8sSUFBSSxLQUFLLElBQUksTUFBTTtBQUNoQyxPQUFLLE1BQU0sSUFBSTtBQUNuQixHQUNhLGdCQUFnQixDQUFDLFFBQVEsS0FBSyxPQUFPLFdBQVc7QUFDekQsTUFBTSxZQUFZLE9BQU8sS0FBSztBQUM5QixFQUFBQSxTQUFRLFdBQVcsS0FBSyxNQUFNO0FBQzlCLE1BQU0sT0FBTyxJQUFJLEtBQUssSUFBSSxNQUFNO0FBQ2hDLE9BQUssTUFBTTtBQUNmOzs7QUNuZE0sU0FBVSxXQUFXLEdBQVk7QUFHbkMsU0FBTyxDQUFDLENBRE8sRUFDQztBQUNwQjtBQWlCTSxTQUFVQyxXQUNaLFFBQ0EsTUFBYTtBQUViLFNBQUksV0FBVyxNQUFNLElBRUssVUFBVSxRQUFRLElBQUksSUFHL0IsT0FDTyxVQUFVLElBQUk7QUFFMUM7QUFpQk0sU0FBVSxlQUFlLFFBQW1DO0FBQzlELE1BQUksQ0FBQztBQUFRO0FBR2IsTUFBSTtBQVVKLE1BUkksV0FBVyxNQUFNLElBRWpCLFdBRGlCLE9BQ0csTUFBTSxLQUFLLFFBRy9CLFdBRGlCLE9BQ0csT0FHcEIsRUFBQyxVQUVMO1FBQUksT0FBTyxZQUFhO0FBQ3BCLFVBQUk7QUFDQSxlQUFPLFNBQVE7TUFDbkIsUUFBUTtBQUNKO01BQ0o7QUFHSixXQUFPOztBQUNYO0FBd0hNLFNBQVUsZ0JBQWdCLFFBQWlCO0FBQzdDLE1BQUksV0FBVyxNQUFNLEdBQUc7QUFFcEIsUUFBTUMsT0FEVyxPQUNJLE1BQU07QUFDM0IsUUFBSUEsTUFBSztBQUVMLFVBQUlBLEtBQUksVUFBVTtBQUFXLGVBQU9BLEtBQUk7QUFDeEMsVUFBSSxNQUFNLFFBQVFBLEtBQUksTUFBTSxLQUFLQSxLQUFJLE9BQU8sU0FBUztBQUNqRCxlQUFPQSxLQUFJLE9BQU8sQ0FBQztJQUUzQjtFQUNKO0FBRUEsTUFBTSxNQURXLE9BQ0k7QUFDckIsTUFBSSxLQUFLO0FBQ0wsUUFBSSxJQUFJLFVBQVU7QUFBVyxhQUFPLElBQUk7QUFDeEMsUUFBSSxNQUFNLFFBQVEsSUFBSSxNQUFNLEtBQUssSUFBSSxPQUFPLFNBQVM7QUFDakQsYUFBTyxJQUFJLE9BQU8sQ0FBQztFQUUzQjtBQUVBLE1BQU0sY0FBZSxPQUErQjtBQUNwRCxNQUFJLGdCQUFnQjtBQUFXLFdBQU87QUFFMUM7OztBQ25SQSxJQUFBQyxtQkFBQTtBQUFBLFNBQUFBLGtCQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxtQkFBQUM7QUFBQSxFQUFBO0FBQUEsb0JBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGtCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUFDO0FBQUEsRUFBQSxrQkFBQUM7QUFBQSxFQUFBLDZCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsaUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEscUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQSx5QkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxpQkFBQUM7QUFBQSxFQUFBLGtCQUFBQztBQUFBLEVBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBLGNBQUFDO0FBQUEsRUFBQTtBQUFBLGtCQUFBQztBQUFBLEVBQUE7QUFBQSxpQkFBQUM7QUFBQSxFQUFBLG1CQUFBQztBQUFBLEVBQUEsaUJBQUFDO0FBQUEsRUFBQTtBQUFBLG1CQUFBQztBQUFBLEVBQUEsbUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEsb0JBQUFDO0FBQUEsRUFBQSxtQkFBQUM7QUFBQSxFQUFBLGlCQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBLGlCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBLG1CQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBLGtCQUFBQztBQUFBLEVBQUEsZUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLHNCQUFBQztBQUFBLEVBQUEsZ0JBQUFDO0FBQUEsRUFBQSxrQkFBQUM7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBQztBQUFBLEVBQUEsaUJBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUEsZUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBLGNBQUFDO0FBQUEsRUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQSxhQUFBQztBQUFBLEVBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsZ0JBQUFDO0FBQUEsRUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQSxhQUFBQztBQUFBLEVBQUEsYUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQTtBQUFBLGFBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQSxZQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsZUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsYUFBQUM7QUFBQSxFQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxpQkFBQUM7QUFBQSxFQUFBLGNBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGdCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsaUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLFdBQUFDO0FBQUEsRUFBQTtBQUFBOzs7QUNBQSxJQUFBQyxrQkFBQTtBQUFBLFNBQUFBLGlCQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7QUNBQSxJQUFBQyxlQUFBO0FBQUEsU0FBQUEsY0FBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUEsZ0JBQUFDO0FBQUEsRUFBQSxZQUFBQztBQUFBO0FBRU8sSUFBTSxpQkFBK0IsZ0JBQUssYUFBYSxrQkFBa0IsQ0FBQyxNQUFNLFFBQVE7QUFDM0YsRUFBSyxnQkFBZ0IsS0FBSyxNQUFNLEdBQUcsR0FDM0IsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQzFDLENBQUM7QUFDTSxTQUFTQyxVQUFTLFFBQVE7QUFDN0IsU0FBWSxhQUFhLGdCQUFnQixNQUFNO0FBQ25EO0FBQ08sSUFBTSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsRUFBSyxZQUFZLEtBQUssTUFBTSxHQUFHLEdBQ3ZCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUMxQyxDQUFDO0FBQ00sU0FBU0MsTUFBSyxRQUFRO0FBQ3pCLFNBQVksU0FBUyxZQUFZLE1BQU07QUFDM0M7QUFDTyxJQUFNLGFBQTJCLGdCQUFLLGFBQWEsY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUNuRixFQUFLLFlBQVksS0FBSyxNQUFNLEdBQUcsR0FDdkIsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQzFDLENBQUM7QUFDTSxTQUFTQyxNQUFLLFFBQVE7QUFDekIsU0FBWSxTQUFTLFlBQVksTUFBTTtBQUMzQztBQUNPLElBQU0saUJBQStCLGdCQUFLLGFBQWEsa0JBQWtCLENBQUMsTUFBTSxRQUFRO0FBQzNGLEVBQUssZ0JBQWdCLEtBQUssTUFBTSxHQUFHLEdBQzNCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUMxQyxDQUFDO0FBQ00sU0FBU0MsVUFBUyxRQUFRO0FBQzdCLFNBQVksYUFBYSxnQkFBZ0IsTUFBTTtBQUNuRDs7O0FDMUJBLElBQU1DLGVBQWMsQ0FBQyxNQUFNLFdBQVc7QUFDbEMsWUFBVSxLQUFLLE1BQU0sTUFBTSxHQUMzQixLQUFLLE9BQU8sWUFDWixPQUFPLGlCQUFpQixNQUFNO0FBQUEsSUFDMUIsUUFBUTtBQUFBLE1BQ0osT0FBTyxDQUFDLFdBQWdCLFlBQVksTUFBTSxNQUFNO0FBQUE7QUFBQSxJQUVwRDtBQUFBLElBQ0EsU0FBUztBQUFBLE1BQ0wsT0FBTyxDQUFDLFdBQWdCLGFBQWEsTUFBTSxNQUFNO0FBQUE7QUFBQSxJQUVyRDtBQUFBLElBQ0EsVUFBVTtBQUFBLE1BQ04sT0FBTyxDQUFDQyxXQUFVO0FBQ2QsYUFBSyxPQUFPLEtBQUtBLE1BQUssR0FDdEIsS0FBSyxVQUFVLEtBQUssVUFBVSxLQUFLLFFBQWEsdUJBQXVCLENBQUM7QUFBQSxNQUM1RTtBQUFBO0FBQUEsSUFFSjtBQUFBLElBQ0EsV0FBVztBQUFBLE1BQ1AsT0FBTyxDQUFDQyxZQUFXO0FBQ2YsYUFBSyxPQUFPLEtBQUssR0FBR0EsT0FBTSxHQUMxQixLQUFLLFVBQVUsS0FBSyxVQUFVLEtBQUssUUFBYSx1QkFBdUIsQ0FBQztBQUFBLE1BQzVFO0FBQUE7QUFBQSxJQUVKO0FBQUEsSUFDQSxTQUFTO0FBQUEsTUFDTCxNQUFNO0FBQ0YsZUFBTyxLQUFLLE9BQU8sV0FBVztBQUFBLE1BQ2xDO0FBQUE7QUFBQSxJQUVKO0FBQUEsRUFDSixDQUFDO0FBTUwsR0FDYUMsWUFBZ0IsYUFBYSxZQUFZSCxZQUFXLEdBQ3BELGVBQW9CLGFBQWEsWUFBWUEsY0FBYTtBQUFBLEVBQ25FLFFBQVE7QUFDWixDQUFDOzs7QUMzQ00sSUFBTUksU0FBd0IsZ0JBQUssT0FBTyxZQUFZLEdBQ2hEQyxjQUE2QixnQkFBSyxZQUFZLFlBQVksR0FDMURDLGFBQTRCLGdCQUFLLFdBQVcsWUFBWSxHQUN4REMsa0JBQWlDLGdCQUFLLGdCQUFnQixZQUFZLEdBRWxFQyxVQUF5QixnQkFBSyxRQUFRLFlBQVksR0FDbERDLFVBQXlCLGdCQUFLLFFBQVEsWUFBWSxHQUNsREMsZUFBOEIsZ0JBQUssYUFBYSxZQUFZLEdBQzVEQyxlQUE4QixnQkFBSyxhQUFhLFlBQVksR0FDNURDLGNBQTZCLGdCQUFLLFlBQVksWUFBWSxHQUMxREMsY0FBNkIsZ0JBQUssWUFBWSxZQUFZLEdBQzFEQyxtQkFBa0MsZ0JBQUssaUJBQWlCLFlBQVksR0FDcEVDLG1CQUFrQyxnQkFBSyxpQkFBaUIsWUFBWTs7O0FKUDFFLElBQU1DLFdBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sU0FDaEUsU0FBUyxLQUFLLE1BQU0sR0FBRyxHQUM1QixPQUFPLE9BQU8sS0FBSyxXQUFXLEdBQUc7QUFBQSxFQUM3QixZQUFZO0FBQUEsSUFDUixPQUFPLCtCQUErQixNQUFNLE9BQU87QUFBQSxJQUNuRCxRQUFRLCtCQUErQixNQUFNLFFBQVE7QUFBQSxFQUN6RDtBQUNKLENBQUMsR0FDRCxLQUFLLGVBQWUseUJBQXlCLE1BQU0sQ0FBQyxDQUFDLEdBQ3JELEtBQUssTUFBTSxLQUNYLEtBQUssT0FBTyxJQUFJLE1BQ2hCLE9BQU8sZUFBZSxNQUFNLFFBQVEsRUFBRSxPQUFPLElBQUksQ0FBQyxHQUVsRCxLQUFLLFFBQVEsSUFBSSxXQUNOLEtBQUssTUFBTSxhQUFLLFVBQVUsS0FBSztBQUFBLEVBQ2xDLFFBQVE7QUFBQSxJQUNKLEdBQUksSUFBSSxVQUFVLENBQUM7QUFBQSxJQUNuQixHQUFHLE9BQU8sSUFBSSxDQUFDLE9BQU8sT0FBTyxNQUFPLGFBQWEsRUFBRSxNQUFNLEVBQUUsT0FBTyxJQUFJLEtBQUssRUFBRSxPQUFPLFNBQVMsR0FBRyxVQUFVLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRTtBQUFBLEVBQ3pIO0FBQ0osQ0FBQyxHQUFHO0FBQUEsRUFDQSxRQUFRO0FBQ1osQ0FBQyxHQUVMLEtBQUssT0FBTyxLQUFLLE9BQ2pCLEtBQUssUUFBUSxDQUFDQyxNQUFLLFdBQWdCLE1BQU0sTUFBTUEsTUFBSyxNQUFNLEdBQzFELEtBQUssUUFBUSxNQUFNLE1BQ25CLEtBQUssV0FBWSxDQUFDLEtBQUtDLFdBQ25CLElBQUksSUFBSSxNQUFNQSxLQUFJLEdBQ1gsT0FHWCxLQUFLLFFBQVEsQ0FBQyxNQUFNLFdBQWlCQyxPQUFNLE1BQU0sTUFBTSxRQUFRLEVBQUUsUUFBUSxLQUFLLE1BQU0sQ0FBQyxHQUNyRixLQUFLLFlBQVksQ0FBQyxNQUFNLFdBQWlCQyxXQUFVLE1BQU0sTUFBTSxNQUFNLEdBQ3JFLEtBQUssYUFBYSxPQUFPLE1BQU0sV0FBaUJDLFlBQVcsTUFBTSxNQUFNLFFBQVEsRUFBRSxRQUFRLEtBQUssV0FBVyxDQUFDLEdBQzFHLEtBQUssaUJBQWlCLE9BQU8sTUFBTSxXQUFpQkMsZ0JBQWUsTUFBTSxNQUFNLE1BQU0sR0FDckYsS0FBSyxNQUFNLEtBQUssZ0JBRWhCLEtBQUssU0FBUyxDQUFDLE1BQU0sV0FBaUJDLFFBQU8sTUFBTSxNQUFNLE1BQU0sR0FDL0QsS0FBSyxTQUFTLENBQUMsTUFBTSxXQUFpQkMsUUFBTyxNQUFNLE1BQU0sTUFBTSxHQUMvRCxLQUFLLGNBQWMsT0FBTyxNQUFNLFdBQWlCQyxhQUFZLE1BQU0sTUFBTSxNQUFNLEdBQy9FLEtBQUssY0FBYyxPQUFPLE1BQU0sV0FBaUJDLGFBQVksTUFBTSxNQUFNLE1BQU0sR0FDL0UsS0FBSyxhQUFhLENBQUMsTUFBTSxXQUFpQkMsWUFBVyxNQUFNLE1BQU0sTUFBTSxHQUN2RSxLQUFLLGFBQWEsQ0FBQyxNQUFNLFdBQWlCQyxZQUFXLE1BQU0sTUFBTSxNQUFNLEdBQ3ZFLEtBQUssa0JBQWtCLE9BQU8sTUFBTSxXQUFpQkMsaUJBQWdCLE1BQU0sTUFBTSxNQUFNLEdBQ3ZGLEtBQUssa0JBQWtCLE9BQU8sTUFBTSxXQUFpQkMsaUJBQWdCLE1BQU0sTUFBTSxNQUFNLEdBRXZGLEtBQUssU0FBUyxDQUFDQyxRQUFPLFdBQVcsS0FBSyxNQUFNLE9BQU9BLFFBQU8sTUFBTSxDQUFDLEdBQ2pFLEtBQUssY0FBYyxDQUFDLGVBQWUsS0FBSyxNQUFNLFlBQVksVUFBVSxDQUFDLEdBQ3JFLEtBQUssWUFBWSxDQUFDLE9BQU8sS0FBSyxNQUFhLFdBQVUsRUFBRSxDQUFDLEdBRXhELEtBQUssV0FBVyxNQUFNLFNBQVMsSUFBSSxHQUNuQyxLQUFLLGdCQUFnQixNQUFNLGNBQWMsSUFBSSxHQUM3QyxLQUFLLFdBQVcsTUFBTSxTQUFTLElBQUksR0FDbkMsS0FBSyxVQUFVLE1BQU0sU0FBUyxTQUFTLElBQUksQ0FBQyxHQUM1QyxLQUFLLGNBQWMsQ0FBQyxXQUFXLFlBQVksTUFBTSxNQUFNLEdBQ3ZELEtBQUssUUFBUSxNQUFNLE1BQU0sSUFBSSxHQUM3QixLQUFLLEtBQUssQ0FBQyxRQUFRLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxHQUNwQyxLQUFLLE1BQU0sQ0FBQyxRQUFRLGFBQWEsTUFBTSxHQUFHLEdBQzFDLEtBQUssWUFBWSxDQUFDLE9BQU8sS0FBSyxNQUFNLFVBQVUsRUFBRSxDQUFDLEdBQ2pELEtBQUssVUFBVSxDQUFDZCxTQUFRLFNBQVMsTUFBTUEsSUFBRyxHQUMxQyxLQUFLLFdBQVcsQ0FBQ0EsU0FBUSxTQUFTLE1BQU1BLElBQUcsR0FFM0MsS0FBSyxRQUFRLENBQUMsV0FBVyxPQUFPLE1BQU0sTUFBTSxHQUM1QyxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBTSxNQUFNLEdBQ3pDLEtBQUssV0FBVyxNQUFNLFNBQVMsSUFBSSxHQUVuQyxLQUFLLFdBQVcsQ0FBQyxnQkFBZ0I7QUFDN0IsTUFBTSxLQUFLLEtBQUssTUFBTTtBQUN0QixTQUFLLGVBQWUsSUFBSSxJQUFJLEVBQUUsWUFBWSxDQUFDLEdBQ3BDO0FBQ1gsR0FDQSxPQUFPLGVBQWUsTUFBTSxlQUFlO0FBQUEsRUFDdkMsTUFBTTtBQUNGLFdBQVksZUFBZSxJQUFJLElBQUksR0FBRztBQUFBLEVBQzFDO0FBQUEsRUFDQSxjQUFjO0FBQ2xCLENBQUMsR0FDRCxLQUFLLE9BQU8sSUFBSSxTQUFTO0FBQ3JCLE1BQUksS0FBSyxXQUFXO0FBQ2hCLFdBQVksZUFBZSxJQUFJLElBQUk7QUFFdkMsTUFBTSxLQUFLLEtBQUssTUFBTTtBQUN0QixTQUFLLGVBQWUsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLEdBQzVCO0FBQ1gsR0FFQSxLQUFLLGFBQWEsTUFBTSxLQUFLLFVBQVUsTUFBUyxFQUFFLFNBQ2xELEtBQUssYUFBYSxNQUFNLEtBQUssVUFBVSxJQUFJLEVBQUUsU0FDN0MsS0FBSyxRQUFRLENBQUMsT0FBTyxHQUFHLElBQUksR0FDckIsS0FDVixHQUVZLGFBQTJCLGdCQUFLLGFBQWEsY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUNuRixFQUFLLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDOUJELFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtnQixPQUFNLFdBQXNCLGdCQUFnQixNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUN2RyxNQUFNLE1BQU0sS0FBSyxLQUFLO0FBQ3RCLE9BQUssU0FBUyxJQUFJLFVBQVUsTUFDNUIsS0FBSyxZQUFZLElBQUksV0FBVyxNQUNoQyxLQUFLLFlBQVksSUFBSSxXQUFXLE1BRWhDLEtBQUssUUFBUSxJQUFJLFNBQVMsS0FBSyxNQUFhLE9BQU0sR0FBRyxJQUFJLENBQUMsR0FDMUQsS0FBSyxXQUFXLElBQUksU0FBUyxLQUFLLE1BQWEsVUFBUyxHQUFHLElBQUksQ0FBQyxHQUNoRSxLQUFLLGFBQWEsSUFBSSxTQUFTLEtBQUssTUFBYSxZQUFXLEdBQUcsSUFBSSxDQUFDLEdBQ3BFLEtBQUssV0FBVyxJQUFJLFNBQVMsS0FBSyxNQUFhLFVBQVMsR0FBRyxJQUFJLENBQUMsR0FDaEUsS0FBSyxNQUFNLElBQUksU0FBUyxLQUFLLE1BQWEsV0FBVSxHQUFHLElBQUksQ0FBQyxHQUM1RCxLQUFLLE1BQU0sSUFBSSxTQUFTLEtBQUssTUFBYSxXQUFVLEdBQUcsSUFBSSxDQUFDLEdBQzVELEtBQUssU0FBUyxJQUFJLFNBQVMsS0FBSyxNQUFhLFFBQU8sR0FBRyxJQUFJLENBQUMsR0FDNUQsS0FBSyxXQUFXLElBQUksU0FBUyxLQUFLLE1BQWEsV0FBVSxHQUFHLEdBQUcsSUFBSSxDQUFDLEdBQ3BFLEtBQUssWUFBWSxDQUFDLFdBQVcsS0FBSyxNQUFhLFdBQVUsTUFBTSxDQUFDLEdBQ2hFLEtBQUssWUFBWSxDQUFDLFdBQVcsS0FBSyxNQUFhLFdBQVUsTUFBTSxDQUFDLEdBRWhFLEtBQUssT0FBTyxNQUFNLEtBQUssTUFBYSxNQUFLLENBQUMsR0FDMUMsS0FBSyxZQUFZLElBQUksU0FBUyxLQUFLLE1BQWEsV0FBVSxHQUFHLElBQUksQ0FBQyxHQUNsRSxLQUFLLGNBQWMsTUFBTSxLQUFLLE1BQWEsYUFBWSxDQUFDLEdBQ3hELEtBQUssY0FBYyxNQUFNLEtBQUssTUFBYSxhQUFZLENBQUMsR0FDeEQsS0FBSyxVQUFVLE1BQU0sS0FBSyxNQUFhLFNBQVEsQ0FBQztBQUNwRCxDQUFDLEdBQ1lDLGFBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUNqRixFQUFLLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDOUIsV0FBVyxLQUFLLE1BQU0sR0FBRyxHQUN6QixLQUFLLFFBQVEsQ0FBQyxXQUFXLEtBQUssTUFBVyxPQUFPLFVBQVUsTUFBTSxDQUFDLEdBQ2pFLEtBQUssTUFBTSxDQUFDLFdBQVcsS0FBSyxNQUFXLEtBQUssUUFBUSxNQUFNLENBQUMsR0FDM0QsS0FBSyxNQUFNLENBQUMsV0FBVyxLQUFLLE1BQVcsS0FBSyxRQUFRLE1BQU0sQ0FBQyxHQUMzRCxLQUFLLFFBQVEsQ0FBQyxXQUFXLEtBQUssTUFBV0MsUUFBTyxVQUFVLE1BQU0sQ0FBQyxHQUNqRSxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssT0FBTyxDQUFDLFdBQVcsS0FBSyxNQUFXLE1BQU0sU0FBUyxNQUFNLENBQUMsR0FDOUQsS0FBSyxTQUFTLENBQUMsV0FBVyxLQUFLLE1BQVcsUUFBUSxTQUFTLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLFNBQVMsQ0FBQyxXQUFXLEtBQUssTUFBVyxRQUFRLFNBQVMsTUFBTSxDQUFDLEdBQ2xFLEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsU0FBUyxNQUFNLENBQUMsR0FDbEUsS0FBSyxTQUFTLENBQUMsV0FBVyxLQUFLLE1BQVcsUUFBUSxXQUFXLE1BQU0sQ0FBQyxHQUNwRSxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssT0FBTyxDQUFDLFdBQVcsS0FBSyxNQUFXLE1BQU0sU0FBUyxNQUFNLENBQUMsR0FDOUQsS0FBSyxRQUFRLENBQUMsV0FBVyxLQUFLLE1BQVcsT0FBTyxVQUFVLE1BQU0sQ0FBQyxHQUNqRSxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsV0FBVyxNQUFNLENBQUMsR0FDcEUsS0FBSyxZQUFZLENBQUMsV0FBVyxLQUFLLE1BQVcsV0FBVyxjQUFjLE1BQU0sQ0FBQyxHQUM3RSxLQUFLLE1BQU0sQ0FBQyxXQUFXLEtBQUssTUFBVyxLQUFLLFFBQVEsTUFBTSxDQUFDLEdBQzNELEtBQUssUUFBUSxDQUFDLFdBQVcsS0FBSyxNQUFXLE9BQU8sVUFBVSxNQUFNLENBQUMsR0FDakUsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsV0FBVyxNQUFNLENBQUMsR0FDcEUsS0FBSyxTQUFTLENBQUMsV0FBVyxLQUFLLE1BQVcsUUFBUSxXQUFXLE1BQU0sQ0FBQyxHQUNwRSxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBRTlELEtBQUssV0FBVyxDQUFDLFdBQVcsS0FBSyxNQUFVQyxVQUFTLE1BQU0sQ0FBQyxHQUMzRCxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVUMsTUFBSyxNQUFNLENBQUMsR0FDbkQsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVVDLE1BQUssTUFBTSxDQUFDLEdBQ25ELEtBQUssV0FBVyxDQUFDLFdBQVcsS0FBSyxNQUFVQyxVQUFTLE1BQU0sQ0FBQztBQUMvRCxDQUFDO0FBQ00sU0FBU0MsUUFBTyxRQUFRO0FBQzNCLFNBQVksUUFBUU4sWUFBVyxNQUFNO0FBQ3pDO0FBQ08sSUFBTSxrQkFBZ0MsZ0JBQUssYUFBYSxtQkFBbUIsQ0FBQyxNQUFNLFFBQVE7QUFDN0YsRUFBSyxpQkFBaUIsS0FBSyxNQUFNLEdBQUcsR0FDcEMsV0FBVyxLQUFLLE1BQU0sR0FBRztBQUM3QixDQUFDLEdBQ1ksV0FBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBRS9FLEVBQUssVUFBVSxLQUFLLE1BQU0sR0FBRyxHQUM3QixnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVNPLE9BQU0sUUFBUTtBQUMxQixTQUFZLE9BQU8sVUFBVSxNQUFNO0FBQ3ZDO0FBQ08sSUFBTSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFFN0UsRUFBSyxTQUFTLEtBQUssTUFBTSxHQUFHLEdBQzVCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUNsQyxDQUFDO0FBQ00sU0FBU0MsTUFBSyxRQUFRO0FBQ3pCLFNBQVksTUFBTSxTQUFTLE1BQU07QUFDckM7QUFDTyxJQUFNLFVBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUU3RSxFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDNUIsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTQyxNQUFLLFFBQVE7QUFDekIsU0FBWSxNQUFNLFNBQVMsTUFBTTtBQUNyQztBQUNPLFNBQVMsT0FBTyxRQUFRO0FBQzNCLFNBQVksUUFBUSxTQUFTLE1BQU07QUFDdkM7QUFFTyxTQUFTLE9BQU8sUUFBUTtBQUMzQixTQUFZLFFBQVEsU0FBUyxNQUFNO0FBQ3ZDO0FBRU8sU0FBUyxPQUFPLFFBQVE7QUFDM0IsU0FBWSxRQUFRLFNBQVMsTUFBTTtBQUN2QztBQUNPLElBQU0sU0FBdUIsZ0JBQUssYUFBYSxVQUFVLENBQUMsTUFBTSxRQUFRO0FBRTNFLEVBQUssUUFBUSxLQUFLLE1BQU0sR0FBRyxHQUMzQixnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVMsSUFBSSxRQUFRO0FBQ3hCLFNBQVksS0FBSyxRQUFRLE1BQU07QUFDbkM7QUFDTyxTQUFTLFFBQVEsUUFBUTtBQUM1QixTQUFZLEtBQUssUUFBUTtBQUFBLElBQ3JCLFVBQVU7QUFBQSxJQUNWLFVBQWUsZ0JBQVE7QUFBQSxJQUN2QixHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUUvRSxFQUFLLFVBQVUsS0FBSyxNQUFNLEdBQUcsR0FDN0IsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTQyxPQUFNLFFBQVE7QUFDMUIsU0FBWVQsUUFBTyxVQUFVLE1BQU07QUFDdkM7QUFDTyxJQUFNLFlBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUVqRixFQUFLLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDOUIsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTVSxRQUFPLFFBQVE7QUFDM0IsU0FBWSxRQUFRLFdBQVcsTUFBTTtBQUN6QztBQUNPLElBQU0sVUFBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBRTdFLEVBQUssU0FBUyxLQUFLLE1BQU0sR0FBRyxHQUM1QixnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVNDLE1BQUssUUFBUTtBQUN6QixTQUFZLE1BQU0sU0FBUyxNQUFNO0FBQ3JDO0FBQ08sSUFBTSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFFL0UsRUFBSyxVQUFVLEtBQUssTUFBTSxHQUFHLEdBQzdCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUNsQyxDQUFDO0FBQ00sU0FBU0MsT0FBTSxRQUFRO0FBQzFCLFNBQVksT0FBTyxVQUFVLE1BQU07QUFDdkM7QUFDTyxJQUFNLFVBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUU3RSxFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDNUIsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTQyxNQUFLLFFBQVE7QUFDekIsU0FBWSxNQUFNLFNBQVMsTUFBTTtBQUNyQztBQUNPLElBQU0sU0FBdUIsZ0JBQUssYUFBYSxVQUFVLENBQUMsTUFBTSxRQUFRO0FBRTNFLEVBQUssUUFBUSxLQUFLLE1BQU0sR0FBRyxHQUMzQixnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVNDLEtBQUksUUFBUTtBQUN4QixTQUFZLEtBQUssUUFBUSxNQUFNO0FBQ25DO0FBQ08sSUFBTSxXQUF5QixnQkFBSyxhQUFhLFlBQVksQ0FBQyxNQUFNLFFBQVE7QUFFL0UsRUFBSyxVQUFVLEtBQUssTUFBTSxHQUFHLEdBQzdCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUNsQyxDQUFDO0FBQ00sU0FBU0MsT0FBTSxRQUFRO0FBQzFCLFNBQVksT0FBTyxVQUFVLE1BQU07QUFDdkM7QUFDTyxJQUFNLFVBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUU3RSxFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDNUIsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTQyxNQUFLLFFBQVE7QUFDekIsU0FBWSxNQUFNLFNBQVMsTUFBTTtBQUNyQztBQUNPLElBQU0sU0FBdUIsZ0JBQUssYUFBYSxVQUFVLENBQUMsTUFBTSxRQUFRO0FBRTNFLEVBQUssUUFBUSxLQUFLLE1BQU0sR0FBRyxHQUMzQixnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVNDLEtBQUksUUFBUTtBQUN4QixTQUFZLEtBQUssUUFBUSxNQUFNO0FBQ25DO0FBQ08sSUFBTSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFFN0UsRUFBSyxTQUFTLEtBQUssTUFBTSxHQUFHLEdBQzVCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUNsQyxDQUFDO0FBQ00sU0FBU0MsTUFBSyxRQUFRO0FBQ3pCLFNBQVksTUFBTSxTQUFTLE1BQU07QUFDckM7QUFDTyxJQUFNLFlBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUNqRixFQUFLLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDOUIsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTQyxRQUFPLFFBQVE7QUFDM0IsU0FBWSxRQUFRLFdBQVcsTUFBTTtBQUN6QztBQUNPLElBQU0sWUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLEVBQUssV0FBVyxLQUFLLE1BQU0sR0FBRyxHQUM5QixnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVNDLFFBQU8sUUFBUTtBQUMzQixTQUFZLFFBQVEsV0FBVyxNQUFNO0FBQ3pDO0FBQ08sSUFBTSxZQUEwQixnQkFBSyxhQUFhLGFBQWEsQ0FBQyxNQUFNLFFBQVE7QUFFakYsRUFBSyxXQUFXLEtBQUssTUFBTSxHQUFHLEdBQzlCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUNsQyxDQUFDO0FBQ00sU0FBU0MsUUFBTyxRQUFRO0FBQzNCLFNBQVksUUFBUSxXQUFXLE1BQU07QUFDekM7QUFDTyxJQUFNLGVBQTZCLGdCQUFLLGFBQWEsZ0JBQWdCLENBQUMsTUFBTSxRQUFRO0FBRXZGLEVBQUssY0FBYyxLQUFLLE1BQU0sR0FBRyxHQUNqQyxnQkFBZ0IsS0FBSyxNQUFNLEdBQUc7QUFDbEMsQ0FBQztBQUNNLFNBQVNDLFdBQVUsUUFBUTtBQUM5QixTQUFZLFdBQVcsY0FBYyxNQUFNO0FBQy9DO0FBQ08sSUFBTSxVQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFFN0UsRUFBSyxTQUFTLEtBQUssTUFBTSxHQUFHLEdBQzVCLGdCQUFnQixLQUFLLE1BQU0sR0FBRztBQUNsQyxDQUFDO0FBQ00sU0FBU0MsTUFBSyxRQUFRO0FBQ3pCLFNBQVksTUFBTSxTQUFTLE1BQU07QUFDckM7QUFDTyxJQUFNLFNBQXVCLGdCQUFLLGFBQWEsVUFBVSxDQUFDLE1BQU0sUUFBUTtBQUUzRSxFQUFLLFFBQVEsS0FBSyxNQUFNLEdBQUcsR0FDM0IsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTLElBQUksUUFBUTtBQUN4QixTQUFZLEtBQUssUUFBUSxNQUFNO0FBQ25DO0FBQ08sSUFBTSx3QkFBc0MsZ0JBQUssYUFBYSx5QkFBeUIsQ0FBQyxNQUFNLFFBQVE7QUFFekcsRUFBSyx1QkFBdUIsS0FBSyxNQUFNLEdBQUcsR0FDMUMsZ0JBQWdCLEtBQUssTUFBTSxHQUFHO0FBQ2xDLENBQUM7QUFDTSxTQUFTLGFBQWEsUUFBUSxXQUFXLFVBQVUsQ0FBQyxHQUFHO0FBQzFELFNBQVksY0FBYyx1QkFBdUIsUUFBUSxXQUFXLE9BQU87QUFDL0U7QUFDTyxTQUFTQyxVQUFTLFNBQVM7QUFDOUIsU0FBWSxjQUFjLHVCQUF1QixZQUFpQixnQkFBUSxVQUFVLE9BQU87QUFDL0Y7QUFDTyxTQUFTQyxLQUFJLFNBQVM7QUFDekIsU0FBWSxjQUFjLHVCQUF1QixPQUFZLGdCQUFRLEtBQUssT0FBTztBQUNyRjtBQUNPLFNBQVMsS0FBSyxLQUFLLFFBQVE7QUFDOUIsTUFBTSxNQUFNLFFBQVEsT0FBTyxPQUNyQixTQUFTLEdBQUcsR0FBRyxJQUFJLEdBQUcsSUFDdEIsUUFBYSxnQkFBUSxNQUFNO0FBQ2pDLE1BQUksQ0FBQztBQUNELFVBQU0sSUFBSSxNQUFNLDZCQUE2QixNQUFNLEVBQUU7QUFDekQsU0FBWSxjQUFjLHVCQUF1QixRQUFRLE9BQU8sTUFBTTtBQUMxRTtBQUNPLElBQU1DLGFBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUNqRixFQUFLLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDOUI1QyxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLZ0IsT0FBTSxXQUFzQixnQkFBZ0IsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDdkcsS0FBSyxLQUFLLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBYSxJQUFHLE9BQU8sTUFBTSxDQUFDLEdBQ2hFLEtBQUssTUFBTSxDQUFDLE9BQU8sV0FBVyxLQUFLLE1BQWEsS0FBSSxPQUFPLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLE1BQU0sQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLEtBQUksT0FBTyxNQUFNLENBQUMsR0FDbEUsS0FBSyxLQUFLLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBYSxJQUFHLE9BQU8sTUFBTSxDQUFDLEdBQ2hFLEtBQUssTUFBTSxDQUFDLE9BQU8sV0FBVyxLQUFLLE1BQWEsS0FBSSxPQUFPLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLE1BQU0sQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLEtBQUksT0FBTyxNQUFNLENBQUMsR0FDbEUsS0FBSyxNQUFNLENBQUMsV0FBVyxLQUFLLE1BQU0sSUFBSSxNQUFNLENBQUMsR0FDN0MsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQU0sSUFBSSxNQUFNLENBQUMsR0FDOUMsS0FBSyxXQUFXLENBQUMsV0FBVyxLQUFLLE1BQWEsSUFBRyxHQUFHLE1BQU0sQ0FBQyxHQUMzRCxLQUFLLGNBQWMsQ0FBQyxXQUFXLEtBQUssTUFBYSxLQUFJLEdBQUcsTUFBTSxDQUFDLEdBQy9ELEtBQUssV0FBVyxDQUFDLFdBQVcsS0FBSyxNQUFhLElBQUcsR0FBRyxNQUFNLENBQUMsR0FDM0QsS0FBSyxjQUFjLENBQUMsV0FBVyxLQUFLLE1BQWEsS0FBSSxHQUFHLE1BQU0sQ0FBQyxHQUMvRCxLQUFLLGFBQWEsQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLFlBQVcsT0FBTyxNQUFNLENBQUMsR0FDaEYsS0FBSyxPQUFPLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBYSxZQUFXLE9BQU8sTUFBTSxDQUFDLEdBRTFFLEtBQUssU0FBUyxNQUFNO0FBQ3BCLE1BQU0sTUFBTSxLQUFLLEtBQUs7QUFDdEIsT0FBSyxXQUNELEtBQUssSUFBSSxJQUFJLFdBQVcsT0FBTyxtQkFBbUIsSUFBSSxvQkFBb0IsT0FBTyxpQkFBaUIsS0FBSyxNQUMzRyxLQUFLLFdBQ0QsS0FBSyxJQUFJLElBQUksV0FBVyxPQUFPLG1CQUFtQixJQUFJLG9CQUFvQixPQUFPLGlCQUFpQixLQUFLLE1BQzNHLEtBQUssU0FBUyxJQUFJLFVBQVUsSUFBSSxTQUFTLEtBQUssS0FBSyxPQUFPLGNBQWMsSUFBSSxjQUFjLEdBQUcsR0FDN0YsS0FBSyxXQUFXLElBQ2hCLEtBQUssU0FBUyxJQUFJLFVBQVU7QUFDaEMsQ0FBQztBQUNNLFNBQVM2QixRQUFPLFFBQVE7QUFDM0IsU0FBWSxRQUFRRCxZQUFXLE1BQU07QUFDekM7QUFDTyxJQUFNLGtCQUFnQyxnQkFBSyxhQUFhLG1CQUFtQixDQUFDLE1BQU0sUUFBUTtBQUM3RixFQUFLLGlCQUFpQixLQUFLLE1BQU0sR0FBRyxHQUNwQ0EsV0FBVSxLQUFLLE1BQU0sR0FBRztBQUM1QixDQUFDO0FBQ00sU0FBUyxJQUFJLFFBQVE7QUFDeEIsU0FBWSxLQUFLLGlCQUFpQixNQUFNO0FBQzVDO0FBQ08sU0FBUyxRQUFRLFFBQVE7QUFDNUIsU0FBWSxTQUFTLGlCQUFpQixNQUFNO0FBQ2hEO0FBQ08sU0FBUyxRQUFRLFFBQVE7QUFDNUIsU0FBWSxTQUFTLGlCQUFpQixNQUFNO0FBQ2hEO0FBQ08sU0FBUyxNQUFNLFFBQVE7QUFDMUIsU0FBWSxPQUFPLGlCQUFpQixNQUFNO0FBQzlDO0FBQ08sU0FBUyxPQUFPLFFBQVE7QUFDM0IsU0FBWSxRQUFRLGlCQUFpQixNQUFNO0FBQy9DO0FBQ08sSUFBTUUsY0FBMkIsZ0JBQUssYUFBYSxjQUFjLENBQUMsTUFBTSxRQUFRO0FBQ25GLEVBQUssWUFBWSxLQUFLLE1BQU0sR0FBRyxHQUMvQjlDLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtnQixPQUFNLFdBQXNCLGlCQUFpQixNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUM1RyxDQUFDO0FBQ00sU0FBUytCLFNBQVEsUUFBUTtBQUM1QixTQUFZLFNBQVNELGFBQVksTUFBTTtBQUMzQztBQUNPLElBQU1FLGFBQTBCLGdCQUFLLGFBQWEsYUFBYSxDQUFDLE1BQU0sUUFBUTtBQUNqRixFQUFLLFdBQVcsS0FBSyxNQUFNLEdBQUcsR0FDOUJoRCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLZ0IsT0FBTSxXQUFzQixnQkFBZ0IsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDdkcsS0FBSyxNQUFNLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBYSxLQUFJLE9BQU8sTUFBTSxDQUFDLEdBQ2xFLEtBQUssTUFBTSxDQUFDLE9BQU8sV0FBVyxLQUFLLE1BQWEsS0FBSSxPQUFPLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLEtBQUssQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLElBQUcsT0FBTyxNQUFNLENBQUMsR0FDaEUsS0FBSyxNQUFNLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBYSxLQUFJLE9BQU8sTUFBTSxDQUFDLEdBQ2xFLEtBQUssTUFBTSxDQUFDLE9BQU8sV0FBVyxLQUFLLE1BQWEsS0FBSSxPQUFPLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLEtBQUssQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLElBQUcsT0FBTyxNQUFNLENBQUMsR0FDaEUsS0FBSyxNQUFNLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBYSxLQUFJLE9BQU8sTUFBTSxDQUFDLEdBQ2xFLEtBQUssTUFBTSxDQUFDLE9BQU8sV0FBVyxLQUFLLE1BQWEsS0FBSSxPQUFPLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLFdBQVcsQ0FBQyxXQUFXLEtBQUssTUFBYSxJQUFHLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUNuRSxLQUFLLFdBQVcsQ0FBQyxXQUFXLEtBQUssTUFBYSxJQUFHLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUNuRSxLQUFLLGNBQWMsQ0FBQyxXQUFXLEtBQUssTUFBYSxLQUFJLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUN2RSxLQUFLLGNBQWMsQ0FBQyxXQUFXLEtBQUssTUFBYSxLQUFJLE9BQU8sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUN2RSxLQUFLLGFBQWEsQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLFlBQVcsT0FBTyxNQUFNLENBQUM7QUFDaEYsTUFBTSxNQUFNLEtBQUssS0FBSztBQUN0QixPQUFLLFdBQVcsSUFBSSxXQUFXLE1BQy9CLEtBQUssV0FBVyxJQUFJLFdBQVcsTUFDL0IsS0FBSyxTQUFTLElBQUksVUFBVTtBQUNoQyxDQUFDO0FBQ00sU0FBU2lDLFFBQU8sUUFBUTtBQUMzQixTQUFZLFFBQVFELFlBQVcsTUFBTTtBQUN6QztBQUNPLElBQU0sa0JBQWdDLGdCQUFLLGFBQWEsbUJBQW1CLENBQUMsTUFBTSxRQUFRO0FBQzdGLEVBQUssaUJBQWlCLEtBQUssTUFBTSxHQUFHLEdBQ3BDQSxXQUFVLEtBQUssTUFBTSxHQUFHO0FBQzVCLENBQUM7QUFFTSxTQUFTLE1BQU0sUUFBUTtBQUMxQixTQUFZLE9BQU8saUJBQWlCLE1BQU07QUFDOUM7QUFFTyxTQUFTLE9BQU8sUUFBUTtBQUMzQixTQUFZLFFBQVEsaUJBQWlCLE1BQU07QUFDL0M7QUFDTyxJQUFNRSxhQUEwQixnQkFBSyxhQUFhLGFBQWEsQ0FBQyxNQUFNLFFBQVE7QUFDakYsRUFBSyxXQUFXLEtBQUssTUFBTSxHQUFHLEdBQzlCbEQsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS2dCLE9BQU0sV0FBc0IsZ0JBQWdCLE1BQU0sS0FBS0EsT0FBTSxNQUFNO0FBQzNHLENBQUM7QUFDTSxTQUFTLE9BQU8sUUFBUTtBQUMzQixTQUFZLFFBQVFrQyxZQUFXLE1BQU07QUFDekM7QUFDTyxJQUFNQyxnQkFBNkIsZ0JBQUssYUFBYSxnQkFBZ0IsQ0FBQyxNQUFNLFFBQVE7QUFDdkYsRUFBSyxjQUFjLEtBQUssTUFBTSxHQUFHLEdBQ2pDbkQsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS2dCLE9BQU0sV0FBc0IsbUJBQW1CLE1BQU0sS0FBS0EsT0FBTSxNQUFNO0FBQzlHLENBQUM7QUFDRCxTQUFTb0MsWUFBVyxRQUFRO0FBQ3hCLFNBQVlBLFlBQVdELGVBQWMsTUFBTTtBQUMvQztBQUVPLElBQU1FLFdBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUM3RSxFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDNUJDLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsY0FBYyxNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUN6RyxDQUFDO0FBQ0QsU0FBU0MsT0FBTSxRQUFRO0FBQ25CLFNBQVlBLE9BQU1ILFVBQVMsTUFBTTtBQUNyQztBQUVPLElBQU1JLFVBQXVCLGdCQUFLLGFBQWEsVUFBVSxDQUFDLE1BQU0sUUFBUTtBQUMzRSxFQUFLLFFBQVEsS0FBSyxNQUFNLEdBQUcsR0FDM0JDLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsYUFBYSxNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUN4RyxDQUFDO0FBQ00sU0FBUyxNQUFNO0FBQ2xCLFNBQVksS0FBS0YsT0FBTTtBQUMzQjtBQUNPLElBQU1HLGNBQTJCLGdCQUFLLGFBQWEsY0FBYyxDQUFDLE1BQU0sUUFBUTtBQUNuRixFQUFLLFlBQVksS0FBSyxNQUFNLEdBQUcsR0FDL0JGLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsaUJBQWlCLE1BQU0sS0FBS0EsT0FBTSxNQUFNO0FBQzVHLENBQUM7QUFDTSxTQUFTLFVBQVU7QUFDdEIsU0FBWSxTQUFTQyxXQUFVO0FBQ25DO0FBQ08sSUFBTUMsWUFBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBQy9FLEVBQUssVUFBVSxLQUFLLE1BQU0sR0FBRyxHQUM3QkgsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixlQUFlLE1BQU0sS0FBS0EsT0FBTSxNQUFNO0FBQzFHLENBQUM7QUFDTSxTQUFTLE1BQU0sUUFBUTtBQUMxQixTQUFZLE9BQU9FLFdBQVUsTUFBTTtBQUN2QztBQUNPLElBQU1DLFdBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUM3RSxFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDNUJKLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsY0FBYyxNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUN6RyxDQUFDO0FBQ0QsU0FBU0ksT0FBTSxRQUFRO0FBQ25CLFNBQVksTUFBTUQsVUFBUyxNQUFNO0FBQ3JDO0FBRU8sSUFBTUUsV0FBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBQzdFLEVBQUssU0FBUyxLQUFLLE1BQU0sR0FBRyxHQUM1QkMsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixjQUFjLE1BQU0sS0FBS0EsT0FBTSxNQUFNLEdBQ3JHLEtBQUssTUFBTSxDQUFDLE9BQU8sV0FBVyxLQUFLLE1BQWEsS0FBSSxPQUFPLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLE1BQU0sQ0FBQyxPQUFPLFdBQVcsS0FBSyxNQUFhLEtBQUksT0FBTyxNQUFNLENBQUM7QUFDbEUsTUFBTSxJQUFJLEtBQUssS0FBSztBQUNwQixPQUFLLFVBQVUsRUFBRSxVQUFVLElBQUksS0FBSyxFQUFFLE9BQU8sSUFBSSxNQUNqRCxLQUFLLFVBQVUsRUFBRSxVQUFVLElBQUksS0FBSyxFQUFFLE9BQU8sSUFBSTtBQUNyRCxDQUFDO0FBQ00sU0FBU0MsTUFBSyxRQUFRO0FBQ3pCLFNBQVksTUFBTUgsVUFBUyxNQUFNO0FBQ3JDO0FBQ08sSUFBTUksWUFBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBQy9FLEVBQUssVUFBVSxLQUFLLE1BQU0sR0FBRyxHQUM3QkgsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixlQUFlLE1BQU0sS0FBS0EsT0FBTSxNQUFNLEdBQ3RHLEtBQUssVUFBVSxJQUFJLFNBQ25CLEtBQUssTUFBTSxDQUFDLFdBQVcsV0FBVyxLQUFLLE1BQWEsV0FBVSxXQUFXLE1BQU0sQ0FBQyxHQUNoRixLQUFLLFdBQVcsQ0FBQyxXQUFXLEtBQUssTUFBYSxXQUFVLEdBQUcsTUFBTSxDQUFDLEdBQ2xFLEtBQUssTUFBTSxDQUFDLFdBQVcsV0FBVyxLQUFLLE1BQWEsV0FBVSxXQUFXLE1BQU0sQ0FBQyxHQUNoRixLQUFLLFNBQVMsQ0FBQyxLQUFLLFdBQVcsS0FBSyxNQUFhLFFBQU8sS0FBSyxNQUFNLENBQUMsR0FDcEUsS0FBSyxTQUFTLE1BQU0sS0FBSztBQUM3QixDQUFDO0FBQ00sU0FBUyxNQUFNLFNBQVMsUUFBUTtBQUNuQyxTQUFZLE9BQU9FLFdBQVUsU0FBUyxNQUFNO0FBQ2hEO0FBRU8sU0FBUyxNQUFNLFFBQVE7QUFDMUIsTUFBTSxRQUFRLE9BQU8sS0FBSyxJQUFJO0FBQzlCLFNBQU8sTUFBTSxPQUFPLEtBQUssS0FBSyxDQUFDO0FBQ25DO0FBQ08sSUFBTUMsYUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLEVBQUssY0FBYyxLQUFLLE1BQU0sR0FBRyxHQUNqQ0osU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixnQkFBZ0IsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDdkcsYUFBSyxXQUFXLE1BQU0sU0FBUyxNQUNwQixJQUFJLEtBQ2QsR0FDRCxLQUFLLFFBQVEsTUFBTSxNQUFNLE9BQU8sS0FBSyxLQUFLLEtBQUssSUFBSSxLQUFLLENBQUMsR0FDekQsS0FBSyxXQUFXLENBQUMsYUFBYSxLQUFLLE1BQU0sRUFBRSxHQUFHLEtBQUssS0FBSyxLQUFLLFNBQW1CLENBQUMsR0FDakYsS0FBSyxjQUFjLE1BQU0sS0FBSyxNQUFNLEVBQUUsR0FBRyxLQUFLLEtBQUssS0FBSyxVQUFVLFFBQVEsRUFBRSxDQUFDLEdBQzdFLEtBQUssUUFBUSxNQUFNLEtBQUssTUFBTSxFQUFFLEdBQUcsS0FBSyxLQUFLLEtBQUssVUFBVSxRQUFRLEVBQUUsQ0FBQyxHQUN2RSxLQUFLLFNBQVMsTUFBTSxLQUFLLE1BQU0sRUFBRSxHQUFHLEtBQUssS0FBSyxLQUFLLFVBQVUsTUFBTSxFQUFFLENBQUMsR0FDdEUsS0FBSyxRQUFRLE1BQU0sS0FBSyxNQUFNLEVBQUUsR0FBRyxLQUFLLEtBQUssS0FBSyxVQUFVLE9BQVUsQ0FBQyxHQUN2RSxLQUFLLFNBQVMsQ0FBQyxhQUNKLGFBQUssT0FBTyxNQUFNLFFBQVEsR0FFckMsS0FBSyxhQUFhLENBQUMsYUFDUixhQUFLLFdBQVcsTUFBTSxRQUFRLEdBRXpDLEtBQUssUUFBUSxDQUFDLFVBQVUsYUFBSyxNQUFNLE1BQU0sS0FBSyxHQUM5QyxLQUFLLE9BQU8sQ0FBQyxTQUFTLGFBQUssS0FBSyxNQUFNLElBQUksR0FDMUMsS0FBSyxPQUFPLENBQUMsU0FBUyxhQUFLLEtBQUssTUFBTSxJQUFJLEdBQzFDLEtBQUssVUFBVSxJQUFJLFNBQVMsYUFBSyxRQUFRSSxjQUFhLE1BQU0sS0FBSyxDQUFDLENBQUMsR0FDbkUsS0FBSyxXQUFXLElBQUksU0FBUyxhQUFLLFNBQVMsZ0JBQWdCLE1BQU0sS0FBSyxDQUFDLENBQUM7QUFDNUUsQ0FBQztBQUNNLFNBQVNDLFFBQU8sT0FBTyxRQUFRO0FBQ2xDLE1BQU0sTUFBTTtBQUFBLElBQ1IsTUFBTTtBQUFBLElBQ04sT0FBTyxTQUFTLENBQUM7QUFBQSxJQUNqQixHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQztBQUNBLFNBQU8sSUFBSUYsV0FBVSxHQUFHO0FBQzVCO0FBRU8sU0FBUyxhQUFhLE9BQU8sUUFBUTtBQUN4QyxTQUFPLElBQUlBLFdBQVU7QUFBQSxJQUNqQixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0EsVUFBVSxNQUFNO0FBQUEsSUFDaEIsR0FBRyxhQUFLLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBRU8sU0FBUyxZQUFZLE9BQU8sUUFBUTtBQUN2QyxTQUFPLElBQUlBLFdBQVU7QUFBQSxJQUNqQixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0EsVUFBVSxRQUFRO0FBQUEsSUFDbEIsR0FBRyxhQUFLLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQ08sSUFBTUcsWUFBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBQy9FLEVBQUssVUFBVSxLQUFLLE1BQU0sR0FBRyxHQUM3QlAsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixlQUFlLE1BQU0sS0FBS0EsT0FBTSxNQUFNLEdBQ3RHLEtBQUssVUFBVSxJQUFJO0FBQ3ZCLENBQUM7QUFDTSxTQUFTLE1BQU0sU0FBUyxRQUFRO0FBQ25DLFNBQU8sSUFBSU0sVUFBUztBQUFBLElBQ2hCLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNLFNBQXVCLGdCQUFLLGFBQWEsVUFBVSxDQUFDLE1BQU0sUUFBUTtBQUMzRSxFQUFBQSxVQUFTLEtBQUssTUFBTSxHQUFHLEdBQ2xCLFFBQVEsS0FBSyxNQUFNLEdBQUcsR0FDM0IsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtOLE9BQU0sV0FBc0IsZUFBZSxNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN0RyxLQUFLLFVBQVUsSUFBSTtBQUN2QixDQUFDO0FBSU0sU0FBUyxJQUFJLFNBQVMsUUFBUTtBQUNqQyxTQUFPLElBQUksT0FBTztBQUFBLElBQ2QsTUFBTTtBQUFBLElBQ047QUFBQSxJQUNBLFdBQVc7QUFBQSxJQUNYLEdBQUcsYUFBSyxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUNPLElBQU1PLHlCQUFzQyxnQkFBSyxhQUFhLHlCQUF5QixDQUFDLE1BQU0sUUFBUTtBQUN6RyxFQUFBRCxVQUFTLEtBQUssTUFBTSxHQUFHLEdBQ2xCLHVCQUF1QixLQUFLLE1BQU0sR0FBRztBQUM5QyxDQUFDO0FBQ00sU0FBUyxtQkFBbUIsZUFBZSxTQUFTLFFBQVE7QUFFL0QsU0FBTyxJQUFJQyx1QkFBc0I7QUFBQSxJQUM3QixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBLEdBQUcsYUFBSyxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUNPLElBQU1DLG1CQUFnQyxnQkFBSyxhQUFhLG1CQUFtQixDQUFDLE1BQU0sUUFBUTtBQUM3RixFQUFLLGlCQUFpQixLQUFLLE1BQU0sR0FBRyxHQUNwQ1QsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixzQkFBc0IsTUFBTSxLQUFLQSxPQUFNLE1BQU07QUFDakgsQ0FBQztBQUNNLFNBQVMsYUFBYSxNQUFNLE9BQU87QUFDdEMsU0FBTyxJQUFJUSxpQkFBZ0I7QUFBQSxJQUN2QixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUNPLElBQU1DLFlBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxFQUFLLFVBQVUsS0FBSyxNQUFNLEdBQUcsR0FDN0JWLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsZUFBZSxNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN0RyxLQUFLLE9BQU8sQ0FBQyxTQUFTLEtBQUssTUFBTTtBQUFBLElBQzdCLEdBQUcsS0FBSyxLQUFLO0FBQUEsSUFDYjtBQUFBLEVBQ0osQ0FBQztBQUNMLENBQUM7QUFDTSxTQUFTLE1BQU0sT0FBTyxlQUFlLFNBQVM7QUFDakQsTUFBTSxVQUFVLHlCQUE4QixVQUN4QyxTQUFTLFVBQVUsVUFBVSxlQUM3QixPQUFPLFVBQVUsZ0JBQWdCO0FBQ3ZDLFNBQU8sSUFBSVMsVUFBUztBQUFBLElBQ2hCLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQTtBQUFBLElBQ0EsR0FBRyxhQUFLLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQ08sSUFBTUMsYUFBMEIsZ0JBQUssYUFBYSxhQUFhLENBQUMsTUFBTSxRQUFRO0FBQ2pGLEVBQUssV0FBVyxLQUFLLE1BQU0sR0FBRyxHQUM5QlgsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixnQkFBZ0IsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDdkcsS0FBSyxVQUFVLElBQUksU0FDbkIsS0FBSyxZQUFZLElBQUk7QUFDekIsQ0FBQztBQUNNLFNBQVMsT0FBTyxTQUFTLFdBQVcsUUFBUTtBQUMvQyxTQUFPLElBQUlVLFdBQVU7QUFBQSxJQUNqQixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0E7QUFBQSxJQUNBLEdBQUcsYUFBSyxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUVPLFNBQVMsY0FBYyxTQUFTLFdBQVcsUUFBUTtBQUN0RCxNQUFNLElBQVMsTUFBTSxPQUFPO0FBQzVCLFdBQUUsS0FBSyxTQUFTLFFBQ1QsSUFBSUEsV0FBVTtBQUFBLElBQ2pCLE1BQU07QUFBQSxJQUNOLFNBQVM7QUFBQSxJQUNUO0FBQUEsSUFDQSxHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxTQUFTLFlBQVksU0FBUyxXQUFXLFFBQVE7QUFDcEQsU0FBTyxJQUFJQSxXQUFVO0FBQUEsSUFDakIsTUFBTTtBQUFBLElBQ047QUFBQSxJQUNBO0FBQUEsSUFDQSxNQUFNO0FBQUEsSUFDTixHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNQyxVQUF1QixnQkFBSyxhQUFhLFVBQVUsQ0FBQyxNQUFNLFFBQVE7QUFDM0UsRUFBSyxRQUFRLEtBQUssTUFBTSxHQUFHLEdBQzNCWixTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGFBQWEsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDcEcsS0FBSyxVQUFVLElBQUksU0FDbkIsS0FBSyxZQUFZLElBQUksV0FDckIsS0FBSyxNQUFNLElBQUksU0FBUyxLQUFLLE1BQVcsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUN6RCxLQUFLLFdBQVcsQ0FBQyxXQUFXLEtBQUssTUFBVyxTQUFTLEdBQUcsTUFBTSxDQUFDLEdBQy9ELEtBQUssTUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFXLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FDekQsS0FBSyxPQUFPLElBQUksU0FBUyxLQUFLLE1BQVcsTUFBTSxHQUFHLElBQUksQ0FBQztBQUMzRCxDQUFDO0FBQ00sU0FBUyxJQUFJLFNBQVMsV0FBVyxRQUFRO0FBQzVDLFNBQU8sSUFBSVcsUUFBTztBQUFBLElBQ2QsTUFBTTtBQUFBLElBQ047QUFBQSxJQUNBO0FBQUEsSUFDQSxHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNQyxVQUF1QixnQkFBSyxhQUFhLFVBQVUsQ0FBQyxNQUFNLFFBQVE7QUFDM0UsRUFBSyxRQUFRLEtBQUssTUFBTSxHQUFHLEdBQzNCYixTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGFBQWEsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDcEcsS0FBSyxNQUFNLElBQUksU0FBUyxLQUFLLE1BQVcsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUN6RCxLQUFLLFdBQVcsQ0FBQyxXQUFXLEtBQUssTUFBVyxTQUFTLEdBQUcsTUFBTSxDQUFDLEdBQy9ELEtBQUssTUFBTSxJQUFJLFNBQVMsS0FBSyxNQUFXLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FDekQsS0FBSyxPQUFPLElBQUksU0FBUyxLQUFLLE1BQVcsTUFBTSxHQUFHLElBQUksQ0FBQztBQUMzRCxDQUFDO0FBQ00sU0FBUyxJQUFJLFdBQVcsUUFBUTtBQUNuQyxTQUFPLElBQUlZLFFBQU87QUFBQSxJQUNkLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNQyxXQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsRUFBSyxTQUFTLEtBQUssTUFBTSxHQUFHLEdBQzVCZCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGNBQWMsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDckcsS0FBSyxPQUFPLElBQUksU0FDaEIsS0FBSyxVQUFVLE9BQU8sT0FBTyxJQUFJLE9BQU87QUFDeEMsTUFBTSxPQUFPLElBQUksSUFBSSxPQUFPLEtBQUssSUFBSSxPQUFPLENBQUM7QUFDN0MsT0FBSyxVQUFVLENBQUMsUUFBUSxXQUFXO0FBQy9CLFFBQU0sYUFBYSxDQUFDO0FBQ3BCLGFBQVcsU0FBUztBQUNoQixVQUFJLEtBQUssSUFBSSxLQUFLO0FBQ2QsbUJBQVcsS0FBSyxJQUFJLElBQUksUUFBUSxLQUFLO0FBQUE7QUFHckMsY0FBTSxJQUFJLE1BQU0sT0FBTyxLQUFLLG9CQUFvQjtBQUV4RCxXQUFPLElBQUlhLFNBQVE7QUFBQSxNQUNmLEdBQUc7QUFBQSxNQUNILFFBQVEsQ0FBQztBQUFBLE1BQ1QsR0FBRyxhQUFLLGdCQUFnQixNQUFNO0FBQUEsTUFDOUIsU0FBUztBQUFBLElBQ2IsQ0FBQztBQUFBLEVBQ0wsR0FDQSxLQUFLLFVBQVUsQ0FBQyxRQUFRLFdBQVc7QUFDL0IsUUFBTSxhQUFhLEVBQUUsR0FBRyxJQUFJLFFBQVE7QUFDcEMsYUFBVyxTQUFTO0FBQ2hCLFVBQUksS0FBSyxJQUFJLEtBQUs7QUFDZCxlQUFPLFdBQVcsS0FBSztBQUFBO0FBR3ZCLGNBQU0sSUFBSSxNQUFNLE9BQU8sS0FBSyxvQkFBb0I7QUFFeEQsV0FBTyxJQUFJQSxTQUFRO0FBQUEsTUFDZixHQUFHO0FBQUEsTUFDSCxRQUFRLENBQUM7QUFBQSxNQUNULEdBQUcsYUFBSyxnQkFBZ0IsTUFBTTtBQUFBLE1BQzlCLFNBQVM7QUFBQSxJQUNiLENBQUM7QUFBQSxFQUNMO0FBQ0osQ0FBQztBQUNELFNBQVMsTUFBTSxRQUFRLFFBQVE7QUFDM0IsTUFBTSxVQUFVLE1BQU0sUUFBUSxNQUFNLElBQUksT0FBTyxZQUFZLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLElBQUk7QUFDeEYsU0FBTyxJQUFJQSxTQUFRO0FBQUEsSUFDZixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0EsR0FBRyxhQUFLLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBU08sU0FBUyxXQUFXLFNBQVMsUUFBUTtBQUN4QyxTQUFPLElBQUlDLFNBQVE7QUFBQSxJQUNmLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNQyxjQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsRUFBSyxZQUFZLEtBQUssTUFBTSxHQUFHLEdBQy9CQyxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGlCQUFpQixNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN4RyxLQUFLLFNBQVMsSUFBSSxJQUFJLElBQUksTUFBTSxHQUNoQyxPQUFPLGVBQWUsTUFBTSxTQUFTO0FBQUEsSUFDakMsTUFBTTtBQUNGLFVBQUksSUFBSSxPQUFPLFNBQVM7QUFDcEIsY0FBTSxJQUFJLE1BQU0sNEVBQTRFO0FBRWhHLGFBQU8sSUFBSSxPQUFPLENBQUM7QUFBQSxJQUN2QjtBQUFBLEVBQ0osQ0FBQztBQUNMLENBQUM7QUFDTSxTQUFTLFFBQVEsT0FBTyxRQUFRO0FBQ25DLFNBQU8sSUFBSUYsWUFBVztBQUFBLElBQ2xCLE1BQU07QUFBQSxJQUNOLFFBQVEsTUFBTSxRQUFRLEtBQUssSUFBSSxRQUFRLENBQUMsS0FBSztBQUFBLElBQzdDLEdBQUcsYUFBSyxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDTDtBQUNPLElBQU0sVUFBd0IsZ0JBQUssYUFBYSxXQUFXLENBQUMsTUFBTSxRQUFRO0FBQzdFLEVBQUssU0FBUyxLQUFLLE1BQU0sR0FBRyxHQUM1QkMsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixjQUFjLE1BQU0sS0FBS0EsT0FBTSxNQUFNLEdBQ3JHLEtBQUssTUFBTSxDQUFDLE1BQU0sV0FBVyxLQUFLLE1BQVcsU0FBUyxNQUFNLE1BQU0sQ0FBQyxHQUNuRSxLQUFLLE1BQU0sQ0FBQyxNQUFNLFdBQVcsS0FBSyxNQUFXLFNBQVMsTUFBTSxNQUFNLENBQUMsR0FDbkUsS0FBSyxPQUFPLENBQUMsT0FBTyxXQUFXLEtBQUssTUFBVyxNQUFNLE1BQU0sUUFBUSxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssR0FBRyxNQUFNLENBQUM7QUFDeEcsQ0FBQztBQUNNLFNBQVMsS0FBSyxRQUFRO0FBQ3pCLFNBQVksTUFBTSxTQUFTLE1BQU07QUFDckM7QUFDTyxJQUFNLGVBQTZCLGdCQUFLLGFBQWEsZ0JBQWdCLENBQUMsTUFBTSxRQUFRO0FBQ3ZGLEVBQUssY0FBYyxLQUFLLE1BQU0sR0FBRyxHQUNqQ0QsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixtQkFBbUIsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDMUcsS0FBSyxLQUFLLFFBQVEsQ0FBQyxTQUFTLFNBQVM7QUFDakMsUUFBSSxLQUFLLGNBQWM7QUFDbkIsWUFBTSxJQUFTLGdCQUFnQixLQUFLLFlBQVksSUFBSTtBQUV4RCxZQUFRLFdBQVcsQ0FBQ0MsV0FBVTtBQUMxQixVQUFJLE9BQU9BLFVBQVU7QUFDakIsZ0JBQVEsT0FBTyxLQUFLLGFBQUssTUFBTUEsUUFBTyxRQUFRLE9BQU8sR0FBRyxDQUFDO0FBQUEsV0FFeEQ7QUFFRCxZQUFNLFNBQVNBO0FBQ2YsUUFBSSxPQUFPLFVBQ1AsT0FBTyxXQUFXLEtBQ3RCLE9BQU8sU0FBUyxPQUFPLE9BQU8sV0FDOUIsT0FBTyxVQUFVLE9BQU8sUUFBUSxRQUFRLFFBQ3hDLE9BQU8sU0FBUyxPQUFPLE9BQU8sT0FFOUIsUUFBUSxPQUFPLEtBQUssYUFBSyxNQUFNLE1BQU0sQ0FBQztBQUFBLE1BQzFDO0FBQUEsSUFDSjtBQUNBLFFBQU0sU0FBUyxJQUFJLFVBQVUsUUFBUSxPQUFPLE9BQU87QUFDbkQsV0FBSSxrQkFBa0IsVUFDWCxPQUFPLEtBQUssQ0FBQ0MsYUFDaEIsUUFBUSxRQUFRQSxTQUNULFFBQ1YsS0FFTCxRQUFRLFFBQVEsUUFDVDtBQUFBLEVBQ1g7QUFDSixDQUFDO0FBQ00sU0FBUyxVQUFVLElBQUk7QUFDMUIsU0FBTyxJQUFJLGFBQWE7QUFBQSxJQUNwQixNQUFNO0FBQUEsSUFDTixXQUFXO0FBQUEsRUFDZixDQUFDO0FBQ0w7QUFDTyxJQUFNQyxlQUE0QixnQkFBSyxhQUFhLGVBQWUsQ0FBQyxNQUFNLFFBQVE7QUFDckYsRUFBSyxhQUFhLEtBQUssTUFBTSxHQUFHLEdBQ2hDSixTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGtCQUFrQixNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN6RyxLQUFLLFNBQVMsTUFBTSxLQUFLLEtBQUssSUFBSTtBQUN0QyxDQUFDO0FBQ00sU0FBUyxTQUFTLFdBQVc7QUFDaEMsU0FBTyxJQUFJRyxhQUFZO0FBQUEsSUFDbkIsTUFBTTtBQUFBLElBQ047QUFBQSxFQUNKLENBQUM7QUFDTDtBQUNPLElBQU0sbUJBQWlDLGdCQUFLLGFBQWEsb0JBQW9CLENBQUMsTUFBTSxRQUFRO0FBQy9GLEVBQUssa0JBQWtCLEtBQUssTUFBTSxHQUFHLEdBQ3JDSixTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGtCQUFrQixNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN6RyxLQUFLLFNBQVMsTUFBTSxLQUFLLEtBQUssSUFBSTtBQUN0QyxDQUFDO0FBQ00sU0FBUyxjQUFjLFdBQVc7QUFDckMsU0FBTyxJQUFJLGlCQUFpQjtBQUFBLElBQ3hCLE1BQU07QUFBQSxJQUNOO0FBQUEsRUFDSixDQUFDO0FBQ0w7QUFDTyxJQUFNSSxlQUE0QixnQkFBSyxhQUFhLGVBQWUsQ0FBQyxNQUFNLFFBQVE7QUFDckYsRUFBSyxhQUFhLEtBQUssTUFBTSxHQUFHLEdBQ2hDTCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGtCQUFrQixNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN6RyxLQUFLLFNBQVMsTUFBTSxLQUFLLEtBQUssSUFBSTtBQUN0QyxDQUFDO0FBQ00sU0FBUyxTQUFTLFdBQVc7QUFDaEMsU0FBTyxJQUFJSSxhQUFZO0FBQUEsSUFDbkIsTUFBTTtBQUFBLElBQ047QUFBQSxFQUNKLENBQUM7QUFDTDtBQUVPLFNBQVNDLFNBQVEsV0FBVztBQUMvQixTQUFPLFNBQVMsU0FBUyxTQUFTLENBQUM7QUFDdkM7QUFDTyxJQUFNQyxjQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsRUFBSyxZQUFZLEtBQUssTUFBTSxHQUFHLEdBQy9CUCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGlCQUFpQixNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN4RyxLQUFLLFNBQVMsTUFBTSxLQUFLLEtBQUssSUFBSSxXQUNsQyxLQUFLLGdCQUFnQixLQUFLO0FBQzlCLENBQUM7QUFDTSxTQUFTLFNBQVMsV0FBVyxjQUFjO0FBQzlDLFNBQU8sSUFBSU0sWUFBVztBQUFBLElBQ2xCLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxJQUFJLGVBQWU7QUFDZixhQUFPLE9BQU8sZ0JBQWlCLGFBQWEsYUFBYSxJQUFJLGFBQUssYUFBYSxZQUFZO0FBQUEsSUFDL0Y7QUFBQSxFQUNKLENBQUM7QUFDTDtBQUNPLElBQU0sY0FBNEIsZ0JBQUssYUFBYSxlQUFlLENBQUMsTUFBTSxRQUFRO0FBQ3JGLEVBQUssYUFBYSxLQUFLLE1BQU0sR0FBRyxHQUNoQ1AsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixrQkFBa0IsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDekcsS0FBSyxTQUFTLE1BQU0sS0FBSyxLQUFLLElBQUk7QUFDdEMsQ0FBQztBQUNNLFNBQVMsU0FBUyxXQUFXLGNBQWM7QUFDOUMsU0FBTyxJQUFJLFlBQVk7QUFBQSxJQUNuQixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0EsSUFBSSxlQUFlO0FBQ2YsYUFBTyxPQUFPLGdCQUFpQixhQUFhLGFBQWEsSUFBSSxhQUFLLGFBQWEsWUFBWTtBQUFBLElBQy9GO0FBQUEsRUFDSixDQUFDO0FBQ0w7QUFDTyxJQUFNLGlCQUErQixnQkFBSyxhQUFhLGtCQUFrQixDQUFDLE1BQU0sUUFBUTtBQUMzRixFQUFLLGdCQUFnQixLQUFLLE1BQU0sR0FBRyxHQUNuQ0QsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixxQkFBcUIsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDNUcsS0FBSyxTQUFTLE1BQU0sS0FBSyxLQUFLLElBQUk7QUFDdEMsQ0FBQztBQUNNLFNBQVMsWUFBWSxXQUFXLFFBQVE7QUFDM0MsU0FBTyxJQUFJLGVBQWU7QUFBQSxJQUN0QixNQUFNO0FBQUEsSUFDTjtBQUFBLElBQ0EsR0FBRyxhQUFLLGdCQUFnQixNQUFNO0FBQUEsRUFDbEMsQ0FBQztBQUNMO0FBQ08sSUFBTSxhQUEyQixnQkFBSyxhQUFhLGNBQWMsQ0FBQyxNQUFNLFFBQVE7QUFDbkYsRUFBSyxZQUFZLEtBQUssTUFBTSxHQUFHLEdBQy9CRCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGlCQUFpQixNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUN4RyxLQUFLLFNBQVMsTUFBTSxLQUFLLEtBQUssSUFBSTtBQUN0QyxDQUFDO0FBQ00sU0FBUyxRQUFRLFdBQVc7QUFDL0IsU0FBTyxJQUFJLFdBQVc7QUFBQSxJQUNsQixNQUFNO0FBQUEsSUFDTjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQ08sSUFBTU8sWUFBeUIsZ0JBQUssYUFBYSxZQUFZLENBQUMsTUFBTSxRQUFRO0FBQy9FLEVBQUssVUFBVSxLQUFLLE1BQU0sR0FBRyxHQUM3QlIsU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixlQUFlLE1BQU0sS0FBS0EsT0FBTSxNQUFNLEdBQ3RHLEtBQUssU0FBUyxNQUFNLEtBQUssS0FBSyxJQUFJLFdBQ2xDLEtBQUssY0FBYyxLQUFLO0FBQzVCLENBQUM7QUFDRCxTQUFTLE9BQU8sV0FBVyxZQUFZO0FBQ25DLFNBQU8sSUFBSU8sVUFBUztBQUFBLElBQ2hCLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxZQUFhLE9BQU8sY0FBZSxhQUFhLGFBQWEsTUFBTTtBQUFBLEVBQ3ZFLENBQUM7QUFDTDtBQUVPLElBQU1DLFVBQXVCLGdCQUFLLGFBQWEsVUFBVSxDQUFDLE1BQU0sUUFBUTtBQUMzRSxFQUFLLFFBQVEsS0FBSyxNQUFNLEdBQUcsR0FDM0JDLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsYUFBYSxNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUN4RyxDQUFDO0FBQ00sU0FBUyxJQUFJLFFBQVE7QUFDeEIsU0FBWSxLQUFLRixTQUFRLE1BQU07QUFDbkM7QUFDTyxJQUFNLFVBQXdCLGdCQUFLLGFBQWEsV0FBVyxDQUFDLE1BQU0sUUFBUTtBQUM3RSxFQUFLLFNBQVMsS0FBSyxNQUFNLEdBQUcsR0FDNUJDLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IsY0FBYyxNQUFNLEtBQUtBLE9BQU0sTUFBTSxHQUNyRyxLQUFLLEtBQUssSUFBSSxJQUNkLEtBQUssTUFBTSxJQUFJO0FBQ25CLENBQUM7QUFDTSxTQUFTLEtBQUssS0FBSyxLQUFLO0FBQzNCLFNBQU8sSUFBSSxRQUFRO0FBQUEsSUFDZixNQUFNO0FBQUEsSUFDTixJQUFJO0FBQUEsSUFDSjtBQUFBO0FBQUEsRUFFSixDQUFDO0FBQ0w7QUFDTyxJQUFNLFdBQXlCLGdCQUFLLGFBQWEsWUFBWSxDQUFDLE1BQU0sUUFBUTtBQUMvRSxVQUFRLEtBQUssTUFBTSxHQUFHLEdBQ2pCLFVBQVUsS0FBSyxNQUFNLEdBQUc7QUFDakMsQ0FBQztBQUNNLFNBQVMsTUFBTSxLQUFLLEtBQUssUUFBUTtBQUNwQyxTQUFPLElBQUksU0FBUztBQUFBLElBQ2hCLE1BQU07QUFBQSxJQUNOLElBQUk7QUFBQSxJQUNKO0FBQUEsSUFDQSxXQUFXLE9BQU87QUFBQSxJQUNsQixrQkFBa0IsT0FBTztBQUFBLEVBQzdCLENBQUM7QUFDTDtBQUNPLElBQU1DLGVBQTRCLGdCQUFLLGFBQWEsZUFBZSxDQUFDLE1BQU0sUUFBUTtBQUNyRixFQUFLLGFBQWEsS0FBSyxNQUFNLEdBQUcsR0FDaENGLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0Isa0JBQWtCLE1BQU0sS0FBS0EsT0FBTSxNQUFNLEdBQ3pHLEtBQUssU0FBUyxNQUFNLEtBQUssS0FBSyxJQUFJO0FBQ3RDLENBQUM7QUFDTSxTQUFTLFNBQVMsV0FBVztBQUNoQyxTQUFPLElBQUlDLGFBQVk7QUFBQSxJQUNuQixNQUFNO0FBQUEsSUFDTjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQ08sSUFBTSxxQkFBbUMsZ0JBQUssYUFBYSxzQkFBc0IsQ0FBQyxNQUFNLFFBQVE7QUFDbkcsRUFBSyxvQkFBb0IsS0FBSyxNQUFNLEdBQUcsR0FDdkNGLFNBQVEsS0FBSyxNQUFNLEdBQUcsR0FDdEIsS0FBSyxLQUFLLG9CQUFvQixDQUFDLEtBQUtDLE9BQU0sV0FBc0IseUJBQXlCLE1BQU0sS0FBS0EsT0FBTSxNQUFNO0FBQ3BILENBQUM7QUFDTSxTQUFTLGdCQUFnQixPQUFPLFFBQVE7QUFDM0MsU0FBTyxJQUFJLG1CQUFtQjtBQUFBLElBQzFCLE1BQU07QUFBQSxJQUNOO0FBQUEsSUFDQSxHQUFHLGFBQUssZ0JBQWdCLE1BQU07QUFBQSxFQUNsQyxDQUFDO0FBQ0w7QUFDTyxJQUFNRSxXQUF3QixnQkFBSyxhQUFhLFdBQVcsQ0FBQyxNQUFNLFFBQVE7QUFDN0UsRUFBSyxTQUFTLEtBQUssTUFBTSxHQUFHLEdBQzVCSCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGNBQWMsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDckcsS0FBSyxTQUFTLE1BQU0sS0FBSyxLQUFLLElBQUksT0FBTztBQUM3QyxDQUFDO0FBQ00sU0FBUyxLQUFLLFFBQVE7QUFDekIsU0FBTyxJQUFJRSxTQUFRO0FBQUEsSUFDZixNQUFNO0FBQUEsSUFDTjtBQUFBLEVBQ0osQ0FBQztBQUNMO0FBQ08sSUFBTUMsY0FBMkIsZ0JBQUssYUFBYSxjQUFjLENBQUMsTUFBTSxRQUFRO0FBQ25GLEVBQUssWUFBWSxLQUFLLE1BQU0sR0FBRyxHQUMvQkosU0FBUSxLQUFLLE1BQU0sR0FBRyxHQUN0QixLQUFLLEtBQUssb0JBQW9CLENBQUMsS0FBS0MsT0FBTSxXQUFzQixpQkFBaUIsTUFBTSxLQUFLQSxPQUFNLE1BQU0sR0FDeEcsS0FBSyxTQUFTLE1BQU0sS0FBSyxLQUFLLElBQUk7QUFDdEMsQ0FBQztBQUNNLFNBQVMsUUFBUSxXQUFXO0FBQy9CLFNBQU8sSUFBSUcsWUFBVztBQUFBLElBQ2xCLE1BQU07QUFBQSxJQUNOO0FBQUEsRUFDSixDQUFDO0FBQ0w7QUFDTyxJQUFNQyxlQUE0QixnQkFBSyxhQUFhLGVBQWUsQ0FBQyxNQUFNLFFBQVE7QUFDckYsRUFBSyxhQUFhLEtBQUssTUFBTSxHQUFHLEdBQ2hDTCxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGtCQUFrQixNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUM3RyxDQUFDO0FBQ00sU0FBUyxVQUFVLFFBQVE7QUFDOUIsU0FBTyxJQUFJSSxhQUFZO0FBQUEsSUFDbkIsTUFBTTtBQUFBLElBQ04sT0FBTyxNQUFNLFFBQVEsUUFBUSxLQUFLLElBQUksTUFBTSxRQUFRLEtBQUssSUFBSyxRQUFRLFNBQVMsTUFBTSxRQUFRLENBQUM7QUFBQSxJQUM5RixRQUFRLFFBQVEsVUFBVSxRQUFRO0FBQUEsRUFDdEMsQ0FBQztBQUNMO0FBRU8sSUFBTSxZQUEwQixnQkFBSyxhQUFhLGFBQWEsQ0FBQyxNQUFNLFFBQVE7QUFDakYsRUFBSyxXQUFXLEtBQUssTUFBTSxHQUFHLEdBQzlCQyxTQUFRLEtBQUssTUFBTSxHQUFHLEdBQ3RCLEtBQUssS0FBSyxvQkFBb0IsQ0FBQyxLQUFLQyxPQUFNLFdBQXNCLGdCQUFnQixNQUFNLEtBQUtBLE9BQU0sTUFBTTtBQUMzRyxDQUFDO0FBRU0sU0FBUyxNQUFNLElBQUk7QUFDdEIsTUFBTSxLQUFLLElBQVMsVUFBVTtBQUFBLElBQzFCLE9BQU87QUFBQTtBQUFBLEVBRVgsQ0FBQztBQUNELFlBQUcsS0FBSyxRQUFRLElBQ1Q7QUFDWDtBQUNPLFNBQVMsT0FBTyxJQUFJLFNBQVM7QUFDaEMsU0FBWSxRQUFRLFdBQVcsT0FBTyxNQUFNLEtBQU8sT0FBTztBQUM5RDtBQUNPLFNBQVMsT0FBTyxJQUFJLFVBQVUsQ0FBQyxHQUFHO0FBQ3JDLFNBQVksUUFBUSxXQUFXLElBQUksT0FBTztBQUM5QztBQUVPLFNBQVMsWUFBWSxJQUFJO0FBQzVCLFNBQVksYUFBYSxFQUFFO0FBQy9CO0FBRU8sSUFBTUMsWUFBZ0IsVUFDaEJDLFFBQVk7QUFDekIsU0FBUyxZQUFZLEtBQUssU0FBUyxDQUFDLEdBQUc7QUFDbkMsTUFBTSxPQUFPLElBQUksVUFBVTtBQUFBLElBQ3ZCLE1BQU07QUFBQSxJQUNOLE9BQU87QUFBQSxJQUNQLElBQUksQ0FBQyxTQUFTLGdCQUFnQjtBQUFBLElBQzlCLE9BQU87QUFBQSxJQUNQLEdBQUcsYUFBSyxnQkFBZ0IsTUFBTTtBQUFBLEVBQ2xDLENBQUM7QUFDRCxjQUFLLEtBQUssSUFBSSxRQUFRLEtBRXRCLEtBQUssS0FBSyxRQUFRLENBQUMsWUFBWTtBQUMzQixJQUFNLFFBQVEsaUJBQWlCLE9BQzNCLFFBQVEsT0FBTyxLQUFLO0FBQUEsTUFDaEIsTUFBTTtBQUFBLE1BQ04sVUFBVSxJQUFJO0FBQUEsTUFDZCxPQUFPLFFBQVE7QUFBQSxNQUNmO0FBQUEsTUFDQSxNQUFNLENBQUMsR0FBSSxLQUFLLEtBQUssSUFBSSxRQUFRLENBQUMsQ0FBRTtBQUFBLElBQ3hDLENBQUM7QUFBQSxFQUVULEdBQ087QUFDWDtBQUdPLElBQU0sYUFBYSxJQUFJLFNBQWMsWUFBWTtBQUFBLEVBQ3BELE9BQU87QUFBQSxFQUNQLFNBQVNDO0FBQUEsRUFDVCxRQUFRQztBQUNaLEdBQUcsR0FBRyxJQUFJO0FBQ0gsU0FBUyxLQUFLLFFBQVE7QUFDekIsTUFBTSxhQUFhLEtBQUssTUFDYixNQUFNLENBQUNDLFFBQU8sTUFBTSxHQUFHQyxRQUFPLEdBQUdDLFNBQVEsR0FBR0MsT0FBTSxHQUFHLE1BQU0sVUFBVSxHQUFHLE9BQU9ILFFBQU8sR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUMvRztBQUNELFNBQU87QUFDWDtBQUdPLFNBQVMsV0FBVyxJQUFJLFFBQVE7QUFDbkMsU0FBTyxLQUFLLFVBQVUsRUFBRSxHQUFHLE1BQU07QUFDckM7OztBS3htQ08sSUFBSUk7QUFFUkEsMkJBQTBCQSx5QkFBd0IsQ0FBQzs7O0FDekJ0RCxJQUFNLElBQUk7QUFBQSxFQUNOLEdBQUdDO0FBQUEsRUFDSCxHQUFHQztBQUFBLEVBQ0gsS0FBS0M7QUFDVDs7O0FDQUEsT0FBT0MsWUFBRyxDQUFDOzs7QUNOSixJQUFNLDBCQUEwQjtBQUVoQyxJQUFNLDhCQUE4QixDQUFDLHlCQUF5QixjQUFjLGNBQWMsY0FBYyxZQUFZLEdBRTlHLHdCQUF3Qix3Q0FHeEIsa0JBQWtCLE9BV3pCLHFCQUF1QixPQUFlLENBQUMsTUFBbUIsTUFBTSxTQUFTLE9BQU8sS0FBTSxZQUFZLE9BQU8sS0FBTSxXQUFXLEdBSW5ILHNCQUF3QixNQUFNLENBQUdDLFFBQU0sR0FBTUMsUUFBTSxFQUFHLElBQUcsQ0FBRSxDQUFDLEdBSzVELGVBQWlCRCxRQUFNLEdBS3ZCLDJCQUE2QixZQUFZOzs7OztFQUtsRCxLQUFPLE1BQU0sQ0FBR0MsUUFBTSxHQUFNQyxPQUFJLENBQUUsQ0FBQyxFQUFFLFNBQVE7Ozs7RUFLN0MsY0FBZ0JELFFBQU0sRUFBRyxTQUFRO0NBQ3BDLEdBRVkscUJBQXVCRSxRQUFPO0VBQ3ZDLEtBQU9GLFFBQU0sRUFBRyxTQUFRO0NBQzNCLEdBTVksNEJBQThCRSxRQUFPO0VBQzlDLFFBQVVILFFBQU07Q0FDbkIsR0FFSyxvQkFBc0IsWUFBWTs7OztFQUlwQyxlQUFlLG9CQUFvQixTQUFROzs7O0VBSTNDLENBQUMscUJBQXFCLEdBQUcsMEJBQTBCLFNBQVE7Q0FDOUQsR0FLSywwQkFBNEJHLFFBQU87Ozs7RUFJckMsT0FBTyxrQkFBa0IsU0FBUTtDQUNwQyxHQUtZLG1DQUFtQyx3QkFBd0IsT0FBTzs7Ozs7Ozs7O0VBUzNFLE1BQU0sbUJBQW1CLFNBQVE7Q0FDcEMsR0FRWSwrQkFBK0IsQ0FBQyxVQUN6QyxpQ0FBaUMsVUFBVSxLQUFLLEVBQUUsU0FFekMsZ0JBQWtCQSxRQUFPO0VBQ2xDLFFBQVVILFFBQU07RUFDaEIsUUFBUSx3QkFBd0IsTUFBSyxFQUFHLFNBQVE7Q0FDbkQsR0FFSyw0QkFBOEJHLFFBQU87Ozs7O0VBS3ZDLE9BQU8sa0JBQWtCLFNBQVE7Q0FDcEMsR0FFWSxxQkFBdUJBLFFBQU87RUFDdkMsUUFBVUgsUUFBTTtFQUNoQixRQUFRLDBCQUEwQixNQUFLLEVBQUcsU0FBUTtDQUNyRCxHQUVZLGVBQWlCLFlBQVk7Ozs7O0VBS3RDLE9BQU8sa0JBQWtCLFNBQVE7Q0FDcEMsR0FLWSxrQkFBb0IsTUFBTSxDQUFHQSxRQUFNLEdBQU1DLFFBQU0sRUFBRyxJQUFHLENBQUUsQ0FBQyxHQUt4RCx1QkFDUkUsUUFBTztFQUNKLFNBQVcsUUFBUSxlQUFlO0VBQ2xDLElBQUk7RUFDSixHQUFHLGNBQWM7Q0FDcEIsRUFDQSxPQUFNLEdBRUUsbUJBQW1CLENBQUMsVUFBNEMscUJBQXFCLFVBQVUsS0FBSyxFQUFFLFNBS3RHLDRCQUNSQSxRQUFPO0VBQ0osU0FBVyxRQUFRLGVBQWU7RUFDbEMsR0FBRyxtQkFBbUI7Q0FDekIsRUFDQSxPQUFNLEdBRUUsd0JBQXdCLENBQUMsVUFBaUQsMEJBQTBCLFVBQVUsS0FBSyxFQUFFLFNBS3JILDhCQUNSQSxRQUFPO0VBQ0osU0FBVyxRQUFRLGVBQWU7RUFDbEMsSUFBSTtFQUNKLFFBQVE7Q0FDWCxFQUNBLE9BQU0sR0FRRSwwQkFBMEIsQ0FBQyxVQUNwQyw0QkFBNEIsVUFBVSxLQUFLLEVBQUU7QUFZakQsSUFBWTtDQUFaLFNBQVlDLFlBQVM7QUFFakIsRUFBQUEsV0FBQUEsV0FBQSxtQkFBQSxLQUFBLElBQUEsb0JBQ0FBLFdBQUFBLFdBQUEsaUJBQUEsTUFBQSxJQUFBLGtCQUdBQSxXQUFBQSxXQUFBLGFBQUEsTUFBQSxJQUFBLGNBQ0FBLFdBQUFBLFdBQUEsaUJBQUEsTUFBQSxJQUFBLGtCQUNBQSxXQUFBQSxXQUFBLGlCQUFBLE1BQUEsSUFBQSxrQkFDQUEsV0FBQUEsV0FBQSxnQkFBQSxNQUFBLElBQUEsaUJBQ0FBLFdBQUFBLFdBQUEsZ0JBQUEsTUFBQSxJQUFBLGlCQUdBQSxXQUFBQSxXQUFBLHlCQUFBLE1BQUEsSUFBQTtBQUNKLEdBZFksY0FBQSxZQUFTLENBQUEsRUFBQTtBQW1CZCxJQUFNLDZCQUNSQyxRQUFPO0VBQ0osU0FBVyxRQUFRLGVBQWU7RUFDbEMsSUFBSSxnQkFBZ0IsU0FBUTtFQUM1QixPQUFTQSxRQUFPOzs7O0lBSVosTUFBUUMsUUFBTSxFQUFHLElBQUc7Ozs7SUFJcEIsU0FBV0MsUUFBTTs7OztJQUlqQixNQUFRLFFBQU8sRUFBRyxTQUFRO0dBQzdCO0NBQ0osRUFDQSxPQUFNO0FBYUosSUFBTSx5QkFBeUIsQ0FBQyxVQUNuQywyQkFBMkIsVUFBVSxLQUFLLEVBQUU7QUFPekMsSUFBTSx1QkFBeUIsTUFBTTtFQUN4QztFQUNBO0VBQ0E7RUFDQTtDQUNILEdBRVksd0JBQTBCLE1BQU0sQ0FBQyw2QkFBNkIsMEJBQTBCLENBQUMsR0FNekYsb0JBQW9CLGFBQWEsT0FBTSxHQUV2QyxvQ0FBb0MsMEJBQTBCLE9BQU87Ozs7OztFQU05RSxXQUFXLGdCQUFnQixTQUFROzs7O0VBSW5DLFFBQVVDLFFBQU0sRUFBRyxTQUFRO0NBQzlCLEdBV1ksOEJBQThCLG1CQUFtQixPQUFPO0VBQ2pFLFFBQVUsUUFBUSx5QkFBeUI7RUFDM0MsUUFBUTtDQUNYLEdBTVksYUFBZUMsUUFBTzs7OztFQUkvQixLQUFPRCxRQUFNOzs7O0VBSWIsVUFBWUEsUUFBTSxFQUFHLFNBQVE7Ozs7Ozs7RUFPN0IsT0FBUyxNQUFRQSxRQUFNLENBQUUsRUFBRSxTQUFROzs7Ozs7OztFQVFuQyxPQUFTLE1BQUssQ0FBQyxTQUFTLE1BQU0sQ0FBQyxFQUFFLFNBQVE7Q0FDNUMsR0FNWSxjQUFnQkMsUUFBTzs7Ozs7Ozs7Ozs7O0VBWWhDLE9BQVMsTUFBTSxVQUFVLEVBQUUsU0FBUTtDQUN0QyxHQUtZLHFCQUF1QkEsUUFBTzs7RUFFdkMsTUFBUUQsUUFBTTs7Ozs7Ozs7O0VBU2QsT0FBU0EsUUFBTSxFQUFHLFNBQVE7Q0FDN0IsR0FNWSx1QkFBdUIsbUJBQW1CLE9BQU87RUFDMUQsR0FBRyxtQkFBbUI7RUFDdEIsR0FBRyxZQUFZO0VBQ2YsU0FBV0EsUUFBTTs7OztFQUlqQixZQUFjQSxRQUFNLEVBQUcsU0FBUTs7Ozs7Ozs7RUFTL0IsYUFBZUEsUUFBTSxFQUFHLFNBQVE7Q0FDbkMsR0FFSyxrQ0FBb0MsYUFDcENDLFFBQU87RUFDTCxlQUFpQkMsU0FBTyxFQUFHLFNBQVE7Q0FDdEMsR0FDQyxPQUFTRixRQUFNLEdBQU0sUUFBTyxDQUFFLENBQUMsR0FHL0IsOEJBQWdDLFdBQ2xDLFdBQ1EsU0FBUyxPQUFPLFNBQVUsWUFBWSxDQUFDLE1BQU0sUUFBUSxLQUFLLEtBQ3RELE9BQU8sS0FBSyxLQUFnQyxFQUFFLFdBQVcsSUFDbEQsRUFBRSxNQUFNLENBQUEsRUFBRSxJQUdsQixPQUVULGFBQ0lDLFFBQU87RUFDTCxNQUFNLGdDQUFnQyxTQUFRO0VBQzlDLEtBQUssbUJBQW1CLFNBQVE7Q0FDbkMsR0FDQyxPQUFTRCxRQUFNLEdBQU0sUUFBTyxDQUFFLEVBQUUsU0FBUSxDQUFFLENBQy9DLEdBTVEsOEJBQWdDLFlBQVk7Ozs7RUFJckQsTUFBTSxtQkFBbUIsU0FBUTs7OztFQUlqQyxRQUFRLG1CQUFtQixTQUFROzs7O0VBSW5DLFVBQ0ssWUFBWTs7OztJQUlULFVBQ0ssWUFBWTtNQUNULGVBQWUsbUJBQW1CLFNBQVE7S0FDN0MsRUFDQSxTQUFROzs7O0lBSWIsYUFDSyxZQUFZO01BQ1QsUUFBUSxtQkFBbUIsU0FBUTtLQUN0QyxFQUNBLFNBQVE7R0FDaEIsRUFDQSxTQUFRO0NBQ2hCLEdBS1ksOEJBQWdDLFlBQVk7Ozs7RUFJckQsTUFBTSxtQkFBbUIsU0FBUTs7OztFQUlqQyxRQUFRLG1CQUFtQixTQUFROzs7O0VBSW5DLFVBQ0ssWUFBWTs7OztJQUlULE9BQ0ssWUFBWTtNQUNULE1BQU0sbUJBQW1CLFNBQVE7S0FDcEMsRUFDQSxTQUFRO0dBQ2hCLEVBQ0EsU0FBUTtDQUNoQixHQUtZLDJCQUE2QkMsUUFBTzs7OztFQUk3QyxjQUFnQixPQUFTRCxRQUFNLEdBQUksa0JBQWtCLEVBQUUsU0FBUTs7OztFQUkvRCxVQUNLQyxRQUFPOzs7OztJQUtKLFNBQVMsbUJBQW1CLFNBQVE7Ozs7SUFJcEMsT0FBTyxtQkFBbUIsU0FBUTtHQUNyQyxFQUNBLFNBQVE7Ozs7RUFJYixhQUFhLDRCQUE0QixTQUFROzs7O0VBSWpELE9BQ0tBLFFBQU87Ozs7SUFJSixhQUFlQyxTQUFPLEVBQUcsU0FBUTtHQUNwQyxFQUNBLFNBQVE7Ozs7RUFJYixPQUFPLDRCQUE0QixTQUFRO0NBQzlDLEdBRVksZ0NBQWdDLHdCQUF3QixPQUFPOzs7O0VBSXhFLGlCQUFtQkYsUUFBTTtFQUN6QixjQUFjO0VBQ2QsWUFBWTtDQUNmLEdBSVksMEJBQTBCLGNBQWMsT0FBTztFQUN4RCxRQUFVLFFBQVEsWUFBWTtFQUM5QixRQUFRO0NBQ1g7QUFPTSxJQUFNLDJCQUE2QkcsUUFBTzs7OztFQUk3QyxjQUFnQixPQUFTQyxRQUFNLEdBQUksa0JBQWtCLEVBQUUsU0FBUTs7OztFQUkvRCxTQUFTLG1CQUFtQixTQUFROzs7O0VBSXBDLGFBQWEsbUJBQW1CLFNBQVE7Ozs7RUFJeEMsU0FDS0QsUUFBTzs7OztJQUlKLGFBQWVFLFNBQU8sRUFBRyxTQUFRO0dBQ3BDLEVBQ0EsU0FBUTs7OztFQUliLFdBQ0tGLFFBQU87Ozs7SUFJSixXQUFhRSxTQUFPLEVBQUcsU0FBUTs7OztJQUsvQixhQUFlQSxTQUFPLEVBQUcsU0FBUTtHQUNwQyxFQUNBLFNBQVE7Ozs7RUFJYixPQUNLRixRQUFPOzs7O0lBSUosYUFBZUUsU0FBTyxFQUFHLFNBQVE7R0FDcEMsRUFDQSxTQUFROzs7O0VBSWIsT0FBTyw0QkFBNEIsU0FBUTtDQUM5QyxHQUtZLHlCQUF5QixhQUFhLE9BQU87Ozs7RUFJdEQsaUJBQW1CRCxRQUFNO0VBQ3pCLGNBQWM7RUFDZCxZQUFZOzs7Ozs7RUFNWixjQUFnQkEsUUFBTSxFQUFHLFNBQVE7Q0FDcEMsR0FLWSxnQ0FBZ0MsbUJBQW1CLE9BQU87RUFDbkUsUUFBVSxRQUFRLDJCQUEyQjtFQUM3QyxRQUFRLDBCQUEwQixTQUFRO0NBQzdDO0FBU00sSUFBTSxvQkFBb0IsY0FBYyxPQUFPO0VBQ2xELFFBQVUsUUFBUSxNQUFNO0VBQ3hCLFFBQVEsd0JBQXdCLFNBQVE7Q0FDM0MsR0FHWSxpQkFBbUJFLFFBQU87Ozs7RUFJbkMsVUFBWUMsUUFBTTs7OztFQUlsQixPQUFTLFNBQVdBLFFBQU0sQ0FBRTs7OztFQUk1QixTQUFXLFNBQVdDLFFBQU0sQ0FBRTtDQUNqQyxHQUVZLG1DQUFxQ0YsUUFBTztFQUNyRCxHQUFHLDBCQUEwQjtFQUM3QixHQUFHLGVBQWU7Ozs7RUFJbEIsZUFBZTtDQUNsQixHQU1ZLDZCQUE2QixtQkFBbUIsT0FBTztFQUNoRSxRQUFVLFFBQVEsd0JBQXdCO0VBQzFDLFFBQVE7Q0FDWCxHQUVZLCtCQUErQix3QkFBd0IsT0FBTzs7Ozs7RUFLdkUsUUFBUSxhQUFhLFNBQVE7Q0FDaEMsR0FHWSx5QkFBeUIsY0FBYyxPQUFPO0VBQ3ZELFFBQVEsNkJBQTZCLFNBQVE7Q0FDaEQsR0FFWSx3QkFBd0IsYUFBYSxPQUFPOzs7OztFQUtyRCxZQUFZLGFBQWEsU0FBUTtDQUNwQyxHQUtZLG1CQUFxQixNQUFLLENBQUMsV0FBVyxrQkFBa0IsYUFBYSxVQUFVLFdBQVcsQ0FBQyxHQU0zRixhQUFlQSxRQUFPO0VBQy9CLFFBQVVFLFFBQU07RUFDaEIsUUFBUTs7Ozs7RUFLUixLQUFPLE1BQU0sQ0FBR0QsUUFBTSxHQUFNRSxPQUFJLENBQUUsQ0FBQzs7OztFQUluQyxXQUFhRCxRQUFNOzs7O0VBSW5CLGVBQWlCQSxRQUFNO0VBQ3ZCLGNBQWdCLFNBQVdELFFBQU0sQ0FBRTs7OztFQUluQyxlQUFpQixTQUFXQyxRQUFNLENBQUU7Q0FDdkMsR0FLWSx5QkFBeUIsYUFBYSxPQUFPO0VBQ3RELE1BQU07Q0FDVCxHQUtZLHFDQUFxQywwQkFBMEIsTUFBTSxVQUFVLEdBSy9FLCtCQUErQixtQkFBbUIsT0FBTztFQUNsRSxRQUFVLFFBQVEsNEJBQTRCO0VBQzlDLFFBQVE7Q0FDWCxHQUtZLHVCQUF1QixjQUFjLE9BQU87RUFDckQsUUFBVSxRQUFRLFdBQVc7RUFDN0IsUUFBUSx3QkFBd0IsT0FBTztJQUNuQyxRQUFVQSxRQUFNO0dBQ25CO0NBQ0osR0FLWSxzQkFBc0IsYUFBYSxNQUFNLFVBQVUsR0FLbkQsOEJBQThCLGNBQWMsT0FBTztFQUM1RCxRQUFVLFFBQVEsY0FBYztFQUNoQyxRQUFRLHdCQUF3QixPQUFPO0lBQ25DLFFBQVVBLFFBQU07R0FDbkI7Q0FDSixHQVFZLDZCQUE2QixhQUFhLE1BQUssR0FLL0MseUJBQXlCLHVCQUF1QixPQUFPO0VBQ2hFLFFBQVUsUUFBUSxZQUFZO0NBQ2pDLEdBS1ksd0JBQXdCLHNCQUFzQixPQUFPO0VBQzlELE9BQVMsTUFBTSxVQUFVO0NBQzVCLEdBS1ksMEJBQTBCLGNBQWMsT0FBTztFQUN4RCxRQUFVLFFBQVEsY0FBYztFQUNoQyxRQUFRLHdCQUF3QixPQUFPO0lBQ25DLFFBQVVBLFFBQU07R0FDbkI7Q0FDSixHQUtZLHlCQUF5QixhQUFhLE1BQU0sVUFBVSxHQU10RCx5QkFBMkJGLFFBQU87Ozs7RUFJM0MsS0FBT0UsUUFBTTs7OztFQUliLFVBQVksU0FBV0EsUUFBTSxDQUFFOzs7OztFQUsvQixPQUFTLE9BQVNBLFFBQU0sR0FBTSxRQUFPLENBQUUsRUFBRSxTQUFRO0NBQ3BELEdBRVksNkJBQTZCLHVCQUF1QixPQUFPOzs7O0VBSXBFLE1BQVFBLFFBQU07Q0FDakIsR0FPSyxlQUFpQkEsUUFBTSxFQUFHLE9BQzVCLFNBQU07QUFDRixNQUFJO0FBR0EsZ0JBQUssR0FBRyxHQUNEO0VBQ1gsUUFBUTtBQUNKLFdBQU87RUFDWDtBQUNKLEdBQ0EsRUFBRSxTQUFTLHdCQUF1QixDQUFFLEdBRzNCLDZCQUE2Qix1QkFBdUIsT0FBTzs7OztFQUlwRSxNQUFNO0NBQ1QsR0FLWSxhQUFlLE1BQUssQ0FBQyxRQUFRLFdBQVcsQ0FBQyxHQUt6QyxvQkFBc0JGLFFBQU87Ozs7RUFJdEMsVUFBWSxNQUFNLFVBQVUsRUFBRSxTQUFROzs7O0VBS3RDLFVBQVlDLFFBQU0sRUFBRyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxTQUFROzs7O0VBSzNDLGNBQWdCRyxhQUFJLFNBQVMsRUFBRSxRQUFRLEdBQUksQ0FBRSxFQUFFLFNBQVE7Q0FDMUQsR0FLWSxpQkFBbUJKLFFBQU87RUFDbkMsR0FBRyxtQkFBbUI7RUFDdEIsR0FBRyxZQUFZOzs7O0VBSWYsS0FBT0UsUUFBTTs7Ozs7O0VBT2IsYUFBZSxTQUFXQSxRQUFNLENBQUU7Ozs7RUFLbEMsVUFBWSxTQUFXQSxRQUFNLENBQUU7Ozs7RUFLL0IsYUFBYSxrQkFBa0IsU0FBUTs7Ozs7RUFNdkMsT0FBUyxTQUFXLFlBQVksQ0FBQSxDQUFFLENBQUM7Q0FDdEMsR0FLWSx5QkFBMkJGLFFBQU87RUFDM0MsR0FBRyxtQkFBbUI7RUFDdEIsR0FBRyxZQUFZOzs7O0VBSWYsYUFBZUUsUUFBTTs7Ozs7O0VBT3JCLGFBQWUsU0FBV0EsUUFBTSxDQUFFOzs7O0VBS2xDLFVBQVksU0FBV0EsUUFBTSxDQUFFOzs7O0VBSy9CLGFBQWEsa0JBQWtCLFNBQVE7Ozs7O0VBTXZDLE9BQVMsU0FBVyxZQUFZLENBQUEsQ0FBRSxDQUFDO0NBQ3RDLEdBS1ksNkJBQTZCLHVCQUF1QixPQUFPO0VBQ3BFLFFBQVUsUUFBUSxnQkFBZ0I7Q0FDckMsR0FLWSw0QkFBNEIsc0JBQXNCLE9BQU87RUFDbEUsV0FBYSxNQUFNLGNBQWM7Q0FDcEMsR0FLWSxxQ0FBcUMsdUJBQXVCLE9BQU87RUFDNUUsUUFBVSxRQUFRLDBCQUEwQjtDQUMvQyxHQUtZLG9DQUFvQyxzQkFBc0IsT0FBTztFQUMxRSxtQkFBcUIsTUFBTSxzQkFBc0I7Q0FDcEQsR0FFWSw4QkFBOEIsd0JBQXdCLE9BQU87Ozs7OztFQU10RSxLQUFPQSxRQUFNO0NBQ2hCLEdBS1ksa0NBQWtDLDZCQUtsQyw0QkFBNEIsY0FBYyxPQUFPO0VBQzFELFFBQVUsUUFBUSxnQkFBZ0I7RUFDbEMsUUFBUTtDQUNYLEdBS1ksMkJBQTJCLGFBQWEsT0FBTztFQUN4RCxVQUFZLE1BQVEsTUFBTSxDQUFDLDRCQUE0QiwwQkFBMEIsQ0FBQyxDQUFDO0NBQ3RGLEdBS1ksd0NBQXdDLG1CQUFtQixPQUFPO0VBQzNFLFFBQVUsUUFBUSxzQ0FBc0M7RUFDeEQsUUFBUSwwQkFBMEIsU0FBUTtDQUM3QyxHQUVZLCtCQUErQiw2QkFJL0IseUJBQXlCLGNBQWMsT0FBTztFQUN2RCxRQUFVLFFBQVEscUJBQXFCO0VBQ3ZDLFFBQVE7Q0FDWCxHQUVZLGlDQUFpQyw2QkFJakMsMkJBQTJCLGNBQWMsT0FBTztFQUN6RCxRQUFVLFFBQVEsdUJBQXVCO0VBQ3pDLFFBQVE7Q0FDWCxHQUtZLDBDQUEwQywwQkFBMEIsT0FBTzs7OztFQUlwRixLQUFPQSxRQUFNO0NBQ2hCLEdBS1ksb0NBQW9DLG1CQUFtQixPQUFPO0VBQ3ZFLFFBQVUsUUFBUSxpQ0FBaUM7RUFDbkQsUUFBUTtDQUNYLEdBTVksdUJBQXlCRixRQUFPOzs7O0VBSXpDLE1BQVFFLFFBQU07Ozs7RUFJZCxhQUFlLFNBQVdBLFFBQU0sQ0FBRTs7OztFQUlsQyxVQUFZLFNBQVdHLFNBQU8sQ0FBRTtDQUNuQyxHQUtZLGVBQWlCTCxRQUFPO0VBQ2pDLEdBQUcsbUJBQW1CO0VBQ3RCLEdBQUcsWUFBWTs7OztFQUlmLGFBQWUsU0FBV0UsUUFBTSxDQUFFOzs7O0VBSWxDLFdBQWEsU0FBVyxNQUFNLG9CQUFvQixDQUFDOzs7OztFQUtuRCxPQUFTLFNBQVcsWUFBWSxDQUFBLENBQUUsQ0FBQztDQUN0QyxHQUtZLDJCQUEyQix1QkFBdUIsT0FBTztFQUNsRSxRQUFVLFFBQVEsY0FBYztDQUNuQyxHQUtZLDBCQUEwQixzQkFBc0IsT0FBTztFQUNoRSxTQUFXLE1BQU0sWUFBWTtDQUNoQyxHQUtZLCtCQUErQix3QkFBd0IsT0FBTzs7OztFQUl2RSxNQUFRQSxRQUFNOzs7O0VBSWQsV0FBYSxPQUFTQSxRQUFNLEdBQU1BLFFBQU0sQ0FBRSxFQUFFLFNBQVE7Q0FDdkQsR0FJWSx5QkFBeUIsY0FBYyxPQUFPO0VBQ3ZELFFBQVUsUUFBUSxhQUFhO0VBQy9CLFFBQVE7Q0FDWCxHQUtZLG9CQUFzQkYsUUFBTztFQUN0QyxNQUFRLFFBQVEsTUFBTTs7OztFQUl0QixNQUFRRSxRQUFNOzs7O0VBS2QsYUFBYSxrQkFBa0IsU0FBUTs7Ozs7RUFNdkMsT0FBUyxPQUFTQSxRQUFNLEdBQU0sUUFBTyxDQUFFLEVBQUUsU0FBUTtDQUNwRCxHQUtZLHFCQUF1QkYsUUFBTztFQUN2QyxNQUFRLFFBQVEsT0FBTzs7OztFQUl2QixNQUFNOzs7O0VBSU4sVUFBWUUsUUFBTTs7OztFQUtsQixhQUFhLGtCQUFrQixTQUFROzs7OztFQU12QyxPQUFTLE9BQVNBLFFBQU0sR0FBTSxRQUFPLENBQUUsRUFBRSxTQUFRO0NBQ3BELEdBS1kscUJBQXVCRixRQUFPO0VBQ3ZDLE1BQVEsUUFBUSxPQUFPOzs7O0VBSXZCLE1BQU07Ozs7RUFJTixVQUFZRSxRQUFNOzs7O0VBS2xCLGFBQWEsa0JBQWtCLFNBQVE7Ozs7O0VBTXZDLE9BQVMsT0FBU0EsUUFBTSxHQUFNLFFBQU8sQ0FBRSxFQUFFLFNBQVE7Q0FDcEQsR0FNWSx1QkFBeUJGLFFBQU87RUFDekMsTUFBUSxRQUFRLFVBQVU7Ozs7O0VBSzFCLE1BQVFFLFFBQU07Ozs7O0VBS2QsSUFBTUEsUUFBTTs7Ozs7RUFLWixPQUFTLE9BQVNBLFFBQU0sR0FBTSxRQUFPLENBQUU7Ozs7O0VBS3ZDLE9BQVMsT0FBU0EsUUFBTSxHQUFNLFFBQU8sQ0FBRSxFQUFFLFNBQVE7Q0FDcEQsR0FLWSx5QkFBMkJGLFFBQU87RUFDM0MsTUFBUSxRQUFRLFVBQVU7RUFDMUIsVUFBWSxNQUFNLENBQUMsNEJBQTRCLDBCQUEwQixDQUFDOzs7O0VBSTFFLGFBQWEsa0JBQWtCLFNBQVE7Ozs7O0VBS3ZDLE9BQVMsT0FBU0UsUUFBTSxHQUFNLFFBQU8sQ0FBRSxFQUFFLFNBQVE7Q0FDcEQsR0FPWSxxQkFBcUIsZUFBZSxPQUFPO0VBQ3BELE1BQVEsUUFBUSxlQUFlO0NBQ2xDLEdBS1kscUJBQXVCLE1BQU07RUFDdEM7RUFDQTtFQUNBO0VBQ0E7RUFDQTtDQUNILEdBS1ksc0JBQXdCRixRQUFPO0VBQ3hDLE1BQU07RUFDTixTQUFTO0NBQ1osR0FLWSx3QkFBd0IsYUFBYSxPQUFPOzs7O0VBSXJELGFBQWVFLFFBQU0sRUFBRyxTQUFRO0VBQ2hDLFVBQVksTUFBTSxtQkFBbUI7Q0FDeEMsR0FLWSxzQ0FBc0MsbUJBQW1CLE9BQU87RUFDekUsUUFBVSxRQUFRLG9DQUFvQztFQUN0RCxRQUFRLDBCQUEwQixTQUFRO0NBQzdDLEdBYVksd0JBQTBCRixRQUFPOzs7O0VBSTFDLE9BQVNFLFFBQU0sRUFBRyxTQUFROzs7Ozs7RUFPMUIsY0FBZ0JHLFNBQU8sRUFBRyxTQUFROzs7Ozs7Ozs7RUFVbEMsaUJBQW1CQSxTQUFPLEVBQUcsU0FBUTs7Ozs7Ozs7O0VBVXJDLGdCQUFrQkEsU0FBTyxFQUFHLFNBQVE7Ozs7Ozs7OztFQVVwQyxlQUFpQkEsU0FBTyxFQUFHLFNBQVE7Q0FDdEMsR0FLWSxzQkFBd0JMLFFBQU87Ozs7Ozs7OztFQVN4QyxhQUFlLE1BQUssQ0FBQyxZQUFZLFlBQVksV0FBVyxDQUFDLEVBQUUsU0FBUTtDQUN0RSxHQUtZLGFBQWVBLFFBQU87RUFDL0IsR0FBRyxtQkFBbUI7RUFDdEIsR0FBRyxZQUFZOzs7O0VBSWYsYUFBZUUsUUFBTSxFQUFHLFNBQVE7Ozs7O0VBS2hDLGFBQ0tGLFFBQU87SUFDSixNQUFRLFFBQVEsUUFBUTtJQUN4QixZQUFjLE9BQVNFLFFBQU0sR0FBSSxrQkFBa0IsRUFBRSxTQUFRO0lBQzdELFVBQVksTUFBUUEsUUFBTSxDQUFFLEVBQUUsU0FBUTtHQUN6QyxFQUNBLFNBQVcsUUFBTyxDQUFFOzs7Ozs7RUFNekIsY0FDS0YsUUFBTztJQUNKLE1BQVEsUUFBUSxRQUFRO0lBQ3hCLFlBQWMsT0FBU0UsUUFBTSxHQUFJLGtCQUFrQixFQUFFLFNBQVE7SUFDN0QsVUFBWSxNQUFRQSxRQUFNLENBQUUsRUFBRSxTQUFRO0dBQ3pDLEVBQ0EsU0FBVyxRQUFPLENBQUUsRUFDcEIsU0FBUTs7OztFQUliLGFBQWEsc0JBQXNCLFNBQVE7Ozs7RUFJM0MsV0FBVyxvQkFBb0IsU0FBUTs7Ozs7RUFNdkMsT0FBUyxPQUFTQSxRQUFNLEdBQU0sUUFBTyxDQUFFLEVBQUUsU0FBUTtDQUNwRCxHQUtZLHlCQUF5Qix1QkFBdUIsT0FBTztFQUNoRSxRQUFVLFFBQVEsWUFBWTtDQUNqQyxHQUtZLHdCQUF3QixzQkFBc0IsT0FBTztFQUM5RCxPQUFTLE1BQU0sVUFBVTtDQUM1QixHQUtZLHVCQUF1QixhQUFhLE9BQU87Ozs7Ozs7RUFPcEQsU0FBVyxNQUFNLGtCQUFrQixFQUFFLFFBQVEsQ0FBQSxDQUFFOzs7Ozs7RUFPL0MsbUJBQXFCLE9BQVNBLFFBQU0sR0FBTSxRQUFPLENBQUUsRUFBRSxTQUFROzs7Ozs7Ozs7Ozs7Ozs7RUFnQjdELFNBQVdHLFNBQU8sRUFBRyxTQUFRO0NBQ2hDLEdBS1ksb0NBQW9DLHFCQUFxQixHQUNsRSxhQUFhLE9BQU87RUFDaEIsWUFBYyxRQUFPO0NBQ3hCLENBQUMsR0FNTyw4QkFBOEIsaUNBQWlDLE9BQU87Ozs7RUFJL0UsTUFBUUgsUUFBTTs7OztFQUlkLFdBQWEsT0FBU0EsUUFBTSxHQUFNLFFBQU8sQ0FBRSxFQUFFLFNBQVE7Q0FDeEQsR0FLWSx3QkFBd0IsY0FBYyxPQUFPO0VBQ3RELFFBQVUsUUFBUSxZQUFZO0VBQzlCLFFBQVE7Q0FDWCxHQUtZLG9DQUFvQyxtQkFBbUIsT0FBTztFQUN2RSxRQUFVLFFBQVEsa0NBQWtDO0VBQ3BELFFBQVEsMEJBQTBCLFNBQVE7Q0FDN0MsR0FXWSwrQkFBaUNGLFFBQU87Ozs7Ozs7OztFQVNqRCxhQUFlSyxTQUFPLEVBQUcsUUFBUSxFQUFJOzs7Ozs7Ozs7RUFTckMsWUFBY0osUUFBTSxFQUFHLElBQUcsRUFBRyxZQUFXLEVBQUcsUUFBUSxHQUFHO0NBQ3pELEdBd0RZLHFCQUF1QixNQUFLLENBQUMsU0FBUyxRQUFRLFVBQVUsV0FBVyxTQUFTLFlBQVksU0FBUyxXQUFXLENBQUMsR0FLN0csOEJBQThCLHdCQUF3QixPQUFPOzs7O0VBSXRFLE9BQU87Q0FDVixHQUlZLHdCQUF3QixjQUFjLE9BQU87RUFDdEQsUUFBVSxRQUFRLGtCQUFrQjtFQUNwQyxRQUFRO0NBQ1gsR0FLWSx5Q0FBeUMsMEJBQTBCLE9BQU87Ozs7RUFJbkYsT0FBTzs7OztFQUlQLFFBQVVDLFFBQU0sRUFBRyxTQUFROzs7O0VBSTNCLE1BQVEsUUFBTztDQUNsQixHQUlZLG1DQUFtQyxtQkFBbUIsT0FBTztFQUN0RSxRQUFVLFFBQVEsdUJBQXVCO0VBQ3pDLFFBQVE7Q0FDWCxHQU1ZLGtCQUFvQkYsUUFBTzs7OztFQUlwQyxNQUFRRSxRQUFNLEVBQUcsU0FBUTtDQUM1QixHQUtZLHlCQUEyQkYsUUFBTzs7OztFQUkzQyxPQUFTLE1BQU0sZUFBZSxFQUFFLFNBQVE7Ozs7RUFJeEMsY0FBZ0JDLFFBQU0sRUFBRyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxTQUFROzs7O0VBSS9DLGVBQWlCQSxRQUFNLEVBQUcsSUFBSSxDQUFDLEVBQUUsSUFBSSxDQUFDLEVBQUUsU0FBUTs7OztFQUloRCxzQkFBd0JBLFFBQU0sRUFBRyxJQUFJLENBQUMsRUFBRSxJQUFJLENBQUMsRUFBRSxTQUFRO0NBQzFELEdBS1ksbUJBQXFCRCxRQUFPOzs7Ozs7O0VBT3JDLE1BQVEsTUFBSyxDQUFDLFFBQVEsWUFBWSxNQUFNLENBQUMsRUFBRSxTQUFRO0NBQ3RELEdBTVksMEJBQTRCQSxRQUFPO0VBQzVDLE1BQVEsUUFBUSxhQUFhO0VBQzdCLFdBQWFFLFFBQU0sRUFBRyxTQUFTLHdEQUF3RDtFQUN2RixTQUFXLE1BQU0sa0JBQWtCLEVBQUUsUUFBUSxDQUFBLENBQUU7RUFDL0MsbUJBQXFCRixRQUFPLENBQUEsQ0FBRSxFQUFFLE1BQUssRUFBRyxTQUFRO0VBQ2hELFNBQVdLLFNBQU8sRUFBRyxTQUFROzs7OztFQU03QixPQUFTLE9BQVNILFFBQU0sR0FBTSxRQUFPLENBQUUsRUFBRSxTQUFRO0NBQ3BELEdBTVksd0JBQTBCLG1CQUFtQixRQUFRLENBQUMsbUJBQW1CLG9CQUFvQixrQkFBa0IsQ0FBQyxHQU1oSCxvQ0FBc0MsbUJBQW1CLFFBQVE7RUFDMUU7RUFDQTtFQUNBO0VBQ0E7RUFDQTtDQUNILEdBS1ksd0JBQTBCRixRQUFPO0VBQzFDLE1BQU07RUFDTixTQUFXLE1BQU0sQ0FBQyxtQ0FBcUMsTUFBTSxpQ0FBaUMsQ0FBQyxDQUFDOzs7OztFQUtoRyxPQUFTLE9BQVNFLFFBQU0sR0FBTSxRQUFPLENBQUUsRUFBRSxTQUFRO0NBQ3BELEdBS1ksbUNBQW1DLGlDQUFpQyxPQUFPO0VBQ3BGLFVBQVksTUFBTSxxQkFBcUI7Ozs7RUFJdkMsa0JBQWtCLHVCQUF1QixTQUFROzs7O0VBSWpELGNBQWdCQSxRQUFNLEVBQUcsU0FBUTs7Ozs7Ozs7RUFRakMsZ0JBQWtCLE1BQUssQ0FBQyxRQUFRLGNBQWMsWUFBWSxDQUFDLEVBQUUsU0FBUTtFQUNyRSxhQUFlRCxRQUFNLEVBQUcsU0FBUTs7Ozs7O0VBTWhDLFdBQWFBLFFBQU0sRUFBRyxJQUFHO0VBQ3pCLGVBQWlCLE1BQVFDLFFBQU0sQ0FBRSxFQUFFLFNBQVE7Ozs7RUFJM0MsVUFBVSxtQkFBbUIsU0FBUTs7Ozs7RUFLckMsT0FBUyxNQUFNLFVBQVUsRUFBRSxTQUFROzs7Ozs7RUFNbkMsWUFBWSxpQkFBaUIsU0FBUTtDQUN4QyxHQUlZLDZCQUE2QixjQUFjLE9BQU87RUFDM0QsUUFBVSxRQUFRLHdCQUF3QjtFQUMxQyxRQUFRO0NBQ1gsR0FPWSw0QkFBNEIsYUFBYSxPQUFPOzs7O0VBSXpELE9BQVNBLFFBQU07Ozs7Ozs7Ozs7O0VBV2YsWUFBYyxTQUFXLE1BQUssQ0FBQyxXQUFXLGdCQUFnQixXQUFXLENBQUMsRUFBRSxHQUFLQSxRQUFNLENBQUUsQ0FBQztFQUN0RixNQUFNOzs7O0VBSU4sU0FBUztDQUNaLEdBTVkscUNBQXFDLGFBQWEsT0FBTzs7OztFQUlsRSxPQUFTQSxRQUFNOzs7Ozs7Ozs7Ozs7RUFZZixZQUFjLFNBQVcsTUFBSyxDQUFDLFdBQVcsZ0JBQWdCLGFBQWEsU0FBUyxDQUFDLEVBQUUsR0FBS0EsUUFBTSxDQUFFLENBQUM7RUFDakcsTUFBTTs7OztFQUlOLFNBQVcsTUFBTSxDQUFDLG1DQUFxQyxNQUFNLGlDQUFpQyxDQUFDLENBQUM7Q0FDbkcsR0FNWSxzQkFBd0JGLFFBQU87RUFDeEMsTUFBUSxRQUFRLFNBQVM7RUFDekIsT0FBU0UsUUFBTSxFQUFHLFNBQVE7RUFDMUIsYUFBZUEsUUFBTSxFQUFHLFNBQVE7RUFDaEMsU0FBV0csU0FBTyxFQUFHLFNBQVE7Q0FDaEMsR0FLWSxxQkFBdUJMLFFBQU87RUFDdkMsTUFBUSxRQUFRLFFBQVE7RUFDeEIsT0FBU0UsUUFBTSxFQUFHLFNBQVE7RUFDMUIsYUFBZUEsUUFBTSxFQUFHLFNBQVE7RUFDaEMsV0FBYUQsUUFBTSxFQUFHLFNBQVE7RUFDOUIsV0FBYUEsUUFBTSxFQUFHLFNBQVE7RUFDOUIsUUFBVSxNQUFLLENBQUMsU0FBUyxPQUFPLFFBQVEsV0FBVyxDQUFDLEVBQUUsU0FBUTtFQUM5RCxTQUFXQyxRQUFNLEVBQUcsU0FBUTtDQUMvQixHQUtZLHFCQUF1QkYsUUFBTztFQUN2QyxNQUFRLE1BQUssQ0FBQyxVQUFVLFNBQVMsQ0FBQztFQUNsQyxPQUFTRSxRQUFNLEVBQUcsU0FBUTtFQUMxQixhQUFlQSxRQUFNLEVBQUcsU0FBUTtFQUNoQyxTQUFXRCxRQUFNLEVBQUcsU0FBUTtFQUM1QixTQUFXQSxRQUFNLEVBQUcsU0FBUTtFQUM1QixTQUFXQSxRQUFNLEVBQUcsU0FBUTtDQUMvQixHQUtZLHVDQUF5Q0QsUUFBTztFQUN6RCxNQUFRLFFBQVEsUUFBUTtFQUN4QixPQUFTRSxRQUFNLEVBQUcsU0FBUTtFQUMxQixhQUFlQSxRQUFNLEVBQUcsU0FBUTtFQUNoQyxNQUFRLE1BQVFBLFFBQU0sQ0FBRTtFQUN4QixTQUFXQSxRQUFNLEVBQUcsU0FBUTtDQUMvQixHQUtZLHFDQUF1Q0YsUUFBTztFQUN2RCxNQUFRLFFBQVEsUUFBUTtFQUN4QixPQUFTRSxRQUFNLEVBQUcsU0FBUTtFQUMxQixhQUFlQSxRQUFNLEVBQUcsU0FBUTtFQUNoQyxPQUFTLE1BQ0hGLFFBQU87SUFDTCxPQUFTRSxRQUFNO0lBQ2YsT0FBU0EsUUFBTTtHQUNsQixDQUFDO0VBRU4sU0FBV0EsUUFBTSxFQUFHLFNBQVE7Q0FDL0IsR0FNWSwrQkFBaUNGLFFBQU87RUFDakQsTUFBUSxRQUFRLFFBQVE7RUFDeEIsT0FBU0UsUUFBTSxFQUFHLFNBQVE7RUFDMUIsYUFBZUEsUUFBTSxFQUFHLFNBQVE7RUFDaEMsTUFBUSxNQUFRQSxRQUFNLENBQUU7RUFDeEIsV0FBYSxNQUFRQSxRQUFNLENBQUUsRUFBRSxTQUFRO0VBQ3ZDLFNBQVdBLFFBQU0sRUFBRyxTQUFRO0NBQy9CLEdBR1ksK0JBQWlDLE1BQU0sQ0FBQyxzQ0FBc0Msa0NBQWtDLENBQUMsR0FLakgsc0NBQXdDRixRQUFPO0VBQ3hELE1BQVEsUUFBUSxPQUFPO0VBQ3ZCLE9BQVNFLFFBQU0sRUFBRyxTQUFRO0VBQzFCLGFBQWVBLFFBQU0sRUFBRyxTQUFRO0VBQ2hDLFVBQVlELFFBQU0sRUFBRyxTQUFRO0VBQzdCLFVBQVlBLFFBQU0sRUFBRyxTQUFRO0VBQzdCLE9BQVNELFFBQU87SUFDWixNQUFRLFFBQVEsUUFBUTtJQUN4QixNQUFRLE1BQVFFLFFBQU0sQ0FBRTtHQUMzQjtFQUNELFNBQVcsTUFBUUEsUUFBTSxDQUFFLEVBQUUsU0FBUTtDQUN4QyxHQUtZLG9DQUFzQ0YsUUFBTztFQUN0RCxNQUFRLFFBQVEsT0FBTztFQUN2QixPQUFTRSxRQUFNLEVBQUcsU0FBUTtFQUMxQixhQUFlQSxRQUFNLEVBQUcsU0FBUTtFQUNoQyxVQUFZRCxRQUFNLEVBQUcsU0FBUTtFQUM3QixVQUFZQSxRQUFNLEVBQUcsU0FBUTtFQUM3QixPQUFTRCxRQUFPO0lBQ1osT0FBUyxNQUNIQSxRQUFPO01BQ0wsT0FBU0UsUUFBTTtNQUNmLE9BQVNBLFFBQU07S0FDbEIsQ0FBQztHQUVUO0VBQ0QsU0FBVyxNQUFRQSxRQUFNLENBQUUsRUFBRSxTQUFRO0NBQ3hDLEdBS1ksOEJBQWdDLE1BQU0sQ0FBQyxxQ0FBcUMsaUNBQWlDLENBQUMsR0FLOUcsbUJBQXFCLE1BQU0sQ0FBQyw4QkFBOEIsOEJBQThCLDJCQUEyQixDQUFDLEdBS3BILGtDQUFvQyxNQUFNLENBQUMsa0JBQWtCLHFCQUFxQixvQkFBb0Isa0JBQWtCLENBQUMsR0FLekgsZ0NBQWdDLGlDQUFpQyxPQUFPOzs7Ozs7RUFNakYsTUFBUSxRQUFRLE1BQU0sRUFBRSxTQUFROzs7O0VBSWhDLFNBQVdBLFFBQU07Ozs7O0VBS2pCLGlCQUFtQkYsUUFBTztJQUN0QixNQUFRLFFBQVEsUUFBUTtJQUN4QixZQUFjLE9BQVNFLFFBQU0sR0FBSSwrQkFBK0I7SUFDaEUsVUFBWSxNQUFRQSxRQUFNLENBQUUsRUFBRSxTQUFRO0dBQ3pDO0NBQ0osR0FLWSwrQkFBK0IsaUNBQWlDLE9BQU87Ozs7RUFJaEYsTUFBUSxRQUFRLEtBQUs7Ozs7RUFJckIsU0FBV0EsUUFBTTs7Ozs7RUFLakIsZUFBaUJBLFFBQU07Ozs7RUFJdkIsS0FBT0EsUUFBTSxFQUFHLElBQUc7Q0FDdEIsR0FLWSw0QkFBOEIsTUFBTSxDQUFDLCtCQUErQiw0QkFBNEIsQ0FBQyxHQU9qRyxzQkFBc0IsY0FBYyxPQUFPO0VBQ3BELFFBQVUsUUFBUSxvQkFBb0I7RUFDdEMsUUFBUTtDQUNYLEdBT1ksOENBQThDLDBCQUEwQixPQUFPOzs7O0VBSXhGLGVBQWlCQSxRQUFNO0NBQzFCLEdBT1ksd0NBQXdDLG1CQUFtQixPQUFPO0VBQzNFLFFBQVUsUUFBUSxvQ0FBb0M7RUFDdEQsUUFBUTtDQUNYLEdBS1kscUJBQXFCLGFBQWEsT0FBTzs7Ozs7OztFQU9sRCxRQUFVLE1BQUssQ0FBQyxVQUFVLFdBQVcsUUFBUSxDQUFDOzs7Ozs7O0VBTzlDLFNBQVcsV0FDUCxTQUFRLFFBQVEsT0FBTyxTQUFZLEtBQ2pDLE9BQVNBLFFBQU0sR0FBTSxNQUFNLENBQUdBLFFBQU0sR0FBTUQsUUFBTSxHQUFNSSxTQUFPLEdBQU0sTUFBUUgsUUFBTSxDQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsU0FBUSxDQUFFO0NBRTNHLEdBTVksa0NBQW9DRixRQUFPO0VBQ3BELE1BQVEsUUFBUSxjQUFjOzs7O0VBSTlCLEtBQU9FLFFBQU07Q0FDaEI7QUFVTSxJQUFNLHdCQUEwQkksUUFBTztFQUMxQyxNQUFRLFFBQVEsWUFBWTs7OztFQUk1QixNQUFRQyxRQUFNO0NBQ2pCLEdBS1ksOEJBQThCLHdCQUF3QixPQUFPO0VBQ3RFLEtBQU8sTUFBTSxDQUFDLHVCQUF1QiwrQkFBK0IsQ0FBQzs7OztFQUlyRSxVQUFZRCxRQUFPOzs7O0lBSWYsTUFBUUMsUUFBTTs7OztJQUlkLE9BQVNBLFFBQU07R0FDbEI7RUFDRCxTQUNLRCxRQUFPOzs7O0lBSUosV0FBYSxPQUFTQyxRQUFNLEdBQU1BLFFBQU0sQ0FBRSxFQUFFLFNBQVE7R0FDdkQsRUFDQSxTQUFRO0NBQ2hCLEdBSVksd0JBQXdCLGNBQWMsT0FBTztFQUN0RCxRQUFVLFFBQVEscUJBQXFCO0VBQ3ZDLFFBQVE7Q0FDWDtBQW1CTSxJQUFNLHVCQUF1QixhQUFhLE9BQU87RUFDcEQsWUFBYyxZQUFZOzs7O0lBSXRCLFFBQVUsTUFBUUMsUUFBTSxDQUFFLEVBQUUsSUFBSSxHQUFHOzs7O0lBSW5DLE9BQVMsU0FBV0MsUUFBTSxFQUFHLElBQUcsQ0FBRTs7OztJQUlsQyxTQUFXLFNBQVdDLFNBQU8sQ0FBRTtHQUNsQztDQUNKLEdBTVksYUFBZUMsUUFBTzs7OztFQUkvQixLQUFPSCxRQUFNLEVBQUcsV0FBVyxTQUFTOzs7O0VBSXBDLE1BQVFBLFFBQU0sRUFBRyxTQUFROzs7OztFQU16QixPQUFTLE9BQVNBLFFBQU0sR0FBTSxRQUFPLENBQUUsRUFBRSxTQUFRO0NBQ3BELEdBS1kseUJBQXlCLGNBQWMsT0FBTztFQUN2RCxRQUFVLFFBQVEsWUFBWTtFQUM5QixRQUFRLHdCQUF3QixTQUFRO0NBQzNDLEdBS1ksd0JBQXdCLGFBQWEsT0FBTztFQUNyRCxPQUFTLE1BQU0sVUFBVTtDQUM1QixHQUtZLHFDQUFxQyxtQkFBbUIsT0FBTztFQUN4RSxRQUFVLFFBQVEsa0NBQWtDO0VBQ3BELFFBQVEsMEJBQTBCLFNBQVE7Q0FDN0MsR0FHWSxzQkFBd0IsTUFBTTtFQUN2QztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0NBQ0gsR0FFWSwyQkFBNkIsTUFBTTtFQUM1QztFQUNBO0VBQ0E7RUFDQTtFQUNBO0NBQ0gsR0FFWSxxQkFBdUIsTUFBTTtFQUN0QztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0NBQ0gsR0FHWSxzQkFBd0IsTUFBTTtFQUN2QztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0NBQ0gsR0FFWSwyQkFBNkIsTUFBTTtFQUM1QztFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7Q0FDSCxHQUVZLHFCQUF1QixNQUFNO0VBQ3RDO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7RUFDQTtFQUNBO0NBQ0gsR0FFWSxXQUFQLE1BQU8sa0JBQWlCLE1BQUs7RUFDL0IsWUFDb0IsTUFDaEIsU0FDZ0IsTUFBYztBQUU5QixVQUFNLGFBQWEsSUFBSSxLQUFLLE9BQU8sRUFBRSxHQUpyQixLQUFBLE9BQUEsTUFFQSxLQUFBLE9BQUEsTUFHaEIsS0FBSyxPQUFPO0VBQ2hCOzs7O0VBS0EsT0FBTyxVQUFVLE1BQWMsU0FBaUIsTUFBYztBQUUxRCxRQUFJLFNBQVMsVUFBVSwwQkFBMEIsTUFBTTtBQUNuRCxVQUFNLFlBQVk7QUFDbEIsVUFBSSxVQUFVO0FBQ1YsZUFBTyxJQUFJLDRCQUE0QixVQUFVLGNBQTBDLE9BQU87SUFFMUc7QUFHQSxXQUFPLElBQUksVUFBUyxNQUFNLFNBQVMsSUFBSTtFQUMzQztHQU9TLDhCQUFQLGNBQTJDLFNBQVE7RUFDckQsWUFBWSxjQUF3QyxVQUFrQixrQkFBa0IsYUFBYSxTQUFTLElBQUksTUFBTSxFQUFFLGFBQVc7QUFDakksVUFBTSxVQUFVLHdCQUF3QixTQUFTO01BQzdDO0tBQ0g7RUFDTDtFQUVBLElBQUksZUFBWTtBQUNaLFdBQVEsS0FBSyxNQUFxRCxnQkFBZ0IsQ0FBQTtFQUN0Rjs7OztBQzkvREUsU0FBVSxXQUFXLFFBQXNCO0FBQzdDLFNBQU8sV0FBVyxlQUFlLFdBQVcsWUFBWSxXQUFXO0FBQ3ZFOzs7QUNoU08sSUFBTSxpQkFBaUIsT0FBTyxtREFBbUQ7OztBQ3FNeEYsSUFBTSxnQkFBZ0IsSUFBSSxJQUFJLDhEQUE4RDs7O0FDdkp0RixTQUFVLGlCQUFpQixRQUF1QjtBQUVwRCxNQUFNLGVBRFEsZUFBZSxNQUFNLEdBQ1A7QUFDNUIsTUFBSSxDQUFDO0FBQ0QsVUFBTSxJQUFJLE1BQU0sb0NBQW9DO0FBR3hELE1BQU0sUUFBUSxnQkFBZ0IsWUFBWTtBQUMxQyxNQUFJLE9BQU8sU0FBVTtBQUNqQixVQUFNLElBQUksTUFBTSx3Q0FBd0M7QUFHNUQsU0FBTztBQUNYO0FBRU0sU0FBVSxnQkFBZ0IsUUFBbUIsTUFBYTtBQUM1RCxNQUFNLFNBQVNJLFdBQVUsUUFBUSxJQUFJO0FBQ3JDLE1BQUksQ0FBQyxPQUFPO0FBQ1IsVUFBTSxPQUFPO0FBRWpCLFNBQU8sT0FBTztBQUNsQjs7O0FDc0NPLElBQU0sK0JBQStCLEtBc050QixXQUFoQixNQUF3QjtFQThDMUIsWUFBb0IsVUFBMEI7QUFBMUIsU0FBQSxXQUFBLFVBNUNaLEtBQUEsb0JBQW9CLEdBQ3BCLEtBQUEsbUJBR0osb0JBQUksSUFBRyxHQUNILEtBQUEsa0NBQW1FLG9CQUFJLElBQUcsR0FDMUUsS0FBQSx3QkFBMkYsb0JBQUksSUFBRyxHQUNsRyxLQUFBLG9CQUFvRixvQkFBSSxJQUFHLEdBQzNGLEtBQUEsb0JBQW1ELG9CQUFJLElBQUcsR0FDMUQsS0FBQSxlQUF5QyxvQkFBSSxJQUFHLEdBQ2hELEtBQUEsaUNBQWlDLG9CQUFJLElBQUcsR0FHeEMsS0FBQSxzQkFBMkMsb0JBQUksSUFBRyxHQUtsRCxLQUFBLG9CQUF1RixvQkFBSSxJQUFHLEdBMkJsRyxLQUFLLHVCQUF1Qiw2QkFBNkIsa0JBQWU7QUFDcEUsV0FBSyxVQUFVLFlBQVk7SUFDL0IsQ0FBQyxHQUVELEtBQUssdUJBQXVCLDRCQUE0QixrQkFBZTtBQUNuRSxXQUFLLFlBQVksWUFBK0M7SUFDcEUsQ0FBQyxHQUVELEtBQUs7TUFDRDs7TUFFQSxlQUFhLENBQUE7SUFBa0IsR0FJbkMsS0FBSyxhQUFhLFVBQVUsV0FDNUIsS0FBSyxvQkFBb0IsVUFBVSxrQkFDL0IsS0FBSyxlQUNMLEtBQUssa0JBQWtCLHNCQUFzQixPQUFPLFNBQVMsVUFBUztBQUNsRSxVQUFNLE9BQU8sTUFBTSxLQUFLLFdBQVksUUFBUSxRQUFRLE9BQU8sUUFBUSxNQUFNLFNBQVM7QUFDbEYsVUFBSSxDQUFDO0FBQ0QsY0FBTSxJQUFJLFNBQVMsVUFBVSxlQUFlLHlDQUF5QztBQU16RixhQUFPO1FBQ0gsR0FBRzs7SUFFWCxDQUFDLEdBRUQsS0FBSyxrQkFBa0IsNkJBQTZCLE9BQU8sU0FBUyxVQUFTO0FBQ3pFLFVBQU0sbUJBQW1CLFlBQWlDO0FBQ3RELFlBQU0sU0FBUyxRQUFRLE9BQU87QUFHOUIsWUFBSSxLQUFLLG1CQUFtQjtBQUN4QixjQUFJO0FBQ0osaUJBQVEsZ0JBQWdCLE1BQU0sS0FBSyxrQkFBa0IsUUFBUSxRQUFRLE1BQU0sU0FBUyxLQUFJO0FBRXBGLGdCQUFJLGNBQWMsU0FBUyxjQUFjLGNBQWMsU0FBUyxTQUFTO0FBQ3JFLGtCQUFNLFVBQVUsY0FBYyxTQUN4QixZQUFZLFFBQVEsSUFHcEIsV0FBVyxLQUFLLGtCQUFrQixJQUFJLFNBQXNCO0FBRWxFLGtCQUFJO0FBS0Esb0JBSEEsS0FBSyxrQkFBa0IsT0FBTyxTQUFzQixHQUdoRCxjQUFjLFNBQVM7QUFDdkIsMkJBQVMsT0FBZ0M7cUJBQ3RDO0FBRUgsc0JBQU0sZUFBZSxTQUNmQyxTQUFRLElBQUksU0FDZCxhQUFhLE1BQU0sTUFDbkIsYUFBYSxNQUFNLFNBQ25CLGFBQWEsTUFBTSxJQUFJO0FBRTNCLDJCQUFTQSxNQUFLO2dCQUNsQjttQkFDRztBQUVILG9CQUFNLGNBQWMsY0FBYyxTQUFTLGFBQWEsYUFBYTtBQUNyRSxxQkFBSyxTQUFTLElBQUksTUFBTSxHQUFHLFdBQVcsZ0NBQWdDLFNBQVMsRUFBRSxDQUFDO2NBQ3RGO0FBR0E7WUFDSjtBQUlBLGtCQUFNLEtBQUssWUFBWSxLQUFLLGNBQWMsU0FBUyxFQUFFLGtCQUFrQixNQUFNLFVBQVMsQ0FBRTtVQUM1RjtRQUNKO0FBR0EsWUFBTSxPQUFPLE1BQU0sS0FBSyxXQUFZLFFBQVEsUUFBUSxNQUFNLFNBQVM7QUFDbkUsWUFBSSxDQUFDO0FBQ0QsZ0JBQU0sSUFBSSxTQUFTLFVBQVUsZUFBZSxtQkFBbUIsTUFBTSxFQUFFO0FBSTNFLFlBQUksQ0FBQyxXQUFXLEtBQUssTUFBTTtBQUV2Qix1QkFBTSxLQUFLLG1CQUFtQixRQUFRLE1BQU0sTUFBTSxHQUczQyxNQUFNLGlCQUFnQjtBQUlqQyxZQUFJLFdBQVcsS0FBSyxNQUFNLEdBQUc7QUFDekIsY0FBTSxTQUFTLE1BQU0sS0FBSyxXQUFZLGNBQWMsUUFBUSxNQUFNLFNBQVM7QUFFM0Usc0JBQUssZ0JBQWdCLE1BQU0sR0FFcEI7WUFDSCxHQUFHO1lBQ0gsT0FBTztjQUNILEdBQUcsT0FBTztjQUNWLENBQUMscUJBQXFCLEdBQUc7Z0JBQ3JCOzs7O1FBSWhCO0FBRUEsZUFBTyxNQUFNLGlCQUFnQjtNQUNqQztBQUVBLGFBQU8sTUFBTSxpQkFBZ0I7SUFDakMsQ0FBQyxHQUVELEtBQUssa0JBQWtCLHdCQUF3QixPQUFPLFNBQVMsVUFBUztBQUNwRSxVQUFJO0FBQ0EsWUFBTSxFQUFFLE9BQU8sV0FBVSxJQUFLLE1BQU0sS0FBSyxXQUFZLFVBQVUsUUFBUSxRQUFRLFFBQVEsTUFBTSxTQUFTO0FBRXRHLGVBQU87VUFDSDtVQUNBO1VBQ0EsT0FBTyxDQUFBOztNQUVmLFNBQVNBLFFBQU87QUFDWixjQUFNLElBQUksU0FDTixVQUFVLGVBQ1YseUJBQXlCQSxrQkFBaUIsUUFBUUEsT0FBTSxVQUFVLE9BQU9BLE1BQUssQ0FBQyxFQUFFO01BRXpGO0lBQ0osQ0FBQyxHQUVELEtBQUssa0JBQWtCLHlCQUF5QixPQUFPLFNBQVMsVUFBUztBQUNyRSxVQUFJO0FBRUEsWUFBTSxPQUFPLE1BQU0sS0FBSyxXQUFZLFFBQVEsUUFBUSxPQUFPLFFBQVEsTUFBTSxTQUFTO0FBRWxGLFlBQUksQ0FBQztBQUNELGdCQUFNLElBQUksU0FBUyxVQUFVLGVBQWUsbUJBQW1CLFFBQVEsT0FBTyxNQUFNLEVBQUU7QUFJMUYsWUFBSSxXQUFXLEtBQUssTUFBTTtBQUN0QixnQkFBTSxJQUFJLFNBQVMsVUFBVSxlQUFlLDBDQUEwQyxLQUFLLE1BQU0sRUFBRTtBQUd2RyxjQUFNLEtBQUssV0FBWSxpQkFDbkIsUUFBUSxPQUFPLFFBQ2YsYUFDQSxvQ0FDQSxNQUFNLFNBQVMsR0FHbkIsS0FBSyxnQkFBZ0IsUUFBUSxPQUFPLE1BQU07QUFFMUMsWUFBTSxnQkFBZ0IsTUFBTSxLQUFLLFdBQVksUUFBUSxRQUFRLE9BQU8sUUFBUSxNQUFNLFNBQVM7QUFDM0YsWUFBSSxDQUFDO0FBRUQsZ0JBQU0sSUFBSSxTQUFTLFVBQVUsZUFBZSxzQ0FBc0MsUUFBUSxPQUFPLE1BQU0sRUFBRTtBQUc3RyxlQUFPO1VBQ0gsT0FBTyxDQUFBO1VBQ1AsR0FBRzs7TUFFWCxTQUFTQSxRQUFPO0FBRVosY0FBSUEsa0JBQWlCLFdBQ1hBLFNBRUosSUFBSSxTQUNOLFVBQVUsZ0JBQ1YsMEJBQTBCQSxrQkFBaUIsUUFBUUEsT0FBTSxVQUFVLE9BQU9BLE1BQUssQ0FBQyxFQUFFO01BRTFGO0lBQ0osQ0FBQztFQUVUO0VBRVEsTUFBTSxVQUFVLGNBQW1DO0FBQ3ZELFFBQUksQ0FBQyxhQUFhLE9BQU87QUFDckI7QUFJSixJQURtQixLQUFLLGdDQUFnQyxJQUFJLGFBQWEsT0FBTyxTQUFTLEdBQzdFLE1BQU0sYUFBYSxPQUFPLE1BQU07RUFDaEQ7RUFFUSxjQUNKLFdBQ0EsU0FDQSxpQkFDQSxXQUNBLHlCQUFrQyxJQUFLO0FBRXZDLFNBQUssYUFBYSxJQUFJLFdBQVc7TUFDN0IsV0FBVyxXQUFXLFdBQVcsT0FBTztNQUN4QyxXQUFXLEtBQUssSUFBRztNQUNuQjtNQUNBO01BQ0E7TUFDQTtLQUNIO0VBQ0w7RUFFUSxjQUFjLFdBQWlCO0FBQ25DLFFBQU0sT0FBTyxLQUFLLGFBQWEsSUFBSSxTQUFTO0FBQzVDLFFBQUksQ0FBQztBQUFNLGFBQU87QUFFbEIsUUFBTSxlQUFlLEtBQUssSUFBRyxJQUFLLEtBQUs7QUFDdkMsUUFBSSxLQUFLLG1CQUFtQixnQkFBZ0IsS0FBSztBQUM3QyxpQkFBSyxhQUFhLE9BQU8sU0FBUyxHQUM1QixTQUFTLFVBQVUsVUFBVSxnQkFBZ0Isa0NBQWtDO1FBQ2pGLGlCQUFpQixLQUFLO1FBQ3RCO09BQ0g7QUFHTCx3QkFBYSxLQUFLLFNBQVMsR0FDM0IsS0FBSyxZQUFZLFdBQVcsS0FBSyxXQUFXLEtBQUssT0FBTyxHQUNqRDtFQUNYO0VBRVEsZ0JBQWdCLFdBQWlCO0FBQ3JDLFFBQU0sT0FBTyxLQUFLLGFBQWEsSUFBSSxTQUFTO0FBQzVDLElBQUksU0FDQSxhQUFhLEtBQUssU0FBUyxHQUMzQixLQUFLLGFBQWEsT0FBTyxTQUFTO0VBRTFDOzs7Ozs7RUFPQSxNQUFNLFFBQVEsV0FBb0I7QUFDOUIsUUFBSSxLQUFLO0FBQ0wsWUFBTSxJQUFJLE1BQ04sMElBQTBJO0FBSWxKLFNBQUssYUFBYTtBQUNsQixRQUFNLFdBQVcsS0FBSyxXQUFXO0FBQ2pDLFNBQUssV0FBVyxVQUFVLE1BQUs7QUFDM0IsaUJBQVUsR0FDVixLQUFLLFNBQVE7SUFDakI7QUFFQSxRQUFNLFdBQVcsS0FBSyxXQUFXO0FBQ2pDLFNBQUssV0FBVyxVQUFVLENBQUNBLFdBQWdCO0FBQ3ZDLGlCQUFXQSxNQUFLLEdBQ2hCLEtBQUssU0FBU0EsTUFBSztJQUN2QjtBQUVBLFFBQU0sYUFBYSxLQUFLLFlBQVk7QUFDcEMsU0FBSyxXQUFXLFlBQVksQ0FBQyxTQUFTLFVBQVM7QUFDM0MsbUJBQWEsU0FBUyxLQUFLLEdBQ3ZCLHdCQUF3QixPQUFPLEtBQUssdUJBQXVCLE9BQU8sSUFDbEUsS0FBSyxZQUFZLE9BQU8sSUFDakIsaUJBQWlCLE9BQU8sSUFDL0IsS0FBSyxXQUFXLFNBQVMsS0FBSyxJQUN2QixzQkFBc0IsT0FBTyxJQUNwQyxLQUFLLGdCQUFnQixPQUFPLElBRTVCLEtBQUssU0FBUyxJQUFJLE1BQU0seUJBQXlCLEtBQUssVUFBVSxPQUFPLENBQUMsRUFBRSxDQUFDO0lBRW5GLEdBRUEsTUFBTSxLQUFLLFdBQVcsTUFBSztFQUMvQjtFQUVRLFdBQVE7QUFDWixRQUFNLG1CQUFtQixLQUFLO0FBQzlCLFNBQUssb0JBQW9CLG9CQUFJLElBQUcsR0FDaEMsS0FBSyxrQkFBa0IsTUFBSyxHQUM1QixLQUFLLG9CQUFvQixNQUFLLEdBQzlCLEtBQUssK0JBQStCLE1BQUs7QUFHekMsYUFBVyxjQUFjLEtBQUssZ0NBQWdDLE9BQU07QUFDaEUsaUJBQVcsTUFBSztBQUVwQixTQUFLLGdDQUFnQyxNQUFLO0FBRTFDLFFBQU1BLFNBQVEsU0FBUyxVQUFVLFVBQVUsa0JBQWtCLG1CQUFtQjtBQUVoRixTQUFLLGFBQWEsUUFDbEIsS0FBSyxVQUFTO0FBRWQsYUFBVyxXQUFXLGlCQUFpQixPQUFNO0FBQ3pDLGNBQVFBLE1BQUs7RUFFckI7RUFFUSxTQUFTQSxRQUFZO0FBQ3pCLFNBQUssVUFBVUEsTUFBSztFQUN4QjtFQUVRLGdCQUFnQixjQUFpQztBQUNyRCxRQUFNLFVBQVUsS0FBSyxzQkFBc0IsSUFBSSxhQUFhLE1BQU0sS0FBSyxLQUFLO0FBRzVFLElBQUksWUFBWSxVQUtoQixRQUFRLFFBQU8sRUFDVixLQUFLLE1BQU0sUUFBUSxZQUFZLENBQUMsRUFDaEMsTUFBTSxDQUFBQSxXQUFTLEtBQUssU0FBUyxJQUFJLE1BQU0sMkNBQTJDQSxNQUFLLEVBQUUsQ0FBQyxDQUFDO0VBQ3BHO0VBRVEsV0FBVyxTQUF5QixPQUF3QjtBQUNoRSxRQUFNLFVBQVUsS0FBSyxpQkFBaUIsSUFBSSxRQUFRLE1BQU0sS0FBSyxLQUFLLHdCQUc1RCxvQkFBb0IsS0FBSyxZQUd6QixnQkFBZ0IsUUFBUSxRQUFRLFFBQVEscUJBQXFCLEdBQUc7QUFFdEUsUUFBSSxZQUFZLFFBQVc7QUFDdkIsVUFBTSxnQkFBc0M7UUFDeEMsU0FBUztRQUNULElBQUksUUFBUTtRQUNaLE9BQU87VUFDSCxNQUFNLFVBQVU7VUFDaEIsU0FBUzs7O0FBS2pCLE1BQUksaUJBQWlCLEtBQUssb0JBQ3RCLEtBQUssb0JBQ0QsZUFDQTtRQUNJLE1BQU07UUFDTixTQUFTO1FBQ1QsV0FBVyxLQUFLLElBQUc7U0FFdkIsbUJBQW1CLFNBQVMsRUFDOUIsTUFBTSxDQUFBQSxXQUFTLEtBQUssU0FBUyxJQUFJLE1BQU0scUNBQXFDQSxNQUFLLEVBQUUsQ0FBQyxDQUFDLElBRXZGLG1CQUNNLEtBQUssYUFBYSxFQUNuQixNQUFNLENBQUFBLFdBQVMsS0FBSyxTQUFTLElBQUksTUFBTSxxQ0FBcUNBLE1BQUssRUFBRSxDQUFDLENBQUM7QUFFOUY7SUFDSjtBQUVBLFFBQU0sa0JBQWtCLElBQUksZ0JBQWU7QUFDM0MsU0FBSyxnQ0FBZ0MsSUFBSSxRQUFRLElBQUksZUFBZTtBQUVwRSxRQUFNLHFCQUFxQiw2QkFBNkIsUUFBUSxNQUFNLElBQUksUUFBUSxPQUFPLE9BQU8sUUFDMUYsWUFBWSxLQUFLLGFBQWEsS0FBSyxpQkFBaUIsU0FBUyxtQkFBbUIsU0FBUyxJQUFJLFFBRTdGLFlBQWtFO01BQ3BFLFFBQVEsZ0JBQWdCO01BQ3hCLFdBQVcsbUJBQW1CO01BQzlCLE9BQU8sUUFBUSxRQUFRO01BQ3ZCLGtCQUFrQixPQUFNLGlCQUFlO0FBQ25DLFlBQUksZ0JBQWdCLE9BQU87QUFBUztBQUVwQyxZQUFNLHNCQUEyQyxFQUFFLGtCQUFrQixRQUFRLEdBQUU7QUFDL0UsUUFBSSxrQkFDQSxvQkFBb0IsY0FBYyxFQUFFLFFBQVEsY0FBYSxJQUU3RCxNQUFNLEtBQUssYUFBYSxjQUFjLG1CQUFtQjtNQUM3RDtNQUNBLGFBQWEsT0FBTyxHQUFHLGNBQWMsWUFBWTtBQUM3QyxZQUFJLGdCQUFnQixPQUFPO0FBQ3ZCLGdCQUFNLElBQUksU0FBUyxVQUFVLGtCQUFrQix1QkFBdUI7QUFHMUUsWUFBTSxpQkFBaUMsRUFBRSxHQUFHLFNBQVMsa0JBQWtCLFFBQVEsR0FBRTtBQUNqRixRQUFJLGlCQUFpQixDQUFDLGVBQWUsZ0JBQ2pDLGVBQWUsY0FBYyxFQUFFLFFBQVEsY0FBYTtBQUt4RCxZQUFNLGtCQUFrQixlQUFlLGFBQWEsVUFBVTtBQUM5RCxlQUFJLG1CQUFtQixhQUNuQixNQUFNLFVBQVUsaUJBQWlCLGlCQUFpQixnQkFBZ0IsR0FHL0QsTUFBTSxLQUFLLFFBQVEsR0FBRyxjQUFjLGNBQWM7TUFDN0Q7TUFDQSxVQUFVLE9BQU87TUFDakIsV0FBVyxRQUFRO01BQ25CLGFBQWEsT0FBTztNQUNwQixRQUFRO01BQ1I7TUFDQSxrQkFBa0Isb0JBQW9CO01BQ3RDLGdCQUFnQixPQUFPO01BQ3ZCLDBCQUEwQixPQUFPOztBQUlyQyxZQUFRLFFBQU8sRUFDVixLQUFLLE1BQUs7QUFFUCxNQUFJLHNCQUVBLEtBQUssNEJBQTRCLFFBQVEsTUFBTTtJQUV2RCxDQUFDLEVBQ0EsS0FBSyxNQUFNLFFBQVEsU0FBUyxTQUFTLENBQUMsRUFDdEMsS0FDRyxPQUFNLFdBQVM7QUFDWCxVQUFJLGdCQUFnQixPQUFPO0FBRXZCO0FBR0osVUFBTSxXQUE0QjtRQUM5QjtRQUNBLFNBQVM7UUFDVCxJQUFJLFFBQVE7O0FBSWhCLE1BQUksaUJBQWlCLEtBQUssb0JBQ3RCLE1BQU0sS0FBSyxvQkFDUCxlQUNBO1FBQ0ksTUFBTTtRQUNOLFNBQVM7UUFDVCxXQUFXLEtBQUssSUFBRztTQUV2QixtQkFBbUIsU0FBUyxJQUdoQyxNQUFNLG1CQUFtQixLQUFLLFFBQVE7SUFFOUMsR0FDQSxPQUFNQSxXQUFRO0FBQ1YsVUFBSSxnQkFBZ0IsT0FBTztBQUV2QjtBQUdKLFVBQU0sZ0JBQXNDO1FBQ3hDLFNBQVM7UUFDVCxJQUFJLFFBQVE7UUFDWixPQUFPO1VBQ0gsTUFBTSxPQUFPLGNBQWNBLE9BQU0sSUFBTyxJQUFJQSxPQUFNLE9BQVUsVUFBVTtVQUN0RSxTQUFTQSxPQUFNLFdBQVc7VUFDMUIsR0FBSUEsT0FBTSxTQUFZLFVBQWEsRUFBRSxNQUFNQSxPQUFNLEtBQU87OztBQUtoRSxNQUFJLGlCQUFpQixLQUFLLG9CQUN0QixNQUFNLEtBQUssb0JBQ1AsZUFDQTtRQUNJLE1BQU07UUFDTixTQUFTO1FBQ1QsV0FBVyxLQUFLLElBQUc7U0FFdkIsbUJBQW1CLFNBQVMsSUFHaEMsTUFBTSxtQkFBbUIsS0FBSyxhQUFhO0lBRW5ELENBQUMsRUFFSixNQUFNLENBQUFBLFdBQVMsS0FBSyxTQUFTLElBQUksTUFBTSw0QkFBNEJBLE1BQUssRUFBRSxDQUFDLENBQUMsRUFDNUUsUUFBUSxNQUFLO0FBQ1YsV0FBSyxnQ0FBZ0MsT0FBTyxRQUFRLEVBQUU7SUFDMUQsQ0FBQztFQUNUO0VBRVEsWUFBWSxjQUFrQztBQUNsRCxRQUFNLEVBQUUsZUFBZSxHQUFHLE9BQU0sSUFBSyxhQUFhLFFBQzVDLFlBQVksT0FBTyxhQUFhLEdBRWhDLFVBQVUsS0FBSyxrQkFBa0IsSUFBSSxTQUFTO0FBQ3BELFFBQUksQ0FBQyxTQUFTO0FBQ1YsV0FBSyxTQUFTLElBQUksTUFBTSwwREFBMEQsS0FBSyxVQUFVLFlBQVksQ0FBQyxFQUFFLENBQUM7QUFDakg7SUFDSjtBQUVBLFFBQU0sa0JBQWtCLEtBQUssa0JBQWtCLElBQUksU0FBUyxHQUN0RCxjQUFjLEtBQUssYUFBYSxJQUFJLFNBQVM7QUFFbkQsUUFBSSxlQUFlLG1CQUFtQixZQUFZO0FBQzlDLFVBQUk7QUFDQSxhQUFLLGNBQWMsU0FBUztNQUNoQyxTQUFTQSxRQUFPO0FBRVosYUFBSyxrQkFBa0IsT0FBTyxTQUFTLEdBQ3ZDLEtBQUssa0JBQWtCLE9BQU8sU0FBUyxHQUN2QyxLQUFLLGdCQUFnQixTQUFTLEdBQzlCLGdCQUFnQkEsTUFBYztBQUM5QjtNQUNKO0FBR0osWUFBUSxNQUFNO0VBQ2xCO0VBRVEsWUFBWSxVQUFnRDtBQUNoRSxRQUFNLFlBQVksT0FBTyxTQUFTLEVBQUUsR0FHOUIsV0FBVyxLQUFLLGtCQUFrQixJQUFJLFNBQVM7QUFDckQsUUFBSSxVQUFVO0FBRVYsVUFEQSxLQUFLLGtCQUFrQixPQUFPLFNBQVMsR0FDbkMsd0JBQXdCLFFBQVE7QUFDaEMsaUJBQVMsUUFBUTtXQUNkO0FBQ0gsWUFBTUEsU0FBUSxJQUFJLFNBQVMsU0FBUyxNQUFNLE1BQU0sU0FBUyxNQUFNLFNBQVMsU0FBUyxNQUFNLElBQUk7QUFDM0YsaUJBQVNBLE1BQUs7TUFDbEI7QUFDQTtJQUNKO0FBRUEsUUFBTSxVQUFVLEtBQUssa0JBQWtCLElBQUksU0FBUztBQUNwRCxRQUFJLFlBQVksUUFBVztBQUN2QixXQUFLLFNBQVMsSUFBSSxNQUFNLGtEQUFrRCxLQUFLLFVBQVUsUUFBUSxDQUFDLEVBQUUsQ0FBQztBQUNyRztJQUNKO0FBRUEsU0FBSyxrQkFBa0IsT0FBTyxTQUFTLEdBQ3ZDLEtBQUssZ0JBQWdCLFNBQVM7QUFHOUIsUUFBSSxpQkFBaUI7QUFDckIsUUFBSSx3QkFBd0IsUUFBUSxLQUFLLFNBQVMsVUFBVSxPQUFPLFNBQVMsVUFBVyxVQUFVO0FBQzdGLFVBQU0sU0FBUyxTQUFTO0FBQ3hCLFVBQUksT0FBTyxRQUFRLE9BQU8sT0FBTyxRQUFTLFVBQVU7QUFDaEQsWUFBTSxPQUFPLE9BQU87QUFDcEIsUUFBSSxPQUFPLEtBQUssVUFBVyxhQUN2QixpQkFBaUIsSUFDakIsS0FBSyxvQkFBb0IsSUFBSSxLQUFLLFFBQVEsU0FBUztNQUUzRDtJQUNKO0FBTUEsUUFKSyxrQkFDRCxLQUFLLGtCQUFrQixPQUFPLFNBQVMsR0FHdkMsd0JBQXdCLFFBQVE7QUFDaEMsY0FBUSxRQUFRO1NBQ2I7QUFDSCxVQUFNQSxTQUFRLFNBQVMsVUFBVSxTQUFTLE1BQU0sTUFBTSxTQUFTLE1BQU0sU0FBUyxTQUFTLE1BQU0sSUFBSTtBQUNqRyxjQUFRQSxNQUFLO0lBQ2pCO0VBQ0o7RUFFQSxJQUFJLFlBQVM7QUFDVCxXQUFPLEtBQUs7RUFDaEI7Ozs7RUFLQSxNQUFNLFFBQUs7QUFDUCxVQUFNLEtBQUssWUFBWSxNQUFLO0VBQ2hDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBZ0VVLE9BQU8sY0FDYixTQUNBLGNBQ0EsU0FBd0I7QUFFeEIsUUFBTSxFQUFFLEtBQUksSUFBSyxXQUFXLENBQUE7QUFHNUIsUUFBSSxDQUFDLE1BQU07QUFDUCxVQUFJO0FBRUEsY0FBTSxFQUFFLE1BQU0sVUFBVSxRQURULE1BQU0sS0FBSyxRQUFRLFNBQVMsY0FBYyxPQUFPLEVBQ2xDO01BQ2xDLFNBQVNBLFFBQU87QUFDWixjQUFNO1VBQ0YsTUFBTTtVQUNOLE9BQU9BLGtCQUFpQixXQUFXQSxTQUFRLElBQUksU0FBUyxVQUFVLGVBQWUsT0FBT0EsTUFBSyxDQUFDOztNQUV0RztBQUNBO0lBQ0o7QUFJQSxRQUFJO0FBQ0osUUFBSTtBQUVBLFVBQU0sZUFBZSxNQUFNLEtBQUssUUFBUSxTQUFTLHdCQUF3QixPQUFPO0FBR2hGLFVBQUksYUFBYTtBQUNiLGlCQUFTLGFBQWEsS0FBSyxRQUMzQixNQUFNLEVBQUUsTUFBTSxlQUFlLE1BQU0sYUFBYSxLQUFJOztBQUVwRCxjQUFNLElBQUksU0FBUyxVQUFVLGVBQWUscUNBQXFDO0FBSXJGLGlCQUFhO0FBRVQsWUFBTUMsUUFBTyxNQUFNLEtBQUssUUFBUSxFQUFFLE9BQU0sR0FBSSxPQUFPO0FBSW5ELFlBSEEsTUFBTSxFQUFFLE1BQU0sY0FBYyxNQUFBQSxNQUFJLEdBRzVCLFdBQVdBLE1BQUssTUFBTSxHQUFHO0FBQ3pCLFVBQUlBLE1BQUssV0FBVyxjQUdoQixNQUFNLEVBQUUsTUFBTSxVQUFVLFFBRFQsTUFBTSxLQUFLLGNBQWMsRUFBRSxPQUFNLEdBQUksY0FBYyxPQUFPLEVBQzNDLElBQ3ZCQSxNQUFLLFdBQVcsV0FDdkIsTUFBTTtZQUNGLE1BQU07WUFDTixPQUFPLElBQUksU0FBUyxVQUFVLGVBQWUsUUFBUSxNQUFNLFNBQVM7Y0FFakVBLE1BQUssV0FBVyxnQkFDdkIsTUFBTTtZQUNGLE1BQU07WUFDTixPQUFPLElBQUksU0FBUyxVQUFVLGVBQWUsUUFBUSxNQUFNLGdCQUFnQjs7QUFHbkY7UUFDSjtBQUlBLFlBQUlBLE1BQUssV0FBVyxrQkFBa0I7QUFFbEMsZ0JBQU0sRUFBRSxNQUFNLFVBQVUsUUFEVCxNQUFNLEtBQUssY0FBYyxFQUFFLE9BQU0sR0FBSSxjQUFjLE9BQU8sRUFDM0M7QUFDOUI7UUFDSjtBQUdBLFlBQU0sZUFBZUEsTUFBSyxnQkFBZ0IsS0FBSyxVQUFVLDJCQUEyQjtBQUNwRixjQUFNLElBQUksUUFBUSxhQUFXLFdBQVcsU0FBUyxZQUFZLENBQUMsR0FHOUQsU0FBUyxRQUFRLGVBQWM7TUFDbkM7SUFDSixTQUFTRCxRQUFPO0FBQ1osWUFBTTtRQUNGLE1BQU07UUFDTixPQUFPQSxrQkFBaUIsV0FBV0EsU0FBUSxJQUFJLFNBQVMsVUFBVSxlQUFlLE9BQU9BLE1BQUssQ0FBQzs7SUFFdEc7RUFDSjs7Ozs7O0VBT0EsUUFBNkIsU0FBdUIsY0FBaUIsU0FBd0I7QUFDekYsUUFBTSxFQUFFLGtCQUFrQixpQkFBaUIsbUJBQW1CLE1BQU0sWUFBVyxJQUFLLFdBQVcsQ0FBQTtBQUcvRixXQUFPLElBQUksUUFBeUIsQ0FBQyxTQUFTLFdBQVU7QUFDcEQsVUFBTSxjQUFjLENBQUNBLFdBQWtCO0FBQ25DLGVBQU9BLE1BQUs7TUFDaEI7QUFFQSxVQUFJLENBQUMsS0FBSyxZQUFZO0FBQ2xCLG9CQUFZLElBQUksTUFBTSxlQUFlLENBQUM7QUFDdEM7TUFDSjtBQUVBLFVBQUksS0FBSyxVQUFVLDhCQUE4QjtBQUM3QyxZQUFJO0FBQ0EsZUFBSywwQkFBMEIsUUFBUSxNQUFNLEdBR3pDLFFBQ0EsS0FBSyxxQkFBcUIsUUFBUSxNQUFNO1FBRWhELFNBQVMsR0FBRztBQUNSLHNCQUFZLENBQUM7QUFDYjtRQUNKO0FBR0osZUFBUyxRQUFRLGVBQWM7QUFFL0IsVUFBTSxZQUFZLEtBQUsscUJBQ2pCLGlCQUFpQztRQUNuQyxHQUFHO1FBQ0gsU0FBUztRQUNULElBQUk7O0FBR1IsTUFBSSxTQUFTLGVBQ1QsS0FBSyxrQkFBa0IsSUFBSSxXQUFXLFFBQVEsVUFBVSxHQUN4RCxlQUFlLFNBQVM7UUFDcEIsR0FBRyxRQUFRO1FBQ1gsT0FBTztVQUNILEdBQUksUUFBUSxRQUFRLFNBQVMsQ0FBQTtVQUM3QixlQUFlOztVQU12QixTQUNBLGVBQWUsU0FBUztRQUNwQixHQUFHLGVBQWU7UUFDbEI7VUFLSixnQkFDQSxlQUFlLFNBQVM7UUFDcEIsR0FBRyxlQUFlO1FBQ2xCLE9BQU87VUFDSCxHQUFJLGVBQWUsUUFBUSxTQUFTLENBQUE7VUFDcEMsQ0FBQyxxQkFBcUIsR0FBRzs7O0FBS3JDLFVBQU0sU0FBUyxDQUFDLFdBQW1CO0FBQy9CLGFBQUssa0JBQWtCLE9BQU8sU0FBUyxHQUN2QyxLQUFLLGtCQUFrQixPQUFPLFNBQVMsR0FDdkMsS0FBSyxnQkFBZ0IsU0FBUyxHQUU5QixLQUFLLFlBQ0MsS0FDRTtVQUNJLFNBQVM7VUFDVCxRQUFRO1VBQ1IsUUFBUTtZQUNKLFdBQVc7WUFDWCxRQUFRLE9BQU8sTUFBTTs7V0FHN0IsRUFBRSxrQkFBa0IsaUJBQWlCLGtCQUFpQixDQUFFLEVBRTNELE1BQU0sQ0FBQUEsV0FBUyxLQUFLLFNBQVMsSUFBSSxNQUFNLGdDQUFnQ0EsTUFBSyxFQUFFLENBQUMsQ0FBQztBQUdyRixZQUFNQSxTQUFRLGtCQUFrQixXQUFXLFNBQVMsSUFBSSxTQUFTLFVBQVUsZ0JBQWdCLE9BQU8sTUFBTSxDQUFDO0FBQ3pHLGVBQU9BLE1BQUs7TUFDaEI7QUFFQSxXQUFLLGtCQUFrQixJQUFJLFdBQVcsY0FBVztBQUM3QyxZQUFJLFVBQVMsUUFBUSxTQUlyQjtjQUFJLG9CQUFvQjtBQUNwQixtQkFBTyxPQUFPLFFBQVE7QUFHMUIsY0FBSTtBQUNBLGdCQUFNLGNBQWNFLFdBQVUsY0FBYyxTQUFTLE1BQU07QUFDM0QsWUFBSyxZQUFZLFVBSWIsUUFBUSxZQUFZLElBQXVCLElBRjNDLE9BQU8sWUFBWSxLQUFLO1VBSWhDLFNBQVNGLFFBQU87QUFDWixtQkFBT0EsTUFBSztVQUNoQjs7TUFDSixDQUFDLEdBRUQsU0FBUyxRQUFRLGlCQUFpQixTQUFTLE1BQUs7QUFDNUMsZUFBTyxTQUFTLFFBQVEsTUFBTTtNQUNsQyxDQUFDO0FBRUQsVUFBTSxVQUFVLFNBQVMsV0FBVyw4QkFDOUIsaUJBQWlCLE1BQU0sT0FBTyxTQUFTLFVBQVUsVUFBVSxnQkFBZ0IscUJBQXFCLEVBQUUsUUFBTyxDQUFFLENBQUM7QUFFbEgsV0FBSyxjQUFjLFdBQVcsU0FBUyxTQUFTLGlCQUFpQixnQkFBZ0IsU0FBUywwQkFBMEIsRUFBSztBQUd6SCxVQUFNLGdCQUFnQixhQUFhO0FBQ25DLFVBQUksZUFBZTtBQUVmLFlBQU0sbUJBQW1CLENBQUMsYUFBMkM7QUFDakUsY0FBTSxVQUFVLEtBQUssa0JBQWtCLElBQUksU0FBUztBQUNwRCxVQUFJLFVBQ0EsUUFBUSxRQUFRLElBR2hCLEtBQUssU0FBUyxJQUFJLE1BQU0sdURBQXVELFNBQVMsRUFBRSxDQUFDO1FBRW5HO0FBQ0EsYUFBSyxrQkFBa0IsSUFBSSxXQUFXLGdCQUFnQixHQUV0RCxLQUFLLG9CQUFvQixlQUFlO1VBQ3BDLE1BQU07VUFDTixTQUFTO1VBQ1QsV0FBVyxLQUFLLElBQUc7U0FDdEIsRUFBRSxNQUFNLENBQUFBLFdBQVE7QUFDYixlQUFLLGdCQUFnQixTQUFTLEdBQzlCLE9BQU9BLE1BQUs7UUFDaEIsQ0FBQztNQUlMO0FBRUksYUFBSyxXQUFXLEtBQUssZ0JBQWdCLEVBQUUsa0JBQWtCLGlCQUFpQixrQkFBaUIsQ0FBRSxFQUFFLE1BQU0sQ0FBQUEsV0FBUTtBQUN6RyxlQUFLLGdCQUFnQixTQUFTLEdBQzlCLE9BQU9BLE1BQUs7UUFDaEIsQ0FBQztJQUVULENBQUM7RUFDTDs7Ozs7O0VBT1UsTUFBTSxRQUFRLFFBQWtDLFNBQXdCO0FBRTlFLFdBQU8sS0FBSyxRQUFRLEVBQUUsUUFBUSxhQUFhLE9BQU0sR0FBSSxxQkFBcUIsT0FBTztFQUNyRjs7Ozs7O0VBT1UsTUFBTSxjQUNaLFFBQ0EsY0FDQSxTQUF3QjtBQUd4QixXQUFPLEtBQUssUUFBUSxFQUFFLFFBQVEsZ0JBQWdCLE9BQU0sR0FBSSxjQUFjLE9BQU87RUFDakY7Ozs7OztFQU9VLE1BQU0sVUFBVSxRQUE4QixTQUF3QjtBQUU1RSxXQUFPLEtBQUssUUFBUSxFQUFFLFFBQVEsY0FBYyxPQUFNLEdBQUksdUJBQXVCLE9BQU87RUFDeEY7Ozs7OztFQU9VLE1BQU0sV0FBVyxRQUE0QixTQUF3QjtBQUUzRSxXQUFPLEtBQUssUUFBUSxFQUFFLFFBQVEsZ0JBQWdCLE9BQU0sR0FBSSx3QkFBd0IsT0FBTztFQUMzRjs7OztFQUtBLE1BQU0sYUFBYSxjQUFpQyxTQUE2QjtBQUM3RSxRQUFJLENBQUMsS0FBSztBQUNOLFlBQU0sSUFBSSxNQUFNLGVBQWU7QUFHbkMsU0FBSyw2QkFBNkIsYUFBYSxNQUFNO0FBR3JELFFBQU0sZ0JBQWdCLFNBQVMsYUFBYTtBQUM1QyxRQUFJLGVBQWU7QUFFZixVQUFNRyx1QkFBMkM7UUFDN0MsR0FBRztRQUNILFNBQVM7UUFDVCxRQUFRO1VBQ0osR0FBRyxhQUFhO1VBQ2hCLE9BQU87WUFDSCxHQUFJLGFBQWEsUUFBUSxTQUFTLENBQUE7WUFDbEMsQ0FBQyxxQkFBcUIsR0FBRyxRQUFROzs7O0FBSzdDLFlBQU0sS0FBSyxvQkFBb0IsZUFBZTtRQUMxQyxNQUFNO1FBQ04sU0FBU0E7UUFDVCxXQUFXLEtBQUssSUFBRztPQUN0QjtBQUlEO0lBQ0o7QUFRQSxTQU55QixLQUFLLFVBQVUsZ0NBQWdDLENBQUEsR0FJbkQsU0FBUyxhQUFhLE1BQU0sS0FBSyxDQUFDLGFBQWEsVUFBVSxDQUFDLFNBQVMsb0JBQW9CLENBQUMsU0FBUyxhQUVyRztBQUViLFVBQUksS0FBSywrQkFBK0IsSUFBSSxhQUFhLE1BQU07QUFDM0Q7QUFJSixXQUFLLCtCQUErQixJQUFJLGFBQWEsTUFBTSxHQUkzRCxRQUFRLFFBQU8sRUFBRyxLQUFLLE1BQUs7QUFLeEIsWUFIQSxLQUFLLCtCQUErQixPQUFPLGFBQWEsTUFBTSxHQUcxRCxDQUFDLEtBQUs7QUFDTjtBQUdKLFlBQUlBLHVCQUEyQztVQUMzQyxHQUFHO1VBQ0gsU0FBUzs7QUFJYixRQUFJLFNBQVMsZ0JBQ1RBLHVCQUFzQjtVQUNsQixHQUFHQTtVQUNILFFBQVE7WUFDSixHQUFHQSxxQkFBb0I7WUFDdkIsT0FBTztjQUNILEdBQUlBLHFCQUFvQixRQUFRLFNBQVMsQ0FBQTtjQUN6QyxDQUFDLHFCQUFxQixHQUFHLFFBQVE7OztZQVFqRCxLQUFLLFlBQVksS0FBS0Esc0JBQXFCLE9BQU8sRUFBRSxNQUFNLENBQUFILFdBQVMsS0FBSyxTQUFTQSxNQUFLLENBQUM7TUFDM0YsQ0FBQztBQUdEO0lBQ0o7QUFFQSxRQUFJLHNCQUEyQztNQUMzQyxHQUFHO01BQ0gsU0FBUzs7QUFJYixJQUFJLFNBQVMsZ0JBQ1Qsc0JBQXNCO01BQ2xCLEdBQUc7TUFDSCxRQUFRO1FBQ0osR0FBRyxvQkFBb0I7UUFDdkIsT0FBTztVQUNILEdBQUksb0JBQW9CLFFBQVEsU0FBUyxDQUFBO1VBQ3pDLENBQUMscUJBQXFCLEdBQUcsUUFBUTs7O1FBTWpELE1BQU0sS0FBSyxXQUFXLEtBQUsscUJBQXFCLE9BQU87RUFDM0Q7Ozs7OztFQU9BLGtCQUNJLGVBQ0EsU0FHdUM7QUFFdkMsUUFBTSxTQUFTLGlCQUFpQixhQUFhO0FBQzdDLFNBQUssK0JBQStCLE1BQU0sR0FFMUMsS0FBSyxpQkFBaUIsSUFBSSxRQUFRLENBQUMsU0FBUyxVQUFTO0FBQ2pELFVBQU0sU0FBUyxnQkFBZ0IsZUFBZSxPQUFPO0FBQ3JELGFBQU8sUUFBUSxRQUFRLFFBQVEsUUFBUSxLQUFLLENBQUM7SUFDakQsQ0FBQztFQUNMOzs7O0VBS0EscUJBQXFCLFFBQWM7QUFDL0IsU0FBSyxpQkFBaUIsT0FBTyxNQUFNO0VBQ3ZDOzs7O0VBS0EsMkJBQTJCLFFBQWM7QUFDckMsUUFBSSxLQUFLLGlCQUFpQixJQUFJLE1BQU07QUFDaEMsWUFBTSxJQUFJLE1BQU0seUJBQXlCLE1BQU0sNENBQTRDO0VBRW5HOzs7Ozs7RUFPQSx1QkFDSSxvQkFDQSxTQUFnRTtBQUVoRSxRQUFNLFNBQVMsaUJBQWlCLGtCQUFrQjtBQUNsRCxTQUFLLHNCQUFzQixJQUFJLFFBQVEsa0JBQWU7QUFDbEQsVUFBTSxTQUFTLGdCQUFnQixvQkFBb0IsWUFBWTtBQUMvRCxhQUFPLFFBQVEsUUFBUSxRQUFRLE1BQU0sQ0FBQztJQUMxQyxDQUFDO0VBQ0w7Ozs7RUFLQSwwQkFBMEIsUUFBYztBQUNwQyxTQUFLLHNCQUFzQixPQUFPLE1BQU07RUFDNUM7Ozs7O0VBTVEsNEJBQTRCLFFBQWM7QUFDOUMsUUFBTSxnQkFBZ0IsS0FBSyxvQkFBb0IsSUFBSSxNQUFNO0FBQ3pELElBQUksa0JBQWtCLFdBQ2xCLEtBQUssa0JBQWtCLE9BQU8sYUFBYSxHQUMzQyxLQUFLLG9CQUFvQixPQUFPLE1BQU07RUFFOUM7Ozs7Ozs7Ozs7OztFQWFRLE1BQU0sb0JBQW9CLFFBQWdCLFNBQXdCLFdBQWtCO0FBRXhGLFFBQUksQ0FBQyxLQUFLLGNBQWMsQ0FBQyxLQUFLO0FBQzFCLFlBQU0sSUFBSSxNQUFNLGdGQUFnRjtBQUdwRyxRQUFNLGVBQWUsS0FBSyxVQUFVO0FBQ3BDLFVBQU0sS0FBSyxrQkFBa0IsUUFBUSxRQUFRLFNBQVMsV0FBVyxZQUFZO0VBQ2pGOzs7Ozs7RUFPUSxNQUFNLGdCQUFnQixRQUFnQixXQUFrQjtBQUM1RCxRQUFJLEtBQUssbUJBQW1CO0FBRXhCLFVBQU0sV0FBVyxNQUFNLEtBQUssa0JBQWtCLFdBQVcsUUFBUSxTQUFTO0FBQzFFLGVBQVcsV0FBVztBQUNsQixZQUFJLFFBQVEsU0FBUyxhQUFhLGlCQUFpQixRQUFRLE9BQU8sR0FBRztBQUVqRSxjQUFNLFlBQVksUUFBUSxRQUFRLElBQzVCLFdBQVcsS0FBSyxrQkFBa0IsSUFBSSxTQUFTO0FBQ3JELFVBQUksWUFDQSxTQUFTLElBQUksU0FBUyxVQUFVLGVBQWUsNkJBQTZCLENBQUMsR0FDN0UsS0FBSyxrQkFBa0IsT0FBTyxTQUFTLEtBR3ZDLEtBQUssU0FBUyxJQUFJLE1BQU0sZ0NBQWdDLFNBQVMsZ0JBQWdCLE1BQU0sVUFBVSxDQUFDO1FBRTFHO0lBRVI7RUFDSjs7Ozs7Ozs7RUFTUSxNQUFNLG1CQUFtQixRQUFnQixRQUFtQjtBQUVoRSxRQUFJLFdBQVcsS0FBSyxVQUFVLDJCQUEyQjtBQUN6RCxRQUFJO0FBQ0EsVUFBTSxPQUFPLE1BQU0sS0FBSyxZQUFZLFFBQVEsTUFBTTtBQUNsRCxNQUFJLE1BQU0saUJBQ04sV0FBVyxLQUFLO0lBRXhCLFFBQVE7SUFFUjtBQUVBLFdBQU8sSUFBSSxRQUFRLENBQUMsU0FBUyxXQUFVO0FBQ25DLFVBQUksT0FBTyxTQUFTO0FBQ2hCLGVBQU8sSUFBSSxTQUFTLFVBQVUsZ0JBQWdCLG1CQUFtQixDQUFDO0FBQ2xFO01BQ0o7QUFHQSxVQUFNLFlBQVksV0FBVyxTQUFTLFFBQVE7QUFHOUMsYUFBTyxpQkFDSCxTQUNBLE1BQUs7QUFDRCxxQkFBYSxTQUFTLEdBQ3RCLE9BQU8sSUFBSSxTQUFTLFVBQVUsZ0JBQWdCLG1CQUFtQixDQUFDO01BQ3RFLEdBQ0EsRUFBRSxNQUFNLEdBQUksQ0FBRTtJQUV0QixDQUFDO0VBQ0w7RUFFUSxpQkFBaUIsU0FBMEIsV0FBa0I7QUFDakUsUUFBTSxZQUFZLEtBQUs7QUFDdkIsUUFBSSxDQUFDO0FBQ0QsWUFBTSxJQUFJLE1BQU0sMEJBQTBCO0FBRzlDLFdBQU87TUFDSCxZQUFZLE9BQU0sZUFBYTtBQUMzQixZQUFJLENBQUM7QUFDRCxnQkFBTSxJQUFJLE1BQU0scUJBQXFCO0FBR3pDLGVBQU8sTUFBTSxVQUFVLFdBQ25CLFlBQ0EsUUFBUSxJQUNSO1VBQ0ksUUFBUSxRQUFRO1VBQ2hCLFFBQVEsUUFBUTtXQUVwQixTQUFTO01BRWpCO01BQ0EsU0FBUyxPQUFNLFdBQVM7QUFDcEIsWUFBTSxPQUFPLE1BQU0sVUFBVSxRQUFRLFFBQVEsU0FBUztBQUN0RCxZQUFJLENBQUM7QUFDRCxnQkFBTSxJQUFJLFNBQVMsVUFBVSxlQUFlLHlDQUF5QztBQUd6RixlQUFPO01BQ1g7TUFDQSxpQkFBaUIsT0FBTyxRQUFRLFFBQVEsV0FBVTtBQUM5QyxjQUFNLFVBQVUsZ0JBQWdCLFFBQVEsUUFBUSxRQUFRLFNBQVM7QUFHakUsWUFBTSxPQUFPLE1BQU0sVUFBVSxRQUFRLFFBQVEsU0FBUztBQUN0RCxZQUFJLE1BQU07QUFDTixjQUFNLGVBQXVDLDZCQUE2QixNQUFNO1lBQzVFLFFBQVE7WUFDUixRQUFRO1dBQ1g7QUFDRCxnQkFBTSxLQUFLLGFBQWEsWUFBaUMsR0FFckQsV0FBVyxLQUFLLE1BQU0sS0FDdEIsS0FBSyw0QkFBNEIsTUFBTTtRQUcvQztNQUNKO01BQ0EsZUFBZSxZQUNKLFVBQVUsY0FBYyxRQUFRLFNBQVM7TUFFcEQsa0JBQWtCLE9BQU8sUUFBUSxRQUFRLGtCQUFpQjtBQUV0RCxZQUFNLE9BQU8sTUFBTSxVQUFVLFFBQVEsUUFBUSxTQUFTO0FBQ3RELFlBQUksQ0FBQztBQUNELGdCQUFNLElBQUksU0FBUyxVQUFVLGVBQWUsU0FBUyxNQUFNLDJDQUEyQztBQUkxRyxZQUFJLFdBQVcsS0FBSyxNQUFNO0FBQ3RCLGdCQUFNLElBQUksU0FDTixVQUFVLGVBQ1YsdUJBQXVCLE1BQU0sMkJBQTJCLEtBQUssTUFBTSxTQUFTLE1BQU0sc0ZBQXNGO0FBSWhMLGNBQU0sVUFBVSxpQkFBaUIsUUFBUSxRQUFRLGVBQWUsU0FBUztBQUd6RSxZQUFNLGNBQWMsTUFBTSxVQUFVLFFBQVEsUUFBUSxTQUFTO0FBQzdELFlBQUksYUFBYTtBQUNiLGNBQU0sZUFBdUMsNkJBQTZCLE1BQU07WUFDNUUsUUFBUTtZQUNSLFFBQVE7V0FDWDtBQUNELGdCQUFNLEtBQUssYUFBYSxZQUFpQyxHQUVyRCxXQUFXLFlBQVksTUFBTSxLQUM3QixLQUFLLDRCQUE0QixNQUFNO1FBRy9DO01BQ0o7TUFDQSxXQUFXLFlBQ0EsVUFBVSxVQUFVLFFBQVEsU0FBUzs7RUFHeEQ7O0FBR0osU0FBU0ksZUFBYyxPQUFjO0FBQ2pDLFNBQU8sVUFBVSxRQUFRLE9BQU8sU0FBVSxZQUFZLENBQUMsTUFBTSxRQUFRLEtBQUs7QUFDOUU7QUFJTSxTQUFVLGtCQUFxRSxNQUFTLFlBQXNCO0FBQ2hILE1BQU0sU0FBWSxFQUFFLEdBQUcsS0FBSTtBQUMzQixXQUFXLE9BQU8sWUFBWTtBQUMxQixRQUFNLElBQUksS0FDSixXQUFXLFdBQVcsQ0FBQztBQUM3QixRQUFJLGFBQWE7QUFBVztBQUM1QixRQUFNLFlBQVksT0FBTyxDQUFDO0FBQzFCLElBQUlBLGVBQWMsU0FBUyxLQUFLQSxlQUFjLFFBQVEsSUFDbEQsT0FBTyxDQUFDLElBQUksRUFBRSxHQUFJLFdBQXVDLEdBQUksU0FBb0MsSUFFakcsT0FBTyxDQUFDLElBQUk7RUFFcEI7QUFDQSxTQUFPO0FBQ1g7OztBQ3BvREEsaUJBQWdCLDJCQUNoQixxQkFBd0I7QUFHeEIsU0FBUywyQkFBd0I7QUFDN0IsTUFBTSxNQUFNLElBQUksV0FBQUMsUUFBSTtJQUNoQixRQUFRO0lBQ1IsaUJBQWlCO0lBQ2pCLGdCQUFnQjtJQUNoQixXQUFXO0dBQ2Q7QUFHRCxhQURtQixtQkFBQUMsU0FDUixHQUFHLEdBRVA7QUFDWDtBQWVNLElBQU8seUJBQVAsTUFBNkI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXVCL0IsWUFBWSxLQUFTO0FBQ2pCLFNBQUssT0FBTyxPQUFPLHlCQUF3QjtFQUMvQzs7Ozs7Ozs7OztFQVdBLGFBQWdCLFFBQXNCO0FBRWxDLFFBQU0sZUFDRixTQUFTLFVBQVUsT0FBTyxPQUFPLE9BQVEsV0FDbEMsS0FBSyxLQUFLLFVBQVUsT0FBTyxHQUFHLEtBQUssS0FBSyxLQUFLLFFBQVEsTUFBTSxJQUM1RCxLQUFLLEtBQUssUUFBUSxNQUFNO0FBRWxDLFdBQU8sQ0FBQyxVQUNVLGFBQWEsS0FBSyxJQUdyQjtNQUNILE9BQU87TUFDUCxNQUFNO01BQ04sY0FBYztRQUdYO01BQ0gsT0FBTztNQUNQLE1BQU07TUFDTixjQUFjLEtBQUssS0FBSyxXQUFXLGFBQWEsTUFBTTs7RUFJdEU7Ozs7QUN0RUUsSUFBTywwQkFBUCxNQUE4QjtFQUtoQyxZQUE2QixTQUFpRDtBQUFqRCxTQUFBLFVBQUE7RUFBb0Q7Ozs7Ozs7Ozs7Ozs7OztFQWdCakYsY0FDSSxTQUNBLGNBQ0EsU0FBd0I7QUFVeEIsV0FBUSxLQUFLLFFBQStDLGNBQWMsU0FBUyxjQUFjLE9BQU87RUFDNUc7Ozs7Ozs7Ozs7RUFXQSxNQUFNLFFBQVEsUUFBZ0IsU0FBd0I7QUFFbEQsV0FBUSxLQUFLLFFBQXlDLFFBQVEsRUFBRSxPQUFNLEdBQUksT0FBTztFQUNyRjs7Ozs7Ozs7Ozs7RUFZQSxNQUFNLGNBQW1DLFFBQWdCLGNBQWtCLFNBQXdCO0FBQy9GLFdBQ0ksS0FBSyxRQU9QLGNBQWMsRUFBRSxPQUFNLEdBQUksY0FBYyxPQUFPO0VBQ3JEOzs7Ozs7Ozs7O0VBV0EsTUFBTSxVQUFVLFFBQWlCLFNBQXdCO0FBQ3JELFdBQ0ksS0FBSyxRQUdQLFVBQVUsU0FBUyxFQUFFLE9BQU0sSUFBSyxRQUFXLE9BQU87RUFDeEQ7Ozs7Ozs7OztFQVVBLE1BQU0sV0FBVyxRQUFnQixTQUF3QjtBQUNyRCxXQUNJLEtBQUssUUFHUCxXQUFXLEVBQUUsT0FBTSxHQUFJLE9BQU87RUFDcEM7Ozs7QUNyR0UsU0FBVSw4QkFDWixVQUNBLFFBQ0EsWUFBK0I7QUFFL0IsTUFBSSxDQUFDO0FBQ0QsVUFBTSxJQUFJLE1BQU0sR0FBRyxVQUFVLGlEQUFpRCxNQUFNLEdBQUc7QUFHM0YsVUFBUSxRQUFRO0lBQ1osS0FBSztBQUNELFVBQUksQ0FBQyxTQUFTLE9BQU87QUFDakIsY0FBTSxJQUFJLE1BQU0sR0FBRyxVQUFVLGdFQUFnRSxNQUFNLEdBQUc7QUFFMUc7SUFFSjtBQUVJO0VBQ1I7QUFDSjtBQWFNLFNBQVUsa0NBQ1osVUFDQSxRQUNBLFlBQStCO0FBRS9CLE1BQUksQ0FBQztBQUNELFVBQU0sSUFBSSxNQUFNLEdBQUcsVUFBVSxpREFBaUQsTUFBTSxHQUFHO0FBRzNGLFVBQVEsUUFBUTtJQUNaLEtBQUs7QUFDRCxVQUFJLENBQUMsU0FBUyxVQUFVO0FBQ3BCLGNBQU0sSUFBSSxNQUFNLEdBQUcsVUFBVSw0RUFBNEUsTUFBTSxHQUFHO0FBRXRIO0lBRUosS0FBSztBQUNELFVBQUksQ0FBQyxTQUFTLGFBQWE7QUFDdkIsY0FBTSxJQUFJLE1BQU0sR0FBRyxVQUFVLHdFQUF3RSxNQUFNLEdBQUc7QUFFbEg7SUFFSjtBQUVJO0VBQ1I7QUFDSjs7O0FDeUNNLElBQU8sU0FBUCxjQUlJLFNBQThGOzs7O0VBZ0JwRyxZQUNZLGFBQ1IsU0FBdUI7QUFFdkIsVUFBTSxPQUFPLEdBSEwsS0FBQSxjQUFBLGFBMENKLEtBQUEsaUJBQWlCLG9CQUFJLElBQUcsR0FHZixLQUFBLHFCQUFxQixJQUFJLElBQUksbUJBQW1CLFFBQVEsSUFBSSxDQUFDLE9BQU8sVUFBVSxDQUFDLE9BQU8sS0FBSyxDQUFDLENBQUMsR0FHdEcsS0FBQSxtQkFBbUIsQ0FBQyxPQUFxQixjQUErQjtBQUM1RSxVQUFNLGVBQWUsS0FBSyxlQUFlLElBQUksU0FBUztBQUN0RCxhQUFPLGVBQWUsS0FBSyxtQkFBbUIsSUFBSSxLQUFLLElBQUssS0FBSyxtQkFBbUIsSUFBSSxZQUFZLElBQUs7SUFDN0csR0EvQ0ksS0FBSyxnQkFBZ0IsU0FBUyxnQkFBZ0IsQ0FBQSxHQUM5QyxLQUFLLGdCQUFnQixTQUFTLGNBQzlCLEtBQUssdUJBQXVCLFNBQVMsdUJBQXVCLElBQUksdUJBQXNCLEdBRXRGLEtBQUssa0JBQWtCLHlCQUF5QixhQUFXLEtBQUssY0FBYyxPQUFPLENBQUMsR0FDdEYsS0FBSyx1QkFBdUIsK0JBQStCLE1BQU0sS0FBSyxnQkFBZSxDQUFFLEdBRW5GLEtBQUssY0FBYyxXQUNuQixLQUFLLGtCQUFrQix1QkFBdUIsT0FBTyxTQUFTLFVBQVM7QUFDbkUsVUFBTSxxQkFDRixNQUFNLGFBQWMsTUFBTSxhQUFhLFFBQVEsZ0JBQWdCLEtBQWdCLFFBQzdFLEVBQUUsTUFBSyxJQUFLLFFBQVEsUUFDcEIsY0FBYyxtQkFBbUIsVUFBVSxLQUFLO0FBQ3RELGFBQUksWUFBWSxXQUNaLEtBQUssZUFBZSxJQUFJLG9CQUFvQixZQUFZLElBQUksR0FFekQsQ0FBQTtJQUNYLENBQUM7RUFFVDs7Ozs7Ozs7RUFTQSxJQUFJLGVBQVk7QUFDWixXQUFLLEtBQUssa0JBQ04sS0FBSyxnQkFBZ0I7TUFDakIsT0FBTyxJQUFJLHdCQUF3QixJQUFJO1FBR3hDLEtBQUs7RUFDaEI7Ozs7OztFQW1CTyxxQkFBcUIsY0FBZ0M7QUFDeEQsUUFBSSxLQUFLO0FBQ0wsWUFBTSxJQUFJLE1BQU0sNERBQTREO0FBRWhGLFNBQUssZ0JBQWdCLGtCQUFrQixLQUFLLGVBQWUsWUFBWTtFQUMzRTs7OztFQUtnQixrQkFDWixlQUNBLFNBRzZEO0FBRzdELFFBQU0sZUFEUSxlQUFlLGFBQWEsR0FDZDtBQUM1QixRQUFJLENBQUM7QUFDRCxZQUFNLElBQUksTUFBTSxvQ0FBb0M7QUFJeEQsUUFBSTtBQUNKLFFBQUksV0FBVyxZQUFZLEdBQUc7QUFDMUIsVUFBTSxXQUFXO0FBRWpCLG9CQURjLFNBQVMsTUFBTSxLQUNSLFNBQVMsU0FBUztJQUMzQyxPQUFPO0FBQ0gsVUFBTSxXQUFXO0FBRWpCLG9CQURrQixTQUFTLE1BQ0YsU0FBUyxTQUFTO0lBQy9DO0FBRUEsUUFBSSxPQUFPLGVBQWdCO0FBQ3ZCLFlBQU0sSUFBSSxNQUFNLHdDQUF3QztBQUk1RCxRQUZlLGdCQUVBLGNBQWM7QUFDekIsVUFBTSxpQkFBaUIsT0FDbkIsU0FDQSxVQUNpQztBQUNqQyxZQUFNLG1CQUFtQkMsV0FBVSx1QkFBdUIsT0FBTztBQUNqRSxZQUFJLENBQUMsaUJBQWlCLFNBQVM7QUFDM0IsY0FBTSxlQUNGLGlCQUFpQixpQkFBaUIsUUFBUSxpQkFBaUIsTUFBTSxVQUFVLE9BQU8saUJBQWlCLEtBQUs7QUFDNUcsZ0JBQU0sSUFBSSxTQUFTLFVBQVUsZUFBZSwrQkFBK0IsWUFBWSxFQUFFO1FBQzdGO0FBRUEsWUFBTSxFQUFFLE9BQU0sSUFBSyxpQkFBaUIsTUFFOUIsU0FBUyxNQUFNLFFBQVEsUUFBUSxRQUFRLFNBQVMsS0FBSyxDQUFDO0FBRzVELFlBQUksT0FBTyxNQUFNO0FBQ2IsY0FBTSx1QkFBdUJBLFdBQVUsd0JBQXdCLE1BQU07QUFDckUsY0FBSSxDQUFDLHFCQUFxQixTQUFTO0FBQy9CLGdCQUFNLGVBQ0YscUJBQXFCLGlCQUFpQixRQUNoQyxxQkFBcUIsTUFBTSxVQUMzQixPQUFPLHFCQUFxQixLQUFLO0FBQzNDLGtCQUFNLElBQUksU0FBUyxVQUFVLGVBQWUsaUNBQWlDLFlBQVksRUFBRTtVQUMvRjtBQUNBLGlCQUFPLHFCQUFxQjtRQUNoQztBQUdBLFlBQU0sbUJBQW1CQSxXQUFVLHNCQUFzQixNQUFNO0FBQy9ELFlBQUksQ0FBQyxpQkFBaUIsU0FBUztBQUMzQixjQUFNLGVBQ0YsaUJBQWlCLGlCQUFpQixRQUFRLGlCQUFpQixNQUFNLFVBQVUsT0FBTyxpQkFBaUIsS0FBSztBQUM1RyxnQkFBTSxJQUFJLFNBQVMsVUFBVSxlQUFlLDhCQUE4QixZQUFZLEVBQUU7UUFDNUY7QUFFQSxlQUFPLGlCQUFpQjtNQUM1QjtBQUdBLGFBQU8sTUFBTSxrQkFBa0IsZUFBZSxjQUEyQztJQUM3RjtBQUdBLFdBQU8sTUFBTSxrQkFBa0IsZUFBZSxPQUFPO0VBQ3pEO0VBRVUsMEJBQTBCLFFBQTBCO0FBQzFELFlBQVEsUUFBbUM7TUFDdkMsS0FBSztBQUNELFlBQUksQ0FBQyxLQUFLLHFCQUFxQjtBQUMzQixnQkFBTSxJQUFJLE1BQU0sa0RBQWtELE1BQU0sR0FBRztBQUUvRTtNQUVKLEtBQUs7QUFDRCxZQUFJLENBQUMsS0FBSyxxQkFBcUI7QUFDM0IsZ0JBQU0sSUFBSSxNQUFNLHFEQUFxRCxNQUFNLEdBQUc7QUFFbEY7TUFFSixLQUFLO0FBQ0QsWUFBSSxDQUFDLEtBQUsscUJBQXFCO0FBQzNCLGdCQUFNLElBQUksTUFBTSx1REFBdUQsTUFBTSxHQUFHO0FBRXBGO01BRUosS0FBSztBQUVEO0lBQ1I7RUFDSjtFQUVVLDZCQUE2QixRQUFzRDtBQUN6RixZQUFRLFFBQXdDO01BQzVDLEtBQUs7QUFDRCxZQUFJLENBQUMsS0FBSyxjQUFjO0FBQ3BCLGdCQUFNLElBQUksTUFBTSxpREFBaUQsTUFBTSxHQUFHO0FBRTlFO01BRUosS0FBSztNQUNMLEtBQUs7QUFDRCxZQUFJLENBQUMsS0FBSyxjQUFjO0FBQ3BCLGdCQUFNLElBQUksTUFBTSxtRUFBbUUsTUFBTSxHQUFHO0FBRWhHO01BRUosS0FBSztBQUNELFlBQUksQ0FBQyxLQUFLLGNBQWM7QUFDcEIsZ0JBQU0sSUFBSSxNQUFNLHdFQUF3RSxNQUFNLEdBQUc7QUFFckc7TUFFSixLQUFLO0FBQ0QsWUFBSSxDQUFDLEtBQUssY0FBYztBQUNwQixnQkFBTSxJQUFJLE1BQU0sMEVBQTBFLE1BQU0sR0FBRztBQUV2RztNQUVKLEtBQUs7QUFDRCxZQUFJLENBQUMsS0FBSyxxQkFBcUIsYUFBYTtBQUN4QyxnQkFBTSxJQUFJLE1BQU0seURBQXlELE1BQU0sR0FBRztBQUV0RjtNQUVKLEtBQUs7QUFFRDtNQUVKLEtBQUs7QUFFRDtJQUNSO0VBQ0o7RUFFVSwrQkFBK0IsUUFBYztBQUduRCxRQUFLLEtBQUs7QUFJVixjQUFRLFFBQVE7UUFDWixLQUFLO0FBQ0QsY0FBSSxDQUFDLEtBQUssY0FBYztBQUNwQixrQkFBTSxJQUFJLE1BQU0scURBQXFELE1BQU0sR0FBRztBQUVsRjtRQUVKLEtBQUs7QUFDRCxjQUFJLENBQUMsS0FBSyxjQUFjO0FBQ3BCLGtCQUFNLElBQUksTUFBTSxpREFBaUQsTUFBTSxHQUFHO0FBRTlFO1FBRUosS0FBSztRQUNMLEtBQUs7QUFDRCxjQUFJLENBQUMsS0FBSyxjQUFjO0FBQ3BCLGtCQUFNLElBQUksTUFBTSxpREFBaUQsTUFBTSxHQUFHO0FBRTlFO1FBRUosS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO0FBQ0QsY0FBSSxDQUFDLEtBQUssY0FBYztBQUNwQixrQkFBTSxJQUFJLE1BQU0sbURBQW1ELE1BQU0sR0FBRztBQUVoRjtRQUVKLEtBQUs7UUFDTCxLQUFLO0FBQ0QsY0FBSSxDQUFDLEtBQUssY0FBYztBQUNwQixrQkFBTSxJQUFJLE1BQU0sK0NBQStDLE1BQU0sR0FBRztBQUU1RTtRQUVKLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7QUFDRCxjQUFJLENBQUMsS0FBSyxjQUFjO0FBQ3BCLGtCQUFNLElBQUksTUFBTSwwREFBMEQsTUFBTSxHQUFHO0FBRXZGO1FBRUosS0FBSztRQUNMLEtBQUs7QUFFRDtNQUNSO0VBQ0o7RUFFVSxxQkFBcUIsUUFBYztBQUN6QyxzQ0FBa0MsS0FBSyxxQkFBcUIsT0FBTyxVQUFVLFFBQVEsUUFBUTtFQUNqRztFQUVVLDRCQUE0QixRQUFjO0FBR2hELElBQUssS0FBSyxpQkFJViw4QkFBOEIsS0FBSyxjQUFjLE9BQU8sVUFBVSxRQUFRLFFBQVE7RUFDdEY7RUFFUSxNQUFNLGNBQWMsU0FBMEI7QUFDbEQsUUFBTSxtQkFBbUIsUUFBUSxPQUFPO0FBRXhDLGdCQUFLLHNCQUFzQixRQUFRLE9BQU8sY0FDMUMsS0FBSyxpQkFBaUIsUUFBUSxPQUFPLFlBSTlCO01BQ0gsaUJBSG9CLDRCQUE0QixTQUFTLGdCQUFnQixJQUFJLG1CQUFtQjtNQUloRyxjQUFjLEtBQUssZ0JBQWU7TUFDbEMsWUFBWSxLQUFLO01BQ2pCLEdBQUksS0FBSyxpQkFBaUIsRUFBRSxjQUFjLEtBQUssY0FBYTs7RUFFcEU7Ozs7RUFLQSx3QkFBcUI7QUFDakIsV0FBTyxLQUFLO0VBQ2hCOzs7O0VBS0EsbUJBQWdCO0FBQ1osV0FBTyxLQUFLO0VBQ2hCO0VBRVEsa0JBQWU7QUFDbkIsV0FBTyxLQUFLO0VBQ2hCO0VBRUEsTUFBTSxPQUFJO0FBQ04sV0FBTyxLQUFLLFFBQVEsRUFBRSxRQUFRLE9BQU0sR0FBSSxpQkFBaUI7RUFDN0Q7O0VBd0JBLE1BQU0sY0FDRixRQUNBLFNBQXdCO0FBR3hCLFNBQUksT0FBTyxTQUFTLE9BQU8sZUFDbkIsQ0FBQyxLQUFLLHFCQUFxQixVQUFVO0FBQ3JDLFlBQU0sSUFBSSxNQUFNLG9EQUFvRDtBQU81RSxRQUFJLE9BQU8sU0FBUyxTQUFTLEdBQUc7QUFDNUIsVUFBTSxjQUFjLE9BQU8sU0FBUyxPQUFPLFNBQVMsU0FBUyxDQUFDLEdBQ3hELGNBQWMsTUFBTSxRQUFRLFlBQVksT0FBTyxJQUFJLFlBQVksVUFBVSxDQUFDLFlBQVksT0FBTyxHQUM3RixpQkFBaUIsWUFBWSxLQUFLLE9BQUssRUFBRSxTQUFTLGFBQWEsR0FFL0Qsa0JBQWtCLE9BQU8sU0FBUyxTQUFTLElBQUksT0FBTyxTQUFTLE9BQU8sU0FBUyxTQUFTLENBQUMsSUFBSSxRQUM3RixrQkFBa0Isa0JBQ2xCLE1BQU0sUUFBUSxnQkFBZ0IsT0FBTyxJQUNqQyxnQkFBZ0IsVUFDaEIsQ0FBQyxnQkFBZ0IsT0FBTyxJQUM1QixDQUFBLEdBQ0EscUJBQXFCLGdCQUFnQixLQUFLLE9BQUssRUFBRSxTQUFTLFVBQVU7QUFFMUUsVUFBSSxnQkFBZ0I7QUFDaEIsWUFBSSxZQUFZLEtBQUssT0FBSyxFQUFFLFNBQVMsYUFBYTtBQUM5QyxnQkFBTSxJQUFJLE1BQU0sMEVBQTBFO0FBRTlGLFlBQUksQ0FBQztBQUNELGdCQUFNLElBQUksTUFBTSw0RUFBNEU7TUFFcEc7QUFDQSxVQUFJLG9CQUFvQjtBQUNwQixZQUFNLGFBQWEsSUFBSSxJQUFJLGdCQUFnQixPQUFPLE9BQUssRUFBRSxTQUFTLFVBQVUsRUFBRSxJQUFJLE9BQU0sRUFBcUIsRUFBRSxDQUFDLEdBQzFHLGdCQUFnQixJQUFJLElBQ3RCLFlBQVksT0FBTyxPQUFLLEVBQUUsU0FBUyxhQUFhLEVBQUUsSUFBSSxPQUFNLEVBQXdCLFNBQVMsQ0FBQztBQUVsRyxZQUFJLFdBQVcsU0FBUyxjQUFjLFFBQVEsQ0FBQyxDQUFDLEdBQUcsVUFBVSxFQUFFLE1BQU0sUUFBTSxjQUFjLElBQUksRUFBRSxDQUFDO0FBQzVGLGdCQUFNLElBQUksTUFBTSxrRkFBa0Y7TUFFMUc7SUFDSjtBQUdBLFdBQUksT0FBTyxRQUNBLEtBQUssUUFBUSxFQUFFLFFBQVEsMEJBQTBCLE9BQU0sR0FBSSxvQ0FBb0MsT0FBTyxJQUUxRyxLQUFLLFFBQVEsRUFBRSxRQUFRLDBCQUEwQixPQUFNLEdBQUksMkJBQTJCLE9BQU87RUFDeEc7Ozs7Ozs7O0VBU0EsTUFBTSxZQUFZLFFBQTBELFNBQXdCO0FBR2hHLFlBRmMsT0FBTyxRQUFRLFFBRWY7TUFDVixLQUFLLE9BQU87QUFDUixZQUFJLENBQUMsS0FBSyxxQkFBcUIsYUFBYTtBQUN4QyxnQkFBTSxJQUFJLE1BQU0sMENBQTBDO0FBRzlELFlBQU0sWUFBWTtBQUNsQixlQUFPLEtBQUssUUFBUSxFQUFFLFFBQVEsc0JBQXNCLFFBQVEsVUFBUyxHQUFJLG9CQUFvQixPQUFPO01BQ3hHO01BQ0EsS0FBSyxRQUFRO0FBQ1QsWUFBSSxDQUFDLEtBQUsscUJBQXFCLGFBQWE7QUFDeEMsZ0JBQU0sSUFBSSxNQUFNLDJDQUEyQztBQUcvRCxZQUFNLGFBQ0YsT0FBTyxTQUFTLFNBQVUsU0FBcUMsRUFBRSxHQUFJLFFBQW9DLE1BQU0sT0FBTSxHQUVuSCxTQUFTLE1BQU0sS0FBSyxRQUFRLEVBQUUsUUFBUSxzQkFBc0IsUUFBUSxXQUFVLEdBQUksb0JBQW9CLE9BQU87QUFFbkgsWUFBSSxPQUFPLFdBQVcsWUFBWSxPQUFPLFdBQVcsV0FBVztBQUMzRCxjQUFJO0FBRUEsZ0JBQU0sbUJBRFksS0FBSyxxQkFBcUIsYUFBYSxXQUFXLGVBQWlDLEVBQ2xFLE9BQU8sT0FBTztBQUVqRCxnQkFBSSxDQUFDLGlCQUFpQjtBQUNsQixvQkFBTSxJQUFJLFNBQ04sVUFBVSxlQUNWLGlFQUFpRSxpQkFBaUIsWUFBWSxFQUFFO1VBRzVHLFNBQVNDLFFBQU87QUFDWixrQkFBSUEsa0JBQWlCLFdBQ1hBLFNBRUosSUFBSSxTQUNOLFVBQVUsZUFDViwwQ0FBMENBLGtCQUFpQixRQUFRQSxPQUFNLFVBQVUsT0FBT0EsTUFBSyxDQUFDLEVBQUU7VUFFMUc7QUFFSixlQUFPO01BQ1g7SUFDSjtFQUNKOzs7Ozs7Ozs7RUFVQSxvQ0FBb0MsZUFBdUIsU0FBNkI7QUFDcEYsUUFBSSxDQUFDLEtBQUsscUJBQXFCLGFBQWE7QUFDeEMsWUFBTSxJQUFJLE1BQU0sMkZBQTJGO0FBRy9HLFdBQU8sTUFDSCxLQUFLLGFBQ0Q7TUFDSSxRQUFRO01BQ1IsUUFBUTtRQUNKOztPQUdSLE9BQU87RUFFbkI7RUFFQSxNQUFNLFVBQVUsUUFBcUMsU0FBd0I7QUFDekUsV0FBTyxLQUFLLFFBQVEsRUFBRSxRQUFRLGNBQWMsT0FBTSxHQUFJLHVCQUF1QixPQUFPO0VBQ3hGOzs7Ozs7OztFQVNBLE1BQU0sbUJBQW1CLFFBQThDLFdBQWtCO0FBQ3JGLFFBQUksS0FBSyxjQUFjLFdBQ2YsQ0FBQyxLQUFLLGlCQUFpQixPQUFPLE9BQU8sU0FBUztBQUM5QyxhQUFPLEtBQUssYUFBYSxFQUFFLFFBQVEseUJBQXlCLE9BQU0sQ0FBRTtFQUdoRjtFQUVBLE1BQU0sb0JBQW9CLFFBQTZDO0FBQ25FLFdBQU8sS0FBSyxhQUFhO01BQ3JCLFFBQVE7TUFDUjtLQUNIO0VBQ0w7RUFFQSxNQUFNLDBCQUF1QjtBQUN6QixXQUFPLEtBQUssYUFBYTtNQUNyQixRQUFRO0tBQ1g7RUFDTDtFQUVBLE1BQU0sc0JBQW1CO0FBQ3JCLFdBQU8sS0FBSyxhQUFhLEVBQUUsUUFBUSxtQ0FBa0MsQ0FBRTtFQUMzRTtFQUVBLE1BQU0sd0JBQXFCO0FBQ3ZCLFdBQU8sS0FBSyxhQUFhLEVBQUUsUUFBUSxxQ0FBb0MsQ0FBRTtFQUM3RTs7OztBQzNwQkosMEJBQW9COzs7QUNLZCxJQUFPLGFBQVAsTUFBaUI7RUFHbkIsT0FBTyxPQUFhO0FBQ2hCLFNBQUssVUFBVSxLQUFLLFVBQVUsT0FBTyxPQUFPLENBQUMsS0FBSyxTQUFTLEtBQUssQ0FBQyxJQUFJO0VBQ3pFO0VBRUEsY0FBVztBQUNQLFFBQUksQ0FBQyxLQUFLO0FBQ04sYUFBTztBQUdYLFFBQU0sUUFBUSxLQUFLLFFBQVEsUUFBUTtDQUFJO0FBQ3ZDLFFBQUksVUFBVTtBQUNWLGFBQU87QUFHWCxRQUFNLE9BQU8sS0FBSyxRQUFRLFNBQVMsUUFBUSxHQUFHLEtBQUssRUFBRSxRQUFRLE9BQU8sRUFBRTtBQUN0RSxnQkFBSyxVQUFVLEtBQUssUUFBUSxTQUFTLFFBQVEsQ0FBQyxHQUN2QyxtQkFBbUIsSUFBSTtFQUNsQztFQUVBLFFBQUs7QUFDRCxTQUFLLFVBQVU7RUFDbkI7O0FBR0UsU0FBVSxtQkFBbUIsTUFBWTtBQUMzQyxTQUFPLHFCQUFxQixNQUFNLEtBQUssTUFBTSxJQUFJLENBQUM7QUFDdEQ7QUFFTSxTQUFVLGlCQUFpQixTQUF1QjtBQUNwRCxTQUFPLEtBQUssVUFBVSxPQUFPLElBQUk7O0FBQ3JDOzs7QUQzQk0sSUFBTyx1QkFBUCxNQUEyQjtFQUk3QixZQUNZLFNBQW1CLG9CQUFBQyxRQUFRLE9BQzNCLFVBQW9CLG9CQUFBQSxRQUFRLFFBQU07QUFEbEMsU0FBQSxTQUFBLFFBQ0EsS0FBQSxVQUFBLFNBTEosS0FBQSxjQUEwQixJQUFJLFdBQVUsR0FDeEMsS0FBQSxXQUFXLElBWW5CLEtBQUEsVUFBVSxDQUFDLFVBQWlCO0FBQ3hCLFdBQUssWUFBWSxPQUFPLEtBQUssR0FDN0IsS0FBSyxrQkFBaUI7SUFDMUIsR0FDQSxLQUFBLFdBQVcsQ0FBQ0MsV0FBZ0I7QUFDeEIsV0FBSyxVQUFVQSxNQUFLO0lBQ3hCO0VBYkc7Ozs7RUFrQkgsTUFBTSxRQUFLO0FBQ1AsUUFBSSxLQUFLO0FBQ0wsWUFBTSxJQUFJLE1BQ04sK0dBQStHO0FBSXZILFNBQUssV0FBVyxJQUNoQixLQUFLLE9BQU8sR0FBRyxRQUFRLEtBQUssT0FBTyxHQUNuQyxLQUFLLE9BQU8sR0FBRyxTQUFTLEtBQUssUUFBUTtFQUN6QztFQUVRLG9CQUFpQjtBQUNyQjtBQUNJLFVBQUk7QUFDQSxZQUFNLFVBQVUsS0FBSyxZQUFZLFlBQVc7QUFDNUMsWUFBSSxZQUFZO0FBQ1o7QUFHSixhQUFLLFlBQVksT0FBTztNQUM1QixTQUFTQSxRQUFPO0FBQ1osYUFBSyxVQUFVQSxNQUFjO01BQ2pDO0VBRVI7RUFFQSxNQUFNLFFBQUs7QUFFUCxTQUFLLE9BQU8sSUFBSSxRQUFRLEtBQUssT0FBTyxHQUNwQyxLQUFLLE9BQU8sSUFBSSxTQUFTLEtBQUssUUFBUSxHQUdQLEtBQUssT0FBTyxjQUFjLE1BQU0sTUFDaEMsS0FHM0IsS0FBSyxPQUFPLE1BQUssR0FJckIsS0FBSyxZQUFZLE1BQUssR0FDdEIsS0FBSyxVQUFTO0VBQ2xCO0VBRUEsS0FBSyxTQUF1QjtBQUN4QixXQUFPLElBQUksUUFBUSxhQUFVO0FBQ3pCLFVBQU1DLFFBQU8saUJBQWlCLE9BQU87QUFDckMsTUFBSSxLQUFLLFFBQVEsTUFBTUEsS0FBSSxJQUN2QixRQUFPLElBRVAsS0FBSyxRQUFRLEtBQUssU0FBUyxPQUFPO0lBRTFDLENBQUM7RUFDTDs7OztBRWxFRyxJQUFNLGlCQUFxQztBQUFBLEVBQ2hELFVBQVU7QUFBQTtBQUFBLEVBQ1YsU0FBUztBQUFBO0FBQUEsRUFDVCxZQUFZO0FBQUEsRUFDWixZQUFZO0FBQUE7QUFBQSxFQUNaLFdBQVc7QUFDYixHQWNhLGVBQU4sTUFBbUI7QUFBQSxFQUNoQjtBQUFBLEVBRVIsWUFBWUMsVUFBc0MsQ0FBQyxHQUFHO0FBQ3BELFNBQUssU0FBUyxFQUFFLEdBQUcsZ0JBQWdCLEdBQUdBLFFBQU87QUFBQSxFQUMvQztBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxNQUFNLFFBQWdCLFVBQXdCLENBQUMsR0FBMEI7QUFDN0UsUUFBTSxFQUFFLFNBQVMsUUFBUSxVQUFVLEtBQUssT0FBTyxTQUFTLGVBQWUsSUFBSSxTQUVyRSxVQUFrQztBQUFBLE1BQ3RDLFFBQVUsV0FBVyxTQUFTLG9DQUFvQztBQUFBLE1BQ2xFLGdCQUFnQjtBQUFBLE1BQ2hCLGNBQWMsS0FBSyxPQUFPO0FBQUEsSUFDNUI7QUFFQSxJQUFJLG1CQUNGLFFBQVEsaUJBQWlCLElBQUk7QUFHL0IsUUFBTSxPQUFPLElBQUksZ0JBQWdCO0FBQUEsTUFDL0IsT0FBTztBQUFBLElBQ1QsQ0FBQyxHQUVHLFlBQTBCO0FBRTlCLGFBQVMsVUFBVSxHQUFHLFVBQVUsS0FBSyxPQUFPLFlBQVk7QUFDdEQsVUFBSTtBQUNGLFlBQU0sYUFBYSxJQUFJLGdCQUFnQixHQUNqQyxZQUFZLFdBQVcsTUFBTSxXQUFXLE1BQU0sR0FBRyxPQUFPLEdBRXhELFdBQVcsTUFBTSxNQUFNLEtBQUssT0FBTyxVQUFVO0FBQUEsVUFDakQsUUFBUTtBQUFBLFVBQ1I7QUFBQSxVQUNBLE1BQU0sS0FBSyxTQUFTO0FBQUEsVUFDcEIsUUFBUSxXQUFXO0FBQUEsUUFDckIsQ0FBQztBQUlELFlBRkEsYUFBYSxTQUFTLEdBRWxCLENBQUMsU0FBUyxJQUFJO0FBQ2hCLGNBQU0sWUFBWSxNQUFNLFNBQVMsS0FBSztBQUN0QyxnQkFBTSxJQUFJLE1BQU0sd0JBQXdCLFNBQVMsTUFBTSxJQUFJLFNBQVMsVUFBVSxNQUFNLFNBQVMsRUFBRTtBQUFBLFFBQ2pHO0FBR0EsZUFEZSxNQUFNLFNBQVMsS0FBSztBQUFBLE1BR3JDLFNBQVNDLFFBQU87QUFJZCxZQUhBLFlBQVlBLFFBR1IsVUFBVSxRQUFRLFNBQVMsR0FBRztBQUNoQyxnQkFBTSxLQUFLLGtCQUFrQixXQUFXLE1BQU07QUFJaEQsUUFBSSxVQUFVLEtBQUssT0FBTyxhQUFhLEtBQ3JDLE1BQU0sS0FBSyxNQUFNLEtBQUssT0FBTyxjQUFjLFVBQVUsRUFBRTtBQUFBLE1BRTNEO0FBR0YsVUFBTSxLQUFLLGtCQUFrQixXQUFZLE1BQU07QUFBQSxFQUNqRDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsTUFBTSxJQUFJLFFBQWdCLFVBQXdCLENBQUMsR0FBcUI7QUFHdEUsWUFGZSxNQUFNLEtBQUssTUFBTSxRQUFRLE9BQU8sR0FFSSxXQUFXO0FBQUEsRUFDaEU7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLE1BQU0sU0FBUyxRQUFnQixVQUF3QixDQUFDLEdBQTBCO0FBQ2hGLFdBQU8sS0FBSyxNQUFNLFFBQVEsRUFBRSxHQUFHLFNBQVMsUUFBUSxPQUFPLENBQUM7QUFBQSxFQUMxRDtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0EsYUFBYSxTQUF3RDtBQUNuRSxXQUFPLFNBQVM7QUFBQSxFQUNsQjtBQUFBO0FBQUE7QUFBQTtBQUFBLEVBS0Esc0JBQ0UsVUFDQSxjQUNBLGdCQUF3QixNQUNKO0FBRXBCLGFBQVcsV0FBVyxVQUFVO0FBQzlCLFVBQU0sUUFBUSxRQUFRLFlBQVk7QUFDbEMsVUFBSSxTQUFTLE1BQU0sVUFBVSxNQUFNO0FBQ2pDLGVBQU8sTUFBTTtBQUFBLElBRWpCO0FBR0EsYUFBVyxXQUFXLFVBQVU7QUFDOUIsVUFBTSxRQUFRLFFBQVEsWUFBWTtBQUNsQyxVQUFJO0FBQ0YsZUFBTyxNQUFNO0FBQUEsSUFFakI7QUFBQSxFQUdGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSx5QkFDRSxVQUNBLGNBQ3dCO0FBQ3hCLFFBQU0sU0FBaUMsQ0FBQztBQUV4QyxhQUFXLFdBQVcsVUFBVTtBQUM5QixVQUFNLFFBQVEsUUFBUSxZQUFZO0FBQ2xDLE1BQUksU0FBUyxNQUFNLFVBQVUsSUFDM0IsT0FBTyxNQUFNLFVBQVUsQ0FBQyxJQUFJLE1BQU0sUUFDekIsU0FBUyxDQUFDLE9BQU8sS0FBSyxNQUFNLEVBQUUsV0FFdkMsT0FBTyxLQUFRLE1BQU07QUFBQSxJQUV6QjtBQUVBLFdBQU87QUFBQSxFQUNUO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxjQUNFLFVBQ0EsYUFDbUQ7QUFDbkQsUUFBTSxTQUFTLG9CQUFJLElBQWtEO0FBRXJFLGFBQVcsV0FBVyxVQUFVO0FBQzlCLFVBQU0sTUFBTSxLQUFLLGFBQWEsUUFBUSxXQUFXLENBQUM7QUFDbEQsVUFBSSxLQUFLO0FBQ1AsWUFBTSxRQUFRLE9BQU8sSUFBSSxHQUFHLEtBQUssQ0FBQztBQUNsQyxjQUFNLEtBQUssT0FBTyxHQUNsQixPQUFPLElBQUksS0FBSyxLQUFLO0FBQUEsTUFDdkI7QUFBQSxJQUNGO0FBRUEsV0FBTztBQUFBLEVBQ1Q7QUFBQTtBQUFBO0FBQUE7QUFBQSxFQUtBLGNBQWMsUUFBb0Q7QUFFaEUsUUFBTSxVQUFVLE9BQU8sS0FBSyxFQUFFLFlBQVk7QUFFMUMsUUFBSSxDQUFDLFFBQVEsV0FBVyxRQUFRLEtBQzVCLENBQUMsUUFBUSxXQUFXLEtBQUssS0FDekIsQ0FBQyxRQUFRLFdBQVcsVUFBVSxLQUM5QixDQUFDLFFBQVEsV0FBVyxXQUFXLEtBQy9CLENBQUMsUUFBUSxXQUFXLFFBQVE7QUFDOUIsYUFBTyxFQUFFLE9BQU8sSUFBTyxPQUFPLG9FQUFvRTtBQUlwRyxRQUFNLGNBQWMsT0FBTyxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsUUFDeEMsZUFBZSxPQUFPLE1BQU0sSUFBSSxLQUFLLENBQUMsR0FBRztBQUMvQyxXQUFJLGVBQWUsY0FDVixFQUFFLE9BQU8sSUFBTyxPQUFPLDZCQUE2QixJQUd0RCxFQUFFLE9BQU8sR0FBSztBQUFBLEVBQ3ZCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLUSxrQkFBa0JBLFFBQWMsT0FBNkI7QUFDbkUsV0FBTztBQUFBLE1BQ0wsTUFBTTtBQUFBLE1BQ04sU0FBU0EsT0FBTTtBQUFBLE1BQ2Y7QUFBQSxNQUNBLFVBQVUsS0FBSyxPQUFPO0FBQUEsSUFDeEI7QUFBQSxFQUNGO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLUSxNQUFNLElBQTJCO0FBQ3ZDLFdBQU8sSUFBSSxRQUFRLGFBQVcsV0FBVyxTQUFTLEVBQUUsQ0FBQztBQUFBLEVBQ3ZEO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxjQUFzQjtBQUNwQixXQUFPLEtBQUssT0FBTztBQUFBLEVBQ3JCO0FBQUE7QUFBQTtBQUFBO0FBQUEsRUFLQSxhQUFhRCxTQUEyQztBQUN0RCxTQUFLLFNBQVMsRUFBRSxHQUFHLEtBQUssUUFBUSxHQUFHQSxRQUFPO0FBQUEsRUFDNUM7QUFDRjtBQUtPLFNBQVMsbUJBQW1CQSxTQUFvRDtBQUNyRixTQUFPLElBQUksYUFBYTtBQUFBLElBQ3RCLEdBQUc7QUFBQSxJQUNILEdBQUdBO0FBQUEsRUFDTCxDQUFDO0FBQ0g7QUFLTyxTQUFTLGdCQUFnQixPQUF1QjtBQUNyRCxTQUFPLE1BQ0osUUFBUSxPQUFPLE1BQU0sRUFDckIsUUFBUSxNQUFNLEtBQUssRUFDbkIsUUFBUSxPQUFPLEtBQUssRUFDcEIsUUFBUSxPQUFPLEtBQUssRUFDcEIsUUFBUSxPQUFPLEtBQUs7QUFDekI7OztBQy9RTyxJQUFNLGVBQWU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBZWYsa0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FZbEIsa0JBQWtCO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FTbEIsZUFBZSxHQUFHLFlBQVksR0FBRyxlQUFlLEdBQUcsZUFBZTtBQUt4RSxTQUFTLGFBQWEsT0FBdUI7QUFDbEQsU0FBTyxHQUFHLFlBQVk7QUFBQSxFQUFLLEtBQUs7QUFDbEM7OztBQ3RDTyxTQUFTLHdCQUF3QixVQUFrQixVQUE2QjtBQUNyRixNQUFNLGFBQWEsV0FDZiwwQkFBMEIsUUFBUSxPQUNsQztBQUVKLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFTTyxnQkFBZ0IsUUFBUSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFJbEQsVUFBVTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBZ0JYO0FBQ0g7QUFnRE8sU0FBUywrQkFBK0IsY0FBc0IsVUFBNkI7QUFDaEcsTUFBTSxhQUFhLFdBQ2YsMEJBQTBCLFFBQVEsT0FDbEM7QUFFSixTQUFPLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBUWxCLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDBDQUs0QixnQkFBZ0IsYUFBYSxZQUFZLENBQUMsQ0FBQztBQUFBO0FBQUE7QUFBQSwwQ0FHM0MsZ0JBQWdCLGFBQWEsWUFBWSxDQUFDLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQVVsRjtBQUNIOzs7QUM1R08sU0FBUyxxQkFDZCxVQUNBLGVBQ0EsVUFDUTtBQUNSLE1BQU0sYUFBYSxXQUNmLDZCQUE2QixRQUFRLE9BQ3JDLElBR0Usb0JBQW9CLGNBQWMsUUFBUSxlQUFlLEVBQUUsRUFBRSxLQUFLO0FBRXhFLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQVVPLGdCQUFnQixRQUFRLENBQUM7QUFBQSxJQUNsRCxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNkJBYWUsZ0JBQWdCLGlCQUFpQixDQUFDO0FBQUEsbUNBQzVCLGdCQUFnQixpQkFBaUIsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE1BTy9ELFdBQVcsaUNBQWlDLFFBQVEsT0FBTyxFQUFFO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0F5QmhFO0FBQ0g7QUFLTyxTQUFTLDhCQUNkLFVBQ0EsZUFDQSxpQkFDQSxVQUNRO0FBQ1IsTUFBTSxhQUFhLFdBQ2YsMEJBQTBCLFFBQVEsT0FDbEMsSUFFRSxvQkFBb0IsY0FBYyxRQUFRLGVBQWUsRUFBRSxFQUFFLEtBQUs7QUFFeEUsU0FBTyxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQVNPLGdCQUFnQixRQUFRLENBQUM7QUFBQSxJQUNsRCxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFXZSxnQkFBZ0IsaUJBQWlCLENBQUM7QUFBQSxtQ0FDNUIsZ0JBQWdCLGlCQUFpQixDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsaUNBVXBDLGdCQUFnQixlQUFlLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FTOUQ7QUFDSDs7O0FDMUlPLFNBQVMsaUJBQ2QsWUFDQSxVQUF5QixDQUFDLEdBQ2xCO0FBQ1IsTUFBTTtBQUFBLElBQ0o7QUFBQSxJQUNBO0FBQUE7QUFBQSxJQUVBO0FBQUEsSUFDQSxRQUFRO0FBQUEsSUFDUixTQUFTO0FBQUEsRUFDWCxJQUFJLFNBRUUsYUFBYSxXQUNmLDBCQUEwQixRQUFRLE9BQ2xDLElBRUUsaUJBQWlCLGlCQUNuQixxQ0FBcUMsZ0JBQWdCLGNBQWMsQ0FBQyxRQUNwRSxJQUVFLGdCQUFnQixXQUFXLFFBQVEsU0FBUyxJQUM5Qyx1QkFBdUIsUUFBUSxJQUFJLE9BQUssSUFBSSxDQUFDLEdBQUcsRUFBRSxLQUFLLElBQUksQ0FBQyxPQUM1RDtBQUVKLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsMENBY29CLGdCQUFnQixVQUFVLENBQUM7QUFBQSw2Q0FDeEIsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBO0FBQUE7QUFBQSxJQUdwRSxVQUFVO0FBQUEsSUFDVixjQUFjO0FBQUEsSUFDZCxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsU0FPUixNQUFNO0FBQUEsUUFDUCxLQUFLO0FBQUEsR0FDVjtBQUNIO0FBS08sU0FBUyxzQkFDZCxZQUNBLFVBQXlCLENBQUMsR0FDbEI7QUFDUixNQUFNLEVBQUUsVUFBVSxnQkFBZ0IsUUFBUSxJQUFJLFNBRXhDLGFBQWEsV0FDZiwwQkFBMEIsUUFBUSxPQUNsQyxJQUVFLGlCQUFpQixpQkFDbkIscUNBQXFDLGdCQUFnQixjQUFjLENBQUMsUUFDcEUsSUFFRSxnQkFBZ0IsV0FBVyxRQUFRLFNBQVMsSUFDOUMsdUJBQXVCLFFBQVEsSUFBSSxPQUFLLElBQUksQ0FBQyxHQUFHLEVBQUUsS0FBSyxJQUFJLENBQUMsT0FDNUQ7QUFFSixTQUFPLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSwwQ0FVb0IsZ0JBQWdCLFVBQVUsQ0FBQztBQUFBLDZDQUN4QixnQkFBZ0IsVUFBVSxDQUFDO0FBQUE7QUFBQTtBQUFBLElBR3BFLFVBQVU7QUFBQSxJQUNWLGNBQWM7QUFBQSxJQUNkLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUlkO0FBQ0g7QUFLTyxTQUFTLHlCQUNkRSxTQUNBLFVBQ0EsUUFBZ0IsS0FDUjtBQUNSLE1BQU0sYUFBYSxXQUNmLDBCQUEwQixRQUFRLE9BQ2xDO0FBSUosU0FBTyxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLHNDQVNnQixnQkFBZ0JBLE9BQU0sQ0FBQztBQUFBLElBQ3pELFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBS04sS0FBSztBQUFBLEdBQ1Y7QUFDSDtBQUtPLFNBQVMsdUJBQ2QsVUFDQSxRQUNBLFVBQ0EsUUFBZ0IsSUFDUjtBQUNSLE1BQU0sYUFBYSxXQUNmLDBCQUEwQixRQUFRLE9BQ2xDLElBRUEsYUFBYTtBQUNqQixTQUFJLFlBQVksU0FDZCxhQUFhLDJCQUEyQixRQUFRLG1DQUFtQyxNQUFNLGlCQUNoRixXQUNULGFBQWEsMkJBQTJCLFFBQVEsaUJBQ3ZDLFdBQ1QsYUFBYSwyQkFBMkIsTUFBTSxpQkFHekMsYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBVWxCLFVBQVU7QUFBQSxJQUNWLFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLFFBS04sS0FBSztBQUFBLEdBQ1Y7QUFDSDtBQW1GTyxJQUFNLGdCQUF3RTtBQUFBLEVBQ25GLEdBQUssRUFBRSxJQUFJLDhCQUEyQixJQUFJLG1DQUE2QixJQUFJLCtCQUE0QjtBQUFBLEVBQ3ZHLEdBQUssRUFBRSxJQUFJLG1EQUFtRCxJQUFJLGlFQUFxRCxJQUFJLGtEQUFrRDtBQUFBLEVBQzdLLEdBQUssRUFBRSxJQUFJLGlEQUFpRCxJQUFJLHFFQUF5RCxJQUFJLDREQUE0RDtBQUFBLEVBQ3pMLEdBQUssRUFBRSxJQUFJLGtDQUFrQyxJQUFJLGdDQUE2QixJQUFJLDZCQUE2QjtBQUFBLEVBQy9HLEdBQUssRUFBRSxJQUFJLHNCQUFzQixJQUFJLHdCQUFxQixJQUFJLG1CQUFtQjtBQUFBLEVBQ2pGLEdBQUssRUFBRSxJQUFJLFlBQVksSUFBSSxZQUFZLElBQUksVUFBVTtBQUFBLEVBQ3JELEdBQUssRUFBRSxJQUFJLDRDQUF5QyxJQUFJLDZDQUEwQyxJQUFJLHdDQUF3QztBQUFBLEVBQzlJLEdBQUssRUFBRSxJQUFJLDRDQUE0QyxJQUFJLCtDQUFzQyxJQUFJLHlDQUFzQztBQUFBLEVBQzNJLEdBQUssRUFBRSxJQUFJLDBDQUEwQyxJQUFJLDBDQUFvQyxJQUFJLGtDQUFrQztBQUNySTs7O0FDdlFPLFNBQVMsMkJBQ2QsVUFDQSxVQUNBLFFBQWdCLElBQ1I7QUFDUixNQUFNLGFBQWEsV0FDZixrQ0FBa0MsUUFBUSxPQUMxQztBQUVKLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQU9PLGdCQUFnQixRQUFRLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFrQmxELFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsUUFNTixLQUFLO0FBQUEsR0FDVjtBQUNIO0FBS08sU0FBUywwQkFDZCxVQUNBLFVBQ0EsUUFBZ0IsSUFDUjtBQUNSLE1BQU0sYUFBYSxXQUNmLGlDQUFpQyxRQUFRLE9BQ3pDO0FBRUosU0FBTyxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNkJBT08sZ0JBQWdCLFFBQVEsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBZ0JsRCxVQUFVO0FBQUE7QUFBQTtBQUFBLFFBR04sS0FBSztBQUFBLEdBQ1Y7QUFDSDtBQU1PLFNBQVMsOEJBQ2QsVUFDQSxVQUNBLFFBQWdCLElBQ1I7QUFDUixNQUFNLGFBQWEsV0FDZixxQ0FBcUMsUUFBUSxPQUM3QztBQUVKLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQU9PLGdCQUFnQixRQUFRLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBb0JsRCxVQUFVO0FBQUE7QUFBQTtBQUFBLFFBR04sS0FBSztBQUFBLEdBQ1Y7QUFDSDtBQW9ETyxTQUFTLDhCQUNkLFVBQ0EsVUFDQSxRQUFnQixJQUNSO0FBQ1IsTUFBTSxhQUFhLFdBQ2YsaUNBQWlDLFFBQVEsT0FDekM7QUFFSixTQUFPLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFPTyxnQkFBZ0IsUUFBUSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBZWxELFVBQVU7QUFBQTtBQUFBO0FBQUEsUUFHTixLQUFLO0FBQUEsR0FDVjtBQUNIO0FBTU8sU0FBUywrQkFDZCxVQUNBLFVBQ0EsUUFBZ0IsSUFDUjtBQUNSLE1BQU0sYUFBYSxXQUNmLGlDQUFpQyxRQUFRLE9BQ3pDO0FBRUosU0FBTyxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNkJBT08sZ0JBQWdCLFFBQVEsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxJQTJCbEQsVUFBVTtBQUFBO0FBQUE7QUFBQSxRQUdOLEtBQUs7QUFBQSxHQUNWO0FBQ0g7QUFLTyxTQUFTLHlCQUNkLFVBQ0EsY0FDQSxVQUNBLFFBQWdCLElBQ1I7QUFDUixNQUFNLGFBQWEsV0FDZixpQ0FBaUMsUUFBUSxPQUN6QztBQUdKLE1BQUk7QUFDRixZQUFRLGNBQWM7QUFBQSxNQUNwQixLQUFLO0FBQ0gsZUFBTywyQkFBMkIsVUFBVSxVQUFVLEtBQUs7QUFBQSxNQUM3RCxLQUFLO0FBQ0gsZUFBTywwQkFBMEIsVUFBVSxVQUFVLEtBQUs7QUFBQSxNQUM1RCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQUEsTUFDTCxLQUFLO0FBQ0gsZUFBTyw4QkFBOEIsVUFBVSxVQUFVLEtBQUs7QUFBQSxNQUNoRSxLQUFLO0FBQ0gsZUFBTyw4QkFBOEIsVUFBVSxVQUFVLEtBQUs7QUFBQSxNQUNoRSxLQUFLO0FBQ0gsZUFBTywrQkFBK0IsVUFBVSxVQUFVLEtBQUs7QUFBQSxJQUNuRTtBQUlGLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQU9PLGdCQUFnQixRQUFRLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBZ0NsRCxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxRQUtOLEtBQUs7QUFBQSxHQUNWO0FBQ0g7QUFNTyxTQUFTLDZCQUNkLFVBQ0EsVUFDUTtBQUNSLE1BQU0sYUFBYSxXQUNmLDBCQUEwQixRQUFRLE9BQ2xDO0FBRUosU0FBTyxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQVNPLGdCQUFnQixRQUFRLENBQUM7QUFBQSxJQUNsRCxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0FVWDtBQUNIOzs7QUN4WU8sU0FBUyxzQkFBc0IsVUFBa0IsVUFBNkI7QUFDbkYsTUFBTSxhQUFhLFdBQ2YsMEJBQTBCLFFBQVEsT0FDbEM7QUFFSixTQUFPLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQVdPLGdCQUFnQixRQUFRLENBQUM7QUFBQSxJQUNsRCxVQUFVO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsR0E0Qlg7QUFDSDtBQU1PLFNBQVMsdUJBQXVCLFVBQTBCO0FBQy9ELFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFTTyxnQkFBZ0IsUUFBUSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBTW5EO0FBQ0g7QUFzQ08sU0FBUyxzQkFBc0IsVUFBa0IsVUFBNkI7QUFDbkYsTUFBTSxhQUFhLFdBQ2YsNENBQTRDLFFBQVEsT0FDcEQ7QUFFSixTQUFPLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFPTyxnQkFBZ0IsUUFBUSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLElBWWxELFVBQVU7QUFBQTtBQUFBO0FBQUEsR0FHWDtBQUNIO0FBc0NPLFNBQVMsNEJBQTRCLFVBQTBCO0FBQ3BFLFNBQU8sYUFBYTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLDZCQU9PLGdCQUFnQixRQUFRLENBQUM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQVVuRDtBQUNIO0FBS08sU0FBUyx5QkFBeUIsVUFBMEI7QUFDakUsU0FBTyxhQUFhO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsNkJBT08sZ0JBQWdCLFFBQVEsQ0FBQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLEdBc0JuRDtBQUNIO0FBTU8sU0FBUyx1QkFBdUIsVUFBa0IsVUFBNkI7QUFDcEYsTUFBTSxhQUFhLFdBQ2Ysb0RBQW9ELFFBQVEsT0FDNUQ7QUFFSixTQUFPLGFBQWE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSw2QkFPTyxnQkFBZ0IsUUFBUSxDQUFDO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsSUFtQmxELFVBQVU7QUFBQTtBQUFBO0FBQUE7QUFBQSxHQUlYO0FBQ0g7OztBQ2xOQSxJQUFJO0FBS0osU0FBUyxtQkFBeUI7QUFDaEMsaUJBQWUsbUJBQW1CO0FBQUEsSUFDaEMsU0FBUztBQUFBO0FBQUEsSUFDVCxZQUFZO0FBQUEsSUFDWixZQUFZO0FBQUEsRUFDZCxDQUFDLEdBRUQsUUFBUSxNQUFNLGdEQUFnRCxhQUFhLFlBQVksQ0FBQyxFQUFFO0FBQzVGO0FBS0EsZUFBZSxjQUFjLE9BQXlEO0FBQ3BGLE1BQU0sWUFBWSxLQUFLLElBQUk7QUFFM0IsTUFBSTtBQUNGLFFBQUksT0FDQTtBQUdKLElBQUksTUFBTSxLQUFLLE1BQU0sVUFBVSxLQUU3QixRQUFRLHdCQUF3QixNQUFNLFlBQVksTUFBTSxRQUFRLEdBQ2hFLGFBQWEsZUFHYixRQUFRLCtCQUErQixNQUFNLFlBQVksTUFBTSxRQUFRLEdBQ3ZFLGFBQWE7QUFJZixRQUFNLFlBRFMsTUFBTSxhQUFhLE1BQU0sS0FBSyxHQUNyQixRQUFRO0FBRWhDLFFBQUksU0FBUyxXQUFXO0FBQ3RCLGFBQU87QUFBQSxRQUNMLE9BQU87QUFBQSxRQUNQLGNBQWMsS0FBSyxJQUFJLElBQUk7QUFBQSxNQUM3QjtBQUlGLFFBQU0sWUFBWSxhQUFhLGNBQWMsVUFBVSxLQUFLLEdBQ3RELE9BQW1CLENBQUM7QUFFMUIsYUFBVyxDQUFDLFFBQVEsV0FBVyxLQUFLLFdBQVc7QUFDN0MsVUFBTSxlQUFlLFlBQVksQ0FBQyxHQUU1QixNQUFnQjtBQUFBLFFBQ3BCLEtBQUs7QUFBQSxRQUNMLFVBQVUsYUFBYSxhQUFhLGFBQWEsUUFBUSxLQUFLO0FBQUEsUUFDOUQsT0FBTyxhQUFhLHlCQUF5QixhQUFhLE9BQU87QUFBQSxRQUNqRSxjQUFjLGFBQWEseUJBQXlCLGFBQWEsY0FBYztBQUFBLFFBQy9FLFNBQVMsYUFBYSxhQUFhLGFBQWEsT0FBTztBQUFBLFFBQ3ZELGNBQWMsYUFBYSxhQUFhLGFBQWEsWUFBWTtBQUFBLFFBQ2pFLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVztBQUFBLFFBQy9ELFFBQVEsYUFBYSxVQUFVLGFBQWE7QUFBQSxNQUM5QztBQUVBLFdBQUssS0FBSyxHQUFHO0FBQUEsSUFDZjtBQUVBLFdBQU87QUFBQSxNQUNMLE9BQU87QUFBQSxNQUNQO0FBQUEsTUFDQTtBQUFBLE1BQ0EsY0FBYyxLQUFLLElBQUksSUFBSTtBQUFBLElBQzdCO0FBQUEsRUFDRixTQUFTQyxRQUFPO0FBQ2Qsa0JBQVEsTUFBTSwwQkFBMEJBLE1BQUssR0FDdkNBO0FBQUEsRUFDUjtBQUNGO0FBS0EsZUFBZSxXQUFXLE9BQW1EO0FBQzNFLE1BQU0sWUFBWSxLQUFLLElBQUk7QUFFM0IsTUFBSTtBQUNGLFFBQUk7QUFFSixJQUFJLE1BQU0sWUFDUixRQUFRO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsTUFDTixNQUFNO0FBQUEsSUFDUixJQUVBLFFBQVE7QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxNQUNOLE1BQU07QUFBQSxJQUNSO0FBSUYsUUFBTSxZQURTLE1BQU0sYUFBYSxNQUFNLEtBQUssR0FDckIsUUFBUTtBQUVoQyxRQUFJLFNBQVMsV0FBVztBQUN0QixhQUFPO0FBQUEsUUFDTCxPQUFPO0FBQUEsUUFDUCxjQUFjLEtBQUssSUFBSSxJQUFJO0FBQUEsTUFDN0I7QUFJRixRQUFNLGVBQWUsU0FBUyxDQUFDLEdBQ3pCLFVBQVU7QUFBQSxNQUNkLEtBQUssYUFBYSxhQUFhLGFBQWEsR0FBRyxLQUFLO0FBQUEsTUFDcEQsVUFBVSxhQUFhLGFBQWEsYUFBYSxRQUFRLEtBQUs7QUFBQSxNQUM5RCxPQUFPLGFBQWEseUJBQXlCLFVBQVUsVUFBVTtBQUFBLElBQ25FLEdBR00sZ0JBQWdCLGFBQWEsY0FBYyxVQUFVLFNBQVMsR0FDOUQsV0FBc0IsQ0FBQztBQUU3QixhQUFXLENBQUMsWUFBWSxlQUFlLEtBQUssZUFBZTtBQUN6RCxVQUFNLGVBQWUsZ0JBQWdCLENBQUMsR0FHaEMsYUFJRCxDQUFDLEdBRUEsa0JBQWtCLGFBQWEsY0FBYyxpQkFBaUIsY0FBYztBQUNsRixlQUFXLENBQUMsY0FBYyxpQkFBaUIsS0FBSyxpQkFBaUI7QUFDL0QsWUFBSSxDQUFDLGFBQWM7QUFHbkIsWUFBTSxVQUFxRSxDQUFDO0FBQzVFLGlCQUFXLFdBQVcsbUJBQW1CO0FBQ3ZDLGNBQU0sWUFBWSxhQUFhLGFBQWEsUUFBUSxTQUFTO0FBQzdELFVBQUksYUFDRixRQUFRLEtBQUs7QUFBQSxZQUNYLFNBQVM7QUFBQSxZQUNULE1BQU0sUUFBUSxhQUFhLEVBQUUsQ0FBQyxRQUFRLFdBQVcsVUFBVSxLQUFLLElBQUksR0FBRyxRQUFRLFdBQVcsTUFBTSxJQUFJO0FBQUEsVUFDdEcsQ0FBQztBQUFBLFFBRUw7QUFFQSxtQkFBVyxLQUFLO0FBQUEsVUFDZCxRQUFRO0FBQUEsVUFDUixNQUFNLGFBQWEseUJBQXlCLG1CQUFtQixlQUFlO0FBQUEsVUFDOUUsU0FBUyxRQUFRLFNBQVMsSUFBSSxVQUFVO0FBQUEsUUFDMUMsQ0FBQztBQUFBLE1BQ0g7QUFFQSxVQUFNLFVBQW1CO0FBQUEsUUFDdkIsS0FBSztBQUFBLFFBQ0wsUUFBUSxhQUFhLGFBQWEsYUFBYSxhQUFhLEtBQUs7QUFBQSxRQUNqRSxPQUFPLGFBQWEseUJBQXlCLGlCQUFpQixjQUFjO0FBQUEsUUFDNUUsTUFBTSxhQUFhLHlCQUF5QixpQkFBaUIsYUFBYTtBQUFBLFFBQzFFLFlBQVksV0FBVyxTQUFTLElBQUksYUFBYTtBQUFBLE1BQ25EO0FBRUEsZUFBUyxLQUFLLE9BQU87QUFBQSxJQUN2QjtBQUVBLFdBQU87QUFBQSxNQUNMLE9BQU87QUFBQSxNQUNQLEtBQUs7QUFBQSxNQUNMO0FBQUEsTUFDQSxjQUFjLEtBQUssSUFBSSxJQUFJO0FBQUEsSUFDN0I7QUFBQSxFQUNGLFNBQVNBLFFBQU87QUFDZCxrQkFBUSxNQUFNLHVCQUF1QkEsTUFBSyxHQUNwQ0E7QUFBQSxFQUNSO0FBQ0Y7QUFLQSxlQUFlLGtCQUFrQixPQUFpRTtBQUNoRyxNQUFNLFlBQVksS0FBSyxJQUFJO0FBRTNCLE1BQUk7QUFDRixRQUFNLFVBQXlCO0FBQUEsTUFDN0IsVUFBVSxNQUFNO0FBQUEsTUFDaEIsU0FBUyxNQUFNO0FBQUEsTUFDZixRQUFRLE1BQU07QUFBQSxNQUNkLGdCQUFnQixNQUFNO0FBQUEsTUFDdEIsT0FBTyxNQUFNLFNBQVM7QUFBQSxNQUN0QixRQUFRLE1BQU0sVUFBVTtBQUFBLElBQzFCLEdBR0ksT0FDQTtBQUVKLElBQUksTUFBTSxVQUFVLENBQUMsTUFBTSxRQUV6QixRQUFRLHlCQUF5QixNQUFNLFFBQVEsTUFBTSxVQUFVLFFBQVEsS0FBSyxJQUNuRSxNQUFNLFlBQVksTUFBTSxTQUVqQyxRQUFRLHVCQUF1QixNQUFNLFVBQVUsTUFBTSxRQUFRLE1BQU0sVUFBVSxRQUFRLEtBQUssS0FHMUYsUUFBUSxpQkFBaUIsTUFBTSxTQUFTLElBQUksT0FBTyxHQUNuRCxhQUFhLHNCQUFzQixNQUFNLFNBQVMsSUFBSSxPQUFPO0FBSy9ELFFBQU0sWUFEUyxNQUFNLGFBQWEsTUFBTSxLQUFLLEdBQ3JCLFFBQVEsVUFHNUIsYUFBYSxTQUFTO0FBQzFCLFFBQUksWUFBWTtBQUNkLFVBQU0sY0FBYyxNQUFNLGFBQWEsTUFBTSxVQUFVO0FBQ3ZELFVBQUksWUFBWSxRQUFRLFNBQVMsU0FBUyxHQUFHO0FBQzNDLFlBQU0sYUFBYSxhQUFhLGFBQWEsWUFBWSxRQUFRLFNBQVMsQ0FBQyxFQUFFLEtBQUs7QUFDbEYscUJBQWEsYUFBYSxTQUFTLFlBQVksRUFBRSxJQUFJLFNBQVM7QUFBQSxNQUNoRTtBQUFBLElBQ0Y7QUFHQSxRQUFNLE9BQW1CLFNBQVMsSUFBSSxDQUFDLGFBQTRDO0FBQUEsTUFDakYsS0FBSyxhQUFhLGFBQWEsUUFBUSxHQUFHLEtBQUs7QUFBQSxNQUMvQyxVQUFVLGFBQWEsYUFBYSxRQUFRLFFBQVEsS0FBSztBQUFBLE1BQ3pELE9BQU8sUUFBUSxRQUFRLEVBQUUsQ0FBQyxRQUFRLE1BQU0sVUFBVSxLQUFLLElBQUksR0FBRyxRQUFRLE1BQU0sTUFBTSxJQUFJLENBQUM7QUFBQSxNQUN2RixjQUFjLFFBQVEsZUFBZSxFQUFFLENBQUMsUUFBUSxhQUFhLFVBQVUsS0FBSyxJQUFJLEdBQUcsUUFBUSxhQUFhLE1BQU0sSUFBSTtBQUFBLE1BQ2xILFNBQVMsYUFBYSxhQUFhLFFBQVEsT0FBTztBQUFBLE1BQ2xELGFBQWEsYUFBYSxhQUFhLFFBQVEsV0FBVztBQUFBLElBQzVELEVBQUUsR0FHSSxlQUF1QyxDQUFDO0FBQzlDLGFBQVcsT0FBTyxNQUFNO0FBQ3RCLFVBQU0sU0FBUyxJQUFJLFNBQVMsTUFBTSxHQUFHLEVBQUUsQ0FBQztBQUN4QyxNQUFJLFVBQVUsY0FBYyxNQUFNLE1BQ2hDLGFBQWEsTUFBTSxLQUFLLGFBQWEsTUFBTSxLQUFLLEtBQUs7QUFBQSxJQUV6RDtBQUVBLFdBQU87QUFBQSxNQUNMO0FBQUEsTUFDQTtBQUFBLE1BQ0EsVUFBVSxRQUFRLFVBQVUsS0FBSyxLQUFLLFNBQVM7QUFBQSxNQUMvQyxRQUFRO0FBQUEsUUFDTixVQUFVO0FBQUEsTUFDWjtBQUFBLE1BQ0EsY0FBYyxLQUFLLElBQUksSUFBSTtBQUFBLElBQzdCO0FBQUEsRUFDRixTQUFTQSxRQUFPO0FBQ2Qsa0JBQVEsTUFBTSw4QkFBOEJBLE1BQUssR0FDM0NBO0FBQUEsRUFDUjtBQUNGO0FBS0EsZUFBZSxZQUFZLE9BQXFEO0FBQzlFLE1BQU0sWUFBWSxLQUFLLElBQUk7QUFFM0IsTUFBSTtBQUVGLFFBQU0sUUFBUTtBQUFBLE1BQ1osTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sTUFBTTtBQUFBLE1BQ04sTUFBTSxTQUFTO0FBQUEsSUFDakIsR0FNTSxlQUpTLE1BQU0sYUFBYSxNQUFNLEtBQUssR0FDckIsUUFBUSxTQUdXLElBQUksQ0FBQyxhQUE0QztBQUFBLE1BQzFGLEtBQUssYUFBYSxhQUFhLFFBQVEsVUFBVSxLQUFLO0FBQUEsTUFDdEQsVUFBVSxhQUFhLGFBQWEsUUFBUSxlQUFlLEtBQUs7QUFBQSxNQUNoRSxPQUFPLFFBQVEsZUFBZSxFQUFFLENBQUMsUUFBUSxhQUFhLFVBQVUsS0FBSyxJQUFJLEdBQUcsUUFBUSxhQUFhLE1BQU0sSUFBSSxDQUFDO0FBQUEsTUFDNUcsY0FBZSxhQUFhLGFBQWEsUUFBUSxZQUFZLEtBQXNCO0FBQUEsTUFDbkYsY0FBYyxhQUFhLGFBQWEsUUFBUSxZQUFZO0FBQUEsSUFDOUQsRUFBRSxHQUdJLGlCQUF5QyxDQUFDO0FBQ2hELGFBQVcsT0FBTyxhQUFhO0FBQzdCLFVBQU0sVUFBVSxJQUFJLGdCQUFnQjtBQUNwQyxxQkFBZSxPQUFPLEtBQUssZUFBZSxPQUFPLEtBQUssS0FBSztBQUFBLElBQzdEO0FBR0EsUUFBSTtBQUNKLFFBQUksTUFBTSxnQkFBZ0I7QUFDeEIsVUFBTSxlQUFlLDZCQUE2QixNQUFNLFVBQVUsTUFBTSxRQUFRO0FBR2hGLDRCQUZzQixNQUFNLGFBQWEsTUFBTSxZQUFZLEdBRXhCLFFBQVEsU0FBUyxJQUFJLENBQUMsYUFBNEM7QUFBQSxRQUNuRyxNQUFNLGFBQWEsYUFBYSxRQUFRLElBQUksS0FBSztBQUFBLFFBQ2pELGFBQWEsYUFBYSxhQUFhLFFBQVEsaUJBQWlCO0FBQUEsTUFDbEUsRUFBRTtBQUFBLElBQ0o7QUFFQSxXQUFPO0FBQUEsTUFDTCxVQUFVLE1BQU07QUFBQSxNQUNoQjtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQSxjQUFjLEtBQUssSUFBSSxJQUFJO0FBQUEsSUFDN0I7QUFBQSxFQUNGLFNBQVNBLFFBQU87QUFDZCxrQkFBUSxNQUFNLHdCQUF3QkEsTUFBSyxHQUNyQ0E7QUFBQSxFQUNSO0FBQ0Y7QUFLQSxlQUFlLFlBQVksT0FBcUQ7QUFDOUUsTUFBTSxZQUFZLEtBQUssSUFBSTtBQUUzQixNQUFJO0FBRUYsUUFBTTtBQUFBLE1BQ0o7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLE1BQ0E7QUFBQSxNQUNBO0FBQUEsTUFDQTtBQUFBLElBQ0YsSUFBSSxNQUFNLFFBQVEsSUFBSTtBQUFBLE1BQ3BCLGFBQWEsTUFBTSxzQkFBc0IsTUFBTSxVQUFVLE1BQU0sUUFBUSxDQUFDO0FBQUEsTUFDeEUsYUFBYSxNQUFNLHVCQUF1QixNQUFNLFFBQVEsQ0FBQztBQUFBLE1BQ3pELGFBQWEsTUFBTSxzQkFBc0IsTUFBTSxVQUFVLE1BQU0sUUFBUSxDQUFDO0FBQUEsTUFDeEUsYUFBYSxNQUFNLDRCQUE0QixNQUFNLFFBQVEsQ0FBQztBQUFBLE1BQzlELGFBQWEsTUFBTSx5QkFBeUIsTUFBTSxRQUFRLENBQUM7QUFBQSxNQUMzRCxNQUFNLG1CQUNGLGFBQWEsTUFBTSx1QkFBdUIsTUFBTSxVQUFVLE1BQU0sUUFBUSxDQUFDLElBQ3pFLFFBQVEsUUFBUSxFQUFFLFNBQVMsRUFBRSxVQUFVLENBQUMsRUFBRSxFQUFFLENBQUM7QUFBQSxJQUNuRCxDQUFDLEdBRUssbUJBQW1CLGVBQWUsUUFBUTtBQUVoRCxRQUFJLGlCQUFpQixXQUFXO0FBQzlCLGFBQU87QUFBQSxRQUNMLE9BQU87QUFBQSxRQUNQLGNBQWMsS0FBSyxJQUFJLElBQUk7QUFBQSxNQUM3QjtBQUdGLFFBQU0sZUFBZSxpQkFBaUIsQ0FBQyxHQUdqQyxXQUEwQztBQUFBLE1BQzlDLEtBQUssYUFBYSxhQUFhLGFBQWEsR0FBRyxLQUFLO0FBQUEsTUFDcEQsVUFBVSxhQUFhLGFBQWEsYUFBYSxRQUFRLEtBQUs7QUFBQSxNQUM5RCxPQUFPLGFBQWEseUJBQXlCLGtCQUFrQixPQUFPO0FBQUEsTUFDdEUsY0FBYyxhQUFhLHlCQUF5QixrQkFBa0IsY0FBYztBQUFBLE1BQ3BGLFNBQVMsYUFBYSxhQUFhLGFBQWEsT0FBTztBQUFBLE1BQ3ZELGNBQWMsYUFBYSxhQUFhLGFBQWEsWUFBWTtBQUFBLE1BQ2pFLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVztBQUFBLE1BQy9ELGdCQUFnQixhQUFhLGFBQWEsYUFBYSxjQUFjO0FBQUEsTUFDckUsUUFBUTtBQUFBLElBQ1Y7QUFHQSxhQUFTLHFCQUFxQixnQkFBZ0IsUUFBUSxTQUNuRCxJQUFJLENBQUMsTUFBcUMsYUFBYSxhQUFhLEVBQUUsUUFBUSxDQUFDLEVBQy9FLE9BQU8sQ0FBQyxTQUF5QixDQUFDLENBQUMsSUFBSTtBQUcxQyxRQUFNLFdBQVcsZUFBZSxRQUFRLFNBQ3JDLElBQUksQ0FBQyxNQUFxQyxhQUFhLGFBQWEsRUFBRSxLQUFLLENBQUMsRUFDNUUsT0FBTyxDQUFDLE1BQW1CLENBQUMsQ0FBQyxDQUFDO0FBQ2pDLElBQUksU0FBUyxTQUFTLE1BQ3BCLFNBQVMsV0FBVztBQUl0QixRQUFNLFdBQVcsY0FBYyxRQUFRLFNBQVMsSUFBSSxDQUFDLE9BQXNDO0FBQUEsTUFDekYsTUFBTSxhQUFhLGFBQWEsRUFBRSxXQUFXLEtBQUs7QUFBQSxNQUNsRCxNQUFNLGFBQWEsYUFBYSxFQUFFLFdBQVc7QUFBQSxNQUM3QyxhQUFhLGFBQWEsYUFBYSxFQUFFLGlCQUFpQjtBQUFBLElBQzVELEVBQUU7QUFNRixRQUxJLFNBQVMsU0FBUyxNQUNwQixTQUFTLGlCQUFpQixXQUl4QixhQUFhLFFBQVEsU0FBUyxTQUFTLEdBQUc7QUFDNUMsVUFBTSxnQkFBZ0IsYUFBYSxRQUFRLFNBQVMsQ0FBQyxHQUMvQyxTQUFTLGFBQWEsYUFBYSxjQUFjLE1BQU07QUFDN0QsT0FBSSxXQUFXLGNBQWMsV0FBVyxlQUFlLFdBQVcsZUFDaEUsU0FBUyxTQUFTLFNBRXBCLFNBQVMsY0FBYyxhQUFhLGFBQWEsY0FBYyxXQUFXO0FBQUEsSUFDNUU7QUFHQSxJQUFJLE1BQU0sb0JBQW9CLGdCQUFnQixRQUFRLFNBQVMsU0FBUyxNQUN0RSxTQUFTLFlBQVksZ0JBQWdCLFFBQVEsU0FBUyxJQUFJLENBQUMsT0FBc0M7QUFBQSxNQUMvRixZQUFZLGFBQWEsYUFBYSxFQUFFLFVBQVUsS0FBSztBQUFBLE1BQ3ZELFdBQVcsYUFBYSxhQUFhLEVBQUUsU0FBUztBQUFBLE1BQ2hELFVBQVUsYUFBYSxhQUFhLEVBQUUsUUFBUTtBQUFBLElBQ2hELEVBQUU7QUFJSixRQUFNLGVBQWUsTUFBTSxTQUFTLE1BQU0sR0FBRyxFQUFFLENBQUM7QUFDaEQsV0FBSSxjQUFjLFlBQVksTUFDNUIsU0FBUyxjQUFjLGNBQWMsWUFBWSxJQUc1QztBQUFBLE1BQ0wsT0FBTztBQUFBLE1BQ1A7QUFBQSxNQUNBLGNBQWMsS0FBSyxJQUFJLElBQUk7QUFBQSxJQUM3QjtBQUFBLEVBQ0YsU0FBU0EsUUFBTztBQUNkLGtCQUFRLE1BQU0sd0JBQXdCQSxNQUFLLEdBQ3JDQTtBQUFBLEVBQ1I7QUFDRjtBQUtBLGVBQWUsT0FBTztBQUVwQixtQkFBaUI7QUFFakIsTUFBTSxTQUFTLElBQUk7QUFBQSxJQUNqQjtBQUFBLE1BQ0UsTUFBTTtBQUFBLE1BQ04sU0FBUztBQUFBLElBQ1g7QUFBQSxJQUNBO0FBQUEsTUFDRSxjQUFjO0FBQUEsUUFDWixPQUFPLENBQUM7QUFBQSxNQUNWO0FBQUEsSUFDRjtBQUFBLEVBQ0Y7QUFHQSxTQUFPLGtCQUFrQix3QkFBd0IsYUFDeEM7QUFBQSxJQUNMLE9BQU87QUFBQSxNQUNMO0FBQUEsUUFDRSxNQUFNO0FBQUEsUUFDTixhQUNFO0FBQUEsUUFDRixhQUFhO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsWUFDVixZQUFZO0FBQUEsY0FDVixNQUFNO0FBQUEsY0FDTixhQUNFO0FBQUEsWUFDSjtBQUFBLFlBQ0EsVUFBVTtBQUFBLGNBQ1IsTUFBTTtBQUFBLGNBQ04sTUFBTSxDQUFDLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFBQSxjQUM3QixhQUFhO0FBQUEsWUFDZjtBQUFBLFVBQ0Y7QUFBQSxVQUNBLFVBQVUsQ0FBQyxZQUFZO0FBQUEsUUFDekI7QUFBQSxNQUNGO0FBQUEsTUFDQTtBQUFBLFFBQ0UsTUFBTTtBQUFBLFFBQ04sYUFDRTtBQUFBLFFBQ0YsYUFBYTtBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFlBQ1YsVUFBVTtBQUFBLGNBQ1IsTUFBTTtBQUFBLGNBQ04sYUFBYTtBQUFBLFlBQ2Y7QUFBQSxZQUNBLGVBQWU7QUFBQSxjQUNiLE1BQU07QUFBQSxjQUNOLGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxXQUFXO0FBQUEsY0FDVCxNQUFNO0FBQUEsY0FDTixhQUFhO0FBQUEsWUFDZjtBQUFBLFlBQ0EsVUFBVTtBQUFBLGNBQ1IsTUFBTTtBQUFBLGNBQ04sTUFBTSxDQUFDLE1BQU0sTUFBTSxNQUFNLElBQUk7QUFBQSxjQUM3QixhQUFhO0FBQUEsWUFDZjtBQUFBLFVBQ0Y7QUFBQSxVQUNBLFVBQVUsQ0FBQyxZQUFZLGVBQWU7QUFBQSxRQUN4QztBQUFBLE1BQ0Y7QUFBQSxNQUNBO0FBQUEsUUFDRSxNQUFNO0FBQUEsUUFDTixhQUNFO0FBQUEsUUFDRixhQUFhO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsWUFDVixPQUFPO0FBQUEsY0FDTCxNQUFNO0FBQUEsY0FDTixhQUFhO0FBQUEsWUFDZjtBQUFBLFlBQ0EsUUFBUTtBQUFBLGNBQ04sTUFBTTtBQUFBLGNBQ04sTUFBTSxDQUFDLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxLQUFLLEtBQUssS0FBSyxHQUFHO0FBQUEsY0FDbEQsYUFDRTtBQUFBLFlBQ0o7QUFBQSxZQUNBLGdCQUFnQjtBQUFBLGNBQ2QsTUFBTTtBQUFBLGNBQ04sYUFBYTtBQUFBLFlBQ2Y7QUFBQSxZQUNBLFVBQVU7QUFBQSxjQUNSLE1BQU07QUFBQSxjQUNOLFFBQVE7QUFBQSxjQUNSLGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxRQUFRO0FBQUEsY0FDTixNQUFNO0FBQUEsY0FDTixRQUFRO0FBQUEsY0FDUixhQUFhO0FBQUEsWUFDZjtBQUFBLFlBQ0EsU0FBUztBQUFBLGNBQ1AsTUFBTTtBQUFBLGNBQ04sT0FBTyxFQUFFLE1BQU0sU0FBUztBQUFBLGNBQ3hCLGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxVQUFVO0FBQUEsY0FDUixNQUFNO0FBQUEsY0FDTixNQUFNLENBQUMsTUFBTSxNQUFNLE1BQU0sSUFBSTtBQUFBLGNBQzdCLGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxPQUFPO0FBQUEsY0FDTCxNQUFNO0FBQUEsY0FDTixTQUFTO0FBQUEsY0FDVCxTQUFTO0FBQUEsY0FDVCxTQUFTO0FBQUEsY0FDVCxhQUFhO0FBQUEsWUFDZjtBQUFBLFlBQ0EsUUFBUTtBQUFBLGNBQ04sTUFBTTtBQUFBLGNBQ04sU0FBUztBQUFBLGNBQ1QsU0FBUztBQUFBLGNBQ1QsYUFBYTtBQUFBLFlBQ2Y7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFBQSxNQUNBO0FBQUEsUUFDRSxNQUFNO0FBQUEsUUFDTixhQUNFO0FBQUEsUUFDRixhQUFhO0FBQUEsVUFDWCxNQUFNO0FBQUEsVUFDTixZQUFZO0FBQUEsWUFDVixVQUFVO0FBQUEsY0FDUixNQUFNO0FBQUEsY0FDTixhQUFhO0FBQUEsWUFDZjtBQUFBLFlBQ0EsY0FBYztBQUFBLGNBQ1osTUFBTTtBQUFBLGNBQ04sTUFBTTtBQUFBLGdCQUNKO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGdCQUNBO0FBQUEsZ0JBQ0E7QUFBQSxnQkFDQTtBQUFBLGNBQ0Y7QUFBQSxjQUNBLGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxnQkFBZ0I7QUFBQSxjQUNkLE1BQU07QUFBQSxjQUNOLFNBQVM7QUFBQSxjQUNULGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxVQUFVO0FBQUEsY0FDUixNQUFNO0FBQUEsY0FDTixNQUFNLENBQUMsTUFBTSxNQUFNLE1BQU0sSUFBSTtBQUFBLGNBQzdCLGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxPQUFPO0FBQUEsY0FDTCxNQUFNO0FBQUEsY0FDTixTQUFTO0FBQUEsY0FDVCxTQUFTO0FBQUEsY0FDVCxTQUFTO0FBQUEsY0FDVCxhQUFhO0FBQUEsWUFDZjtBQUFBLFVBQ0Y7QUFBQSxVQUNBLFVBQVUsQ0FBQyxVQUFVO0FBQUEsUUFDdkI7QUFBQSxNQUNGO0FBQUEsTUFDQTtBQUFBLFFBQ0UsTUFBTTtBQUFBLFFBQ04sYUFDRTtBQUFBLFFBQ0YsYUFBYTtBQUFBLFVBQ1gsTUFBTTtBQUFBLFVBQ04sWUFBWTtBQUFBLFlBQ1YsVUFBVTtBQUFBLGNBQ1IsTUFBTTtBQUFBLGNBQ04sYUFBYTtBQUFBLFlBQ2Y7QUFBQSxZQUNBLGtCQUFrQjtBQUFBLGNBQ2hCLE1BQU07QUFBQSxjQUNOLFNBQVM7QUFBQSxjQUNULGFBQWE7QUFBQSxZQUNmO0FBQUEsWUFDQSxVQUFVO0FBQUEsY0FDUixNQUFNO0FBQUEsY0FDTixNQUFNLENBQUMsTUFBTSxNQUFNLE1BQU0sSUFBSTtBQUFBLGNBQzdCLGFBQWE7QUFBQSxZQUNmO0FBQUEsVUFDRjtBQUFBLFVBQ0EsVUFBVSxDQUFDLFVBQVU7QUFBQSxRQUN2QjtBQUFBLE1BQ0Y7QUFBQSxJQUNGO0FBQUEsRUFDRixFQUNELEdBR0QsT0FBTyxrQkFBa0IsdUJBQXVCLE9BQU8sWUFBWTtBQUNqRSxRQUFNLEVBQUUsTUFBTSxXQUFXLEtBQUssSUFBSSxRQUFRO0FBRTFDLFFBQUk7QUFDRixVQUFJLFNBQVMsa0JBQWtCO0FBRTdCLFlBQU0sU0FBUyxNQUFNLGNBRFAsSUFDMEI7QUFDeEMsZUFBTztBQUFBLFVBQ0wsU0FBUztBQUFBLFlBQ1A7QUFBQSxjQUNFLE1BQU07QUFBQSxjQUNOLE1BQU0sS0FBSyxVQUFVLFFBQVEsTUFBTSxDQUFDO0FBQUEsWUFDdEM7QUFBQSxVQUNGO0FBQUEsUUFDRjtBQUFBLE1BQ0Y7QUFFQSxVQUFJLFNBQVMsZUFBZTtBQUUxQixZQUFNLFNBQVMsTUFBTSxXQURQLElBQ3VCO0FBQ3JDLGVBQU87QUFBQSxVQUNMLFNBQVM7QUFBQSxZQUNQO0FBQUEsY0FDRSxNQUFNO0FBQUEsY0FDTixNQUFNLEtBQUssVUFBVSxRQUFRLE1BQU0sQ0FBQztBQUFBLFlBQ3RDO0FBQUEsVUFDRjtBQUFBLFFBQ0Y7QUFBQSxNQUNGO0FBRUEsVUFBSSxTQUFTLHNCQUFzQjtBQUVqQyxZQUFNLFNBQVMsTUFBTSxrQkFEUCxJQUM4QjtBQUM1QyxlQUFPO0FBQUEsVUFDTCxTQUFTO0FBQUEsWUFDUDtBQUFBLGNBQ0UsTUFBTTtBQUFBLGNBQ04sTUFBTSxLQUFLLFVBQVUsUUFBUSxNQUFNLENBQUM7QUFBQSxZQUN0QztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLFVBQUksU0FBUyxnQkFBZ0I7QUFFM0IsWUFBTSxTQUFTLE1BQU0sWUFEUCxJQUN3QjtBQUN0QyxlQUFPO0FBQUEsVUFDTCxTQUFTO0FBQUEsWUFDUDtBQUFBLGNBQ0UsTUFBTTtBQUFBLGNBQ04sTUFBTSxLQUFLLFVBQVUsUUFBUSxNQUFNLENBQUM7QUFBQSxZQUN0QztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLFVBQUksU0FBUyxnQkFBZ0I7QUFFM0IsWUFBTSxTQUFTLE1BQU0sWUFEUCxJQUN3QjtBQUN0QyxlQUFPO0FBQUEsVUFDTCxTQUFTO0FBQUEsWUFDUDtBQUFBLGNBQ0UsTUFBTTtBQUFBLGNBQ04sTUFBTSxLQUFLLFVBQVUsUUFBUSxNQUFNLENBQUM7QUFBQSxZQUN0QztBQUFBLFVBQ0Y7QUFBQSxRQUNGO0FBQUEsTUFDRjtBQUVBLFlBQU0sSUFBSSxNQUFNLGlCQUFpQixJQUFJLEVBQUU7QUFBQSxJQUN6QyxTQUFTQSxRQUFPO0FBQ2QsVUFBTSxlQUFlQSxrQkFBaUIsUUFBUUEsT0FBTSxVQUFVLE9BQU9BLE1BQUs7QUFDMUUscUJBQVEsTUFBTSwwQkFBMEIsSUFBSSxJQUFJQSxNQUFLLEdBRTlDO0FBQUEsUUFDTCxTQUFTO0FBQUEsVUFDUDtBQUFBLFlBQ0UsTUFBTTtBQUFBLFlBQ04sTUFBTSxLQUFLLFVBQVUsRUFBRSxPQUFPLGFBQWEsR0FBRyxNQUFNLENBQUM7QUFBQSxVQUN2RDtBQUFBLFFBQ0Y7QUFBQSxRQUNBLFNBQVM7QUFBQSxNQUNYO0FBQUEsSUFDRjtBQUFBLEVBQ0YsQ0FBQztBQUdELE1BQU0sWUFBWSxJQUFJLHFCQUFxQjtBQUMzQyxRQUFNLE9BQU8sUUFBUSxTQUFTLEdBRTlCLFFBQVEsTUFBTSwyQ0FBMkM7QUFDM0Q7QUFFQSxLQUFLLEVBQUUsTUFBTSxDQUFDQSxXQUFVO0FBQ3RCLFVBQVEsTUFBTSwwQkFBMEJBLE1BQUssR0FDN0MsUUFBUSxLQUFLLENBQUM7QUFDaEIsQ0FBQzsiLAogICJuYW1lcyI6IFsiZXhwb3J0cyIsICJfYSIsICJVc2VkVmFsdWVTdGF0ZSIsICJleHBvcnRzIiwgIl9hIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiX2EiLCAiaGFzaCIsICJleHBvcnRzIiwgIm1lcmdlVmFsdWVzIiwgIlR5cGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIl9hIiwgIkRhdGFUeXBlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiX2EiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIl9hIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiaGV4IiwgImlwdjYiLCAiZXNjIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgInBhcnNlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJfYSIsICJBanYiLCAibWV0YSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiX2EiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIkRpc2NyRXJyb3IiLCAiZXhwb3J0cyIsICJlcnJvciIsICJfYSIsICJyZXF1aXJlZCIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgIkFqdiIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgImRhdGUiLCAidGltZSIsICJlcnJvciIsICJleHBvcnRzIiwgIl9hIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgInV0aWwiLCAiYXNzZXJ0SXMiLCAiYXNzZXJ0TmV2ZXIiLCAib2JqZWN0IiwgImpvaW5WYWx1ZXMiLCAiYXJyYXkiLCAib2JqZWN0VXRpbCIsICJpc3N1ZSIsICJlcnJvciIsICJpc3N1ZSIsICJtYXAiLCAiaXNzdWUiLCAiZXJyb3JVdGlsIiwgImVycm9yIiwgImVycm9yTWFwIiwgImNoZWNrIiwgInRyYW5zZm9ybSIsICJ2ZXJzaW9uIiwgImp3dCIsICJiYXNlNjQiLCAiX1pvZFN0cmluZyIsICJjdHgiLCAicmVzdWx0IiwgImlzc3VlIiwgImlzc3VlcyIsICJlbGVtZW50cyIsICJwcm9jZXNzZWQiLCAicHJlcHJvY2VzcyIsICJyZXN1bHQiLCAiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwgImluaXRpYWxpemVyIiwgIl9hIiwgImZsb2F0U2FmZVJlbWFpbmRlciIsICJnZXRQYXJzZWRUeXBlIiwgImFycmF5IiwgIm9iamVjdCIsICJDbGFzcyIsICJfYSIsICJjb25maWciLCAiYmFzZTY0IiwgImJhc2U2NHVybCIsICJoZXgiLCAiZXJyb3IiLCAiaXNzdWUiLCAidmVyc2lvbiIsICJ0aW1lIiwgInRpbWVSZWdleCIsICJfYSIsICJpbnN0IiwgImZsb2F0U2FmZVJlbWFpbmRlciIsICJyZXN1bHQiLCAiX2EiLCAiY2hlY2tzIiwgImlzQWJvcnRlZCIsICJjaGVja1Jlc3VsdCIsICJjYW5hcnkiLCAicmVzdWx0IiwgInVybCIsICJiYXNlNjQiLCAiaXNWYWxpZEpXVCIsICJyIiwgImlzT2JqZWN0IiwgInJlc3VsdHMiLCAibWFwIiwgImxlZnQiLCAicmlnaHQiLCAibWVyZ2VWYWx1ZXMiLCAia2V5UmVzdWx0IiwgInZhbHVlUmVzdWx0IiwgIm91dHB1dCIsICJpc3N1ZSIsICJlbl9kZWZhdWx0IiwgIm1ldGEiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiX2Vtb2ppIiwgIkNsYXNzIiwgIkNsYXNzIiwgIkNsYXNzIiwgIkNsYXNzIiwgIl91bmRlZmluZWQiLCAiX251bGwiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiaXNzdWUiLCAiY29kZWMiLCAicHJvY2VzcyIsICJfYSIsICJtZXRhIiwgImlkIiwgInNjaGVtYSIsICJqc29uIiwgImZpbGUiLCAicHJvY2VzcyIsICJzYWZlUGFyc2UiLCAiZGVmIiwgInNjaGVtYXNfZXhwb3J0cyIsICJab2RBbnkiLCAiWm9kQXJyYXkiLCAiWm9kQmlnSW50IiwgIlpvZEJvb2xlYW4iLCAiWm9kQ2F0Y2giLCAiWm9kRGF0ZSIsICJab2REZWZhdWx0IiwgIlpvZERpc2NyaW1pbmF0ZWRVbmlvbiIsICJab2RFbnVtIiwgIlpvZEZ1bmN0aW9uIiwgIlpvZEludGVyc2VjdGlvbiIsICJab2RMYXp5IiwgIlpvZExpdGVyYWwiLCAiWm9kTWFwIiwgIlpvZE5hTiIsICJab2ROZXZlciIsICJab2ROdWxsIiwgIlpvZE51bGxhYmxlIiwgIlpvZE51bWJlciIsICJab2RPYmplY3QiLCAiWm9kT3B0aW9uYWwiLCAiWm9kUHJvbWlzZSIsICJab2RSZWFkb25seSIsICJab2RSZWNvcmQiLCAiWm9kU2V0IiwgIlpvZFN0cmluZyIsICJab2RTeW1ib2wiLCAiWm9kVHVwbGUiLCAiWm9kVHlwZSIsICJab2RVbmRlZmluZWQiLCAiWm9kVW5pb24iLCAiWm9kVW5rbm93biIsICJab2RWb2lkIiwgImJhc2U2NCIsICJiYXNlNjR1cmwiLCAiYmlnaW50IiwgImJvb2xlYW4iLCAiY2lkcnY0IiwgImNpZHJ2NiIsICJjdWlkIiwgImN1aWQyIiwgImRhdGUiLCAiZGVzY3JpYmUiLCAiZTE2NCIsICJlbWFpbCIsICJlbW9qaSIsICJndWlkIiwgImhleCIsICJob3N0bmFtZSIsICJpcHY0IiwgImlwdjYiLCAia3N1aWQiLCAibWFjIiwgIm1ldGEiLCAibmFub2lkIiwgIl9udWxsIiwgIm51bGxpc2giLCAibnVtYmVyIiwgIm9iamVjdCIsICJzdHJpbmciLCAidWxpZCIsICJfdW5kZWZpbmVkIiwgInV1aWQiLCAiX3ZvaWQiLCAieGlkIiwgImNoZWNrc19leHBvcnRzIiwgImlzb19leHBvcnRzIiwgImRhdGUiLCAiZGF0ZXRpbWUiLCAiZHVyYXRpb24iLCAidGltZSIsICJkYXRldGltZSIsICJkYXRlIiwgInRpbWUiLCAiZHVyYXRpb24iLCAiaW5pdGlhbGl6ZXIiLCAiaXNzdWUiLCAiaXNzdWVzIiwgIlpvZEVycm9yIiwgInBhcnNlIiwgInBhcnNlQXN5bmMiLCAic2FmZVBhcnNlIiwgInNhZmVQYXJzZUFzeW5jIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlQXN5bmMiLCAiZGVjb2RlQXN5bmMiLCAic2FmZUVuY29kZSIsICJzYWZlRGVjb2RlIiwgInNhZmVFbmNvZGVBc3luYyIsICJzYWZlRGVjb2RlQXN5bmMiLCAiWm9kVHlwZSIsICJkZWYiLCAibWV0YSIsICJwYXJzZSIsICJzYWZlUGFyc2UiLCAicGFyc2VBc3luYyIsICJzYWZlUGFyc2VBc3luYyIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImVuY29kZUFzeW5jIiwgImRlY29kZUFzeW5jIiwgInNhZmVFbmNvZGUiLCAic2FmZURlY29kZSIsICJzYWZlRW5jb2RlQXN5bmMiLCAic2FmZURlY29kZUFzeW5jIiwgImNoZWNrIiwgImpzb24iLCAiWm9kU3RyaW5nIiwgIl9lbW9qaSIsICJkYXRldGltZSIsICJkYXRlIiwgInRpbWUiLCAiZHVyYXRpb24iLCAic3RyaW5nIiwgImVtYWlsIiwgImd1aWQiLCAidXVpZCIsICJlbW9qaSIsICJuYW5vaWQiLCAiY3VpZCIsICJjdWlkMiIsICJ1bGlkIiwgInhpZCIsICJrc3VpZCIsICJpcHY0IiwgIm1hYyIsICJpcHY2IiwgImNpZHJ2NCIsICJjaWRydjYiLCAiYmFzZTY0IiwgImJhc2U2NHVybCIsICJlMTY0IiwgImhvc3RuYW1lIiwgImhleCIsICJab2ROdW1iZXIiLCAibnVtYmVyIiwgIlpvZEJvb2xlYW4iLCAiYm9vbGVhbiIsICJab2RCaWdJbnQiLCAiYmlnaW50IiwgIlpvZFN5bWJvbCIsICJab2RVbmRlZmluZWQiLCAiX3VuZGVmaW5lZCIsICJab2ROdWxsIiwgIlpvZFR5cGUiLCAianNvbiIsICJfbnVsbCIsICJab2RBbnkiLCAiWm9kVHlwZSIsICJqc29uIiwgIlpvZFVua25vd24iLCAiWm9kTmV2ZXIiLCAiWm9kVm9pZCIsICJfdm9pZCIsICJab2REYXRlIiwgIlpvZFR5cGUiLCAianNvbiIsICJkYXRlIiwgIlpvZEFycmF5IiwgIlpvZE9iamVjdCIsICJab2RPcHRpb25hbCIsICJvYmplY3QiLCAiWm9kVW5pb24iLCAiWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwgIlpvZEludGVyc2VjdGlvbiIsICJab2RUdXBsZSIsICJab2RSZWNvcmQiLCAiWm9kTWFwIiwgIlpvZFNldCIsICJab2RFbnVtIiwgIlpvZEVudW0iLCAiWm9kTGl0ZXJhbCIsICJab2RUeXBlIiwgImpzb24iLCAiaXNzdWUiLCAib3V0cHV0IiwgIlpvZE9wdGlvbmFsIiwgIlpvZE51bGxhYmxlIiwgIm51bGxpc2giLCAiWm9kRGVmYXVsdCIsICJab2RDYXRjaCIsICJab2ROYU4iLCAiWm9kVHlwZSIsICJqc29uIiwgIlpvZFJlYWRvbmx5IiwgIlpvZExhenkiLCAiWm9kUHJvbWlzZSIsICJab2RGdW5jdGlvbiIsICJab2RUeXBlIiwgImpzb24iLCAiZGVzY3JpYmUiLCAibWV0YSIsICJab2RCb29sZWFuIiwgIlpvZFN0cmluZyIsICJzdHJpbmciLCAibnVtYmVyIiwgImJvb2xlYW4iLCAiX251bGwiLCAiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwgInNjaGVtYXNfZXhwb3J0cyIsICJjaGVja3NfZXhwb3J0cyIsICJpc29fZXhwb3J0cyIsICJlbl9kZWZhdWx0IiwgInN0cmluZyIsICJudW1iZXIiLCAiX251bGwiLCAib2JqZWN0IiwgIkVycm9yQ29kZSIsICJvYmplY3QiLCAibnVtYmVyIiwgInN0cmluZyIsICJzdHJpbmciLCAib2JqZWN0IiwgImJvb2xlYW4iLCAib2JqZWN0IiwgInN0cmluZyIsICJib29sZWFuIiwgIm9iamVjdCIsICJudW1iZXIiLCAic3RyaW5nIiwgIl9udWxsIiwgImlzb19leHBvcnRzIiwgImJvb2xlYW4iLCAib2JqZWN0IiwgInN0cmluZyIsICJzdHJpbmciLCAibnVtYmVyIiwgImJvb2xlYW4iLCAib2JqZWN0IiwgInNhZmVQYXJzZSIsICJlcnJvciIsICJ0YXNrIiwgInNhZmVQYXJzZSIsICJqc29ucnBjTm90aWZpY2F0aW9uIiwgImlzUGxhaW5PYmplY3QiLCAiQWp2IiwgIl9hZGRGb3JtYXRzIiwgInNhZmVQYXJzZSIsICJlcnJvciIsICJwcm9jZXNzIiwgImVycm9yIiwgImpzb24iLCAiY29uZmlnIiwgImVycm9yIiwgImRvbWFpbiIsICJlcnJvciJdCn0K
