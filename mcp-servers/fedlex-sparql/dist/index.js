#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.regexpCode = exports2.getEsmExportName = exports2.getProperty = exports2.safeStringify = exports2.stringify = exports2.strConcat = exports2.addCodeArg = exports2.str = exports2._ = exports2.nil = exports2._Code = exports2.Name = exports2.IDENTIFIER = exports2._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports2._CodeOrName = _CodeOrName;
    exports2.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        if (super(), !exports2.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports2.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super(), this._items = typeof code == "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        let item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => (c instanceof Name && (names[c.str] = (names[c.str] || 0) + 1), names), {});
      }
    };
    exports2._Code = _Code;
    exports2.nil = new _Code("");
    function _(strs, ...args) {
      let code = [strs[0]], i = 0;
      for (; i < args.length; )
        addCodeArg(code, args[i]), code.push(strs[++i]);
      return new _Code(code);
    }
    exports2._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      let expr = [safeStringify(strs[0])], i = 0;
      for (; i < args.length; )
        expr.push(plus), addCodeArg(expr, args[i]), expr.push(plus, safeStringify(strs[++i]));
      return optimize(expr), new _Code(expr);
    }
    exports2.str = str;
    function addCodeArg(code, arg) {
      arg instanceof _Code ? code.push(...arg._items) : arg instanceof Name ? code.push(arg) : code.push(interpolate(arg));
    }
    exports2.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      for (; i < expr.length - 1; ) {
        if (expr[i] === plus) {
          let res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string")
        return b instanceof Name || a[a.length - 1] !== '"' ? void 0 : typeof b != "string" ? `${a.slice(0, -1)}${b}"` : b[0] === '"' ? a.slice(0, -1) + b.slice(1) : void 0;
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports2.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports2.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports2.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports2.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports2.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports2.IDENTIFIER.test(key))
        return new _Code(`${key}`);
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports2.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports2.regexpCode = regexpCode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.ValueScope = exports2.ValueScopeName = exports2.Scope = exports2.varKinds = exports2.UsedValueState = void 0;
    var code_1 = require_code(), ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`), this.value = name.value;
      }
    }, UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2.Started = 0] = "Started", UsedValueState2[UsedValueState2.Completed = 1] = "Completed";
    })(UsedValueState || (exports2.UsedValueState = UsedValueState = {}));
    exports2.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {}, this._prefixes = prefixes, this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        let ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (!((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0) && _b.has(prefix) || this._prefixes && !this._prefixes.has(prefix))
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports2.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr), this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value, this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports2.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`, ValueScope = class extends Scope {
      constructor(opts) {
        super(opts), this._values = {}, this._scope = opts.scope, this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        let name = this.toName(nameOrPrefix), { prefix } = name, valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref, vs = this._values[prefix];
        if (vs) {
          let _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        vs.set(valueKey, name);
        let s = this._scope[prefix] || (this._scope[prefix] = []), itemIndex = s.length;
        return s[itemIndex] = value.ref, name.setValue(value, { property: prefix, itemIndex }), name;
      }
      getValue(prefix, keyOrRef) {
        let vs = this._values[prefix];
        if (vs)
          return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (let prefix in values) {
          let vs = values[prefix];
          if (!vs)
            continue;
          let nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              let def = this.opts.es5 ? exports2.varKinds.var : exports2.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode?.(name))
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            else
              throw new ValueError(name);
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports2.ValueScope = ValueScope;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.or = exports2.and = exports2.not = exports2.CodeGen = exports2.operators = exports2.varKinds = exports2.ValueScopeName = exports2.ValueScope = exports2.Scope = exports2.Name = exports2.regexpCode = exports2.stringify = exports2.getProperty = exports2.nil = exports2.strConcat = exports2.str = exports2._ = void 0;
    var code_1 = require_code(), scope_1 = require_scope(), code_2 = require_code();
    Object.defineProperty(exports2, "_", { enumerable: !0, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: !0, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports2, "strConcat", { enumerable: !0, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: !0, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports2, "getProperty", { enumerable: !0, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: !0, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports2, "regexpCode", { enumerable: !0, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: !0, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports2, "Scope", { enumerable: !0, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports2, "ValueScope", { enumerable: !0, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports2, "ValueScopeName", { enumerable: !0, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports2, "varKinds", { enumerable: !0, get: function() {
      return scope_2.varKinds;
    } });
    exports2.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }, Def = class extends Node {
      constructor(varKind, name, rhs) {
        super(), this.varKind = varKind, this.name = name, this.rhs = rhs;
      }
      render({ es5, _n }) {
        let varKind = es5 ? scope_1.varKinds.var : this.varKind, rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (names[this.name.str])
          return this.rhs && (this.rhs = optimizeExpr(this.rhs, names, constants)), this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }, Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super(), this.lhs = lhs, this.rhs = rhs, this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!(this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects))
          return this.rhs = optimizeExpr(this.rhs, names, constants), this;
      }
      get names() {
        let names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    }, AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects), this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }, Label = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }, Break = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `break${this.label ? ` ${this.label}` : ""};` + _n;
      }
    }, Throw = class extends Node {
      constructor(error2) {
        super(), this.error = error2;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }, AnyCode = class extends Node {
      constructor(code) {
        super(), this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        return this.code = optimizeExpr(this.code, names, constants), this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }, ParentNode = class extends Node {
      constructor(nodes = []) {
        super(), this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i].optimizeNodes();
          Array.isArray(n) ? nodes.splice(i, 1, ...n) : n ? nodes[i] = n : nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i];
          n.optimizeNames(names, constants) || (subtractNames(names, n.names), nodes.splice(i, 1));
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    }, BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }, Root = class extends ParentNode {
    }, Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes), this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        return this.else && (code += "else " + this.else.render(opts)), code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let cond = this.condition;
        if (cond === !0)
          return this.nodes;
        let e = this.else;
        if (e) {
          let ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e)
          return cond === !1 ? e instanceof _If ? e : e.nodes : this.nodes.length ? this : new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        if (!(cond === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        if (this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants), !!(super.optimizeNames(names, constants) || this.else))
          return this.condition = optimizeExpr(this.condition, names, constants), this;
      }
      get names() {
        let names = super.names;
        return addExprNames(names, this.condition), this.else && addNames(names, this.else.names), names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super(), this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iteration = optimizeExpr(this.iteration, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }, ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super(), this.varKind = varKind, this.name = name, this.from = from, this.to = to;
      }
      render(opts) {
        let varKind = opts.es5 ? scope_1.varKinds.var : this.varKind, { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        let names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    }, ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super(), this.loop = loop, this.varKind = varKind, this.name = name, this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iterable = optimizeExpr(this.iterable, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }, Func = class extends BlockNode {
      constructor(name, args, async) {
        super(), this.name = name, this.args = args, this.async = async;
      }
      render(opts) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        return this.catch && (code += this.catch.render(opts)), this.finally && (code += this.finally.render(opts)), code;
      }
      optimizeNodes() {
        var _a2, _b;
        return super.optimizeNodes(), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNodes(), (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes(), this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        return super.optimizeNames(names, constants), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNames(names, constants), (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants), this;
      }
      get names() {
        let names = super.names;
        return this.catch && addNames(names, this.catch.names), this.finally && addNames(names, this.finally.names), names;
      }
    }, Catch = class extends BlockNode {
      constructor(error2) {
        super(), this.error = error2;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...opts, _n: opts.lines ? `
` : "" }, this._extScope = extScope, this._scope = new scope_1.Scope({ parent: extScope }), this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        let name = this._extScope.value(prefixOrName, value);
        return (this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name), name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        let name = this._scope.toName(nameOrPrefix);
        return rhs !== void 0 && constant && (this._constants[name.str] = rhs), this._leafNode(new Def(varKind, name, rhs)), name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports2.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        return typeof c == "function" ? c() : c !== code_1.nil && this._leafNode(new AnyCode(c)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        let code = ["{"];
        for (let [key, value] of keyValues)
          code.length > 1 && code.push(","), code.push(key), (key !== value || this.opts.es5) && (code.push(":"), (0, code_1.addCodeArg)(code, value));
        return code.push("}"), new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        if (this._blockNode(new If(condition)), thenBody && elseBody)
          this.code(thenBody).else().code(elseBody).endIf();
        else if (thenBody)
          this.code(thenBody).endIf();
        else if (elseBody)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        return this._blockNode(node), forBody && this.code(forBody).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        let name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          let arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`), forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        let node = new Return();
        if (this._blockNode(node), this.code(value), node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        let node = new Try();
        if (this._blockNode(node), this.code(tryBody), catchCode) {
          let error2 = this.name("e");
          this._currNode = node.catch = new Catch(error2), catchCode(error2);
        }
        return finallyCode && (this._currNode = node.finally = new Finally(), this.code(finallyCode)), this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error2) {
        return this._leafNode(new Throw(error2));
      }
      // start self-balancing block
      block(body, nodeCount) {
        return this._blockStarts.push(this._nodes.length), body && this.code(body).endBlock(nodeCount), this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        let len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        let toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount)
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        return this._nodes.length = len, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        return this._blockNode(new Func(name, args, async)), funcBody && this.code(funcBody).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        for (; n-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(node) {
        return this._currNode.nodes.push(node), this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node), this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        let n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        let n = this._currNode;
        if (!(n instanceof If))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = n.else = node, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        let ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports2.CodeGen = CodeGen;
    function addNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => (c instanceof code_1.Name && (c = replaceName(c)), c instanceof code_1._Code ? items.push(...c._items) : items.push(c), items), []));
      function replaceName(n) {
        let c = constants[n.str];
        return c === void 0 || names[n.str] !== 1 ? n : (delete names[n.str], c);
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports2.not = not;
    var andCode = mappend(exports2.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports2.and = and;
    var orCode = mappend(exports2.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports2.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.checkStrictMode = exports2.getErrorPath = exports2.Type = exports2.useFunc = exports2.setEvaluated = exports2.evaluatedPropsToName = exports2.mergeEvaluated = exports2.eachItem = exports2.unescapeJsonPointer = exports2.escapeJsonPointer = exports2.escapeFragment = exports2.unescapeFragment = exports2.schemaRefOrVal = exports2.schemaHasRulesButRef = exports2.schemaHasRules = exports2.checkUnknownRules = exports2.alwaysValidSchema = exports2.toHash = void 0;
    var codegen_1 = require_codegen(), code_1 = require_code();
    function toHash(arr) {
      let hash2 = {};
      for (let item of arr)
        hash2[item] = !0;
      return hash2;
    }
    exports2.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      return typeof schema == "boolean" ? schema : Object.keys(schema).length === 0 ? !0 : (checkUnknownRules(it, schema), !schemaHasRules(schema, it.self.RULES.all));
    }
    exports2.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      let { opts, self } = it;
      if (!opts.strictSchema || typeof schema == "boolean")
        return;
      let rules = self.RULES.keywords;
      for (let key in schema)
        rules[key] || checkStrictMode(it, `unknown keyword: "${key}"`);
    }
    exports2.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (rules[key])
          return !0;
      return !1;
    }
    exports2.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (key !== "$ref" && RULES.all[key])
          return !0;
      return !1;
    }
    exports2.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports2.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports2.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports2.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      return typeof str == "number" ? `${str}` : str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports2.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports2.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs))
        for (let x of xs)
          f(x);
      else
        f(xs);
    }
    exports2.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
      return (gen, from, to, toName) => {
        let res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports2.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, !0), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          from === !0 ? gen.assign(to, !0) : (gen.assign(to, (0, codegen_1._)`${to} || {}`), setEvaluated(gen, to, from));
        }),
        mergeValues: (from, to) => from === !0 ? !0 : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === !0 ? !0 : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === !0 ? !0 : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === !0)
        return gen.var("props", !0);
      let props = gen.var("props", (0, codegen_1._)`{}`);
      return ps !== void 0 && setEvaluated(gen, props, ps), props;
    }
    exports2.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, !0));
    }
    exports2.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports2.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2.Num = 0] = "Num", Type2[Type2.Str = 1] = "Str";
    })(Type || (exports2.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        let isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports2.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (mode) {
        if (msg = `strict mode: ${msg}`, mode === !0)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
    }
    exports2.checkStrictMode = checkStrictMode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/names.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports2.default = names;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.extendErrors = exports2.resetErrorsCount = exports2.reportExtraError = exports2.reportError = exports2.keyword$DataError = exports2.keywordError = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names();
    exports2.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports2.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error2 = exports2.keywordError, errorPaths, overrideAllErrors) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      overrideAllErrors ?? (compositeRule || allErrors) ? addError(gen, errObj) : returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
    exports2.reportError = reportError;
    function reportExtraError(cxt, error2 = exports2.keywordError, errorPaths) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      addError(gen, errObj), compositeRule || allErrors || returnErrors(it, names_1.default.vErrors);
    }
    exports2.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount), gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports2.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      let err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`), gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath))), gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`), it.opts.verbose && (gen.assign((0, codegen_1._)`${err}.schema`, schemaValue), gen.assign((0, codegen_1._)`${err}.data`, data));
      });
    }
    exports2.extendErrors = extendErrors;
    function addError(gen, errObj) {
      let err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`), gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      let { gen, validateName, schemaEnv } = it;
      schemaEnv.$async ? gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`) : (gen.assign((0, codegen_1._)`${validateName}.errors`, errs), gen.return(!1));
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error2, errorPaths) {
      let { createErrors } = cxt.it;
      return createErrors === !1 ? (0, codegen_1._)`{}` : errorObject(cxt, error2, errorPaths);
    }
    function errorObject(cxt, error2, errorPaths = {}) {
      let { gen, it } = cxt, keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      return extraErrorProps(cxt, error2, keyValues), gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      let instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      return schemaPath && (schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`), [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      let { keyword, data, schemaValue, it } = cxt, { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]), opts.messages && keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]), opts.verbose && keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]), propertyName && keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.boolOrEmptySchema = exports2.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors(), codegen_1 = require_codegen(), names_1 = require_names(), boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      let { gen, schema, validateName } = it;
      schema === !1 ? falseSchemaError(it, !1) : typeof schema == "object" && schema.$async === !0 ? gen.return(names_1.default.data) : (gen.assign((0, codegen_1._)`${validateName}.errors`, null), gen.return(!0));
    }
    exports2.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      let { gen, schema } = it;
      schema === !1 ? (gen.var(valid, !1), falseSchemaError(it)) : gen.var(valid, !0);
    }
    exports2.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      let { gen, data } = it, cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getRules = exports2.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"], jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports2.isJSONType = isJSONType;
    function getRules() {
      let groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports2.getRules = getRules;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.shouldUseRule = exports2.shouldUseGroup = exports2.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      let group = self.RULES.types[type];
      return group && group !== !0 && shouldUseGroup(schema, group);
    }
    exports2.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports2.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports2.shouldUseRule = shouldUseRule;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.reportTypeError = exports2.checkDataTypes = exports2.checkDataType = exports2.coerceAndCheckDataType = exports2.getJSONTypes = exports2.getSchemaTypes = exports2.DataType = void 0;
    var rules_1 = require_rules(), applicability_1 = require_applicability(), errors_1 = require_errors(), codegen_1 = require_codegen(), util_1 = require_util(), DataType;
    (function(DataType2) {
      DataType2[DataType2.Correct = 0] = "Correct", DataType2[DataType2.Wrong = 1] = "Wrong";
    })(DataType || (exports2.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      let types = getJSONTypes(schema.type);
      if (types.includes("null")) {
        if (schema.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        schema.nullable === !0 && types.push("null");
      }
      return types;
    }
    exports2.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      let types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports2.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      let { gen, data, opts } = it, coerceTo = coerceToTypes(types, opts.coerceTypes), checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        let wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          coerceTo.length ? coerceData(it, types, coerceTo) : reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports2.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      let { gen, data, opts } = it, dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`), coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      opts.coerceTypes === "array" && gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))), gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (let t of coerceTo)
        (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") && coerceSpecificType(t);
      gen.else(), reportTypeError(it), gen.endIf(), gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced), assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, !1).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, !0);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`), gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      let EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ, cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports2.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1)
        return checkDataType(dataTypes[0], data, strictNums, correct);
      let cond, types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        let notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`, delete types.null, delete types.array, delete types.object;
      } else
        cond = codegen_1.nil;
      types.number && delete types.integer;
      for (let t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports2.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      let cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports2.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      let { gen, data, schema } = it, schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.assignDefaults = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function assignDefaults(it, ty) {
      let { properties, items } = it.schema;
      if (ty === "object" && properties)
        for (let key in properties)
          assignDefault(it, key, properties[key].default);
      else ty === "array" && Array.isArray(items) && items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
    exports2.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      let { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      let childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      opts.useDefaults === "empty" && (condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`), gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateUnion = exports2.validateArray = exports2.usePattern = exports2.callValidateCode = exports2.schemaProperties = exports2.allSchemaProperties = exports2.noPropertyInData = exports2.propertyInData = exports2.isOwnProperty = exports2.hasPropFunc = exports2.reportMissingProp = exports2.checkMissingProp = exports2.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names(), util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      let { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, !0), cxt.error();
      });
    }
    exports2.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports2.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, !0), cxt.error();
    }
    exports2.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports2.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports2.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports2.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports2.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports2.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports2.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      let dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data, valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      it.opts.dynamicRef && valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      let args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports2.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      let u = opts.unicodeRegExp ? "u" : "", { regExp } = opts.code, rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports2.usePattern = usePattern;
    function validateArray(cxt) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      if (it.allErrors) {
        let validArr = gen.let("valid", !0);
        return validateItems(() => gen.assign(validArr, !1)), validArr;
      }
      return gen.var(valid, !0), validateItems(() => gen.break()), valid;
      function validateItems(notValid) {
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid), gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports2.validateArray = validateArray;
    function validateUnion(cxt) {
      let { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated)
        return;
      let valid = gen.let("valid", !1), schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        let schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: !0
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`), cxt.mergeValidEvaluated(schCxt, schValid) || gen.if((0, codegen_1.not)(valid));
      })), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
    }
    exports2.validateUnion = validateUnion;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateKeywordUsage = exports2.validSchemaType = exports2.funcKeywordCode = exports2.macroKeywordCode = void 0;
    var codegen_1 = require_codegen(), names_1 = require_names(), code_1 = require_code2(), errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      let { gen, keyword, schema, parentSchema, it } = cxt, macroSchema = def.macro.call(it.self, schema, parentSchema, it), schemaRef = useKeyword(gen, keyword, macroSchema);
      it.opts.validateSchema !== !1 && it.self.validateSchema(macroSchema, !0);
      let valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: !0
      }, valid), cxt.pass(valid, () => cxt.error(!0));
    }
    exports2.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      let { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      let validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate, validateRef = useKeyword(gen, keyword, validate), valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword), cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === !1)
          assignValid(), def.modifying && modifyData(cxt), reportErrs(() => cxt.error());
        else {
          let ruleErrs = def.async ? validateAsync() : validateSync();
          def.modifying && modifyData(cxt), reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        let ruleErrs = gen.let("ruleErrs", null);
        return gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, !1).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e))), ruleErrs;
      }
      function validateSync() {
        let validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        return gen.assign(validateErrs, null), assignValid(codegen_1.nil), validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        let passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self, passSchema = !("compile" in def && !$data || def.schema === !1);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports2.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      let { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      let { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`), (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = !1) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema > "u");
    }
    exports2.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword)
        throw new Error("ajv implementation error");
      let deps = def.dependencies;
      if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)))
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      if (def.validateSchema && !def.validateSchema(schema[keyword])) {
        let msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
    exports2.validateKeywordUsage = validateKeywordUsage;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.extendSubschemaMode = exports2.extendSubschemaData = exports2.getSubschema = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (keyword !== void 0) {
        let sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports2.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      let { gen } = it;
      if (dataProp !== void 0) {
        let { errorPath, dataPathArr, opts } = it, nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, !0);
        dataContextProps(nextData), subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`, subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`, subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        let nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, !0);
        dataContextProps(nextData), propertyName !== void 0 && (subschema.propertyName = propertyName);
      }
      dataTypes && (subschema.dataTypes = dataTypes);
      function dataContextProps(_nextData) {
        subschema.data = _nextData, subschema.dataLevel = it.dataLevel + 1, subschema.dataTypes = [], it.definedProperties = /* @__PURE__ */ new Set(), subschema.parentData = it.data, subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports2.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      compositeRule !== void 0 && (subschema.compositeRule = compositeRule), createErrors !== void 0 && (subschema.createErrors = createErrors), allErrors !== void 0 && (subschema.allErrors = allErrors), subschema.jtdDiscriminator = jtdDiscriminator, subschema.jtdMetadata = jtdMetadata;
    }
    exports2.extendSubschemaMode = extendSubschemaMode;
  }
});

// mcp-servers-src/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "mcp-servers-src/node_modules/fast-deep-equal/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function equal(a, b) {
      if (a === b) return !0;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return !1;
        var length, i, keys;
        if (Array.isArray(a)) {
          if (length = a.length, length != b.length) return !1;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return !1;
          return !0;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return !1;
        }
        return !0;
      }
      return a !== a && b !== b;
    };
  }
});

// mcp-servers-src/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "mcp-servers-src/node_modules/json-schema-traverse/index.js"(exports2, module2) {
    "use strict";
    var traverse = module2.exports = function(schema, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      }, post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    };
    traverse.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    };
    traverse.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    };
    traverse.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords)
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object")
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/resolve.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getSchemaRefs = exports2.resolveUrl = exports2.normalizeId = exports2._getFullPath = exports2.getFullPath = exports2.inlineRef = void 0;
    var util_1 = require_util(), equal = require_fast_deep_equal(), traverse = require_json_schema_traverse(), SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = !0) {
      return typeof schema == "boolean" ? !0 : limit === !0 ? !hasRef(schema) : limit ? countKeys(schema) <= limit : !1;
    }
    exports2.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (let key in schema) {
        if (REF_KEYWORDS.has(key))
          return !0;
        let sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef) || typeof sch == "object" && hasRef(sch))
          return !0;
      }
      return !1;
    }
    function countKeys(schema) {
      let count = 0;
      for (let key in schema) {
        if (key === "$ref")
          return 1 / 0;
        if (count++, !SIMPLE_INLINED.has(key) && (typeof schema[key] == "object" && (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch)), count === 1 / 0))
          return 1 / 0;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      normalize !== !1 && (id = normalizeId(id));
      let p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports2.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      return resolver.serialize(p).split("#")[0] + "#";
    }
    exports2._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports2.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      return id = normalizeId(id), resolver.resolve(baseId, id);
    }
    exports2.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      let { schemaId, uriResolver } = this.opts, schId = normalizeId(schema[schemaId] || baseId), baseIds = { "": schId }, pathPrefix = getFullPath(uriResolver, schId, !1), localRefs = {}, schemaRefs = /* @__PURE__ */ new Set();
      return traverse(schema, { allKeys: !0 }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        let fullPath = pathPrefix + jsonPtr, innerBaseId = baseIds[parentJsonPtr];
        typeof sch[schemaId] == "string" && (innerBaseId = addRef.call(this, sch[schemaId])), addAnchor.call(this, sch.$anchor), addAnchor.call(this, sch.$dynamicAnchor), baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          let _resolve = this.opts.uriResolver.resolve;
          if (ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref), schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          return typeof schOrRef == "string" && (schOrRef = this.refs[schOrRef]), typeof schOrRef == "object" ? checkAmbiguosRef(sch, schOrRef.schema, ref) : ref !== normalizeId(fullPath) && (ref[0] === "#" ? (checkAmbiguosRef(sch, localRefs[ref], ref), localRefs[ref] = sch) : this.refs[ref] = fullPath), ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      }), localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports2.getSchemaRefs = getSchemaRefs;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.getData = exports2.KeywordCxt = exports2.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema(), dataType_1 = require_dataType(), applicability_1 = require_applicability(), dataType_2 = require_dataType(), defaults_1 = require_defaults(), keyword_1 = require_keyword(), subschema_1 = require_subschema(), codegen_1 = require_codegen(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        topSchemaObjCode(it);
        return;
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports2.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      opts.code.es5 ? gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`), destructureValCxtES5(gen, opts), gen.code(body);
      }) : gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`), gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`), gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`), gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`), gen.var(names_1.default.rootData, names_1.default.data), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      let { schema, opts, gen } = it;
      validateFunction(it, () => {
        opts.$comment && schema.$comment && commentKeyword(it), checkNoDefault(it), gen.let(names_1.default.vErrors, null), gen.let(names_1.default.errors, 0), opts.unevaluated && resetEvaluated(it), typeAndKeywords(it), returnResults(it);
      });
    }
    function resetEvaluated(it) {
      let { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`), gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`)), gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      let schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        subSchemaObjCode(it, valid);
        return;
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (self.RULES.all[key])
          return !0;
      return !1;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      let { schema, gen, opts } = it;
      opts.$comment && schema.$comment && commentKeyword(it), updateContext(it), checkAsyncSchema(it);
      let errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount), gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it), checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], !1, errsCount);
      let types = (0, dataType_1.getSchemaTypes)(it.schema), checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      let { schema, errSchemaPath, opts, self } = it;
      schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES) && self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
    function checkNoDefault(it) {
      let { schema, opts } = it;
      schema.default !== void 0 && opts.useDefaults && opts.strictSchema && (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
    function updateContext(it) {
      let schId = it.schema[it.opts.schemaId];
      schId && (it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId));
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      let msg = schema.$comment;
      if (opts.$comment === !0)
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      else if (typeof opts.$comment == "function") {
        let schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`, rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      let { gen, schemaEnv, validateName, ValidationError, opts } = it;
      schemaEnv.$async ? gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`)) : (gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors), opts.unevaluated && assignEvaluated(it), gen.return((0, codegen_1._)`${names_1.default.errors} === 0`));
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      props instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.props`, props), items instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      let { gen, schema, data, allErrors, opts, self } = it, { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      opts.jtd || checkStrictTypes(it, types), gen.block(() => {
        for (let group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        (0, applicability_1.shouldUseGroup)(schema, group) && (group.type ? (gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)), iterateKeywords(it, group), types.length === 1 && types[0] === group.type && typeErrors && (gen.else(), (0, dataType_2.reportTypeError)(it)), gen.endIf()) : iterateKeywords(it, group), allErrors || gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`));
      }
    }
    function iterateKeywords(it, group) {
      let { gen, schema, opts: { useDefaults } } = it;
      useDefaults && (0, defaults_1.assignDefaults)(it, group.type), gen.block(() => {
        for (let rule of group.rules)
          (0, applicability_1.shouldUseRule)(schema, rule) && keywordCode(it, rule.keyword, rule.definition, group.type);
      });
    }
    function checkStrictTypes(it, types) {
      it.schemaEnv.meta || !it.opts.strictTypes || (checkContextTypes(it, types), it.opts.allowUnionTypes || checkMultipleTypes(it, types), checkKeywordTypes(it, it.dataTypes));
    }
    function checkContextTypes(it, types) {
      if (types.length) {
        if (!it.dataTypes.length) {
          it.dataTypes = types;
          return;
        }
        types.forEach((t) => {
          includesType(it.dataTypes, t) || strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }), narrowSchemaTypes(it, types);
      }
    }
    function checkMultipleTypes(it, ts) {
      ts.length > 1 && !(ts.length === 2 && ts.includes("null")) && strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
    function checkKeywordTypes(it, ts) {
      let rules = it.self.RULES.all;
      for (let keyword in rules) {
        let rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          let { type } = rule.definition;
          type.length && !type.some((t) => hasApplicableType(ts, t)) && strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      let ts = [];
      for (let t of it.dataTypes)
        includesType(withTypes, t) ? ts.push(t) : withTypes.includes("integer") && t === "number" && ts.push("integer");
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      let schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`, (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        if ((0, keyword_1.validateKeywordUsage)(it, def, keyword), this.gen = it.gen, this.allErrors = it.allErrors, this.keyword = keyword, this.data = it.data, this.schema = it.schema[keyword], this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data), this.schemaType = def.schemaType, this.parentSchema = it.schema, this.params = {}, this.it = it, this.def = def, this.$data)
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        else if (this.schemaCode = this.schemaValue, !(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined))
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        ("code" in def ? def.trackErrors : def.errors !== !1) && (this.errsCount = it.gen.const("_errs", names_1.default.errors));
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition), failAction ? failAction() : this.error(), successAction ? (this.gen.else(), successAction(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(condition), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        let { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams), this._error(append, errorPaths), this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        this.allErrors || this.gen.if(cond);
      }
      setParams(obj, assign) {
        assign ? Object.assign(this.params, obj) : this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid), codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        let { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid)), valid !== codegen_1.nil && gen.assign(valid, !0), (schemaType.length || def.validateSchema) && (gen.elseIf(this.invalid$data()), this.$dataError(), valid !== codegen_1.nil && gen.assign(valid, !1)), gen.else();
      }
      invalid$data() {
        let { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            let st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            let validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        let subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl), (0, subschema_1.extendSubschemaMode)(subschema, appl);
        let nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        return subschemaCode(nextContext, valid), nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        let { it, gen } = this;
        it.opts.unevaluated && (it.props !== !0 && schemaCxt.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)), it.items !== !0 && schemaCxt.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)));
      }
      mergeValidEvaluated(schemaCxt, valid) {
        let { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== !0 || it.items !== !0))
          return gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name)), !0;
      }
    };
    exports2.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      let cxt = new KeywordCxt(it, def, keyword);
      "code" in def ? def.code(cxt, ruleType) : cxt.$data && def.validate ? (0, keyword_1.funcKeywordCode)(cxt, def) : "macro" in def ? (0, keyword_1.macroKeywordCode)(cxt, def) : (def.compile || def.validate) && (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer, data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data, data = names_1.default.rootData;
      } else {
        let matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        let up = +matches[1];
        if (jsonPointer = matches[2], jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        if (data = dataNames[dataLevel - up], !jsonPointer)
          return data;
      }
      let expr = data, segments = jsonPointer.split("/");
      for (let segment of segments)
        segment && (data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`, expr = (0, codegen_1._)`${expr} && ${data}`);
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports2.getData = getData;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed"), this.errors = errors, this.ajv = this.validation = !0;
      }
    };
    exports2.default = ValidationError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var resolve_1 = require_resolve(), MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`), this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref), this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports2.default = MissingRefError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.resolveSchema = exports2.getCompilingSchema = exports2.resolveRef = exports2.compileSchema = exports2.SchemaEnv = void 0;
    var codegen_1 = require_codegen(), validation_error_1 = require_validation_error(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), validate_1 = require_validate(), SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {}, this.dynamicAnchors = {};
        let schema;
        typeof env.schema == "object" && (schema = env.schema), this.schema = env.schema, this.schemaId = env.schemaId, this.root = env.root || this, this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema?.[env.schemaId || "$id"]), this.schemaPath = env.schemaPath, this.localRefs = env.localRefs, this.meta = env.meta, this.$async = schema?.$async, this.refs = {};
      }
    };
    exports2.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      let _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      let rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId), { es5, lines } = this.opts.code, { ownProperties } = this.opts, gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties }), _ValidationError;
      sch.$async && (_ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      }));
      let validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      let schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === !0 ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      }, sourceCode;
      try {
        this._compilations.add(sch), (0, validate_1.validateFunctionCode)(schemaCxt), gen.optimize(this.opts.code.optimize);
        let validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`, this.opts.code.process && (sourceCode = this.opts.code.process(sourceCode, sch));
        let validate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode)(this, this.scope.get());
        if (this.scope.value(validateName, { ref: validate }), validate.errors = null, validate.schema = sch.schema, validate.schemaEnv = sch, sch.$async && (validate.$async = !0), this.opts.code.source === !0 && (validate.source = { validateName, validateCode, scopeValues: gen._values }), this.opts.unevaluated) {
          let { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          }, validate.source && (validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated));
        }
        return sch.validate = validate, sch;
      } catch (e) {
        throw delete sch.validate, delete sch.validateName, sourceCode && this.logger.error("Error compiling schema, function code:", sourceCode), e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports2.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      let schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        let schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref], { schemaId } = this.opts;
        schema && (_sch = new SchemaEnv({ schema, schemaId, root, baseId }));
      }
      if (_sch !== void 0)
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports2.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      return (0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs) ? sch.schema : sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (let sch of this._compilations)
        if (sameSchemaEnv(sch, schEnv))
          return sch;
    }
    exports2.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      for (; typeof (sch = this.refs[ref]) == "string"; )
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      let p = this.opts.uriResolver.parse(ref), refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p), baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId)
        return getJsonPointer.call(this, p, root);
      let id = (0, resolve_1.normalizeId)(refPath), schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        let sch = resolveSchema.call(this, root, schOrRef);
        return typeof sch?.schema != "object" ? void 0 : getJsonPointer.call(this, p, sch);
      }
      if (typeof schOrRef?.schema == "object") {
        if (schOrRef.validate || compileSchema.call(this, schOrRef), id === (0, resolve_1.normalizeId)(ref)) {
          let { schema } = schOrRef, { schemaId } = this.opts, schId = schema[schemaId];
          return schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId)), new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
      }
    }
    exports2.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (let part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
          return;
        let partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        let schId = typeof schema == "object" && schema[this.opts.schemaId];
        !PREVENT_SCOPE_CHANGE.has(part) && schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId));
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        let $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      let { schemaId } = this.opts;
      if (env = env || new SchemaEnv({ schema, schemaId, root, baseId }), env.schema !== env.root.schema)
        return env;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/data.json"(exports2, module2) {
    module2.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: !1
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/utils.js"(exports2, module2) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "", code = 0, i = 0;
      for (i = 0; i < input.length; i++)
        if (code = input[i].charCodeAt(0), code !== 48) {
          if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
            return "";
          acc += input[i];
          break;
        }
      for (i += 1; i < input.length; i++) {
        if (code = input[i].charCodeAt(0), !(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
          return "";
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      return buffer.length = 0, !0;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        let hex3 = stringArrayToHexStripped(buffer);
        if (hex3 !== "")
          address.push(hex3);
        else
          return output.error = !0, !1;
        buffer.length = 0;
      }
      return !0;
    }
    function getIPV6(input) {
      let tokenCount = 0, output = { error: !1, address: "", zone: "" }, address = [], buffer = [], endipv6Encountered = !1, endIpv6 = !1, consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        let cursor = input[i];
        if (!(cursor === "[" || cursor === "]"))
          if (cursor === ":") {
            if (endipv6Encountered === !0 && (endIpv6 = !0), !consume(buffer, address, output))
              break;
            if (++tokenCount > 7) {
              output.error = !0;
              break;
            }
            i > 0 && input[i - 1] === ":" && (endipv6Encountered = !0), address.push(":");
            continue;
          } else if (cursor === "%") {
            if (!consume(buffer, address, output))
              break;
            consume = consumeIsZone;
          } else {
            buffer.push(cursor);
            continue;
          }
      }
      return buffer.length && (consume === consumeIsZone ? output.zone = buffer.join("") : endIpv6 ? address.push(buffer.join("")) : address.push(stringArrayToHexStripped(buffer))), output.address = address.join(""), output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2)
        return { host, isIPV6: !1 };
      let ipv63 = getIPV6(host);
      if (ipv63.error)
        return { host, isIPV6: !1 };
      {
        let newHost = ipv63.address, escapedHost = ipv63.address;
        return ipv63.zone && (newHost += "%" + ipv63.zone, escapedHost += "%25" + ipv63.zone), { host: newHost, isIPV6: !0, escapedHost };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++)
        str[i] === token && ind++;
      return ind;
    }
    function removeDotSegments(path) {
      let input = path, output = [], nextSlash = -1, len = 0;
      for (; len = input.length; ) {
        if (len === 1) {
          if (input === ".")
            break;
          if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".")
              break;
            if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/" && (input[1] === "." || input[1] === "/")) {
            output.push("/");
            break;
          }
        } else if (len === 3 && input === "/..") {
          output.length !== 0 && output.pop(), output.push("/");
          break;
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/" && input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === "." && input[3] === "/") {
            input = input.slice(3), output.length !== 0 && output.pop();
            continue;
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else
          output.push(input.slice(0, nextSlash)), input = input.slice(nextSlash);
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      let func = esc2 !== !0 ? escape : unescape;
      return component.scheme !== void 0 && (component.scheme = func(component.scheme)), component.userinfo !== void 0 && (component.userinfo = func(component.userinfo)), component.host !== void 0 && (component.host = func(component.host)), component.path !== void 0 && (component.path = func(component.path)), component.query !== void 0 && (component.query = func(component.query)), component.fragment !== void 0 && (component.fragment = func(component.fragment)), component;
    }
    function recomposeAuthority(component) {
      let uriTokens = [];
      if (component.userinfo !== void 0 && (uriTokens.push(component.userinfo), uriTokens.push("@")), component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          let ipV6res = normalizeIPv6(host);
          ipV6res.isIPV6 === !0 ? host = `[${ipV6res.escapedHost}]` : host = component.host;
        }
        uriTokens.push(host);
      }
      return (typeof component.port == "number" || typeof component.port == "string") && (uriTokens.push(":"), uriTokens.push(String(component.port))), uriTokens.length ? uriTokens.join("") : void 0;
    }
    module2.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/schemes.js"(exports2, module2) {
    "use strict";
    var { isUUID } = require_utils(), URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      return wsComponent.secure === !0 ? !0 : wsComponent.secure === !1 ? !1 : wsComponent.scheme ? wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S") : !1;
    }
    function httpParse(component) {
      return component.host || (component.error = component.error || "HTTP URIs must have a host."), component;
    }
    function httpSerialize(component) {
      let secure = String(component.scheme).toLowerCase() === "https";
      return (component.port === (secure ? 443 : 80) || component.port === "") && (component.port = void 0), component.path || (component.path = "/"), component;
    }
    function wsParse(wsComponent) {
      return wsComponent.secure = wsIsSecure(wsComponent), wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : ""), wsComponent.path = void 0, wsComponent.query = void 0, wsComponent;
    }
    function wsSerialize(wsComponent) {
      if ((wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") && (wsComponent.port = void 0), typeof wsComponent.secure == "boolean" && (wsComponent.scheme = wsComponent.secure ? "wss" : "ws", wsComponent.secure = void 0), wsComponent.resourceName) {
        let [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0, wsComponent.query = query, wsComponent.resourceName = void 0;
      }
      return wsComponent.fragment = void 0, wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path)
        return urnComponent.error = "URN can not be parsed", urnComponent;
      let matches = urnComponent.path.match(URN_REG);
      if (matches) {
        let scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase(), urnComponent.nss = matches[2];
        let urnScheme = `${scheme}:${options.nid || urnComponent.nid}`, schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0, schemeHandler && (urnComponent = schemeHandler.parse(urnComponent, options));
      } else
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      let scheme = options.scheme || urnComponent.scheme || "urn", nid = urnComponent.nid.toLowerCase(), urnScheme = `${scheme}:${options.nid || nid}`, schemeHandler = getSchemeHandler(urnScheme);
      schemeHandler && (urnComponent = schemeHandler.serialize(urnComponent, options));
      let uriComponent = urnComponent, nss = urnComponent.nss;
      return uriComponent.path = `${nid || options.nid}:${nss}`, options.skipEscape = !0, uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      let uuidComponent = urnComponent;
      return uuidComponent.uuid = uuidComponent.nss, uuidComponent.nss = void 0, !options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid)) && (uuidComponent.error = uuidComponent.error || "UUID is not valid."), uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      let urnComponent = uuidComponent;
      return urnComponent.nss = (uuidComponent.uuid || "").toLowerCase(), urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: wsParse,
        serialize: wsSerialize
      }
    ), wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    ), urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: !0
      }
    ), urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: !0
      }
    ), SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module2.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/index.js"(exports2, module2) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils(), { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      return typeof uri == "string" ? uri = /** @type {T} */
      serialize(parse3(uri, options), options) : typeof uri == "object" && (uri = /** @type {T} */
      parse3(serialize(uri, options), options)), uri;
    }
    function resolve(baseURI, relativeURI, options) {
      let schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" }, resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, !0);
      return schemelessOptions.skipEscape = !0, serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      let target = {};
      return skipNormalization || (base = parse3(serialize(base, options), options), relative = parse3(serialize(relative, options), options)), options = options || {}, !options.tolerant && relative.scheme ? (target.scheme = relative.scheme, target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0 ? (target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.path ? (relative.path[0] === "/" ? target.path = removeDotSegments(relative.path) : ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path ? target.path = "/" + relative.path : base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path, target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, relative.query !== void 0 ? target.query = relative.query : target.query = base.query), target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), target.scheme = base.scheme), target.fragment = relative.fragment, target;
    }
    function equal(uriA, uriB, options) {
      return typeof uriA == "string" ? (uriA = unescape(uriA), uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), !0), { ...options, skipEscape: !0 })) : typeof uriA == "object" && (uriA = serialize(normalizeComponentEncoding(uriA, !0), { ...options, skipEscape: !0 })), typeof uriB == "string" ? (uriB = unescape(uriB), uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), !0), { ...options, skipEscape: !0 })) : typeof uriB == "object" && (uriB = serialize(normalizeComponentEncoding(uriB, !0), { ...options, skipEscape: !0 })), uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      let component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      }, options = Object.assign({}, opts), uriTokens = [], schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      schemeHandler && schemeHandler.serialize && schemeHandler.serialize(component, options), component.path !== void 0 && (options.skipEscape ? component.path = unescape(component.path) : (component.path = escape(component.path), component.scheme !== void 0 && (component.path = component.path.split("%3A").join(":")))), options.reference !== "suffix" && component.scheme && uriTokens.push(component.scheme, ":");
      let authority = recomposeAuthority(component);
      if (authority !== void 0 && (options.reference !== "suffix" && uriTokens.push("//"), uriTokens.push(authority), component.path && component.path[0] !== "/" && uriTokens.push("/")), component.path !== void 0) {
        let s = component.path;
        !options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath) && (s = removeDotSegments(s)), authority === void 0 && s[0] === "/" && s[1] === "/" && (s = "/%2F" + s.slice(2)), uriTokens.push(s);
      }
      return component.query !== void 0 && uriTokens.push("?", component.query), component.fragment !== void 0 && uriTokens.push("#", component.fragment), uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      let options = Object.assign({}, opts), parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, isIP = !1;
      options.reference === "suffix" && (options.scheme ? uri = options.scheme + ":" + uri : uri = "//" + uri);
      let matches = uri.match(URI_PARSE);
      if (matches) {
        if (parsed.scheme = matches[1], parsed.userinfo = matches[3], parsed.host = matches[4], parsed.port = parseInt(matches[5], 10), parsed.path = matches[6] || "", parsed.query = matches[7], parsed.fragment = matches[8], isNaN(parsed.port) && (parsed.port = matches[5]), parsed.host)
          if (isIPv4(parsed.host) === !1) {
            let ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase(), isIP = ipv6result.isIPV6;
          } else
            isIP = !0;
        parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path ? parsed.reference = "same-document" : parsed.scheme === void 0 ? parsed.reference = "relative" : parsed.fragment === void 0 ? parsed.reference = "absolute" : parsed.reference = "uri", options.reference && options.reference !== "suffix" && options.reference !== parsed.reference && (parsed.error = parsed.error || "URI is not a " + options.reference + " reference.");
        let schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport) && parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === !1 && nonSimpleDomain(parsed.host))
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) && (uri.indexOf("%") !== -1 && (parsed.scheme !== void 0 && (parsed.scheme = unescape(parsed.scheme)), parsed.host !== void 0 && (parsed.host = unescape(parsed.host))), parsed.path && (parsed.path = escape(unescape(parsed.path))), parsed.fragment && (parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment)))), schemeHandler && schemeHandler.parse && schemeHandler.parse(parsed, options);
      } else
        parsed.error = parsed.error || "URI can not be parsed.";
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module2.exports = fastUri;
    module2.exports.default = fastUri;
    module2.exports.fastUri = fastUri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/uri.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports2.default = uri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/core.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error(), ref_error_1 = require_ref_error(), rules_1 = require_rules(), compile_1 = require_compile(), codegen_2 = require_codegen(), resolve_1 = require_resolve(), dataType_1 = require_dataType(), util_1 = require_util(), $dataRefSchema = require_data(), uri_1 = require_uri(), defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"], EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      let s = o.strict, _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize, optimize = _optz === !0 || _optz === void 0 ? 1 : _optz || 0, regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp, uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : !0,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : !0,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : !1,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : !0,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : !0,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : !0,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : !0,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : !0,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : !0,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : !0,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : !0,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), opts = this.opts = { ...opts, ...requiredOptions(opts) };
        let { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines }), this.logger = getLogger(opts.logger);
        let formatOpt = opts.validateFormats;
        opts.validateFormats = !1, this.RULES = (0, rules_1.getRules)(), checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED"), checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn"), this._metaOpts = getMetaSchemaOptions.call(this), opts.formats && addInitialFormats.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), opts.keywords && addInitialKeywords.call(this, opts.keywords), typeof opts.meta == "object" && this.addMetaSchema(opts.meta), addInitialSchemas.call(this), opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data, meta: meta3, schemaId } = this.opts, _dataRefSchema = $dataRefSchema;
        schemaId === "id" && (_dataRefSchema = { ...$dataRefSchema }, _dataRefSchema.id = _dataRefSchema.$id, delete _dataRefSchema.$id), meta3 && $data && this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], !1);
      }
      defaultMeta() {
        let { meta: meta3, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          if (v = this.getSchema(schemaKeyRef), !v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else
          v = this.compile(schemaKeyRef);
        let valid = v(data);
        return "$async" in v || (this.errors = v.errors), valid;
      }
      compile(schema, _meta) {
        let sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta3) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        let { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta3);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          let sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          $ref && !this.getSchema($ref) && await runCompileAsync.call(this, { $ref }, !0);
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            return checkLoaded.call(this, e), await loadMissingSchema.call(this, e.missingSchema), _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref])
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
        async function loadMissingSchema(ref) {
          let _schema = await _loadSchema.call(this, ref);
          this.refs[ref] || await loadMetaSchema.call(this, _schema.$schema), this.refs[ref] || this.addSchema(_schema, ref, meta3);
        }
        async function _loadSchema(ref) {
          let p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (let sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema == "object") {
          let { schemaId } = this.opts;
          if (id = schema[schemaId], id !== void 0 && typeof id != "string")
            throw new Error(`schema ${schemaId} must be string`);
        }
        return key = (0, resolve_1.normalizeId)(key || id), this._checkUnique(key), this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        return this.addSchema(schema, key, !0, _validateSchema), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return !0;
        let $schema;
        if ($schema = schema.$schema, $schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        if ($schema = $schema || this.opts.defaultMeta || this.defaultMeta(), !$schema)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        let valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          let message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        for (; typeof (sch = getSchEnv.call(this, keyRef)) == "string"; )
          keyRef = sch;
        if (sch === void 0) {
          let { schemaId } = this.opts, root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          if (sch = compile_1.resolveSchema.call(this, root, keyRef), !sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp)
          return this._removeAllSchemas(this.schemas, schemaKeyRef), this._removeAllSchemas(this.refs, schemaKeyRef), this;
        switch (typeof schemaKeyRef) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            let sch = getSchEnv.call(this, schemaKeyRef);
            return typeof sch == "object" && this._cache.delete(sch.schema), delete this.schemas[schemaKeyRef], delete this.refs[schemaKeyRef], this;
          }
          case "object": {
            let cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            return id && (id = (0, resolve_1.normalizeId)(id), delete this.schemas[id], delete this.refs[id]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (let def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string")
          keyword = kwdOrDef, typeof def == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), def.keyword = keyword);
        else if (typeof kwdOrDef == "object" && def === void 0) {
          if (def = kwdOrDef, keyword = def.keyword, Array.isArray(keyword) && !keyword.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (checkKeyword.call(this, keyword, def), !def)
          return (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd)), this;
        keywordMetaschema.call(this, def);
        let definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        return (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))), this;
      }
      getKeyword(keyword) {
        let rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        let { RULES } = this;
        delete RULES.keywords[keyword], delete RULES.all[keyword];
        for (let group of RULES.rules) {
          let i = group.rules.findIndex((rule) => rule.keyword === keyword);
          i >= 0 && group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        return typeof format == "string" && (format = new RegExp(format)), this.formats[name] = format, this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        return !errors || errors.length === 0 ? "No errors" : errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        let rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (let jsonPointer of keywordsJsonPointers) {
          let segments = jsonPointer.split("/").slice(1), keywords = metaSchema;
          for (let seg of segments)
            keywords = keywords[seg];
          for (let key in rules) {
            let rule = rules[key];
            if (typeof rule != "object")
              continue;
            let { $data } = rule.definition, schema = keywords[key];
            $data && schema && (keywords[key] = schemaOrData(schema));
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (let keyRef in schemas) {
          let sch = schemas[keyRef];
          (!regex || regex.test(keyRef)) && (typeof sch == "string" ? delete schemas[keyRef] : sch && !sch.meta && (this._cache.delete(sch.schema), delete schemas[keyRef]));
        }
      }
      _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id, { schemaId } = this.opts;
        if (typeof schema == "object")
          id = schema[schemaId];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        let localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        return sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs }), this._cache.set(sch.schema, sch), addSchema && !baseId.startsWith("#") && (baseId && this._checkUnique(baseId), this.refs[baseId] = sch), validateSchema && this.validateSchema(schema, !0), sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id])
          throw new Error(`schema with key or id "${id}" already exists`);
      }
      _compileSchemaEnv(sch) {
        if (sch.meta ? this._compileMetaSchema(sch) : compile_1.compileSchema.call(this, sch), !sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        let currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports2.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (let key in checkOpts) {
        let opt = key;
        opt in options && this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      return keyRef = (0, resolve_1.normalizeId)(keyRef), this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      let optsSchemas = this.opts.schemas;
      if (optsSchemas)
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (let key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (let name in this.opts.formats) {
        let format = this.opts.formats[name];
        format && this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let keyword in defs) {
        let def = defs[keyword];
        def.keyword || (def.keyword = keyword), this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      let metaOpts = { ...this.opts };
      for (let opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === !1)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      let { RULES } = this;
      if ((0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      }), !!def && def.$data && !("code" in def || "validate" in def))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      let post = definition?.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      let { RULES } = this, ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (ruleGroup || (ruleGroup = { type: dataType, rules: [] }, RULES.rules.push(ruleGroup)), RULES.keywords[keyword] = !0, !definition)
        return;
      let rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      definition.before ? addBeforeRule.call(this, ruleGroup, rule, definition.before) : ruleGroup.rules.push(rule), RULES.all[keyword] = rule, (_a2 = definition.implements) === null || _a2 === void 0 || _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      let i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      i >= 0 ? ruleGroup.rules.splice(i, 0, rule) : (ruleGroup.rules.push(rule), this.logger.warn(`rule ${before} is not defined`));
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      metaSchema !== void 0 && (def.$data && this.opts.$data && (metaSchema = schemaOrData(metaSchema)), def.validateSchema = this.compile(metaSchema, !0));
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.callRef = exports2.getValidate = void 0;
    var ref_error_1 = require_ref_error(), code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), compile_1 = require_compile(), util_1 = require_util(), def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        let { gen, schema: $ref, it } = cxt, { baseId, schemaEnv: env, validateName, opts, self } = it, { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        let schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          let rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          let v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          let schName = gen.scopeValue("schema", opts.code.source === !0 ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch }), valid = gen.name("valid"), schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt), cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      let { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports2.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      let { gen, it } = cxt, { allErrors, schemaEnv: env, opts } = it, passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      $async ? callAsyncRef() : callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        let valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`), addEvaluatedFrom(v), allErrors || gen.assign(valid, !0);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e)), addErrorsFrom(e), allErrors || gen.assign(valid, !1);
        }), cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        let errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`), gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        let schEvaluated = (_a2 = sch?.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== !0)
          if (schEvaluated && !schEvaluated.dynamicProps)
            schEvaluated.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props));
          else {
            let props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        if (it.items !== !0)
          if (schEvaluated && !schEvaluated.dynamicItems)
            schEvaluated.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items));
          else {
            let items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
      }
    }
    exports2.callRef = callRef;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var id_1 = require_id(), ref_1 = require_ref(), core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports2.default = core;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    }, def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    }, def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, it } = cxt, prec = it.opts.multipleOfPrecision, res = gen.let("res"), invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    function ucs2length(str) {
      let len = str.length, length = 0, pos = 0, value;
      for (; pos < len; )
        length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), (value & 64512) === 56320 && pos++);
      return length;
    }
    exports2.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), ucs2length_1 = require_ucs2length(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode, it } = cxt, op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT, len = it.opts.unicode === !1 ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    }, def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { data, $data, schema, schemaCode, it } = cxt, u = it.opts.unicodeRegExp ? "u" : "", regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    }, def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, schemaCode, data, $data, it } = cxt, { opts } = it;
        if (!$data && schema.length === 0)
          return;
        let useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors ? allErrorsMode() : exitOnErrorMode(), opts.strictRequired) {
          let props = cxt.parentSchema.properties, { definedProperties } = cxt.it;
          for (let requiredKey of schema)
            if (props?.[requiredKey] === void 0 && !definedProperties.has(requiredKey)) {
              let schemaPath = it.schemaEnv.baseId + it.errSchemaPath, msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
        }
        function allErrorsMode() {
          if (useLoop || $data)
            cxt.block$data(codegen_1.nil, loopAllRequired);
          else
            for (let prop of schema)
              (0, code_1.checkReportMissingProp)(cxt, prop);
        }
        function exitOnErrorMode() {
          let missing = gen.let("missing");
          if (useLoop || $data) {
            let valid = gen.let("valid", !0);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid)), cxt.ok(valid);
          } else
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing)), (0, code_1.reportMissingProp)(cxt, missing), gen.else();
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop }), gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing }), gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties)), gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(), gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/equal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports2.default = equal;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var dataType_1 = require_dataType(), codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    }, def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        let valid = gen.let("valid"), itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`), cxt.ok(valid);
        function validateUniqueItems() {
          let i = gen.let("i", (0, codegen_1._)`${data}.length`), j = gen.let("j");
          cxt.setParams({ i, j }), gen.assign(valid, !0), gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          let item = gen.name("item"), wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong), indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`), gen.if(wrongType, (0, codegen_1._)`continue`), itemTypes.length > 1 && gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`), gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`), cxt.error(), gen.assign(valid, !1).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          let eql = (0, util_1.useFunc)(gen, equal_1.default), outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error(), gen.assign(valid, !1).break(outer);
          })));
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    }, def = {
      keyword: "const",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schemaCode, schema } = cxt;
        $data || schema && typeof schema == "object" ? cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`) : cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    }, def = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        let useLoop = schema.length >= it.opts.loopEnum, eql, getEql = () => eql ?? (eql = (0, util_1.useFunc)(gen, equal_1.default)), valid;
        if (useLoop || $data)
          valid = gen.let("valid"), cxt.block$data(valid, loopEnum);
        else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          let vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, !1), gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, !0).break()));
        }
        function equalCode(vSchema, i) {
          let sch = schema[i];
          return typeof sch == "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var limitNumber_1 = require_limitNumber(), multipleOf_1 = require_multipleOf(), limitLength_1 = require_limitLength(), pattern_1 = require_pattern(), limitProperties_1 = require_limitProperties(), required_1 = require_required(), limitItems_1 = require_limitItems(), uniqueItems_1 = require_uniqueItems(), const_1 = require_const(), enum_1 = require_enum(), validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports2.default = validation;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { parentSchema, it } = cxt, { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      let { gen, schema, data, keyword, it } = cxt;
      it.items = !0;
      let len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === !1)
        cxt.setParams({ len: items.length }), cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        let valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid)), cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid), it.allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports2.validateAdditionalItems = validateAdditionalItems;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateTuple = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        let { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      let { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema), it.opts.unevaluated && schArr.length && it.items !== !0 && (it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items));
      let valid = gen.name("valid"), len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        (0, util_1.alwaysValidSchema)(it, sch) || (gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid)), cxt.ok(valid));
      });
      function checkStrictTuple(sch) {
        let { opts, errSchemaPath } = it, l = schArr.length, fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === !1);
        if (opts.strictTuples && !fullTuple) {
          let msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports2.validateTuple = validateTuple;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var items_1 = require_items(), def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), additionalItems_1 = require_additionalItems(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { schema, parentSchema, it } = cxt, { prefixItems } = parentSchema;
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && (prefixItems ? (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems) : cxt.ok((0, code_1.validateArray)(cxt)));
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    }, def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt, min, max, { minContains, maxContains } = parentSchema;
        it.opts.next ? (min = minContains === void 0 ? 1 : minContains, max = maxContains) : min = 1;
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (cxt.setParams({ min, max }), max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid'), cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          max !== void 0 && (cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`), cxt.pass(cond);
          return;
        }
        it.items = !0;
        let valid = gen.name("valid");
        max === void 0 && min === 1 ? validateItems(valid, () => gen.if(valid, () => gen.break())) : min === 0 ? (gen.let(valid, !0), max !== void 0 && gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount)) : (gen.let(valid, !1), validateItemsWithCount()), cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          let schValid = gen.name("_valid"), count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: !0
            }, _valid), block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`), max === void 0 ? gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0).break()) : (gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, !1).break()), min === 1 ? gen.assign(valid, !0) : gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0)));
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.validateSchemaDeps = exports2.validatePropertyDeps = exports2.error = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2();
    exports2.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        let property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports2.error,
      code(cxt) {
        let [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps), validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      let propertyDeps = {}, schemaDeps = {};
      for (let key in schema) {
        if (key === "__proto__")
          continue;
        let deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      let { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      let missing = gen.let("missing");
      for (let prop in propertyDeps) {
        let deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        let hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        }), it.allErrors ? gen.if(hasProperty, () => {
          for (let depProp of deps)
            (0, code_1.checkReportMissingProp)(cxt, depProp);
        }) : (gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`), (0, code_1.reportMissingProp)(cxt, missing), gen.else());
      }
    }
    exports2.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      for (let prop in schemaDeps)
        (0, util_1.alwaysValidSchema)(it, schemaDeps[prop]) || (gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            let schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, !0)
          // TODO var
        ), cxt.ok(valid));
    }
    exports2.validateSchemaDeps = validateSchemaDeps;
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    }, def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error2,
      code(cxt) {
        let { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        let valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key }), cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: !0
          }, valid), gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(!0), it.allErrors || gen.break();
          });
        }), cxt.ok(valid);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), util_1 = require_util(), error2 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    }, def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        let { allErrors, opts } = it;
        if (it.props = !0, opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        let props = (0, code_1.allSchemaProperties)(parentSchema.properties), patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties(), cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            !props.length && !patProps.length ? additionalPropertyCode(key) : gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            let propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else props.length ? definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`)) : definedProp = codegen_1.nil;
          return patProps.length && (definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`))), (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === !1) {
            deleteAdditional(key);
            return;
          }
          if (schema === !1) {
            cxt.setParams({ additionalProperty: key }), cxt.error(), allErrors || gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            let valid = gen.name("valid");
            opts.removeAdditional === "failing" ? (applyAdditionalSchema(key, valid, !1), gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset(), deleteAdditional(key);
            })) : (applyAdditionalSchema(key, valid), allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break()));
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          let subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          errors === !1 && Object.assign(subschema, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), cxt.subschema(subschema, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var validate_1 = require_validate(), code_1 = require_code2(), util_1 = require_util(), additionalProperties_1 = require_additionalProperties(), def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt;
        it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0 && additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        let allProps = (0, code_1.allSchemaProperties)(schema);
        for (let prop of allProps)
          it.definedProperties.add(prop);
        it.opts.unevaluated && allProps.length && it.props !== !0 && (it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props));
        let properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        let valid = gen.name("valid");
        for (let prop of properties)
          hasDefault(prop) ? applyPropertySchema(prop) : (gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)), applyPropertySchema(prop), it.allErrors || gen.else().var(valid, !0), gen.endIf()), cxt.it.definedProperties.add(prop), cxt.ok(valid);
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), util_2 = require_util(), def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, data, parentSchema, it } = cxt, { opts } = it, patterns = (0, code_1.allSchemaProperties)(schema), alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === !0))
          return;
        let checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties, valid = gen.name("valid");
        it.props !== !0 && !(it.props instanceof codegen_1.Name) && (it.props = (0, util_2.evaluatedPropsToName)(gen, it.props));
        let { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (let pat of patterns)
            checkProperties && checkMatchingProperties(pat), it.allErrors ? validateProperties(pat) : (gen.var(valid, !0), validateProperties(pat), gen.if(valid));
        }
        function checkMatchingProperties(pat) {
          for (let prop in checkProperties)
            new RegExp(pat).test(prop) && (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              let alwaysValid = alwaysValidPatterns.includes(pat);
              alwaysValid || cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid), it.opts.unevaluated && props !== !0 ? gen.assign((0, codegen_1._)`${props}[${key}]`, !0) : !alwaysValid && !it.allErrors && gen.if((0, codegen_1.not)(valid), () => gen.break());
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(cxt) {
        let { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        let valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, valid), cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var code_1 = require_code2(), def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    }, def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        let schArr = schema, valid = gen.let("valid", !1), passing = gen.let("passing", null), schValid = gen.name("_valid");
        cxt.setParams({ passing }), gen.block(validateOneOf), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            (0, util_1.alwaysValidSchema)(it, sch) ? gen.var(schValid, !0) : schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: !0
            }, schValid), i > 0 && gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, !1).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else(), gen.if(schValid, () => {
              gen.assign(valid, !0), gen.assign(passing, i), schCxt && cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        let { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        let valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          let schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid), cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    }, def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, parentSchema, it } = cxt;
        parentSchema.then === void 0 && parentSchema.else === void 0 && (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        let hasThen = hasSchema(it, "then"), hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        let valid = gen.let("valid", !0), schValid = gen.name("_valid");
        if (validateIf(), cxt.reset(), hasThen && hasElse) {
          let ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause }), gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else hasThen ? gen.if(schValid, validateClause("then")) : gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        cxt.pass(valid, () => cxt.error(!0));
        function validateIf() {
          let schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            let schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid), cxt.mergeValidEvaluated(schCxt, valid), ifClause ? gen.assign(ifClause, (0, codegen_1._)`${keyword}`) : cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      let schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        parentSchema.if === void 0 && (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var additionalItems_1 = require_additionalItems(), prefixItems_1 = require_prefixItems(), items_1 = require_items(), items2020_1 = require_items2020(), contains_1 = require_contains(), dependencies_1 = require_dependencies(), propertyNames_1 = require_propertyNames(), additionalProperties_1 = require_additionalProperties(), properties_1 = require_properties(), patternProperties_1 = require_patternProperties(), not_1 = require_not(), anyOf_1 = require_anyOf(), oneOf_1 = require_oneOf(), allOf_1 = require_allOf(), if_1 = require_if(), thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = !1) {
      let applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      return draft2020 ? applicator.push(prefixItems_1.default, items2020_1.default) : applicator.push(additionalItems_1.default, items_1.default), applicator.push(contains_1.default), applicator;
    }
    exports2.default = getApplicator;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    }, def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt, ruleType) {
        let { gen, data, $data, schema, schemaCode, it } = cxt, { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        $data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`), fType = gen.let("fType"), format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)), cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            return opts.strictSchema === !1 ? codegen_1.nil : (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            let callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`, validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          let formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === !0)
            return;
          let [fmtType, format, fmtRef] = getFormat(formatDef);
          fmtType === ruleType && cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === !1) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            let code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0, fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            return typeof fmtDef == "object" && !(fmtDef instanceof RegExp) ? [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`] : ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var format_1 = require_format(), format = [format_1.default];
    exports2.default = format;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.contentVocabulary = exports2.metadataVocabulary = void 0;
    exports2.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports2.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var core_1 = require_core2(), validation_1 = require_validation(), applicator_1 = require_applicator(), format_1 = require_format2(), metadata_1 = require_metadata(), draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports2.default = draft7Vocabularies;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2.Tag = "tag", DiscrError2.Mapping = "mapping";
    })(DiscrError || (exports2.DiscrError = DiscrError = {}));
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), types_1 = require_types(), compile_1 = require_compile(), ref_error_1 = require_ref_error(), util_1 = require_util(), error2 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    }, def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error2,
      code(cxt) {
        let { gen, data, schema, parentSchema, it } = cxt, { oneOf } = parentSchema;
        if (!it.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        let tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        let valid = gen.let("valid", !1), tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(!1, { discrError: types_1.DiscrError.Tag, tag, tagName })), cxt.ok(valid);
        function validateMapping() {
          let mapping = getMapping();
          gen.if(!1);
          for (let tagValue in mapping)
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`), gen.assign(valid, applyTagSchema(mapping[tagValue]));
          gen.else(), cxt.error(!1, { discrError: types_1.DiscrError.Mapping, tag, tagName }), gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          let _valid = gen.name("valid"), schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          return cxt.mergeEvaluated(schCxt, codegen_1.Name), _valid;
        }
        function getMapping() {
          var _a2;
          let oneOfMapping = {}, topRequired = hasRequired(parentSchema), tagRequired = !0;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (sch?.$ref && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              let ref = sch.$ref;
              if (sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref), sch instanceof compile_1.SchemaEnv && (sch = sch.schema), sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            let propSch = (_a2 = sch?.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            tagRequired = tagRequired && (topRequired || hasRequired(sch)), addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const)
              addMapping(sch.const, i);
            else if (sch.enum)
              for (let tagValue of sch.enum)
                addMapping(tagValue, i);
            else
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping)
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports2.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports2, module2) {
    module2.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: !0,
        readOnly: {
          type: "boolean",
          default: !1
        },
        examples: {
          type: "array",
          items: !0
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: !1
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: {
          type: "array",
          items: !0,
          minItems: 1,
          uniqueItems: !0
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: !0
    };
  }
});

// mcp-servers-src/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/ajv.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.MissingRefError = exports2.ValidationError = exports2.CodeGen = exports2.Name = exports2.nil = exports2.stringify = exports2.str = exports2._ = exports2.KeywordCxt = exports2.Ajv = void 0;
    var core_1 = require_core(), draft7_1 = require_draft7(), discriminator_1 = require_discriminator(), draft7MetaSchema = require_json_schema_draft_07(), META_SUPPORT_DATA = ["/properties"], META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies(), draft7_1.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        let metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, !1), this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports2.Ajv = Ajv2;
    module2.exports = exports2 = Ajv2;
    module2.exports.Ajv = Ajv2;
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports2, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports2, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports2, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports2, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports2, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports2, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports2, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports2, "ValidationError", { enumerable: !0, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports2, "MissingRefError", { enumerable: !0, get: function() {
      return ref_error_1.default;
    } });
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/formats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.formatNames = exports2.fastFormats = exports2.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports2.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date4, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(!0), compareTime),
      "date-time": fmtDef(getDateTime(!0), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    };
    exports2.fastFormats = {
      ...exports2.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports2.formatNames = Object.keys(exports2.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date4(str) {
      let matches = DATE.exec(str);
      if (!matches)
        return !1;
      let year = +matches[1], month = +matches[2], day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (d1 && d2)
        return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function(str) {
        let matches = TIME.exec(str);
        if (!matches)
          return !1;
        let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return !1;
        if (hr <= 23 && min <= 59 && sec < 60)
          return !0;
        let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return;
      let t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf(), t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (t1 && t2)
        return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return;
      let a1 = TIME.exec(t1), a2 = TIME.exec(t2);
      if (a1 && a2)
        return t1 = a1[1] + a1[2] + a1[3], t2 = a2[1] + a2[2] + a2[3], t1 > t2 ? 1 : t1 < t2 ? -1 : 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      let time3 = getTime(strictTimeZone);
      return function(str) {
        let dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date4(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let d1 = new Date(dt1).valueOf(), d2 = new Date(dt2).valueOf();
      if (d1 && d2)
        return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let [d1, t1] = dt1.split(DATE_TIME_SEPARATOR), [d2, t2] = dt2.split(DATE_TIME_SEPARATOR), res = compareDate(d1, d2);
      if (res !== void 0)
        return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      return BYTE.lastIndex = 0, BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31), MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return !0;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return !1;
      try {
        return new RegExp(str), !0;
      } catch {
        return !1;
      }
    }
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/limit.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv(), codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports2.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, keyword, it } = cxt, { opts, self } = it;
        if (!opts.validateFormats)
          return;
        let fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        fCxt.$data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          let format = fCxt.schema, fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === !0)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function")
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          let fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => (ajv.addKeyword(exports2.formatLimitDefinition), ajv);
    exports2.default = formatLimitPlugin;
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/index.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    var formats_1 = require_formats(), limit_1 = require_limit(), codegen_1 = require_codegen(), fullName = new codegen_1.Name("fullFormats"), fastName = new codegen_1.Name("fastFormats"), formatsPlugin = (ajv, opts = { keywords: !0 }) => {
      if (Array.isArray(opts))
        return addFormats(ajv, opts, formats_1.fullFormats, fullName), ajv;
      let [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName], list = opts.formats || formats_1.formatNames;
      return addFormats(ajv, list, formats, exportName), opts.keywords && (0, limit_1.default)(ajv), ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      let f = (mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats)[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a2, _b;
      (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== void 0 || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
      for (let f of list)
        ajv.addFormat(f, fs[f]);
    }
    module2.exports = exports2 = formatsPlugin;
    Object.defineProperty(exports2, "__esModule", { value: !0 });
    exports2.default = formatsPlugin;
  }
});

// mcp-servers-src/node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2, util2.arrayToEnum = (items) => {
    let obj = {};
    for (let item of items)
      obj[item] = item;
    return obj;
  }, util2.getValidEnumValues = (obj) => {
    let validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] != "number"), filtered = {};
    for (let k of validKeys)
      filtered[k] = obj[k];
    return util2.objectValues(filtered);
  }, util2.objectValues = (obj) => util2.objectKeys(obj).map(function(e) {
    return obj[e];
  }), util2.objectKeys = typeof Object.keys == "function" ? (obj) => Object.keys(obj) : (object3) => {
    let keys = [];
    for (let key in object3)
      Object.prototype.hasOwnProperty.call(object3, key) && keys.push(key);
    return keys;
  }, util2.find = (arr, checker) => {
    for (let item of arr)
      if (checker(item))
        return item;
  }, util2.isInteger = typeof Number.isInteger == "function" ? (val) => Number.isInteger(val) : (val) => typeof val == "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val == "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2, util2.jsonStringifyReplacer = (_, value) => typeof value == "bigint" ? value.toString() : value;
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => ({
    ...first,
    ...second
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (data) => {
  switch (typeof data) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(data) ? ZodParsedType.array : data === null ? ZodParsedType.null : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && data instanceof Map ? ZodParsedType.map : typeof Set < "u" && data instanceof Set ? ZodParsedType.set : typeof Date < "u" && data instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// mcp-servers-src/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super(), this.issues = [], this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    }, this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    let actualProto = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, actualProto) : this.__proto__ = actualProto, this.name = "ZodError", this.issues = issues;
  }
  format(_mapper) {
    let mapper = _mapper || function(issue2) {
      return issue2.message;
    }, fieldErrors = { _errors: [] }, processError = (error2) => {
      for (let issue2 of error2.issues)
        if (issue2.code === "invalid_union")
          issue2.unionErrors.map(processError);
        else if (issue2.code === "invalid_return_type")
          processError(issue2.returnTypeError);
        else if (issue2.code === "invalid_arguments")
          processError(issue2.argumentsError);
        else if (issue2.path.length === 0)
          fieldErrors._errors.push(mapper(issue2));
        else {
          let curr = fieldErrors, i = 0;
          for (; i < issue2.path.length; ) {
            let el = issue2.path[i];
            i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
          }
        }
    };
    return processError(this), fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError))
      throw new Error(`Not a ZodError: ${value}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    let fieldErrors = /* @__PURE__ */ Object.create(null), formErrors = [];
    for (let sub of this.issues)
      if (sub.path.length > 0) {
        let firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [], fieldErrors[firstEl].push(mapper(sub));
      } else
        formErrors.push(mapper(sub));
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => new ZodError(issues);

// mcp-servers-src/node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      issue2.received === ZodParsedType.undefined ? message = "Required" : message = `Expected ${issue2.expected}, received ${issue2.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      message = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      message = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof issue2.validation == "object" ? "includes" in issue2.validation ? (message = `Invalid input: must include "${issue2.validation.includes}"`, typeof issue2.validation.position == "number" && (message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`)) : "startsWith" in issue2.validation ? message = `Invalid input: must start with "${issue2.validation.startsWith}"` : "endsWith" in issue2.validation ? message = `Invalid input: must end with "${issue2.validation.endsWith}"` : util.assertNever(issue2.validation) : issue2.validation !== "regex" ? message = `Invalid ${issue2.validation}` : message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "more than"} ${issue2.minimum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "over"} ${issue2.minimum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "bigint" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue2.minimum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "less than"} ${issue2.maximum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "under"} ${issue2.maximum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "bigint" ? message = `BigInt must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly" : issue2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue2.maximum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError, util.assertNever(issue2);
  }
  return { message };
}, en_default = errorMap;

// mcp-servers-src/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// mcp-servers-src/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  let { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0)
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  let errorMessage = "", maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (let map2 of maps)
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  let overrideMap = getErrorMap(), issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(status, results) {
    let arrayValue = [];
    for (let s of results) {
      if (s.status === "aborted")
        return INVALID;
      s.status === "dirty" && status.dirty(), arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    let syncPairs = [];
    for (let pair of pairs) {
      let key = await pair.key, value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    let finalObject = {};
    for (let pair of pairs) {
      let { key, value } = pair;
      if (key.status === "aborted" || value.status === "aborted")
        return INVALID;
      key.status === "dirty" && status.dirty(), value.status === "dirty" && status.dirty(), key.value !== "__proto__" && (typeof value.value < "u" || pair.alwaysSet) && (finalObject[key.value] = value.value);
    }
    return { status: status.value, value: finalObject };
  }
}, INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise < "u" && x instanceof Promise;

// mcp-servers-src/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message == "string" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message == "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// mcp-servers-src/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}, handleResult = (ctx, result) => {
  if (isValid(result))
    return { success: !0, data: result.value };
  if (!ctx.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      let error2 = new ZodError(ctx.common.issues);
      return this._error = error2, this._error;
    }
  };
};
function processCreateParams(params) {
  if (!params)
    return {};
  let { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return errorMap2 ? { errorMap: errorMap2, description } : { errorMap: (iss, ctx) => {
    let { message } = params;
    return iss.code === "invalid_enum_value" ? { message: message ?? ctx.defaultError } : typeof ctx.data > "u" ? { message: message ?? required_error ?? ctx.defaultError } : iss.code !== "invalid_type" ? { message: ctx.defaultError } : { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    let result = this._parse(input);
    if (isAsync(result))
      throw new Error("Synchronous parse encountered promise.");
    return result;
  }
  _parseAsync(input) {
    let result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    let result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    let ctx = {
      common: {
        issues: [],
        async: params?.async ?? !1,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    let ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async)
      try {
        let result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        err?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), ctx.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    let result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    let ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: !0
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    let getIssueProperties = (val) => typeof message == "string" || typeof message > "u" ? { message } : typeof message == "function" ? message(val) : message;
    return this._refinement((val, ctx) => {
      let result = check2(val), setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      return typeof Promise < "u" && result instanceof Promise ? result.then((data) => data ? !0 : (setError(), !1)) : result ? !0 : (setError(), !1);
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => check2(val) ? !0 : (ctx.addIssue(typeof refinementData == "function" ? refinementData(val, ctx) : refinementData), !1));
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    let defaultValueFunc = typeof def == "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    let catchValueFunc = typeof def == "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    let This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", emojiRegex, ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = "[0-5]\\d";
  args.precision ? secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}` : args.precision == null && (secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`);
  let secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`, opts = [];
  return opts.push(args.local ? "Z?" : "Z"), args.offset && opts.push("([+-]\\d{2}:?\\d{2})"), regex = `${regex}(${opts.join("|")})`, new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4Regex.test(ip) || (version2 === "v6" || !version2) && ipv6Regex.test(ip));
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return !1;
  try {
    let [header] = jwt2.split(".");
    if (!header)
      return !1;
    let base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "="), decoded = JSON.parse(atob(base643));
    return !(typeof decoded != "object" || decoded === null || "typ" in decoded && decoded?.typ !== "JWT" || !decoded.alg || alg && decoded.alg !== alg);
  } catch {
    return !1;
  }
}
function isValidCidr(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip) || (version2 === "v6" || !version2) && ipv6CidrRegex.test(ip));
}
var ZodString = class _ZodString2 extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = String(input.data)), this._getType(input) !== ZodParsedType.string) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      if (check2.kind === "min")
        input.data.length < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "max")
        input.data.length > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "length") {
        let tooBig = input.data.length > check2.value, tooSmall = input.data.length < check2.value;
        (tooBig || tooSmall) && (ctx = this._getOrReturnCtx(input, ctx), tooBig ? addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }) : tooSmall && addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }), status.dirty());
      } else if (check2.kind === "email")
        emailRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "uuid")
        uuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "nanoid")
        nanoidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid")
        cuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid2")
        cuid2Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "ulid")
        ulidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "url")
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          }), status.dirty();
        }
      else check2.kind === "regex" ? (check2.regex.lastIndex = 0, check2.regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "regex",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty())) : check2.kind === "trim" ? input.data = input.data.trim() : check2.kind === "includes" ? input.data.includes(check2.value, check2.position) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { includes: check2.value, position: check2.position },
        message: check2.message
      }), status.dirty()) : check2.kind === "toLowerCase" ? input.data = input.data.toLowerCase() : check2.kind === "toUpperCase" ? input.data = input.data.toUpperCase() : check2.kind === "startsWith" ? input.data.startsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { startsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "endsWith" ? input.data.endsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { endsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "datetime" ? datetimeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "datetime",
        message: check2.message
      }), status.dirty()) : check2.kind === "date" ? dateRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "date",
        message: check2.message
      }), status.dirty()) : check2.kind === "time" ? timeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "time",
        message: check2.message
      }), status.dirty()) : check2.kind === "duration" ? durationRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "duration",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "ip" ? isValidIP(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "ip",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "jwt" ? isValidJWT(input.data, check2.alg) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "jwt",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "cidr" ? isValidCidr(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "cidr",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64" ? base64Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64url" ? base64urlRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64url",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: options
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      offset: options?.offset ?? !1,
      local: options?.local ?? !1,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: options
    }) : this._addCheck({
      kind: "time",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxLength() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodString.create = (params) => new ZodString({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodString,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
function floatSafeRemainder(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepDecCount = (step.toString().split(".")[1] || "").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce && (input.data = Number(input.data)), this._getType(input) !== ZodParsedType.number) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      }), INVALID;
    }
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "int" ? util.isInteger(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: check2.message
      }), status.dirty()) : check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? floatSafeRemainder(input.data, check2.value) !== 0 && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : check2.kind === "finite" ? Number.isFinite(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_finite,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (let ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
        return !0;
      ch.kind === "min" ? (min === null || ch.value > min) && (min = ch.value) : ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce)
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    if (this._getType(input) !== ZodParsedType.bigint)
      return this._getInvalidInput(input);
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? input.data % check2.value !== BigInt(0) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    }), INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodBigInt.create = (params) => new ZodBigInt({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodBigInt,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = !!input.data), this._getType(input) !== ZodParsedType.boolean) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = new Date(input.data)), this._getType(input) !== ZodParsedType.date) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      }), INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      check2.kind === "min" ? input.data.getTime() < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        minimum: check2.value,
        type: "date"
      }), status.dirty()) : check2.kind === "max" ? input.data.getTime() > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        maximum: check2.value,
        type: "date"
      }), status.dirty()) : util.assertNever(check2);
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => new ZodDate({
  checks: [],
  coerce: params?.coerce || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(params)
});
var ZodSymbol = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.symbol) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(params)
});
var ZodUndefined = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(params)
});
var ZodNull = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.null) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(params)
});
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(params)
});
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(params)
});
var ZodNever = class extends ZodType {
  _parse(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    }), INVALID;
  }
};
ZodNever.create = (params) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(params)
});
var ZodVoid = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(params)
});
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    let { ctx, status } = this._processInputParams(input), def = this._def;
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (def.exactLength !== null) {
      let tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;
      (tooBig || tooSmall) && (addIssueToContext(ctx, {
        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: tooSmall ? def.exactLength.value : void 0,
        maximum: tooBig ? def.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: def.exactLength.message
      }), status.dirty());
    }
    if (def.minLength !== null && ctx.data.length < def.minLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.minLength.message
    }), status.dirty()), def.maxLength !== null && ctx.data.length > def.maxLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.maxLength.message
    }), status.dirty()), ctx.common.async)
      return Promise.all([...ctx.data].map((item, i) => def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result2) => ParseStatus.mergeArray(status, result2));
    let result = [...ctx.data].map((item, i) => def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => new ZodArray({
  type: schema,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(params)
});
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    let newShape = {};
    for (let key in schema.shape) {
      let fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else return schema instanceof ZodArray ? new ZodArray({
    ...schema._def,
    type: deepPartialify(schema.element)
  }) : schema instanceof ZodOptional ? ZodOptional.create(deepPartialify(schema.unwrap())) : schema instanceof ZodNullable ? ZodNullable.create(deepPartialify(schema.unwrap())) : schema instanceof ZodTuple ? ZodTuple.create(schema.items.map((item) => deepPartialify(item))) : schema;
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    let shape = this._def.shape(), keys = util.objectKeys(shape);
    return this._cached = { shape, keys }, this._cached;
  }
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.object) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      }), INVALID;
    }
    let { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (let key in ctx.data)
        shapeKeys.includes(key) || extraKeys.push(key);
    let pairs = [];
    for (let key of shapeKeys) {
      let keyValidator = shape[key], value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      let unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough")
        for (let key of extraKeys)
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
      else if (unknownKeys === "strict")
        extraKeys.length > 0 && (addIssueToContext(ctx, {
          code: ZodIssueCode.unrecognized_keys,
          keys: extraKeys
        }), status.dirty());
      else if (unknownKeys !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let catchall = this._def.catchall;
      for (let key of extraKeys) {
        let value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    return ctx.common.async ? Promise.resolve().then(async () => {
      let syncPairs = [];
      for (let pair of pairs) {
        let key = await pair.key, value = await pair.value;
        syncPairs.push({
          key,
          value,
          alwaysSet: pair.alwaysSet
        });
      }
      return syncPairs;
    }).then((syncPairs) => ParseStatus.mergeObjectSync(status, syncPairs)) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    return errorUtil.errToObj, new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          let defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          return issue2.code === "unrecognized_keys" ? {
            message: errorUtil.errToObj(message).message ?? defaultError
          } : {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    return new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    let shape = {};
    for (let key of util.objectKeys(mask))
      mask[key] && this.shape[key] && (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    let shape = {};
    for (let key of util.objectKeys(this.shape))
      mask[key] || (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape)) {
      let fieldSchema = this.shape[key];
      mask && !mask[key] ? newShape[key] = fieldSchema : newShape[key] = fieldSchema.optional();
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape))
      if (mask && !mask[key])
        newShape[key] = this.shape[key];
      else {
        let newField = this.shape[key];
        for (; newField instanceof ZodOptional; )
          newField = newField._def.innerType;
        newShape[key] = newField;
      }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.strictCreate = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.lazycreate = (shape, params) => new ZodObject({
  shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
var ZodUnion = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), options = this._def.options;
    function handleResults(results) {
      for (let result of results)
        if (result.result.status === "valid")
          return result.result;
      for (let result of results)
        if (result.result.status === "dirty")
          return ctx.common.issues.push(...result.ctx.common.issues), result.result;
      let unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
    if (ctx.common.async)
      return Promise.all(options.map(async (option) => {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    {
      let dirty, issues = [];
      for (let option of options) {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }, result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid")
          return result;
        result.status === "dirty" && !dirty && (dirty = { result, ctx: childCtx }), childCtx.common.issues.length && issues.push(childCtx.common.issues);
      }
      if (dirty)
        return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
      let unionErrors = issues.map((issues2) => new ZodError(issues2));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => new ZodUnion({
  options: types,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(params)
});
var getDiscriminator = (type) => type instanceof ZodLazy ? getDiscriminator(type.schema) : type instanceof ZodEffects ? getDiscriminator(type.innerType()) : type instanceof ZodLiteral ? [type.value] : type instanceof ZodEnum ? type.options : type instanceof ZodNativeEnum ? util.objectValues(type.enum) : type instanceof ZodDefault ? getDiscriminator(type._def.innerType) : type instanceof ZodUndefined ? [void 0] : type instanceof ZodNull ? [null] : type instanceof ZodOptional ? [void 0, ...getDiscriminator(type.unwrap())] : type instanceof ZodNullable ? [null, ...getDiscriminator(type.unwrap())] : type instanceof ZodBranded || type instanceof ZodReadonly ? getDiscriminator(type.unwrap()) : type instanceof ZodCatch ? getDiscriminator(type._def.innerType) : [], ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);
    return option ? ctx.common.async ? option._parseAsync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : option._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : (addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [discriminator]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    let optionsMap = /* @__PURE__ */ new Map();
    for (let type of options) {
      let discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length)
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      for (let value of discriminatorValues) {
        if (optionsMap.has(value))
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  let aType = getParsedType(a), bType = getParsedType(b);
  if (a === b)
    return { valid: !0, data: a };
  if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    let bKeys = util.objectKeys(b), sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid)
        return { valid: !1 };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length)
      return { valid: !1 };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid)
        return { valid: !1 };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  } else return aType === ZodParsedType.date && bType === ZodParsedType.date && +a == +b ? { valid: !0, data: a } : { valid: !1 };
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight))
        return INVALID;
      let merged = mergeValues(parsedLeft.value, parsedRight.value);
      return merged.valid ? ((isDirty(parsedLeft) || isDirty(parsedRight)) && status.dirty(), { status: status.value, value: merged.data }) : (addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return ctx.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }),
      this._def.right._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
    ]).then(([left, right]) => handleParsed(left, right)) : handleParsed(this._def.left._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }), this._def.right._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }));
  }
};
ZodIntersection.create = (left, right, params) => new ZodIntersection({
  left,
  right,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(params)
});
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (ctx.data.length < this._def.items.length)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && ctx.data.length > this._def.items.length && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), status.dirty());
    let items = [...ctx.data].map((item, itemIndex) => {
      let schema = this._def.items[itemIndex] || this._def.rest;
      return schema ? schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)) : null;
    }).filter((x) => !!x);
    return ctx.common.async ? Promise.all(items).then((results) => ParseStatus.mergeArray(status, results)) : ParseStatus.mergeArray(status, items);
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;
    for (let key in ctx.data)
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    return ctx.common.async ? ParseStatus.mergeObjectAsync(status, pairs) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    return second instanceof ZodType ? new _ZodRecord({
      keyType: first,
      valueType: second,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(third)
    }) : new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}, ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      }), INVALID;
    let keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => ({
      key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
      value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
    }));
    if (ctx.common.async) {
      let finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let pair of pairs) {
          let key = await pair.key, value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted")
            return INVALID;
          (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      let finalMap = /* @__PURE__ */ new Map();
      for (let pair of pairs) {
        let key = pair.key, value = pair.value;
        if (key.status === "aborted" || value.status === "aborted")
          return INVALID;
        (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => new ZodMap({
  valueType,
  keyType,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(params)
});
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      }), INVALID;
    let def = this._def;
    def.minSize !== null && ctx.data.size < def.minSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.minSize.message
    }), status.dirty()), def.maxSize !== null && ctx.data.size > def.maxSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.maxSize.message
    }), status.dirty());
    let valueType = this._def.valueType;
    function finalizeSet(elements2) {
      let parsedSet = /* @__PURE__ */ new Set();
      for (let element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        element.status === "dirty" && status.dirty(), parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    let elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ctx.common.async ? Promise.all(elements).then((elements2) => finalizeSet(elements2)) : finalizeSet(elements);
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => new ZodSet({
  valueType,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(params)
});
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      }), INVALID;
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    let params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      let me = this;
      return OK(async function(...args) {
        let error2 = new ZodError([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          throw error2.addIssue(makeArgsIssue(args, e)), error2;
        }), result = await Reflect.apply(fn, this, parsedArgs);
        return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          throw error2.addIssue(makeReturnsIssue(result, e)), error2;
        });
      });
    } else {
      let me = this;
      return OK(function(...args) {
        let parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success)
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        let result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success)
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    return this.parse(func);
  }
  strictImplement(func) {
    return this.parse(func);
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}, ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => new ZodLazy({
  getter,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(params)
});
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => new ZodLiteral({
  value,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(params)
});
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data != "string") {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(input.data)) {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Values() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    let nativeEnumValues = util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(util.getValidEnumValues(this._def.values))), !this._cache.has(input.data)) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => new ZodNativeEnum({
  values,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(params)
});
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      }), INVALID;
    let promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => this._def.type.parseAsync(data, {
      path: ctx.path,
      errorMap: ctx.common.contextualErrorMap
    })));
  }
};
ZodPromise.create = (schema, params) => new ZodPromise({
  type: schema,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(params)
});
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg), arg.fatal ? status.abort() : status.dirty();
      },
      get path() {
        return ctx.path;
      }
    };
    if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === "preprocess") {
      let processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async)
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          let result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
        });
      {
        if (status.value === "aborted")
          return INVALID;
        let result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
      }
    }
    if (effect.type === "refinement") {
      let executeRefinement = (acc) => {
        let result = effect.refinement(acc, checkCtx);
        if (ctx.common.async)
          return Promise.resolve(result);
        if (result instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return acc;
      };
      if (ctx.common.async === !1) {
        let inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value), { status: status.value, value: inner.value });
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value).then(() => ({ status: status.value, value: inner.value }))));
    }
    if (effect.type === "transform")
      if (ctx.common.async === !1) {
        let base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        let result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: status.value, value: result };
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => isValid(base) ? Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
          status: status.value,
          value: result
        })) : INVALID);
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => new ZodEffects({
  schema,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect,
  ...processCreateParams(params)
});
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => new ZodEffects({
  schema,
  effect: { type: "preprocess", transform: preprocess2 },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(params)
});
var ZodOptional = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => new ZodOptional({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(params)
});
var ZodNullable = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => new ZodNullable({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(params)
});
var ZodDefault = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return ctx.parsedType === ZodParsedType.undefined && (data = this._def.defaultValue()), this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => new ZodDefault({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof params.default == "function" ? params.default : () => params.default,
  ...processCreateParams(params)
});
var ZodCatch = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    }, result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    return isAsync(result) ? result.then((result2) => ({
      status: "valid",
      value: result2.status === "valid" ? result2.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    })) : {
      status: "valid",
      value: result.status === "valid" ? result.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => new ZodCatch({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof params.catch == "function" ? params.catch : () => params.catch,
  ...processCreateParams(params)
});
var ZodNaN = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.nan) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(params)
});
var BRAND = Symbol("zod_brand"), ZodBranded = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.common.async)
      return (async () => {
        let inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), DIRTY(inResult.value)) : this._def.out._parseAsync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      })();
    {
      let inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), {
        status: "dirty",
        value: inResult.value
      }) : this._def.out._parseSync({
        data: inResult.value,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}, ZodReadonly = class extends ZodType {
  _parse(input) {
    let result = this._def.innerType._parse(input), freeze = (data) => (isValid(data) && (data.value = Object.freeze(data.value)), data);
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => new ZodReadonly({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(params)
});
var late = {
  object: ZodObject.lazycreate
}, ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3.ZodString = "ZodString", ZodFirstPartyTypeKind3.ZodNumber = "ZodNumber", ZodFirstPartyTypeKind3.ZodNaN = "ZodNaN", ZodFirstPartyTypeKind3.ZodBigInt = "ZodBigInt", ZodFirstPartyTypeKind3.ZodBoolean = "ZodBoolean", ZodFirstPartyTypeKind3.ZodDate = "ZodDate", ZodFirstPartyTypeKind3.ZodSymbol = "ZodSymbol", ZodFirstPartyTypeKind3.ZodUndefined = "ZodUndefined", ZodFirstPartyTypeKind3.ZodNull = "ZodNull", ZodFirstPartyTypeKind3.ZodAny = "ZodAny", ZodFirstPartyTypeKind3.ZodUnknown = "ZodUnknown", ZodFirstPartyTypeKind3.ZodNever = "ZodNever", ZodFirstPartyTypeKind3.ZodVoid = "ZodVoid", ZodFirstPartyTypeKind3.ZodArray = "ZodArray", ZodFirstPartyTypeKind3.ZodObject = "ZodObject", ZodFirstPartyTypeKind3.ZodUnion = "ZodUnion", ZodFirstPartyTypeKind3.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ZodFirstPartyTypeKind3.ZodIntersection = "ZodIntersection", ZodFirstPartyTypeKind3.ZodTuple = "ZodTuple", ZodFirstPartyTypeKind3.ZodRecord = "ZodRecord", ZodFirstPartyTypeKind3.ZodMap = "ZodMap", ZodFirstPartyTypeKind3.ZodSet = "ZodSet", ZodFirstPartyTypeKind3.ZodFunction = "ZodFunction", ZodFirstPartyTypeKind3.ZodLazy = "ZodLazy", ZodFirstPartyTypeKind3.ZodLiteral = "ZodLiteral", ZodFirstPartyTypeKind3.ZodEnum = "ZodEnum", ZodFirstPartyTypeKind3.ZodEffects = "ZodEffects", ZodFirstPartyTypeKind3.ZodNativeEnum = "ZodNativeEnum", ZodFirstPartyTypeKind3.ZodOptional = "ZodOptional", ZodFirstPartyTypeKind3.ZodNullable = "ZodNullable", ZodFirstPartyTypeKind3.ZodDefault = "ZodDefault", ZodFirstPartyTypeKind3.ZodCatch = "ZodCatch", ZodFirstPartyTypeKind3.ZodPromise = "ZodPromise", ZodFirstPartyTypeKind3.ZodBranded = "ZodBranded", ZodFirstPartyTypeKind3.ZodPipeline = "ZodPipeline", ZodFirstPartyTypeKind3.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create;

// mcp-servers-src/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (inst._zod || Object.defineProperty(inst, "_zod", {
      value: {
        def,
        constr: _,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), inst._zod.traits.has(name))
      return;
    inst._zod.traits.add(name), initializer3(inst, def);
    let proto = _.prototype, keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      let k = keys[i];
      k in inst || (inst[k] = proto[k].bind(inst));
    }
  }
  let Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    let inst = params?.Parent ? new Definition() : this;
    init(inst, def), (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (let fn of inst._zod.deferred)
      fn();
    return inst;
  }
  return Object.defineProperty(_, "init", { value: init }), Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => params?.Parent && inst instanceof params.Parent ? !0 : inst?._zod?.traits?.has(name)
  }), Object.defineProperty(_, "name", { value: name }), _;
}
var $brand = Symbol("zod_brand"), $ZodAsyncError = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}, $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`), this.name = "ZodEncodeError";
  }
}, globalConfig = {};
function config(newConfig) {
  return newConfig && Object.assign(globalConfig, newConfig), globalConfig;
}

// mcp-servers-src/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  let numericValues = Object.values(entries).filter((v) => typeof v == "number");
  return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  return typeof value == "bigint" ? value.toString() : value;
}
function cached(getter) {
  return {
    get value() {
      {
        let value = getter();
        return Object.defineProperty(this, "value", { value }), value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input == null;
}
function cleanRegex(source) {
  let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepString = step.toString(), stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    let match = stepString.match(/\d?e-(\d?)/);
    match?.[1] && (stepDecCount = Number.parseInt(match[1]));
  }
  let decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object3, key, getter) {
  let value;
  Object.defineProperty(object3, key, {
    get() {
      if (value !== EVALUATING)
        return value === void 0 && (value = EVALUATING, value = getter()), value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function mergeDefs(...defs) {
  let mergedDescriptors = {};
  for (let def of defs) {
    let descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  return path ? path.reduce((acc, key) => acc?.[key], obj) : obj;
}
function promiseAllObject(promisesObj) {
  let keys = Object.keys(promisesObj), promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    let resolvedObj = {};
    for (let i = 0; i < keys.length; i++)
      resolvedObj[keys[i]] = results[i];
    return resolvedObj;
  });
}
function randomString(length = 10) {
  let chars = "abcdefghijklmnopqrstuvwxyz", str = "";
  for (let i = 0; i < length; i++)
    str += chars[Math.floor(Math.random() * chars.length)];
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data == "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    let F = Function;
    return new F(""), !0;
  } catch {
    return !1;
  }
});
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  let ctor = o.constructor;
  if (ctor === void 0 || typeof ctor != "function")
    return !0;
  let prot = ctor.prototype;
  return !(isObject(prot) === !1 || Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === !1);
}
function shallowClone(o) {
  return isPlainObject(o) ? { ...o } : Array.isArray(o) ? [...o] : o;
}
function numKeys(data) {
  let keyCount = 0;
  for (let key in data)
    Object.prototype.hasOwnProperty.call(data, key) && keyCount++;
  return keyCount;
}
var getParsedType2 = (data) => {
  let t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(data) ? "array" : data === null ? "null" : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? "promise" : typeof Map < "u" && data instanceof Map ? "map" : typeof Set < "u" && data instanceof Set ? "set" : typeof Date < "u" && data instanceof Date ? "date" : typeof File < "u" && data instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]), primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  let cl = new inst._zod.constr(def ?? inst._zod.def);
  return (!def || params?.parent) && (cl._zod.parent = inst), cl;
}
function normalizeParams(_params) {
  let params = _params;
  if (!params)
    return {};
  if (typeof params == "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  return delete params.message, typeof params.error == "string" ? { ...params, error: () => params.error } : params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      return target ?? (target = getter()), Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      return target ?? (target = getter()), Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      return target ?? (target = getter()), Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      return target ?? (target = getter()), Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      return target ?? (target = getter()), Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      return target ?? (target = getter()), Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      return target ?? (target = getter()), Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  return typeof value == "bigint" ? value.toString() + "n" : typeof value == "string" ? `"${value}"` : `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional");
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = {};
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && (newShape[key] = currDef.shape[key]);
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = { ...schema._zod.def.shape };
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && delete newShape[key];
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to extend: expected a plain object");
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0) {
    let existingShape = schema._zod.def.shape;
    for (let key in shape)
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  let def = mergeDefs(a._zod.def, {
    get shape() {
      let _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in oldShape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key]);
        }
      else
        for (let key in oldShape)
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
      return assignProp(this, "shape", shape), shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in shape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          }));
        }
      else
        for (let key in oldShape)
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
      return assignProp(this, "shape", shape), shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === !0)
    return !0;
  for (let i = startIndex; i < x.issues.length; i++)
    if (x.issues[i]?.continue !== !0)
      return !0;
  return !1;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    return (_a2 = iss).path ?? (_a2.path = []), iss.path.unshift(path), iss;
  });
}
function unwrapMessage(message) {
  return typeof message == "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  let full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    let message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  return delete full.inst, delete full.continue, ctx?.reportInput || delete full.input, full;
}
function getSizableOrigin(input) {
  return input instanceof Set ? "set" : input instanceof Map ? "map" : input instanceof File ? "file" : "unknown";
}
function getLengthableOrigin(input) {
  return Array.isArray(input) ? "array" : typeof input == "string" ? "string" : "unknown";
}
function parsedType(data) {
  let t = typeof data;
  switch (t) {
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "object": {
      if (data === null)
        return "null";
      if (Array.isArray(data))
        return "array";
      let obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor)
        return obj.constructor.name;
    }
  }
  return t;
}
function issue(...args) {
  let [iss, input, inst] = args;
  return typeof iss == "string" ? {
    message: iss,
    code: "custom",
    input,
    inst
  } : { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => Number.isNaN(Number.parseInt(k, 10))).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  let binaryString = atob(base643), bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++)
    bytes[i] = binaryString.charCodeAt(i);
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++)
    binaryString += String.fromCharCode(bytes[i]);
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  let base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/"), padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  let cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  let bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2)
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// mcp-servers-src/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError", Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: !1
  }), Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: !1
  }), inst.message = JSON.stringify(def, jsonStringifyReplacer, 2), Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: !1
  });
}, $ZodError = $constructor("$ZodError", initializer), $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = {}, formErrors = [];
  for (let sub of error2.issues)
    sub.path.length > 0 ? (fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub))) : formErrors.push(mapper(sub));
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = { _errors: [] }, processError = (error3) => {
    for (let issue2 of error3.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues });
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues });
      else if (issue2.path.length === 0)
        fieldErrors._errors.push(mapper(issue2));
      else {
        let curr = fieldErrors, i = 0;
        for (; i < issue2.path.length; ) {
          let el = issue2.path[i];
          i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
        }
      }
  };
  return processError(error2), fieldErrors;
}

// mcp-servers-src/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !1 }) : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  if (result.issues.length) {
    let e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, _params?.callee), e;
  }
  return result.value;
}, parse = /* @__PURE__ */ _parse($ZodRealError), _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise && (result = await result), result.issues.length) {
    let e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, params?.callee), e;
  }
  return result.value;
}, parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError), _safeParse = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? { ..._ctx, async: !1 } : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  return result.issues.length ? {
    success: !1,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParse = /* @__PURE__ */ _safeParse($ZodRealError), _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  return result instanceof Promise && (result = await result), result.issues.length ? {
    success: !1,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError), _encode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var _decode = (_Err) => (schema, value, _ctx) => _parse(_Err)(schema, value, _ctx);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var _decodeAsync = (_Err) => async (schema, value, _ctx) => _parseAsync(_Err)(schema, value, _ctx);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var _safeDecode = (_Err) => (schema, value, _ctx) => _safeParse(_Err)(schema, value, _ctx);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => _safeParseAsync(_Err)(schema, value, _ctx);

// mcp-servers-src/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/, cuid2 = /^[0-9a-z]+$/, ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, xid = /^[0-9a-vA-V]{20}$/, ksuid = /^[A-Za-z0-9]{27}$/, nanoid = /^[a-zA-Z0-9_-]{21}$/, duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, uuid = (version2) => version2 ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, uuid4 = /* @__PURE__ */ uuid(4), uuid6 = /* @__PURE__ */ uuid(6), uuid7 = /* @__PURE__ */ uuid(7), email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, idnEmail = unicodeEmail, browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, _emoji = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, mac = (delimiter) => {
  let escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, base64url = /^[A-Za-z0-9_-]*$/, hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, e164 = /^\+[1-9]\d{6,14}$/, dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  let hhmm = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof args.precision == "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  let time3 = timeSource({ precision: args.precision }), opts = ["Z"];
  args.local && opts.push(""), args.offset && opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let timeRegex2 = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  let regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${regex}$`);
}, bigint = /^-?\d+n?$/, integer = /^-?\d+$/, number = /^-?\d+(?:\.\d+)?$/, boolean = /^(?:true|false)$/i, _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/, uppercase = /^[^a-z]*$/, hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/, md5_base64 = /* @__PURE__ */ fixedBase64(22, "=="), md5_base64url = /* @__PURE__ */ fixedBase64url(22), sha1_hex = /^[0-9a-fA-F]{40}$/, sha1_base64 = /* @__PURE__ */ fixedBase64(27, "="), sha1_base64url = /* @__PURE__ */ fixedBase64url(27), sha256_hex = /^[0-9a-fA-F]{64}$/, sha256_base64 = /* @__PURE__ */ fixedBase64(43, "="), sha256_base64url = /* @__PURE__ */ fixedBase64url(43), sha384_hex = /^[0-9a-fA-F]{96}$/, sha384_base64 = /* @__PURE__ */ fixedBase64(64, ""), sha384_base64url = /* @__PURE__ */ fixedBase64url(64), sha512_hex = /^[0-9a-fA-F]{128}$/, sha512_base64 = /* @__PURE__ */ fixedBase64(86, "=="), sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// mcp-servers-src/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {}), inst._zod.def = def, (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
}), numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    def.value < curr && (def.inclusive ? bag.maximum = def.value : bag.exclusiveMaximum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value <= def.value : payload.value < def.value) || payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    def.value > curr && (def.inclusive ? bag.minimum = def.value : bag.exclusiveMinimum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value >= def.value : payload.value > def.value) || payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  }), inst._zod.check = (payload) => {
    if (typeof payload.value != typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof payload.value == "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0) || payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def), def.format = def.format || "float64";
  let isInt = def.format?.includes("int"), origin = isInt ? "int" : "number", [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum, isInt && (bag.pattern = integer);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: !1,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        input > 0 ? payload.issues.push({
          input,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        }) : payload.issues.push({
          input,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        });
        return;
      }
    }
    input < minimum && payload.issues.push({
      origin: "number",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "number",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  let [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input < minimum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size <= def.maximum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size >= def.minimum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.size, bag.maximum = def.size, bag.size = def.size;
  }), inst._zod.check = (payload) => {
    let input = payload.value, size = input.size;
    if (size === def.size)
      return;
    let tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length <= def.maximum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length >= def.minimum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.length, bag.maximum = def.length, bag.length = def.length;
  }), inst._zod.check = (payload) => {
    let input = payload.value, length = input.length;
    if (length === def.length)
      return;
    let origin = getLengthableOrigin(input), tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, def.pattern && (bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(def.pattern));
  }), def.pattern ? (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? { pattern: def.pattern.toString() } : {},
      inst,
      continue: !def.abort
    });
  }) : (_b = inst._zod).check ?? (_b.check = () => {
  });
}), $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  let escapedRegex = escapeRegex(def.includes), pattern = new RegExp(typeof def.position == "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern, inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.includes(def.includes, def.position) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.startsWith(def.prefix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.endsWith(def.suffix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  result.issues.length && payload.issues.push(...prefixIssues(property, result.issues));
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    let result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise)
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    handleCheckPropertyResult(result, payload, def.property);
  };
}), $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  let mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  }), inst._zod.check = (payload) => {
    mimeSet.has(payload.value.type) || payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// mcp-servers-src/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [], this.indent = 0, this && (this.args = args);
  }
  indented(fn) {
    this.indent += 1, fn(this), this.indent -= 1;
  }
  write(arg) {
    if (typeof arg == "function") {
      arg(this, { execution: "sync" }), arg(this, { execution: "async" });
      return;
    }
    let lines = arg.split(`
`).filter((x) => x), minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length)), dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (let line of dedented)
      this.content.push(line);
  }
  compile() {
    let F = Function, args = this?.args, lines = [...(this?.content ?? [""]).map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
};

// mcp-servers-src/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// mcp-servers-src/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {}), inst._zod.def = def, inst._zod.bag = inst._zod.bag || {}, inst._zod.version = version;
  let checks = [...inst._zod.def.checks ?? []];
  inst._zod.traits.has("$ZodCheck") && checks.unshift(inst);
  for (let ch of checks)
    for (let fn of ch._zod.onattach)
      fn(inst);
  if (checks.length === 0)
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []), inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  else {
    let runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload), asyncResult;
      for (let ch of checks2) {
        if (ch._zod.def.when) {
          if (!ch._zod.def.when(payload))
            continue;
        } else if (isAborted2)
          continue;
        let currLen = payload.issues.length, _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === !1)
          throw new $ZodAsyncError();
        if (asyncResult || _ instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _, payload.issues.length !== currLen && (isAborted2 || (isAborted2 = aborted(payload, currLen)));
          });
        else {
          if (payload.issues.length === currLen)
            continue;
          isAborted2 || (isAborted2 = aborted(payload, currLen));
        }
      }
      return asyncResult ? asyncResult.then(() => payload) : payload;
    }, handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary))
        return canary.aborted = !0, canary;
      let checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks)
        return inst._zod.parse(payload, ctx);
      if (ctx.direction === "backward") {
        let canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: !0 });
        return canary instanceof Promise ? canary.then((canary2) => handleCanaryResult(canary2, payload, ctx)) : handleCanaryResult(canary, payload, ctx);
      }
      let result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        let r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag), inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch {
      }
    return typeof payload.value == "string" || payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), $ZodString.init(inst, def);
}), $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid), $ZodStringFormat.init(inst, def);
}), $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    let v = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
}), $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email), $ZodStringFormat.init(inst, def);
}), $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    try {
      let trimmed = payload.value.trim(), url2 = new URL(trimmed);
      def.hostname && (def.hostname.lastIndex = 0, def.hostname.test(url2.hostname) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: def.hostname.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.protocol && (def.protocol.lastIndex = 0, def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: def.protocol.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.normalize ? payload.value = url2.href : payload.value = trimmed;
      return;
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji()), $ZodStringFormat.init(inst, def);
}), $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid), $ZodStringFormat.init(inst, def);
}), $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid), $ZodStringFormat.init(inst, def);
}), $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2), $ZodStringFormat.init(inst, def);
}), $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid), $ZodStringFormat.init(inst, def);
}), $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid), $ZodStringFormat.init(inst, def);
}), $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid), $ZodStringFormat.init(inst, def);
}), $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date), $ZodStringFormat.init(inst, def);
}), $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration), $ZodStringFormat.init(inst, def);
}), $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv4";
}), $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv6", inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter)), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "mac";
}), $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4), $ZodStringFormat.init(inst, def);
}), $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6), $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    let parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      let [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      let prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return !0;
  if (data.length % 4 !== 0)
    return !1;
  try {
    return atob(data), !0;
  } catch {
    return !1;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64", inst._zod.check = (payload) => {
    isValidBase64(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return !1;
  let base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/"), padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64url", inst._zod.check = (payload) => {
    isValidBase64URL(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164), $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    let tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return !1;
    let [header] = tokensParts;
    if (!header)
      return !1;
    let parsedHeader = JSON.parse(atob(header));
    return !("typ" in parsedHeader && parsedHeader?.typ !== "JWT" || !parsedHeader.alg || algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm));
  } catch {
    return !1;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    isValidJWT2(payload.value, def.alg) || payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.fn(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = inst._zod.bag.pattern ?? number, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch {
      }
    let input = payload.value;
    if (typeof input == "number" && !Number.isNaN(input) && Number.isFinite(input))
      return payload;
    let received = typeof input == "number" ? Number.isNaN(input) ? "NaN" : Number.isFinite(input) ? void 0 : "Infinity" : void 0;
    return payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    }), payload;
  };
}), $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def), $ZodNumber.init(inst, def);
}), $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = boolean, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = !!payload.value;
      } catch {
      }
    let input = payload.value;
    return typeof input == "boolean" || payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = bigint, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch {
      }
    return typeof payload.value == "bigint" || payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def), $ZodBigInt.init(inst, def);
}), $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input == "symbol" || payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _undefined, inst._zod.values = /* @__PURE__ */ new Set([void 0]), inst._zod.optin = "optional", inst._zod.optout = "optional", inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _null, inst._zod.values = /* @__PURE__ */ new Set([null]), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input === null || payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => (payload.issues.push({
    expected: "never",
    code: "invalid_type",
    input: payload.value,
    inst
  }), payload);
}), $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = new Date(payload.value);
      } catch {
      }
    let input = payload.value, isDate = input instanceof Date;
    return isDate && !Number.isNaN(input.getTime()) || payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    }), payload;
  };
});
function handleArrayResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = Array(input.length);
    let proms = [];
    for (let i = 0; i < input.length; i++) {
      let item = input[i], result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleArrayResult(result2, payload, i))) : handleArrayResult(result, payload, i);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input))
      return;
    final.issues.push(...prefixIssues(key, result.issues));
  }
  result.value === void 0 ? key in input && (final.value[key] = void 0) : final.value[key] = result.value;
}
function normalizeDef(def) {
  let keys = Object.keys(def.shape);
  for (let k of keys)
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
  let okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  let unrecognized = [], keySet = def.keySet, _catchall = def.catchall._zod, t = _catchall.def.type, isOptionalOut = _catchall.optout === "optional";
  for (let key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    let r = _catchall.run({ value: input[key], issues: [] }, ctx);
    r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
  }
  return unrecognized.length && payload.issues.push({
    code: "unrecognized_keys",
    keys: unrecognized,
    input,
    inst
  }), proms.length ? Promise.all(proms).then(() => payload) : payload;
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  if ($ZodType.init(inst, def), !Object.getOwnPropertyDescriptor(def, "shape")?.get) {
    let sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        let newSh = { ...sh };
        return Object.defineProperty(def, "shape", {
          value: newSh
        }), newSh;
      }
    });
  }
  let _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    let shape = def.shape, propValues = {};
    for (let key in shape) {
      let field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (let v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  let isObject2 = isObject, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    if (!isObject2(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = {};
    let proms = [], shape = value.shape;
    for (let key of value.keys) {
      let el = shape[key], isOptionalOut = el._zod.optout === "optional", r = el._zod.run({ value: input[key], issues: [] }, ctx);
      r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
    return catchall ? handleCatchall(proms, input, payload, ctx, _normalized.value, inst) : proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  let superParse = inst._zod.parse, _normalized = cached(() => normalizeDef(def)), generateFastpass = (shape) => {
    let doc = new Doc(["shape", "payload", "ctx"]), normalized = _normalized.value, parseStr = (key) => {
      let k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write("const input = payload.value;");
    let ids = /* @__PURE__ */ Object.create(null), counter = 0;
    for (let key of normalized.keys)
      ids[key] = `key_${counter++}`;
    doc.write("const newResult = {};");
    for (let key of normalized.keys) {
      let id = ids[key], k = esc(key), isOptionalOut = shape[key]?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`), isOptionalOut ? doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `) : doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write("payload.value = newResult;"), doc.write("return payload;");
    let fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, fastpass, isObject2 = isObject, jit = !globalConfig.jitless, fastEnabled = jit && allowsEval.value, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    return isObject2(input) ? jit && fastEnabled && ctx?.async === !1 && ctx.jitless !== !0 ? (fastpass || (fastpass = generateFastpass(def.shape)), payload = fastpass(payload, ctx), catchall ? handleCatchall([], input, payload, ctx, value, inst) : payload) : superParse(payload, ctx) : (payload.issues.push({
      expected: "object",
      code: "invalid_type",
      input,
      inst
    }), payload);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (let result of results)
    if (result.issues.length === 0)
      return final.value = result.value, final;
  let nonaborted = results.filter((r) => !aborted(r));
  return nonaborted.length === 1 ? (final.value = nonaborted[0].value, nonaborted[0]) : (final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }), final);
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values))
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
  }), defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      let patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
  });
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    return async ? Promise.all(results).then((results2) => handleUnionResults(results2, payload, inst, ctx)) : handleUnionResults(results, payload, inst, ctx);
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  let successes = results.filter((r) => r.issues.length === 0);
  return successes.length === 1 ? (final.value = successes[0].value, final) : (successes.length === 0 ? final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }) : final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: [],
    inclusive: !1
  }), final);
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def), def.inclusive = !1;
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      result instanceof Promise ? (results.push(result), async = !0) : results.push(result);
    }
    return async ? Promise.all(results).then((results2) => handleExclusiveUnionResults(results2, payload, inst, ctx)) : handleExclusiveUnionResults(results, payload, inst, ctx);
  };
}), $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = !1, $ZodUnion.init(inst, def);
  let _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    let propValues = {};
    for (let option of def.options) {
      let pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (let [k, v] of Object.entries(pv)) {
        propValues[k] || (propValues[k] = /* @__PURE__ */ new Set());
        for (let val of v)
          propValues[k].add(val);
      }
    }
    return propValues;
  });
  let disc = cached(() => {
    let opts = def.options, map2 = /* @__PURE__ */ new Map();
    for (let o of opts) {
      let values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (let v of values) {
        if (map2.has(v))
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isObject(input))
      return payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      }), payload;
    let opt = disc.value.get(input?.[def.discriminator]);
    return opt ? opt._zod.run(payload, ctx) : def.unionFallback ? _super(payload, ctx) : (payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    }), payload);
  };
}), $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value, left = def.left._zod.run({ value: input, issues: [] }, ctx), right = def.right._zod.run({ value: input, issues: [] }, ctx);
    return left instanceof Promise || right instanceof Promise ? Promise.all([left, right]).then(([left2, right2]) => handleIntersectionResults(payload, left2, right2)) : handleIntersectionResults(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b)
    return { valid: !0, data: a };
  if (a instanceof Date && b instanceof Date && +a == +b)
    return { valid: !0, data: a };
  if (isPlainObject(a) && isPlainObject(b)) {
    let bKeys = Object.keys(b), sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length)
      return { valid: !1, mergeErrorPath: [] };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  let unrecKeys = /* @__PURE__ */ new Map(), unrecIssue;
  for (let iss of left.issues)
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).l = !0;
    } else
      result.issues.push(iss);
  for (let iss of right.issues)
    if (iss.code === "unrecognized_keys")
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).r = !0;
    else
      result.issues.push(iss);
  let bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue && result.issues.push({ ...unrecIssue, keys: bothKeys }), aborted(result))
    return result;
  let merged = mergeValues2(left.value, right.value);
  if (!merged.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  return result.value = merged.data, result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  let items = def.items;
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      }), payload;
    payload.value = [];
    let proms = [], reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional"), optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      let tooBig = input.length > items.length, tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall)
        return payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: !0 } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        }), payload;
    }
    let i = -1;
    for (let item of items) {
      if (i++, i >= input.length && i >= optStart)
        continue;
      let result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
    }
    if (def.rest) {
      let rest = input.slice(items.length);
      for (let el of rest) {
        i++;
        let result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleTupleResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isPlainObject(input))
      return payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [], values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      let recordKeys = /* @__PURE__ */ new Set();
      for (let key of values)
        if (typeof key == "string" || typeof key == "number" || typeof key == "symbol") {
          recordKeys.add(typeof key == "number" ? key.toString() : key);
          let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          result instanceof Promise ? proms.push(result.then((result2) => {
            result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[key] = result2.value;
          })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[key] = result.value);
        }
      let unrecognized;
      for (let key in input)
        recordKeys.has(key) || (unrecognized = unrecognized ?? [], unrecognized.push(key));
      unrecognized && unrecognized.length > 0 && payload.issues.push({
        code: "unrecognized_keys",
        input,
        inst,
        keys: unrecognized
      });
    } else {
      payload.value = {};
      for (let key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof key == "string" && number.test(key) && keyResult.issues.length) {
          let retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          retryResult.issues.length === 0 && (keyResult = retryResult);
        }
        if (keyResult.issues.length) {
          def.mode === "loose" ? payload.value[key] = input[key] : payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          continue;
        }
        let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => {
          result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[keyResult.value] = result2.value;
        })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[keyResult.value] = result.value);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Map))
      return payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (let [key, value] of input) {
      let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx), valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      keyResult instanceof Promise || valueResult instanceof Promise ? proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
        handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
      })) : handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  keyResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, keyResult.issues)) : final.issues.push({
    code: "invalid_key",
    origin: "map",
    input,
    inst,
    issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), valueResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, valueResult.issues)) : final.issues.push({
    origin: "map",
    code: "invalid_element",
    input,
    inst,
    key,
    issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Set))
      return payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (let item of input) {
      let result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleSetResult(result2, payload))) : handleSetResult(result, payload);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleSetResult(result, final) {
  result.issues.length && final.issues.push(...result.issues), final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  let values = getEnumValues(def.entries), valuesSet = new Set(values);
  inst._zod.values = valuesSet, inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o == "string" ? escapeRegex(o) : o.toString()).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return valuesSet.has(input) || payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    }), payload;
  };
}), $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  if ($ZodType.init(inst, def), def.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  let values = new Set(def.values);
  inst._zod.values = values, inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o == "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return values.has(input) || payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    }), payload;
  };
}), $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input instanceof File || payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    let _out = def.transform(payload.value, payload);
    if (ctx.async)
      return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output2) => (payload.value = output2, payload));
    if (_out instanceof Promise)
      throw new $ZodAsyncError();
    return payload.value = _out, payload;
  };
});
function handleOptionalResult(result, input) {
  return result.issues.length && input === void 0 ? { issues: [], value: void 0 } : result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", inst._zod.optout = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      let result = def.innerType._zod.run(payload, ctx);
      return result instanceof Promise ? result.then((r) => handleOptionalResult(r, payload.value)) : handleOptionalResult(result, payload.value);
    }
    return payload.value === void 0 ? payload : def.innerType._zod.run(payload, ctx);
  };
}), $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern), inst._zod.parse = (payload, ctx) => def.innerType._zod.run(payload, ctx);
}), $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  }), defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0), inst._zod.parse = (payload, ctx) => payload.value === null ? payload : def.innerType._zod.run(payload, ctx);
}), $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0)
      return payload.value = def.defaultValue, payload;
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleDefaultResult(result2, def)) : handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  return payload.value === void 0 && (payload.value = def.defaultValue), payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => (ctx.direction === "backward" || payload.value === void 0 && (payload.value = def.defaultValue), def.innerType._zod.run(payload, ctx));
}), $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => {
    let v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleNonOptionalResult(result2, inst)) : handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  return !payload.issues.length && payload.value === void 0 && payload.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: payload.value,
    inst
  }), payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError("ZodSuccess");
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.issues.length === 0, payload)) : (payload.value = result.issues.length === 0, payload);
  };
}), $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.value, result2.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload)) : (payload.value = result.value, result.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload);
  };
}), $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => ((typeof payload.value != "number" || !Number.isNaN(payload.value)) && payload.issues.push({
    input: payload.value,
    inst,
    expected: "nan",
    code: "invalid_type"
  }), payload);
}), $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handlePipeResult(right2, def.in, ctx)) : handlePipeResult(right, def.in, ctx);
    }
    let left = def.in._zod.run(payload, ctx);
    return left instanceof Promise ? left.then((left2) => handlePipeResult(left2, def.out, ctx)) : handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if ((ctx.direction || "forward") === "forward") {
      let left = def.in._zod.run(payload, ctx);
      return left instanceof Promise ? left.then((left2) => handleCodecAResult(left2, def, ctx)) : handleCodecAResult(left, def, ctx);
    } else {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handleCodecAResult(right2, def, ctx)) : handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length)
    return result.aborted = !0, result;
  if ((ctx.direction || "forward") === "forward") {
    let transformed = def.transform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx)) : handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    let transformed = def.reverseTransform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx)) : handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin), defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then(handleReadonlyResult) : handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  return payload.value = Object.freeze(payload.value), payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  let regexParts = [];
  for (let part of def.parts)
    if (typeof part == "object" && part !== null) {
      if (!part._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      let source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part))
      regexParts.push(escapeRegex(`${part}`));
    else
      throw new Error(`Invalid template literal part: ${part}`);
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`), inst._zod.parse = (payload, _ctx) => typeof payload.value != "string" ? (payload.issues.push({
    input: payload.value,
    inst,
    expected: "string",
    code: "invalid_type"
  }), payload) : (inst._zod.pattern.lastIndex = 0, inst._zod.pattern.test(payload.value) || payload.issues.push({
    input: payload.value,
    inst,
    code: "invalid_format",
    format: def.format ?? "template_literal",
    pattern: inst._zod.pattern.source
  }), payload);
}), $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => ($ZodType.init(inst, def), inst._def = def, inst._zod.def = def, inst.implement = (func) => {
  if (typeof func != "function")
    throw new Error("implement() must be called with a function");
  return function(...args) {
    let parsedArgs = inst._def.input ? parse(inst._def.input, args) : args, result = Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? parse(inst._def.output, result) : result;
  };
}, inst.implementAsync = (func) => {
  if (typeof func != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...args) {
    let parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args, result = await Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? await parseAsync(inst._def.output, result) : result;
  };
}, inst._zod.parse = (payload, _ctx) => typeof payload.value != "function" ? (payload.issues.push({
  code: "invalid_type",
  expected: "function",
  input: payload.value,
  inst
}), payload) : (inst._def.output && inst._def.output._zod.def.type === "promise" ? payload.value = inst.implementAsync(payload.value) : payload.value = inst.implement(payload.value), payload), inst.input = (...args) => {
  let F = inst.constructor;
  return Array.isArray(args[0]) ? new F({
    type: "function",
    input: new $ZodTuple({
      type: "tuple",
      items: args[0],
      rest: args[1]
    }),
    output: inst._def.output
  }) : new F({
    type: "function",
    input: args[0],
    output: inst._def.output
  });
}, inst.output = (output) => {
  let F = inst.constructor;
  return new F({
    type: "function",
    input: inst._def.input,
    output
  });
}, inst)), $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
}), $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "innerType", () => def.getter()), defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern), defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues), defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0), defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0), inst._zod.parse = (payload, ctx) => inst._zod.innerType._zod.run(payload, ctx);
}), $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def), $ZodType.init(inst, def), inst._zod.parse = (payload, _) => payload, inst._zod.check = (payload) => {
    let input = payload.value, r = def.fn(input);
    if (r instanceof Promise)
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    handleRefineResult(r, payload, input, inst);
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    let _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    inst._zod.def.params && (_iss.params = inst._zod.def.params), payload.issues.push(issue(_iss));
  }
}

// mcp-servers-src/node_modules/zod/v4/locales/en.js
var error = () => {
  let Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        return issue2.values.length === 1 ? `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}` : `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        return sizing ? `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}` : `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        return sizing ? `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}` : `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        return _issue.format === "starts_with" ? `Invalid string: must start with "${_issue.prefix}"` : _issue.format === "ends_with" ? `Invalid string: must end with "${_issue.suffix}"` : _issue.format === "includes" ? `Invalid string: must include "${_issue.includes}"` : _issue.format === "regex" ? `Invalid string: must match pattern ${_issue.pattern}` : `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function en_default2() {
  return {
    localeError: error()
  };
}

// mcp-servers-src/node_modules/zod/v4/core/registries.js
var _a, $output = Symbol("ZodOutput"), $input = Symbol("ZodInput"), $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    let meta3 = _meta[0];
    return this._map.set(schema, meta3), meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.set(meta3.id, schema), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(schema) {
    let meta3 = this._map.get(schema);
    return meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.delete(meta3.id), this._map.delete(schema), this;
  }
  get(schema) {
    let p = schema._zod.parent;
    if (p) {
      let pm = { ...this.get(p) ?? {} };
      delete pm.id;
      let f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// mcp-servers-src/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  return new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  let norm = normalizeParams(_params);
  return norm.abort ?? (norm.abort = !0), new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  return new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  let ch = /* @__PURE__ */ _check((payload) => (payload.addIssue = (issue2) => {
    if (typeof issue2 == "string")
      payload.issues.push(issue(issue2, payload.value, ch._zod.def));
    else {
      let _issue = issue2;
      _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = ch), _issue.continue ?? (_issue.continue = !ch._zod.def.abort), payload.issues.push(issue(_issue));
    }
  }, fn(payload.value, payload)));
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  let ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  return ch._zod.check = fn, ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  let ch = new $ZodCheck({ check: "describe" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  let ch = new $ZodCheck({ check: "meta" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  let params = normalizeParams(_params), truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  params.case !== "sensitive" && (truthyArray = truthyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v), falsyArray = falsyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v));
  let truthySet = new Set(truthyArray), falsySet = new Set(falsyArray), _Codec = Classes.Codec ?? $ZodCodec, _Boolean = Classes.Boolean ?? $ZodBoolean, _String = Classes.String ?? $ZodString, stringSchema = new _String({ type: "string", error: params.error }), booleanSchema = new _Boolean({ type: "boolean", error: params.error }), codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      return params.case !== "sensitive" && (data = data.toLowerCase()), truthySet.has(data) ? !0 : falsySet.has(data) ? !1 : (payload.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...truthySet, ...falsySet],
        input: payload.value,
        inst: codec2,
        continue: !1
      }), {});
    },
    reverseTransform: (input, _payload) => input === !0 ? truthyArray[0] || "true" : falsyArray[0] || "false",
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  let params = normalizeParams(_params), def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex == "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  return fnOrRegex instanceof RegExp && (def.pattern = fnOrRegex), new Class2(def);
}

// mcp-servers-src/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  return target === "draft-4" && (target = "draft-04"), target === "draft-7" && (target = "draft-07"), {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  let def = schema._zod.def, seen = ctx.seen.get(schema);
  if (seen)
    return seen.count++, _params.schemaPath.includes(schema) && (seen.cycle = _params.path), seen.schema;
  let result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  let overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema)
    result.schema = overrideSchema;
  else {
    let params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema)
      schema._zod.processJSONSchema(ctx, result.schema, params);
    else {
      let _json = result.schema, processor = ctx.processors[def.type];
      if (!processor)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      processor(schema, ctx, _json, params);
    }
    let parent = schema._zod.parent;
    parent && (result.ref || (result.ref = parent), process2(parent, ctx, params), ctx.seen.get(parent).isParent = !0);
  }
  let meta3 = ctx.metadataRegistry.get(schema);
  return meta3 && Object.assign(result.schema, meta3), ctx.io === "input" && isTransforming(schema) && (delete result.schema.examples, delete result.schema.default), ctx.io === "input" && result.schema._prefault && ((_a2 = result.schema).default ?? (_a2.default = result.schema._prefault)), delete result.schema._prefault, ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let idToSchema = /* @__PURE__ */ new Map();
  for (let entry of ctx.seen.entries()) {
    let id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      let existing = idToSchema.get(id);
      if (existing && existing !== entry[0])
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      idToSchema.set(id, entry[0]);
    }
  }
  let makeURI = (entry) => {
    let defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      let externalId = ctx.external.registry.get(entry[0])?.id, uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId)
        return { ref: uriGenerator(externalId) };
      let id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      return entry[1].defId = id, { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root)
      return { ref: "#" };
    let defUriPrefix = `#/${defsSegment}/`, defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, extractToDef = (entry) => {
    if (entry[1].schema.$ref)
      return;
    let seen = entry[1], { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema }, defId && (seen.defId = defId);
    let schema2 = seen.schema;
    for (let key in schema2)
      delete schema2[key];
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw")
    for (let entry of ctx.seen.entries()) {
      let seen = entry[1];
      if (seen.cycle)
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      let ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    if (ctx.metadataRegistry.get(entry[0])?.id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1 && ctx.reused === "ref") {
      extractToDef(entry);
      continue;
    }
  }
}
function finalize(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let flattenRef = (zodSchema) => {
    let seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    let schema2 = seen.def ?? seen.schema, _cached = { ...schema2 }, ref = seen.ref;
    if (seen.ref = null, ref) {
      flattenRef(ref);
      let refSeen = ctx.seen.get(ref), refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0") ? (schema2.allOf = schema2.allOf ?? [], schema2.allOf.push(refSchema)) : Object.assign(schema2, refSchema), Object.assign(schema2, _cached), zodSchema._zod.parent === ref)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in _cached || delete schema2[key];
      if (refSchema.$ref && refSeen.def)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key]) && delete schema2[key];
    }
    let parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      let parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref && (schema2.$ref = parentSeen.schema.$ref, parentSeen.def))
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key]) && delete schema2[key];
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (let entry of [...ctx.seen.entries()].reverse())
    flattenRef(entry[0]);
  let result = {};
  if (ctx.target === "draft-2020-12" ? result.$schema = "https://json-schema.org/draft/2020-12/schema" : ctx.target === "draft-07" ? result.$schema = "http://json-schema.org/draft-07/schema#" : ctx.target === "draft-04" ? result.$schema = "http://json-schema.org/draft-04/schema#" : ctx.target, ctx.external?.uri) {
    let id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  let defs = ctx.external?.defs ?? {};
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    seen.def && seen.defId && (defs[seen.defId] = seen.def);
  }
  ctx.external || Object.keys(defs).length > 0 && (ctx.target === "draft-2020-12" ? result.$defs = defs : result.definitions = defs);
  try {
    let finalized = JSON.parse(JSON.stringify(result));
    return Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), finalized;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  let ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return !1;
  ctx.seen.add(_schema);
  let def = _schema._zod.def;
  if (def.type === "transform")
    return !0;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault")
    return isTransforming(def.innerType, ctx);
  if (def.type === "intersection")
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  if (def.type === "record" || def.type === "map")
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  if (def.type === "pipe")
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  if (def.type === "object") {
    for (let key in def.shape)
      if (isTransforming(def.shape[key], ctx))
        return !0;
    return !1;
  }
  if (def.type === "union") {
    for (let option of def.options)
      if (isTransforming(option, ctx))
        return !0;
    return !1;
  }
  if (def.type === "tuple") {
    for (let item of def.items)
      if (isTransforming(item, ctx))
        return !0;
    return !!(def.rest && isTransforming(def.rest, ctx));
  }
  return !1;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  let ctx = initializeContext({ ...params, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  let { libraryOptions, target } = params ?? {}, ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
};

// mcp-servers-src/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, stringProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json;
  json2.type = "string";
  let { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum == "number" && (json2.minLength = minimum), typeof maximum == "number" && (json2.maxLength = maximum), format && (json2.format = formatMap[format] ?? format, json2.format === "" && delete json2.format, format === "time" && delete json2.format), contentEncoding && (json2.contentEncoding = contentEncoding), patterns && patterns.size > 0) {
    let regexes = [...patterns];
    regexes.length === 1 ? json2.pattern = regexes[0].source : regexes.length > 1 && (json2.allOf = [
      ...regexes.map((regex) => ({
        ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: regex.source
      }))
    ]);
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json, { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  typeof format == "string" && format.includes("int") ? json2.type = "integer" : json2.type = "number", typeof exclusiveMinimum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.minimum = exclusiveMinimum, json2.exclusiveMinimum = !0) : json2.exclusiveMinimum = exclusiveMinimum), typeof minimum == "number" && (json2.minimum = minimum, typeof exclusiveMinimum == "number" && ctx.target !== "draft-04" && (exclusiveMinimum >= minimum ? delete json2.minimum : delete json2.exclusiveMinimum)), typeof exclusiveMaximum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.maximum = exclusiveMaximum, json2.exclusiveMaximum = !0) : json2.exclusiveMaximum = exclusiveMaximum), typeof maximum == "number" && (json2.maximum = maximum, typeof exclusiveMaximum == "number" && ctx.target !== "draft-04" && (exclusiveMaximum <= maximum ? delete json2.maximum : delete json2.exclusiveMaximum)), typeof multipleOf == "number" && (json2.multipleOf = multipleOf);
}, booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, nullProcessor = (_schema, ctx, json2, _params) => {
  ctx.target === "openapi-3.0" ? (json2.type = "string", json2.nullable = !0, json2.enum = [null]) : json2.type = "null";
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {
}, unknownProcessor = (_schema, _ctx, _json, _params) => {
}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, enumProcessor = (schema, _ctx, json2, _params) => {
  let def = schema._zod.def, values = getEnumValues(def.entries);
  values.every((v) => typeof v == "number") && (json2.type = "number"), values.every((v) => typeof v == "string") && (json2.type = "string"), json2.enum = values;
}, literalProcessor = (schema, ctx, json2, _params) => {
  let def = schema._zod.def, vals = [];
  for (let val of def.values)
    if (val === void 0) {
      if (ctx.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof val == "bigint") {
      if (ctx.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      vals.push(Number(val));
    } else
      vals.push(val);
  if (vals.length !== 0)
    if (vals.length === 1) {
      let val = vals[0];
      json2.type = val === null ? "null" : typeof val, ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? json2.enum = [val] : json2.const = val;
    } else
      vals.every((v) => typeof v == "number") && (json2.type = "number"), vals.every((v) => typeof v == "string") && (json2.type = "string"), vals.every((v) => typeof v == "boolean") && (json2.type = "boolean"), vals.every((v) => v === null) && (json2.type = "null"), json2.enum = vals;
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string", _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum, maximum, mime } = schema._zod.bag;
  minimum !== void 0 && (file2.minLength = minimum), maximum !== void 0 && (file2.maxLength = maximum), mime ? mime.length === 1 ? (file2.contentMediaType = mime[0], Object.assign(_json, file2)) : (Object.assign(_json, file2), _json.anyOf = mime.map((m) => ({ contentMediaType: m }))) : Object.assign(_json, file2);
}, successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, arrayProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def, { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum), json2.type = "array", json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object", json2.properties = {};
  let shape = def.shape;
  for (let key in shape)
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  let allKeys = new Set(Object.keys(shape)), requiredKeys = new Set([...allKeys].filter((key) => {
    let v = def.shape[key]._zod;
    return ctx.io === "input" ? v.optin === void 0 : v.optout === void 0;
  }));
  requiredKeys.size > 0 && (json2.required = Array.from(requiredKeys)), def.catchall?._zod.def.type === "never" ? json2.additionalProperties = !1 : def.catchall ? def.catchall && (json2.additionalProperties = process2(def.catchall, ctx, {
    ...params,
    path: [...params.path, "additionalProperties"]
  })) : ctx.io === "output" && (json2.additionalProperties = !1);
}, unionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, isExclusive = def.inclusive === !1, options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  isExclusive ? json2.oneOf = options : json2.anyOf = options;
}, intersectionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  }), b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  }), isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1, allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "array";
  let prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items", restPath = ctx.target === "draft-2020-12" || ctx.target === "openapi-3.0" ? "items" : "additionalItems", prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  })), rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  ctx.target === "draft-2020-12" ? (json2.prefixItems = prefixItems, rest && (json2.items = rest)) : ctx.target === "openapi-3.0" ? (json2.items = {
    anyOf: prefixItems
  }, rest && json2.items.anyOf.push(rest), json2.minItems = prefixItems.length, rest || (json2.maxItems = prefixItems.length)) : (json2.items = prefixItems, rest && (json2.additionalItems = rest));
  let { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum);
}, recordProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object";
  let keyType = def.keyType, patterns = keyType._zod.bag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    let valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (let pattern of patterns)
      json2.patternProperties[pattern.source] = valueSchema;
  } else
    (ctx.target === "draft-07" || ctx.target === "draft-2020-12") && (json2.propertyNames = process2(def.keyType, ctx, {
      ...params,
      path: [...params.path, "propertyNames"]
    })), json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  let keyValues = keyType._zod.values;
  if (keyValues) {
    let validKeyValues = [...keyValues].filter((v) => typeof v == "string" || typeof v == "number");
    validKeyValues.length > 0 && (json2.required = validKeyValues);
  }
}, nullableProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, inner = process2(def.innerType, ctx, params), seen = ctx.seen.get(schema);
  ctx.target === "openapi-3.0" ? (seen.ref = def.innerType, json2.nullable = !0) : json2.anyOf = [inner, { type: "null" }];
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, ctx.io === "input" && (json2._prefault = JSON.parse(JSON.stringify(def.defaultValue)));
}, catchProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def, innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.readOnly = !0;
}, promiseProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  let innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  return !!s._zod;
}
function safeParse2(schema, data) {
  return isZ4Schema(schema) ? safeParse(schema, data) : schema.safeParse(data);
}
function getObjectShape(schema) {
  if (!schema)
    return;
  let rawShape;
  if (isZ4Schema(schema) ? rawShape = schema._zod?.def?.shape : rawShape = schema.shape, !!rawShape) {
    if (typeof rawShape == "function")
      try {
        return rawShape();
      } catch {
        return;
      }
    return rawShape;
  }
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    let def2 = schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0)
        return def2.values[0];
    }
  }
  let def = schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0)
      return def.values[0];
  }
  let directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
}

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var schemas_exports3 = {};
__export(schemas_exports3, {
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object2,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// mcp-servers-src/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// mcp-servers-src/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def), ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def), ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// mcp-servers-src/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues), inst.name = "ZodError", Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, ZodError2 = $constructor("ZodError", initializer2), ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// mcp-servers-src/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError), parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError), safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError), safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError), encode2 = /* @__PURE__ */ _encode(ZodRealError), decode2 = /* @__PURE__ */ _decode(ZodRealError), encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError), decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError), safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError), safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError), safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError), safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => ($ZodType.init(inst, def), Object.assign(inst["~standard"], {
  jsonSchema: {
    input: createStandardJSONSchemaMethod(inst, "input"),
    output: createStandardJSONSchemaMethod(inst, "output")
  }
}), inst.toJSONSchema = createToJSONSchemaMethod(inst, {}), inst.def = def, inst.type = def.type, Object.defineProperty(inst, "_def", { value: def }), inst.check = (...checks) => inst.clone(util_exports.mergeDefs(def, {
  checks: [
    ...def.checks ?? [],
    ...checks.map((ch) => typeof ch == "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
  ]
}), {
  parent: !0
}), inst.with = inst.check, inst.clone = (def2, params) => clone(inst, def2, params), inst.brand = () => inst, inst.register = (reg, meta3) => (reg.add(inst, meta3), inst), inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse }), inst.safeParse = (data, params) => safeParse3(inst, data, params), inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync }), inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params), inst.spa = inst.safeParseAsync, inst.encode = (data, params) => encode2(inst, data, params), inst.decode = (data, params) => decode2(inst, data, params), inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params), inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params), inst.safeEncode = (data, params) => safeEncode2(inst, data, params), inst.safeDecode = (data, params) => safeDecode2(inst, data, params), inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params), inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params), inst.refine = (check2, params) => inst.check(refine(check2, params)), inst.superRefine = (refinement) => inst.check(superRefine(refinement)), inst.overwrite = (fn) => inst.check(_overwrite(fn)), inst.optional = () => optional(inst), inst.exactOptional = () => exactOptional(inst), inst.nullable = () => nullable(inst), inst.nullish = () => optional(nullable(inst)), inst.nonoptional = (params) => nonoptional(inst, params), inst.array = () => array(inst), inst.or = (arg) => union([inst, arg]), inst.and = (arg) => intersection(inst, arg), inst.transform = (tx) => pipe(inst, transform(tx)), inst.default = (def2) => _default(inst, def2), inst.prefault = (def2) => prefault(inst, def2), inst.catch = (params) => _catch(inst, params), inst.pipe = (target) => pipe(inst, target), inst.readonly = () => readonly(inst), inst.describe = (description) => {
  let cl = inst.clone();
  return globalRegistry.add(cl, { description }), cl;
}, Object.defineProperty(inst, "description", {
  get() {
    return globalRegistry.get(inst)?.description;
  },
  configurable: !0
}), inst.meta = (...args) => {
  if (args.length === 0)
    return globalRegistry.get(inst);
  let cl = inst.clone();
  return globalRegistry.add(cl, args[0]), cl;
}, inst.isOptional = () => inst.safeParse(void 0).success, inst.isNullable = () => inst.safeParse(null).success, inst.apply = (fn) => fn(inst), inst)), _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  let bag = inst._zod.bag;
  inst.format = bag.format ?? null, inst.minLength = bag.minimum ?? null, inst.maxLength = bag.maximum ?? null, inst.regex = (...args) => inst.check(_regex(...args)), inst.includes = (...args) => inst.check(_includes(...args)), inst.startsWith = (...args) => inst.check(_startsWith(...args)), inst.endsWith = (...args) => inst.check(_endsWith(...args)), inst.min = (...args) => inst.check(_minLength(...args)), inst.max = (...args) => inst.check(_maxLength(...args)), inst.length = (...args) => inst.check(_length(...args)), inst.nonempty = (...args) => inst.check(_minLength(1, ...args)), inst.lowercase = (params) => inst.check(_lowercase(params)), inst.uppercase = (params) => inst.check(_uppercase(params)), inst.trim = () => inst.check(_trim()), inst.normalize = (...args) => inst.check(_normalize(...args)), inst.toLowerCase = () => inst.check(_toLowerCase()), inst.toUpperCase = () => inst.check(_toUpperCase()), inst.slugify = () => inst.check(_slugify());
}), ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def), _ZodString.init(inst, def), inst.email = (params) => inst.check(_email(ZodEmail, params)), inst.url = (params) => inst.check(_url(ZodURL, params)), inst.jwt = (params) => inst.check(_jwt(ZodJWT, params)), inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.uuid = (params) => inst.check(_uuid(ZodUUID, params)), inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params)), inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params)), inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params)), inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.cuid = (params) => inst.check(_cuid(ZodCUID, params)), inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params)), inst.ulid = (params) => inst.check(_ulid(ZodULID, params)), inst.base64 = (params) => inst.check(_base64(ZodBase64, params)), inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params)), inst.xid = (params) => inst.check(_xid(ZodXID, params)), inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params)), inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params)), inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params)), inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params)), inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params)), inst.e164 = (params) => inst.check(_e164(ZodE164, params)), inst.datetime = (params) => inst.check(datetime2(params)), inst.date = (params) => inst.check(date2(params)), inst.time = (params) => inst.check(time2(params)), inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString2, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), _ZodString.init(inst, def);
}), ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def), ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def), ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def), ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def), ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def), ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def), ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def), ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def), ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def), ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def), ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def), ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  let enc = params?.enc ?? "hex", format = `${alg}_${enc}`, regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.int = (params) => inst.check(int(params)), inst.safe = (params) => inst.check(int(params)), inst.positive = (params) => inst.check(_gt(0, params)), inst.nonnegative = (params) => inst.check(_gte(0, params)), inst.negative = (params) => inst.check(_lt(0, params)), inst.nonpositive = (params) => inst.check(_lte(0, params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params)), inst.step = (value, params) => inst.check(_multipleOf(value, params)), inst.finite = () => inst;
  let bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5), inst.isFinite = !0, inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber2, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def), ZodNumber2.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.positive = (params) => inst.check(_gt(BigInt(0), params)), inst.negative = (params) => inst.check(_lt(BigInt(0), params)), inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params)), inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  let bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null, inst.maxValue = bag.maximum ?? null, inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt2, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def), ZodBigInt2.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params), inst.min = (value, params) => inst.check(_gte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params));
  let c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null, inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params), inst.element = def.element, inst.min = (minLength, params) => inst.check(_minLength(minLength, params)), inst.nonempty = (params) => inst.check(_minLength(1, params)), inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params)), inst.length = (len, params) => inst.check(_length(len, params)), inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray2, element, params);
}
function keyof(schema) {
  let shape = schema._zod.def.shape;
  return _enum(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params), util_exports.defineLazy(inst, "shape", () => def.shape), inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)), inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall }), inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() }), inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 }), inst.extend = (incoming) => util_exports.extend(inst, incoming), inst.safeExtend = (incoming) => util_exports.safeExtend(inst, incoming), inst.merge = (other) => util_exports.merge(inst, other), inst.pick = (mask) => util_exports.pick(inst, mask), inst.omit = (mask) => util_exports.omit(inst, mask), inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]), inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  let def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodXor.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: !1,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params), inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  let hasRest = _paramsOrRest instanceof $ZodType, params = hasRest ? _params : _paramsOrRest, rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  let k = clone(keyType);
  return k._zod.values = void 0, new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType, inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params), inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params), inst.enum = def.entries, inst.options = Object.values(def.entries);
  let keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    let newEntries = {};
    for (let value of values)
      if (keys.has(value))
        newEntries[value] = def.entries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  }, inst.exclude = (values, params) => {
    let newEntries = { ...def.entries };
    for (let value of values)
      if (keys.has(value))
        delete newEntries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  let entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params), inst.values = new Set(def.values), Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params), inst.min = (size, params) => inst.check(_minSize(size, params)), inst.max = (size, params) => inst.check(_maxSize(size, params)), inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params), inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    payload.addIssue = (issue2) => {
      if (typeof issue2 == "string")
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      else {
        let _issue = issue2;
        _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = inst), payload.issues.push(util_exports.issue(_issue));
      }
    };
    let output = def.transform(payload.value, payload);
    return output instanceof Promise ? output.then((output2) => (payload.value = output2, payload)) : (payload.value = output, payload);
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue == "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN2, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params), inst.in = def.in, inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def), $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  let ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return ch._zod.check = fn, ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => !0), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe, meta2 = meta;
function _instanceof(cls, params = {}) {
  let inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: !0,
    ...util_exports.normalizeParams(params)
  });
  return inst._zod.bag.Class = cls, inst._zod.check = (payload) => {
    payload.value instanceof cls || payload.issues.push({
      code: "invalid_type",
      expected: cls.name,
      input: payload.value,
      inst,
      path: [...inst._zod.def.path ?? []]
    });
  }, inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json(params) {
  let jsonSchema = lazy(() => union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]));
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// mcp-servers-src/node_modules/zod/v4/classic/compat.js
var ZodFirstPartyTypeKind2;
ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {});

// mcp-servers-src/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports3,
  ...checks_exports2,
  iso: iso_exports2
};

// mcp-servers-src/node_modules/zod/v4/classic/external.js
config(en_default2());

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"], RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task", JSONRPC_VERSION = "2.0", AssertObjectSchema = custom((v) => v !== null && (typeof v == "object" || typeof v == "function")), ProgressTokenSchema = union([string2(), number2().int()]), CursorSchema = string2(), TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number2().optional()
}), TaskMetadataSchema = object2({
  ttl: number2().optional()
}), RelatedTaskMetadataSchema = object2({
  taskId: string2()
}), RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
}), BaseRequestParamsSchema = object2({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
}), TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
}), isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success, RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.loose().optional()
}), NotificationsParamsSchema = object2({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.loose().optional()
}), ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), RequestIdSchema = union([string2(), number2().int()]), JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict(), isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success, JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict(), isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success, JSONRPCResultResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict(), isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2.ConnectionClosed = -32e3] = "ConnectionClosed", ErrorCode2[ErrorCode2.RequestTimeout = -32001] = "RequestTimeout", ErrorCode2[ErrorCode2.ParseError = -32700] = "ParseError", ErrorCode2[ErrorCode2.InvalidRequest = -32600] = "InvalidRequest", ErrorCode2[ErrorCode2.MethodNotFound = -32601] = "MethodNotFound", ErrorCode2[ErrorCode2.InvalidParams = -32602] = "InvalidParams", ErrorCode2[ErrorCode2.InternalError = -32603] = "InternalError", ErrorCode2[ErrorCode2.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object2({
    /**
     * The error type that occurred.
     */
    code: number2().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string2(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]), JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]), EmptyResultSchema = ResultSchema.strict(), CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string2().optional()
}), CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
}), IconSchema = object2({
  /**
   * URL or data URI for the icon.
   */
  src: string2(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string2().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string2()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
}), IconsSchema = object2({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
}), BaseMetadataSchema = object2({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string2(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string2().optional()
}), ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string2().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string2().optional()
}), FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown())), ElicitationCapabilitySchema = preprocess((value) => value && typeof value == "object" && !Array.isArray(value) && Object.keys(value).length === 0 ? { form: {} } : value, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional())), ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ClientCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object2({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object2({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
}), InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
}), InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object2({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object2({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean2().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object2({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
}), InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string2().optional()
}), InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
}), ProgressSchema = object2({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number2(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number2()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string2())
}), ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
}), ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
}), PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
}), PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
}), PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
}), TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]), TaskSchema = object2({
  taskId: string2(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string2(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string2(),
  pollInterval: optional(number2()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string2())
}), CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
}), TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema), TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
}), GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskResultSchema = ResultSchema.merge(TaskSchema), GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskPayloadResultSchema = ResultSchema.loose(), ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
}), ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
}), CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), CancelTaskResultSchema = ResultSchema.merge(TaskSchema), ResourceContentsSchema = object2({
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string2()
}), Base64Schema = string2().refine((val) => {
  try {
    return atob(val), !0;
  } catch {
    return !1;
  }
}, { message: "Invalid Base64 string" }), BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
}), RoleSchema = _enum(["user", "assistant"]), AnnotationsSchema = object2({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number2().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports2.datetime({ offset: !0 }).optional()
}), ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string2(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
}), ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
}), ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
}), ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
}), ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string2()
}), ReadResourceRequestParamsSchema = ResourceRequestParamsSchema, ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
}), ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
}), ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
}), SubscribeRequestParamsSchema = ResourceRequestParamsSchema, SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
}), UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema, UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
}), ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string2()
}), ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
}), PromptArgumentSchema = object2({
  /**
   * The name of the argument.
   */
  name: string2(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string2()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean2())
}), PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string2()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
}), ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
}), GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string2(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string2(), string2()).optional()
}), GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
}), TextContentSchema = object2({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ImageContentSchema = object2({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), AudioContentSchema = object2({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ToolUseContentSchema = object2({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string2(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string2(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string2(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
}), ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]), PromptMessageSchema = object2({
  role: RoleSchema,
  content: ContentBlockSchema
}), GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string2().optional(),
  messages: array(PromptMessageSchema)
}), PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ToolAnnotationsSchema = object2({
  /**
   * A human-readable title for the tool.
   */
  title: string2().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean2().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean2().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean2().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean2().optional()
}), ToolExecutionSchema = object2({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
}), ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string2().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
}), ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
}), CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string2(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean2().optional()
}), CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
})), CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string2(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string2(), unknown()).optional()
}), CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
}), ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ListChangedOptionsBaseSchema = object2({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean2().default(!0),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number2().int().nonnegative().default(300)
}), LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
}), SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
}), LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string2().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
}), LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
}), ModelHintSchema = object2({
  /**
   * A hint for a model name.
   */
  name: string2().optional()
}), ModelPreferencesSchema = object2({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number2().min(0).max(1).optional()
}), ToolChoiceSchema = object2({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
}), ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).loose().optional(),
  isError: boolean2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]), SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]), SamplingMessageSchema = object2({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string2().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
}), CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
}), CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
}), CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
}), BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
}), StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
}), NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
}), UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
}), TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
}), LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
}), SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]), UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
}), TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
}), MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]), EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]), PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]), ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string2(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
}), ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string2(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string2(),
  /**
   * The URL that the user should navigate to.
   */
  url: string2().url()
}), ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]), ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
}), ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string2()
}), ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
}), ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
}), ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string2()
}), CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object2({
    /**
     * The name of the argument
     */
    name: string2(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string2()
  }),
  context: object2({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string2(), string2()).optional()
  }).optional()
}), CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string2()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number2().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean2())
  })
}), RootSchema = object2({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string2().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
}), ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
}), RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]), ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]), ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`), this.code = code, this.data = data, this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      let errorData = data;
      if (errorData.elicitations)
        return new UrlElicitationRequiredError(errorData.elicitations, message);
    }
    return new _McpError(code, message, data);
  }
}, UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  let methodSchema = getObjectShape(schema)?.method;
  if (!methodSchema)
    throw new Error("Schema is missing a method literal");
  let value = getLiteralValue(methodSchema);
  if (typeof value != "string")
    throw new Error("Schema method literal must be a string");
  return value;
}
function parseWithCompat(schema, data) {
  let result = safeParse2(schema, data);
  if (!result.success)
    throw result.error;
  return result.data;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4, Protocol = class {
  constructor(_options) {
    this._options = _options, this._requestMessageId = 0, this._requestHandlers = /* @__PURE__ */ new Map(), this._requestHandlerAbortControllers = /* @__PURE__ */ new Map(), this._notificationHandlers = /* @__PURE__ */ new Map(), this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers = /* @__PURE__ */ new Map(), this._timeoutInfo = /* @__PURE__ */ new Map(), this._pendingDebouncedNotifications = /* @__PURE__ */ new Set(), this._taskProgressTokens = /* @__PURE__ */ new Map(), this._requestResolvers = /* @__PURE__ */ new Map(), this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    }), this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    }), this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    ), this._taskStore = _options?.taskStore, this._taskMessageQueue = _options?.taskMessageQueue, this._taskStore && (this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
      let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
      if (!task)
        throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
      return {
        ...task
      };
    }), this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
      let handleTaskResult = async () => {
        let taskId = request.params.taskId;
        if (this._taskMessageQueue) {
          let queuedMessage;
          for (; queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId); ) {
            if (queuedMessage.type === "response" || queuedMessage.type === "error") {
              let message = queuedMessage.message, requestId = message.id, resolver = this._requestResolvers.get(requestId);
              if (resolver)
                if (this._requestResolvers.delete(requestId), queuedMessage.type === "response")
                  resolver(message);
                else {
                  let errorMessage = message, error2 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                  resolver(error2);
                }
              else {
                let messageType = queuedMessage.type === "response" ? "Response" : "Error";
                this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
              }
              continue;
            }
            await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
          }
        }
        let task = await this._taskStore.getTask(taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
        if (!isTerminal(task.status))
          return await this._waitForTaskUpdate(taskId, extra.signal), await handleTaskResult();
        if (isTerminal(task.status)) {
          let result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
          return this._clearTaskQueue(taskId), {
            ...result,
            _meta: {
              ...result._meta,
              [RELATED_TASK_META_KEY]: {
                taskId
              }
            }
          };
        }
        return await handleTaskResult();
      };
      return await handleTaskResult();
    }), this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
      try {
        let { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
        return {
          tasks,
          nextCursor,
          _meta: {}
        };
      } catch (error2) {
        throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }), this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
      try {
        let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
        await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId), this._clearTaskQueue(request.params.taskId);
        let cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!cancelledTask)
          throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
        return {
          _meta: {},
          ...cancelledTask
        };
      } catch (error2) {
        throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }));
  }
  async _oncancel(notification) {
    if (!notification.params.requestId)
      return;
    this._requestHandlerAbortControllers.get(notification.params.requestId)?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = !1) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    if (!info)
      return !1;
    let totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout)
      throw this._timeoutInfo.delete(messageId), McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    return clearTimeout(info.timeoutId), info.timeoutId = setTimeout(info.onTimeout, info.timeout), !0;
  }
  _cleanupTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    info && (clearTimeout(info.timeoutId), this._timeoutInfo.delete(messageId));
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport)
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    this._transport = transport;
    let _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.(), this._onclose();
    };
    let _onerror = this.transport?.onerror;
    this._transport.onerror = (error2) => {
      _onerror?.(error2), this._onerror(error2);
    };
    let _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra), isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message) ? this._onresponse(message) : isJSONRPCRequest(message) ? this._onrequest(message, extra) : isJSONRPCNotification(message) ? this._onnotification(message) : this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
    }, await this._transport.start();
  }
  _onclose() {
    let responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
    for (let controller of this._requestHandlerAbortControllers.values())
      controller.abort();
    this._requestHandlerAbortControllers.clear();
    let error2 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0, this.onclose?.();
    for (let handler of responseHandlers.values())
      handler(error2);
  }
  _onerror(error2) {
    this.onerror?.(error2);
  }
  _onnotification(notification) {
    let handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    handler !== void 0 && Promise.resolve().then(() => handler(notification)).catch((error2) => this._onerror(new Error(`Uncaught error in notification handler: ${error2}`)));
  }
  _onrequest(request, extra) {
    let handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler, capturedTransport = this._transport, relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      relatedTaskId && this._taskMessageQueue ? this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId).catch((error2) => this._onerror(new Error(`Failed to enqueue error response: ${error2}`))) : capturedTransport?.send(errorResponse).catch((error2) => this._onerror(new Error(`Failed to send an error response: ${error2}`)));
      return;
    }
    let abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    let taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0, taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0, fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        let notificationOptions = { relatedRequestId: request.id };
        relatedTaskId && (notificationOptions.relatedTask = { taskId: relatedTaskId }), await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        if (abortController.signal.aborted)
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        let requestOptions = { ...options, relatedRequestId: request.id };
        relatedTaskId && !requestOptions.relatedTask && (requestOptions.relatedTask = { taskId: relatedTaskId });
        let effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        return effectiveTaskId && taskStore && await taskStore.updateTaskStatus(effectiveTaskId, "input_required"), await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      taskCreationParams && this.assertTaskHandlerCapability(request.method);
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted)
        return;
      let response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "response",
        message: response,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(response);
    }, async (error2) => {
      if (abortController.signal.aborted)
        return;
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error2.code) ? error2.code : ErrorCode.InternalError,
          message: error2.message ?? "Internal error",
          ...error2.data !== void 0 && { data: error2.data }
        }
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(errorResponse);
    }).catch((error2) => this._onerror(new Error(`Failed to send response: ${error2}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    let { progressToken, ...params } = notification.params, messageId = Number(progressToken), handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    let responseHandler = this._responseHandlers.get(messageId), timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress)
      try {
        this._resetTimeout(messageId);
      } catch (error2) {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), responseHandler(error2);
        return;
      }
    handler(params);
  }
  _onresponse(response) {
    let messageId = Number(response.id), resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      if (this._requestResolvers.delete(messageId), isJSONRPCResultResponse(response))
        resolver(response);
      else {
        let error2 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error2);
      }
      return;
    }
    let handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId), this._cleanupTimeout(messageId);
    let isTaskResponse = !1;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result == "object") {
      let result = response.result;
      if (result.task && typeof result.task == "object") {
        let task = result.task;
        typeof task.taskId == "string" && (isTaskResponse = !0, this._taskProgressTokens.set(task.taskId, messageId));
      }
    }
    if (isTaskResponse || this._progressHandlers.delete(messageId), isJSONRPCResultResponse(response))
      handler(response);
    else {
      let error2 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error2);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    let { task } = options ?? {};
    if (!task) {
      try {
        yield { type: "result", result: await this.request(request, resultSchema, options) };
      } catch (error2) {
        yield {
          type: "error",
          error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
        };
      }
      return;
    }
    let taskId;
    try {
      let createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task)
        taskId = createResult.task.taskId, yield { type: "taskCreated", task: createResult.task };
      else
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      for (; ; ) {
        let task2 = await this.getTask({ taskId }, options);
        if (yield { type: "taskStatus", task: task2 }, isTerminal(task2.status)) {
          task2.status === "completed" ? yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) } : task2.status === "failed" ? yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
          } : task2.status === "cancelled" && (yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
          });
          return;
        }
        if (task2.status === "input_required") {
          yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) };
          return;
        }
        let pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval)), options?.signal?.throwIfAborted();
      }
    } catch (error2) {
      yield {
        type: "error",
        error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    let { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      let earlyReject = (error2) => {
        reject(error2);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === !0)
        try {
          this.assertCapabilityForMethod(request.method), task && this.assertTaskCapability(request.method);
        } catch (e) {
          earlyReject(e);
          return;
        }
      options?.signal?.throwIfAborted();
      let messageId = this._requestMessageId++, jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      options?.onprogress && (this._progressHandlers.set(messageId, options.onprogress), jsonrpcRequest.params = {
        ...request.params,
        _meta: {
          ...request.params?._meta || {},
          progressToken: messageId
        }
      }), task && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        task
      }), relatedTask && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        _meta: {
          ...jsonrpcRequest.params?._meta || {},
          [RELATED_TASK_META_KEY]: relatedTask
        }
      });
      let cancel = (reason) => {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error3) => this._onerror(new Error(`Failed to send cancellation: ${error3}`)));
        let error2 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error2);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (!options?.signal?.aborted) {
          if (response instanceof Error)
            return reject(response);
          try {
            let parseResult = safeParse2(resultSchema, response.result);
            parseResult.success ? resolve(parseResult.data) : reject(parseResult.error);
          } catch (error2) {
            reject(error2);
          }
        }
      }), options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      let timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC, timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? !1);
      let relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        let responseResolver = (response) => {
          let handler = this._responseHandlers.get(messageId);
          handler ? handler(response) : this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
        };
        this._requestResolvers.set(messageId, responseResolver), this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
      } else
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport)
      throw new Error("Not connected");
    this.assertNotificationCapability(notification.method);
    let relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      let jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    if ((this._options?.debouncedNotificationMethods ?? []).includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask) {
      if (this._pendingDebouncedNotifications.has(notification.method))
        return;
      this._pendingDebouncedNotifications.add(notification.method), Promise.resolve().then(() => {
        if (this._pendingDebouncedNotifications.delete(notification.method), !this._transport)
          return;
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        options?.relatedTask && (jsonrpcNotification2 = {
          ...jsonrpcNotification2,
          params: {
            ...jsonrpcNotification2.params,
            _meta: {
              ...jsonrpcNotification2.params?._meta || {},
              [RELATED_TASK_META_KEY]: options.relatedTask
            }
          }
        }), this._transport?.send(jsonrpcNotification2, options).catch((error2) => this._onerror(error2));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    options?.relatedTask && (jsonrpcNotification = {
      ...jsonrpcNotification,
      params: {
        ...jsonrpcNotification.params,
        _meta: {
          ...jsonrpcNotification.params?._meta || {},
          [RELATED_TASK_META_KEY]: options.relatedTask
        }
      }
    }), await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    let method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method), this._requestHandlers.set(method, (request, extra) => {
      let parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method))
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    let method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      let parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    let progressToken = this._taskProgressTokens.get(taskId);
    progressToken !== void 0 && (this._progressHandlers.delete(progressToken), this._taskProgressTokens.delete(taskId));
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue)
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    let maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      let messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (let message of messages)
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          let requestId = message.message.id, resolver = this._requestResolvers.get(requestId);
          resolver ? (resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(requestId)) : this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
        }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      let task = await this._taskStore?.getTask(taskId);
      task?.pollInterval && (interval = task.pollInterval);
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      let timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId), reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: !0 });
    });
  }
  requestTaskStore(request, sessionId) {
    let taskStore = this._taskStore;
    if (!taskStore)
      throw new Error("No task store configured");
    return {
      createTask: async (taskParams) => {
        if (!request)
          throw new Error("No request provided");
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        let task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification), isTerminal(task.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      getTaskResult: (taskId) => taskStore.getTaskResult(taskId, sessionId),
      updateTaskStatus: async (taskId, status, statusMessage) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        let updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification), isTerminal(updatedTask.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      listTasks: (cursor) => taskStore.listTasks(cursor, sessionId)
    };
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  let result = { ...base };
  for (let key in additional) {
    let k = key, addValue = additional[k];
    if (addValue === void 0)
      continue;
    let baseValue = result[k];
    isPlainObject2(baseValue) && isPlainObject2(addValue) ? result[k] = { ...baseValue, ...addValue } : result[k] = addValue;
  }
  return result;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1), import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  let ajv = new import_ajv.default({
    strict: !1,
    validateFormats: !0,
    validateSchema: !1,
    allErrors: !0
  });
  return (0, import_ajv_formats.default)(ajv), ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    let ajvValidator = "$id" in schema && typeof schema.$id == "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => ajvValidator(input) ? {
      valid: !0,
      data: input,
      errorMessage: void 0
    } : {
      valid: !1,
      data: void 0,
      errorMessage: this._ajv.errorsText(ajvValidator.errors)
    };
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
var ExperimentalServerTasks = class {
  constructor(_server) {
    this._server = _server;
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._server.requestStream(request, resultSchema, options);
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._server.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._server.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._server.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._server.cancelTask({ taskId }, options);
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call)
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage)
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create)
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      break;
    default:
      break;
  }
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server = class extends Protocol {
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    super(options), this._serverInfo = _serverInfo, this._loggingLevels = /* @__PURE__ */ new Map(), this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index])), this.isMessageIgnored = (level, sessionId) => {
      let currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : !1;
    }, this._capabilities = options?.capabilities ?? {}, this._instructions = options?.instructions, this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator(), this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request)), this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.()), this._capabilities.logging && this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
      let transportSessionId = extra.sessionId || extra.requestInfo?.headers["mcp-session-id"] || void 0, { level } = request.params, parseResult = LoggingLevelSchema.safeParse(level);
      return parseResult.success && this._loggingLevels.set(transportSessionId, parseResult.data), {};
    });
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    return this._experimental || (this._experimental = {
      tasks: new ExperimentalServerTasks(this)
    }), this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport)
      throw new Error("Cannot register capabilities after connecting to transport");
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce server-side validation for tools/call.
   */
  setRequestHandler(requestSchema, handler) {
    let methodSchema = getObjectShape(requestSchema)?.method;
    if (!methodSchema)
      throw new Error("Schema is missing a method literal");
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      let v4Schema = methodSchema;
      methodValue = v4Schema._zod?.def?.value ?? v4Schema.value;
    } else {
      let v3Schema = methodSchema;
      methodValue = v3Schema._def?.value ?? v3Schema.value;
    }
    if (typeof methodValue != "string")
      throw new Error("Schema method literal must be a string");
    if (methodValue === "tools/call") {
      let wrappedHandler = async (request, extra) => {
        let validatedRequest = safeParse2(CallToolRequestSchema, request);
        if (!validatedRequest.success) {
          let errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
        }
        let { params } = validatedRequest.data, result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          let taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            let errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        let validationResult = safeParse2(CallToolResultSchema, result);
        if (!validationResult.success) {
          let errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._clientCapabilities?.sampling)
          throw new Error(`Client does not support sampling (required for ${method})`);
        break;
      case "elicitation/create":
        if (!this._clientCapabilities?.elicitation)
          throw new Error(`Client does not support elicitation (required for ${method})`);
        break;
      case "roots/list":
        if (!this._clientCapabilities?.roots)
          throw new Error(`Client does not support listing roots (required for ${method})`);
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging)
          throw new Error(`Server does not support logging (required for ${method})`);
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources)
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools)
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts)
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        break;
      case "notifications/elicitation/complete":
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error(`Client does not support URL elicitation (required for ${method})`);
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (this._capabilities)
      switch (method) {
        case "completion/complete":
          if (!this._capabilities.completions)
            throw new Error(`Server does not support completions (required for ${method})`);
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging)
            throw new Error(`Server does not support logging (required for ${method})`);
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts)
            throw new Error(`Server does not support prompts (required for ${method})`);
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources)
            throw new Error(`Server does not support resources (required for ${method})`);
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools)
            throw new Error(`Server does not support tools (required for ${method})`);
          break;
        case "tasks/get":
        case "tasks/list":
        case "tasks/result":
        case "tasks/cancel":
          if (!this._capabilities.tasks)
            throw new Error(`Server does not support tasks capability (required for ${method})`);
          break;
        case "ping":
        case "initialize":
          break;
      }
  }
  assertTaskCapability(method) {
    assertClientRequestTaskCapability(this._clientCapabilities?.tasks?.requests, method, "Client");
  }
  assertTaskHandlerCapability(method) {
    this._capabilities && assertToolsCallTaskCapability(this._capabilities.tasks?.requests, method, "Server");
  }
  async _oninitialize(request) {
    let requestedVersion = request.params.protocolVersion;
    return this._clientCapabilities = request.params.capabilities, this._clientVersion = request.params.clientInfo, {
      protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  // Implementation
  async createMessage(params, options) {
    if ((params.tools || params.toolChoice) && !this._clientCapabilities?.sampling?.tools)
      throw new Error("Client does not support sampling tools capability.");
    if (params.messages.length > 0) {
      let lastMessage = params.messages[params.messages.length - 1], lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content], hasToolResults = lastContent.some((c) => c.type === "tool_result"), previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0, previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [], hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
      if (hasToolResults) {
        if (lastContent.some((c) => c.type !== "tool_result"))
          throw new Error("The last message must contain only tool_result content if any is present");
        if (!hasPreviousToolUse)
          throw new Error("tool_result blocks are not matching any tool_use from the previous message");
      }
      if (hasPreviousToolUse) {
        let toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id)), toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
        if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id)))
          throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
      }
    }
    return params.tools ? this.request({ method: "sampling/createMessage", params }, CreateMessageResultWithToolsSchema, options) : this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  /**
   * Creates an elicitation request for the given parameters.
   * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
   * @param params The parameters for the elicitation request.
   * @param options Optional request options.
   * @returns The result of the elicitation request.
   */
  async elicitInput(params, options) {
    switch (params.mode ?? "form") {
      case "url": {
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error("Client does not support url elicitation.");
        let urlParams = params;
        return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options);
      }
      case "form": {
        if (!this._clientCapabilities?.elicitation?.form)
          throw new Error("Client does not support form elicitation.");
        let formParams = params.mode === "form" ? params : { ...params, mode: "form" }, result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content && formParams.requestedSchema)
          try {
            let validationResult = this._jsonSchemaValidator.getValidator(formParams.requestedSchema)(result.content);
            if (!validationResult.valid)
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
          } catch (error2) {
            throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error2 instanceof Error ? error2.message : String(error2)}`);
          }
        return result;
      }
    }
  }
  /**
   * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
   * notification for the specified elicitation ID.
   *
   * @param elicitationId The ID of the elicitation to mark as complete.
   * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
   * @returns A function that emits the completion notification when awaited.
   */
  createElicitationCompletionNotifier(elicitationId, options) {
    if (!this._clientCapabilities?.elicitation?.url)
      throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
    return () => this.notification({
      method: "notifications/elicitation/complete",
      params: {
        elicitationId
      }
    }, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging && !this.isMessageIgnored(params.level, sessionId))
      return this.notification({ method: "notifications/message", params });
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var import_node_process = __toESM(require("node:process"), 1);

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer)
      return null;
    let index = this._buffer.indexOf(`
`);
    if (index === -1)
      return null;
    let line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    return this._buffer = this._buffer.subarray(index + 1), deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var StdioServerTransport = class {
  constructor(_stdin = import_node_process.default.stdin, _stdout = import_node_process.default.stdout) {
    this._stdin = _stdin, this._stdout = _stdout, this._readBuffer = new ReadBuffer(), this._started = !1, this._ondata = (chunk) => {
      this._readBuffer.append(chunk), this.processReadBuffer();
    }, this._onerror = (error2) => {
      this.onerror?.(error2);
    };
  }
  /**
   * Starts listening for messages on stdin.
   */
  async start() {
    if (this._started)
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    this._started = !0, this._stdin.on("data", this._ondata), this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    for (; ; )
      try {
        let message = this._readBuffer.readMessage();
        if (message === null)
          break;
        this.onmessage?.(message);
      } catch (error2) {
        this.onerror?.(error2);
      }
  }
  async close() {
    this._stdin.off("data", this._ondata), this._stdin.off("error", this._onerror), this._stdin.listenerCount("data") === 0 && this._stdin.pause(), this._readBuffer.clear(), this.onclose?.();
  }
  send(message) {
    return new Promise((resolve) => {
      let json2 = serializeMessage(message);
      this._stdout.write(json2) ? resolve() : this._stdout.once("drain", resolve);
    });
  }
};

// mcp-servers-src/fedlex-sparql/src/sparql-client.ts
var DEFAULT_CONFIG = {
  endpoint: "https://fedlex.data.admin.ch/sparqlendpoint",
  // Correct Fedlex SPARQL endpoint
  timeout: 3e4,
  // 30 seconds
  maxRetries: 3,
  retryDelay: 1e3,
  // 1 second
  userAgent: "BetterCallClaude/2.0.1 (Swiss Legal Intelligence)"
}, SPARQLClient = class {
  config;
  constructor(config2 = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config2 };
  }
  /**
   * Execute a SPARQL SELECT query
   */
  async query(sparql, options = {}) {
    let { format = "json", timeout = this.config.timeout, acceptLanguage } = options, headers = {
      Accept: format === "json" ? "application/sparql-results+json" : "application/sparql-results+xml",
      "Content-Type": "application/x-www-form-urlencoded",
      "User-Agent": this.config.userAgent
    };
    acceptLanguage && (headers["Accept-Language"] = acceptLanguage);
    let body = new URLSearchParams({
      query: sparql
    }), lastError = null;
    for (let attempt = 0; attempt < this.config.maxRetries; attempt++)
      try {
        let controller = new AbortController(), timeoutId = setTimeout(() => controller.abort(), timeout), response = await fetch(this.config.endpoint, {
          method: "POST",
          headers,
          body: body.toString(),
          signal: controller.signal
        });
        if (clearTimeout(timeoutId), !response.ok) {
          let errorText = await response.text();
          throw new Error(`SPARQL query failed: ${response.status} ${response.statusText} - ${errorText}`);
        }
        return await response.json();
      } catch (error2) {
        if (lastError = error2, lastError.message.includes("4"))
          throw this.createFedlexError(lastError, sparql);
        attempt < this.config.maxRetries - 1 && await this.delay(this.config.retryDelay * (attempt + 1));
      }
    throw this.createFedlexError(lastError, sparql);
  }
  /**
   * Execute a SPARQL ASK query
   */
  async ask(sparql, options = {}) {
    return (await this.query(sparql, options)).boolean ?? !1;
  }
  /**
   * Execute a SPARQL DESCRIBE query
   */
  async describe(sparql, options = {}) {
    return this.query(sparql, { ...options, format: "json" });
  }
  /**
   * Helper to extract a single value from bindings
   */
  extractValue(binding) {
    return binding?.value;
  }
  /**
   * Helper to extract a localized value based on language preference
   */
  extractLocalizedValue(bindings, variableName, preferredLang = "de") {
    for (let binding of bindings) {
      let value = binding[variableName];
      if (value && value["xml:lang"] === preferredLang)
        return value.value;
    }
    for (let binding of bindings) {
      let value = binding[variableName];
      if (value)
        return value.value;
    }
  }
  /**
   * Helper to extract multilingual values
   */
  extractMultilingualValue(bindings, variableName) {
    let result = {};
    for (let binding of bindings) {
      let value = binding[variableName];
      value && value["xml:lang"] ? result[value["xml:lang"]] = value.value : value && !Object.keys(result).length && (result.de = value.value);
    }
    return result;
  }
  /**
   * Helper to group bindings by a key variable
   */
  groupBindings(bindings, keyVariable) {
    let groups = /* @__PURE__ */ new Map();
    for (let binding of bindings) {
      let key = this.extractValue(binding[keyVariable]);
      if (key) {
        let group = groups.get(key) || [];
        group.push(binding), groups.set(key, group);
      }
    }
    return groups;
  }
  /**
   * Validate a SPARQL query syntax (basic check)
   */
  validateQuery(sparql) {
    let trimmed = sparql.trim().toUpperCase();
    if (!trimmed.startsWith("SELECT") && !trimmed.startsWith("ASK") && !trimmed.startsWith("DESCRIBE") && !trimmed.startsWith("CONSTRUCT") && !trimmed.startsWith("PREFIX"))
      return { valid: !1, error: "Query must start with SELECT, ASK, DESCRIBE, CONSTRUCT, or PREFIX" };
    let openBraces = (sparql.match(/{/g) || []).length, closeBraces = (sparql.match(/}/g) || []).length;
    return openBraces !== closeBraces ? { valid: !1, error: "Unbalanced braces in query" } : { valid: !0 };
  }
  /**
   * Create a FedlexError from an Error
   */
  createFedlexError(error2, query) {
    return {
      code: "SPARQL_ERROR",
      message: error2.message,
      query,
      endpoint: this.config.endpoint
    };
  }
  /**
   * Delay helper for retry logic
   */
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  /**
   * Get the configured endpoint URL
   */
  getEndpoint() {
    return this.config.endpoint;
  }
  /**
   * Update client configuration
   */
  updateConfig(config2) {
    this.config = { ...this.config, ...config2 };
  }
};
function createFedlexClient(config2) {
  return new SPARQLClient({
    ...DEFAULT_CONFIG,
    ...config2
  });
}
function escapeForSPARQL(value) {
  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\t/g, "\\t");
}

// mcp-servers-src/fedlex-sparql/src/queries/prefixes.ts
var RDF_PREFIXES = `
PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>
PREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>
PREFIX xsd: <http://www.w3.org/2001/XMLSchema#>
PREFIX owl: <http://www.w3.org/2002/07/owl#>
PREFIX skos: <http://www.w3.org/2004/02/skos/core#>
PREFIX dcterms: <http://purl.org/dc/terms/>
PREFIX dcat: <http://www.w3.org/ns/dcat#>
`, FEDLEX_PREFIXES = `
PREFIX eli: <http://data.europa.eu/eli/ontology#>
PREFIX jolux: <http://data.legilux.public.lu/resource/ontology/jolux#>
PREFIX fedlex: <https://fedlex.data.admin.ch/vocabulary/>
PREFIX fedlex-eli: <https://fedlex.data.admin.ch/eli/>
PREFIX fedlex-cc: <https://fedlex.data.admin.ch/eli/cc/>
PREFIX schema: <http://schema.org/>
`, LINDAS_PREFIXES = `
PREFIX ld: <https://ld.admin.ch/>
PREFIX cube: <https://cube.link/>
PREFIX qudt: <http://qudt.org/schema/qudt/>
`, ALL_PREFIXES = `${RDF_PREFIXES}${FEDLEX_PREFIXES}${LINDAS_PREFIXES}`;
function withPrefixes(query) {
  return `${ALL_PREFIXES}
${query}`;
}

// mcp-servers-src/fedlex-sparql/src/queries/lookup.ts
function buildLookupStatuteQuery(srNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?inForce ?dateInForce ?dateDocument ?actType
WHERE {
  # Find act via taxonomy classification
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  # Get SR number from taxonomy
  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get title from taxonomy prefLabel (has language tags)
  ?taxonomy skos:prefLabel ?title .
  ${langFilter}

  # Optional metadata
  OPTIONAL { ?act jolux:titleShort ?abbreviation }
  OPTIONAL { ?act jolux:dateDocument ?dateDocument }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
  OPTIONAL { ?act jolux:typeDocument ?actType }

  # Check if currently in force
  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }
}
ORDER BY ?srNumber
LIMIT 10
  `);
}
function buildLookupByAbbreviationQuery(abbreviation, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?inForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  ?taxonomy skos:prefLabel ?title .
  ${langFilter}

  # Search for abbreviation in various places
  {
    ?act jolux:titleShort ?abbreviation .
    FILTER(UCASE(STR(?abbreviation)) = "${escapeForSPARQL(abbreviation.toUpperCase())}")
  } UNION {
    ?taxonomy skos:altLabel ?abbreviation .
    FILTER(UCASE(STR(?abbreviation)) = "${escapeForSPARQL(abbreviation.toUpperCase())}")
  }

  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }
}
ORDER BY ?srNumber
LIMIT 10
  `);
}

// mcp-servers-src/fedlex-sparql/src/queries/articles.ts
function buildGetArticleQuery(srNumber, articleNumber, language) {
  let langFilter = language ? `FILTER(LANG(?actTitle) = "${language}")` : "", normalizedArticle = articleNumber.replace(/^Art\.?\s*/i, "").trim();
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?actTitle ?article ?articleNumber ?articleTitle ?text ?paragraphNum ?paragraphText
WHERE {
  # Find the act via taxonomy (ConsolidationAbstract for consolidated laws)
  ?act a jolux:ConsolidationAbstract ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?actTitle .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  # Find articles that belong to this act (inverse relationship: article \u2192 parent)
  ?article a jolux:LegalResourceSubdivision ;
           jolux:legalResourceSubdivisionIsPartOf ?act ;
           jolux:legalResourceSubdivisionType <https://fedlex.data.admin.ch/vocabulary/subdivision-type/art> .

  # Get article number from subdivision detail
  ?article jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?detail .
  ?detail jolux:legalResourceSubdivisionDetailId ?articleNumber .

  # Match article number
  FILTER(
    STR(?articleNumber) = "${escapeForSPARQL(normalizedArticle)}" ||
    REGEX(STR(?articleNumber), "^${escapeForSPARQL(normalizedArticle)}[a-z]?$", "i")
  )

  # Article title (marginal note) from expression
  OPTIONAL {
    ?article jolux:isRealizedBy ?articleExpr .
    ?articleExpr jolux:title ?articleTitle .
    ${language ? `FILTER(LANG(?articleTitle) = "${language}")` : ""}
  }

  # Get text content from manifestation
  OPTIONAL {
    ?article jolux:isRealizedBy ?expr .
    ?expr jolux:isEmbodiedBy ?manif .
    ?manif jolux:text ?text .
  }

  # Paragraphs (sub-subdivisions)
  OPTIONAL {
    ?paragraph a jolux:LegalResourceSubdivision ;
               jolux:legalResourceSubdivisionIsPartOf ?article .
    ?paragraph jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?pDetail .
    ?pDetail jolux:legalResourceSubdivisionDetailId ?paragraphNum .

    OPTIONAL {
      ?paragraph jolux:isRealizedBy ?pExpr .
      ?pExpr jolux:isEmbodiedBy ?pManif .
      ?pManif jolux:text ?paragraphText .
    }
  }
}
ORDER BY ?paragraphNum
  `);
}
function buildGetArticleParagraphQuery(srNumber, articleNumber, paragraphNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", normalizedArticle = articleNumber.replace(/^Art\.?\s*/i, "").trim();
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?article ?articleNumber ?paragraph ?paragraphNum ?text
WHERE {
  ?act a jolux:ConsolidationAbstract ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  # Find article via inverse relationship
  ?article a jolux:LegalResourceSubdivision ;
           jolux:legalResourceSubdivisionIsPartOf ?act ;
           jolux:legalResourceSubdivisionType <https://fedlex.data.admin.ch/vocabulary/subdivision-type/art> .

  ?article jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?detail .
  ?detail jolux:legalResourceSubdivisionDetailId ?articleNumber .

  FILTER(
    STR(?articleNumber) = "${escapeForSPARQL(normalizedArticle)}" ||
    REGEX(STR(?articleNumber), "^${escapeForSPARQL(normalizedArticle)}[a-z]?$", "i")
  )

  # Find paragraph within article
  ?paragraph a jolux:LegalResourceSubdivision ;
             jolux:legalResourceSubdivisionIsPartOf ?article .

  ?paragraph jolux:legalResourceSubdivisionHasSubdivisionIdentificationDetail ?pDetail .
  ?pDetail jolux:legalResourceSubdivisionDetailId ?paragraphNum .

  FILTER(STR(?paragraphNum) = "${escapeForSPARQL(paragraphNumber)}")

  # Get paragraph text
  OPTIONAL {
    ?paragraph jolux:isRealizedBy ?pExpr .
    ?pExpr jolux:isEmbodiedBy ?pManif .
    ?pManif jolux:text ?text .
  }
}
  `);
}

// mcp-servers-src/fedlex-sparql/src/queries/search.ts
function buildSearchQuery(searchText, filters = {}) {
  let {
    language,
    actType,
    // status filter not yet implemented - Fedlex uses jolux:inForce vocabulary
    srNumberPrefix,
    limit = 50,
    offset = 0
  } = filters, langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", srPrefixFilter = srNumberPrefix ? `FILTER(STRSTARTS(STR(?srNumber), "${escapeForSPARQL(srNumberPrefix)}"))` : "", actTypeFilter = actType && actType.length > 0 ? `FILTER(?actType IN (${actType.map((t) => `"${t}"`).join(", ")}))` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?actType ?dateInForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  # Get SR number from taxonomy
  ?taxonomy skos:notation ?srNumber .

  # Get title from taxonomy prefLabel (has language tags)
  ?taxonomy skos:prefLabel ?title .

  # Text search in title or SR number
  FILTER(
    CONTAINS(LCASE(STR(?title)), LCASE("${escapeForSPARQL(searchText)}")) ||
    CONTAINS(LCASE(STR(?srNumber)), LCASE("${escapeForSPARQL(searchText)}"))
  )

  ${langFilter}
  ${srPrefixFilter}
  ${actTypeFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
  OPTIONAL { ?act jolux:typeDocument ?actType }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
}
ORDER BY ?srNumber
OFFSET ${offset}
LIMIT ${limit}
  `);
}
function buildSearchCountQuery(searchText, filters = {}) {
  let { language, srNumberPrefix, actType } = filters, langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", srPrefixFilter = srNumberPrefix ? `FILTER(STRSTARTS(STR(?srNumber), "${escapeForSPARQL(srNumberPrefix)}"))` : "", actTypeFilter = actType && actType.length > 0 ? `FILTER(?actType IN (${actType.map((t) => `"${t}"`).join(", ")}))` : "";
  return withPrefixes(`
SELECT (COUNT(DISTINCT ?act) AS ?count)
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(
    CONTAINS(LCASE(STR(?title)), LCASE("${escapeForSPARQL(searchText)}")) ||
    CONTAINS(LCASE(STR(?srNumber)), LCASE("${escapeForSPARQL(searchText)}"))
  )

  ${langFilter}
  ${srPrefixFilter}
  ${actTypeFilter}

  OPTIONAL { ?act jolux:typeDocument ?actType }
}
  `);
}
function buildSearchByDomainQuery(domain2, language, limit = 100) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STRSTARTS(STR(?srNumber), "${escapeForSPARQL(domain2)}"))
  ${langFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
}
ORDER BY ?srNumber
LIMIT ${limit}
  `);
}
function buildSearchByDateQuery(dateFrom, dateTo, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "", dateFilter = "";
  return dateFrom && dateTo ? dateFilter = `FILTER(?dateInForce >= "${dateFrom}"^^xsd:date && ?dateInForce <= "${dateTo}"^^xsd:date)` : dateFrom ? dateFilter = `FILTER(?dateInForce >= "${dateFrom}"^^xsd:date)` : dateTo && (dateFilter = `FILTER(?dateInForce <= "${dateTo}"^^xsd:date)`), withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?dateInForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy ;
       jolux:dateEntryInForce ?dateInForce .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  ${dateFilter}
  ${langFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
}
ORDER BY DESC(?dateInForce)
LIMIT ${limit}
  `);
}
var LEGAL_DOMAINS = {
  1: { de: "Staat - Volk - Beh\xF6rden", fr: "\xC9tat - Peuple - Autorit\xE9s", it: "Stato - Popolo - Autorit\xE0" },
  2: { de: "Privatrecht - Zivilrechtspflege - Vollstreckung", fr: "Droit priv\xE9 - Proc\xE9dure civile - Ex\xE9cution forc\xE9e", it: "Diritto privato - Procedura civile - Esecuzione" },
  3: { de: "Strafrecht - Strafrechtspflege - Strafvollzug", fr: "Droit p\xE9nal - Proc\xE9dure p\xE9nale - Ex\xE9cution des peines", it: "Diritto penale - Procedura penale - Esecuzione delle pene" },
  4: { de: "Schule - Wissenschaft - Kultur", fr: "\xC9cole - Science - Culture", it: "Scuola - Scienza - Cultura" },
  5: { de: "Landesverteidigung", fr: "D\xE9fense nationale", it: "Difesa nazionale" },
  6: { de: "Finanzen", fr: "Finances", it: "Finanze" },
  7: { de: "\xD6ffentliche Werke - Energie - Verkehr", fr: "Travaux publics - \xC9nergie - Transports", it: "Lavori pubblici - Energia - Trasporti" },
  8: { de: "Gesundheit - Arbeit - Soziale Sicherheit", fr: "Sant\xE9 - Travail - S\xE9curit\xE9 sociale", it: "Sanit\xE0 - Lavoro - Sicurezza sociale" },
  9: { de: "Wirtschaft - Technische Zusammenarbeit", fr: "\xC9conomie - Coop\xE9ration technique", it: "Economia - Cooperazione tecnica" }
};

// mcp-servers-src/fedlex-sparql/src/queries/related.ts
function buildFindAmendingActsQuery(srNumber, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?amendingTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?amendingAct ?amendingSrNumber ?amendingTitle ?amendmentDate ?amendmentType
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Find acts that amend this act via consolidation links
  # JOLUX uses legalResourceImpactHasLegalResource or similar predicates
  {
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?act .
    ?impactEntry jolux:impactFromLegalResource ?amendingAct .
  } UNION {
    # Alternative: direct amendment relationship if available
    ?amendingAct jolux:legalResourceLegalResourceAmends ?act .
  }

  ?amendingAct a jolux:Act ;
               jolux:classifiedByTaxonomyEntry ?amendingTax .

  ?amendingTax skos:notation ?amendingSrNumber ;
               skos:prefLabel ?amendingTitle .

  ${langFilter}

  OPTIONAL { ?amendingAct jolux:dateDocument ?amendmentDate }
  OPTIONAL { ?amendingAct jolux:typeDocument ?amendmentType }
}
ORDER BY DESC(?amendmentDate)
LIMIT ${limit}
  `);
}
function buildFindAmendedActsQuery(srNumber, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?amendedTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?amendedAct ?amendedSrNumber ?amendedTitle
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Find acts amended by this act
  {
    ?impactEntry jolux:impactFromLegalResource ?act .
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?amendedAct .
  } UNION {
    ?act jolux:legalResourceLegalResourceAmends ?amendedAct .
  }

  ?amendedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?amendedTax .

  ?amendedTax skos:notation ?amendedSrNumber ;
              skos:prefLabel ?amendedTitle .

  ${langFilter}
}
ORDER BY ?amendedSrNumber
LIMIT ${limit}
  `);
}
function buildFindReferencingActsQuery(srNumber, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?referencingTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?referencingAct ?referencingSrNumber ?referencingTitle ?referenceType
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Find acts that reference this act via various relationship types
  {
    ?referencingAct jolux:legalResourceLegalResourceCites ?act .
    BIND("cites" AS ?referenceType)
  } UNION {
    ?referencingAct jolux:legalResourceLegalResourceBasedOn ?act .
    BIND("based_on" AS ?referenceType)
  } UNION {
    ?referencingAct jolux:legalResourceLegalResourceImplements ?act .
    BIND("implements" AS ?referenceType)
  }

  ?referencingAct a jolux:Act ;
                  jolux:classifiedByTaxonomyEntry ?refTax .

  ?refTax skos:notation ?referencingSrNumber ;
          skos:prefLabel ?referencingTitle .

  ${langFilter}
}
ORDER BY ?referencingSrNumber
LIMIT ${limit}
  `);
}
function buildFindRelatedByDomainQuery(srNumber, language, limit = 20) {
  let langFilter = language ? `FILTER(LANG(?relatedTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?relatedAct ?relatedSrNumber ?relatedTitle
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get the domain prefix (first digit(s) of SR number)
  BIND(REPLACE(STR(?srNumber), "^([0-9]+)\\\\..*", "$1") AS ?domainPrefix)

  # Find acts in the same domain via taxonomy
  ?relatedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?relatedTax .

  ?relatedTax skos:notation ?relatedSrNumber ;
              skos:prefLabel ?relatedTitle .

  FILTER(?relatedAct != ?act)
  FILTER(STRSTARTS(STR(?relatedSrNumber), ?domainPrefix))

  ${langFilter}
}
ORDER BY ?relatedSrNumber
LIMIT ${limit}
  `);
}
function buildFindRelatedBySubjectQuery(srNumber, language, limit = 20) {
  let langFilter = language ? `FILTER(LANG(?relatedTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?relatedAct ?relatedSrNumber ?relatedTitle ?sharedSubject
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get subject via taxonomy or dcterms:subject
  {
    ?taxonomy skos:broader ?subject .
  } UNION {
    ?act dcterms:subject ?subject .
  }

  # Find acts with the same subject
  {
    ?relatedAct jolux:classifiedByTaxonomyEntry ?relatedTax .
    ?relatedTax skos:broader ?subject .
  } UNION {
    ?relatedAct dcterms:subject ?subject .
  }

  ?relatedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?relatedTaxMain .

  ?relatedTaxMain skos:notation ?relatedSrNumber ;
                  skos:prefLabel ?relatedTitle .

  FILTER(?relatedAct != ?act)

  OPTIONAL { ?subject skos:prefLabel ?sharedSubject }

  ${langFilter}
}
ORDER BY ?relatedSrNumber
LIMIT ${limit}
  `);
}
function buildFindAllRelatedQuery(srNumber, relationType, language, limit = 50) {
  let langFilter = language ? `FILTER(LANG(?relatedTitle) = "${language}")` : "";
  if (relationType)
    switch (relationType) {
      case "amends":
        return buildFindAmendingActsQuery(srNumber, language, limit);
      case "amended_by":
        return buildFindAmendedActsQuery(srNumber, language, limit);
      case "cites":
      case "cited_by":
      case "implements":
      case "implemented_by":
      case "based_on":
        return buildFindReferencingActsQuery(srNumber, language, limit);
      case "same_domain":
        return buildFindRelatedByDomainQuery(srNumber, language, limit);
      case "same_subject":
        return buildFindRelatedBySubjectQuery(srNumber, language, limit);
    }
  return withPrefixes(`
SELECT DISTINCT ?relatedAct ?relatedSrNumber ?relatedTitle ?relationType ?relationDate
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  {
    # Amending acts (via impact entries)
    ?impactEntry jolux:impactFromLegalResource ?relatedAct .
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?act .
    BIND("amends" AS ?relationType)
  } UNION {
    # Amended acts
    ?impactEntry jolux:impactFromLegalResource ?act .
    ?impactEntry jolux:legalResourceImpactHasLegalResource ?relatedAct .
    BIND("amended_by" AS ?relationType)
  } UNION {
    # Citing acts
    ?relatedAct jolux:legalResourceLegalResourceCites ?act .
    BIND("cites" AS ?relationType)
  } UNION {
    # Cited acts
    ?act jolux:legalResourceLegalResourceCites ?relatedAct .
    BIND("cited_by" AS ?relationType)
  } UNION {
    # Based on
    ?relatedAct jolux:legalResourceLegalResourceBasedOn ?act .
    BIND("based_on" AS ?relationType)
  }

  ?relatedAct a jolux:Act ;
              jolux:classifiedByTaxonomyEntry ?relatedTax .

  ?relatedTax skos:notation ?relatedSrNumber ;
              skos:prefLabel ?relatedTitle .

  ${langFilter}

  OPTIONAL { ?relatedAct jolux:dateDocument ?relationDate }
}
ORDER BY ?relationType ?relatedSrNumber
LIMIT ${limit}
  `);
}
function buildLegislativeHistoryQuery(srNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?version ?date ?title ?changeDescription
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  # Get all versions/expressions in the consolidation
  ?act jolux:isRealizedBy ?version .
  ?version jolux:dateDocument ?date .

  OPTIONAL { ?version jolux:title ?changeDescription }
}
ORDER BY DESC(?date)
LIMIT 100
  `);
}

// mcp-servers-src/fedlex-sparql/src/queries/metadata.ts
function buildGetMetadataQuery(srNumber, language) {
  let langFilter = language ? `FILTER(LANG(?title) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?act ?srNumber ?title ?abbreviation ?actType ?dateDocument ?dateInForce
       ?dateAbrogation ?publicationStatus ?responsibleAuthority ?legalBasis
       ?classificationNumber ?version ?expressionLanguage ?inForce
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")
  ${langFilter}

  OPTIONAL { ?act jolux:titleShort ?abbreviation }
  OPTIONAL { ?act jolux:typeDocument ?actType }
  OPTIONAL { ?act jolux:dateDocument ?dateDocument }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
  OPTIONAL { ?act jolux:dateNoLongerInForce ?dateAbrogation }

  # In force status
  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }

  # Authority and basis
  OPTIONAL { ?act dcterms:creator ?responsibleAuthority }
  OPTIONAL { ?act jolux:legalResourceLegalResourceBasedOn ?legalBasis }

  # Classification number (same as SR)
  BIND(?srNumber AS ?classificationNumber)

  # Version info via Expression
  OPTIONAL {
    ?act jolux:isRealizedBy ?version .
    ?version jolux:language ?expressionLanguage .
  }
}
LIMIT 50
  `);
}
function buildGetLanguagesQuery(srNumber) {
  return withPrefixes(`
SELECT DISTINCT ?language ?title
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber ;
            skos:prefLabel ?title .

  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  BIND(LANG(?title) AS ?language)
  FILTER(BOUND(?language) && ?language != "")
}
ORDER BY ?language
  `);
}
function buildGetSubjectsQuery(srNumber, language) {
  let langFilter = language ? `FILTER(!BOUND(?label) || LANG(?label) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?subject ?label ?scheme
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get subjects from taxonomy hierarchy or dcterms:subject
  {
    ?taxonomy skos:broader ?subject .
  } UNION {
    ?act dcterms:subject ?subject .
  }

  OPTIONAL { ?subject skos:prefLabel ?label }
  OPTIONAL { ?subject skos:inScheme ?scheme }

  ${langFilter}
}
ORDER BY ?label
  `);
}
function buildGetVersionHistoryQuery(srNumber) {
  return withPrefixes(`
SELECT DISTINCT ?version ?versionDate ?versionType ?title
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  ?act jolux:isRealizedBy ?version .

  OPTIONAL { ?version jolux:dateDocument ?versionDate }
  OPTIONAL { ?version jolux:typeDocument ?versionType }
  OPTIONAL { ?version jolux:title ?title }
}
ORDER BY DESC(?versionDate)
LIMIT 50
  `);
}
function buildGetLegalStatusQuery(srNumber) {
  return withPrefixes(`
SELECT DISTINCT ?status ?inForce ?dateInForce ?dateAbrogation ?abrogatedBy
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  OPTIONAL {
    ?act jolux:inForce ?inForceStatus .
    BIND(?inForceStatus = <https://fedlex.data.admin.ch/vocabulary/enforcement-status/1> AS ?inForce)
  }
  OPTIONAL { ?act jolux:dateEntryInForce ?dateInForce }
  OPTIONAL { ?act jolux:dateNoLongerInForce ?dateAbrogation }

  # Check if abrogated by another act
  OPTIONAL {
    ?abrogatingAct jolux:legalResourceLegalResourceRepeals ?act .
    ?abrogatingAct jolux:classifiedByTaxonomyEntry ?abrogatingTax .
    ?abrogatingTax skos:notation ?abrogatedBy .
  }

  BIND(
    IF(BOUND(?dateAbrogation), "abrogated",
      IF(BOUND(?dateInForce), "in_force", "pending")
    ) AS ?status
  )
}
  `);
}
function buildGetStructureQuery(srNumber, language) {
  let langFilter = language ? `FILTER(!BOUND(?partTitle) || LANG(?partTitle) = "${language}")` : "";
  return withPrefixes(`
SELECT DISTINCT ?part ?partNumber ?partTitle ?partType ?parentPart
WHERE {
  ?act a jolux:Act ;
       jolux:classifiedByTaxonomyEntry ?taxonomy .

  ?taxonomy skos:notation ?srNumber .
  FILTER(STR(?srNumber) = "${escapeForSPARQL(srNumber)}")

  # Get structural parts (chapters, sections, articles)
  ?act jolux:hasPart+ ?part .

  ?part jolux:number ?partNumber .

  OPTIONAL {
    ?part jolux:isRealizedBy ?partExpr .
    ?partExpr jolux:title ?partTitle .
  }
  OPTIONAL { ?part a ?partType }

  # Get parent relationship for hierarchy
  OPTIONAL {
    ?parentPart jolux:hasPart ?part .
    FILTER(?parentPart != ?act)
  }

  ${langFilter}
}
ORDER BY ?partNumber
LIMIT 500
  `);
}

// mcp-servers-src/fedlex-sparql/src/abbreviation-map.ts
var ABBREVIATION_TO_SR = /* @__PURE__ */ new Map([
  // === CONSTITUTIONAL LAW ===
  // Bundesverfassung / Constitution federale / Costituzione federale
  ["bv", "101"],
  ["cst", "101"],
  ["cst.", "101"],
  ["cost", "101"],
  ["cost.", "101"],
  // === CIVIL LAW ===
  // Zivilgesetzbuch / Code civil / Codice civile
  ["zgb", "210"],
  ["cc", "210"],
  // Obligationenrecht / Code des obligations / Codice delle obbligazioni
  ["or", "220"],
  ["co", "220"],
  // === CRIMINAL LAW ===
  // Strafgesetzbuch / Code penal / Codice penale
  ["stgb", "311.0"],
  ["cp", "311.0"],
  // === PROCEDURAL LAW ===
  // Zivilprozessordnung / Code de procedure civile / Codice di procedura civile
  ["zpo", "272"],
  ["cpc", "272"],
  // Strafprozessordnung / Code de procedure penale / Codice di procedura penale
  ["stpo", "312.0"],
  ["cpp", "312.0"],
  // Schuldbetreibungs- und Konkursgesetz / LP / LEF
  ["schkg", "281.1"],
  ["lp", "281.1"],
  ["lef", "281.1"],
  // === ADMINISTRATIVE LAW ===
  // Verwaltungsverfahrensgesetz / PA
  ["vwvg", "172.021"],
  ["pa", "172.021"],
  // Bundesgerichtsgesetz / LTF
  ["bgg", "173.110"],
  ["ltf", "173.110"],
  // === COMMERCIAL LAW ===
  // Bundesgesetz gegen den unlauteren Wettbewerb / LCD / LCSl
  ["uwg", "241"],
  ["lcd", "241"],
  ["lcsl", "241"],
  // Kartellgesetz / LCart
  ["kg", "251"],
  ["lcart", "251"],
  // === DATA PROTECTION ===
  // Datenschutzgesetz / LPD
  ["dsg", "235.1"],
  ["lpd", "235.1"],
  // === INTELLECTUAL PROPERTY ===
  // Urheberrechtsgesetz / LDA
  ["urg", "231.1"],
  ["lda", "231.1"],
  // Markenschutzgesetz / LPM
  ["mschg", "232.11"],
  ["lpm", "232.11"],
  // === EMPLOYMENT / LABOR ===
  // Arbeitsgesetz / LTr / LL
  ["arg", "822.11"],
  ["ltr", "822.11"],
  ["ll", "822.11"],
  // === TRANSPORT ===
  // Strassenverkehrsgesetz / LCR / LCStr
  ["svg", "741.01"],
  ["lcr", "741.01"],
  ["lcstr", "741.01"],
  // === INSURANCE ===
  // Versicherungsvertragsgesetz / LCA
  ["vvg", "221.229.1"],
  ["lca", "221.229.1"],
  // === PRIVATE INTERNATIONAL LAW ===
  // IPRG / LDIP
  ["iprg", "291"],
  ["ldip", "291"],
  // === ADDITIONAL COMMON ACTS ===
  // Gleichstellungsgesetz / LEg / LPar
  ["glg", "151.1"],
  ["leg", "151.1"],
  ["lpar", "151.1"],
  // Bundesgesetz ber die Mehrwertsteuer / LTVA / LIVA
  ["mwstg", "641.20"],
  ["ltva", "641.20"],
  ["liva", "641.20"],
  // Bundesgesetz ber die direkte Bundessteuer / LIFD
  ["dbg", "642.11"],
  ["lifd", "642.11"],
  // Steuerharmonisierungsgesetz / LHID
  ["sthg", "642.14"],
  ["lhid", "642.14"],
  // Miete (Tenancy) - Part of OR but commonly referenced
  // OR 253ff, no separate SR
  // Bundesgesetz ber Schuldbetreibung und Konkurs (already covered as SchKG)
  // Fusionsgesetz / LFus
  ["fusg", "221.301"],
  ["lfus", "221.301"],
  // GwG / LBA (Anti-Money Laundering)
  ["gwg", "955.0"],
  ["lba", "955.0"],
  // FINMAG
  ["finmag", "956.1"],
  ["lfinma", "956.1"],
  // FIDLEG / LSFin
  ["fidleg", "950.1"],
  ["lsfin", "950.1"],
  // FINIG / LEFin
  ["finig", "954.1"],
  ["lefin", "954.1"]
]);
function lookupSRByAbbreviation(abbreviation) {
  let normalized = abbreviation.toLowerCase().replace(/\.+$/, "");
  return ABBREVIATION_TO_SR.get(normalized);
}

// mcp-servers-src/fedlex-sparql/src/index.ts
var sparqlClient;
function initializeClient() {
  sparqlClient = createFedlexClient({
    timeout: 6e4,
    // 60 seconds for complex queries
    maxRetries: 3,
    retryDelay: 2e3
  }), console.error(`Fedlex SPARQL client initialized - endpoint: ${sparqlClient.getEndpoint()}`);
}
async function lookupStatute(input) {
  let startTime = Date.now();
  try {
    let query, searchType;
    if (/^\d/.test(input.identifier))
      query = buildLookupStatuteQuery(input.identifier, input.language), searchType = "srNumber";
    else {
      let srNumber = lookupSRByAbbreviation(input.identifier);
      srNumber ? (console.error(`Abbreviation "${input.identifier}" resolved to SR ${srNumber} via local map`), query = buildLookupStatuteQuery(srNumber, input.language), searchType = "abbreviation") : (query = buildLookupByAbbreviationQuery(input.identifier, input.language), searchType = "abbreviation");
    }
    let bindings = (await sparqlClient.query(query)).results.bindings;
    if (bindings.length === 0)
      return {
        found: !1,
        searchTimeMs: Date.now() - startTime
      };
    let actGroups = sparqlClient.groupBindings(bindings, "act"), acts = [];
    for (let [actUri, actBindings] of actGroups) {
      let firstBinding = actBindings[0], act = {
        uri: actUri,
        srNumber: sparqlClient.extractValue(firstBinding.srNumber) || "",
        title: sparqlClient.extractMultilingualValue(actBindings, "title"),
        abbreviation: sparqlClient.extractMultilingualValue(actBindings, "abbreviation"),
        actType: sparqlClient.extractValue(firstBinding.actType),
        dateDocument: sparqlClient.extractValue(firstBinding.dateDocument),
        dateInForce: sparqlClient.extractValue(firstBinding.dateInForce),
        status: firstBinding.inForce ? "in_force" : "unknown"
      };
      acts.push(act);
    }
    return {
      found: !0,
      acts,
      searchType,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Lookup statute failed:", error2), error2;
  }
}
async function getArticle(input) {
  let startTime = Date.now();
  try {
    let query;
    input.paragraph ? query = buildGetArticleParagraphQuery(
      input.srNumber,
      input.articleNumber,
      input.paragraph,
      input.language
    ) : query = buildGetArticleQuery(
      input.srNumber,
      input.articleNumber,
      input.language
    );
    let bindings = (await sparqlClient.query(query)).results.bindings;
    if (bindings.length === 0)
      return {
        found: !1,
        searchTimeMs: Date.now() - startTime
      };
    let firstBinding = bindings[0], actInfo = {
      uri: sparqlClient.extractValue(firstBinding.act) || "",
      srNumber: sparqlClient.extractValue(firstBinding.srNumber) || "",
      title: sparqlClient.extractMultilingualValue(bindings, "actTitle")
    }, articleGroups = sparqlClient.groupBindings(bindings, "article"), articles = [];
    for (let [articleUri, articleBindings] of articleGroups) {
      let articleFirst = articleBindings[0], paragraphs = [], paragraphGroups = sparqlClient.groupBindings(articleBindings, "paragraphNum");
      for (let [paragraphNum, paragraphBindings] of paragraphGroups) {
        if (!paragraphNum) continue;
        let letters = [];
        for (let binding of paragraphBindings) {
          let letterLit = sparqlClient.extractValue(binding.letterLit);
          letterLit && letters.push({
            literal: letterLit,
            text: binding.letterText ? { [binding.letterText["xml:lang"] || "de"]: binding.letterText.value } : void 0
          });
        }
        paragraphs.push({
          number: paragraphNum,
          text: sparqlClient.extractMultilingualValue(paragraphBindings, "paragraphText"),
          letters: letters.length > 0 ? letters : void 0
        });
      }
      let article = {
        uri: articleUri,
        number: sparqlClient.extractValue(articleFirst.articleNumber) || "",
        title: sparqlClient.extractMultilingualValue(articleBindings, "articleTitle"),
        text: sparqlClient.extractMultilingualValue(articleBindings, "articleText"),
        paragraphs: paragraphs.length > 0 ? paragraphs : void 0
      };
      articles.push(article);
    }
    return {
      found: !0,
      act: actInfo,
      articles,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Get article failed:", error2), error2;
  }
}
async function searchLegislation(input) {
  let startTime = Date.now();
  try {
    let filters = {
      language: input.language,
      actType: input.actType,
      status: input.status,
      srNumberPrefix: input.srNumberPrefix,
      limit: input.limit || 50,
      offset: input.offset || 0
    }, query, countQuery;
    input.domain && !input.query ? query = buildSearchByDomainQuery(input.domain, input.language, filters.limit) : input.dateFrom || input.dateTo ? query = buildSearchByDateQuery(input.dateFrom, input.dateTo, input.language, filters.limit) : (query = buildSearchQuery(input.query || "", filters), countQuery = buildSearchCountQuery(input.query || "", filters));
    let bindings = (await sparqlClient.query(query)).results.bindings, totalCount = bindings.length;
    if (countQuery) {
      let countResult = await sparqlClient.query(countQuery);
      if (countResult.results.bindings.length > 0) {
        let countValue = sparqlClient.extractValue(countResult.results.bindings[0].count);
        totalCount = countValue ? parseInt(countValue, 10) : bindings.length;
      }
    }
    let acts = bindings.map((binding) => ({
      uri: sparqlClient.extractValue(binding.act) || "",
      srNumber: sparqlClient.extractValue(binding.srNumber) || "",
      title: binding.title ? { [binding.title["xml:lang"] || "de"]: binding.title.value } : {},
      abbreviation: binding.abbreviation ? { [binding.abbreviation["xml:lang"] || "de"]: binding.abbreviation.value } : void 0,
      actType: sparqlClient.extractValue(binding.actType),
      dateInForce: sparqlClient.extractValue(binding.dateInForce)
    })), domainFacets = {};
    for (let act of acts) {
      let prefix = act.srNumber.split(".")[0];
      prefix && LEGAL_DOMAINS[prefix] && (domainFacets[prefix] = (domainFacets[prefix] || 0) + 1);
    }
    return {
      acts,
      totalCount,
      hasMore: (filters.offset || 0) + acts.length < totalCount,
      facets: {
        byDomain: domainFacets
      },
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Search legislation failed:", error2), error2;
  }
}
async function findRelated(input) {
  let startTime = Date.now();
  try {
    let query = buildFindAllRelatedQuery(
      input.srNumber,
      input.relationType,
      input.language,
      input.limit || 50
    ), relatedActs = (await sparqlClient.query(query)).results.bindings.map((binding) => ({
      uri: sparqlClient.extractValue(binding.relatedAct) || "",
      srNumber: sparqlClient.extractValue(binding.relatedSrNumber) || "",
      title: binding.relatedTitle ? { [binding.relatedTitle["xml:lang"] || "de"]: binding.relatedTitle.value } : {},
      relationType: sparqlClient.extractValue(binding.relationType) || "same_domain",
      relationDate: sparqlClient.extractValue(binding.relationDate)
    })), byRelationType = {};
    for (let act of relatedActs) {
      let relType = act.relationType || "unknown";
      byRelationType[relType] = (byRelationType[relType] || 0) + 1;
    }
    let legislativeHistory;
    if (input.includeHistory) {
      let historyQuery = buildLegislativeHistoryQuery(input.srNumber, input.language);
      legislativeHistory = (await sparqlClient.query(historyQuery)).results.bindings.map((binding) => ({
        date: sparqlClient.extractValue(binding.date) || "",
        description: sparqlClient.extractValue(binding.changeDescription)
      }));
    }
    return {
      srNumber: input.srNumber,
      relatedActs,
      byRelationType,
      legislativeHistory,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Find related failed:", error2), error2;
  }
}
async function getMetadata(input) {
  let startTime = Date.now();
  try {
    let [
      metadataResult,
      languagesResult,
      subjectsResult,
      historyResult,
      statusResult,
      structureResult
    ] = await Promise.all([
      sparqlClient.query(buildGetMetadataQuery(input.srNumber, input.language)),
      sparqlClient.query(buildGetLanguagesQuery(input.srNumber)),
      sparqlClient.query(buildGetSubjectsQuery(input.srNumber, input.language)),
      sparqlClient.query(buildGetVersionHistoryQuery(input.srNumber)),
      sparqlClient.query(buildGetLegalStatusQuery(input.srNumber)),
      input.includeStructure ? sparqlClient.query(buildGetStructureQuery(input.srNumber, input.language)) : Promise.resolve({ results: { bindings: [] } })
    ]), metadataBindings = metadataResult.results.bindings;
    if (metadataBindings.length === 0)
      return {
        found: !1,
        searchTimeMs: Date.now() - startTime
      };
    let firstBinding = metadataBindings[0], metadata = {
      uri: sparqlClient.extractValue(firstBinding.act) || "",
      srNumber: sparqlClient.extractValue(firstBinding.srNumber) || "",
      title: sparqlClient.extractMultilingualValue(metadataBindings, "title"),
      abbreviation: sparqlClient.extractMultilingualValue(metadataBindings, "abbreviation"),
      actType: sparqlClient.extractValue(firstBinding.actType),
      dateDocument: sparqlClient.extractValue(firstBinding.dateDocument),
      dateInForce: sparqlClient.extractValue(firstBinding.dateInForce),
      dateAbrogation: sparqlClient.extractValue(firstBinding.dateAbrogation),
      status: "unknown"
    };
    metadata.availableLanguages = languagesResult.results.bindings.map((b) => sparqlClient.extractValue(b.language)).filter((lang) => !!lang);
    let subjects = subjectsResult.results.bindings.map((b) => sparqlClient.extractValue(b.label)).filter((s) => !!s);
    subjects.length > 0 && (metadata.subjects = subjects);
    let versions = historyResult.results.bindings.map((b) => ({
      date: sparqlClient.extractValue(b.versionDate) || "",
      type: sparqlClient.extractValue(b.versionType),
      description: sparqlClient.extractValue(b.changeDescription)
    }));
    if (versions.length > 0 && (metadata.versionHistory = versions), statusResult.results.bindings.length > 0) {
      let statusBinding = statusResult.results.bindings[0], status = sparqlClient.extractValue(statusBinding.status);
      (status === "in_force" || status === "abrogated" || status === "pending") && (metadata.status = status), metadata.abrogatedBy = sparqlClient.extractValue(statusBinding.abrogatedBy);
    }
    input.includeStructure && structureResult.results.bindings.length > 0 && (metadata.structure = structureResult.results.bindings.map((b) => ({
      partNumber: sparqlClient.extractValue(b.partNumber) || "",
      partTitle: sparqlClient.extractValue(b.partTitle),
      partType: sparqlClient.extractValue(b.partType)
    })));
    let domainPrefix = input.srNumber.split(".")[0];
    return LEGAL_DOMAINS[domainPrefix] && (metadata.legalDomain = LEGAL_DOMAINS[domainPrefix]), {
      found: !0,
      metadata,
      searchTimeMs: Date.now() - startTime
    };
  } catch (error2) {
    throw console.error("Get metadata failed:", error2), error2;
  }
}
async function main() {
  initializeClient();
  let server = new Server(
    {
      name: "fedlex-sparql",
      version: "2.0.1"
    },
    {
      capabilities: {
        tools: {}
      }
    }
  );
  server.setRequestHandler(ListToolsRequestSchema, async () => ({
    tools: [
      {
        name: "lookup_statute",
        description: "Look up a Swiss federal legal act by SR number (e.g., '220' for OR) or abbreviation (e.g., 'OR', 'ZGB'). Returns basic information including title, type, and status in multiple languages (DE/FR/IT).",
        inputSchema: {
          type: "object",
          properties: {
            identifier: {
              type: "string",
              description: "SR number (e.g., '220', '210') or abbreviation (e.g., 'OR', 'ZGB', 'StGB')"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for results (de=German, fr=French, it=Italian, rm=Romansh)"
            }
          },
          required: ["identifier"]
        }
      },
      {
        name: "get_article",
        description: "Retrieve a specific article within a Swiss legal act. Returns article text, marginal notes, paragraphs (Abs\xE4tze), and letters (Buchstaben) in structured format.",
        inputSchema: {
          type: "object",
          properties: {
            srNumber: {
              type: "string",
              description: "SR number of the legal act (e.g., '220' for OR)"
            },
            articleNumber: {
              type: "string",
              description: "Article number (e.g., '97', '41', 'Art. 97')"
            },
            paragraph: {
              type: "string",
              description: "Specific paragraph/Absatz number (optional)"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for article text"
            }
          },
          required: ["srNumber", "articleNumber"]
        }
      },
      {
        name: "search_legislation",
        description: "Search across Swiss federal legislation with full-text search and filters. Supports filtering by legal domain, date range, act type, and language.",
        inputSchema: {
          type: "object",
          properties: {
            query: {
              type: "string",
              description: "Full-text search query (searches title and SR number)"
            },
            domain: {
              type: "string",
              enum: ["1", "2", "3", "4", "5", "6", "7", "8", "9"],
              description: "Legal domain filter by SR prefix: 1=State/Constitutional, 2=Private/Civil, 3=Criminal, 4=Education/Culture, 5=Defense, 6=Finance, 7=Public Works/Transport, 8=Health/Labor/Social Security, 9=Economy"
            },
            srNumberPrefix: {
              type: "string",
              description: "Filter by SR number prefix (e.g., '22' for contract law)"
            },
            dateFrom: {
              type: "string",
              format: "date",
              description: "Filter acts in force from this date (ISO 8601: YYYY-MM-DD)"
            },
            dateTo: {
              type: "string",
              format: "date",
              description: "Filter acts in force until this date (ISO 8601: YYYY-MM-DD)"
            },
            actType: {
              type: "array",
              items: { type: "string" },
              description: "Filter by act types (e.g., 'Bundesgesetz', 'Verordnung')"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Language filter for results"
            },
            limit: {
              type: "number",
              minimum: 1,
              maximum: 100,
              default: 50,
              description: "Maximum number of results"
            },
            offset: {
              type: "number",
              minimum: 0,
              default: 0,
              description: "Offset for pagination"
            }
          }
        }
      },
      {
        name: "find_related",
        description: "Find legislation related to a specific act through amendments, citations, references, or shared legal domain. Optionally includes legislative history (consolidation chain).",
        inputSchema: {
          type: "object",
          properties: {
            srNumber: {
              type: "string",
              description: "SR number of the legal act (e.g., '220' for OR)"
            },
            relationType: {
              type: "string",
              enum: [
                "amends",
                "amended_by",
                "cites",
                "cited_by",
                "implements",
                "implemented_by",
                "based_on",
                "same_domain",
                "same_subject"
              ],
              description: "Filter by specific relation type (optional - returns all if not specified)"
            },
            includeHistory: {
              type: "boolean",
              default: !1,
              description: "Include legislative history (consolidation chain)"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for results"
            },
            limit: {
              type: "number",
              minimum: 1,
              maximum: 100,
              default: 50,
              description: "Maximum number of related acts"
            }
          },
          required: ["srNumber"]
        }
      },
      {
        name: "get_metadata",
        description: "Get comprehensive metadata about a legal act including publication info, subjects/keywords, version history, legal status, available languages, and optionally the document structure (table of contents).",
        inputSchema: {
          type: "object",
          properties: {
            srNumber: {
              type: "string",
              description: "SR number of the legal act (e.g., '220' for OR)"
            },
            includeStructure: {
              type: "boolean",
              default: !1,
              description: "Include document structure (table of contents with chapters, sections, articles)"
            },
            language: {
              type: "string",
              enum: ["de", "fr", "it", "rm"],
              description: "Preferred language for metadata text"
            }
          },
          required: ["srNumber"]
        }
      }
    ]
  })), server.setRequestHandler(CallToolRequestSchema, async (request) => {
    let { name, arguments: args } = request.params;
    try {
      if (name === "lookup_statute") {
        let result = await lookupStatute(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "get_article") {
        let result = await getArticle(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "search_legislation") {
        let result = await searchLegislation(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "find_related") {
        let result = await findRelated(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      if (name === "get_metadata") {
        let result = await getMetadata(args);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      }
      throw new Error(`Unknown tool: ${name}`);
    } catch (error2) {
      let errorMessage = error2 instanceof Error ? error2.message : String(error2);
      return console.error(`Tool execution failed: ${name}`, error2), {
        content: [
          {
            type: "text",
            text: JSON.stringify({ error: errorMessage }, null, 2)
          }
        ],
        isError: !0
      };
    }
  });
  let transport = new StdioServerTransport();
  await server.connect(transport), console.error("Fedlex SPARQL MCP server running on stdio");
}
main().catch((error2) => {
  console.error("Fatal error in main():", error2), process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2NvZGVnZW4vc2NvcGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91dGlsLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL25hbWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9ycy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3J1bGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3JlZl9lcnJvci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91cmkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvcmUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2lkLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvY29yZS9yZWYudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91Y3MybGVuZ3RoLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcGF0dGVybi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRJdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS9lcXVhbC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2NvbnN0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zMjAyMC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydHlOYW1lcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3BhdHRlcm5Qcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9vbmVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci90aGVuRWxzZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZm9ybWF0L2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvbWV0YWRhdGEudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kcmFmdDcudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvbiIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvc3JjL2Zvcm1hdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvbGltaXQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy91dGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL1pvZEVycm9yLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvZXJyb3JzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY29yZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3V0aWwuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2V4ZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9kb2MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS92ZXJzaW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvbG9jYWxlcy9lbi5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2lzdHJpZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9hcGkuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS90by1qc29uLXNjaGVtYS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2pzb24tc2NoZW1hLXByb2Nlc3NvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvem9kLWNvbXBhdC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9pc28uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2NvbXBhdC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2Zyb20tanNvbi1zY2hlbWEuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9leHRlcm5hbC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2ludGVyZmFjZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vT3B0aW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3NlcnZlci96b2QtanNvbi1zY2hlbWEtY29tcGF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL3Byb3RvY29sLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvdmFsaWRhdGlvbi9hanYtcHJvdmlkZXIudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9leHBlcmltZW50YWwvdGFza3Mvc2VydmVyLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2hlbHBlcnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zaGFyZWQvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3NwYXJxbC1jbGllbnQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3F1ZXJpZXMvcHJlZml4ZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3F1ZXJpZXMvbG9va3VwLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9xdWVyaWVzL2FydGljbGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9xdWVyaWVzL3NlYXJjaC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvZmVkbGV4LXNwYXJxbC9zcmMvcXVlcmllcy9yZWxhdGVkLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9xdWVyaWVzL21ldGFkYXRhLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9hYmJyZXZpYXRpb24tbWFwLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9mZWRsZXgtc3BhcnFsL3NyYy9pbmRleC50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHRyYW5lb3VzLWNsYXNzXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgX0NvZGVPck5hbWUge1xuICBhYnN0cmFjdCByZWFkb25seSBzdHI6IHN0cmluZ1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG4gIGFic3RyYWN0IHRvU3RyaW5nKCk6IHN0cmluZ1xuICBhYnN0cmFjdCBlbXB0eVN0cigpOiBib29sZWFuXG59XG5cbmV4cG9ydCBjb25zdCBJREVOVElGSUVSID0gL15bYS16JF9dW2EteiRfMC05XSokL2lcblxuZXhwb3J0IGNsYXNzIE5hbWUgZXh0ZW5kcyBfQ29kZU9yTmFtZSB7XG4gIHJlYWRvbmx5IHN0cjogc3RyaW5nXG4gIGNvbnN0cnVjdG9yKHM6IHN0cmluZykge1xuICAgIHN1cGVyKClcbiAgICBpZiAoIUlERU5USUZJRVIudGVzdChzKSkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbmFtZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclwiKVxuICAgIHRoaXMuc3RyID0gc1xuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJcbiAgfVxuXG4gIGVtcHR5U3RyKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHtbdGhpcy5zdHJdOiAxfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBfQ29kZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgcmVhZG9ubHkgX2l0ZW1zOiByZWFkb25seSBDb2RlSXRlbVtdXG4gIHByaXZhdGUgX3N0cj86IHN0cmluZ1xuICBwcml2YXRlIF9uYW1lcz86IFVzZWROYW1lc1xuXG4gIGNvbnN0cnVjdG9yKGNvZGU6IHN0cmluZyB8IHJlYWRvbmx5IENvZGVJdGVtW10pIHtcbiAgICBzdXBlcigpXG4gICAgdGhpcy5faXRlbXMgPSB0eXBlb2YgY29kZSA9PT0gXCJzdHJpbmdcIiA/IFtjb2RlXSA6IGNvZGVcbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuc3RyXG4gIH1cblxuICBlbXB0eVN0cigpOiBib29sZWFuIHtcbiAgICBpZiAodGhpcy5faXRlbXMubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaXRlbSA9IHRoaXMuX2l0ZW1zWzBdXG4gICAgcmV0dXJuIGl0ZW0gPT09IFwiXCIgfHwgaXRlbSA9PT0gJ1wiXCInXG4gIH1cblxuICBnZXQgc3RyKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICh0aGlzLl9zdHIgPz89IHRoaXMuX2l0ZW1zLnJlZHVjZSgoczogc3RyaW5nLCBjOiBDb2RlSXRlbSkgPT4gYCR7c30ke2N9YCwgXCJcIikpXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gKHRoaXMuX25hbWVzID8/PSB0aGlzLl9pdGVtcy5yZWR1Y2UoKG5hbWVzOiBVc2VkTmFtZXMsIGMpID0+IHtcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgTmFtZSkgbmFtZXNbYy5zdHJdID0gKG5hbWVzW2Muc3RyXSB8fCAwKSArIDFcbiAgICAgIHJldHVybiBuYW1lc1xuICAgIH0sIHt9KSlcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBDb2RlSXRlbSA9IE5hbWUgfCBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG5leHBvcnQgdHlwZSBVc2VkTmFtZXMgPSBSZWNvcmQ8c3RyaW5nLCBudW1iZXIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCB0eXBlIENvZGUgPSBfQ29kZSB8IE5hbWVcblxuZXhwb3J0IHR5cGUgU2FmZUV4cHIgPSBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGxcblxuZXhwb3J0IGNvbnN0IG5pbCA9IG5ldyBfQ29kZShcIlwiKVxuXG50eXBlIENvZGVBcmcgPSBTYWZlRXhwciB8IHN0cmluZyB8IHVuZGVmaW5lZFxuXG5leHBvcnQgZnVuY3Rpb24gXyhzdHJzOiBUZW1wbGF0ZVN0cmluZ3NBcnJheSwgLi4uYXJnczogQ29kZUFyZ1tdKTogX0NvZGUge1xuICBjb25zdCBjb2RlOiBDb2RlSXRlbVtdID0gW3N0cnNbMF1dXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgYWRkQ29kZUFyZyhjb2RlLCBhcmdzW2ldKVxuICAgIGNvZGUucHVzaChzdHJzWysraV0pXG4gIH1cbiAgcmV0dXJuIG5ldyBfQ29kZShjb2RlKVxufVxuXG5jb25zdCBwbHVzID0gbmV3IF9Db2RlKFwiK1wiKVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyKHN0cnM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiAoQ29kZUFyZyB8IHN0cmluZ1tdKVtdKTogX0NvZGUge1xuICBjb25zdCBleHByOiBDb2RlSXRlbVtdID0gW3NhZmVTdHJpbmdpZnkoc3Ryc1swXSldXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgZXhwci5wdXNoKHBsdXMpXG4gICAgYWRkQ29kZUFyZyhleHByLCBhcmdzW2ldKVxuICAgIGV4cHIucHVzaChwbHVzLCBzYWZlU3RyaW5naWZ5KHN0cnNbKytpXSkpXG4gIH1cbiAgb3B0aW1pemUoZXhwcilcbiAgcmV0dXJuIG5ldyBfQ29kZShleHByKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkQ29kZUFyZyhjb2RlOiBDb2RlSXRlbVtdLCBhcmc6IENvZGVBcmcgfCBzdHJpbmdbXSk6IHZvaWQge1xuICBpZiAoYXJnIGluc3RhbmNlb2YgX0NvZGUpIGNvZGUucHVzaCguLi5hcmcuX2l0ZW1zKVxuICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBOYW1lKSBjb2RlLnB1c2goYXJnKVxuICBlbHNlIGNvZGUucHVzaChpbnRlcnBvbGF0ZShhcmcpKVxufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZShleHByOiBDb2RlSXRlbVtdKTogdm9pZCB7XG4gIGxldCBpID0gMVxuICB3aGlsZSAoaSA8IGV4cHIubGVuZ3RoIC0gMSkge1xuICAgIGlmIChleHByW2ldID09PSBwbHVzKSB7XG4gICAgICBjb25zdCByZXMgPSBtZXJnZUV4cHJJdGVtcyhleHByW2kgLSAxXSwgZXhwcltpICsgMV0pXG4gICAgICBpZiAocmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXhwci5zcGxpY2UoaSAtIDEsIDMsIHJlcylcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGV4cHJbaSsrXSA9IFwiK1wiXG4gICAgfVxuICAgIGkrK1xuICB9XG59XG5cbmZ1bmN0aW9uIG1lcmdlRXhwckl0ZW1zKGE6IENvZGVJdGVtLCBiOiBDb2RlSXRlbSk6IENvZGVJdGVtIHwgdW5kZWZpbmVkIHtcbiAgaWYgKGIgPT09ICdcIlwiJykgcmV0dXJuIGFcbiAgaWYgKGEgPT09ICdcIlwiJykgcmV0dXJuIGJcbiAgaWYgKHR5cGVvZiBhID09IFwic3RyaW5nXCIpIHtcbiAgICBpZiAoYiBpbnN0YW5jZW9mIE5hbWUgfHwgYVthLmxlbmd0aCAtIDFdICE9PSAnXCInKSByZXR1cm5cbiAgICBpZiAodHlwZW9mIGIgIT0gXCJzdHJpbmdcIikgcmV0dXJuIGAke2Euc2xpY2UoMCwgLTEpfSR7Yn1cImBcbiAgICBpZiAoYlswXSA9PT0gJ1wiJykgcmV0dXJuIGEuc2xpY2UoMCwgLTEpICsgYi5zbGljZSgxKVxuICAgIHJldHVyblxuICB9XG4gIGlmICh0eXBlb2YgYiA9PSBcInN0cmluZ1wiICYmIGJbMF0gPT09ICdcIicgJiYgIShhIGluc3RhbmNlb2YgTmFtZSkpIHJldHVybiBgXCIke2F9JHtiLnNsaWNlKDEpfWBcbiAgcmV0dXJuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdHJDb25jYXQoYzE6IENvZGUsIGMyOiBDb2RlKTogQ29kZSB7XG4gIHJldHVybiBjMi5lbXB0eVN0cigpID8gYzEgOiBjMS5lbXB0eVN0cigpID8gYzIgOiBzdHJgJHtjMX0ke2MyfWBcbn1cblxuLy8gVE9ETyBkbyBub3QgYWxsb3cgYXJyYXlzIGhlcmVcbmZ1bmN0aW9uIGludGVycG9sYXRlKHg/OiBzdHJpbmcgfCBzdHJpbmdbXSB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsKTogU2FmZUV4cHIgfCBzdHJpbmcge1xuICByZXR1cm4gdHlwZW9mIHggPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB4ID09PSBudWxsXG4gICAgPyB4XG4gICAgOiBzYWZlU3RyaW5naWZ5KEFycmF5LmlzQXJyYXkoeCkgPyB4LmpvaW4oXCIsXCIpIDogeClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeSh4OiB1bmtub3duKTogQ29kZSB7XG4gIHJldHVybiBuZXcgX0NvZGUoc2FmZVN0cmluZ2lmeSh4KSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkoeDogdW5rbm93bik6IHN0cmluZyB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh4KVxuICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgXCJcXFxcdTIwMjlcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5KGtleTogQ29kZSB8IHN0cmluZyB8IG51bWJlcik6IENvZGUge1xuICByZXR1cm4gdHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIElERU5USUZJRVIudGVzdChrZXkpID8gbmV3IF9Db2RlKGAuJHtrZXl9YCkgOiBfYFske2tleX1dYFxufVxuXG4vL0RvZXMgYmVzdCBlZmZvcnQgdG8gZm9ybWF0IHRoZSBuYW1lIHByb3Blcmx5XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXNtRXhwb3J0TmFtZShrZXk6IENvZGUgfCBzdHJpbmcgfCBudW1iZXIpOiBDb2RlIHtcbiAgaWYgKHR5cGVvZiBrZXkgPT0gXCJzdHJpbmdcIiAmJiBJREVOVElGSUVSLnRlc3Qoa2V5KSkge1xuICAgIHJldHVybiBuZXcgX0NvZGUoYCR7a2V5fWApXG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBpbnZhbGlkIGV4cG9ydCBuYW1lOiAke2tleX0sIHVzZSBleHBsaWNpdCAkaWQgbmFtZSBtYXBwaW5nYClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlZ2V4cENvZGUocng6IFJlZ0V4cCk6IENvZGUge1xuICByZXR1cm4gbmV3IF9Db2RlKHJ4LnRvU3RyaW5nKCkpXG59XG4iLCAiaW1wb3J0IHtfLCBuaWwsIENvZGUsIE5hbWV9IGZyb20gXCIuL2NvZGVcIlxuXG5pbnRlcmZhY2UgTmFtZUdyb3VwIHtcbiAgcHJlZml4OiBzdHJpbmdcbiAgaW5kZXg6IG51bWJlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIE5hbWVWYWx1ZSB7XG4gIHJlZjogVmFsdWVSZWZlcmVuY2UgLy8gdGhpcyBpcyB0aGUgcmVmZXJlbmNlIHRvIGFueSB2YWx1ZSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBmcm9tIGdlbmVyYXRlZCBjb2RlIHZpYSBgZ2xvYmFsc2AgdmFyIGluIHRoZSBjbG9zdXJlXG4gIGtleT86IHVua25vd24gLy8gYW55IGtleSB0byBpZGVudGlmeSBhIGdsb2JhbCB0byBhdm9pZCBkdXBsaWNhdGVzLCBpZiBub3QgcGFzc2VkIHJlZiBpcyB1c2VkXG4gIGNvZGU/OiBDb2RlIC8vIHRoaXMgaXMgdGhlIGNvZGUgY3JlYXRpbmcgdGhlIHZhbHVlIG5lZWRlZCBmb3Igc3RhbmRhbG9uZSBjb2RlIHdpdF9vdXQgY2xvc3VyZSAtIGNhbiBiZSBhIHByaW1pdGl2ZSB2YWx1ZSwgZnVuY3Rpb24gb3IgaW1wb3J0IChgcmVxdWlyZWApXG59XG5cbmV4cG9ydCB0eXBlIFZhbHVlUmVmZXJlbmNlID0gdW5rbm93biAvLyBwb3NzaWJseSBtYWtlIENvZGVHZW4gcGFyYW1ldGVyaXplZCB0eXBlIG9uIHRoaXMgdHlwZVxuXG5jbGFzcyBWYWx1ZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICByZWFkb25seSB2YWx1ZT86IE5hbWVWYWx1ZVxuICBjb25zdHJ1Y3RvcihuYW1lOiBWYWx1ZVNjb3BlTmFtZSkge1xuICAgIHN1cGVyKGBDb2RlR2VuOiBcImNvZGVcIiBmb3IgJHtuYW1lfSBub3QgZGVmaW5lZGApXG4gICAgdGhpcy52YWx1ZSA9IG5hbWUudmFsdWVcbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NvcGVPcHRpb25zIHtcbiAgcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwYXJlbnQ/OiBTY29wZVxufVxuXG5pbnRlcmZhY2UgVmFsdWVTY29wZU9wdGlvbnMgZXh0ZW5kcyBTY29wZU9wdGlvbnMge1xuICBzY29wZTogU2NvcGVTdG9yZVxuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxufVxuXG5leHBvcnQgdHlwZSBTY29wZVN0b3JlID0gUmVjb3JkPHN0cmluZywgVmFsdWVSZWZlcmVuY2VbXSB8IHVuZGVmaW5lZD5cblxudHlwZSBTY29wZVZhbHVlcyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogTWFwPHVua25vd24sIFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgdHlwZSBTY29wZVZhbHVlU2V0cyA9IHtcbiAgW1ByZWZpeCBpbiBzdHJpbmddPzogU2V0PFZhbHVlU2NvcGVOYW1lPlxufVxuXG5leHBvcnQgZW51bSBVc2VkVmFsdWVTdGF0ZSB7XG4gIFN0YXJ0ZWQsXG4gIENvbXBsZXRlZCxcbn1cblxuZXhwb3J0IHR5cGUgVXNlZFNjb3BlVmFsdWVzID0ge1xuICBbUHJlZml4IGluIHN0cmluZ10/OiBNYXA8VmFsdWVTY29wZU5hbWUsIFVzZWRWYWx1ZVN0YXRlIHwgdW5kZWZpbmVkPlxufVxuXG5leHBvcnQgY29uc3QgdmFyS2luZHMgPSB7XG4gIGNvbnN0OiBuZXcgTmFtZShcImNvbnN0XCIpLFxuICBsZXQ6IG5ldyBOYW1lKFwibGV0XCIpLFxuICB2YXI6IG5ldyBOYW1lKFwidmFyXCIpLFxufVxuXG5leHBvcnQgY2xhc3MgU2NvcGUge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX25hbWVzOiB7W1ByZWZpeCBpbiBzdHJpbmddPzogTmFtZUdyb3VwfSA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfcHJlZml4ZXM/OiBTZXQ8c3RyaW5nPlxuICBwcm90ZWN0ZWQgcmVhZG9ubHkgX3BhcmVudD86IFNjb3BlXG5cbiAgY29uc3RydWN0b3Ioe3ByZWZpeGVzLCBwYXJlbnR9OiBTY29wZU9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuX3ByZWZpeGVzID0gcHJlZml4ZXNcbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnRcbiAgfVxuXG4gIHRvTmFtZShuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gbmFtZU9yUHJlZml4IGluc3RhbmNlb2YgTmFtZSA/IG5hbWVPclByZWZpeCA6IHRoaXMubmFtZShuYW1lT3JQcmVmaXgpXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogTmFtZSB7XG4gICAgcmV0dXJuIG5ldyBOYW1lKHRoaXMuX25ld05hbWUocHJlZml4KSlcbiAgfVxuXG4gIHByb3RlY3RlZCBfbmV3TmFtZShwcmVmaXg6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgY29uc3QgbmcgPSB0aGlzLl9uYW1lc1twcmVmaXhdIHx8IHRoaXMuX25hbWVHcm91cChwcmVmaXgpXG4gICAgcmV0dXJuIGAke3ByZWZpeH0ke25nLmluZGV4Kyt9YFxuICB9XG5cbiAgcHJpdmF0ZSBfbmFtZUdyb3VwKHByZWZpeDogc3RyaW5nKTogTmFtZUdyb3VwIHtcbiAgICBpZiAodGhpcy5fcGFyZW50Py5fcHJlZml4ZXM/LmhhcyhwcmVmaXgpIHx8ICh0aGlzLl9wcmVmaXhlcyAmJiAhdGhpcy5fcHJlZml4ZXMuaGFzKHByZWZpeCkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IHByZWZpeCBcIiR7cHJlZml4fVwiIGlzIG5vdCBhbGxvd2VkIGluIHRoaXMgc2NvcGVgKVxuICAgIH1cbiAgICByZXR1cm4gKHRoaXMuX25hbWVzW3ByZWZpeF0gPSB7cHJlZml4LCBpbmRleDogMH0pXG4gIH1cbn1cblxuaW50ZXJmYWNlIFNjb3BlUGF0aCB7XG4gIHByb3BlcnR5OiBzdHJpbmdcbiAgaXRlbUluZGV4OiBudW1iZXJcbn1cblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGVOYW1lIGV4dGVuZHMgTmFtZSB7XG4gIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nXG4gIHZhbHVlPzogTmFtZVZhbHVlXG4gIHNjb3BlUGF0aD86IENvZGVcblxuICBjb25zdHJ1Y3RvcihwcmVmaXg6IHN0cmluZywgbmFtZVN0cjogc3RyaW5nKSB7XG4gICAgc3VwZXIobmFtZVN0cilcbiAgICB0aGlzLnByZWZpeCA9IHByZWZpeFxuICB9XG5cbiAgc2V0VmFsdWUodmFsdWU6IE5hbWVWYWx1ZSwge3Byb3BlcnR5LCBpdGVtSW5kZXh9OiBTY29wZVBhdGgpOiB2b2lkIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgICB0aGlzLnNjb3BlUGF0aCA9IF9gLiR7bmV3IE5hbWUocHJvcGVydHkpfVske2l0ZW1JbmRleH1dYFxuICB9XG59XG5cbmludGVyZmFjZSBWU09wdGlvbnMgZXh0ZW5kcyBWYWx1ZVNjb3BlT3B0aW9ucyB7XG4gIF9uOiBDb2RlXG59XG5cbmNvbnN0IGxpbmUgPSBfYFxcbmBcblxuZXhwb3J0IGNsYXNzIFZhbHVlU2NvcGUgZXh0ZW5kcyBTY29wZSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlcyA9IHt9XG4gIHByb3RlY3RlZCByZWFkb25seSBfc2NvcGU6IFNjb3BlU3RvcmVcbiAgcmVhZG9ubHkgb3B0czogVlNPcHRpb25zXG5cbiAgY29uc3RydWN0b3Iob3B0czogVmFsdWVTY29wZU9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRzKVxuICAgIHRoaXMuX3Njb3BlID0gb3B0cy5zY29wZVxuICAgIHRoaXMub3B0cyA9IHsuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IGxpbmUgOiBuaWx9XG4gIH1cblxuICBnZXQoKTogU2NvcGVTdG9yZSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njb3BlXG4gIH1cblxuICBuYW1lKHByZWZpeDogc3RyaW5nKTogVmFsdWVTY29wZU5hbWUge1xuICAgIHJldHVybiBuZXcgVmFsdWVTY29wZU5hbWUocHJlZml4LCB0aGlzLl9uZXdOYW1lKHByZWZpeCkpXG4gIH1cblxuICB2YWx1ZShuYW1lT3JQcmVmaXg6IFZhbHVlU2NvcGVOYW1lIHwgc3RyaW5nLCB2YWx1ZTogTmFtZVZhbHVlKTogVmFsdWVTY29wZU5hbWUge1xuICAgIGlmICh2YWx1ZS5yZWYgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogcmVmIG11c3QgYmUgcGFzc2VkIGluIHZhbHVlXCIpXG4gICAgY29uc3QgbmFtZSA9IHRoaXMudG9OYW1lKG5hbWVPclByZWZpeCkgYXMgVmFsdWVTY29wZU5hbWVcbiAgICBjb25zdCB7cHJlZml4fSA9IG5hbWVcbiAgICBjb25zdCB2YWx1ZUtleSA9IHZhbHVlLmtleSA/PyB2YWx1ZS5yZWZcbiAgICBsZXQgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XVxuICAgIGlmICh2cykge1xuICAgICAgY29uc3QgX25hbWUgPSB2cy5nZXQodmFsdWVLZXkpXG4gICAgICBpZiAoX25hbWUpIHJldHVybiBfbmFtZVxuICAgIH0gZWxzZSB7XG4gICAgICB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdID0gbmV3IE1hcCgpXG4gICAgfVxuICAgIHZzLnNldCh2YWx1ZUtleSwgbmFtZSlcblxuICAgIGNvbnN0IHMgPSB0aGlzLl9zY29wZVtwcmVmaXhdIHx8ICh0aGlzLl9zY29wZVtwcmVmaXhdID0gW10pXG4gICAgY29uc3QgaXRlbUluZGV4ID0gcy5sZW5ndGhcbiAgICBzW2l0ZW1JbmRleF0gPSB2YWx1ZS5yZWZcbiAgICBuYW1lLnNldFZhbHVlKHZhbHVlLCB7cHJvcGVydHk6IHByZWZpeCwgaXRlbUluZGV4fSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0VmFsdWUocHJlZml4OiBzdHJpbmcsIGtleU9yUmVmOiB1bmtub3duKTogVmFsdWVTY29wZU5hbWUgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF1cbiAgICBpZiAoIXZzKSByZXR1cm5cbiAgICByZXR1cm4gdnMuZ2V0KGtleU9yUmVmKVxuICB9XG5cbiAgc2NvcGVSZWZzKHNjb3BlTmFtZTogTmFtZSwgdmFsdWVzOiBTY29wZVZhbHVlcyB8IFNjb3BlVmFsdWVTZXRzID0gdGhpcy5fdmFsdWVzKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyh2YWx1ZXMsIChuYW1lOiBWYWx1ZVNjb3BlTmFtZSkgPT4ge1xuICAgICAgaWYgKG5hbWUuc2NvcGVQYXRoID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogbmFtZSBcIiR7bmFtZX1cIiBoYXMgbm8gdmFsdWVgKVxuICAgICAgcmV0dXJuIF9gJHtzY29wZU5hbWV9JHtuYW1lLnNjb3BlUGF0aH1gXG4gICAgfSlcbiAgfVxuXG4gIHNjb3BlQ29kZShcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMgPSB0aGlzLl92YWx1ZXMsXG4gICAgdXNlZFZhbHVlcz86IFVzZWRTY29wZVZhbHVlcyxcbiAgICBnZXRDb2RlPzogKG46IFZhbHVlU2NvcGVOYW1lKSA9PiBDb2RlIHwgdW5kZWZpbmVkXG4gICk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9yZWR1Y2VWYWx1ZXMoXG4gICAgICB2YWx1ZXMsXG4gICAgICAobmFtZTogVmFsdWVTY29wZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWUudmFsdWUgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApXG4gICAgICAgIHJldHVybiBuYW1lLnZhbHVlLmNvZGVcbiAgICAgIH0sXG4gICAgICB1c2VkVmFsdWVzLFxuICAgICAgZ2V0Q29kZVxuICAgIClcbiAgfVxuXG4gIHByaXZhdGUgX3JlZHVjZVZhbHVlcyhcbiAgICB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMsXG4gICAgdmFsdWVDb2RlOiAobjogVmFsdWVTY29wZU5hbWUpID0+IENvZGUgfCB1bmRlZmluZWQsXG4gICAgdXNlZFZhbHVlczogVXNlZFNjb3BlVmFsdWVzID0ge30sXG4gICAgZ2V0Q29kZT86IChuOiBWYWx1ZVNjb3BlTmFtZSkgPT4gQ29kZSB8IHVuZGVmaW5lZFxuICApOiBDb2RlIHtcbiAgICBsZXQgY29kZTogQ29kZSA9IG5pbFxuICAgIGZvciAoY29uc3QgcHJlZml4IGluIHZhbHVlcykge1xuICAgICAgY29uc3QgdnMgPSB2YWx1ZXNbcHJlZml4XVxuICAgICAgaWYgKCF2cykgY29udGludWVcbiAgICAgIGNvbnN0IG5hbWVTZXQgPSAodXNlZFZhbHVlc1twcmVmaXhdID0gdXNlZFZhbHVlc1twcmVmaXhdIHx8IG5ldyBNYXAoKSlcbiAgICAgIHZzLmZvckVhY2goKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSA9PiB7XG4gICAgICAgIGlmIChuYW1lU2V0LmhhcyhuYW1lKSkgcmV0dXJuXG4gICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLlN0YXJ0ZWQpXG4gICAgICAgIGxldCBjID0gdmFsdWVDb2RlKG5hbWUpXG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgY29uc3QgZGVmID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmNvbnN0XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7ZGVmfSAke25hbWV9ID0gJHtjfTske3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSBpZiAoKGMgPSBnZXRDb2RlPy4obmFtZSkpKSB7XG4gICAgICAgICAgY29kZSA9IF9gJHtjb2RlfSR7Y30ke3RoaXMub3B0cy5fbn1gXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IobmFtZSlcbiAgICAgICAgfVxuICAgICAgICBuYW1lU2V0LnNldChuYW1lLCBVc2VkVmFsdWVTdGF0ZS5Db21wbGV0ZWQpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gY29kZVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1Njb3BlVmFsdWVTZXRzLCBOYW1lVmFsdWUsIFZhbHVlU2NvcGUsIFZhbHVlU2NvcGVOYW1lfSBmcm9tIFwiLi9zY29wZVwiXG5pbXBvcnQge18sIG5pbCwgX0NvZGUsIENvZGUsIE5hbWUsIFVzZWROYW1lcywgQ29kZUl0ZW0sIGFkZENvZGVBcmcsIF9Db2RlT3JOYW1lfSBmcm9tIFwiLi9jb2RlXCJcbmltcG9ydCB7U2NvcGUsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbmV4cG9ydCB7Xywgc3RyLCBzdHJDb25jYXQsIG5pbCwgZ2V0UHJvcGVydHksIHN0cmluZ2lmeSwgcmVnZXhwQ29kZSwgTmFtZSwgQ29kZX0gZnJvbSBcIi4vY29kZVwiXG5leHBvcnQge1Njb3BlLCBTY29wZVN0b3JlLCBWYWx1ZVNjb3BlLCBWYWx1ZVNjb3BlTmFtZSwgU2NvcGVWYWx1ZVNldHMsIHZhcktpbmRzfSBmcm9tIFwiLi9zY29wZVwiXG5cbi8vIHR5cGUgZm9yIGV4cHJlc3Npb25zIHRoYXQgY2FuIGJlIHNhZmVseSBpbnNlcnRlZCBpbiBjb2RlIHdpdGhvdXQgcXVvdGVzXG5leHBvcnQgdHlwZSBTYWZlRXhwciA9IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG4vLyB0eXBlIHRoYXQgaXMgZWl0aGVyIENvZGUgb2YgZnVuY3Rpb24gdGhhdCBhZGRzIGNvZGUgdG8gQ29kZUdlbiBpbnN0YW5jZSB1c2luZyBpdHMgbWV0aG9kc1xuZXhwb3J0IHR5cGUgQmxvY2sgPSBDb2RlIHwgKCgpID0+IHZvaWQpXG5cbmV4cG9ydCBjb25zdCBvcGVyYXRvcnMgPSB7XG4gIEdUOiBuZXcgX0NvZGUoXCI+XCIpLFxuICBHVEU6IG5ldyBfQ29kZShcIj49XCIpLFxuICBMVDogbmV3IF9Db2RlKFwiPFwiKSxcbiAgTFRFOiBuZXcgX0NvZGUoXCI8PVwiKSxcbiAgRVE6IG5ldyBfQ29kZShcIj09PVwiKSxcbiAgTkVROiBuZXcgX0NvZGUoXCIhPT1cIiksXG4gIE5PVDogbmV3IF9Db2RlKFwiIVwiKSxcbiAgT1I6IG5ldyBfQ29kZShcInx8XCIpLFxuICBBTkQ6IG5ldyBfQ29kZShcIiYmXCIpLFxuICBBREQ6IG5ldyBfQ29kZShcIitcIiksXG59XG5cbmFic3RyYWN0IGNsYXNzIE5vZGUge1xuICBhYnN0cmFjdCByZWFkb25seSBuYW1lczogVXNlZE5hbWVzXG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgQ2hpbGROb2RlIHwgQ2hpbGROb2RlW10gfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKF9uYW1lczogVXNlZE5hbWVzLCBfY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIDFcbiAgLy8gfVxufVxuXG5jbGFzcyBEZWYgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogTmFtZSxcbiAgICBwcml2YXRlIHJocz86IFNhZmVFeHByXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7ZXM1LCBfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgdmFyS2luZCA9IGVzNSA/IHZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZFxuICAgIGNvbnN0IHJocyA9IHRoaXMucmhzID09PSB1bmRlZmluZWQgPyBcIlwiIDogYCA9ICR7dGhpcy5yaHN9YFxuICAgIHJldHVybiBgJHt2YXJLaW5kfSAke3RoaXMubmFtZX0ke3Joc307YCArIF9uXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFuYW1lc1t0aGlzLm5hbWUuc3RyXSkgcmV0dXJuXG4gICAgaWYgKHRoaXMucmhzKSB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMucmhzIGluc3RhbmNlb2YgX0NvZGVPck5hbWUgPyB0aGlzLnJocy5uYW1lcyA6IHt9XG4gIH1cbn1cblxuY2xhc3MgQXNzaWduIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHJlYWRvbmx5IGxoczogQ29kZSxcbiAgICBwdWJsaWMgcmhzOiBTYWZlRXhwcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNpZGVFZmZlY3RzPzogYm9vbGVhblxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saHN9ID0gJHt0aGlzLnJoc307YCArIF9uXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKHRoaXMubGhzIGluc3RhbmNlb2YgTmFtZSAmJiAhbmFtZXNbdGhpcy5saHMuc3RyXSAmJiAhdGhpcy5zaWRlRWZmZWN0cykgcmV0dXJuXG4gICAgdGhpcy5yaHMgPSBvcHRpbWl6ZUV4cHIodGhpcy5yaHMsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5saHMgaW5zdGFuY2VvZiBOYW1lID8ge30gOiB7Li4udGhpcy5saHMubmFtZXN9XG4gICAgcmV0dXJuIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5yaHMpXG4gIH1cbn1cblxuY2xhc3MgQXNzaWduT3AgZXh0ZW5kcyBBc3NpZ24ge1xuICBjb25zdHJ1Y3RvcihcbiAgICBsaHM6IENvZGUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBvcDogQ29kZSxcbiAgICByaHM6IFNhZmVFeHByLFxuICAgIHNpZGVFZmZlY3RzPzogYm9vbGVhblxuICApIHtcbiAgICBzdXBlcihsaHMsIHJocywgc2lkZUVmZmVjdHMpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYCR7dGhpcy5saHN9ICR7dGhpcy5vcH09ICR7dGhpcy5yaHN9O2AgKyBfblxuICB9XG59XG5cbmNsYXNzIExhYmVsIGV4dGVuZHMgTm9kZSB7XG4gIHJlYWRvbmx5IG5hbWVzOiBVc2VkTmFtZXMgPSB7fVxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBsYWJlbDogTmFtZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxhYmVsfTpgICsgX25cbiAgfVxufVxuXG5jbGFzcyBCcmVhayBleHRlbmRzIE5vZGUge1xuICByZWFkb25seSBuYW1lczogVXNlZE5hbWVzID0ge31cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbGFiZWw/OiBDb2RlKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmxhYmVsID8gYCAke3RoaXMubGFiZWx9YCA6IFwiXCJcbiAgICByZXR1cm4gYGJyZWFrJHtsYWJlbH07YCArIF9uXG4gIH1cbn1cblxuY2xhc3MgVGhyb3cgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgZXJyb3I6IENvZGUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYHRocm93ICR7dGhpcy5lcnJvcn07YCArIF9uXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5lcnJvci5uYW1lc1xuICB9XG59XG5cbmNsYXNzIEFueUNvZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBjb2RlOiBTYWZlRXhwcikge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmNvZGV9O2AgKyBfblxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gYCR7dGhpcy5jb2RlfWAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB7XG4gICAgdGhpcy5jb2RlID0gb3B0aW1pemVFeHByKHRoaXMuY29kZSwgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMuY29kZSBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gdGhpcy5jb2RlLm5hbWVzIDoge31cbiAgfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBQYXJlbnROb2RlIGV4dGVuZHMgTm9kZSB7XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IG5vZGVzOiBDaGlsZE5vZGVbXSA9IFtdKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjb2RlLCBuKSA9PiBjb2RlICsgbi5yZW5kZXIob3B0cyksIFwiXCIpXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IHRoaXMgfCBDaGlsZE5vZGUgfCBDaGlsZE5vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qge25vZGVzfSA9IHRoaXNcbiAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIGNvbnN0IG4gPSBub2Rlc1tpXS5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG4pKSBub2Rlcy5zcGxpY2UoaSwgMSwgLi4ubilcbiAgICAgIGVsc2UgaWYgKG4pIG5vZGVzW2ldID0gblxuICAgICAgZWxzZSBub2Rlcy5zcGxpY2UoaSwgMSlcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzLmxlbmd0aCA+IDAgPyB0aGlzIDogdW5kZWZpbmVkXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qge25vZGVzfSA9IHRoaXNcbiAgICBsZXQgaSA9IG5vZGVzLmxlbmd0aFxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIC8vIGl0ZXJhdGluZyBiYWNrd2FyZHMgaW1wcm92ZXMgMS1wYXNzIG9wdGltaXphdGlvblxuICAgICAgY29uc3QgbiA9IG5vZGVzW2ldXG4gICAgICBpZiAobi5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKSBjb250aW51ZVxuICAgICAgc3VidHJhY3ROYW1lcyhuYW1lcywgbi5uYW1lcylcbiAgICAgIG5vZGVzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWRcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgobmFtZXM6IFVzZWROYW1lcywgbikgPT4gYWRkTmFtZXMobmFtZXMsIG4ubmFtZXMpLCB7fSlcbiAgfVxuXG4gIC8vIGdldCBjb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiB0aGlzLm5vZGVzLnJlZHVjZSgoYywgbikgPT4gYyArIG4uY291bnQsIDEpXG4gIC8vIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgQmxvY2tOb2RlIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBcIntcIiArIG9wdHMuX24gKyBzdXBlci5yZW5kZXIob3B0cykgKyBcIn1cIiArIG9wdHMuX25cbiAgfVxufVxuXG5jbGFzcyBSb290IGV4dGVuZHMgUGFyZW50Tm9kZSB7fVxuXG5jbGFzcyBFbHNlIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImVsc2VcIlxufVxuXG5jbGFzcyBJZiBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJpZlwiXG4gIGVsc2U/OiBJZiB8IEVsc2VcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBjb25kaXRpb246IENvZGUgfCBib29sZWFuLFxuICAgIG5vZGVzPzogQ2hpbGROb2RlW11cbiAgKSB7XG4gICAgc3VwZXIobm9kZXMpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBsZXQgY29kZSA9IGBpZigke3RoaXMuY29uZGl0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuZWxzZSkgY29kZSArPSBcImVsc2UgXCIgKyB0aGlzLmVsc2UucmVuZGVyKG9wdHMpXG4gICAgcmV0dXJuIGNvZGVcbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogSWYgfCBDaGlsZE5vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgc3VwZXIub3B0aW1pemVOb2RlcygpXG4gICAgY29uc3QgY29uZCA9IHRoaXMuY29uZGl0aW9uXG4gICAgaWYgKGNvbmQgPT09IHRydWUpIHJldHVybiB0aGlzLm5vZGVzIC8vIGVsc2UgaXMgaWdub3JlZCBoZXJlXG4gICAgbGV0IGUgPSB0aGlzLmVsc2VcbiAgICBpZiAoZSkge1xuICAgICAgY29uc3QgbnMgPSBlLm9wdGltaXplTm9kZXMoKVxuICAgICAgZSA9IHRoaXMuZWxzZSA9IEFycmF5LmlzQXJyYXkobnMpID8gbmV3IEVsc2UobnMpIDogKG5zIGFzIEVsc2UgfCB1bmRlZmluZWQpXG4gICAgfVxuICAgIGlmIChlKSB7XG4gICAgICBpZiAoY29uZCA9PT0gZmFsc2UpIHJldHVybiBlIGluc3RhbmNlb2YgSWYgPyBlIDogZS5ub2Rlc1xuICAgICAgaWYgKHRoaXMubm9kZXMubGVuZ3RoKSByZXR1cm4gdGhpc1xuICAgICAgcmV0dXJuIG5ldyBJZihub3QoY29uZCksIGUgaW5zdGFuY2VvZiBJZiA/IFtlXSA6IGUubm9kZXMpXG4gICAgfVxuICAgIGlmIChjb25kID09PSBmYWxzZSB8fCAhdGhpcy5ub2Rlcy5sZW5ndGgpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIHRoaXMuZWxzZSA9IHRoaXMuZWxzZT8ub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIGlmICghKHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykgfHwgdGhpcy5lbHNlKSkgcmV0dXJuXG4gICAgdGhpcy5jb25kaXRpb24gPSBvcHRpbWl6ZUV4cHIodGhpcy5jb25kaXRpb24sIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXNcbiAgICBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMuY29uZGl0aW9uKVxuICAgIGlmICh0aGlzLmVsc2UpIGFkZE5hbWVzKG5hbWVzLCB0aGlzLmVsc2UubmFtZXMpXG4gICAgcmV0dXJuIG5hbWVzXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gc3VwZXIuY291bnQgKyAodGhpcy5lbHNlPy5jb3VudCB8fCAwKVxuICAvLyB9XG59XG5cbmFic3RyYWN0IGNsYXNzIEZvciBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmb3JcIlxufVxuXG5jbGFzcyBGb3JMb29wIGV4dGVuZHMgRm9yIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBpdGVyYXRpb246IENvZGUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGZvcigke3RoaXMuaXRlcmF0aW9ufSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKSByZXR1cm5cbiAgICB0aGlzLml0ZXJhdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLml0ZXJhdGlvbiwgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhdGlvbi5uYW1lcylcbiAgfVxufVxuXG5jbGFzcyBGb3JSYW5nZSBleHRlbmRzIEZvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFyS2luZDogTmFtZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5hbWU6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBmcm9tOiBTYWZlRXhwcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRvOiBTYWZlRXhwclxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YXJLaW5kID0gb3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB0aGlzLnZhcktpbmRcbiAgICBjb25zdCB7bmFtZSwgZnJvbSwgdG99ID0gdGhpc1xuICAgIHJldHVybiBgZm9yKCR7dmFyS2luZH0gJHtuYW1lfT0ke2Zyb219OyAke25hbWV9PCR7dG99OyAke25hbWV9KyspYCArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSBhZGRFeHByTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuZnJvbSlcbiAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnRvKVxuICB9XG59XG5cbmNsYXNzIEZvckl0ZXIgZXh0ZW5kcyBGb3Ige1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGxvb3A6IFwib2ZcIiB8IFwiaW5cIixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhcktpbmQ6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBOYW1lLFxuICAgIHByaXZhdGUgaXRlcmFibGU6IENvZGVcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBmb3IoJHt0aGlzLnZhcktpbmR9ICR7dGhpcy5uYW1lfSAke3RoaXMubG9vcH0gJHt0aGlzLml0ZXJhYmxlfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCFzdXBlci5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpKSByZXR1cm5cbiAgICB0aGlzLml0ZXJhYmxlID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmFibGUsIG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiBhZGROYW1lcyhzdXBlci5uYW1lcywgdGhpcy5pdGVyYWJsZS5uYW1lcylcbiAgfVxufVxuXG5jbGFzcyBGdW5jIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImZ1bmNcIlxuICBjb25zdHJ1Y3RvcihcbiAgICBwdWJsaWMgbmFtZTogTmFtZSxcbiAgICBwdWJsaWMgYXJnczogQ29kZSxcbiAgICBwdWJsaWMgYXN5bmM/OiBib29sZWFuXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IF9hc3luYyA9IHRoaXMuYXN5bmMgPyBcImFzeW5jIFwiIDogXCJcIlxuICAgIHJldHVybiBgJHtfYXN5bmN9ZnVuY3Rpb24gJHt0aGlzLm5hbWV9KCR7dGhpcy5hcmdzfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgUmV0dXJuIGV4dGVuZHMgUGFyZW50Tm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJyZXR1cm5cIlxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBcInJldHVybiBcIiArIHN1cGVyLnJlbmRlcihvcHRzKVxuICB9XG59XG5cbmNsYXNzIFRyeSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIGNhdGNoPzogQ2F0Y2hcbiAgZmluYWxseT86IEZpbmFsbHlcblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBsZXQgY29kZSA9IFwidHJ5XCIgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgICBpZiAodGhpcy5jYXRjaCkgY29kZSArPSB0aGlzLmNhdGNoLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmZpbmFsbHkpIGNvZGUgKz0gdGhpcy5maW5hbGx5LnJlbmRlcihvcHRzKVxuICAgIHJldHVybiBjb2RlXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IHRoaXMge1xuICAgIHN1cGVyLm9wdGltaXplTm9kZXMoKVxuICAgIHRoaXMuY2F0Y2g/Lm9wdGltaXplTm9kZXMoKSBhcyBDYXRjaCB8IHVuZGVmaW5lZFxuICAgIHRoaXMuZmluYWxseT8ub3B0aW1pemVOb2RlcygpIGFzIEZpbmFsbHkgfCB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgb3B0aW1pemVOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMge1xuICAgIHN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICB0aGlzLmNhdGNoPy5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpXG4gICAgdGhpcy5maW5hbGx5Py5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIGNvbnN0IG5hbWVzID0gc3VwZXIubmFtZXNcbiAgICBpZiAodGhpcy5jYXRjaCkgYWRkTmFtZXMobmFtZXMsIHRoaXMuY2F0Y2gubmFtZXMpXG4gICAgaWYgKHRoaXMuZmluYWxseSkgYWRkTmFtZXMobmFtZXMsIHRoaXMuZmluYWxseS5uYW1lcylcbiAgICByZXR1cm4gbmFtZXNcbiAgfVxuXG4gIC8vIGdldCBjb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiBzdXBlci5jb3VudCArICh0aGlzLmNhdGNoPy5jb3VudCB8fCAwKSArICh0aGlzLmZpbmFsbHk/LmNvdW50IHx8IDApXG4gIC8vIH1cbn1cblxuY2xhc3MgQ2F0Y2ggZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiY2F0Y2hcIlxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBlcnJvcjogTmFtZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgY2F0Y2goJHt0aGlzLmVycm9yfSlgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgRmluYWxseSBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJmaW5hbGx5XCJcbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiZmluYWxseVwiICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxudHlwZSBTdGFydEJsb2NrTm9kZSA9IElmIHwgRm9yIHwgRnVuYyB8IFJldHVybiB8IFRyeVxuXG50eXBlIExlYWZOb2RlID0gRGVmIHwgQXNzaWduIHwgTGFiZWwgfCBCcmVhayB8IFRocm93IHwgQW55Q29kZVxuXG50eXBlIENoaWxkTm9kZSA9IFN0YXJ0QmxvY2tOb2RlIHwgTGVhZk5vZGVcblxudHlwZSBFbmRCbG9ja05vZGVUeXBlID1cbiAgfCB0eXBlb2YgSWZcbiAgfCB0eXBlb2YgRWxzZVxuICB8IHR5cGVvZiBGb3JcbiAgfCB0eXBlb2YgRnVuY1xuICB8IHR5cGVvZiBSZXR1cm5cbiAgfCB0eXBlb2YgQ2F0Y2hcbiAgfCB0eXBlb2YgRmluYWxseVxuXG50eXBlIENvbnN0YW50cyA9IFJlY29yZDxzdHJpbmcsIFNhZmVFeHByIHwgdW5kZWZpbmVkPlxuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVHZW5PcHRpb25zIHtcbiAgZXM1PzogYm9vbGVhblxuICBsaW5lcz86IGJvb2xlYW5cbiAgb3duUHJvcGVydGllcz86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIENHT3B0aW9ucyBleHRlbmRzIENvZGVHZW5PcHRpb25zIHtcbiAgX246IFwiXFxuXCIgfCBcIlwiXG59XG5cbmV4cG9ydCBjbGFzcyBDb2RlR2VuIHtcbiAgcmVhZG9ubHkgX3Njb3BlOiBTY29wZVxuICByZWFkb25seSBfZXh0U2NvcGU6IFZhbHVlU2NvcGVcbiAgcmVhZG9ubHkgX3ZhbHVlczogU2NvcGVWYWx1ZVNldHMgPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IF9ub2RlczogUGFyZW50Tm9kZVtdXG4gIHByaXZhdGUgcmVhZG9ubHkgX2Jsb2NrU3RhcnRzOiBudW1iZXJbXSA9IFtdXG4gIHByaXZhdGUgcmVhZG9ubHkgX2NvbnN0YW50czogQ29uc3RhbnRzID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBvcHRzOiBDR09wdGlvbnNcblxuICBjb25zdHJ1Y3RvcihleHRTY29wZTogVmFsdWVTY29wZSwgb3B0czogQ29kZUdlbk9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMub3B0cyA9IHsuLi5vcHRzLCBfbjogb3B0cy5saW5lcyA/IFwiXFxuXCIgOiBcIlwifVxuICAgIHRoaXMuX2V4dFNjb3BlID0gZXh0U2NvcGVcbiAgICB0aGlzLl9zY29wZSA9IG5ldyBTY29wZSh7cGFyZW50OiBleHRTY29wZX0pXG4gICAgdGhpcy5fbm9kZXMgPSBbbmV3IFJvb3QoKV1cbiAgfVxuXG4gIHRvU3RyaW5nKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QucmVuZGVyKHRoaXMub3B0cylcbiAgfVxuXG4gIC8vIHJldHVybnMgdW5pcXVlIG5hbWUgaW4gdGhlIGludGVybmFsIHNjb3BlXG4gIG5hbWUocHJlZml4OiBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fc2NvcGUubmFtZShwcmVmaXgpXG4gIH1cblxuICAvLyByZXNlcnZlcyB1bmlxdWUgbmFtZSBpbiB0aGUgZXh0ZXJuYWwgc2NvcGVcbiAgc2NvcGVOYW1lKHByZWZpeDogc3RyaW5nKTogVmFsdWVTY29wZU5hbWUge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5uYW1lKHByZWZpeClcbiAgfVxuXG4gIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZSBhbmQgYXNzaWducyB2YWx1ZSB0byBpdFxuICBzY29wZVZhbHVlKHByZWZpeE9yTmFtZTogVmFsdWVTY29wZU5hbWUgfCBzdHJpbmcsIHZhbHVlOiBOYW1lVmFsdWUpOiBOYW1lIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fZXh0U2NvcGUudmFsdWUocHJlZml4T3JOYW1lLCB2YWx1ZSlcbiAgICBjb25zdCB2cyA9IHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gfHwgKHRoaXMuX3ZhbHVlc1tuYW1lLnByZWZpeF0gPSBuZXcgU2V0KCkpXG4gICAgdnMuYWRkKG5hbWUpXG4gICAgcmV0dXJuIG5hbWVcbiAgfVxuXG4gIGdldFNjb3BlVmFsdWUocHJlZml4OiBzdHJpbmcsIGtleU9yUmVmOiB1bmtub3duKTogVmFsdWVTY29wZU5hbWUgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5nZXRWYWx1ZShwcmVmaXgsIGtleU9yUmVmKVxuICB9XG5cbiAgLy8gcmV0dXJuIGNvZGUgdGhhdCBhc3NpZ25zIHZhbHVlcyBpbiB0aGUgZXh0ZXJuYWwgc2NvcGUgdG8gdGhlIG5hbWVzIHRoYXQgYXJlIHVzZWQgaW50ZXJuYWxseVxuICAvLyAoc2FtZSBuYW1lcyB0aGF0IHdlcmUgcmV0dXJuZWQgYnkgZ2VuLnNjb3BlTmFtZSBvciBnZW4uc2NvcGVWYWx1ZSlcbiAgc2NvcGVSZWZzKHNjb3BlTmFtZTogTmFtZSk6IENvZGUge1xuICAgIHJldHVybiB0aGlzLl9leHRTY29wZS5zY29wZVJlZnMoc2NvcGVOYW1lLCB0aGlzLl92YWx1ZXMpXG4gIH1cblxuICBzY29wZUNvZGUoKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlQ29kZSh0aGlzLl92YWx1ZXMpXG4gIH1cblxuICBwcml2YXRlIF9kZWYoXG4gICAgdmFyS2luZDogTmFtZSxcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgcmhzPzogU2FmZUV4cHIsXG4gICAgY29uc3RhbnQ/OiBib29sZWFuXG4gICk6IE5hbWUge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIGlmIChyaHMgIT09IHVuZGVmaW5lZCAmJiBjb25zdGFudCkgdGhpcy5fY29uc3RhbnRzW25hbWUuc3RyXSA9IHJoc1xuICAgIHRoaXMuX2xlYWZOb2RlKG5ldyBEZWYodmFyS2luZCwgbmFtZSwgcmhzKSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgLy8gYGNvbnN0YCBkZWNsYXJhdGlvbiAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gIGNvbnN0KG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZywgcmhzOiBTYWZlRXhwciwgX2NvbnN0YW50PzogYm9vbGVhbik6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9kZWYodmFyS2luZHMuY29uc3QsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBgbGV0YCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnQgKGB2YXJgIGluIGVzNSBtb2RlKVxuICBsZXQobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLCByaHM/OiBTYWZlRXhwciwgX2NvbnN0YW50PzogYm9vbGVhbik6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9kZWYodmFyS2luZHMubGV0LCBuYW1lT3JQcmVmaXgsIHJocywgX2NvbnN0YW50KVxuICB9XG5cbiAgLy8gYHZhcmAgZGVjbGFyYXRpb24gd2l0aCBvcHRpb25hbCBhc3NpZ25tZW50XG4gIHZhcihuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsIHJocz86IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy52YXIsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBhc3NpZ25tZW50IGNvZGVcbiAgYXNzaWduKGxoczogQ29kZSwgcmhzOiBTYWZlRXhwciwgc2lkZUVmZmVjdHM/OiBib29sZWFuKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ24obGhzLCByaHMsIHNpZGVFZmZlY3RzKSlcbiAgfVxuXG4gIC8vIGArPWAgY29kZVxuICBhZGQobGhzOiBDb2RlLCByaHM6IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBBc3NpZ25PcChsaHMsIG9wZXJhdG9ycy5BREQsIHJocykpXG4gIH1cblxuICAvLyBhcHBlbmRzIHBhc3NlZCBTYWZlRXhwciB0byBjb2RlIG9yIGV4ZWN1dGVzIEJsb2NrXG4gIGNvZGUoYzogQmxvY2sgfCBTYWZlRXhwcik6IENvZGVHZW4ge1xuICAgIGlmICh0eXBlb2YgYyA9PSBcImZ1bmN0aW9uXCIpIGMoKVxuICAgIGVsc2UgaWYgKGMgIT09IG5pbCkgdGhpcy5fbGVhZk5vZGUobmV3IEFueUNvZGUoYykpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIHJldHVybnMgY29kZSBmb3Igb2JqZWN0IGxpdGVyYWwgZm9yIHRoZSBwYXNzZWQgYXJndW1lbnQgbGlzdCBvZiBrZXktdmFsdWUgcGFpcnNcbiAgb2JqZWN0KC4uLmtleVZhbHVlczogW05hbWUgfCBzdHJpbmcsIFNhZmVFeHByIHwgc3RyaW5nXVtdKTogX0NvZGUge1xuICAgIGNvbnN0IGNvZGU6IENvZGVJdGVtW10gPSBbXCJ7XCJdXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Yga2V5VmFsdWVzKSB7XG4gICAgICBpZiAoY29kZS5sZW5ndGggPiAxKSBjb2RlLnB1c2goXCIsXCIpXG4gICAgICBjb2RlLnB1c2goa2V5KVxuICAgICAgaWYgKGtleSAhPT0gdmFsdWUgfHwgdGhpcy5vcHRzLmVzNSkge1xuICAgICAgICBjb2RlLnB1c2goXCI6XCIpXG4gICAgICAgIGFkZENvZGVBcmcoY29kZSwgdmFsdWUpXG4gICAgICB9XG4gICAgfVxuICAgIGNvZGUucHVzaChcIn1cIilcbiAgICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpXG4gIH1cblxuICAvLyBgaWZgIGNsYXVzZSAob3Igc3RhdGVtZW50IGlmIGB0aGVuQm9keWAgYW5kLCBvcHRpb25hbGx5LCBgZWxzZUJvZHlgIGFyZSBwYXNzZWQpXG4gIGlmKGNvbmRpdGlvbjogQ29kZSB8IGJvb2xlYW4sIHRoZW5Cb2R5PzogQmxvY2ssIGVsc2VCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja05vZGUobmV3IElmKGNvbmRpdGlvbikpXG5cbiAgICBpZiAodGhlbkJvZHkgJiYgZWxzZUJvZHkpIHtcbiAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZWxzZSgpLmNvZGUoZWxzZUJvZHkpLmVuZElmKClcbiAgICB9IGVsc2UgaWYgKHRoZW5Cb2R5KSB7XG4gICAgICB0aGlzLmNvZGUodGhlbkJvZHkpLmVuZElmKClcbiAgICB9IGVsc2UgaWYgKGVsc2VCb2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwiZWxzZVwiIGJvZHkgd2l0aG91dCBcInRoZW5cIiBib2R5JylcbiAgICB9XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGBlbHNlIGlmYCBjbGF1c2UgLSBpbnZhbGlkIHdpdGhvdXQgYGlmYCBvciBhZnRlciBgZWxzZWAgY2xhdXNlc1xuICBlbHNlSWYoY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbik6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgSWYoY29uZGl0aW9uKSlcbiAgfVxuXG4gIC8vIGBlbHNlYCBjbGF1c2UgLSBvbmx5IHZhbGlkIGFmdGVyIGBpZmAgb3IgYGVsc2UgaWZgIGNsYXVzZXNcbiAgZWxzZSgpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZWxzZU5vZGUobmV3IEVsc2UoKSlcbiAgfVxuXG4gIC8vIGVuZCBgaWZgIHN0YXRlbWVudCAobmVlZGVkIGlmIGdlbi5pZiB3YXMgdXNlZCBvbmx5IHdpdGggY29uZGl0aW9uKVxuICBlbmRJZigpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKElmLCBFbHNlKVxuICB9XG5cbiAgcHJpdmF0ZSBfZm9yKG5vZGU6IEZvciwgZm9yQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tOb2RlKG5vZGUpXG4gICAgaWYgKGZvckJvZHkpIHRoaXMuY29kZShmb3JCb2R5KS5lbmRGb3IoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBhIGdlbmVyaWMgYGZvcmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYGZvckJvZHlgIGlzIHBhc3NlZClcbiAgZm9yKGl0ZXJhdGlvbjogQ29kZSwgZm9yQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9yTG9vcChpdGVyYXRpb24pLCBmb3JCb2R5KVxuICB9XG5cbiAgLy8gYGZvcmAgc3RhdGVtZW50IGZvciBhIHJhbmdlIG9mIHZhbHVlc1xuICBmb3JSYW5nZShcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgZnJvbTogU2FmZUV4cHIsXG4gICAgdG86IFNhZmVFeHByLFxuICAgIGZvckJvZHk6IChpbmRleDogTmFtZSkgPT4gdm9pZCxcbiAgICB2YXJLaW5kOiBDb2RlID0gdGhpcy5vcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHZhcktpbmRzLmxldFxuICApOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeClcbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JSYW5nZSh2YXJLaW5kLCBuYW1lLCBmcm9tLCB0byksICgpID0+IGZvckJvZHkobmFtZSkpXG4gIH1cblxuICAvLyBgZm9yLW9mYCBzdGF0ZW1lbnQgKGluIGVzNSBtb2RlIHJlcGxhY2Ugd2l0aCBhIG5vcm1hbCBmb3IgbG9vcClcbiAgZm9yT2YoXG4gICAgbmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLFxuICAgIGl0ZXJhYmxlOiBDb2RlLFxuICAgIGZvckJvZHk6IChpdGVtOiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB2YXJLaW5kcy5jb25zdFxuICApOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5fc2NvcGUudG9OYW1lKG5hbWVPclByZWZpeClcbiAgICBpZiAodGhpcy5vcHRzLmVzNSkge1xuICAgICAgY29uc3QgYXJyID0gaXRlcmFibGUgaW5zdGFuY2VvZiBOYW1lID8gaXRlcmFibGUgOiB0aGlzLnZhcihcIl9hcnJcIiwgaXRlcmFibGUpXG4gICAgICByZXR1cm4gdGhpcy5mb3JSYW5nZShcIl9pXCIsIDAsIF9gJHthcnJ9Lmxlbmd0aGAsIChpKSA9PiB7XG4gICAgICAgIHRoaXMudmFyKG5hbWUsIF9gJHthcnJ9WyR7aX1dYClcbiAgICAgICAgZm9yQm9keShuYW1lKVxuICAgICAgfSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcIm9mXCIsIHZhcktpbmQsIG5hbWUsIGl0ZXJhYmxlKSwgKCkgPT4gZm9yQm9keShuYW1lKSlcbiAgfVxuXG4gIC8vIGBmb3ItaW5gIHN0YXRlbWVudC5cbiAgLy8gV2l0aCBvcHRpb24gYG93blByb3BlcnRpZXNgIHJlcGxhY2VkIHdpdGggYSBgZm9yLW9mYCBsb29wIGZvciBvYmplY3Qga2V5c1xuICBmb3JJbihcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgb2JqOiBDb2RlLFxuICAgIGZvckJvZHk6IChpdGVtOiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB0aGlzLm9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdmFyS2luZHMuY29uc3RcbiAgKTogQ29kZUdlbiB7XG4gICAgaWYgKHRoaXMub3B0cy5vd25Qcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm4gdGhpcy5mb3JPZihuYW1lT3JQcmVmaXgsIF9gT2JqZWN0LmtleXMoJHtvYmp9KWAsIGZvckJvZHkpXG4gICAgfVxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvckl0ZXIoXCJpblwiLCB2YXJLaW5kLCBuYW1lLCBvYmopLCAoKSA9PiBmb3JCb2R5KG5hbWUpKVxuICB9XG5cbiAgLy8gZW5kIGBmb3JgIGxvb3BcbiAgZW5kRm9yKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRm9yKVxuICB9XG5cbiAgLy8gYGxhYmVsYCBzdGF0ZW1lbnRcbiAgbGFiZWwobGFiZWw6IE5hbWUpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IExhYmVsKGxhYmVsKSlcbiAgfVxuXG4gIC8vIGBicmVha2Agc3RhdGVtZW50XG4gIGJyZWFrKGxhYmVsPzogQ29kZSk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgQnJlYWsobGFiZWwpKVxuICB9XG5cbiAgLy8gYHJldHVybmAgc3RhdGVtZW50XG4gIHJldHVybih2YWx1ZTogQmxvY2sgfCBTYWZlRXhwcik6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5vZGUgPSBuZXcgUmV0dXJuKClcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICB0aGlzLmNvZGUodmFsdWUpXG4gICAgaWYgKG5vZGUubm9kZXMubGVuZ3RoICE9PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ0NvZGVHZW46IFwicmV0dXJuXCIgc2hvdWxkIGhhdmUgb25lIG5vZGUnKVxuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoUmV0dXJuKVxuICB9XG5cbiAgLy8gYHRyeWAgc3RhdGVtZW50XG4gIHRyeSh0cnlCb2R5OiBCbG9jaywgY2F0Y2hDb2RlPzogKGU6IE5hbWUpID0+IHZvaWQsIGZpbmFsbHlDb2RlPzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICBpZiAoIWNhdGNoQ29kZSAmJiAhZmluYWxseUNvZGUpIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJ0cnlcIiB3aXRob3V0IFwiY2F0Y2hcIiBhbmQgXCJmaW5hbGx5XCInKVxuICAgIGNvbnN0IG5vZGUgPSBuZXcgVHJ5KClcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICB0aGlzLmNvZGUodHJ5Qm9keSlcbiAgICBpZiAoY2F0Y2hDb2RlKSB7XG4gICAgICBjb25zdCBlcnJvciA9IHRoaXMubmFtZShcImVcIilcbiAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5jYXRjaCA9IG5ldyBDYXRjaChlcnJvcilcbiAgICAgIGNhdGNoQ29kZShlcnJvcilcbiAgICB9XG4gICAgaWYgKGZpbmFsbHlDb2RlKSB7XG4gICAgICB0aGlzLl9jdXJyTm9kZSA9IG5vZGUuZmluYWxseSA9IG5ldyBGaW5hbGx5KClcbiAgICAgIHRoaXMuY29kZShmaW5hbGx5Q29kZSlcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShDYXRjaCwgRmluYWxseSlcbiAgfVxuXG4gIC8vIGB0aHJvd2Agc3RhdGVtZW50XG4gIHRocm93KGVycm9yOiBDb2RlKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBUaHJvdyhlcnJvcikpXG4gIH1cblxuICAvLyBzdGFydCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICBibG9jayhib2R5PzogQmxvY2ssIG5vZGVDb3VudD86IG51bWJlcik6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrU3RhcnRzLnB1c2godGhpcy5fbm9kZXMubGVuZ3RoKVxuICAgIGlmIChib2R5KSB0aGlzLmNvZGUoYm9keSkuZW5kQmxvY2sobm9kZUNvdW50KVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBlbmQgdGhlIGN1cnJlbnQgc2VsZi1iYWxhbmNpbmcgYmxvY2tcbiAgZW5kQmxvY2sobm9kZUNvdW50PzogbnVtYmVyKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbGVuID0gdGhpcy5fYmxvY2tTdGFydHMucG9wKClcbiAgICBpZiAobGVuID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIkNvZGVHZW46IG5vdCBpbiBzZWxmLWJhbGFuY2luZyBibG9ja1wiKVxuICAgIGNvbnN0IHRvQ2xvc2UgPSB0aGlzLl9ub2Rlcy5sZW5ndGggLSBsZW5cbiAgICBpZiAodG9DbG9zZSA8IDAgfHwgKG5vZGVDb3VudCAhPT0gdW5kZWZpbmVkICYmIHRvQ2xvc2UgIT09IG5vZGVDb3VudCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogd3JvbmcgbnVtYmVyIG9mIG5vZGVzOiAke3RvQ2xvc2V9IHZzICR7bm9kZUNvdW50fSBleHBlY3RlZGApXG4gICAgfVxuICAgIHRoaXMuX25vZGVzLmxlbmd0aCA9IGxlblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBgZnVuY3Rpb25gIGhlYWRpbmcgKG9yIGRlZmluaXRpb24gaWYgZnVuY0JvZHkgaXMgcGFzc2VkKVxuICBmdW5jKG5hbWU6IE5hbWUsIGFyZ3M6IENvZGUgPSBuaWwsIGFzeW5jPzogYm9vbGVhbiwgZnVuY0JvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgRnVuYyhuYW1lLCBhcmdzLCBhc3luYykpXG4gICAgaWYgKGZ1bmNCb2R5KSB0aGlzLmNvZGUoZnVuY0JvZHkpLmVuZEZ1bmMoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBlbmQgZnVuY3Rpb24gZGVmaW5pdGlvblxuICBlbmRGdW5jKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoRnVuYylcbiAgfVxuXG4gIG9wdGltaXplKG4gPSAxKTogdm9pZCB7XG4gICAgd2hpbGUgKG4tLSA+IDApIHtcbiAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOb2RlcygpXG4gICAgICB0aGlzLl9yb290Lm9wdGltaXplTmFtZXModGhpcy5fcm9vdC5uYW1lcywgdGhpcy5fY29uc3RhbnRzKVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgX2xlYWZOb2RlKG5vZGU6IExlYWZOb2RlKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fY3Vyck5vZGUubm9kZXMucHVzaChub2RlKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIF9ibG9ja05vZGUobm9kZTogU3RhcnRCbG9ja05vZGUpOiB2b2lkIHtcbiAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpXG4gICAgdGhpcy5fbm9kZXMucHVzaChub2RlKVxuICB9XG5cbiAgcHJpdmF0ZSBfZW5kQmxvY2tOb2RlKE4xOiBFbmRCbG9ja05vZGVUeXBlLCBOMj86IEVuZEJsb2NrTm9kZVR5cGUpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBuID0gdGhpcy5fY3Vyck5vZGVcbiAgICBpZiAobiBpbnN0YW5jZW9mIE4xIHx8IChOMiAmJiBuIGluc3RhbmNlb2YgTjIpKSB7XG4gICAgICB0aGlzLl9ub2Rlcy5wb3AoKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBub3QgaW4gYmxvY2sgXCIke04yID8gYCR7TjEua2luZH0vJHtOMi5raW5kfWAgOiBOMS5raW5kfVwiYClcbiAgfVxuXG4gIHByaXZhdGUgX2Vsc2VOb2RlKG5vZGU6IElmIHwgRWxzZSk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZVxuICAgIGlmICghKG4gaW5zdGFuY2VvZiBJZikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgd2l0aG91dCBcImlmXCInKVxuICAgIH1cbiAgICB0aGlzLl9jdXJyTm9kZSA9IG4uZWxzZSA9IG5vZGVcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX3Jvb3QoKTogUm9vdCB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGVzWzBdIGFzIFJvb3RcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IF9jdXJyTm9kZSgpOiBQYXJlbnROb2RlIHtcbiAgICBjb25zdCBucyA9IHRoaXMuX25vZGVzXG4gICAgcmV0dXJuIG5zW25zLmxlbmd0aCAtIDFdXG4gIH1cblxuICBwcml2YXRlIHNldCBfY3Vyck5vZGUobm9kZTogUGFyZW50Tm9kZSkge1xuICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXNcbiAgICBuc1tucy5sZW5ndGggLSAxXSA9IG5vZGVcbiAgfVxuXG4gIC8vIGdldCBub2RlQ291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gdGhpcy5fcm9vdC5jb3VudFxuICAvLyB9XG59XG5cbmZ1bmN0aW9uIGFkZE5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGZyb206IFVzZWROYW1lcyk6IFVzZWROYW1lcyB7XG4gIGZvciAoY29uc3QgbiBpbiBmcm9tKSBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSArIChmcm9tW25dIHx8IDApXG4gIHJldHVybiBuYW1lc1xufVxuXG5mdW5jdGlvbiBhZGRFeHByTmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogU2FmZUV4cHIpOiBVc2VkTmFtZXMge1xuICByZXR1cm4gZnJvbSBpbnN0YW5jZW9mIF9Db2RlT3JOYW1lID8gYWRkTmFtZXMobmFtZXMsIGZyb20ubmFtZXMpIDogbmFtZXNcbn1cblxuZnVuY3Rpb24gb3B0aW1pemVFeHByPFQgZXh0ZW5kcyBTYWZlRXhwciB8IENvZGU+KGV4cHI6IFQsIG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogVFxuZnVuY3Rpb24gb3B0aW1pemVFeHByKGV4cHI6IFNhZmVFeHByLCBuYW1lczogVXNlZE5hbWVzLCBjb25zdGFudHM6IENvbnN0YW50cyk6IFNhZmVFeHByIHtcbiAgaWYgKGV4cHIgaW5zdGFuY2VvZiBOYW1lKSByZXR1cm4gcmVwbGFjZU5hbWUoZXhwcilcbiAgaWYgKCFjYW5PcHRpbWl6ZShleHByKSkgcmV0dXJuIGV4cHJcbiAgcmV0dXJuIG5ldyBfQ29kZShcbiAgICBleHByLl9pdGVtcy5yZWR1Y2UoKGl0ZW1zOiBDb2RlSXRlbVtdLCBjOiBTYWZlRXhwciB8IHN0cmluZykgPT4ge1xuICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKSBjID0gcmVwbGFjZU5hbWUoYylcbiAgICAgIGlmIChjIGluc3RhbmNlb2YgX0NvZGUpIGl0ZW1zLnB1c2goLi4uYy5faXRlbXMpXG4gICAgICBlbHNlIGl0ZW1zLnB1c2goYylcbiAgICAgIHJldHVybiBpdGVtc1xuICAgIH0sIFtdKVxuICApXG5cbiAgZnVuY3Rpb24gcmVwbGFjZU5hbWUobjogTmFtZSk6IFNhZmVFeHByIHtcbiAgICBjb25zdCBjID0gY29uc3RhbnRzW24uc3RyXVxuICAgIGlmIChjID09PSB1bmRlZmluZWQgfHwgbmFtZXNbbi5zdHJdICE9PSAxKSByZXR1cm4gblxuICAgIGRlbGV0ZSBuYW1lc1tuLnN0cl1cbiAgICByZXR1cm4gY1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuT3B0aW1pemUoZTogU2FmZUV4cHIpOiBlIGlzIF9Db2RlIHtcbiAgICByZXR1cm4gKFxuICAgICAgZSBpbnN0YW5jZW9mIF9Db2RlICYmXG4gICAgICBlLl9pdGVtcy5zb21lKFxuICAgICAgICAoYykgPT4gYyBpbnN0YW5jZW9mIE5hbWUgJiYgbmFtZXNbYy5zdHJdID09PSAxICYmIGNvbnN0YW50c1tjLnN0cl0gIT09IHVuZGVmaW5lZFxuICAgICAgKVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJ0cmFjdE5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGZyb206IFVzZWROYW1lcyk6IHZvaWQge1xuICBmb3IgKGNvbnN0IG4gaW4gZnJvbSkgbmFtZXNbbl0gPSAobmFtZXNbbl0gfHwgMCkgLSAoZnJvbVtuXSB8fCAwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gbm90PFQgZXh0ZW5kcyBDb2RlIHwgU2FmZUV4cHI+KHg6IFQpOiBUXG5leHBvcnQgZnVuY3Rpb24gbm90KHg6IENvZGUgfCBTYWZlRXhwcik6IENvZGUgfCBTYWZlRXhwciB7XG4gIHJldHVybiB0eXBlb2YgeCA9PSBcImJvb2xlYW5cIiB8fCB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHggPT09IG51bGwgPyAheCA6IF9gISR7cGFyKHgpfWBcbn1cblxuY29uc3QgYW5kQ29kZSA9IG1hcHBlbmQob3BlcmF0b3JzLkFORClcblxuLy8gYm9vbGVhbiBBTkQgKCYmKSBleHByZXNzaW9uIHdpdGggdGhlIHBhc3NlZCBhcmd1bWVudHNcbmV4cG9ydCBmdW5jdGlvbiBhbmQoLi4uYXJnczogQ29kZVtdKTogQ29kZSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZShhbmRDb2RlKVxufVxuXG5jb25zdCBvckNvZGUgPSBtYXBwZW5kKG9wZXJhdG9ycy5PUilcblxuLy8gYm9vbGVhbiBPUiAofHwpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIG9yKC4uLmFyZ3M6IENvZGVbXSk6IENvZGUge1xuICByZXR1cm4gYXJncy5yZWR1Y2Uob3JDb2RlKVxufVxuXG50eXBlIE1BcHBlbmQgPSAoeDogQ29kZSwgeTogQ29kZSkgPT4gQ29kZVxuXG5mdW5jdGlvbiBtYXBwZW5kKG9wOiBDb2RlKTogTUFwcGVuZCB7XG4gIHJldHVybiAoeCwgeSkgPT4gKHggPT09IG5pbCA/IHkgOiB5ID09PSBuaWwgPyB4IDogX2Ake3Bhcih4KX0gJHtvcH0gJHtwYXIoeSl9YClcbn1cblxuZnVuY3Rpb24gcGFyKHg6IENvZGUpOiBDb2RlIHtcbiAgcmV0dXJuIHggaW5zdGFuY2VvZiBOYW1lID8geCA6IF9gKCR7eH0pYFxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWEsIEV2YWx1YXRlZFByb3BlcnRpZXMsIEV2YWx1YXRlZEl0ZW1zfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLlwiXG5pbXBvcnQge18sIGdldFByb3BlcnR5LCBDb2RlLCBOYW1lLCBDb2RlR2VufSBmcm9tIFwiLi9jb2RlZ2VuXCJcbmltcG9ydCB7X0NvZGV9IGZyb20gXCIuL2NvZGVnZW4vY29kZVwiXG5pbXBvcnQgdHlwZSB7UnVsZSwgVmFsaWRhdGlvblJ1bGVzfSBmcm9tIFwiLi9ydWxlc1wiXG5cbi8vIFRPRE8gcmVmYWN0b3IgdG8gdXNlIFNldFxuZXhwb3J0IGZ1bmN0aW9uIHRvSGFzaDxUIGV4dGVuZHMgc3RyaW5nID0gc3RyaW5nPihhcnI6IFRbXSk6IHtbSyBpbiBUXT86IHRydWV9IHtcbiAgY29uc3QgaGFzaDoge1tLIGluIFRdPzogdHJ1ZX0gPSB7fVxuICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSBoYXNoW2l0ZW1dID0gdHJ1ZVxuICByZXR1cm4gaGFzaFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWx3YXlzVmFsaWRTY2hlbWEoaXQ6IFNjaGVtYUN4dCwgc2NoZW1hOiBBbnlTY2hlbWEpOiBib29sZWFuIHwgdm9pZCB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gc2NoZW1hXG4gIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWVcbiAgY2hlY2tVbmtub3duUnVsZXMoaXQsIHNjaGVtYSlcbiAgcmV0dXJuICFzY2hlbWFIYXNSdWxlcyhzY2hlbWEsIGl0LnNlbGYuUlVMRVMuYWxsKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tVbmtub3duUnVsZXMoaXQ6IFNjaGVtYUN4dCwgc2NoZW1hOiBBbnlTY2hlbWEgPSBpdC5zY2hlbWEpOiB2b2lkIHtcbiAgY29uc3Qge29wdHMsIHNlbGZ9ID0gaXRcbiAgaWYgKCFvcHRzLnN0cmljdFNjaGVtYSkgcmV0dXJuXG4gIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIikgcmV0dXJuXG4gIGNvbnN0IHJ1bGVzID0gc2VsZi5SVUxFUy5rZXl3b3Jkc1xuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoIXJ1bGVzW2tleV0pIGNoZWNrU3RyaWN0TW9kZShpdCwgYHVua25vd24ga2V5d29yZDogXCIke2tleX1cImApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzKFxuICBzY2hlbWE6IEFueVNjaGVtYSxcbiAgcnVsZXM6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFuIHwgUnVsZX1cbik6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuICFzY2hlbWFcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSBpZiAocnVsZXNba2V5XSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWE6IEFueVNjaGVtYSwgUlVMRVM6IFZhbGlkYXRpb25SdWxlcyk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuICFzY2hlbWFcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSBpZiAoa2V5ICE9PSBcIiRyZWZcIiAmJiBSVUxFUy5hbGxba2V5XSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFSZWZPclZhbChcbiAge3RvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aH06IFNjaGVtYU9iakN4dCxcbiAgc2NoZW1hOiB1bmtub3duLFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gICRkYXRhPzogc3RyaW5nIHwgZmFsc2Vcbik6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHtcbiAgaWYgKCEkZGF0YSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHNjaGVtYVxuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIpIHJldHVybiBfYCR7c2NoZW1hfWBcbiAgfVxuICByZXR1cm4gX2Ake3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9JHtnZXRQcm9wZXJ0eShrZXl3b3JkKX1gXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUZyYWdtZW50KHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHVuZXNjYXBlSnNvblBvaW50ZXIoZGVjb2RlVVJJQ29tcG9uZW50KHN0cikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVGcmFnbWVudChzdHI6IHN0cmluZyB8IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoZXNjYXBlSnNvblBvaW50ZXIoc3RyKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUpzb25Qb2ludGVyKHN0cjogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgaWYgKHR5cGVvZiBzdHIgPT0gXCJudW1iZXJcIikgcmV0dXJuIGAke3N0cn1gXG4gIHJldHVybiBzdHIucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcLy9nLCBcIn4xXCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bmVzY2FwZUpzb25Qb2ludGVyKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+MS9nLCBcIi9cIikucmVwbGFjZSgvfjAvZywgXCJ+XCIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlYWNoSXRlbTxUPih4czogVCB8IFRbXSwgZjogKHg6IFQpID0+IHZvaWQpOiB2b2lkIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgZm9yIChjb25zdCB4IG9mIHhzKSBmKHgpXG4gIH0gZWxzZSB7XG4gICAgZih4cylcbiAgfVxufVxuXG50eXBlIFNvbWVFdmFsdWF0ZWQgPSBFdmFsdWF0ZWRQcm9wZXJ0aWVzIHwgRXZhbHVhdGVkSXRlbXNcblxudHlwZSBNZXJnZUV2YWx1YXRlZEZ1bmM8VCBleHRlbmRzIFNvbWVFdmFsdWF0ZWQ+ID0gKFxuICBnZW46IENvZGVHZW4sXG4gIGZyb206IE5hbWUgfCBULFxuICB0bzogTmFtZSB8IEV4Y2x1ZGU8VCwgdHJ1ZT4gfCB1bmRlZmluZWQsXG4gIHRvTmFtZT86IHR5cGVvZiBOYW1lXG4pID0+IE5hbWUgfCBUXG5cbmludGVyZmFjZSBNYWtlTWVyZ2VGdW5jQXJnczxUIGV4dGVuZHMgU29tZUV2YWx1YXRlZD4ge1xuICBtZXJnZU5hbWVzOiAoZ2VuOiBDb2RlR2VuLCBmcm9tOiBOYW1lLCB0bzogTmFtZSkgPT4gdm9pZFxuICBtZXJnZVRvTmFtZTogKGdlbjogQ29kZUdlbiwgZnJvbTogVCwgdG86IE5hbWUpID0+IHZvaWRcbiAgbWVyZ2VWYWx1ZXM6IChmcm9tOiBULCB0bzogRXhjbHVkZTxULCB0cnVlPikgPT4gVFxuICByZXN1bHRUb05hbWU6IChnZW46IENvZGVHZW4sIHJlcz86IFQpID0+IE5hbWVcbn1cblxuZnVuY3Rpb24gbWFrZU1lcmdlRXZhbHVhdGVkPFQgZXh0ZW5kcyBTb21lRXZhbHVhdGVkPih7XG4gIG1lcmdlTmFtZXMsXG4gIG1lcmdlVG9OYW1lLFxuICBtZXJnZVZhbHVlcyxcbiAgcmVzdWx0VG9OYW1lLFxufTogTWFrZU1lcmdlRnVuY0FyZ3M8VD4pOiBNZXJnZUV2YWx1YXRlZEZ1bmM8VD4ge1xuICByZXR1cm4gKGdlbiwgZnJvbSwgdG8sIHRvTmFtZSkgPT4ge1xuICAgIGNvbnN0IHJlcyA9XG4gICAgICB0byA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gZnJvbVxuICAgICAgICA6IHRvIGluc3RhbmNlb2YgTmFtZVxuICAgICAgICA/IChmcm9tIGluc3RhbmNlb2YgTmFtZSA/IG1lcmdlTmFtZXMoZ2VuLCBmcm9tLCB0bykgOiBtZXJnZVRvTmFtZShnZW4sIGZyb20sIHRvKSwgdG8pXG4gICAgICAgIDogZnJvbSBpbnN0YW5jZW9mIE5hbWVcbiAgICAgICAgPyAobWVyZ2VUb05hbWUoZ2VuLCB0bywgZnJvbSksIGZyb20pXG4gICAgICAgIDogbWVyZ2VWYWx1ZXMoZnJvbSwgdG8pXG4gICAgcmV0dXJuIHRvTmFtZSA9PT0gTmFtZSAmJiAhKHJlcyBpbnN0YW5jZW9mIE5hbWUpID8gcmVzdWx0VG9OYW1lKGdlbiwgcmVzKSA6IHJlc1xuICB9XG59XG5cbmludGVyZmFjZSBNZXJnZUV2YWx1YXRlZCB7XG4gIHByb3BzOiBNZXJnZUV2YWx1YXRlZEZ1bmM8RXZhbHVhdGVkUHJvcGVydGllcz5cbiAgaXRlbXM6IE1lcmdlRXZhbHVhdGVkRnVuYzxFdmFsdWF0ZWRJdGVtcz5cbn1cblxuZXhwb3J0IGNvbnN0IG1lcmdlRXZhbHVhdGVkOiBNZXJnZUV2YWx1YXRlZCA9IHtcbiAgcHJvcHM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5pZihcbiAgICAgICAgICBfYCR7ZnJvbX0gPT09IHRydWVgLFxuICAgICAgICAgICgpID0+IGdlbi5hc3NpZ24odG8sIHRydWUpLFxuICAgICAgICAgICgpID0+IGdlbi5hc3NpZ24odG8sIF9gJHt0b30gfHwge31gKS5jb2RlKF9gT2JqZWN0LmFzc2lnbigke3RvfSwgJHtmcm9tfSlgKVxuICAgICAgICApXG4gICAgICB9KSxcbiAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZWAsICgpID0+IHtcbiAgICAgICAgaWYgKGZyb20gPT09IHRydWUpIHtcbiAgICAgICAgICBnZW4uYXNzaWduKHRvLCB0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbi5hc3NpZ24odG8sIF9gJHt0b30gfHwge31gKVxuICAgICAgICAgIHNldEV2YWx1YXRlZChnZW4sIHRvLCBmcm9tKVxuICAgICAgICB9XG4gICAgICB9KSxcbiAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiB7Li4uZnJvbSwgLi4udG99KSxcbiAgICByZXN1bHRUb05hbWU6IGV2YWx1YXRlZFByb3BzVG9OYW1lLFxuICB9KSxcbiAgaXRlbXM6IG1ha2VNZXJnZUV2YWx1YXRlZCh7XG4gICAgbWVyZ2VOYW1lczogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZSAmJiAke2Zyb219ICE9PSB1bmRlZmluZWRgLCAoKSA9PlxuICAgICAgICBnZW4uYXNzaWduKHRvLCBfYCR7ZnJvbX0gPT09IHRydWUgPyB0cnVlIDogJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YClcbiAgICAgICksXG4gICAgbWVyZ2VUb05hbWU6IChnZW4sIGZyb20sIHRvKSA9PlxuICAgICAgZ2VuLmlmKF9gJHt0b30gIT09IHRydWVgLCAoKSA9PlxuICAgICAgICBnZW4uYXNzaWduKHRvLCBmcm9tID09PSB0cnVlID8gdHJ1ZSA6IF9gJHt0b30gPiAke2Zyb219ID8gJHt0b30gOiAke2Zyb219YClcbiAgICAgICksXG4gICAgbWVyZ2VWYWx1ZXM6IChmcm9tLCB0bykgPT4gKGZyb20gPT09IHRydWUgPyB0cnVlIDogTWF0aC5tYXgoZnJvbSwgdG8pKSxcbiAgICByZXN1bHRUb05hbWU6IChnZW4sIGl0ZW1zKSA9PiBnZW4udmFyKFwiaXRlbXNcIiwgaXRlbXMpLFxuICB9KSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV2YWx1YXRlZFByb3BzVG9OYW1lKGdlbjogQ29kZUdlbiwgcHM/OiBFdmFsdWF0ZWRQcm9wZXJ0aWVzKTogTmFtZSB7XG4gIGlmIChwcyA9PT0gdHJ1ZSkgcmV0dXJuIGdlbi52YXIoXCJwcm9wc1wiLCB0cnVlKVxuICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCBfYHt9YClcbiAgaWYgKHBzICE9PSB1bmRlZmluZWQpIHNldEV2YWx1YXRlZChnZW4sIHByb3BzLCBwcylcbiAgcmV0dXJuIHByb3BzXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRFdmFsdWF0ZWQoZ2VuOiBDb2RlR2VuLCBwcm9wczogTmFtZSwgcHM6IHtbSyBpbiBzdHJpbmddPzogdHJ1ZX0pOiB2b2lkIHtcbiAgT2JqZWN0LmtleXMocHMpLmZvckVhY2goKHApID0+IGdlbi5hc3NpZ24oX2Ake3Byb3BzfSR7Z2V0UHJvcGVydHkocCl9YCwgdHJ1ZSkpXG59XG5cbmNvbnN0IHNuaXBwZXRzOiB7W1MgaW4gc3RyaW5nXT86IF9Db2RlfSA9IHt9XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VGdW5jKGdlbjogQ29kZUdlbiwgZjoge2NvZGU6IHN0cmluZ30pOiBOYW1lIHtcbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwiZnVuY1wiLCB7XG4gICAgcmVmOiBmLFxuICAgIGNvZGU6IHNuaXBwZXRzW2YuY29kZV0gfHwgKHNuaXBwZXRzW2YuY29kZV0gPSBuZXcgX0NvZGUoZi5jb2RlKSksXG4gIH0pXG59XG5cbmV4cG9ydCBlbnVtIFR5cGUge1xuICBOdW0sXG4gIFN0cixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yUGF0aChcbiAgZGF0YVByb3A6IE5hbWUgfCBzdHJpbmcgfCBudW1iZXIsXG4gIGRhdGFQcm9wVHlwZT86IFR5cGUsXG4gIGpzUHJvcGVydHlTeW50YXg/OiBib29sZWFuXG4pOiBDb2RlIHwgc3RyaW5nIHtcbiAgLy8gbGV0IHBhdGhcbiAgaWYgKGRhdGFQcm9wIGluc3RhbmNlb2YgTmFtZSkge1xuICAgIGNvbnN0IGlzTnVtYmVyID0gZGF0YVByb3BUeXBlID09PSBUeXBlLk51bVxuICAgIHJldHVybiBqc1Byb3BlcnR5U3ludGF4XG4gICAgICA/IGlzTnVtYmVyXG4gICAgICAgID8gX2BcIltcIiArICR7ZGF0YVByb3B9ICsgXCJdXCJgXG4gICAgICAgIDogX2BcIlsnXCIgKyAke2RhdGFQcm9wfSArIFwiJ11cImBcbiAgICAgIDogaXNOdW1iZXJcbiAgICAgID8gX2BcIi9cIiArICR7ZGF0YVByb3B9YFxuICAgICAgOiBfYFwiL1wiICsgJHtkYXRhUHJvcH0ucmVwbGFjZSgvfi9nLCBcIn4wXCIpLnJlcGxhY2UoL1xcXFwvL2csIFwifjFcIilgIC8vIFRPRE8gbWF5YmUgdXNlIGdsb2JhbCBlc2NhcGVQb2ludGVyXG4gIH1cbiAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXggPyBnZXRQcm9wZXJ0eShkYXRhUHJvcCkudG9TdHJpbmcoKSA6IFwiL1wiICsgZXNjYXBlSnNvblBvaW50ZXIoZGF0YVByb3ApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1N0cmljdE1vZGUoXG4gIGl0OiBTY2hlbWFDeHQsXG4gIG1zZzogc3RyaW5nLFxuICBtb2RlOiBib29sZWFuIHwgXCJsb2dcIiA9IGl0Lm9wdHMuc3RyaWN0U2NoZW1hXG4pOiB2b2lkIHtcbiAgaWYgKCFtb2RlKSByZXR1cm5cbiAgbXNnID0gYHN0cmljdCBtb2RlOiAke21zZ31gXG4gIGlmIChtb2RlID09PSB0cnVlKSB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICBpdC5zZWxmLmxvZ2dlci53YXJuKG1zZylcbn1cbiIsICJpbXBvcnQge05hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuXG5jb25zdCBuYW1lcyA9IHtcbiAgLy8gdmFsaWRhdGlvbiBmdW5jdGlvbiBhcmd1bWVudHNcbiAgZGF0YTogbmV3IE5hbWUoXCJkYXRhXCIpLCAvLyBkYXRhIHBhc3NlZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIC8vIGFyZ3MgcGFzc2VkIGZyb20gcmVmZXJlbmNpbmcgc2NoZW1hXG4gIHZhbEN4dDogbmV3IE5hbWUoXCJ2YWxDeHRcIiksIC8vIHZhbGlkYXRpb24vZGF0YSBjb250ZXh0IC0gc2hvdWxkIG5vdCBiZSB1c2VkIGRpcmVjdGx5LCBpdCBpcyBkZXN0cnVjdHVyZWQgdG8gdGhlIG5hbWVzIGJlbG93XG4gIGluc3RhbmNlUGF0aDogbmV3IE5hbWUoXCJpbnN0YW5jZVBhdGhcIiksXG4gIHBhcmVudERhdGE6IG5ldyBOYW1lKFwicGFyZW50RGF0YVwiKSxcbiAgcGFyZW50RGF0YVByb3BlcnR5OiBuZXcgTmFtZShcInBhcmVudERhdGFQcm9wZXJ0eVwiKSxcbiAgcm9vdERhdGE6IG5ldyBOYW1lKFwicm9vdERhdGFcIiksIC8vIHJvb3QgZGF0YSAtIHNhbWUgYXMgdGhlIGRhdGEgcGFzc2VkIHRvIHRoZSBmaXJzdC90b3AgdmFsaWRhdGlvbiBmdW5jdGlvblxuICBkeW5hbWljQW5jaG9yczogbmV3IE5hbWUoXCJkeW5hbWljQW5jaG9yc1wiKSwgLy8gdXNlZCB0byBzdXBwb3J0IHJlY3Vyc2l2ZVJlZiBhbmQgZHluYW1pY1JlZlxuICAvLyBmdW5jdGlvbiBzY29wZWQgdmFyaWFibGVzXG4gIHZFcnJvcnM6IG5ldyBOYW1lKFwidkVycm9yc1wiKSwgLy8gbnVsbCBvciBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICBlcnJvcnM6IG5ldyBOYW1lKFwiZXJyb3JzXCIpLCAvLyBjb3VudGVyIG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gIHRoaXM6IG5ldyBOYW1lKFwidGhpc1wiKSxcbiAgLy8gXCJnbG9iYWxzXCJcbiAgc2VsZjogbmV3IE5hbWUoXCJzZWxmXCIpLFxuICBzY29wZTogbmV3IE5hbWUoXCJzY29wZVwiKSxcbiAgLy8gSlREIHNlcmlhbGl6ZS9wYXJzZSBuYW1lIGZvciBKU09OIHN0cmluZyBhbmQgcG9zaXRpb25cbiAganNvbjogbmV3IE5hbWUoXCJqc29uXCIpLFxuICBqc29uUG9zOiBuZXcgTmFtZShcImpzb25Qb3NcIiksXG4gIGpzb25MZW46IG5ldyBOYW1lKFwianNvbkxlblwiKSxcbiAganNvblBhcnQ6IG5ldyBOYW1lKFwianNvblBhcnRcIiksXG59XG5cbmV4cG9ydCBkZWZhdWx0IG5hbWVzXG4iLCAiaW1wb3J0IHR5cGUge0tleXdvcmRFcnJvckN4dCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFDeHR9IGZyb20gXCIuL2luZGV4XCJcbmltcG9ydCB7Q29kZUdlbiwgXywgc3RyLCBzdHJDb25jYXQsIENvZGUsIE5hbWV9IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IHtTYWZlRXhwcn0gZnJvbSBcIi4vY29kZWdlbi9jb2RlXCJcbmltcG9ydCB7Z2V0RXJyb3JQYXRoLCBUeXBlfSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCBOIGZyb20gXCIuL25hbWVzXCJcblxuZXhwb3J0IGNvbnN0IGtleXdvcmRFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkfSkgPT4gc3RyYG11c3QgcGFzcyBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIHZhbGlkYXRpb25gLFxufVxuXG5leHBvcnQgY29uc3Qga2V5d29yZCREYXRhRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7a2V5d29yZCwgc2NoZW1hVHlwZX0pID0+XG4gICAgc2NoZW1hVHlwZVxuICAgICAgPyBzdHJgXCIke2tleXdvcmR9XCIga2V5d29yZCBtdXN0IGJlICR7c2NoZW1hVHlwZX0gKCRkYXRhKWBcbiAgICAgIDogc3RyYFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgaXMgaW52YWxpZCAoJGRhdGEpYCxcbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvclBhdGhzIHtcbiAgaW5zdGFuY2VQYXRoPzogQ29kZVxuICBzY2hlbWFQYXRoPzogc3RyaW5nXG4gIHBhcmVudFNjaGVtYT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEVycm9yKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSBrZXl3b3JkRXJyb3IsXG4gIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzLFxuICBvdmVycmlkZUFsbEVycm9ycz86IGJvb2xlYW5cbik6IHZvaWQge1xuICBjb25zdCB7aXR9ID0gY3h0XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9yc30gPSBpdFxuICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocylcbiAgaWYgKG92ZXJyaWRlQWxsRXJyb3JzID8/IChjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICBhZGRFcnJvcihnZW4sIGVyck9iailcbiAgfSBlbHNlIHtcbiAgICByZXR1cm5FcnJvcnMoaXQsIF9gWyR7ZXJyT2JqfV1gKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRFeHRyYUVycm9yKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSBrZXl3b3JkRXJyb3IsXG4gIGVycm9yUGF0aHM/OiBFcnJvclBhdGhzXG4pOiB2b2lkIHtcbiAgY29uc3Qge2l0fSA9IGN4dFxuICBjb25zdCB7Z2VuLCBjb21wb3NpdGVSdWxlLCBhbGxFcnJvcnN9ID0gaXRcbiAgY29uc3QgZXJyT2JqID0gZXJyb3JPYmplY3RDb2RlKGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpXG4gIGFkZEVycm9yKGdlbiwgZXJyT2JqKVxuICBpZiAoIShjb21wb3NpdGVSdWxlIHx8IGFsbEVycm9ycykpIHtcbiAgICByZXR1cm5FcnJvcnMoaXQsIE4udkVycm9ycylcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzZXRFcnJvcnNDb3VudChnZW46IENvZGVHZW4sIGVycnNDb3VudDogTmFtZSk6IHZvaWQge1xuICBnZW4uYXNzaWduKE4uZXJyb3JzLCBlcnJzQ291bnQpXG4gIGdlbi5pZihfYCR7Ti52RXJyb3JzfSAhPT0gbnVsbGAsICgpID0+XG4gICAgZ2VuLmlmKFxuICAgICAgZXJyc0NvdW50LFxuICAgICAgKCkgPT4gZ2VuLmFzc2lnbihfYCR7Ti52RXJyb3JzfS5sZW5ndGhgLCBlcnJzQ291bnQpLFxuICAgICAgKCkgPT4gZ2VuLmFzc2lnbihOLnZFcnJvcnMsIG51bGwpXG4gICAgKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRFcnJvcnMoe1xuICBnZW4sXG4gIGtleXdvcmQsXG4gIHNjaGVtYVZhbHVlLFxuICBkYXRhLFxuICBlcnJzQ291bnQsXG4gIGl0LFxufTogS2V5d29yZEVycm9yQ3h0KTogdm9pZCB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXJyc0NvdW50ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICBjb25zdCBlcnIgPSBnZW4ubmFtZShcImVyclwiKVxuICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGVycnNDb3VudCwgTi5lcnJvcnMsIChpKSA9PiB7XG4gICAgZ2VuLmNvbnN0KGVyciwgX2Ake04udkVycm9yc31bJHtpfV1gKVxuICAgIGdlbi5pZihfYCR7ZXJyfS5pbnN0YW5jZVBhdGggPT09IHVuZGVmaW5lZGAsICgpID0+XG4gICAgICBnZW4uYXNzaWduKF9gJHtlcnJ9Lmluc3RhbmNlUGF0aGAsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgaXQuZXJyb3JQYXRoKSlcbiAgICApXG4gICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5zY2hlbWFQYXRoYCwgc3RyYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWApXG4gICAgaWYgKGl0Lm9wdHMudmVyYm9zZSkge1xuICAgICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5zY2hlbWFgLCBzY2hlbWFWYWx1ZSlcbiAgICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uZGF0YWAsIGRhdGEpXG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBhZGRFcnJvcihnZW46IENvZGVHZW4sIGVyck9iajogQ29kZSk6IHZvaWQge1xuICBjb25zdCBlcnIgPSBnZW4uY29uc3QoXCJlcnJcIiwgZXJyT2JqKVxuICBnZW4uaWYoXG4gICAgX2Ake04udkVycm9yc30gPT09IG51bGxgLFxuICAgICgpID0+IGdlbi5hc3NpZ24oTi52RXJyb3JzLCBfYFske2Vycn1dYCksXG4gICAgX2Ake04udkVycm9yc30ucHVzaCgke2Vycn0pYFxuICApXG4gIGdlbi5jb2RlKF9gJHtOLmVycm9yc30rK2ApXG59XG5cbmZ1bmN0aW9uIHJldHVybkVycm9ycyhpdDogU2NoZW1hQ3h0LCBlcnJzOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hRW52fSA9IGl0XG4gIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgZ2VuLnRocm93KF9gbmV3ICR7aXQuVmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9KCR7ZXJyc30pYClcbiAgfSBlbHNlIHtcbiAgICBnZW4uYXNzaWduKF9gJHt2YWxpZGF0ZU5hbWV9LmVycm9yc2AsIGVycnMpXG4gICAgZ2VuLnJldHVybihmYWxzZSlcbiAgfVxufVxuXG5jb25zdCBFID0ge1xuICBrZXl3b3JkOiBuZXcgTmFtZShcImtleXdvcmRcIiksXG4gIHNjaGVtYVBhdGg6IG5ldyBOYW1lKFwic2NoZW1hUGF0aFwiKSwgLy8gYWxzbyB1c2VkIGluIEpURCBlcnJvcnNcbiAgcGFyYW1zOiBuZXcgTmFtZShcInBhcmFtc1wiKSxcbiAgcHJvcGVydHlOYW1lOiBuZXcgTmFtZShcInByb3BlcnR5TmFtZVwiKSxcbiAgbWVzc2FnZTogbmV3IE5hbWUoXCJtZXNzYWdlXCIpLFxuICBzY2hlbWE6IG5ldyBOYW1lKFwic2NoZW1hXCIpLFxuICBwYXJlbnRTY2hlbWE6IG5ldyBOYW1lKFwicGFyZW50U2NoZW1hXCIpLFxufVxuXG5mdW5jdGlvbiBlcnJvck9iamVjdENvZGUoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHNcbik6IENvZGUge1xuICBjb25zdCB7Y3JlYXRlRXJyb3JzfSA9IGN4dC5pdFxuICBpZiAoY3JlYXRlRXJyb3JzID09PSBmYWxzZSkgcmV0dXJuIF9ge31gXG4gIHJldHVybiBlcnJvck9iamVjdChjeHQsIGVycm9yLCBlcnJvclBhdGhzKVxufVxuXG5mdW5jdGlvbiBlcnJvck9iamVjdChcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBlcnJvclBhdGhzOiBFcnJvclBhdGhzID0ge31cbik6IENvZGUge1xuICBjb25zdCB7Z2VuLCBpdH0gPSBjeHRcbiAgY29uc3Qga2V5VmFsdWVzOiBbTmFtZSwgU2FmZUV4cHIgfCBzdHJpbmddW10gPSBbXG4gICAgZXJyb3JJbnN0YW5jZVBhdGgoaXQsIGVycm9yUGF0aHMpLFxuICAgIGVycm9yU2NoZW1hUGF0aChjeHQsIGVycm9yUGF0aHMpLFxuICBdXG4gIGV4dHJhRXJyb3JQcm9wcyhjeHQsIGVycm9yLCBrZXlWYWx1ZXMpXG4gIHJldHVybiBnZW4ub2JqZWN0KC4uLmtleVZhbHVlcylcbn1cblxuZnVuY3Rpb24gZXJyb3JJbnN0YW5jZVBhdGgoe2Vycm9yUGF0aH06IFNjaGVtYUN4dCwge2luc3RhbmNlUGF0aH06IEVycm9yUGF0aHMpOiBbTmFtZSwgQ29kZV0ge1xuICBjb25zdCBpbnN0UGF0aCA9IGluc3RhbmNlUGF0aFxuICAgID8gc3RyYCR7ZXJyb3JQYXRofSR7Z2V0RXJyb3JQYXRoKGluc3RhbmNlUGF0aCwgVHlwZS5TdHIpfWBcbiAgICA6IGVycm9yUGF0aFxuICByZXR1cm4gW04uaW5zdGFuY2VQYXRoLCBzdHJDb25jYXQoTi5pbnN0YW5jZVBhdGgsIGluc3RQYXRoKV1cbn1cblxuZnVuY3Rpb24gZXJyb3JTY2hlbWFQYXRoKFxuICB7a2V5d29yZCwgaXQ6IHtlcnJTY2hlbWFQYXRofX06IEtleXdvcmRFcnJvckN4dCxcbiAge3NjaGVtYVBhdGgsIHBhcmVudFNjaGVtYX06IEVycm9yUGF0aHNcbik6IFtOYW1lLCBzdHJpbmcgfCBDb2RlXSB7XG4gIGxldCBzY2hQYXRoID0gcGFyZW50U2NoZW1hID8gZXJyU2NoZW1hUGF0aCA6IHN0cmAke2VyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gXG4gIGlmIChzY2hlbWFQYXRoKSB7XG4gICAgc2NoUGF0aCA9IHN0cmAke3NjaFBhdGh9JHtnZXRFcnJvclBhdGgoc2NoZW1hUGF0aCwgVHlwZS5TdHIpfWBcbiAgfVxuICByZXR1cm4gW0Uuc2NoZW1hUGF0aCwgc2NoUGF0aF1cbn1cblxuZnVuY3Rpb24gZXh0cmFFcnJvclByb3BzKFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAge3BhcmFtcywgbWVzc2FnZX06IEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIGtleVZhbHVlczogW05hbWUsIFNhZmVFeHByIHwgc3RyaW5nXVtdXG4pOiB2b2lkIHtcbiAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYVZhbHVlLCBpdH0gPSBjeHRcbiAgY29uc3Qge29wdHMsIHByb3BlcnR5TmFtZSwgdG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRofSA9IGl0XG4gIGtleVZhbHVlcy5wdXNoKFxuICAgIFtFLmtleXdvcmQsIGtleXdvcmRdLFxuICAgIFtFLnBhcmFtcywgdHlwZW9mIHBhcmFtcyA9PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoY3h0KSA6IHBhcmFtcyB8fCBfYHt9YF1cbiAgKVxuICBpZiAob3B0cy5tZXNzYWdlcykge1xuICAgIGtleVZhbHVlcy5wdXNoKFtFLm1lc3NhZ2UsIHR5cGVvZiBtZXNzYWdlID09IFwiZnVuY3Rpb25cIiA/IG1lc3NhZ2UoY3h0KSA6IG1lc3NhZ2VdKVxuICB9XG4gIGlmIChvcHRzLnZlcmJvc2UpIHtcbiAgICBrZXlWYWx1ZXMucHVzaChcbiAgICAgIFtFLnNjaGVtYSwgc2NoZW1hVmFsdWVdLFxuICAgICAgW0UucGFyZW50U2NoZW1hLCBfYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH1gXSxcbiAgICAgIFtOLmRhdGEsIGRhdGFdXG4gICAgKVxuICB9XG4gIGlmIChwcm9wZXJ0eU5hbWUpIGtleVZhbHVlcy5wdXNoKFtFLnByb3BlcnR5TmFtZSwgcHJvcGVydHlOYW1lXSlcbn1cbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEVycm9yRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yQ3h0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7cmVwb3J0RXJyb3J9IGZyb20gXCIuLi9lcnJvcnNcIlxuaW1wb3J0IHtfLCBOYW1lfSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vbmFtZXNcIlxuXG5jb25zdCBib29sRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwiYm9vbGVhbiBzY2hlbWEgaXMgZmFsc2VcIixcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRvcEJvb2xPckVtcHR5U2NoZW1hKGl0OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCB2YWxpZGF0ZU5hbWV9ID0gaXRcbiAgaWYgKHNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICBmYWxzZVNjaGVtYUVycm9yKGl0LCBmYWxzZSlcbiAgfSBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgc2NoZW1hLiRhc3luYyA9PT0gdHJ1ZSkge1xuICAgIGdlbi5yZXR1cm4oTi5kYXRhKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgbnVsbClcbiAgICBnZW4ucmV0dXJuKHRydWUpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJvb2xPckVtcHR5U2NoZW1hKGl0OiBTY2hlbWFDeHQsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYX0gPSBpdFxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGdlbi52YXIodmFsaWQsIGZhbHNlKSAvLyBUT0RPIHZhclxuICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQpXG4gIH0gZWxzZSB7XG4gICAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgfVxufVxuXG5mdW5jdGlvbiBmYWxzZVNjaGVtYUVycm9yKGl0OiBTY2hlbWFDeHQsIG92ZXJyaWRlQWxsRXJyb3JzPzogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhfSA9IGl0XG4gIC8vIFRPRE8gbWF5YmUgc29tZSBvdGhlciBpbnRlcmZhY2Ugc2hvdWxkIGJlIHVzZWQgZm9yIG5vbi1rZXl3b3JkIHZhbGlkYXRpb24gZXJyb3JzLi4uXG4gIGNvbnN0IGN4dDogS2V5d29yZEVycm9yQ3h0ID0ge1xuICAgIGdlbixcbiAgICBrZXl3b3JkOiBcImZhbHNlIHNjaGVtYVwiLFxuICAgIGRhdGEsXG4gICAgc2NoZW1hOiBmYWxzZSxcbiAgICBzY2hlbWFDb2RlOiBmYWxzZSxcbiAgICBzY2hlbWFWYWx1ZTogZmFsc2UsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpdCxcbiAgfVxuICByZXBvcnRFcnJvcihjeHQsIGJvb2xFcnJvciwgdW5kZWZpbmVkLCBvdmVycmlkZUFsbEVycm9ycylcbn1cbiIsICJpbXBvcnQgdHlwZSB7QWRkZWRLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uL3R5cGVzXCJcblxuY29uc3QgX2pzb25UeXBlcyA9IFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiLCBcIm9iamVjdFwiLCBcImFycmF5XCJdIGFzIGNvbnN0XG5cbmV4cG9ydCB0eXBlIEpTT05UeXBlID0gKHR5cGVvZiBfanNvblR5cGVzKVtudW1iZXJdXG5cbmNvbnN0IGpzb25UeXBlczogU2V0PHN0cmluZz4gPSBuZXcgU2V0KF9qc29uVHlwZXMpXG5cbmV4cG9ydCBmdW5jdGlvbiBpc0pTT05UeXBlKHg6IHVua25vd24pOiB4IGlzIEpTT05UeXBlIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwic3RyaW5nXCIgJiYganNvblR5cGVzLmhhcyh4KVxufVxuXG50eXBlIFZhbGlkYXRpb25UeXBlcyA9IHtcbiAgW0sgaW4gSlNPTlR5cGVdOiBib29sZWFuIHwgUnVsZUdyb3VwIHwgdW5kZWZpbmVkXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVmFsaWRhdGlvblJ1bGVzIHtcbiAgcnVsZXM6IFJ1bGVHcm91cFtdXG4gIHBvc3Q6IFJ1bGVHcm91cFxuICBhbGw6IHtbS2V5IGluIHN0cmluZ10/OiBib29sZWFuIHwgUnVsZX0gLy8gcnVsZXMgdGhhdCBoYXZlIHRvIGJlIHZhbGlkYXRlZFxuICBrZXl3b3Jkczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW59IC8vIGFsbCBrbm93biBrZXl3b3JkcyAoc3VwZXJzZXQgb2YgXCJhbGxcIilcbiAgdHlwZXM6IFZhbGlkYXRpb25UeXBlc1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGVHcm91cCB7XG4gIHR5cGU/OiBKU09OVHlwZVxuICBydWxlczogUnVsZVtdXG59XG5cbi8vIFRoaXMgaW50ZXJmYWNlIHdyYXBzIEtleXdvcmREZWZpbml0aW9uIGJlY2F1c2UgZGVmaW5pdGlvbiBjYW4gaGF2ZSBtdWx0aXBsZSBrZXl3b3Jkc1xuZXhwb3J0IGludGVyZmFjZSBSdWxlIHtcbiAga2V5d29yZDogc3RyaW5nXG4gIGRlZmluaXRpb246IEFkZGVkS2V5d29yZERlZmluaXRpb25cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bGVzKCk6IFZhbGlkYXRpb25SdWxlcyB7XG4gIGNvbnN0IGdyb3VwczogUmVjb3JkPFwibnVtYmVyXCIgfCBcInN0cmluZ1wiIHwgXCJhcnJheVwiIHwgXCJvYmplY3RcIiwgUnVsZUdyb3VwPiA9IHtcbiAgICBudW1iZXI6IHt0eXBlOiBcIm51bWJlclwiLCBydWxlczogW119LFxuICAgIHN0cmluZzoge3R5cGU6IFwic3RyaW5nXCIsIHJ1bGVzOiBbXX0sXG4gICAgYXJyYXk6IHt0eXBlOiBcImFycmF5XCIsIHJ1bGVzOiBbXX0sXG4gICAgb2JqZWN0OiB7dHlwZTogXCJvYmplY3RcIiwgcnVsZXM6IFtdfSxcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGVzOiB7Li4uZ3JvdXBzLCBpbnRlZ2VyOiB0cnVlLCBib29sZWFuOiB0cnVlLCBudWxsOiB0cnVlfSxcbiAgICBydWxlczogW3tydWxlczogW119LCBncm91cHMubnVtYmVyLCBncm91cHMuc3RyaW5nLCBncm91cHMuYXJyYXksIGdyb3Vwcy5vYmplY3RdLFxuICAgIHBvc3Q6IHtydWxlczogW119LFxuICAgIGFsbDoge30sXG4gICAga2V5d29yZHM6IHt9LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYU9iamVjdH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGUsIFJ1bGVHcm91cCwgUnVsZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzRm9yVHlwZShcbiAge3NjaGVtYSwgc2VsZn06IFNjaGVtYU9iakN4dCxcbiAgdHlwZTogSlNPTlR5cGVcbik6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICBjb25zdCBncm91cCA9IHNlbGYuUlVMRVMudHlwZXNbdHlwZV1cbiAgcmV0dXJuIGdyb3VwICYmIGdyb3VwICE9PSB0cnVlICYmIHNob3VsZFVzZUdyb3VwKHNjaGVtYSwgZ3JvdXApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRVc2VHcm91cChzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgZ3JvdXA6IFJ1bGVHcm91cCk6IGJvb2xlYW4ge1xuICByZXR1cm4gZ3JvdXAucnVsZXMuc29tZSgocnVsZSkgPT4gc2hvdWxkVXNlUnVsZShzY2hlbWEsIHJ1bGUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvdWxkVXNlUnVsZShzY2hlbWE6IEFueVNjaGVtYU9iamVjdCwgcnVsZTogUnVsZSk6IGJvb2xlYW4gfCB1bmRlZmluZWQge1xuICByZXR1cm4gKFxuICAgIHNjaGVtYVtydWxlLmtleXdvcmRdICE9PSB1bmRlZmluZWQgfHxcbiAgICBydWxlLmRlZmluaXRpb24uaW1wbGVtZW50cz8uc29tZSgoa3dkKSA9PiBzY2hlbWFba3dkXSAhPT0gdW5kZWZpbmVkKVxuICApXG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JDeHQsXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtpc0pTT05UeXBlLCBKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNGb3JUeXBlfSBmcm9tIFwiLi9hcHBsaWNhYmlsaXR5XCJcbmltcG9ydCB7cmVwb3J0RXJyb3J9IGZyb20gXCIuLi9lcnJvcnNcIlxuaW1wb3J0IHtfLCBuaWwsIGFuZCwgbm90LCBvcGVyYXRvcnMsIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7dG9IYXNoLCBzY2hlbWFSZWZPclZhbH0gZnJvbSBcIi4uL3V0aWxcIlxuXG5leHBvcnQgZW51bSBEYXRhVHlwZSB7XG4gIENvcnJlY3QsXG4gIFdyb25nLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hVHlwZXMoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXMgPSBnZXRKU09OVHlwZXMoc2NoZW1hLnR5cGUpXG4gIGNvbnN0IGhhc051bGwgPSB0eXBlcy5pbmNsdWRlcyhcIm51bGxcIilcbiAgaWYgKGhhc051bGwpIHtcbiAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSBmYWxzZSkgdGhyb3cgbmV3IEVycm9yKFwidHlwZTogbnVsbCBjb250cmFkaWN0cyBudWxsYWJsZTogZmFsc2VcIilcbiAgfSBlbHNlIHtcbiAgICBpZiAoIXR5cGVzLmxlbmd0aCAmJiBzY2hlbWEubnVsbGFibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcIm51bGxhYmxlXCIgY2Fubm90IGJlIHVzZWQgd2l0aG91dCBcInR5cGVcIicpXG4gICAgfVxuICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IHRydWUpIHR5cGVzLnB1c2goXCJudWxsXCIpXG4gIH1cbiAgcmV0dXJuIHR5cGVzXG59XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG5leHBvcnQgZnVuY3Rpb24gZ2V0SlNPTlR5cGVzKHRzOiB1bmtub3duIHwgdW5rbm93bltdKTogSlNPTlR5cGVbXSB7XG4gIGNvbnN0IHR5cGVzOiB1bmtub3duW10gPSBBcnJheS5pc0FycmF5KHRzKSA/IHRzIDogdHMgPyBbdHNdIDogW11cbiAgaWYgKHR5cGVzLmV2ZXJ5KGlzSlNPTlR5cGUpKSByZXR1cm4gdHlwZXNcbiAgdGhyb3cgbmV3IEVycm9yKFwidHlwZSBtdXN0IGJlIEpTT05UeXBlIG9yIEpTT05UeXBlW106IFwiICsgdHlwZXMuam9pbihcIixcIikpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb2VyY2VBbmRDaGVja0RhdGFUeXBlKGl0OiBTY2hlbWFPYmpDeHQsIHR5cGVzOiBKU09OVHlwZVtdKTogYm9vbGVhbiB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIG9wdHN9ID0gaXRcbiAgY29uc3QgY29lcmNlVG8gPSBjb2VyY2VUb1R5cGVzKHR5cGVzLCBvcHRzLmNvZXJjZVR5cGVzKVxuICBjb25zdCBjaGVja1R5cGVzID1cbiAgICB0eXBlcy5sZW5ndGggPiAwICYmXG4gICAgIShjb2VyY2VUby5sZW5ndGggPT09IDAgJiYgdHlwZXMubGVuZ3RoID09PSAxICYmIHNjaGVtYUhhc1J1bGVzRm9yVHlwZShpdCwgdHlwZXNbMF0pKVxuICBpZiAoY2hlY2tUeXBlcykge1xuICAgIGNvbnN0IHdyb25nVHlwZSA9IGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKVxuICAgIGdlbi5pZih3cm9uZ1R5cGUsICgpID0+IHtcbiAgICAgIGlmIChjb2VyY2VUby5sZW5ndGgpIGNvZXJjZURhdGEoaXQsIHR5cGVzLCBjb2VyY2VUbylcbiAgICAgIGVsc2UgcmVwb3J0VHlwZUVycm9yKGl0KVxuICAgIH0pXG4gIH1cbiAgcmV0dXJuIGNoZWNrVHlwZXNcbn1cblxuY29uc3QgQ09FUkNJQkxFOiBTZXQ8SlNPTlR5cGU+ID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJpbnRlZ2VyXCIsIFwiYm9vbGVhblwiLCBcIm51bGxcIl0pXG5mdW5jdGlvbiBjb2VyY2VUb1R5cGVzKHR5cGVzOiBKU09OVHlwZVtdLCBjb2VyY2VUeXBlcz86IGJvb2xlYW4gfCBcImFycmF5XCIpOiBKU09OVHlwZVtdIHtcbiAgcmV0dXJuIGNvZXJjZVR5cGVzXG4gICAgPyB0eXBlcy5maWx0ZXIoKHQpID0+IENPRVJDSUJMRS5oYXModCkgfHwgKGNvZXJjZVR5cGVzID09PSBcImFycmF5XCIgJiYgdCA9PT0gXCJhcnJheVwiKSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGNvZXJjZURhdGEoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10sIGNvZXJjZVRvOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIG9wdHN9ID0gaXRcbiAgY29uc3QgZGF0YVR5cGUgPSBnZW4ubGV0KFwiZGF0YVR5cGVcIiwgX2B0eXBlb2YgJHtkYXRhfWApXG4gIGNvbnN0IGNvZXJjZWQgPSBnZW4ubGV0KFwiY29lcmNlZFwiLCBfYHVuZGVmaW5lZGApXG4gIGlmIChvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpIHtcbiAgICBnZW4uaWYoX2Ake2RhdGFUeXBlfSA9PSAnb2JqZWN0JyAmJiBBcnJheS5pc0FycmF5KCR7ZGF0YX0pICYmICR7ZGF0YX0ubGVuZ3RoID09IDFgLCAoKSA9PlxuICAgICAgZ2VuXG4gICAgICAgIC5hc3NpZ24oZGF0YSwgX2Ake2RhdGF9WzBdYClcbiAgICAgICAgLmFzc2lnbihkYXRhVHlwZSwgX2B0eXBlb2YgJHtkYXRhfWApXG4gICAgICAgIC5pZihjaGVja0RhdGFUeXBlcyh0eXBlcywgZGF0YSwgb3B0cy5zdHJpY3ROdW1iZXJzKSwgKCkgPT4gZ2VuLmFzc2lnbihjb2VyY2VkLCBkYXRhKSlcbiAgICApXG4gIH1cbiAgZ2VuLmlmKF9gJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYClcbiAgZm9yIChjb25zdCB0IG9mIGNvZXJjZVRvKSB7XG4gICAgaWYgKENPRVJDSUJMRS5oYXModCkgfHwgKHQgPT09IFwiYXJyYXlcIiAmJiBvcHRzLmNvZXJjZVR5cGVzID09PSBcImFycmF5XCIpKSB7XG4gICAgICBjb2VyY2VTcGVjaWZpY1R5cGUodClcbiAgICB9XG4gIH1cbiAgZ2VuLmVsc2UoKVxuICByZXBvcnRUeXBlRXJyb3IoaXQpXG4gIGdlbi5lbmRJZigpXG5cbiAgZ2VuLmlmKF9gJHtjb2VyY2VkfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT4ge1xuICAgIGdlbi5hc3NpZ24oZGF0YSwgY29lcmNlZClcbiAgICBhc3NpZ25QYXJlbnREYXRhKGl0LCBjb2VyY2VkKVxuICB9KVxuXG4gIGZ1bmN0aW9uIGNvZXJjZVNwZWNpZmljVHlwZSh0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihfYCR7ZGF0YVR5cGV9ID09IFwibnVtYmVyXCIgfHwgJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCJgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2BcIlwiICsgJHtkYXRhfWApXG4gICAgICAgICAgLmVsc2VJZihfYCR7ZGF0YX0gPT09IG51bGxgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2BcIlwiYClcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoXG4gICAgICAgICAgICBfYCR7ZGF0YVR5cGV9ID09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxcbiAgICAgICAgICAgICAgfHwgKCR7ZGF0YVR5cGV9ID09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9KWBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYCske2RhdGF9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKFxuICAgICAgICAgICAgX2Ake2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgJiYgJHtkYXRhfSAmJiAke2RhdGF9ID09ICske2RhdGF9ICYmICEoJHtkYXRhfSAlIDEpKWBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYCske2RhdGF9YClcbiAgICAgICAgcmV0dXJuXG4gICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gXCJmYWxzZVwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBmYWxzZSlcbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gXCJ0cnVlXCIgfHwgJHtkYXRhfSA9PT0gMWApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCB0cnVlKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJudWxsXCI6XG4gICAgICAgIGdlbi5lbHNlSWYoX2Ake2RhdGF9ID09PSBcIlwiIHx8ICR7ZGF0YX0gPT09IDAgfHwgJHtkYXRhfSA9PT0gZmFsc2VgKVxuICAgICAgICBnZW4uYXNzaWduKGNvZXJjZWQsIG51bGwpXG4gICAgICAgIHJldHVyblxuXG4gICAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihcbiAgICAgICAgICAgIF9gJHtkYXRhVHlwZX0gPT09IFwic3RyaW5nXCIgfHwgJHtkYXRhVHlwZX0gPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgfHwgJHtkYXRhVHlwZX0gPT09IFwiYm9vbGVhblwiIHx8ICR7ZGF0YX0gPT09IG51bGxgXG4gICAgICAgICAgKVxuICAgICAgICAgIC5hc3NpZ24oY29lcmNlZCwgX2BbJHtkYXRhfV1gKVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25QYXJlbnREYXRhKHtnZW4sIHBhcmVudERhdGEsIHBhcmVudERhdGFQcm9wZXJ0eX06IFNjaGVtYU9iakN4dCwgZXhwcjogTmFtZSk6IHZvaWQge1xuICAvLyBUT0RPIHVzZSBnZW4ucHJvcGVydHlcbiAgZ2VuLmlmKF9gJHtwYXJlbnREYXRhfSAhPT0gdW5kZWZpbmVkYCwgKCkgPT5cbiAgICBnZW4uYXNzaWduKF9gJHtwYXJlbnREYXRhfVske3BhcmVudERhdGFQcm9wZXJ0eX1dYCwgZXhwcilcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tEYXRhVHlwZShcbiAgZGF0YVR5cGU6IEpTT05UeXBlLFxuICBkYXRhOiBOYW1lLFxuICBzdHJpY3ROdW1zPzogYm9vbGVhbiB8IFwibG9nXCIsXG4gIGNvcnJlY3QgPSBEYXRhVHlwZS5Db3JyZWN0XG4pOiBDb2RlIHtcbiAgY29uc3QgRVEgPSBjb3JyZWN0ID09PSBEYXRhVHlwZS5Db3JyZWN0ID8gb3BlcmF0b3JzLkVRIDogb3BlcmF0b3JzLk5FUVxuICBsZXQgY29uZDogQ29kZVxuICBzd2l0Y2ggKGRhdGFUeXBlKSB7XG4gICAgY2FzZSBcIm51bGxcIjpcbiAgICAgIHJldHVybiBfYCR7ZGF0YX0gJHtFUX0gbnVsbGBcbiAgICBjYXNlIFwiYXJyYXlcIjpcbiAgICAgIGNvbmQgPSBfYEFycmF5LmlzQXJyYXkoJHtkYXRhfSlgXG4gICAgICBicmVha1xuICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgIGNvbmQgPSBfYCR7ZGF0YX0gJiYgdHlwZW9mICR7ZGF0YX0gPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheSgke2RhdGF9KWBcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcImludGVnZXJcIjpcbiAgICAgIGNvbmQgPSBudW1Db25kKF9gISgke2RhdGF9ICUgMSkgJiYgIWlzTmFOKCR7ZGF0YX0pYClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgY29uZCA9IG51bUNvbmQoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIF9gdHlwZW9mICR7ZGF0YX0gJHtFUX0gJHtkYXRhVHlwZX1gXG4gIH1cbiAgcmV0dXJuIGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBjb25kIDogbm90KGNvbmQpXG5cbiAgZnVuY3Rpb24gbnVtQ29uZChfY29uZDogQ29kZSA9IG5pbCk6IENvZGUge1xuICAgIHJldHVybiBhbmQoX2B0eXBlb2YgJHtkYXRhfSA9PSBcIm51bWJlclwiYCwgX2NvbmQsIHN0cmljdE51bXMgPyBfYGlzRmluaXRlKCR7ZGF0YX0pYCA6IG5pbClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tEYXRhVHlwZXMoXG4gIGRhdGFUeXBlczogSlNPTlR5cGVbXSxcbiAgZGF0YTogTmFtZSxcbiAgc3RyaWN0TnVtcz86IGJvb2xlYW4gfCBcImxvZ1wiLFxuICBjb3JyZWN0PzogRGF0YVR5cGVcbik6IENvZGUge1xuICBpZiAoZGF0YVR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBjaGVja0RhdGFUeXBlKGRhdGFUeXBlc1swXSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdClcbiAgfVxuICBsZXQgY29uZDogQ29kZVxuICBjb25zdCB0eXBlcyA9IHRvSGFzaChkYXRhVHlwZXMpXG4gIGlmICh0eXBlcy5hcnJheSAmJiB0eXBlcy5vYmplY3QpIHtcbiAgICBjb25zdCBub3RPYmogPSBfYHR5cGVvZiAke2RhdGF9ICE9IFwib2JqZWN0XCJgXG4gICAgY29uZCA9IHR5cGVzLm51bGwgPyBub3RPYmogOiBfYCEke2RhdGF9IHx8ICR7bm90T2JqfWBcbiAgICBkZWxldGUgdHlwZXMubnVsbFxuICAgIGRlbGV0ZSB0eXBlcy5hcnJheVxuICAgIGRlbGV0ZSB0eXBlcy5vYmplY3RcbiAgfSBlbHNlIHtcbiAgICBjb25kID0gbmlsXG4gIH1cbiAgaWYgKHR5cGVzLm51bWJlcikgZGVsZXRlIHR5cGVzLmludGVnZXJcbiAgZm9yIChjb25zdCB0IGluIHR5cGVzKSBjb25kID0gYW5kKGNvbmQsIGNoZWNrRGF0YVR5cGUodCBhcyBKU09OVHlwZSwgZGF0YSwgc3RyaWN0TnVtcywgY29ycmVjdCkpXG4gIHJldHVybiBjb25kXG59XG5cbmV4cG9ydCB0eXBlIFR5cGVFcnJvciA9IEVycm9yT2JqZWN0PFwidHlwZVwiLCB7dHlwZTogc3RyaW5nfT5cblxuY29uc3QgdHlwZUVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYX0pID0+IGBtdXN0IGJlICR7c2NoZW1hfWAsXG4gIHBhcmFtczogKHtzY2hlbWEsIHNjaGVtYVZhbHVlfSkgPT5cbiAgICB0eXBlb2Ygc2NoZW1hID09IFwic3RyaW5nXCIgPyBfYHt0eXBlOiAke3NjaGVtYX19YCA6IF9ge3R5cGU6ICR7c2NoZW1hVmFsdWV9fWAsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRUeXBlRXJyb3IoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCBjeHQgPSBnZXRUeXBlRXJyb3JDb250ZXh0KGl0KVxuICByZXBvcnRFcnJvcihjeHQsIHR5cGVFcnJvcilcbn1cblxuZnVuY3Rpb24gZ2V0VHlwZUVycm9yQ29udGV4dChpdDogU2NoZW1hT2JqQ3h0KTogS2V5d29yZEVycm9yQ3h0IHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hfSA9IGl0XG4gIGNvbnN0IHNjaGVtYUNvZGUgPSBzY2hlbWFSZWZPclZhbChpdCwgc2NoZW1hLCBcInR5cGVcIilcbiAgcmV0dXJuIHtcbiAgICBnZW4sXG4gICAga2V5d29yZDogXCJ0eXBlXCIsXG4gICAgZGF0YSxcbiAgICBzY2hlbWE6IHNjaGVtYS50eXBlLFxuICAgIHNjaGVtYUNvZGUsXG4gICAgc2NoZW1hVmFsdWU6IHNjaGVtYUNvZGUsXG4gICAgcGFyZW50U2NoZW1hOiBzY2hlbWEsXG4gICAgcGFyYW1zOiB7fSxcbiAgICBpdCxcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge18sIGdldFByb3BlcnR5LCBzdHJpbmdpZnl9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vdXRpbFwiXG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25EZWZhdWx0cyhpdDogU2NoZW1hT2JqQ3h0LCB0eT86IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB7cHJvcGVydGllcywgaXRlbXN9ID0gaXQuc2NoZW1hXG4gIGlmICh0eSA9PT0gXCJvYmplY3RcIiAmJiBwcm9wZXJ0aWVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgYXNzaWduRGVmYXVsdChpdCwga2V5LCBwcm9wZXJ0aWVzW2tleV0uZGVmYXVsdClcbiAgICB9XG4gIH0gZWxzZSBpZiAodHkgPT09IFwiYXJyYXlcIiAmJiBBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgIGl0ZW1zLmZvckVhY2goKHNjaCwgaTogbnVtYmVyKSA9PiBhc3NpZ25EZWZhdWx0KGl0LCBpLCBzY2guZGVmYXVsdCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduRGVmYXVsdChpdDogU2NoZW1hT2JqQ3h0LCBwcm9wOiBzdHJpbmcgfCBudW1iZXIsIGRlZmF1bHRWYWx1ZTogdW5rbm93bik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBjb21wb3NpdGVSdWxlLCBkYXRhLCBvcHRzfSA9IGl0XG4gIGlmIChkZWZhdWx0VmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIGNvbnN0IGNoaWxkRGF0YSA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcCl9YFxuICBpZiAoY29tcG9zaXRlUnVsZSkge1xuICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYGRlZmF1bHQgaXMgaWdub3JlZCBmb3I6ICR7Y2hpbGREYXRhfWApXG4gICAgcmV0dXJuXG4gIH1cblxuICBsZXQgY29uZGl0aW9uID0gX2Ake2NoaWxkRGF0YX0gPT09IHVuZGVmaW5lZGBcbiAgaWYgKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIikge1xuICAgIGNvbmRpdGlvbiA9IF9gJHtjb25kaXRpb259IHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgXG4gIH1cbiAgLy8gYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYCArXG4gIC8vIChvcHRzLnVzZURlZmF1bHRzID09PSBcImVtcHR5XCIgPyBgIHx8ICR7Y2hpbGREYXRhfSA9PT0gbnVsbCB8fCAke2NoaWxkRGF0YX0gPT09IFwiXCJgIDogXCJcIilcbiAgZ2VuLmlmKGNvbmRpdGlvbiwgX2Ake2NoaWxkRGF0YX0gPSAke3N0cmluZ2lmeShkZWZhdWx0VmFsdWUpfWApXG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYSwgU2NoZW1hTWFwfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4uL2NvbXBpbGVcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Q29kZUdlbiwgXywgYW5kLCBvciwgbm90LCBuaWwsIHN0ckNvbmNhdCwgZ2V0UHJvcGVydHksIENvZGUsIE5hbWV9IGZyb20gXCIuLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgVHlwZX0gZnJvbSBcIi4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vY29tcGlsZS9uYW1lc1wiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi9jb21waWxlL3V0aWxcIlxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0OiBLZXl3b3JkQ3h0LCBwcm9wOiBzdHJpbmcpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgaXR9ID0gY3h0XG4gIGdlbi5pZihub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSwgKCkgPT4ge1xuICAgIGN4dC5zZXRQYXJhbXMoe21pc3NpbmdQcm9wZXJ0eTogX2Ake3Byb3B9YH0sIHRydWUpXG4gICAgY3h0LmVycm9yKClcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrTWlzc2luZ1Byb3AoXG4gIHtnZW4sIGRhdGEsIGl0OiB7b3B0c319OiBLZXl3b3JkQ3h0LFxuICBwcm9wZXJ0aWVzOiBzdHJpbmdbXSxcbiAgbWlzc2luZzogTmFtZVxuKTogQ29kZSB7XG4gIHJldHVybiBvcihcbiAgICAuLi5wcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT5cbiAgICAgIGFuZChub1Byb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgb3B0cy5vd25Qcm9wZXJ0aWVzKSwgX2Ake21pc3Npbmd9ID0gJHtwcm9wfWApXG4gICAgKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXBvcnRNaXNzaW5nUHJvcChjeHQ6IEtleXdvcmRDeHQsIG1pc3Npbmc6IE5hbWUpOiB2b2lkIHtcbiAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nfSwgdHJ1ZSlcbiAgY3h0LmVycm9yKClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc1Byb3BGdW5jKGdlbjogQ29kZUdlbik6IE5hbWUge1xuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuYm91bmQtbWV0aG9kXG4gICAgcmVmOiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LFxuICAgIGNvZGU6IF9gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eWAsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc093blByb3BlcnR5KGdlbjogQ29kZUdlbiwgZGF0YTogTmFtZSwgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcpOiBDb2RlIHtcbiAgcmV0dXJuIF9gJHtoYXNQcm9wRnVuYyhnZW4pfS5jYWxsKCR7ZGF0YX0sICR7cHJvcGVydHl9KWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByb3BlcnR5SW5EYXRhKFxuICBnZW46IENvZGVHZW4sXG4gIGRhdGE6IE5hbWUsXG4gIHByb3BlcnR5OiBOYW1lIHwgc3RyaW5nLFxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGNvbmQgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHByb3BlcnR5KX0gIT09IHVuZGVmaW5lZGBcbiAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBfYCR7Y29uZH0gJiYgJHtpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpfWAgOiBjb25kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub1Byb3BlcnR5SW5EYXRhKFxuICBnZW46IENvZGVHZW4sXG4gIGRhdGE6IE5hbWUsXG4gIHByb3BlcnR5OiBOYW1lIHwgc3RyaW5nLFxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGNvbmQgPSBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHByb3BlcnR5KX0gPT09IHVuZGVmaW5lZGBcbiAgcmV0dXJuIG93blByb3BlcnRpZXMgPyBvcihjb25kLCBub3QoaXNPd25Qcm9wZXJ0eShnZW4sIGRhdGEsIHByb3BlcnR5KSkpIDogY29uZFxufVxuXG5leHBvcnQgZnVuY3Rpb24gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXA/OiBTY2hlbWFNYXApOiBzdHJpbmdbXSB7XG4gIHJldHVybiBzY2hlbWFNYXAgPyBPYmplY3Qua2V5cyhzY2hlbWFNYXApLmZpbHRlcigocCkgPT4gcCAhPT0gXCJfX3Byb3RvX19cIikgOiBbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hUHJvcGVydGllcyhpdDogU2NoZW1hQ3h0LCBzY2hlbWFNYXA6IFNjaGVtYU1hcCk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIGFsbFNjaGVtYVByb3BlcnRpZXMoc2NoZW1hTWFwKS5maWx0ZXIoXG4gICAgKHApID0+ICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hTWFwW3BdIGFzIEFueVNjaGVtYSlcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbFZhbGlkYXRlQ29kZShcbiAge3NjaGVtYUNvZGUsIGRhdGEsIGl0OiB7Z2VuLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGgsIGVycm9yUGF0aH0sIGl0fTogS2V5d29yZEN4dCxcbiAgZnVuYzogQ29kZSxcbiAgY29udGV4dDogQ29kZSxcbiAgcGFzc1NjaGVtYT86IGJvb2xlYW5cbik6IENvZGUge1xuICBjb25zdCBkYXRhQW5kU2NoZW1hID0gcGFzc1NjaGVtYSA/IF9gJHtzY2hlbWFDb2RlfSwgJHtkYXRhfSwgJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWAgOiBkYXRhXG4gIGNvbnN0IHZhbEN4dDogW05hbWUsIENvZGUgfCBudW1iZXJdW10gPSBbXG4gICAgW04uaW5zdGFuY2VQYXRoLCBzdHJDb25jYXQoTi5pbnN0YW5jZVBhdGgsIGVycm9yUGF0aCldLFxuICAgIFtOLnBhcmVudERhdGEsIGl0LnBhcmVudERhdGFdLFxuICAgIFtOLnBhcmVudERhdGFQcm9wZXJ0eSwgaXQucGFyZW50RGF0YVByb3BlcnR5XSxcbiAgICBbTi5yb290RGF0YSwgTi5yb290RGF0YV0sXG4gIF1cbiAgaWYgKGl0Lm9wdHMuZHluYW1pY1JlZikgdmFsQ3h0LnB1c2goW04uZHluYW1pY0FuY2hvcnMsIE4uZHluYW1pY0FuY2hvcnNdKVxuICBjb25zdCBhcmdzID0gX2Ake2RhdGFBbmRTY2hlbWF9LCAke2dlbi5vYmplY3QoLi4udmFsQ3h0KX1gXG4gIHJldHVybiBjb250ZXh0ICE9PSBuaWwgPyBfYCR7ZnVuY30uY2FsbCgke2NvbnRleHR9LCAke2FyZ3N9KWAgOiBfYCR7ZnVuY30oJHthcmdzfSlgXG59XG5cbmNvbnN0IG5ld1JlZ0V4cCA9IF9gbmV3IFJlZ0V4cGBcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVBhdHRlcm4oe2dlbiwgaXQ6IHtvcHRzfX06IEtleXdvcmRDeHQsIHBhdHRlcm46IHN0cmluZyk6IE5hbWUge1xuICBjb25zdCB1ID0gb3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiXG4gIGNvbnN0IHtyZWdFeHB9ID0gb3B0cy5jb2RlXG4gIGNvbnN0IHJ4ID0gcmVnRXhwKHBhdHRlcm4sIHUpXG5cbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFwicGF0dGVyblwiLCB7XG4gICAga2V5OiByeC50b1N0cmluZygpLFxuICAgIHJlZjogcngsXG4gICAgY29kZTogX2Ake3JlZ0V4cC5jb2RlID09PSBcIm5ldyBSZWdFeHBcIiA/IG5ld1JlZ0V4cCA6IHVzZUZ1bmMoZ2VuLCByZWdFeHApfSgke3BhdHRlcm59LCAke3V9KWAsXG4gIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFycmF5KGN4dDogS2V5d29yZEN4dCk6IE5hbWUge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICBjb25zdCB2YWxpZEFyciA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKVxuICAgIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmFzc2lnbih2YWxpZEFyciwgZmFsc2UpKVxuICAgIHJldHVybiB2YWxpZEFyclxuICB9XG4gIGdlbi52YXIodmFsaWQsIHRydWUpXG4gIHZhbGlkYXRlSXRlbXMoKCkgPT4gZ2VuLmJyZWFrKCkpXG4gIHJldHVybiB2YWxpZFxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXMobm90VmFsaWQ6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgX2Ake2RhdGF9Lmxlbmd0aGApXG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCAwLCBsZW4sIChpKSA9PiB7XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksIG5vdFZhbGlkKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVW5pb24oY3h0OiBLZXl3b3JkQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIGNvbnN0IGFsd2F5c1ZhbGlkID0gc2NoZW1hLnNvbWUoKHNjaDogQW55U2NoZW1hKSA9PiBhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSlcbiAgaWYgKGFsd2F5c1ZhbGlkICYmICFpdC5vcHRzLnVuZXZhbHVhdGVkKSByZXR1cm5cblxuICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSlcbiAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuXG4gIGdlbi5ibG9jaygoKSA9PlxuICAgIHNjaGVtYS5mb3JFYWNoKChfc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQsXG4gICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBzY2hWYWxpZFxuICAgICAgKVxuICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgX2Ake3ZhbGlkfSB8fCAke3NjaFZhbGlkfWApXG4gICAgICBjb25zdCBtZXJnZWQgPSBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHNjaFZhbGlkKVxuICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllcy9JdGVtc2Agbm90IHN1cHBvcnRlZCAob3B0cy51bmV2YWx1YXRlZCAhPT0gdHJ1ZSlcbiAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIGFuZCBpdGVtcyB3ZXJlIGV2YWx1YXRlZCAoaXQucHJvcHMgPT09IHRydWUgJiYgaXQuaXRlbXMgPT09IHRydWUpXG4gICAgICBpZiAoIW1lcmdlZCkgZ2VuLmlmKG5vdCh2YWxpZCkpXG4gICAgfSlcbiAgKVxuXG4gIGN4dC5yZXN1bHQoXG4gICAgdmFsaWQsXG4gICAgKCkgPT4gY3h0LnJlc2V0KCksXG4gICAgKCkgPT4gY3h0LmVycm9yKHRydWUpXG4gIClcbn1cbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi5cIlxuaW1wb3J0IHR5cGUge1xuICBBbnlTY2hlbWEsXG4gIFNjaGVtYVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIE1hY3JvS2V5d29yZERlZmluaXRpb24sXG4gIEZ1bmNLZXl3b3JkRGVmaW5pdGlvbixcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge18sIG5pbCwgbm90LCBzdHJpbmdpZnksIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGV9IGZyb20gXCIuLi9ydWxlc1wiXG5pbXBvcnQge2NhbGxWYWxpZGF0ZUNvZGV9IGZyb20gXCIuLi8uLi92b2NhYnVsYXJpZXMvY29kZVwiXG5pbXBvcnQge2V4dGVuZEVycm9yc30gZnJvbSBcIi4uL2Vycm9yc1wiXG5cbnR5cGUgS2V5d29yZENvbXBpbGF0aW9uUmVzdWx0ID0gQW55U2NoZW1hIHwgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbiB8IEFueVZhbGlkYXRlRnVuY3Rpb25cblxuZXhwb3J0IGZ1bmN0aW9uIG1hY3JvS2V5d29yZENvZGUoY3h0OiBLZXl3b3JkQ3h0LCBkZWY6IE1hY3JvS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICBjb25zdCBtYWNyb1NjaGVtYSA9IGRlZi5tYWNyby5jYWxsKGl0LnNlbGYsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdClcbiAgY29uc3Qgc2NoZW1hUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIG1hY3JvU2NoZW1hKVxuICBpZiAoaXQub3B0cy52YWxpZGF0ZVNjaGVtYSAhPT0gZmFsc2UpIGl0LnNlbGYudmFsaWRhdGVTY2hlbWEobWFjcm9TY2hlbWEsIHRydWUpXG5cbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGN4dC5zdWJzY2hlbWEoXG4gICAge1xuICAgICAgc2NoZW1hOiBtYWNyb1NjaGVtYSxcbiAgICAgIHNjaGVtYVBhdGg6IG5pbCxcbiAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgdG9wU2NoZW1hUmVmOiBzY2hlbWFSZWYsXG4gICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgIH0sXG4gICAgdmFsaWRcbiAgKVxuICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZnVuY0tleXdvcmRDb2RlKGN4dDogS2V5d29yZEN4dCwgZGVmOiBGdW5jS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwga2V5d29yZCwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsICRkYXRhLCBpdH0gPSBjeHRcbiAgY2hlY2tBc3luY0tleXdvcmQoaXQsIGRlZilcbiAgY29uc3QgdmFsaWRhdGUgPVxuICAgICEkZGF0YSAmJiBkZWYuY29tcGlsZSA/IGRlZi5jb21waWxlLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KSA6IGRlZi52YWxpZGF0ZVxuICBjb25zdCB2YWxpZGF0ZVJlZiA9IHVzZUtleXdvcmQoZ2VuLCBrZXl3b3JkLCB2YWxpZGF0ZSlcbiAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIilcbiAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlS2V5d29yZClcbiAgY3h0Lm9rKGRlZi52YWxpZCA/PyB2YWxpZClcblxuICBmdW5jdGlvbiB2YWxpZGF0ZUtleXdvcmQoKTogdm9pZCB7XG4gICAgaWYgKGRlZi5lcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICBhc3NpZ25WYWxpZCgpXG4gICAgICBpZiAoZGVmLm1vZGlmeWluZykgbW9kaWZ5RGF0YShjeHQpXG4gICAgICByZXBvcnRFcnJzKCgpID0+IGN4dC5lcnJvcigpKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBydWxlRXJycyA9IGRlZi5hc3luYyA/IHZhbGlkYXRlQXN5bmMoKSA6IHZhbGlkYXRlU3luYygpXG4gICAgICBpZiAoZGVmLm1vZGlmeWluZykgbW9kaWZ5RGF0YShjeHQpXG4gICAgICByZXBvcnRFcnJzKCgpID0+IGFkZEVycnMoY3h0LCBydWxlRXJycykpXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVBc3luYygpOiBOYW1lIHtcbiAgICBjb25zdCBydWxlRXJycyA9IGdlbi5sZXQoXCJydWxlRXJyc1wiLCBudWxsKVxuICAgIGdlbi50cnkoXG4gICAgICAoKSA9PiBhc3NpZ25WYWxpZChfYGF3YWl0IGApLFxuICAgICAgKGUpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5pZihcbiAgICAgICAgICBfYCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvciBhcyBOYW1lfWAsXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihydWxlRXJycywgX2Ake2V9LmVycm9yc2ApLFxuICAgICAgICAgICgpID0+IGdlbi50aHJvdyhlKVxuICAgICAgICApXG4gICAgKVxuICAgIHJldHVybiBydWxlRXJyc1xuICB9XG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVTeW5jKCk6IENvZGUge1xuICAgIGNvbnN0IHZhbGlkYXRlRXJycyA9IF9gJHt2YWxpZGF0ZVJlZn0uZXJyb3JzYFxuICAgIGdlbi5hc3NpZ24odmFsaWRhdGVFcnJzLCBudWxsKVxuICAgIGFzc2lnblZhbGlkKG5pbClcbiAgICByZXR1cm4gdmFsaWRhdGVFcnJzXG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25WYWxpZChfYXdhaXQ6IENvZGUgPSBkZWYuYXN5bmMgPyBfYGF3YWl0IGAgOiBuaWwpOiB2b2lkIHtcbiAgICBjb25zdCBwYXNzQ3h0ID0gaXQub3B0cy5wYXNzQ29udGV4dCA/IE4udGhpcyA6IE4uc2VsZlxuICAgIGNvbnN0IHBhc3NTY2hlbWEgPSAhKChcImNvbXBpbGVcIiBpbiBkZWYgJiYgISRkYXRhKSB8fCBkZWYuc2NoZW1hID09PSBmYWxzZSlcbiAgICBnZW4uYXNzaWduKFxuICAgICAgdmFsaWQsXG4gICAgICBfYCR7X2F3YWl0fSR7Y2FsbFZhbGlkYXRlQ29kZShjeHQsIHZhbGlkYXRlUmVmLCBwYXNzQ3h0LCBwYXNzU2NoZW1hKX1gLFxuICAgICAgZGVmLm1vZGlmeWluZ1xuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcG9ydEVycnMoZXJyb3JzOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgZ2VuLmlmKG5vdChkZWYudmFsaWQgPz8gdmFsaWQpLCBlcnJvcnMpXG4gIH1cbn1cblxuZnVuY3Rpb24gbW9kaWZ5RGF0YShjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgaXR9ID0gY3h0XG4gIGdlbi5pZihpdC5wYXJlbnREYXRhLCAoKSA9PiBnZW4uYXNzaWduKGRhdGEsIF9gJHtpdC5wYXJlbnREYXRhfVske2l0LnBhcmVudERhdGFQcm9wZXJ0eX1dYCkpXG59XG5cbmZ1bmN0aW9uIGFkZEVycnMoY3h0OiBLZXl3b3JkQ3h0LCBlcnJzOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IHtnZW59ID0gY3h0XG4gIGdlbi5pZihcbiAgICBfYEFycmF5LmlzQXJyYXkoJHtlcnJzfSlgLFxuICAgICgpID0+IHtcbiAgICAgIGdlblxuICAgICAgICAuYXNzaWduKE4udkVycm9ycywgX2Ake04udkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtOLnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApXG4gICAgICAgIC5hc3NpZ24oTi5lcnJvcnMsIF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGApXG4gICAgICBleHRlbmRFcnJvcnMoY3h0KVxuICAgIH0sXG4gICAgKCkgPT4gY3h0LmVycm9yKClcbiAgKVxufVxuXG5mdW5jdGlvbiBjaGVja0FzeW5jS2V5d29yZCh7c2NoZW1hRW52fTogU2NoZW1hT2JqQ3h0LCBkZWY6IEZ1bmNLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBpZiAoZGVmLmFzeW5jICYmICFzY2hlbWFFbnYuJGFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBrZXl3b3JkIGluIHN5bmMgc2NoZW1hXCIpXG59XG5cbmZ1bmN0aW9uIHVzZUtleXdvcmQoZ2VuOiBDb2RlR2VuLCBrZXl3b3JkOiBzdHJpbmcsIHJlc3VsdD86IEtleXdvcmRDb21waWxhdGlvblJlc3VsdCk6IE5hbWUge1xuICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihga2V5d29yZCBcIiR7a2V5d29yZH1cIiBmYWlsZWQgdG8gY29tcGlsZWApXG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcbiAgICBcImtleXdvcmRcIixcbiAgICB0eXBlb2YgcmVzdWx0ID09IFwiZnVuY3Rpb25cIiA/IHtyZWY6IHJlc3VsdH0gOiB7cmVmOiByZXN1bHQsIGNvZGU6IHN0cmluZ2lmeShyZXN1bHQpfVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZFNjaGVtYVR5cGUoXG4gIHNjaGVtYTogdW5rbm93bixcbiAgc2NoZW1hVHlwZTogSlNPTlR5cGVbXSxcbiAgYWxsb3dVbmRlZmluZWQgPSBmYWxzZVxuKTogYm9vbGVhbiB7XG4gIC8vIFRPRE8gYWRkIHRlc3RzXG4gIHJldHVybiAoXG4gICAgIXNjaGVtYVR5cGUubGVuZ3RoIHx8XG4gICAgc2NoZW1hVHlwZS5zb21lKChzdCkgPT5cbiAgICAgIHN0ID09PSBcImFycmF5XCJcbiAgICAgICAgPyBBcnJheS5pc0FycmF5KHNjaGVtYSlcbiAgICAgICAgOiBzdCA9PT0gXCJvYmplY3RcIlxuICAgICAgICA/IHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICA6IHR5cGVvZiBzY2hlbWEgPT0gc3QgfHwgKGFsbG93VW5kZWZpbmVkICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJ1bmRlZmluZWRcIilcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZFVzYWdlKFxuICB7c2NoZW1hLCBvcHRzLCBzZWxmLCBlcnJTY2hlbWFQYXRofTogU2NoZW1hT2JqQ3h0LFxuICBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIGtleXdvcmQ6IHN0cmluZ1xuKTogdm9pZCB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoQXJyYXkuaXNBcnJheShkZWYua2V5d29yZCkgPyAhZGVmLmtleXdvcmQuaW5jbHVkZXMoa2V5d29yZCkgOiBkZWYua2V5d29yZCAhPT0ga2V5d29yZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICB9XG5cbiAgY29uc3QgZGVwcyA9IGRlZi5kZXBlbmRlbmNpZXNcbiAgaWYgKGRlcHM/LnNvbWUoKGt3ZCkgPT4gIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzY2hlbWEsIGt3ZCkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBwYXJlbnQgc2NoZW1hIG11c3QgaGF2ZSBkZXBlbmRlbmNpZXMgb2YgJHtrZXl3b3JkfTogJHtkZXBzLmpvaW4oXCIsXCIpfWApXG4gIH1cblxuICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgY29uc3QgdmFsaWQgPSBkZWYudmFsaWRhdGVTY2hlbWEoc2NoZW1hW2tleXdvcmRdKVxuICAgIGlmICghdmFsaWQpIHtcbiAgICAgIGNvbnN0IG1zZyA9XG4gICAgICAgIGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIHZhbHVlIGlzIGludmFsaWQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cIjogYCArXG4gICAgICAgIHNlbGYuZXJyb3JzVGV4dChkZWYudmFsaWRhdGVTY2hlbWEuZXJyb3JzKVxuICAgICAgaWYgKG9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpIHNlbGYubG9nZ2VyLmVycm9yKG1zZylcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKG1zZylcbiAgICB9XG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7Xywgc3RyLCBnZXRQcm9wZXJ0eSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IHtlc2NhcGVGcmFnbWVudCwgZ2V0RXJyb3JQYXRoLCBUeXBlfSBmcm9tIFwiLi4vdXRpbFwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGV9IGZyb20gXCIuLi9ydWxlc1wiXG5cbmV4cG9ydCBpbnRlcmZhY2UgU3Vic2NoZW1hQ29udGV4dCB7XG4gIC8vIFRPRE8gdXNlIE9wdGlvbmFsPyBhbGlnbiB3aXRoIFNjaGVtQ3h0IHByb3BlcnR5IHR5cGVzXG4gIHNjaGVtYTogQW55U2NoZW1hXG4gIHNjaGVtYVBhdGg6IENvZGVcbiAgZXJyU2NoZW1hUGF0aDogc3RyaW5nXG4gIHRvcFNjaGVtYVJlZj86IENvZGVcbiAgZXJyb3JQYXRoPzogQ29kZVxuICBkYXRhTGV2ZWw/OiBudW1iZXJcbiAgZGF0YVR5cGVzPzogSlNPTlR5cGVbXVxuICBkYXRhPzogTmFtZVxuICBwYXJlbnREYXRhPzogTmFtZVxuICBwYXJlbnREYXRhUHJvcGVydHk/OiBDb2RlIHwgbnVtYmVyXG4gIGRhdGFOYW1lcz86IE5hbWVbXVxuICBkYXRhUGF0aEFycj86IChDb2RlIHwgbnVtYmVyKVtdXG4gIHByb3BlcnR5TmFtZT86IE5hbWVcbiAganRkRGlzY3JpbWluYXRvcj86IHN0cmluZ1xuICBqdGRNZXRhZGF0YT86IGJvb2xlYW5cbiAgY29tcG9zaXRlUnVsZT86IHRydWVcbiAgY3JlYXRlRXJyb3JzPzogYm9vbGVhblxuICBhbGxFcnJvcnM/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFN1YnNjaGVtYUFyZ3MgPSBQYXJ0aWFsPHtcbiAga2V5d29yZDogc3RyaW5nXG4gIHNjaGVtYVByb3A6IHN0cmluZyB8IG51bWJlclxuICBzY2hlbWE6IEFueVNjaGVtYVxuICBzY2hlbWFQYXRoOiBDb2RlXG4gIGVyclNjaGVtYVBhdGg6IHN0cmluZ1xuICB0b3BTY2hlbWFSZWY6IENvZGVcbiAgZGF0YTogTmFtZSB8IENvZGVcbiAgZGF0YVByb3A6IENvZGUgfCBzdHJpbmcgfCBudW1iZXJcbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdXG4gIGRlZmluZWRQcm9wZXJ0aWVzOiBTZXQ8c3RyaW5nPlxuICBwcm9wZXJ0eU5hbWU6IE5hbWVcbiAgZGF0YVByb3BUeXBlOiBUeXBlXG4gIGp0ZERpc2NyaW1pbmF0b3I6IHN0cmluZ1xuICBqdGRNZXRhZGF0YTogYm9vbGVhblxuICBjb21wb3NpdGVSdWxlOiB0cnVlXG4gIGNyZWF0ZUVycm9yczogYm9vbGVhblxuICBhbGxFcnJvcnM6IGJvb2xlYW5cbn0+XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTdWJzY2hlbWEoXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIHtrZXl3b3JkLCBzY2hlbWFQcm9wLCBzY2hlbWEsIHNjaGVtYVBhdGgsIGVyclNjaGVtYVBhdGgsIHRvcFNjaGVtYVJlZn06IFN1YnNjaGVtYUFyZ3Ncbik6IFN1YnNjaGVtYUNvbnRleHQge1xuICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkICYmIHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwia2V5d29yZFwiIGFuZCBcInNjaGVtYVwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpXG4gIH1cblxuICBpZiAoa2V5d29yZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc2NoID0gaXQuc2NoZW1hW2tleXdvcmRdXG4gICAgcmV0dXJuIHNjaGVtYVByb3AgPT09IHVuZGVmaW5lZFxuICAgICAgPyB7XG4gICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgc2NoZW1hUGF0aDogX2Ake2l0LnNjaGVtYVBhdGh9JHtnZXRQcm9wZXJ0eShrZXl3b3JkKX1gLFxuICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH1gLFxuICAgICAgICB9XG4gICAgICA6IHtcbiAgICAgICAgICBzY2hlbWE6IHNjaFtzY2hlbWFQcm9wXSxcbiAgICAgICAgICBzY2hlbWFQYXRoOiBfYCR7aXQuc2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfSR7Z2V0UHJvcGVydHkoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgICBlcnJTY2hlbWFQYXRoOiBgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9LyR7ZXNjYXBlRnJhZ21lbnQoc2NoZW1hUHJvcCl9YCxcbiAgICAgICAgfVxuICB9XG5cbiAgaWYgKHNjaGVtYSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCBlcnJTY2hlbWFQYXRoID09PSB1bmRlZmluZWQgfHwgdG9wU2NoZW1hUmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJzY2hlbWFQYXRoXCIsIFwiZXJyU2NoZW1hUGF0aFwiIGFuZCBcInRvcFNjaGVtYVJlZlwiIGFyZSByZXF1aXJlZCB3aXRoIFwic2NoZW1hXCInKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc2NoZW1hLFxuICAgICAgc2NoZW1hUGF0aCxcbiAgICAgIHRvcFNjaGVtYVJlZixcbiAgICAgIGVyclNjaGVtYVBhdGgsXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdlaXRoZXIgXCJrZXl3b3JkXCIgb3IgXCJzY2hlbWFcIiBtdXN0IGJlIHBhc3NlZCcpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFEYXRhKFxuICBzdWJzY2hlbWE6IFN1YnNjaGVtYUNvbnRleHQsXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIHtkYXRhUHJvcCwgZGF0YVByb3BUeXBlOiBkcFR5cGUsIGRhdGEsIGRhdGFUeXBlcywgcHJvcGVydHlOYW1lfTogU3Vic2NoZW1hQXJnc1xuKTogdm9pZCB7XG4gIGlmIChkYXRhICE9PSB1bmRlZmluZWQgJiYgZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignYm90aCBcImRhdGFcIiBhbmQgXCJkYXRhUHJvcFwiIHBhc3NlZCwgb25seSBvbmUgYWxsb3dlZCcpXG4gIH1cblxuICBjb25zdCB7Z2VufSA9IGl0XG5cbiAgaWYgKGRhdGFQcm9wICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCB7ZXJyb3JQYXRoLCBkYXRhUGF0aEFyciwgb3B0c30gPSBpdFxuICAgIGNvbnN0IG5leHREYXRhID0gZ2VuLmxldChcImRhdGFcIiwgX2Ake2l0LmRhdGF9JHtnZXRQcm9wZXJ0eShkYXRhUHJvcCl9YCwgdHJ1ZSlcbiAgICBkYXRhQ29udGV4dFByb3BzKG5leHREYXRhKVxuICAgIHN1YnNjaGVtYS5lcnJvclBhdGggPSBzdHJgJHtlcnJvclBhdGh9JHtnZXRFcnJvclBhdGgoZGF0YVByb3AsIGRwVHlwZSwgb3B0cy5qc1Byb3BlcnR5U3ludGF4KX1gXG4gICAgc3Vic2NoZW1hLnBhcmVudERhdGFQcm9wZXJ0eSA9IF9gJHtkYXRhUHJvcH1gXG4gICAgc3Vic2NoZW1hLmRhdGFQYXRoQXJyID0gWy4uLmRhdGFQYXRoQXJyLCBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5XVxuICB9XG5cbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IG5leHREYXRhID0gZGF0YSBpbnN0YW5jZW9mIE5hbWUgPyBkYXRhIDogZ2VuLmxldChcImRhdGFcIiwgZGF0YSwgdHJ1ZSkgLy8gcmVwbGFjZWFibGUgaWYgdXNlZCBvbmNlP1xuICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpXG4gICAgaWYgKHByb3BlcnR5TmFtZSAhPT0gdW5kZWZpbmVkKSBzdWJzY2hlbWEucHJvcGVydHlOYW1lID0gcHJvcGVydHlOYW1lXG4gICAgLy8gVE9ETyBzb21ldGhpbmcgaXMgcG9zc2libHkgd3JvbmcgaGVyZSB3aXRoIG5vdCBjaGFuZ2luZyBwYXJlbnREYXRhUHJvcGVydHkgYW5kIG5vdCBhcHBlbmRpbmcgZGF0YVBhdGhBcnJcbiAgfVxuXG4gIGlmIChkYXRhVHlwZXMpIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBkYXRhVHlwZXNcblxuICBmdW5jdGlvbiBkYXRhQ29udGV4dFByb3BzKF9uZXh0RGF0YTogTmFtZSk6IHZvaWQge1xuICAgIHN1YnNjaGVtYS5kYXRhID0gX25leHREYXRhXG4gICAgc3Vic2NoZW1hLmRhdGFMZXZlbCA9IGl0LmRhdGFMZXZlbCArIDFcbiAgICBzdWJzY2hlbWEuZGF0YVR5cGVzID0gW11cbiAgICBpdC5kZWZpbmVkUHJvcGVydGllcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG4gICAgc3Vic2NoZW1hLnBhcmVudERhdGEgPSBpdC5kYXRhXG4gICAgc3Vic2NoZW1hLmRhdGFOYW1lcyA9IFsuLi5pdC5kYXRhTmFtZXMsIF9uZXh0RGF0YV1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kU3Vic2NoZW1hTW9kZShcbiAgc3Vic2NoZW1hOiBTdWJzY2hlbWFDb250ZXh0LFxuICB7anRkRGlzY3JpbWluYXRvciwganRkTWV0YWRhdGEsIGNvbXBvc2l0ZVJ1bGUsIGNyZWF0ZUVycm9ycywgYWxsRXJyb3JzfTogU3Vic2NoZW1hQXJnc1xuKTogdm9pZCB7XG4gIGlmIChjb21wb3NpdGVSdWxlICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5jb21wb3NpdGVSdWxlID0gY29tcG9zaXRlUnVsZVxuICBpZiAoY3JlYXRlRXJyb3JzICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5jcmVhdGVFcnJvcnMgPSBjcmVhdGVFcnJvcnNcbiAgaWYgKGFsbEVycm9ycyAhPT0gdW5kZWZpbmVkKSBzdWJzY2hlbWEuYWxsRXJyb3JzID0gYWxsRXJyb3JzXG4gIHN1YnNjaGVtYS5qdGREaXNjcmltaW5hdG9yID0ganRkRGlzY3JpbWluYXRvciAvLyBub3QgaW5oZXJpdGVkXG4gIHN1YnNjaGVtYS5qdGRNZXRhZGF0YSA9IGp0ZE1ldGFkYXRhIC8vIG5vdCBpbmhlcml0ZWRcbn1cbiIsICIndXNlIHN0cmljdCc7XG5cbi8vIGRvIG5vdCBlZGl0IC5qcyBmaWxlcyBkaXJlY3RseSAtIGVkaXQgc3JjL2luZGV4LmpzdFxuXG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIGlmIChhID09PSBiKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAoYSAmJiBiICYmIHR5cGVvZiBhID09ICdvYmplY3QnICYmIHR5cGVvZiBiID09ICdvYmplY3QnKSB7XG4gICAgaWYgKGEuY29uc3RydWN0b3IgIT09IGIuY29uc3RydWN0b3IpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBsZW5ndGgsIGksIGtleXM7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYSkpIHtcbiAgICAgIGxlbmd0aCA9IGEubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCAhPSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgICBpZiAoIWVxdWFsKGFbaV0sIGJbaV0pKSByZXR1cm4gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuXG4gICAgaWYgKGEuY29uc3RydWN0b3IgPT09IFJlZ0V4cCkgcmV0dXJuIGEuc291cmNlID09PSBiLnNvdXJjZSAmJiBhLmZsYWdzID09PSBiLmZsYWdzO1xuICAgIGlmIChhLnZhbHVlT2YgIT09IE9iamVjdC5wcm90b3R5cGUudmFsdWVPZikgcmV0dXJuIGEudmFsdWVPZigpID09PSBiLnZhbHVlT2YoKTtcbiAgICBpZiAoYS50b1N0cmluZyAhPT0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZykgcmV0dXJuIGEudG9TdHJpbmcoKSA9PT0gYi50b1N0cmluZygpO1xuXG4gICAga2V5cyA9IE9iamVjdC5rZXlzKGEpO1xuICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIGlmIChsZW5ndGggIT09IE9iamVjdC5rZXlzKGIpLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KVxuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwga2V5c1tpXSkpIHJldHVybiBmYWxzZTtcblxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tICE9PSAwOykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyB0cnVlIGlmIGJvdGggTmFOLCBmYWxzZSBvdGhlcndpc2VcbiAgcmV0dXJuIGEhPT1hICYmIGIhPT1iO1xufTtcbiIsICIndXNlIHN0cmljdCc7XG5cbnZhciB0cmF2ZXJzZSA9IG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNjaGVtYSwgb3B0cywgY2IpIHtcbiAgLy8gTGVnYWN5IHN1cHBvcnQgZm9yIHYwLjMuMSBhbmQgZWFybGllci5cbiAgaWYgKHR5cGVvZiBvcHRzID09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG5cbiAgY2IgPSBvcHRzLmNiIHx8IGNiO1xuICB2YXIgcHJlID0gKHR5cGVvZiBjYiA9PSAnZnVuY3Rpb24nKSA/IGNiIDogY2IucHJlIHx8IGZ1bmN0aW9uKCkge307XG4gIHZhciBwb3N0ID0gY2IucG9zdCB8fCBmdW5jdGlvbigpIHt9O1xuXG4gIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwgJycsIHNjaGVtYSk7XG59O1xuXG5cbnRyYXZlcnNlLmtleXdvcmRzID0ge1xuICBhZGRpdGlvbmFsSXRlbXM6IHRydWUsXG4gIGl0ZW1zOiB0cnVlLFxuICBjb250YWluczogdHJ1ZSxcbiAgYWRkaXRpb25hbFByb3BlcnRpZXM6IHRydWUsXG4gIHByb3BlcnR5TmFtZXM6IHRydWUsXG4gIG5vdDogdHJ1ZSxcbiAgaWY6IHRydWUsXG4gIHRoZW46IHRydWUsXG4gIGVsc2U6IHRydWVcbn07XG5cbnRyYXZlcnNlLmFycmF5S2V5d29yZHMgPSB7XG4gIGl0ZW1zOiB0cnVlLFxuICBhbGxPZjogdHJ1ZSxcbiAgYW55T2Y6IHRydWUsXG4gIG9uZU9mOiB0cnVlXG59O1xuXG50cmF2ZXJzZS5wcm9wc0tleXdvcmRzID0ge1xuICAkZGVmczogdHJ1ZSxcbiAgZGVmaW5pdGlvbnM6IHRydWUsXG4gIHByb3BlcnRpZXM6IHRydWUsXG4gIHBhdHRlcm5Qcm9wZXJ0aWVzOiB0cnVlLFxuICBkZXBlbmRlbmNpZXM6IHRydWVcbn07XG5cbnRyYXZlcnNlLnNraXBLZXl3b3JkcyA9IHtcbiAgZGVmYXVsdDogdHJ1ZSxcbiAgZW51bTogdHJ1ZSxcbiAgY29uc3Q6IHRydWUsXG4gIHJlcXVpcmVkOiB0cnVlLFxuICBtYXhpbXVtOiB0cnVlLFxuICBtaW5pbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNYXhpbXVtOiB0cnVlLFxuICBleGNsdXNpdmVNaW5pbXVtOiB0cnVlLFxuICBtdWx0aXBsZU9mOiB0cnVlLFxuICBtYXhMZW5ndGg6IHRydWUsXG4gIG1pbkxlbmd0aDogdHJ1ZSxcbiAgcGF0dGVybjogdHJ1ZSxcbiAgZm9ybWF0OiB0cnVlLFxuICBtYXhJdGVtczogdHJ1ZSxcbiAgbWluSXRlbXM6IHRydWUsXG4gIHVuaXF1ZUl0ZW1zOiB0cnVlLFxuICBtYXhQcm9wZXJ0aWVzOiB0cnVlLFxuICBtaW5Qcm9wZXJ0aWVzOiB0cnVlXG59O1xuXG5cbmZ1bmN0aW9uIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCkge1xuICBpZiAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkge1xuICAgIHByZShzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICAgIGZvciAodmFyIGtleSBpbiBzY2hlbWEpIHtcbiAgICAgIHZhciBzY2ggPSBzY2hlbWFba2V5XTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkpIHtcbiAgICAgICAgaWYgKGtleSBpbiB0cmF2ZXJzZS5hcnJheUtleXdvcmRzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaT0wOyBpPHNjaC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtpXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2UucHJvcHNLZXl3b3Jkcykge1xuICAgICAgICBpZiAoc2NoICYmIHR5cGVvZiBzY2ggPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIHNjaClcbiAgICAgICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaFtwcm9wXSwganNvblB0ciArICcvJyArIGtleSArICcvJyArIGVzY2FwZUpzb25QdHIocHJvcCksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hLCBwcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgaW4gdHJhdmVyc2Uua2V5d29yZHMgfHwgKG9wdHMuYWxsS2V5cyAmJiAhKGtleSBpbiB0cmF2ZXJzZS5za2lwS2V5d29yZHMpKSkge1xuICAgICAgICBfdHJhdmVyc2Uob3B0cywgcHJlLCBwb3N0LCBzY2gsIGpzb25QdHIgKyAnLycgKyBrZXksIHJvb3RTY2hlbWEsIGpzb25QdHIsIGtleSwgc2NoZW1hKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9zdChzY2hlbWEsIGpzb25QdHIsIHJvb3RTY2hlbWEsIHBhcmVudEpzb25QdHIsIHBhcmVudEtleXdvcmQsIHBhcmVudFNjaGVtYSwga2V5SW5kZXgpO1xuICB9XG59XG5cblxuZnVuY3Rpb24gZXNjYXBlSnNvblB0cihzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csICd+MCcpLnJlcGxhY2UoL1xcLy9nLCAnfjEnKTtcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hLCBBbnlTY2hlbWFPYmplY3QsIFVyaVJlc29sdmVyfSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUgQWp2IGZyb20gXCIuLi9hanZcIlxuaW1wb3J0IHR5cGUge1VSSUNvbXBvbmVudH0gZnJvbSBcImZhc3QtdXJpXCJcbmltcG9ydCB7ZWFjaEl0ZW19IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0ICogYXMgZXF1YWwgZnJvbSBcImZhc3QtZGVlcC1lcXVhbFwiXG5pbXBvcnQgKiBhcyB0cmF2ZXJzZSBmcm9tIFwianNvbi1zY2hlbWEtdHJhdmVyc2VcIlxuXG4vLyB0aGUgaGFzaCBvZiBsb2NhbCByZWZlcmVuY2VzIGluc2lkZSB0aGUgc2NoZW1hIChjcmVhdGVkIGJ5IGdldFNjaGVtYVJlZnMpLCB1c2VkIGZvciBpbmxpbmUgcmVzb2x1dGlvblxuZXhwb3J0IHR5cGUgTG9jYWxSZWZzID0ge1tSZWYgaW4gc3RyaW5nXT86IEFueVNjaGVtYU9iamVjdH1cblxuLy8gVE9ETyByZWZhY3RvciB0byB1c2Uga2V5d29yZCBkZWZpbml0aW9uc1xuY29uc3QgU0lNUExFX0lOTElORUQgPSBuZXcgU2V0KFtcbiAgXCJ0eXBlXCIsXG4gIFwiZm9ybWF0XCIsXG4gIFwicGF0dGVyblwiLFxuICBcIm1heExlbmd0aFwiLFxuICBcIm1pbkxlbmd0aFwiLFxuICBcIm1heFByb3BlcnRpZXNcIixcbiAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gIFwibWF4SXRlbXNcIixcbiAgXCJtaW5JdGVtc1wiLFxuICBcIm1heGltdW1cIixcbiAgXCJtaW5pbXVtXCIsXG4gIFwidW5pcXVlSXRlbXNcIixcbiAgXCJtdWx0aXBsZU9mXCIsXG4gIFwicmVxdWlyZWRcIixcbiAgXCJlbnVtXCIsXG4gIFwiY29uc3RcIixcbl0pXG5cbmV4cG9ydCBmdW5jdGlvbiBpbmxpbmVSZWYoc2NoZW1hOiBBbnlTY2hlbWEsIGxpbWl0OiBib29sZWFuIHwgbnVtYmVyID0gdHJ1ZSk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHRydWVcbiAgaWYgKGxpbWl0ID09PSB0cnVlKSByZXR1cm4gIWhhc1JlZihzY2hlbWEpXG4gIGlmICghbGltaXQpIHJldHVybiBmYWxzZVxuICByZXR1cm4gY291bnRLZXlzKHNjaGVtYSkgPD0gbGltaXRcbn1cblxuY29uc3QgUkVGX0tFWVdPUkRTID0gbmV3IFNldChbXG4gIFwiJHJlZlwiLFxuICBcIiRyZWN1cnNpdmVSZWZcIixcbiAgXCIkcmVjdXJzaXZlQW5jaG9yXCIsXG4gIFwiJGR5bmFtaWNSZWZcIixcbiAgXCIkZHluYW1pY0FuY2hvclwiLFxuXSlcblxuZnVuY3Rpb24gaGFzUmVmKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0KTogYm9vbGVhbiB7XG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmIChSRUZfS0VZV09SRFMuaGFzKGtleSkpIHJldHVybiB0cnVlXG4gICAgY29uc3Qgc2NoID0gc2NoZW1hW2tleV1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2gpICYmIHNjaC5zb21lKGhhc1JlZikpIHJldHVybiB0cnVlXG4gICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIiAmJiBoYXNSZWYoc2NoKSkgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gY291bnRLZXlzKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0KTogbnVtYmVyIHtcbiAgbGV0IGNvdW50ID0gMFxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoa2V5ID09PSBcIiRyZWZcIikgcmV0dXJuIEluZmluaXR5XG4gICAgY291bnQrK1xuICAgIGlmIChTSU1QTEVfSU5MSU5FRC5oYXMoa2V5KSkgY29udGludWVcbiAgICBpZiAodHlwZW9mIHNjaGVtYVtrZXldID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGVhY2hJdGVtKHNjaGVtYVtrZXldLCAoc2NoKSA9PiAoY291bnQgKz0gY291bnRLZXlzKHNjaCkpKVxuICAgIH1cbiAgICBpZiAoY291bnQgPT09IEluZmluaXR5KSByZXR1cm4gSW5maW5pdHlcbiAgfVxuICByZXR1cm4gY291bnRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEZ1bGxQYXRoKHJlc29sdmVyOiBVcmlSZXNvbHZlciwgaWQgPSBcIlwiLCBub3JtYWxpemU/OiBib29sZWFuKTogc3RyaW5nIHtcbiAgaWYgKG5vcm1hbGl6ZSAhPT0gZmFsc2UpIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gIGNvbnN0IHAgPSByZXNvbHZlci5wYXJzZShpZClcbiAgcmV0dXJuIF9nZXRGdWxsUGF0aChyZXNvbHZlciwgcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9nZXRGdWxsUGF0aChyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIHA6IFVSSUNvbXBvbmVudCk6IHN0cmluZyB7XG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSByZXNvbHZlci5zZXJpYWxpemUocClcbiAgcmV0dXJuIHNlcmlhbGl6ZWQuc3BsaXQoXCIjXCIpWzBdICsgXCIjXCJcbn1cblxuY29uc3QgVFJBSUxJTkdfU0xBU0hfSEFTSCA9IC8jXFwvPyQvXG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplSWQoaWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB7XG4gIHJldHVybiBpZCA/IGlkLnJlcGxhY2UoVFJBSUxJTkdfU0xBU0hfSEFTSCwgXCJcIikgOiBcIlwiXG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlVXJsKHJlc29sdmVyOiBVcmlSZXNvbHZlciwgYmFzZUlkOiBzdHJpbmcsIGlkOiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZCA9IG5vcm1hbGl6ZUlkKGlkKVxuICByZXR1cm4gcmVzb2x2ZXIucmVzb2x2ZShiYXNlSWQsIGlkKVxufVxuXG5jb25zdCBBTkNIT1IgPSAvXlthLXpfXVstYS16MC05Ll9dKiQvaVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hUmVmcyh0aGlzOiBBanYsIHNjaGVtYTogQW55U2NoZW1hLCBiYXNlSWQ6IHN0cmluZyk6IExvY2FsUmVmcyB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4ge31cbiAgY29uc3Qge3NjaGVtYUlkLCB1cmlSZXNvbHZlcn0gPSB0aGlzLm9wdHNcbiAgY29uc3Qgc2NoSWQgPSBub3JtYWxpemVJZChzY2hlbWFbc2NoZW1hSWRdIHx8IGJhc2VJZClcbiAgY29uc3QgYmFzZUlkczoge1tKc29uUHRyIGluIHN0cmluZ10/OiBzdHJpbmd9ID0ge1wiXCI6IHNjaElkfVxuICBjb25zdCBwYXRoUHJlZml4ID0gZ2V0RnVsbFBhdGgodXJpUmVzb2x2ZXIsIHNjaElkLCBmYWxzZSlcbiAgY29uc3QgbG9jYWxSZWZzOiBMb2NhbFJlZnMgPSB7fVxuICBjb25zdCBzY2hlbWFSZWZzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoKVxuXG4gIHRyYXZlcnNlKHNjaGVtYSwge2FsbEtleXM6IHRydWV9LCAoc2NoLCBqc29uUHRyLCBfLCBwYXJlbnRKc29uUHRyKSA9PiB7XG4gICAgaWYgKHBhcmVudEpzb25QdHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gICAgY29uc3QgZnVsbFBhdGggPSBwYXRoUHJlZml4ICsganNvblB0clxuICAgIGxldCBpbm5lckJhc2VJZCA9IGJhc2VJZHNbcGFyZW50SnNvblB0cl1cbiAgICBpZiAodHlwZW9mIHNjaFtzY2hlbWFJZF0gPT0gXCJzdHJpbmdcIikgaW5uZXJCYXNlSWQgPSBhZGRSZWYuY2FsbCh0aGlzLCBzY2hbc2NoZW1hSWRdKVxuICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kYW5jaG9yKVxuICAgIGFkZEFuY2hvci5jYWxsKHRoaXMsIHNjaC4kZHluYW1pY0FuY2hvcilcbiAgICBiYXNlSWRzW2pzb25QdHJdID0gaW5uZXJCYXNlSWRcblxuICAgIGZ1bmN0aW9uIGFkZFJlZih0aGlzOiBBanYsIHJlZjogc3RyaW5nKTogc3RyaW5nIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICAgIGNvbnN0IF9yZXNvbHZlID0gdGhpcy5vcHRzLnVyaVJlc29sdmVyLnJlc29sdmVcbiAgICAgIHJlZiA9IG5vcm1hbGl6ZUlkKGlubmVyQmFzZUlkID8gX3Jlc29sdmUoaW5uZXJCYXNlSWQsIHJlZikgOiByZWYpXG4gICAgICBpZiAoc2NoZW1hUmVmcy5oYXMocmVmKSkgdGhyb3cgYW1iaWd1b3MocmVmKVxuICAgICAgc2NoZW1hUmVmcy5hZGQocmVmKVxuICAgICAgbGV0IHNjaE9yUmVmID0gdGhpcy5yZWZzW3JlZl1cbiAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikgc2NoT3JSZWYgPSB0aGlzLnJlZnNbc2NoT3JSZWZdXG4gICAgICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIHNjaE9yUmVmLnNjaGVtYSwgcmVmKVxuICAgICAgfSBlbHNlIGlmIChyZWYgIT09IG5vcm1hbGl6ZUlkKGZ1bGxQYXRoKSkge1xuICAgICAgICBpZiAocmVmWzBdID09PSBcIiNcIikge1xuICAgICAgICAgIGNoZWNrQW1iaWd1b3NSZWYoc2NoLCBsb2NhbFJlZnNbcmVmXSwgcmVmKVxuICAgICAgICAgIGxvY2FsUmVmc1tyZWZdID0gc2NoXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZWZzW3JlZl0gPSBmdWxsUGF0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVmXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkQW5jaG9yKHRoaXM6IEFqdiwgYW5jaG9yOiB1bmtub3duKTogdm9pZCB7XG4gICAgICBpZiAodHlwZW9mIGFuY2hvciA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGlmICghQU5DSE9SLnRlc3QoYW5jaG9yKSkgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFuY2hvciBcIiR7YW5jaG9yfVwiYClcbiAgICAgICAgYWRkUmVmLmNhbGwodGhpcywgYCMke2FuY2hvcn1gKVxuICAgICAgfVxuICAgIH1cbiAgfSlcblxuICByZXR1cm4gbG9jYWxSZWZzXG5cbiAgZnVuY3Rpb24gY2hlY2tBbWJpZ3Vvc1JlZihzY2gxOiBBbnlTY2hlbWEsIHNjaDI6IEFueVNjaGVtYSB8IHVuZGVmaW5lZCwgcmVmOiBzdHJpbmcpOiB2b2lkIHtcbiAgICBpZiAoc2NoMiAhPT0gdW5kZWZpbmVkICYmICFlcXVhbChzY2gxLCBzY2gyKSkgdGhyb3cgYW1iaWd1b3MocmVmKVxuICB9XG5cbiAgZnVuY3Rpb24gYW1iaWd1b3MocmVmOiBzdHJpbmcpOiBFcnJvciB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcihgcmVmZXJlbmNlIFwiJHtyZWZ9XCIgcmVzb2x2ZXMgdG8gbW9yZSB0aGFuIG9uZSBzY2hlbWFgKVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgS2V5d29yZEVycm9yQ3h0LFxuICBLZXl3b3JkQ3h0UGFyYW1zLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHR5cGUge0luc3RhbmNlT3B0aW9uc30gZnJvbSBcIi4uLy4uL2NvcmVcIlxuaW1wb3J0IHtib29sT3JFbXB0eVNjaGVtYSwgdG9wQm9vbE9yRW1wdHlTY2hlbWF9IGZyb20gXCIuL2Jvb2xTY2hlbWFcIlxuaW1wb3J0IHtjb2VyY2VBbmRDaGVja0RhdGFUeXBlLCBnZXRTY2hlbWFUeXBlc30gZnJvbSBcIi4vZGF0YVR5cGVcIlxuaW1wb3J0IHtzaG91bGRVc2VHcm91cCwgc2hvdWxkVXNlUnVsZX0gZnJvbSBcIi4vYXBwbGljYWJpbGl0eVwiXG5pbXBvcnQge2NoZWNrRGF0YVR5cGUsIGNoZWNrRGF0YVR5cGVzLCByZXBvcnRUeXBlRXJyb3IsIERhdGFUeXBlfSBmcm9tIFwiLi9kYXRhVHlwZVwiXG5pbXBvcnQge2Fzc2lnbkRlZmF1bHRzfSBmcm9tIFwiLi9kZWZhdWx0c1wiXG5pbXBvcnQge2Z1bmNLZXl3b3JkQ29kZSwgbWFjcm9LZXl3b3JkQ29kZSwgdmFsaWRhdGVLZXl3b3JkVXNhZ2UsIHZhbGlkU2NoZW1hVHlwZX0gZnJvbSBcIi4va2V5d29yZFwiXG5pbXBvcnQge2dldFN1YnNjaGVtYSwgZXh0ZW5kU3Vic2NoZW1hRGF0YSwgU3Vic2NoZW1hQXJncywgZXh0ZW5kU3Vic2NoZW1hTW9kZX0gZnJvbSBcIi4vc3Vic2NoZW1hXCJcbmltcG9ydCB7XywgbmlsLCBzdHIsIG9yLCBub3QsIGdldFByb3BlcnR5LCBCbG9jaywgQ29kZSwgTmFtZSwgQ29kZUdlbn0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uL25hbWVzXCJcbmltcG9ydCB7cmVzb2x2ZVVybH0gZnJvbSBcIi4uL3Jlc29sdmVcIlxuaW1wb3J0IHtcbiAgc2NoZW1hUmVmT3JWYWwsXG4gIHNjaGVtYUhhc1J1bGVzQnV0UmVmLFxuICBjaGVja1Vua25vd25SdWxlcyxcbiAgY2hlY2tTdHJpY3RNb2RlLFxuICB1bmVzY2FwZUpzb25Qb2ludGVyLFxuICBtZXJnZUV2YWx1YXRlZCxcbn0gZnJvbSBcIi4uL3V0aWxcIlxuaW1wb3J0IHR5cGUge0pTT05UeXBlLCBSdWxlLCBSdWxlR3JvdXB9IGZyb20gXCIuLi9ydWxlc1wiXG5pbXBvcnQge1xuICBFcnJvclBhdGhzLFxuICByZXBvcnRFcnJvcixcbiAgcmVwb3J0RXh0cmFFcnJvcixcbiAgcmVzZXRFcnJvcnNDb3VudCxcbiAga2V5d29yZCREYXRhRXJyb3IsXG59IGZyb20gXCIuLi9lcnJvcnNcIlxuXG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSBnZW5lcmF0ZXMgdmFsaWRhdGlvbiBmdW5jdGlvbiwgc3Vic2NoZW1hQ29kZSAoYmVsb3cpIGlzIHVzZWQgZm9yIHN1YnNjaGVtYXNcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShpdDogU2NoZW1hQ3h0KTogdm9pZCB7XG4gIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICBjaGVja0tleXdvcmRzKGl0KVxuICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgIHRvcFNjaGVtYU9iakNvZGUoaXQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQpKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUZ1bmN0aW9uKFxuICB7Z2VuLCB2YWxpZGF0ZU5hbWUsIHNjaGVtYSwgc2NoZW1hRW52LCBvcHRzfTogU2NoZW1hQ3h0LFxuICBib2R5OiBCbG9ja1xuKTogdm9pZCB7XG4gIGlmIChvcHRzLmNvZGUuZXM1KSB7XG4gICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBfYCR7Ti5kYXRhfSwgJHtOLnZhbEN4dH1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PiB7XG4gICAgICBnZW4uY29kZShfYFwidXNlIHN0cmljdFwiOyAke2Z1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKX1gKVxuICAgICAgZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuLCBvcHRzKVxuICAgICAgZ2VuLmNvZGUoYm9keSlcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGdlbi5mdW5jKHZhbGlkYXRlTmFtZSwgX2Ake04uZGF0YX0sICR7ZGVzdHJ1Y3R1cmVWYWxDeHQob3B0cyl9YCwgc2NoZW1hRW52LiRhc3luYywgKCkgPT5cbiAgICAgIGdlbi5jb2RlKGZ1bmNTb3VyY2VVcmwoc2NoZW1hLCBvcHRzKSkuY29kZShib2R5KVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXN0cnVjdHVyZVZhbEN4dChvcHRzOiBJbnN0YW5jZU9wdGlvbnMpOiBDb2RlIHtcbiAgcmV0dXJuIF9geyR7Ti5pbnN0YW5jZVBhdGh9PVwiXCIsICR7Ti5wYXJlbnREYXRhfSwgJHtOLnBhcmVudERhdGFQcm9wZXJ0eX0sICR7Ti5yb290RGF0YX09JHtcbiAgICBOLmRhdGFcbiAgfSR7b3B0cy5keW5hbWljUmVmID8gX2AsICR7Ti5keW5hbWljQW5jaG9yc309e31gIDogbmlsfX09e31gXG59XG5cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0RVM1KGdlbjogQ29kZUdlbiwgb3B0czogSW5zdGFuY2VPcHRpb25zKTogdm9pZCB7XG4gIGdlbi5pZihcbiAgICBOLnZhbEN4dCxcbiAgICAoKSA9PiB7XG4gICAgICBnZW4udmFyKE4uaW5zdGFuY2VQYXRoLCBfYCR7Ti52YWxDeHR9LiR7Ti5pbnN0YW5jZVBhdGh9YClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhLCBfYCR7Ti52YWxDeHR9LiR7Ti5wYXJlbnREYXRhfWApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YVByb3BlcnR5LCBfYCR7Ti52YWxDeHR9LiR7Ti5wYXJlbnREYXRhUHJvcGVydHl9YClcbiAgICAgIGdlbi52YXIoTi5yb290RGF0YSwgX2Ake04udmFsQ3h0fS4ke04ucm9vdERhdGF9YClcbiAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpIGdlbi52YXIoTi5keW5hbWljQW5jaG9ycywgX2Ake04udmFsQ3h0fS4ke04uZHluYW1pY0FuY2hvcnN9YClcbiAgICB9LFxuICAgICgpID0+IHtcbiAgICAgIGdlbi52YXIoTi5pbnN0YW5jZVBhdGgsIF9gXCJcImApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YSwgX2B1bmRlZmluZWRgKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGFQcm9wZXJ0eSwgX2B1bmRlZmluZWRgKVxuICAgICAgZ2VuLnZhcihOLnJvb3REYXRhLCBOLmRhdGEpXG4gICAgICBpZiAob3B0cy5keW5hbWljUmVmKSBnZW4udmFyKE4uZHluYW1pY0FuY2hvcnMsIF9ge31gKVxuICAgIH1cbiAgKVxufVxuXG5mdW5jdGlvbiB0b3BTY2hlbWFPYmpDb2RlKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgb3B0cywgZ2VufSA9IGl0XG4gIHZhbGlkYXRlRnVuY3Rpb24oaXQsICgpID0+IHtcbiAgICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpIGNvbW1lbnRLZXl3b3JkKGl0KVxuICAgIGNoZWNrTm9EZWZhdWx0KGl0KVxuICAgIGdlbi5sZXQoTi52RXJyb3JzLCBudWxsKVxuICAgIGdlbi5sZXQoTi5lcnJvcnMsIDApXG4gICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpIHJlc2V0RXZhbHVhdGVkKGl0KVxuICAgIHR5cGVBbmRLZXl3b3JkcyhpdClcbiAgICByZXR1cm5SZXN1bHRzKGl0KVxuICB9KVxuICByZXR1cm5cbn1cblxuZnVuY3Rpb24gcmVzZXRFdmFsdWF0ZWQoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICAvLyBUT0RPIG1heWJlIHNvbWUgaG9vayB0byBleGVjdXRlIGl0IGluIHRoZSBlbmQgdG8gY2hlY2sgd2hldGhlciBwcm9wcy9pdGVtcyBhcmUgTmFtZSwgYXMgaW4gYXNzaWduRXZhbHVhdGVkXG4gIGNvbnN0IHtnZW4sIHZhbGlkYXRlTmFtZX0gPSBpdFxuICBpdC5ldmFsdWF0ZWQgPSBnZW4uY29uc3QoXCJldmFsdWF0ZWRcIiwgX2Ake3ZhbGlkYXRlTmFtZX0uZXZhbHVhdGVkYClcbiAgZ2VuLmlmKF9gJHtpdC5ldmFsdWF0ZWR9LmR5bmFtaWNQcm9wc2AsICgpID0+IGdlbi5hc3NpZ24oX2Ake2l0LmV2YWx1YXRlZH0ucHJvcHNgLCBfYHVuZGVmaW5lZGApKVxuICBnZW4uaWYoX2Ake2l0LmV2YWx1YXRlZH0uZHluYW1pY0l0ZW1zYCwgKCkgPT4gZ2VuLmFzc2lnbihfYCR7aXQuZXZhbHVhdGVkfS5pdGVtc2AsIF9gdW5kZWZpbmVkYCkpXG59XG5cbmZ1bmN0aW9uIGZ1bmNTb3VyY2VVcmwoc2NoZW1hOiBBbnlTY2hlbWEsIG9wdHM6IEluc3RhbmNlT3B0aW9ucyk6IENvZGUge1xuICBjb25zdCBzY2hJZCA9IHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbb3B0cy5zY2hlbWFJZF1cbiAgcmV0dXJuIHNjaElkICYmIChvcHRzLmNvZGUuc291cmNlIHx8IG9wdHMuY29kZS5wcm9jZXNzKSA/IF9gLyojIHNvdXJjZVVSTD0ke3NjaElkfSAqL2AgOiBuaWxcbn1cblxuLy8gc2NoZW1hIGNvbXBpbGF0aW9uIC0gdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHJlY3Vyc2l2ZWx5IHRvIGdlbmVyYXRlIGNvZGUgZm9yIHN1Yi1zY2hlbWFzXG5mdW5jdGlvbiBzdWJzY2hlbWFDb2RlKGl0OiBTY2hlbWFDeHQsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gIGlmIChpc1NjaGVtYU9iaihpdCkpIHtcbiAgICBjaGVja0tleXdvcmRzKGl0KVxuICAgIGlmIChzY2hlbWFDeHRIYXNSdWxlcyhpdCkpIHtcbiAgICAgIHN1YlNjaGVtYU9iakNvZGUoaXQsIHZhbGlkKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG4gIGJvb2xPckVtcHR5U2NoZW1hKGl0LCB2YWxpZClcbn1cblxuZnVuY3Rpb24gc2NoZW1hQ3h0SGFzUnVsZXMoe3NjaGVtYSwgc2VsZn06IFNjaGVtYUN4dCk6IGJvb2xlYW4ge1xuICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuICFzY2hlbWFcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSBpZiAoc2VsZi5SVUxFUy5hbGxba2V5XSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGlzU2NoZW1hT2JqKGl0OiBTY2hlbWFDeHQpOiBpdCBpcyBTY2hlbWFPYmpDeHQge1xuICByZXR1cm4gdHlwZW9mIGl0LnNjaGVtYSAhPSBcImJvb2xlYW5cIlxufVxuXG5mdW5jdGlvbiBzdWJTY2hlbWFPYmpDb2RlKGl0OiBTY2hlbWFPYmpDeHQsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIGdlbiwgb3B0c30gPSBpdFxuICBpZiAob3B0cy4kY29tbWVudCAmJiBzY2hlbWEuJGNvbW1lbnQpIGNvbW1lbnRLZXl3b3JkKGl0KVxuICB1cGRhdGVDb250ZXh0KGl0KVxuICBjaGVja0FzeW5jU2NoZW1hKGl0KVxuICBjb25zdCBlcnJzQ291bnQgPSBnZW4uY29uc3QoXCJfZXJyc1wiLCBOLmVycm9ycylcbiAgdHlwZUFuZEtleXdvcmRzKGl0LCBlcnJzQ291bnQpXG4gIC8vIFRPRE8gdmFyXG4gIGdlbi52YXIodmFsaWQsIF9gJHtlcnJzQ291bnR9ID09PSAke04uZXJyb3JzfWApXG59XG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjaGVja1Vua25vd25SdWxlcyhpdClcbiAgY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQpXG59XG5cbmZ1bmN0aW9uIHR5cGVBbmRLZXl3b3JkcyhpdDogU2NoZW1hT2JqQ3h0LCBlcnJzQ291bnQ/OiBOYW1lKTogdm9pZCB7XG4gIGlmIChpdC5vcHRzLmp0ZCkgcmV0dXJuIHNjaGVtYUtleXdvcmRzKGl0LCBbXSwgZmFsc2UsIGVycnNDb3VudClcbiAgY29uc3QgdHlwZXMgPSBnZXRTY2hlbWFUeXBlcyhpdC5zY2hlbWEpXG4gIGNvbnN0IGNoZWNrZWRUeXBlcyA9IGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQsIHR5cGVzKVxuICBzY2hlbWFLZXl3b3JkcyhpdCwgdHlwZXMsICFjaGVja2VkVHlwZXMsIGVycnNDb3VudClcbn1cblxuZnVuY3Rpb24gY2hlY2tSZWZzQW5kS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBlcnJTY2hlbWFQYXRoLCBvcHRzLCBzZWxmfSA9IGl0XG4gIGlmIChzY2hlbWEuJHJlZiAmJiBvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiAmJiBzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHNlbGYuUlVMRVMpKSB7XG4gICAgc2VsZi5sb2dnZXIud2FybihgJHJlZjoga2V5d29yZHMgaWdub3JlZCBpbiBzY2hlbWEgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImApXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tOb0RlZmF1bHQoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBvcHRzfSA9IGl0XG4gIGlmIChzY2hlbWEuZGVmYXVsdCAhPT0gdW5kZWZpbmVkICYmIG9wdHMudXNlRGVmYXVsdHMgJiYgb3B0cy5zdHJpY3RTY2hlbWEpIHtcbiAgICBjaGVja1N0cmljdE1vZGUoaXQsIFwiZGVmYXVsdCBpcyBpZ25vcmVkIGluIHRoZSBzY2hlbWEgcm9vdFwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHQoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCBzY2hJZCA9IGl0LnNjaGVtYVtpdC5vcHRzLnNjaGVtYUlkXVxuICBpZiAoc2NoSWQpIGl0LmJhc2VJZCA9IHJlc29sdmVVcmwoaXQub3B0cy51cmlSZXNvbHZlciwgaXQuYmFzZUlkLCBzY2hJZClcbn1cblxuZnVuY3Rpb24gY2hlY2tBc3luY1NjaGVtYShpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGlmIChpdC5zY2hlbWEuJGFzeW5jICYmICFpdC5zY2hlbWFFbnYuJGFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgaW4gc3luYyBzY2hlbWFcIilcbn1cblxuZnVuY3Rpb24gY29tbWVudEtleXdvcmQoe2dlbiwgc2NoZW1hRW52LCBzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHN9OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgY29uc3QgbXNnID0gc2NoZW1hLiRjb21tZW50XG4gIGlmIChvcHRzLiRjb21tZW50ID09PSB0cnVlKSB7XG4gICAgZ2VuLmNvZGUoX2Ake04uc2VsZn0ubG9nZ2VyLmxvZygke21zZ30pYClcbiAgfSBlbHNlIGlmICh0eXBlb2Ygb3B0cy4kY29tbWVudCA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBjb25zdCBzY2hlbWFQYXRoID0gc3RyYCR7ZXJyU2NoZW1hUGF0aH0vJGNvbW1lbnRgXG4gICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwge3JlZjogc2NoZW1hRW52LnJvb3R9KVxuICAgIGdlbi5jb2RlKF9gJHtOLnNlbGZ9Lm9wdHMuJGNvbW1lbnQoJHttc2d9LCAke3NjaGVtYVBhdGh9LCAke3Jvb3ROYW1lfS5zY2hlbWEpYClcbiAgfVxufVxuXG5mdW5jdGlvbiByZXR1cm5SZXN1bHRzKGl0OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hRW52LCB2YWxpZGF0ZU5hbWUsIFZhbGlkYXRpb25FcnJvciwgb3B0c30gPSBpdFxuICBpZiAoc2NoZW1hRW52LiRhc3luYykge1xuICAgIC8vIFRPRE8gYXNzaWduIHVuZXZhbHVhdGVkXG4gICAgZ2VuLmlmKFxuICAgICAgX2Ake04uZXJyb3JzfSA9PT0gMGAsXG4gICAgICAoKSA9PiBnZW4ucmV0dXJuKE4uZGF0YSksXG4gICAgICAoKSA9PiBnZW4udGhyb3coX2BuZXcgJHtWYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0oJHtOLnZFcnJvcnN9KWApXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgTi52RXJyb3JzKVxuICAgIGlmIChvcHRzLnVuZXZhbHVhdGVkKSBhc3NpZ25FdmFsdWF0ZWQoaXQpXG4gICAgZ2VuLnJldHVybihfYCR7Ti5lcnJvcnN9ID09PSAwYClcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25FdmFsdWF0ZWQoe2dlbiwgZXZhbHVhdGVkLCBwcm9wcywgaXRlbXN9OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgaWYgKHByb3BzIGluc3RhbmNlb2YgTmFtZSkgZ2VuLmFzc2lnbihfYCR7ZXZhbHVhdGVkfS5wcm9wc2AsIHByb3BzKVxuICBpZiAoaXRlbXMgaW5zdGFuY2VvZiBOYW1lKSBnZW4uYXNzaWduKF9gJHtldmFsdWF0ZWR9Lml0ZW1zYCwgaXRlbXMpXG59XG5cbmZ1bmN0aW9uIHNjaGVtYUtleXdvcmRzKFxuICBpdDogU2NoZW1hT2JqQ3h0LFxuICB0eXBlczogSlNPTlR5cGVbXSxcbiAgdHlwZUVycm9yczogYm9vbGVhbixcbiAgZXJyc0NvdW50PzogTmFtZVxuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwgYWxsRXJyb3JzLCBvcHRzLCBzZWxmfSA9IGl0XG4gIGNvbnN0IHtSVUxFU30gPSBzZWxmXG4gIGlmIChzY2hlbWEuJHJlZiAmJiAob3B0cy5pZ25vcmVLZXl3b3Jkc1dpdGhSZWYgfHwgIXNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgUlVMRVMpKSkge1xuICAgIGdlbi5ibG9jaygoKSA9PiBrZXl3b3JkQ29kZShpdCwgXCIkcmVmXCIsIChSVUxFUy5hbGwuJHJlZiBhcyBSdWxlKS5kZWZpbml0aW9uKSkgLy8gVE9ETyB0eXBlY2FzdFxuICAgIHJldHVyblxuICB9XG4gIGlmICghb3B0cy5qdGQpIGNoZWNrU3RyaWN0VHlwZXMoaXQsIHR5cGVzKVxuICBnZW4uYmxvY2soKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIGdyb3VwS2V5d29yZHMoZ3JvdXApXG4gICAgZ3JvdXBLZXl3b3JkcyhSVUxFUy5wb3N0KVxuICB9KVxuXG4gIGZ1bmN0aW9uIGdyb3VwS2V5d29yZHMoZ3JvdXA6IFJ1bGVHcm91cCk6IHZvaWQge1xuICAgIGlmICghc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cCkpIHJldHVyblxuICAgIGlmIChncm91cC50eXBlKSB7XG4gICAgICBnZW4uaWYoY2hlY2tEYXRhVHlwZShncm91cC50eXBlLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpKVxuICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cClcbiAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEgJiYgdHlwZXNbMF0gPT09IGdyb3VwLnR5cGUgJiYgdHlwZUVycm9ycykge1xuICAgICAgICBnZW4uZWxzZSgpXG4gICAgICAgIHJlcG9ydFR5cGVFcnJvcihpdClcbiAgICAgIH1cbiAgICAgIGdlbi5lbmRJZigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVLZXl3b3JkcyhpdCwgZ3JvdXApXG4gICAgfVxuICAgIC8vIFRPRE8gbWFrZSBpdCBcIm9rXCIgY2FsbD9cbiAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmlmKF9gJHtOLmVycm9yc30gPT09ICR7ZXJyc0NvdW50IHx8IDB9YClcbiAgfVxufVxuXG5mdW5jdGlvbiBpdGVyYXRlS2V5d29yZHMoaXQ6IFNjaGVtYU9iakN4dCwgZ3JvdXA6IFJ1bGVHcm91cCk6IHZvaWQge1xuICBjb25zdCB7XG4gICAgZ2VuLFxuICAgIHNjaGVtYSxcbiAgICBvcHRzOiB7dXNlRGVmYXVsdHN9LFxuICB9ID0gaXRcbiAgaWYgKHVzZURlZmF1bHRzKSBhc3NpZ25EZWZhdWx0cyhpdCwgZ3JvdXAudHlwZSlcbiAgZ2VuLmJsb2NrKCgpID0+IHtcbiAgICBmb3IgKGNvbnN0IHJ1bGUgb2YgZ3JvdXAucnVsZXMpIHtcbiAgICAgIGlmIChzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpIHtcbiAgICAgICAga2V5d29yZENvZGUoaXQsIHJ1bGUua2V5d29yZCwgcnVsZS5kZWZpbml0aW9uLCBncm91cC50eXBlKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuZnVuY3Rpb24gY2hlY2tTdHJpY3RUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBpZiAoaXQuc2NoZW1hRW52Lm1ldGEgfHwgIWl0Lm9wdHMuc3RyaWN0VHlwZXMpIHJldHVyblxuICBjaGVja0NvbnRleHRUeXBlcyhpdCwgdHlwZXMpXG4gIGlmICghaXQub3B0cy5hbGxvd1VuaW9uVHlwZXMpIGNoZWNrTXVsdGlwbGVUeXBlcyhpdCwgdHlwZXMpXG4gIGNoZWNrS2V5d29yZFR5cGVzKGl0LCBpdC5kYXRhVHlwZXMpXG59XG5cbmZ1bmN0aW9uIGNoZWNrQ29udGV4dFR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHR5cGVzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGlmICghdHlwZXMubGVuZ3RoKSByZXR1cm5cbiAgaWYgKCFpdC5kYXRhVHlwZXMubGVuZ3RoKSB7XG4gICAgaXQuZGF0YVR5cGVzID0gdHlwZXNcbiAgICByZXR1cm5cbiAgfVxuICB0eXBlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgaWYgKCFpbmNsdWRlc1R5cGUoaXQuZGF0YVR5cGVzLCB0KSkge1xuICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYHR5cGUgXCIke3R9XCIgbm90IGFsbG93ZWQgYnkgY29udGV4dCBcIiR7aXQuZGF0YVR5cGVzLmpvaW4oXCIsXCIpfVwiYClcbiAgICB9XG4gIH0pXG4gIG5hcnJvd1NjaGVtYVR5cGVzKGl0LCB0eXBlcylcbn1cblxuZnVuY3Rpb24gY2hlY2tNdWx0aXBsZVR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHRzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGlmICh0cy5sZW5ndGggPiAxICYmICEodHMubGVuZ3RoID09PSAyICYmIHRzLmluY2x1ZGVzKFwibnVsbFwiKSkpIHtcbiAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBcInVzZSBhbGxvd1VuaW9uVHlwZXMgdG8gYWxsb3cgdW5pb24gdHlwZSBrZXl3b3JkXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkVHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3QgcnVsZXMgPSBpdC5zZWxmLlJVTEVTLmFsbFxuICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gcnVsZXMpIHtcbiAgICBjb25zdCBydWxlID0gcnVsZXNba2V5d29yZF1cbiAgICBpZiAodHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiAmJiBzaG91bGRVc2VSdWxlKGl0LnNjaGVtYSwgcnVsZSkpIHtcbiAgICAgIGNvbnN0IHt0eXBlfSA9IHJ1bGUuZGVmaW5pdGlvblxuICAgICAgaWYgKHR5cGUubGVuZ3RoICYmICF0eXBlLnNvbWUoKHQpID0+IGhhc0FwcGxpY2FibGVUeXBlKHRzLCB0KSkpIHtcbiAgICAgICAgc3RyaWN0VHlwZXNFcnJvcihpdCwgYG1pc3NpbmcgdHlwZSBcIiR7dHlwZS5qb2luKFwiLFwiKX1cIiBmb3Iga2V5d29yZCBcIiR7a2V5d29yZH1cImApXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhhc0FwcGxpY2FibGVUeXBlKHNjaFRzOiBKU09OVHlwZVtdLCBrd2RUOiBKU09OVHlwZSk6IGJvb2xlYW4ge1xuICByZXR1cm4gc2NoVHMuaW5jbHVkZXMoa3dkVCkgfHwgKGt3ZFQgPT09IFwibnVtYmVyXCIgJiYgc2NoVHMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpKVxufVxuXG5mdW5jdGlvbiBpbmNsdWRlc1R5cGUodHM6IEpTT05UeXBlW10sIHQ6IEpTT05UeXBlKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cy5pbmNsdWRlcyh0KSB8fCAodCA9PT0gXCJpbnRlZ2VyXCIgJiYgdHMuaW5jbHVkZXMoXCJudW1iZXJcIikpXG59XG5cbmZ1bmN0aW9uIG5hcnJvd1NjaGVtYVR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHdpdGhUeXBlczogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBjb25zdCB0czogSlNPTlR5cGVbXSA9IFtdXG4gIGZvciAoY29uc3QgdCBvZiBpdC5kYXRhVHlwZXMpIHtcbiAgICBpZiAoaW5jbHVkZXNUeXBlKHdpdGhUeXBlcywgdCkpIHRzLnB1c2godClcbiAgICBlbHNlIGlmICh3aXRoVHlwZXMuaW5jbHVkZXMoXCJpbnRlZ2VyXCIpICYmIHQgPT09IFwibnVtYmVyXCIpIHRzLnB1c2goXCJpbnRlZ2VyXCIpXG4gIH1cbiAgaXQuZGF0YVR5cGVzID0gdHNcbn1cblxuZnVuY3Rpb24gc3RyaWN0VHlwZXNFcnJvcihpdDogU2NoZW1hT2JqQ3h0LCBtc2c6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGhcbiAgbXNnICs9IGAgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFR5cGVzKWBcbiAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0VHlwZXMpXG59XG5cbmV4cG9ydCBjbGFzcyBLZXl3b3JkQ3h0IGltcGxlbWVudHMgS2V5d29yZEVycm9yQ3h0IHtcbiAgcmVhZG9ubHkgZ2VuOiBDb2RlR2VuXG4gIHJlYWRvbmx5IGFsbEVycm9ycz86IGJvb2xlYW5cbiAgcmVhZG9ubHkga2V5d29yZDogc3RyaW5nXG4gIHJlYWRvbmx5IGRhdGE6IE5hbWUgLy8gTmFtZSByZWZlcmVuY2luZyB0aGUgY3VycmVudCBsZXZlbCBvZiB0aGUgZGF0YSBpbnN0YW5jZVxuICByZWFkb25seSAkZGF0YT86IHN0cmluZyB8IGZhbHNlXG4gIHNjaGVtYTogYW55IC8vIGtleXdvcmQgdmFsdWUgaW4gdGhlIHNjaGVtYVxuICByZWFkb25seSBzY2hlbWFWYWx1ZTogQ29kZSB8IG51bWJlciB8IGJvb2xlYW4gLy8gQ29kZSByZWZlcmVuY2UgdG8ga2V5d29yZCBzY2hlbWEgdmFsdWUgb3IgcHJpbWl0aXZlIHZhbHVlXG4gIHJlYWRvbmx5IHNjaGVtYUNvZGU6IENvZGUgfCBudW1iZXIgfCBib29sZWFuIC8vIENvZGUgcmVmZXJlbmNlIHRvIHJlc29sdmVkIHNjaGVtYSB2YWx1ZSAoZGlmZmVyZW50IGlmIHNjaGVtYSBpcyAkZGF0YSlcbiAgcmVhZG9ubHkgc2NoZW1hVHlwZTogSlNPTlR5cGVbXSAvLyBhbGxvd2VkIHR5cGUocykgb2Yga2V5d29yZCB2YWx1ZSBpbiB0aGUgc2NoZW1hXG4gIHJlYWRvbmx5IHBhcmVudFNjaGVtYTogQW55U2NoZW1hT2JqZWN0XG4gIHJlYWRvbmx5IGVycnNDb3VudD86IE5hbWUgLy8gTmFtZSByZWZlcmVuY2UgdG8gdGhlIG51bWJlciBvZiB2YWxpZGF0aW9uIGVycm9ycyBjb2xsZWN0ZWQgYmVmb3JlIHRoaXMga2V5d29yZCxcbiAgLy8gcmVxdWlyZXMgb3B0aW9uIHRyYWNrRXJyb3JzIGluIGtleXdvcmQgZGVmaW5pdGlvblxuICBwYXJhbXM6IEtleXdvcmRDeHRQYXJhbXMgLy8gb2JqZWN0IHRvIHBhc3MgcGFyYW1ldGVycyB0byBlcnJvciBtZXNzYWdlcyBmcm9tIGtleXdvcmQgY29kZVxuICByZWFkb25seSBpdDogU2NoZW1hT2JqQ3h0IC8vIHNjaGVtYSBjb21waWxhdGlvbiBjb250ZXh0IChzY2hlbWEgaXMgZ3VhcmFudGVlZCB0byBiZSBhbiBvYmplY3QsIG5vdCBib29sZWFuKVxuICByZWFkb25seSBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb25cblxuICBjb25zdHJ1Y3RvcihpdDogU2NoZW1hT2JqQ3h0LCBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb24sIGtleXdvcmQ6IHN0cmluZykge1xuICAgIHZhbGlkYXRlS2V5d29yZFVzYWdlKGl0LCBkZWYsIGtleXdvcmQpXG4gICAgdGhpcy5nZW4gPSBpdC5nZW5cbiAgICB0aGlzLmFsbEVycm9ycyA9IGl0LmFsbEVycm9yc1xuICAgIHRoaXMua2V5d29yZCA9IGtleXdvcmRcbiAgICB0aGlzLmRhdGEgPSBpdC5kYXRhXG4gICAgdGhpcy5zY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgICB0aGlzLiRkYXRhID0gZGVmLiRkYXRhICYmIGl0Lm9wdHMuJGRhdGEgJiYgdGhpcy5zY2hlbWEgJiYgdGhpcy5zY2hlbWEuJGRhdGFcbiAgICB0aGlzLnNjaGVtYVZhbHVlID0gc2NoZW1hUmVmT3JWYWwoaXQsIHRoaXMuc2NoZW1hLCBrZXl3b3JkLCB0aGlzLiRkYXRhKVxuICAgIHRoaXMuc2NoZW1hVHlwZSA9IGRlZi5zY2hlbWFUeXBlXG4gICAgdGhpcy5wYXJlbnRTY2hlbWEgPSBpdC5zY2hlbWFcbiAgICB0aGlzLnBhcmFtcyA9IHt9XG4gICAgdGhpcy5pdCA9IGl0XG4gICAgdGhpcy5kZWYgPSBkZWZcblxuICAgIGlmICh0aGlzLiRkYXRhKSB7XG4gICAgICB0aGlzLnNjaGVtYUNvZGUgPSBpdC5nZW4uY29uc3QoXCJ2U2NoZW1hXCIsIGdldERhdGEodGhpcy4kZGF0YSwgaXQpKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNjaGVtYUNvZGUgPSB0aGlzLnNjaGVtYVZhbHVlXG4gICAgICBpZiAoIXZhbGlkU2NoZW1hVHlwZSh0aGlzLnNjaGVtYSwgZGVmLnNjaGVtYVR5cGUsIGRlZi5hbGxvd1VuZGVmaW5lZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke2tleXdvcmR9IHZhbHVlIG11c3QgYmUgJHtKU09OLnN0cmluZ2lmeShkZWYuc2NoZW1hVHlwZSl9YClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoXCJjb2RlXCIgaW4gZGVmID8gZGVmLnRyYWNrRXJyb3JzIDogZGVmLmVycm9ycyAhPT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuZXJyc0NvdW50ID0gaXQuZ2VuLmNvbnN0KFwiX2VycnNcIiwgTi5lcnJvcnMpXG4gICAgfVxuICB9XG5cbiAgcmVzdWx0KGNvbmRpdGlvbjogQ29kZSwgc3VjY2Vzc0FjdGlvbj86ICgpID0+IHZvaWQsIGZhaWxBY3Rpb24/OiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5mYWlsUmVzdWx0KG5vdChjb25kaXRpb24pLCBzdWNjZXNzQWN0aW9uLCBmYWlsQWN0aW9uKVxuICB9XG5cbiAgZmFpbFJlc3VsdChjb25kaXRpb246IENvZGUsIHN1Y2Nlc3NBY3Rpb24/OiAoKSA9PiB2b2lkLCBmYWlsQWN0aW9uPzogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbilcbiAgICBpZiAoZmFpbEFjdGlvbikgZmFpbEFjdGlvbigpXG4gICAgZWxzZSB0aGlzLmVycm9yKClcbiAgICBpZiAoc3VjY2Vzc0FjdGlvbikge1xuICAgICAgdGhpcy5nZW4uZWxzZSgpXG4gICAgICBzdWNjZXNzQWN0aW9uKClcbiAgICAgIGlmICh0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uZW5kSWYoKVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmVuZElmKClcbiAgICAgIGVsc2UgdGhpcy5nZW4uZWxzZSgpXG4gICAgfVxuICB9XG5cbiAgcGFzcyhjb25kaXRpb246IENvZGUsIGZhaWxBY3Rpb24/OiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5mYWlsUmVzdWx0KG5vdChjb25kaXRpb24pLCB1bmRlZmluZWQsIGZhaWxBY3Rpb24pXG4gIH1cblxuICBmYWlsKGNvbmRpdGlvbj86IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoY29uZGl0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZXJyb3IoKVxuICAgICAgaWYgKCF0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uaWYoZmFsc2UpIC8vIHRoaXMgYnJhbmNoIHdpbGwgYmUgcmVtb3ZlZCBieSBnZW4ub3B0aW1pemVcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLmdlbi5pZihjb25kaXRpb24pXG4gICAgdGhpcy5lcnJvcigpXG4gICAgaWYgKHRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5lbmRJZigpXG4gICAgZWxzZSB0aGlzLmdlbi5lbHNlKClcbiAgfVxuXG4gIGZhaWwkZGF0YShjb25kaXRpb246IENvZGUpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuJGRhdGEpIHJldHVybiB0aGlzLmZhaWwoY29uZGl0aW9uKVxuICAgIGNvbnN0IHtzY2hlbWFDb2RlfSA9IHRoaXNcbiAgICB0aGlzLmZhaWwoX2Ake3NjaGVtYUNvZGV9ICE9PSB1bmRlZmluZWQgJiYgKCR7b3IodGhpcy5pbnZhbGlkJGRhdGEoKSwgY29uZGl0aW9uKX0pYClcbiAgfVxuXG4gIGVycm9yKGFwcGVuZD86IGJvb2xlYW4sIGVycm9yUGFyYW1zPzogS2V5d29yZEN4dFBhcmFtcywgZXJyb3JQYXRocz86IEVycm9yUGF0aHMpOiB2b2lkIHtcbiAgICBpZiAoZXJyb3JQYXJhbXMpIHtcbiAgICAgIHRoaXMuc2V0UGFyYW1zKGVycm9yUGFyYW1zKVxuICAgICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKVxuICAgICAgdGhpcy5zZXRQYXJhbXMoe30pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdGhpcy5fZXJyb3IoYXBwZW5kLCBlcnJvclBhdGhzKVxuICB9XG5cbiAgcHJpdmF0ZSBfZXJyb3IoYXBwZW5kPzogYm9vbGVhbiwgZXJyb3JQYXRocz86IEVycm9yUGF0aHMpOiB2b2lkIHtcbiAgICA7KGFwcGVuZCA/IHJlcG9ydEV4dHJhRXJyb3IgOiByZXBvcnRFcnJvcikodGhpcywgdGhpcy5kZWYuZXJyb3IsIGVycm9yUGF0aHMpXG4gIH1cblxuICAkZGF0YUVycm9yKCk6IHZvaWQge1xuICAgIHJlcG9ydEVycm9yKHRoaXMsIHRoaXMuZGVmLiRkYXRhRXJyb3IgfHwga2V5d29yZCREYXRhRXJyb3IpXG4gIH1cblxuICByZXNldCgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5lcnJzQ291bnQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdhZGQgXCJ0cmFja0Vycm9yc1wiIHRvIGtleXdvcmQgZGVmaW5pdGlvbicpXG4gICAgcmVzZXRFcnJvcnNDb3VudCh0aGlzLmdlbiwgdGhpcy5lcnJzQ291bnQpXG4gIH1cblxuICBvayhjb25kOiBDb2RlIHwgYm9vbGVhbik6IHZvaWQge1xuICAgIGlmICghdGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmlmKGNvbmQpXG4gIH1cblxuICBzZXRQYXJhbXMob2JqOiBLZXl3b3JkQ3h0UGFyYW1zLCBhc3NpZ24/OiB0cnVlKTogdm9pZCB7XG4gICAgaWYgKGFzc2lnbikgT2JqZWN0LmFzc2lnbih0aGlzLnBhcmFtcywgb2JqKVxuICAgIGVsc2UgdGhpcy5wYXJhbXMgPSBvYmpcbiAgfVxuXG4gIGJsb2NrJGRhdGEodmFsaWQ6IE5hbWUsIGNvZGVCbG9jazogKCkgPT4gdm9pZCwgJGRhdGFWYWxpZDogQ29kZSA9IG5pbCk6IHZvaWQge1xuICAgIHRoaXMuZ2VuLmJsb2NrKCgpID0+IHtcbiAgICAgIHRoaXMuY2hlY2skZGF0YSh2YWxpZCwgJGRhdGFWYWxpZClcbiAgICAgIGNvZGVCbG9jaygpXG4gICAgfSlcbiAgfVxuXG4gIGNoZWNrJGRhdGEodmFsaWQ6IE5hbWUgPSBuaWwsICRkYXRhVmFsaWQ6IENvZGUgPSBuaWwpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMuJGRhdGEpIHJldHVyblxuICAgIGNvbnN0IHtnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZn0gPSB0aGlzXG4gICAgZ2VuLmlmKG9yKF9gJHtzY2hlbWFDb2RlfSA9PT0gdW5kZWZpbmVkYCwgJGRhdGFWYWxpZCkpXG4gICAgaWYgKHZhbGlkICE9PSBuaWwpIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoIHx8IGRlZi52YWxpZGF0ZVNjaGVtYSkge1xuICAgICAgZ2VuLmVsc2VJZih0aGlzLmludmFsaWQkZGF0YSgpKVxuICAgICAgdGhpcy4kZGF0YUVycm9yKClcbiAgICAgIGlmICh2YWxpZCAhPT0gbmlsKSBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICB9XG4gICAgZ2VuLmVsc2UoKVxuICB9XG5cbiAgaW52YWxpZCRkYXRhKCk6IENvZGUge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYUNvZGUsIHNjaGVtYVR5cGUsIGRlZiwgaXR9ID0gdGhpc1xuICAgIHJldHVybiBvcih3cm9uZyREYXRhVHlwZSgpLCBpbnZhbGlkJERhdGFTY2hlbWEoKSlcblxuICAgIGZ1bmN0aW9uIHdyb25nJERhdGFUeXBlKCk6IENvZGUge1xuICAgICAgaWYgKHNjaGVtYVR5cGUubGVuZ3RoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoIShzY2hlbWFDb2RlIGluc3RhbmNlb2YgTmFtZSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgICAgICBjb25zdCBzdCA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlIDogW3NjaGVtYVR5cGVdXG4gICAgICAgIHJldHVybiBfYCR7Y2hlY2tEYXRhVHlwZXMoc3QsIHNjaGVtYUNvZGUsIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpfWBcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWxcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkJERhdGFTY2hlbWEoKTogQ29kZSB7XG4gICAgICBpZiAoZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlU2NoZW1hUmVmID0gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZSRkYXRhXCIsIHtyZWY6IGRlZi52YWxpZGF0ZVNjaGVtYX0pIC8vIFRPRE8gdmFsdWUuY29kZSBmb3Igc3RhbmRhbG9uZVxuICAgICAgICByZXR1cm4gX2AhJHt2YWxpZGF0ZVNjaGVtYVJlZn0oJHtzY2hlbWFDb2RlfSlgXG4gICAgICB9XG4gICAgICByZXR1cm4gbmlsXG4gICAgfVxuICB9XG5cbiAgc3Vic2NoZW1hKGFwcGw6IFN1YnNjaGVtYUFyZ3MsIHZhbGlkOiBOYW1lKTogU2NoZW1hQ3h0IHtcbiAgICBjb25zdCBzdWJzY2hlbWEgPSBnZXRTdWJzY2hlbWEodGhpcy5pdCwgYXBwbClcbiAgICBleHRlbmRTdWJzY2hlbWFEYXRhKHN1YnNjaGVtYSwgdGhpcy5pdCwgYXBwbClcbiAgICBleHRlbmRTdWJzY2hlbWFNb2RlKHN1YnNjaGVtYSwgYXBwbClcbiAgICBjb25zdCBuZXh0Q29udGV4dCA9IHsuLi50aGlzLml0LCAuLi5zdWJzY2hlbWEsIGl0ZW1zOiB1bmRlZmluZWQsIHByb3BzOiB1bmRlZmluZWR9XG4gICAgc3Vic2NoZW1hQ29kZShuZXh0Q29udGV4dCwgdmFsaWQpXG4gICAgcmV0dXJuIG5leHRDb250ZXh0XG4gIH1cblxuICBtZXJnZUV2YWx1YXRlZChzY2hlbWFDeHQ6IFNjaGVtYUN4dCwgdG9OYW1lPzogdHlwZW9mIE5hbWUpOiB2b2lkIHtcbiAgICBjb25zdCB7aXQsIGdlbn0gPSB0aGlzXG4gICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKSByZXR1cm5cbiAgICBpZiAoaXQucHJvcHMgIT09IHRydWUgJiYgc2NoZW1hQ3h0LnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hlbWFDeHQucHJvcHMsIGl0LnByb3BzLCB0b05hbWUpXG4gICAgfVxuICAgIGlmIChpdC5pdGVtcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaGVtYUN4dC5pdGVtcywgaXQuaXRlbXMsIHRvTmFtZSlcbiAgICB9XG4gIH1cblxuICBtZXJnZVZhbGlkRXZhbHVhdGVkKHNjaGVtYUN4dDogU2NoZW1hQ3h0LCB2YWxpZDogTmFtZSk6IGJvb2xlYW4gfCB2b2lkIHtcbiAgICBjb25zdCB7aXQsIGdlbn0gPSB0aGlzXG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgKGl0LnByb3BzICE9PSB0cnVlIHx8IGl0Lml0ZW1zICE9PSB0cnVlKSkge1xuICAgICAgZ2VuLmlmKHZhbGlkLCAoKSA9PiB0aGlzLm1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dCwgTmFtZSkpXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBrZXl3b3JkQ29kZShcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAga2V5d29yZDogc3RyaW5nLFxuICBkZWY6IEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIHJ1bGVUeXBlPzogSlNPTlR5cGVcbik6IHZvaWQge1xuICBjb25zdCBjeHQgPSBuZXcgS2V5d29yZEN4dChpdCwgZGVmLCBrZXl3b3JkKVxuICBpZiAoXCJjb2RlXCIgaW4gZGVmKSB7XG4gICAgZGVmLmNvZGUoY3h0LCBydWxlVHlwZSlcbiAgfSBlbHNlIGlmIChjeHQuJGRhdGEgJiYgZGVmLnZhbGlkYXRlKSB7XG4gICAgZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKVxuICB9IGVsc2UgaWYgKFwibWFjcm9cIiBpbiBkZWYpIHtcbiAgICBtYWNyb0tleXdvcmRDb2RlKGN4dCwgZGVmKVxuICB9IGVsc2UgaWYgKGRlZi5jb21waWxlIHx8IGRlZi52YWxpZGF0ZSkge1xuICAgIGZ1bmNLZXl3b3JkQ29kZShjeHQsIGRlZilcbiAgfVxufVxuXG5jb25zdCBKU09OX1BPSU5URVIgPSAvXlxcLyg/Oltefl18fjB8fjEpKiQvXG5jb25zdCBSRUxBVElWRV9KU09OX1BPSU5URVIgPSAvXihbMC05XSspKCN8XFwvKD86W15+XXx+MHx+MSkqKT8kL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERhdGEoXG4gICRkYXRhOiBzdHJpbmcsXG4gIHtkYXRhTGV2ZWwsIGRhdGFOYW1lcywgZGF0YVBhdGhBcnJ9OiBTY2hlbWFDeHRcbik6IENvZGUgfCBudW1iZXIge1xuICBsZXQganNvblBvaW50ZXJcbiAgbGV0IGRhdGE6IENvZGVcbiAgaWYgKCRkYXRhID09PSBcIlwiKSByZXR1cm4gTi5yb290RGF0YVxuICBpZiAoJGRhdGFbMF0gPT09IFwiL1wiKSB7XG4gICAgaWYgKCFKU09OX1BPSU5URVIudGVzdCgkZGF0YSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YClcbiAgICBqc29uUG9pbnRlciA9ICRkYXRhXG4gICAgZGF0YSA9IE4ucm9vdERhdGFcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBtYXRjaGVzID0gUkVMQVRJVkVfSlNPTl9QT0lOVEVSLmV4ZWMoJGRhdGEpXG4gICAgaWYgKCFtYXRjaGVzKSB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgSlNPTi1wb2ludGVyOiAkeyRkYXRhfWApXG4gICAgY29uc3QgdXA6IG51bWJlciA9ICttYXRjaGVzWzFdXG4gICAganNvblBvaW50ZXIgPSBtYXRjaGVzWzJdXG4gICAgaWYgKGpzb25Qb2ludGVyID09PSBcIiNcIikge1xuICAgICAgaWYgKHVwID49IGRhdGFMZXZlbCkgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwicHJvcGVydHkvaW5kZXhcIiwgdXApKVxuICAgICAgcmV0dXJuIGRhdGFQYXRoQXJyW2RhdGFMZXZlbCAtIHVwXVxuICAgIH1cbiAgICBpZiAodXAgPiBkYXRhTGV2ZWwpIHRocm93IG5ldyBFcnJvcihlcnJvck1zZyhcImRhdGFcIiwgdXApKVxuICAgIGRhdGEgPSBkYXRhTmFtZXNbZGF0YUxldmVsIC0gdXBdXG4gICAgaWYgKCFqc29uUG9pbnRlcikgcmV0dXJuIGRhdGFcbiAgfVxuXG4gIGxldCBleHByID0gZGF0YVxuICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKVxuICBmb3IgKGNvbnN0IHNlZ21lbnQgb2Ygc2VnbWVudHMpIHtcbiAgICBpZiAoc2VnbWVudCkge1xuICAgICAgZGF0YSA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkodW5lc2NhcGVKc29uUG9pbnRlcihzZWdtZW50KSl9YFxuICAgICAgZXhwciA9IF9gJHtleHByfSAmJiAke2RhdGF9YFxuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwclxuXG4gIGZ1bmN0aW9uIGVycm9yTXNnKHBvaW50ZXJUeXBlOiBzdHJpbmcsIHVwOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBgQ2Fubm90IGFjY2VzcyAke3BvaW50ZXJUeXBlfSAke3VwfSBsZXZlbHMgdXAsIGN1cnJlbnQgbGV2ZWwgaXMgJHtkYXRhTGV2ZWx9YFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yT2JqZWN0fSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IGVycm9yczogUGFydGlhbDxFcnJvck9iamVjdD5bXVxuICByZWFkb25seSBhanY6IHRydWVcbiAgcmVhZG9ubHkgdmFsaWRhdGlvbjogdHJ1ZVxuXG4gIGNvbnN0cnVjdG9yKGVycm9yczogUGFydGlhbDxFcnJvck9iamVjdD5bXSkge1xuICAgIHN1cGVyKFwidmFsaWRhdGlvbiBmYWlsZWRcIilcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yc1xuICAgIHRoaXMuYWp2ID0gdGhpcy52YWxpZGF0aW9uID0gdHJ1ZVxuICB9XG59XG4iLCAiaW1wb3J0IHtyZXNvbHZlVXJsLCBub3JtYWxpemVJZCwgZ2V0RnVsbFBhdGh9IGZyb20gXCIuL3Jlc29sdmVcIlxuaW1wb3J0IHR5cGUge1VyaVJlc29sdmVyfSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNaXNzaW5nUmVmRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IG1pc3NpbmdSZWY6IHN0cmluZ1xuICByZWFkb25seSBtaXNzaW5nU2NoZW1hOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihyZXNvbHZlcjogVXJpUmVzb2x2ZXIsIGJhc2VJZDogc3RyaW5nLCByZWY6IHN0cmluZywgbXNnPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobXNnIHx8IGBjYW4ndCByZXNvbHZlIHJlZmVyZW5jZSAke3JlZn0gZnJvbSBpZCAke2Jhc2VJZH1gKVxuICAgIHRoaXMubWlzc2luZ1JlZiA9IHJlc29sdmVVcmwocmVzb2x2ZXIsIGJhc2VJZCwgcmVmKVxuICAgIHRoaXMubWlzc2luZ1NjaGVtYSA9IG5vcm1hbGl6ZUlkKGdldEZ1bGxQYXRoKHJlc29sdmVyLCB0aGlzLm1pc3NpbmdSZWYpKVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1xuICBBbnlTY2hlbWEsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uLFxuICBFdmFsdWF0ZWRQcm9wZXJ0aWVzLFxuICBFdmFsdWF0ZWRJdGVtcyxcbn0gZnJvbSBcIi4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIEFqdiBmcm9tIFwiLi4vY29yZVwiXG5pbXBvcnQgdHlwZSB7SW5zdGFuY2VPcHRpb25zfSBmcm9tIFwiLi4vY29yZVwiXG5pbXBvcnQge0NvZGVHZW4sIF8sIG5pbCwgc3RyaW5naWZ5LCBOYW1lLCBDb2RlLCBWYWx1ZVNjb3BlTmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5pbXBvcnQgVmFsaWRhdGlvbkVycm9yIGZyb20gXCIuLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIlxuaW1wb3J0IE4gZnJvbSBcIi4vbmFtZXNcIlxuaW1wb3J0IHtMb2NhbFJlZnMsIGdldEZ1bGxQYXRoLCBfZ2V0RnVsbFBhdGgsIGlubGluZVJlZiwgbm9ybWFsaXplSWQsIHJlc29sdmVVcmx9IGZyb20gXCIuL3Jlc29sdmVcIlxuaW1wb3J0IHtzY2hlbWFIYXNSdWxlc0J1dFJlZiwgdW5lc2NhcGVGcmFnbWVudH0gZnJvbSBcIi4vdXRpbFwiXG5pbXBvcnQge3ZhbGlkYXRlRnVuY3Rpb25Db2RlfSBmcm9tIFwiLi92YWxpZGF0ZVwiXG5pbXBvcnQge1VSSUNvbXBvbmVudH0gZnJvbSBcImZhc3QtdXJpXCJcbmltcG9ydCB7SlNPTlR5cGV9IGZyb20gXCIuL3J1bGVzXCJcblxuZXhwb3J0IHR5cGUgU2NoZW1hUmVmcyA9IHtcbiAgW1JlZiBpbiBzdHJpbmddPzogU2NoZW1hRW52IHwgQW55U2NoZW1hXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hQ3h0IHtcbiAgcmVhZG9ubHkgZ2VuOiBDb2RlR2VuXG4gIHJlYWRvbmx5IGFsbEVycm9ycz86IGJvb2xlYW4gLy8gdmFsaWRhdGlvbiBtb2RlIC0gd2hldGhlciB0byBjb2xsZWN0IGFsbCBlcnJvcnMgb3IgYnJlYWsgb24gZXJyb3JcbiAgcmVhZG9ubHkgZGF0YTogTmFtZSAvLyBOYW1lIHdpdGggcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHBhcnQgb2YgZGF0YSBpbnN0YW5jZVxuICByZWFkb25seSBwYXJlbnREYXRhOiBOYW1lIC8vIHNob3VsZCBiZSB1c2VkIGluIGtleXdvcmRzIG1vZGlmeWluZyBkYXRhXG4gIHJlYWRvbmx5IHBhcmVudERhdGFQcm9wZXJ0eTogQ29kZSB8IG51bWJlciAvLyBzaG91bGQgYmUgdXNlZCBpbiBrZXl3b3JkcyBtb2RpZnlpbmcgZGF0YVxuICByZWFkb25seSBkYXRhTmFtZXM6IE5hbWVbXVxuICByZWFkb25seSBkYXRhUGF0aEFycjogKENvZGUgfCBudW1iZXIpW11cbiAgcmVhZG9ubHkgZGF0YUxldmVsOiBudW1iZXIgLy8gdGhlIGxldmVsIG9mIHRoZSBjdXJyZW50bHkgdmFsaWRhdGVkIGRhdGEsXG4gIC8vIGl0IGNhbiBiZSB1c2VkIHRvIGFjY2VzcyBib3RoIHRoZSBwcm9wZXJ0eSBuYW1lcyBhbmQgdGhlIGRhdGEgb24gYWxsIGxldmVscyBmcm9tIHRoZSB0b3AuXG4gIGRhdGFUeXBlczogSlNPTlR5cGVbXSAvLyBkYXRhIHR5cGVzIGFwcGxpZWQgdG8gdGhlIGN1cnJlbnQgcGFydCBvZiBkYXRhIGluc3RhbmNlXG4gIGRlZmluZWRQcm9wZXJ0aWVzOiBTZXQ8c3RyaW5nPiAvLyBzZXQgb2YgcHJvcGVydGllcyB0byBrZWVwIHRyYWNrIG9mIGZvciByZXF1aXJlZCBjaGVja3NcbiAgcmVhZG9ubHkgdG9wU2NoZW1hUmVmOiBDb2RlXG4gIHJlYWRvbmx5IHZhbGlkYXRlTmFtZTogTmFtZVxuICBldmFsdWF0ZWQ/OiBOYW1lXG4gIHJlYWRvbmx5IFZhbGlkYXRpb25FcnJvcj86IE5hbWVcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWEgLy8gY3VycmVudCBzY2hlbWEgb2JqZWN0IC0gZXF1YWwgdG8gcGFyZW50U2NoZW1hIHBhc3NlZCB2aWEgS2V5d29yZEN4dFxuICByZWFkb25seSBzY2hlbWFFbnY6IFNjaGVtYUVudlxuICByZWFkb25seSByb290SWQ6IHN0cmluZ1xuICBiYXNlSWQ6IHN0cmluZyAvLyB0aGUgY3VycmVudCBzY2hlbWEgYmFzZSBVUkkgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyB0aGUgYmFzZSBmb3IgcmVzb2x2aW5nIFVSSXMgaW4gcmVmZXJlbmNlcyAoXFwkcmVmKVxuICByZWFkb25seSBzY2hlbWFQYXRoOiBDb2RlIC8vIHRoZSBydW4tdGltZSBleHByZXNzaW9uIHRoYXQgZXZhbHVhdGVzIHRvIHRoZSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBjdXJyZW50IHNjaGVtYVxuICByZWFkb25seSBlcnJTY2hlbWFQYXRoOiBzdHJpbmcgLy8gdGhpcyBpcyBhY3R1YWwgc3RyaW5nLCBzaG91bGQgbm90IGJlIGNoYW5nZWQgdG8gQ29kZVxuICByZWFkb25seSBlcnJvclBhdGg6IENvZGVcbiAgcmVhZG9ubHkgcHJvcGVydHlOYW1lPzogTmFtZVxuICByZWFkb25seSBjb21wb3NpdGVSdWxlPzogYm9vbGVhbiAvLyB0cnVlIGluZGljYXRlcyB0aGF0IHRoZSBjdXJyZW50IHNjaGVtYSBpcyBpbnNpZGUgdGhlIGNvbXBvdW5kIGtleXdvcmQsXG4gIC8vIHdoZXJlIGZhaWxpbmcgc29tZSBydWxlIGRvZXNuJ3QgbWVhbiB2YWxpZGF0aW9uIGZhaWx1cmUgKGBhbnlPZmAsIGBvbmVPZmAsIGBub3RgLCBgaWZgKS5cbiAgLy8gVGhpcyBmbGFnIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgeW91IGNhbiByZXR1cm4gdmFsaWRhdGlvbiByZXN1bHQgaW1tZWRpYXRlbHkgYWZ0ZXIgYW55IGVycm9yIGluIGNhc2UgdGhlIG9wdGlvbiBgYWxsRXJyb3JzYCBpcyBub3QgYHRydWUuXG4gIC8vIFlvdSBvbmx5IG5lZWQgdG8gdXNlIGl0IGlmIHlvdSBoYXZlIG1hbnkgc3RlcHMgaW4geW91ciBrZXl3b3JkcyBhbmQgcG90ZW50aWFsbHkgY2FuIGRlZmluZSBtdWx0aXBsZSBlcnJvcnMuXG4gIHByb3BzPzogRXZhbHVhdGVkUHJvcGVydGllcyB8IE5hbWUgLy8gcHJvcGVydGllcyBldmFsdWF0ZWQgYnkgdGhpcyBzY2hlbWEgLSB1c2VkIGJ5IHBhcmVudCBzY2hlbWEgb3IgYXNzaWduZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICBpdGVtcz86IEV2YWx1YXRlZEl0ZW1zIHwgTmFtZSAvLyBsYXN0IGl0ZW0gZXZhbHVhdGVkIGJ5IHRoaXMgc2NoZW1hIC0gdXNlZCBieSBwYXJlbnQgc2NoZW1hIG9yIGFzc2lnbmVkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAganRkRGlzY3JpbWluYXRvcj86IHN0cmluZ1xuICBqdGRNZXRhZGF0YT86IGJvb2xlYW5cbiAgcmVhZG9ubHkgY3JlYXRlRXJyb3JzPzogYm9vbGVhblxuICByZWFkb25seSBvcHRzOiBJbnN0YW5jZU9wdGlvbnMgLy8gQWp2IGluc3RhbmNlIG9wdGlvbi5cbiAgcmVhZG9ubHkgc2VsZjogQWp2IC8vIGN1cnJlbnQgQWp2IGluc3RhbmNlXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hT2JqQ3h0IGV4dGVuZHMgU2NoZW1hQ3h0IHtcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3Rcbn1cbmludGVyZmFjZSBTY2hlbWFFbnZBcmdzIHtcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hSWQ/OiBcIiRpZFwiIHwgXCJpZFwiXG4gIHJlYWRvbmx5IHJvb3Q/OiBTY2hlbWFFbnZcbiAgcmVhZG9ubHkgYmFzZUlkPzogc3RyaW5nXG4gIHJlYWRvbmx5IHNjaGVtYVBhdGg/OiBzdHJpbmdcbiAgcmVhZG9ubHkgbG9jYWxSZWZzPzogTG9jYWxSZWZzXG4gIHJlYWRvbmx5IG1ldGE/OiBib29sZWFuXG59XG5cbmV4cG9ydCBjbGFzcyBTY2hlbWFFbnYgaW1wbGVtZW50cyBTY2hlbWFFbnZBcmdzIHtcbiAgcmVhZG9ubHkgc2NoZW1hOiBBbnlTY2hlbWFcbiAgcmVhZG9ubHkgc2NoZW1hSWQ/OiBcIiRpZFwiIHwgXCJpZFwiXG4gIHJlYWRvbmx5IHJvb3Q6IFNjaGVtYUVudlxuICBiYXNlSWQ6IHN0cmluZyAvLyBUT0RPIHBvc3NpYmx5LCBpdCBzaG91bGQgYmUgcmVhZG9ubHlcbiAgc2NoZW1hUGF0aD86IHN0cmluZ1xuICBsb2NhbFJlZnM/OiBMb2NhbFJlZnNcbiAgcmVhZG9ubHkgbWV0YT86IGJvb2xlYW5cbiAgcmVhZG9ubHkgJGFzeW5jPzogYm9vbGVhbiAvLyB0cnVlIGlmIHRoZSBjdXJyZW50IHNjaGVtYSBpcyBhc3luY2hyb25vdXMuXG4gIHJlYWRvbmx5IHJlZnM6IFNjaGVtYVJlZnMgPSB7fVxuICByZWFkb25seSBkeW5hbWljQW5jaG9yczoge1tSZWYgaW4gc3RyaW5nXT86IHRydWV9ID0ge31cbiAgdmFsaWRhdGU/OiBBbnlWYWxpZGF0ZUZ1bmN0aW9uXG4gIHZhbGlkYXRlTmFtZT86IFZhbHVlU2NvcGVOYW1lXG4gIHNlcmlhbGl6ZT86IChkYXRhOiB1bmtub3duKSA9PiBzdHJpbmdcbiAgc2VyaWFsaXplTmFtZT86IFZhbHVlU2NvcGVOYW1lXG4gIHBhcnNlPzogKGRhdGE6IHN0cmluZykgPT4gdW5rbm93blxuICBwYXJzZU5hbWU/OiBWYWx1ZVNjb3BlTmFtZVxuXG4gIGNvbnN0cnVjdG9yKGVudjogU2NoZW1hRW52QXJncykge1xuICAgIGxldCBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2YgZW52LnNjaGVtYSA9PSBcIm9iamVjdFwiKSBzY2hlbWEgPSBlbnYuc2NoZW1hXG4gICAgdGhpcy5zY2hlbWEgPSBlbnYuc2NoZW1hXG4gICAgdGhpcy5zY2hlbWFJZCA9IGVudi5zY2hlbWFJZFxuICAgIHRoaXMucm9vdCA9IGVudi5yb290IHx8IHRoaXNcbiAgICB0aGlzLmJhc2VJZCA9IGVudi5iYXNlSWQgPz8gbm9ybWFsaXplSWQoc2NoZW1hPy5bZW52LnNjaGVtYUlkIHx8IFwiJGlkXCJdKVxuICAgIHRoaXMuc2NoZW1hUGF0aCA9IGVudi5zY2hlbWFQYXRoXG4gICAgdGhpcy5sb2NhbFJlZnMgPSBlbnYubG9jYWxSZWZzXG4gICAgdGhpcy5tZXRhID0gZW52Lm1ldGFcbiAgICB0aGlzLiRhc3luYyA9IHNjaGVtYT8uJGFzeW5jXG4gICAgdGhpcy5yZWZzID0ge31cbiAgfVxufVxuXG4vLyBsZXQgY29kZVNpemUgPSAwXG4vLyBsZXQgbm9kZUNvdW50ID0gMFxuXG4vLyBDb21waWxlcyBzY2hlbWEgaW4gU2NoZW1hRW52XG5leHBvcnQgZnVuY3Rpb24gY29tcGlsZVNjaGVtYSh0aGlzOiBBanYsIHNjaDogU2NoZW1hRW52KTogU2NoZW1hRW52IHtcbiAgLy8gVE9ETyByZWZhY3RvciAtIHJlbW92ZSBjb21waWxhdGlvbnNcbiAgY29uc3QgX3NjaCA9IGdldENvbXBpbGluZ1NjaGVtYS5jYWxsKHRoaXMsIHNjaClcbiAgaWYgKF9zY2gpIHJldHVybiBfc2NoXG4gIGNvbnN0IHJvb3RJZCA9IGdldEZ1bGxQYXRoKHRoaXMub3B0cy51cmlSZXNvbHZlciwgc2NoLnJvb3QuYmFzZUlkKSAvLyBUT0RPIGlmIGdldEZ1bGxQYXRoIHJlbW92ZWQgMSB0ZXN0cyBmYWlsc1xuICBjb25zdCB7ZXM1LCBsaW5lc30gPSB0aGlzLm9wdHMuY29kZVxuICBjb25zdCB7b3duUHJvcGVydGllc30gPSB0aGlzLm9wdHNcbiAgY29uc3QgZ2VuID0gbmV3IENvZGVHZW4odGhpcy5zY29wZSwge2VzNSwgbGluZXMsIG93blByb3BlcnRpZXN9KVxuICBsZXQgX1ZhbGlkYXRpb25FcnJvclxuICBpZiAoc2NoLiRhc3luYykge1xuICAgIF9WYWxpZGF0aW9uRXJyb3IgPSBnZW4uc2NvcGVWYWx1ZShcIkVycm9yXCIsIHtcbiAgICAgIHJlZjogVmFsaWRhdGlvbkVycm9yLFxuICAgICAgY29kZTogX2ByZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCIpLmRlZmF1bHRgLFxuICAgIH0pXG4gIH1cblxuICBjb25zdCB2YWxpZGF0ZU5hbWUgPSBnZW4uc2NvcGVOYW1lKFwidmFsaWRhdGVcIilcbiAgc2NoLnZhbGlkYXRlTmFtZSA9IHZhbGlkYXRlTmFtZVxuXG4gIGNvbnN0IHNjaGVtYUN4dDogU2NoZW1hQ3h0ID0ge1xuICAgIGdlbixcbiAgICBhbGxFcnJvcnM6IHRoaXMub3B0cy5hbGxFcnJvcnMsXG4gICAgZGF0YTogTi5kYXRhLFxuICAgIHBhcmVudERhdGE6IE4ucGFyZW50RGF0YSxcbiAgICBwYXJlbnREYXRhUHJvcGVydHk6IE4ucGFyZW50RGF0YVByb3BlcnR5LFxuICAgIGRhdGFOYW1lczogW04uZGF0YV0sXG4gICAgZGF0YVBhdGhBcnI6IFtuaWxdLCAvLyBUT0RPIGNhbiBpdHMgbGVuZ3RoIGJlIHVzZWQgYXMgZGF0YUxldmVsIGlmIG5pbCBpcyByZW1vdmVkP1xuICAgIGRhdGFMZXZlbDogMCxcbiAgICBkYXRhVHlwZXM6IFtdLFxuICAgIGRlZmluZWRQcm9wZXJ0aWVzOiBuZXcgU2V0PHN0cmluZz4oKSxcbiAgICB0b3BTY2hlbWFSZWY6IGdlbi5zY29wZVZhbHVlKFxuICAgICAgXCJzY2hlbWFcIixcbiAgICAgIHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZVxuICAgICAgICA/IHtyZWY6IHNjaC5zY2hlbWEsIGNvZGU6IHN0cmluZ2lmeShzY2guc2NoZW1hKX1cbiAgICAgICAgOiB7cmVmOiBzY2guc2NoZW1hfVxuICAgICksXG4gICAgdmFsaWRhdGVOYW1lLFxuICAgIFZhbGlkYXRpb25FcnJvcjogX1ZhbGlkYXRpb25FcnJvcixcbiAgICBzY2hlbWE6IHNjaC5zY2hlbWEsXG4gICAgc2NoZW1hRW52OiBzY2gsXG4gICAgcm9vdElkLFxuICAgIGJhc2VJZDogc2NoLmJhc2VJZCB8fCByb290SWQsXG4gICAgc2NoZW1hUGF0aDogbmlsLFxuICAgIGVyclNjaGVtYVBhdGg6IHNjaC5zY2hlbWFQYXRoIHx8ICh0aGlzLm9wdHMuanRkID8gXCJcIiA6IFwiI1wiKSxcbiAgICBlcnJvclBhdGg6IF9gXCJcImAsXG4gICAgb3B0czogdGhpcy5vcHRzLFxuICAgIHNlbGY6IHRoaXMsXG4gIH1cblxuICBsZXQgc291cmNlQ29kZTogc3RyaW5nIHwgdW5kZWZpbmVkXG4gIHRyeSB7XG4gICAgdGhpcy5fY29tcGlsYXRpb25zLmFkZChzY2gpXG4gICAgdmFsaWRhdGVGdW5jdGlvbkNvZGUoc2NoZW1hQ3h0KVxuICAgIGdlbi5vcHRpbWl6ZSh0aGlzLm9wdHMuY29kZS5vcHRpbWl6ZSlcbiAgICAvLyBnZW4ub3B0aW1pemUoMSlcbiAgICBjb25zdCB2YWxpZGF0ZUNvZGUgPSBnZW4udG9TdHJpbmcoKVxuICAgIHNvdXJjZUNvZGUgPSBgJHtnZW4uc2NvcGVSZWZzKE4uc2NvcGUpfXJldHVybiAke3ZhbGlkYXRlQ29kZX1gXG4gICAgLy8gY29uc29sZS5sb2coKGNvZGVTaXplICs9IHNvdXJjZUNvZGUubGVuZ3RoKSwgKG5vZGVDb3VudCArPSBnZW4ubm9kZUNvdW50KSlcbiAgICBpZiAodGhpcy5vcHRzLmNvZGUucHJvY2Vzcykgc291cmNlQ29kZSA9IHRoaXMub3B0cy5jb2RlLnByb2Nlc3Moc291cmNlQ29kZSwgc2NoKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSlcbiAgICBjb25zdCBtYWtlVmFsaWRhdGUgPSBuZXcgRnVuY3Rpb24oYCR7Ti5zZWxmfWAsIGAke04uc2NvcGV9YCwgc291cmNlQ29kZSlcbiAgICBjb25zdCB2YWxpZGF0ZTogQW55VmFsaWRhdGVGdW5jdGlvbiA9IG1ha2VWYWxpZGF0ZSh0aGlzLCB0aGlzLnNjb3BlLmdldCgpKVxuICAgIHRoaXMuc2NvcGUudmFsdWUodmFsaWRhdGVOYW1lLCB7cmVmOiB2YWxpZGF0ZX0pXG5cbiAgICB2YWxpZGF0ZS5lcnJvcnMgPSBudWxsXG4gICAgdmFsaWRhdGUuc2NoZW1hID0gc2NoLnNjaGVtYVxuICAgIHZhbGlkYXRlLnNjaGVtYUVudiA9IHNjaFxuICAgIGlmIChzY2guJGFzeW5jKSAodmFsaWRhdGUgYXMgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uKS4kYXN5bmMgPSB0cnVlXG4gICAgaWYgKHRoaXMub3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSkge1xuICAgICAgdmFsaWRhdGUuc291cmNlID0ge3ZhbGlkYXRlTmFtZSwgdmFsaWRhdGVDb2RlLCBzY29wZVZhbHVlczogZ2VuLl92YWx1ZXN9XG4gICAgfVxuICAgIGlmICh0aGlzLm9wdHMudW5ldmFsdWF0ZWQpIHtcbiAgICAgIGNvbnN0IHtwcm9wcywgaXRlbXN9ID0gc2NoZW1hQ3h0XG4gICAgICB2YWxpZGF0ZS5ldmFsdWF0ZWQgPSB7XG4gICAgICAgIHByb3BzOiBwcm9wcyBpbnN0YW5jZW9mIE5hbWUgPyB1bmRlZmluZWQgOiBwcm9wcyxcbiAgICAgICAgaXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgTmFtZSA/IHVuZGVmaW5lZCA6IGl0ZW1zLFxuICAgICAgICBkeW5hbWljUHJvcHM6IHByb3BzIGluc3RhbmNlb2YgTmFtZSxcbiAgICAgICAgZHluYW1pY0l0ZW1zOiBpdGVtcyBpbnN0YW5jZW9mIE5hbWUsXG4gICAgICB9XG4gICAgICBpZiAodmFsaWRhdGUuc291cmNlKSB2YWxpZGF0ZS5zb3VyY2UuZXZhbHVhdGVkID0gc3RyaW5naWZ5KHZhbGlkYXRlLmV2YWx1YXRlZClcbiAgICB9XG4gICAgc2NoLnZhbGlkYXRlID0gdmFsaWRhdGVcbiAgICByZXR1cm4gc2NoXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWxldGUgc2NoLnZhbGlkYXRlXG4gICAgZGVsZXRlIHNjaC52YWxpZGF0ZU5hbWVcbiAgICBpZiAoc291cmNlQ29kZSkgdGhpcy5sb2dnZXIuZXJyb3IoXCJFcnJvciBjb21waWxpbmcgc2NoZW1hLCBmdW5jdGlvbiBjb2RlOlwiLCBzb3VyY2VDb2RlKVxuICAgIC8vIGNvbnNvbGUubG9nKFwiXFxuXFxuXFxuICoqKiBcXG5cIiwgc291cmNlQ29kZSwgdGhpcy5vcHRzKVxuICAgIHRocm93IGVcbiAgfSBmaW5hbGx5IHtcbiAgICB0aGlzLl9jb21waWxhdGlvbnMuZGVsZXRlKHNjaClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVJlZihcbiAgdGhpczogQWp2LFxuICByb290OiBTY2hlbWFFbnYsXG4gIGJhc2VJZDogc3RyaW5nLFxuICByZWY6IHN0cmluZ1xuKTogQW55U2NoZW1hIHwgU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgcmVmID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgcmVmKVxuICBjb25zdCBzY2hPckZ1bmMgPSByb290LnJlZnNbcmVmXVxuICBpZiAoc2NoT3JGdW5jKSByZXR1cm4gc2NoT3JGdW5jXG5cbiAgbGV0IF9zY2ggPSByZXNvbHZlLmNhbGwodGhpcywgcm9vdCwgcmVmKVxuICBpZiAoX3NjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3Qgc2NoZW1hID0gcm9vdC5sb2NhbFJlZnM/LltyZWZdIC8vIFRPRE8gbWF5YmUgbG9jYWxSZWZzIHNob3VsZCBob2xkIFNjaGVtYUVudlxuICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICBpZiAoc2NoZW1hKSBfc2NoID0gbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkfSlcbiAgfVxuXG4gIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHJldHVyblxuICByZXR1cm4gKHJvb3QucmVmc1tyZWZdID0gaW5saW5lT3JDb21waWxlLmNhbGwodGhpcywgX3NjaCkpXG59XG5cbmZ1bmN0aW9uIGlubGluZU9yQ29tcGlsZSh0aGlzOiBBanYsIHNjaDogU2NoZW1hRW52KTogQW55U2NoZW1hIHwgU2NoZW1hRW52IHtcbiAgaWYgKGlubGluZVJlZihzY2guc2NoZW1hLCB0aGlzLm9wdHMuaW5saW5lUmVmcykpIHJldHVybiBzY2guc2NoZW1hXG4gIHJldHVybiBzY2gudmFsaWRhdGUgPyBzY2ggOiBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKVxufVxuXG4vLyBJbmRleCBvZiBzY2hlbWEgY29tcGlsYXRpb24gaW4gdGhlIGN1cnJlbnRseSBjb21waWxlZCBsaXN0XG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcGlsaW5nU2NoZW1hKHRoaXM6IEFqdiwgc2NoRW52OiBTY2hlbWFFbnYpOiBTY2hlbWFFbnYgfCB2b2lkIHtcbiAgZm9yIChjb25zdCBzY2ggb2YgdGhpcy5fY29tcGlsYXRpb25zKSB7XG4gICAgaWYgKHNhbWVTY2hlbWFFbnYoc2NoLCBzY2hFbnYpKSByZXR1cm4gc2NoXG4gIH1cbn1cblxuZnVuY3Rpb24gc2FtZVNjaGVtYUVudihzMTogU2NoZW1hRW52LCBzMjogU2NoZW1hRW52KTogYm9vbGVhbiB7XG4gIHJldHVybiBzMS5zY2hlbWEgPT09IHMyLnNjaGVtYSAmJiBzMS5yb290ID09PSBzMi5yb290ICYmIHMxLmJhc2VJZCA9PT0gczIuYmFzZUlkXG59XG5cbi8vIHJlc29sdmUgYW5kIGNvbXBpbGUgdGhlIHJlZmVyZW5jZXMgKCRyZWYpXG4vLyBUT0RPIHJldHVybnMgQW55U2NoZW1hT2JqZWN0IChpZiB0aGUgc2NoZW1hIGNhbiBiZSBpbmxpbmVkKSBvciB2YWxpZGF0aW9uIGZ1bmN0aW9uXG5mdW5jdGlvbiByZXNvbHZlKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudiwgLy8gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHJvb3Qgc2NoZW1hIGZvciB0aGUgY3VycmVudCBzY2hlbWFcbiAgcmVmOiBzdHJpbmcgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbik6IFNjaGVtYUVudiB8IHVuZGVmaW5lZCB7XG4gIGxldCBzY2hcbiAgd2hpbGUgKHR5cGVvZiAoc2NoID0gdGhpcy5yZWZzW3JlZl0pID09IFwic3RyaW5nXCIpIHJlZiA9IHNjaFxuICByZXR1cm4gc2NoIHx8IHRoaXMuc2NoZW1hc1tyZWZdIHx8IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCByZWYpXG59XG5cbi8vIFJlc29sdmUgc2NoZW1hLCBpdHMgcm9vdCBhbmQgYmFzZUlkXG5leHBvcnQgZnVuY3Rpb24gcmVzb2x2ZVNjaGVtYShcbiAgdGhpczogQWp2LFxuICByb290OiBTY2hlbWFFbnYsIC8vIHJvb3Qgb2JqZWN0IHdpdGggcHJvcGVydGllcyBzY2hlbWEsIHJlZnMgVE9ETyBiZWxvdyBTY2hlbWFFbnYgaXMgYXNzaWduZWQgdG8gaXRcbiAgcmVmOiBzdHJpbmcgLy8gcmVmZXJlbmNlIHRvIHJlc29sdmVcbik6IFNjaGVtYUVudiB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHAgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucGFyc2UocmVmKVxuICBjb25zdCByZWZQYXRoID0gX2dldEZ1bGxQYXRoKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcClcbiAgbGV0IGJhc2VJZCA9IGdldEZ1bGxQYXRoKHRoaXMub3B0cy51cmlSZXNvbHZlciwgcm9vdC5iYXNlSWQsIHVuZGVmaW5lZClcbiAgLy8gVE9ETyBgT2JqZWN0LmtleXMocm9vdC5zY2hlbWEpLmxlbmd0aCA+IDBgIHNob3VsZCBub3QgYmUgbmVlZGVkIC0gYnV0IHJlbW92aW5nIGJyZWFrcyAyIHRlc3RzXG4gIGlmIChPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMCAmJiByZWZQYXRoID09PSBiYXNlSWQpIHtcbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCByb290KVxuICB9XG5cbiAgY29uc3QgaWQgPSBub3JtYWxpemVJZChyZWZQYXRoKVxuICBjb25zdCBzY2hPclJlZiA9IHRoaXMucmVmc1tpZF0gfHwgdGhpcy5zY2hlbWFzW2lkXVxuICBpZiAodHlwZW9mIHNjaE9yUmVmID09IFwic3RyaW5nXCIpIHtcbiAgICBjb25zdCBzY2ggPSByZXNvbHZlU2NoZW1hLmNhbGwodGhpcywgcm9vdCwgc2NoT3JSZWYpXG4gICAgaWYgKHR5cGVvZiBzY2g/LnNjaGVtYSAhPT0gXCJvYmplY3RcIikgcmV0dXJuXG4gICAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBzY2hPclJlZj8uc2NoZW1hICE9PSBcIm9iamVjdFwiKSByZXR1cm5cbiAgaWYgKCFzY2hPclJlZi52YWxpZGF0ZSkgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaE9yUmVmKVxuICBpZiAoaWQgPT09IG5vcm1hbGl6ZUlkKHJlZikpIHtcbiAgICBjb25zdCB7c2NoZW1hfSA9IHNjaE9yUmVmXG4gICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGNvbnN0IHNjaElkID0gc2NoZW1hW3NjaGVtYUlkXVxuICAgIGlmIChzY2hJZCkgYmFzZUlkID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoSWQpXG4gICAgcmV0dXJuIG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZH0pXG4gIH1cbiAgcmV0dXJuIGdldEpzb25Qb2ludGVyLmNhbGwodGhpcywgcCwgc2NoT3JSZWYpXG59XG5cbmNvbnN0IFBSRVZFTlRfU0NPUEVfQ0hBTkdFID0gbmV3IFNldChbXG4gIFwicHJvcGVydGllc1wiLFxuICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gIFwiZW51bVwiLFxuICBcImRlcGVuZGVuY2llc1wiLFxuICBcImRlZmluaXRpb25zXCIsXG5dKVxuXG5mdW5jdGlvbiBnZXRKc29uUG9pbnRlcihcbiAgdGhpczogQWp2LFxuICBwYXJzZWRSZWY6IFVSSUNvbXBvbmVudCxcbiAge2Jhc2VJZCwgc2NoZW1hLCByb290fTogU2NoZW1hRW52XG4pOiBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICBpZiAocGFyc2VkUmVmLmZyYWdtZW50Py5bMF0gIT09IFwiL1wiKSByZXR1cm5cbiAgZm9yIChjb25zdCBwYXJ0IG9mIHBhcnNlZFJlZi5mcmFnbWVudC5zbGljZSgxKS5zcGxpdChcIi9cIikpIHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpIHJldHVyblxuICAgIGNvbnN0IHBhcnRTY2hlbWEgPSBzY2hlbWFbdW5lc2NhcGVGcmFnbWVudChwYXJ0KV1cbiAgICBpZiAocGFydFNjaGVtYSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBzY2hlbWEgPSBwYXJ0U2NoZW1hXG4gICAgLy8gVE9ETyBQUkVWRU5UX1NDT1BFX0NIQU5HRSBjb3VsZCBiZSBkZWZpbmVkIGluIGtleXdvcmQgZGVmP1xuICAgIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIiAmJiBzY2hlbWFbdGhpcy5vcHRzLnNjaGVtYUlkXVxuICAgIGlmICghUFJFVkVOVF9TQ09QRV9DSEFOR0UuaGFzKHBhcnQpICYmIHNjaElkKSB7XG4gICAgICBiYXNlSWQgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZClcbiAgICB9XG4gIH1cbiAgbGV0IGVudjogU2NoZW1hRW52IHwgdW5kZWZpbmVkXG4gIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiICYmIHNjaGVtYS4kcmVmICYmICFzY2hlbWFIYXNSdWxlc0J1dFJlZihzY2hlbWEsIHRoaXMuUlVMRVMpKSB7XG4gICAgY29uc3QgJHJlZiA9IHJlc29sdmVVcmwodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaGVtYS4kcmVmKVxuICAgIGVudiA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCAkcmVmKVxuICB9XG4gIC8vIGV2ZW4gdGhvdWdoIHJlc29sdXRpb24gZmFpbGVkIHdlIG5lZWQgdG8gcmV0dXJuIFNjaGVtYUVudiB0byB0aHJvdyBleGNlcHRpb25cbiAgLy8gc28gdGhhdCBjb21waWxlQXN5bmMgbG9hZHMgbWlzc2luZyBzY2hlbWEuXG4gIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgZW52ID0gZW52IHx8IG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIHJvb3QsIGJhc2VJZH0pXG4gIGlmIChlbnYuc2NoZW1hICE9PSBlbnYucm9vdC5zY2hlbWEpIHJldHVybiBlbnZcbiAgcmV0dXJuIHVuZGVmaW5lZFxufVxuIiwgIntcbiAgXCIkaWRcIjogXCJodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vYWp2LXZhbGlkYXRvci9hanYvbWFzdGVyL2xpYi9yZWZzL2RhdGEuanNvbiNcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIk1ldGEtc2NoZW1hIGZvciAkZGF0YSByZWZlcmVuY2UgKEpTT04gQW55U2NoZW1hIGV4dGVuc2lvbiBwcm9wb3NhbClcIixcbiAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gIFwicmVxdWlyZWRcIjogW1wiJGRhdGFcIl0sXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCIkZGF0YVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiYW55T2ZcIjogW3tcImZvcm1hdFwiOiBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwifSwge1wiZm9ybWF0XCI6IFwianNvbi1wb2ludGVyXCJ9XVxuICAgIH1cbiAgfSxcbiAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiBmYWxzZVxufVxuIiwgIid1c2Ugc3RyaWN0J1xuXG4vKiogQHR5cGUgeyh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFufSAqL1xuY29uc3QgaXNVVUlEID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL15bXFxkYS1mXXs4fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXs0fS1bXFxkYS1mXXsxMn0kL2l1KVxuXG4vKiogQHR5cGUgeyh2YWx1ZTogc3RyaW5nKSA9PiBib29sZWFufSAqL1xuY29uc3QgaXNJUHY0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oPzooPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZClcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZHsyfXxbMS05XVxcZHxcXGQpJC91KVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gaW5wdXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZCAoaW5wdXQpIHtcbiAgbGV0IGFjYyA9ICcnXG4gIGxldCBjb2RlID0gMFxuICBsZXQgaSA9IDBcblxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaW5wdXRbaV0uY2hhckNvZGVBdCgwKVxuICAgIGlmIChjb2RlID09PSA0OCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKCEoKGNvZGUgPj0gNDggJiYgY29kZSA8PSA1NykgfHwgKGNvZGUgPj0gNjUgJiYgY29kZSA8PSA3MCkgfHwgKGNvZGUgPj0gOTcgJiYgY29kZSA8PSAxMDIpKSkge1xuICAgICAgcmV0dXJuICcnXG4gICAgfVxuICAgIGFjYyArPSBpbnB1dFtpXVxuICAgIGJyZWFrXG4gIH1cblxuICBmb3IgKGkgKz0gMTsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29kZSA9IGlucHV0W2ldLmNoYXJDb2RlQXQoMClcbiAgICBpZiAoISgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSB8fCAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikpKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgYWNjICs9IGlucHV0W2ldXG4gIH1cbiAgcmV0dXJuIGFjY1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEdldElQVjZSZXN1bHRcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZXJyb3IgLSBJbmRpY2F0ZXMgaWYgdGhlcmUgd2FzIGFuIGVycm9yIHBhcnNpbmcgdGhlIElQdjYgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhZGRyZXNzIC0gVGhlIHBhcnNlZCBJUHY2IGFkZHJlc3MuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3pvbmVdIC0gVGhlIHpvbmUgaWRlbnRpZmllciwgaWYgcHJlc2VudC5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmNvbnN0IG5vblNpbXBsZURvbWFpbiA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9bXiFcIiQmJygpKissXFwtLjs9X2BhLXp7fX5dL3UpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBidWZmZXJcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBjb25zdW1lSXNab25lIChidWZmZXIpIHtcbiAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGJ1ZmZlclxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhZGRyZXNzXG4gKiBAcGFyYW0ge0dldElQVjZSZXN1bHR9IG91dHB1dFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVIZXh0ZXRzIChidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkge1xuICBpZiAoYnVmZmVyLmxlbmd0aCkge1xuICAgIGNvbnN0IGhleCA9IHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZChidWZmZXIpXG4gICAgaWYgKGhleCAhPT0gJycpIHtcbiAgICAgIGFkZHJlc3MucHVzaChoZXgpXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICBidWZmZXIubGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGlucHV0XG4gKiBAcmV0dXJucyB7R2V0SVBWNlJlc3VsdH1cbiAqL1xuZnVuY3Rpb24gZ2V0SVBWNiAoaW5wdXQpIHtcbiAgbGV0IHRva2VuQ291bnQgPSAwXG4gIGNvbnN0IG91dHB1dCA9IHsgZXJyb3I6IGZhbHNlLCBhZGRyZXNzOiAnJywgem9uZTogJycgfVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGFkZHJlc3MgPSBbXVxuICAvKiogQHR5cGUge0FycmF5PHN0cmluZz59ICovXG4gIGNvbnN0IGJ1ZmZlciA9IFtdXG4gIGxldCBlbmRpcHY2RW5jb3VudGVyZWQgPSBmYWxzZVxuICBsZXQgZW5kSXB2NiA9IGZhbHNlXG5cbiAgbGV0IGNvbnN1bWUgPSBjb25zdW1lSGV4dGV0c1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjdXJzb3IgPSBpbnB1dFtpXVxuICAgIGlmIChjdXJzb3IgPT09ICdbJyB8fCBjdXJzb3IgPT09ICddJykgeyBjb250aW51ZSB9XG4gICAgaWYgKGN1cnNvciA9PT0gJzonKSB7XG4gICAgICBpZiAoZW5kaXB2NkVuY291bnRlcmVkID09PSB0cnVlKSB7XG4gICAgICAgIGVuZElwdjYgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoIWNvbnN1bWUoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpKSB7IGJyZWFrIH1cbiAgICAgIGlmICgrK3Rva2VuQ291bnQgPiA3KSB7XG4gICAgICAgIC8vIG5vdCB2YWxpZFxuICAgICAgICBvdXRwdXQuZXJyb3IgPSB0cnVlXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBpZiAoaSA+IDAgJiYgaW5wdXRbaSAtIDFdID09PSAnOicpIHtcbiAgICAgICAgZW5kaXB2NkVuY291bnRlcmVkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgYWRkcmVzcy5wdXNoKCc6JylcbiAgICAgIGNvbnRpbnVlXG4gICAgfSBlbHNlIGlmIChjdXJzb3IgPT09ICclJykge1xuICAgICAgaWYgKCFjb25zdW1lKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSkgeyBicmVhayB9XG4gICAgICAvLyBzd2l0Y2ggdG8gem9uZSBkZXRlY3Rpb25cbiAgICAgIGNvbnN1bWUgPSBjb25zdW1lSXNab25lXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlci5wdXNoKGN1cnNvcilcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGNvbnN1bWUgPT09IGNvbnN1bWVJc1pvbmUpIHtcbiAgICAgIG91dHB1dC56b25lID0gYnVmZmVyLmpvaW4oJycpXG4gICAgfSBlbHNlIGlmIChlbmRJcHY2KSB7XG4gICAgICBhZGRyZXNzLnB1c2goYnVmZmVyLmpvaW4oJycpKVxuICAgIH0gZWxzZSB7XG4gICAgICBhZGRyZXNzLnB1c2goc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcikpXG4gICAgfVxuICB9XG4gIG91dHB1dC5hZGRyZXNzID0gYWRkcmVzcy5qb2luKCcnKVxuICByZXR1cm4gb3V0cHV0XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gTm9ybWFsaXplSVB2NlJlc3VsdFxuICogQHByb3BlcnR5IHtzdHJpbmd9IGhvc3QgLSBUaGUgbm9ybWFsaXplZCBob3N0LlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtlc2NhcGVkSG9zdF0gLSBUaGUgZXNjYXBlZCBob3N0LlxuICogQHByb3BlcnR5IHtib29sZWFufSBpc0lQVjYgLSBJbmRpY2F0ZXMgaWYgdGhlIGhvc3QgaXMgYW4gSVB2NiBhZGRyZXNzLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGhvc3RcbiAqIEByZXR1cm5zIHtOb3JtYWxpemVJUHY2UmVzdWx0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVJUHY2IChob3N0KSB7XG4gIGlmIChmaW5kVG9rZW4oaG9zdCwgJzonKSA8IDIpIHsgcmV0dXJuIHsgaG9zdCwgaXNJUFY2OiBmYWxzZSB9IH1cbiAgY29uc3QgaXB2NiA9IGdldElQVjYoaG9zdClcblxuICBpZiAoIWlwdjYuZXJyb3IpIHtcbiAgICBsZXQgbmV3SG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGxldCBlc2NhcGVkSG9zdCA9IGlwdjYuYWRkcmVzc1xuICAgIGlmIChpcHY2LnpvbmUpIHtcbiAgICAgIG5ld0hvc3QgKz0gJyUnICsgaXB2Ni56b25lXG4gICAgICBlc2NhcGVkSG9zdCArPSAnJTI1JyArIGlwdjYuem9uZVxuICAgIH1cbiAgICByZXR1cm4geyBob3N0OiBuZXdIb3N0LCBpc0lQVjY6IHRydWUsIGVzY2FwZWRIb3N0IH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b2tlblxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZFRva2VuIChzdHIsIHRva2VuKSB7XG4gIGxldCBpbmQgPSAwXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHN0cltpXSA9PT0gdG9rZW4pIGluZCsrXG4gIH1cbiAgcmV0dXJuIGluZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRG90U2VnbWVudHMgKHBhdGgpIHtcbiAgbGV0IGlucHV0ID0gcGF0aFxuICBjb25zdCBvdXRwdXQgPSBbXVxuICBsZXQgbmV4dFNsYXNoID0gLTFcbiAgbGV0IGxlbiA9IDBcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uZC1hc3NpZ25cbiAgd2hpbGUgKGxlbiA9IGlucHV0Lmxlbmd0aCkge1xuICAgIGlmIChsZW4gPT09IDEpIHtcbiAgICAgIGlmIChpbnB1dCA9PT0gJy4nKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2UgaWYgKGlucHV0ID09PSAnLycpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICBicmVha1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2goaW5wdXQpXG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIGlmIChpbnB1dFswXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfSBlbHNlIGlmIChpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMF0gPT09ICcvJykge1xuICAgICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJyB8fCBpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMykge1xuICAgICAgaWYgKGlucHV0ID09PSAnLy4uJykge1xuICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIG91dHB1dC5wb3AoKVxuICAgICAgICB9XG4gICAgICAgIG91dHB1dC5wdXNoKCcvJylcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlucHV0WzBdID09PSAnLicpIHtcbiAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsyXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMV0gPT09ICcvJykge1xuICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnB1dFswXSA9PT0gJy8nKSB7XG4gICAgICBpZiAoaW5wdXRbMV0gPT09ICcuJykge1xuICAgICAgICBpZiAoaW5wdXRbMl0gPT09ICcvJykge1xuICAgICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGlucHV0WzJdID09PSAnLicpIHtcbiAgICAgICAgICBpZiAoaW5wdXRbM10gPT09ICcvJykge1xuICAgICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgzKVxuICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgb3V0cHV0LnBvcCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1bGUgMkU6IE1vdmUgbm9ybWFsIHBhdGggc2VnbWVudCB0byBvdXRwdXRcbiAgICBpZiAoKG5leHRTbGFzaCA9IGlucHV0LmluZGV4T2YoJy8nLCAxKSkgPT09IC0xKSB7XG4gICAgICBvdXRwdXQucHVzaChpbnB1dClcbiAgICAgIGJyZWFrXG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dC5wdXNoKGlucHV0LnNsaWNlKDAsIG5leHRTbGFzaCkpXG4gICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKG5leHRTbGFzaClcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZXNjXG4gKiBAcmV0dXJucyB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcgKGNvbXBvbmVudCwgZXNjKSB7XG4gIGNvbnN0IGZ1bmMgPSBlc2MgIT09IHRydWUgPyBlc2NhcGUgOiB1bmVzY2FwZVxuICBpZiAoY29tcG9uZW50LnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnNjaGVtZSA9IGZ1bmMoY29tcG9uZW50LnNjaGVtZSlcbiAgfVxuICBpZiAoY29tcG9uZW50LnVzZXJpbmZvICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQudXNlcmluZm8gPSBmdW5jKGNvbXBvbmVudC51c2VyaW5mbylcbiAgfVxuICBpZiAoY29tcG9uZW50Lmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5ob3N0ID0gZnVuYyhjb21wb25lbnQuaG9zdClcbiAgfVxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gZnVuYyhjb21wb25lbnQucGF0aClcbiAgfVxuICBpZiAoY29tcG9uZW50LnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQucXVlcnkgPSBmdW5jKGNvbXBvbmVudC5xdWVyeSlcbiAgfVxuICBpZiAoY29tcG9uZW50LmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuZnJhZ21lbnQgPSBmdW5jKGNvbXBvbmVudC5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiByZWNvbXBvc2VBdXRob3JpdHkgKGNvbXBvbmVudCkge1xuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIGlmIChjb21wb25lbnQudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKGNvbXBvbmVudC51c2VyaW5mbylcbiAgICB1cmlUb2tlbnMucHVzaCgnQCcpXG4gIH1cblxuICBpZiAoY29tcG9uZW50Lmhvc3QgIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBob3N0ID0gdW5lc2NhcGUoY29tcG9uZW50Lmhvc3QpXG4gICAgaWYgKCFpc0lQdjQoaG9zdCkpIHtcbiAgICAgIGNvbnN0IGlwVjZyZXMgPSBub3JtYWxpemVJUHY2KGhvc3QpXG4gICAgICBpZiAoaXBWNnJlcy5pc0lQVjYgPT09IHRydWUpIHtcbiAgICAgICAgaG9zdCA9IGBbJHtpcFY2cmVzLmVzY2FwZWRIb3N0fV1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBob3N0ID0gY29tcG9uZW50Lmhvc3RcbiAgICAgIH1cbiAgICB9XG4gICAgdXJpVG9rZW5zLnB1c2goaG9zdClcbiAgfVxuXG4gIGlmICh0eXBlb2YgY29tcG9uZW50LnBvcnQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBjb21wb25lbnQucG9ydCA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnOicpXG4gICAgdXJpVG9rZW5zLnB1c2goU3RyaW5nKGNvbXBvbmVudC5wb3J0KSlcbiAgfVxuXG4gIHJldHVybiB1cmlUb2tlbnMubGVuZ3RoID8gdXJpVG9rZW5zLmpvaW4oJycpIDogdW5kZWZpbmVkXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgbm9uU2ltcGxlRG9tYWluLFxuICByZWNvbXBvc2VBdXRob3JpdHksXG4gIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLFxuICByZW1vdmVEb3RTZWdtZW50cyxcbiAgaXNJUHY0LFxuICBpc1VVSUQsXG4gIG5vcm1hbGl6ZUlQdjYsXG4gIHN0cmluZ0FycmF5VG9IZXhTdHJpcHBlZFxufVxuIiwgIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IGlzVVVJRCB9ID0gcmVxdWlyZSgnLi91dGlscycpXG5jb25zdCBVUk5fUkVHID0gLyhbXFxkYS16XVtcXGRcXC1hLXpdezAsMzF9KTooKD86W1xcdyEkJygpKissXFwtLjo7PUBdfCVbXFxkYS1mXXsyfSkrKS9pdVxuXG5jb25zdCBzdXBwb3J0ZWRTY2hlbWVOYW1lcyA9IC8qKiBAdHlwZSB7Y29uc3R9ICovIChbJ2h0dHAnLCAnaHR0cHMnLCAnd3MnLFxuICAnd3NzJywgJ3VybicsICd1cm46dXVpZCddKVxuXG4vKiogQHR5cGVkZWYge3N1cHBvcnRlZFNjaGVtZU5hbWVzW251bWJlcl19IFNjaGVtZU5hbWUgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybnMge25hbWUgaXMgU2NoZW1lTmFtZX1cbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFNjaGVtZU5hbWUgKG5hbWUpIHtcbiAgcmV0dXJuIHN1cHBvcnRlZFNjaGVtZU5hbWVzLmluZGV4T2YoLyoqIEB0eXBlIHsqfSAqLyAobmFtZSkpICE9PSAtMVxufVxuXG4vKipcbiAqIEBjYWxsYmFjayBTY2hlbWVGblxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gU2NoZW1lSGFuZGxlclxuICogQHByb3BlcnR5IHtTY2hlbWVOYW1lfSBzY2hlbWUgLSBUaGUgc2NoZW1lIG5hbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtkb21haW5Ib3N0XSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHN1cHBvcnRzIGRvbWFpbiBob3N0cy5cbiAqIEBwcm9wZXJ0eSB7U2NoZW1lRm59IHBhcnNlIC0gRnVuY3Rpb24gdG8gcGFyc2UgdGhlIFVSSSBjb21wb25lbnQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtTY2hlbWVGbn0gc2VyaWFsaXplIC0gRnVuY3Rpb24gdG8gc2VyaWFsaXplIHRoZSBVUkkgY29tcG9uZW50IGZvciB0aGlzIHNjaGVtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemVdIC0gSW5kaWNhdGVzIGlmIG5vcm1hbGl6YXRpb24gc2hvdWxkIGJlIHNraXBwZWQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbYWJzb2x1dGVQYXRoXSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHVzZXMgYWJzb2x1dGUgcGF0aHMuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFt1bmljb2RlU3VwcG9ydF0gLSBJbmRpY2F0ZXMgaWYgdGhlIHNjaGVtZSBzdXBwb3J0cyBVbmljb2RlLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSB3c0NvbXBvbmVudFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIHdzSXNTZWN1cmUgKHdzQ29tcG9uZW50KSB7XG4gIGlmICh3c0NvbXBvbmVudC5zZWN1cmUgPT09IHRydWUpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9IGVsc2UgaWYgKHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfSBlbHNlIGlmICh3c0NvbXBvbmVudC5zY2hlbWUpIHtcbiAgICByZXR1cm4gKFxuICAgICAgd3NDb21wb25lbnQuc2NoZW1lLmxlbmd0aCA9PT0gMyAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ3cnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVswXSA9PT0gJ1cnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsxXSA9PT0gJ1MnKSAmJlxuICAgICAgKHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ3MnIHx8IHdzQ29tcG9uZW50LnNjaGVtZVsyXSA9PT0gJ1MnKVxuICAgIClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFBhcnNlIChjb21wb25lbnQpIHtcbiAgaWYgKCFjb21wb25lbnQuaG9zdCkge1xuICAgIGNvbXBvbmVudC5lcnJvciA9IGNvbXBvbmVudC5lcnJvciB8fCAnSFRUUCBVUklzIG11c3QgaGF2ZSBhIGhvc3QuJ1xuICB9XG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gaHR0cFNlcmlhbGl6ZSAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHNlY3VyZSA9IFN0cmluZyhjb21wb25lbnQuc2NoZW1lKS50b0xvd2VyQ2FzZSgpID09PSAnaHR0cHMnXG5cbiAgLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKGNvbXBvbmVudC5wb3J0ID09PSAoc2VjdXJlID8gNDQzIDogODApIHx8IGNvbXBvbmVudC5wb3J0ID09PSAnJykge1xuICAgIGNvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBub3JtYWxpemUgdGhlIGVtcHR5IHBhdGhcbiAgaWYgKCFjb21wb25lbnQucGF0aCkge1xuICAgIGNvbXBvbmVudC5wYXRoID0gJy8nXG4gIH1cblxuICAvLyBOT1RFOiBXZSBkbyBub3QgcGFyc2UgcXVlcnkgc3RyaW5ncyBmb3IgSFRUUCBVUklzXG4gIC8vIGFzIFdXVyBGb3JtIFVybCBFbmNvZGVkIHF1ZXJ5IHN0cmluZ3MgYXJlIHBhcnQgb2YgdGhlIEhUTUw0KyBzcGVjLFxuICAvLyBhbmQgbm90IHRoZSBIVFRQIHNwZWMuXG5cbiAgcmV0dXJuIGNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gd3NQYXJzZSAod3NDb21wb25lbnQpIHtcbi8vIGluZGljYXRlIGlmIHRoZSBzZWN1cmUgZmxhZyBpcyBzZXRcbiAgd3NDb21wb25lbnQuc2VjdXJlID0gd3NJc1NlY3VyZSh3c0NvbXBvbmVudClcblxuICAvLyBjb25zdHJ1Y3QgcmVzb3VjZSBuYW1lXG4gIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9ICh3c0NvbXBvbmVudC5wYXRoIHx8ICcvJykgKyAod3NDb21wb25lbnQucXVlcnkgPyAnPycgKyB3c0NvbXBvbmVudC5xdWVyeSA6ICcnKVxuICB3c0NvbXBvbmVudC5wYXRoID0gdW5kZWZpbmVkXG4gIHdzQ29tcG9uZW50LnF1ZXJ5ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB3c1NlcmlhbGl6ZSAod3NDb21wb25lbnQpIHtcbi8vIG5vcm1hbGl6ZSB0aGUgZGVmYXVsdCBwb3J0XG4gIGlmICh3c0NvbXBvbmVudC5wb3J0ID09PSAod3NJc1NlY3VyZSh3c0NvbXBvbmVudCkgPyA0NDMgOiA4MCkgfHwgd3NDb21wb25lbnQucG9ydCA9PT0gJycpIHtcbiAgICB3c0NvbXBvbmVudC5wb3J0ID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBlbnN1cmUgc2NoZW1lIG1hdGNoZXMgc2VjdXJlIGZsYWdcbiAgaWYgKHR5cGVvZiB3c0NvbXBvbmVudC5zZWN1cmUgPT09ICdib29sZWFuJykge1xuICAgIHdzQ29tcG9uZW50LnNjaGVtZSA9ICh3c0NvbXBvbmVudC5zZWN1cmUgPyAnd3NzJyA6ICd3cycpXG4gICAgd3NDb21wb25lbnQuc2VjdXJlID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyByZWNvbnN0cnVjdCBwYXRoIGZyb20gcmVzb3VyY2UgbmFtZVxuICBpZiAod3NDb21wb25lbnQucmVzb3VyY2VOYW1lKSB7XG4gICAgY29uc3QgW3BhdGgsIHF1ZXJ5XSA9IHdzQ29tcG9uZW50LnJlc291cmNlTmFtZS5zcGxpdCgnPycpXG4gICAgd3NDb21wb25lbnQucGF0aCA9IChwYXRoICYmIHBhdGggIT09ICcvJyA/IHBhdGggOiB1bmRlZmluZWQpXG4gICAgd3NDb21wb25lbnQucXVlcnkgPSBxdWVyeVxuICAgIHdzQ29tcG9uZW50LnJlc291cmNlTmFtZSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gZm9yYmlkIGZyYWdtZW50IGNvbXBvbmVudFxuICB3c0NvbXBvbmVudC5mcmFnbWVudCA9IHVuZGVmaW5lZFxuXG4gIHJldHVybiB3c0NvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuUGFyc2UgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAoIXVybkNvbXBvbmVudC5wYXRoKSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gJ1VSTiBjYW4gbm90IGJlIHBhcnNlZCdcbiAgICByZXR1cm4gdXJuQ29tcG9uZW50XG4gIH1cbiAgY29uc3QgbWF0Y2hlcyA9IHVybkNvbXBvbmVudC5wYXRoLm1hdGNoKFVSTl9SRUcpXG4gIGlmIChtYXRjaGVzKSB7XG4gICAgY29uc3Qgc2NoZW1lID0gb3B0aW9ucy5zY2hlbWUgfHwgdXJuQ29tcG9uZW50LnNjaGVtZSB8fCAndXJuJ1xuICAgIHVybkNvbXBvbmVudC5uaWQgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcbiAgICB1cm5Db21wb25lbnQubnNzID0gbWF0Y2hlc1syXVxuICAgIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCB1cm5Db21wb25lbnQubmlkfWBcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcih1cm5TY2hlbWUpXG4gICAgdXJuQ29tcG9uZW50LnBhdGggPSB1bmRlZmluZWRcblxuICAgIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgICB1cm5Db21wb25lbnQgPSBzY2hlbWVIYW5kbGVyLnBhcnNlKHVybkNvbXBvbmVudCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJuQ29tcG9uZW50LmVycm9yID0gdXJuQ29tcG9uZW50LmVycm9yIHx8ICdVUk4gY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG5cbiAgcmV0dXJuIHVybkNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJuU2VyaWFsaXplICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgaWYgKHVybkNvbXBvbmVudC5uaWQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVVJOIHdpdGhvdXQgbmlkIGNhbm5vdCBiZSBzZXJpYWxpemVkJylcbiAgfVxuICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnQuc2NoZW1lIHx8ICd1cm4nXG4gIGNvbnN0IG5pZCA9IHVybkNvbXBvbmVudC5uaWQudG9Mb3dlckNhc2UoKVxuICBjb25zdCB1cm5TY2hlbWUgPSBgJHtzY2hlbWV9OiR7b3B0aW9ucy5uaWQgfHwgbmlkfWBcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIodXJuU2NoZW1lKVxuXG4gIGlmIChzY2hlbWVIYW5kbGVyKSB7XG4gICAgdXJuQ29tcG9uZW50ID0gc2NoZW1lSGFuZGxlci5zZXJpYWxpemUodXJuQ29tcG9uZW50LCBvcHRpb25zKVxuICB9XG5cbiAgY29uc3QgdXJpQ29tcG9uZW50ID0gdXJuQ29tcG9uZW50XG4gIGNvbnN0IG5zcyA9IHVybkNvbXBvbmVudC5uc3NcbiAgdXJpQ29tcG9uZW50LnBhdGggPSBgJHtuaWQgfHwgb3B0aW9ucy5uaWR9OiR7bnNzfWBcblxuICBvcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiB1cmlDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHVybnV1aWRQYXJzZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGNvbnN0IHV1aWRDb21wb25lbnQgPSB1cm5Db21wb25lbnRcbiAgdXVpZENvbXBvbmVudC51dWlkID0gdXVpZENvbXBvbmVudC5uc3NcbiAgdXVpZENvbXBvbmVudC5uc3MgPSB1bmRlZmluZWRcblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgKCF1dWlkQ29tcG9uZW50LnV1aWQgfHwgIWlzVVVJRCh1dWlkQ29tcG9uZW50LnV1aWQpKSkge1xuICAgIHV1aWRDb21wb25lbnQuZXJyb3IgPSB1dWlkQ29tcG9uZW50LmVycm9yIHx8ICdVVUlEIGlzIG5vdCB2YWxpZC4nXG4gIH1cblxuICByZXR1cm4gdXVpZENvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJudXVpZFNlcmlhbGl6ZSAodXVpZENvbXBvbmVudCkge1xuICBjb25zdCB1cm5Db21wb25lbnQgPSB1dWlkQ29tcG9uZW50XG4gIC8vIG5vcm1hbGl6ZSBVVUlEXG4gIHVybkNvbXBvbmVudC5uc3MgPSAodXVpZENvbXBvbmVudC51dWlkIHx8ICcnKS50b0xvd2VyQ2FzZSgpXG4gIHJldHVybiB1cm5Db21wb25lbnRcbn1cblxuY29uc3QgaHR0cCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnaHR0cCcsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufSlcblxuY29uc3QgaHR0cHMgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ2h0dHBzJyxcbiAgZG9tYWluSG9zdDogaHR0cC5kb21haW5Ib3N0LFxuICBwYXJzZTogaHR0cFBhcnNlLFxuICBzZXJpYWxpemU6IGh0dHBTZXJpYWxpemVcbn0pXG5cbmNvbnN0IHdzID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd3cycsXG4gIGRvbWFpbkhvc3Q6IHRydWUsXG4gIHBhcnNlOiB3c1BhcnNlLFxuICBzZXJpYWxpemU6IHdzU2VyaWFsaXplXG59KVxuXG5jb25zdCB3c3MgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3dzcycsXG4gIGRvbWFpbkhvc3Q6IHdzLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiB3cy5wYXJzZSxcbiAgc2VyaWFsaXplOiB3cy5zZXJpYWxpemVcbn0pXG5cbmNvbnN0IHVybiA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuJyxcbiAgcGFyc2U6IHVyblBhcnNlLFxuICBzZXJpYWxpemU6IHVyblNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufSlcblxuY29uc3QgdXJudXVpZCA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAndXJuOnV1aWQnLFxuICBwYXJzZTogdXJudXVpZFBhcnNlLFxuICBzZXJpYWxpemU6IHVybnV1aWRTZXJpYWxpemUsXG4gIHNraXBOb3JtYWxpemU6IHRydWVcbn0pXG5cbmNvbnN0IFNDSEVNRVMgPSAvKiogQHR5cGUge1JlY29yZDxTY2hlbWVOYW1lLCBTY2hlbWVIYW5kbGVyPn0gKi8gKHtcbiAgaHR0cCxcbiAgaHR0cHMsXG4gIHdzLFxuICB3c3MsXG4gIHVybixcbiAgJ3Vybjp1dWlkJzogdXJudXVpZFxufSlcblxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFNDSEVNRVMsIG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd8dW5kZWZpbmVkfSBzY2hlbWVcbiAqIEByZXR1cm5zIHtTY2hlbWVIYW5kbGVyfHVuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2NoZW1lSGFuZGxlciAoc2NoZW1lKSB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1lICYmIChcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyAoc2NoZW1lKV0gfHxcbiAgICAgIFNDSEVNRVNbLyoqIEB0eXBlIHtTY2hlbWVOYW1lfSAqLyhzY2hlbWUudG9Mb3dlckNhc2UoKSldKVxuICApIHx8XG4gICAgdW5kZWZpbmVkXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3c0lzU2VjdXJlLFxuICBTQ0hFTUVTLFxuICBpc1ZhbGlkU2NoZW1lTmFtZSxcbiAgZ2V0U2NoZW1lSGFuZGxlcixcbn1cbiIsICIndXNlIHN0cmljdCdcblxuY29uc3QgeyBub3JtYWxpemVJUHY2LCByZW1vdmVEb3RTZWdtZW50cywgcmVjb21wb3NlQXV0aG9yaXR5LCBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZywgaXNJUHY0LCBub25TaW1wbGVEb21haW4gfSA9IHJlcXVpcmUoJy4vbGliL3V0aWxzJylcbmNvbnN0IHsgU0NIRU1FUywgZ2V0U2NoZW1lSGFuZGxlciB9ID0gcmVxdWlyZSgnLi9saWIvc2NoZW1lcycpXG5cbi8qKlxuICogQHRlbXBsYXRlIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR8c3RyaW5nfSBUXG4gKiBAcGFyYW0ge1R9IHVyaVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtUfVxuICovXG5mdW5jdGlvbiBub3JtYWxpemUgKHVyaSwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmkgPSAvKiogQHR5cGUge1R9ICovIChzZXJpYWxpemUocGFyc2UodXJpLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaSA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmkgPSAvKiogQHR5cGUge1R9ICovIChwYXJzZShzZXJpYWxpemUodXJpLCBvcHRpb25zKSwgb3B0aW9ucykpXG4gIH1cbiAgcmV0dXJuIHVyaVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJJXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUklcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdGlvbnNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZXNvbHZlIChiYXNlVVJJLCByZWxhdGl2ZVVSSSwgb3B0aW9ucykge1xuICBjb25zdCBzY2hlbWVsZXNzT3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHsgc2NoZW1lOiAnbnVsbCcgfSwgb3B0aW9ucykgOiB7IHNjaGVtZTogJ251bGwnIH1cbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlQ29tcG9uZW50KHBhcnNlKGJhc2VVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgcGFyc2UocmVsYXRpdmVVUkksIHNjaGVtZWxlc3NPcHRpb25zKSwgc2NoZW1lbGVzc09wdGlvbnMsIHRydWUpXG4gIHNjaGVtZWxlc3NPcHRpb25zLnNraXBFc2NhcGUgPSB0cnVlXG4gIHJldHVybiBzZXJpYWxpemUocmVzb2x2ZWQsIHNjaGVtZWxlc3NPcHRpb25zKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gYmFzZVxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSByZWxhdGl2ZVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBOb3JtYWxpemF0aW9uPWZhbHNlXVxuICogQHJldHVybnMge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnQgKGJhc2UsIHJlbGF0aXZlLCBvcHRpb25zLCBza2lwTm9ybWFsaXphdGlvbikge1xuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gKi9cbiAgY29uc3QgdGFyZ2V0ID0ge31cbiAgaWYgKCFza2lwTm9ybWFsaXphdGlvbikge1xuICAgIGJhc2UgPSBwYXJzZShzZXJpYWxpemUoYmFzZSwgb3B0aW9ucyksIG9wdGlvbnMpIC8vIG5vcm1hbGl6ZSBiYXNlIGNvbXBvbmVudFxuICAgIHJlbGF0aXZlID0gcGFyc2Uoc2VyaWFsaXplKHJlbGF0aXZlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIHJlbGF0aXZlIGNvbXBvbmVudFxuICB9XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9XG5cbiAgaWYgKCFvcHRpb25zLnRvbGVyYW50ICYmIHJlbGF0aXZlLnNjaGVtZSkge1xuICAgIHRhcmdldC5zY2hlbWUgPSByZWxhdGl2ZS5zY2hlbWVcbiAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgdGFyZ2V0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0XG4gICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgIHRhcmdldC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5XG4gIH0gZWxzZSB7XG4gICAgaWYgKHJlbGF0aXZlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUuaG9zdCAhPT0gdW5kZWZpbmVkIHx8IHJlbGF0aXZlLnBvcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IHJlbGF0aXZlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IHJlbGF0aXZlLnVzZXJpbmZvXG4gICAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gcmVsYXRpdmUucG9ydFxuICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyhyZWxhdGl2ZS5wYXRoIHx8ICcnKVxuICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFyZWxhdGl2ZS5wYXRoKSB7XG4gICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoXG4gICAgICAgIGlmIChyZWxhdGl2ZS5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSBiYXNlLnF1ZXJ5XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyZWxhdGl2ZS5wYXRoWzBdID09PSAnLycpIHtcbiAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKChiYXNlLnVzZXJpbmZvICE9PSB1bmRlZmluZWQgfHwgYmFzZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgYmFzZS5wb3J0ICE9PSB1bmRlZmluZWQpICYmICFiYXNlLnBhdGgpIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gJy8nICsgcmVsYXRpdmUucGF0aFxuICAgICAgICAgIH0gZWxzZSBpZiAoIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKDAsIGJhc2UucGF0aC5sYXN0SW5kZXhPZignLycpICsgMSkgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfVxuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHModGFyZ2V0LnBhdGgpXG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgICAgIH1cbiAgICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSBiYXNlLmF1dGhvcml0eTtcbiAgICAgIHRhcmdldC51c2VyaW5mbyA9IGJhc2UudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gYmFzZS5ob3N0XG4gICAgICB0YXJnZXQucG9ydCA9IGJhc2UucG9ydFxuICAgIH1cbiAgICB0YXJnZXQuc2NoZW1lID0gYmFzZS5zY2hlbWVcbiAgfVxuXG4gIHRhcmdldC5mcmFnbWVudCA9IHJlbGF0aXZlLmZyYWdtZW50XG5cbiAgcmV0dXJuIHRhcmdldFxufVxuXG4vKipcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IHVyaUFcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IHVyaUJcbiAqIEBwYXJhbSB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBlcXVhbCAodXJpQSwgdXJpQiwgb3B0aW9ucykge1xuICBpZiAodHlwZW9mIHVyaUEgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQSA9IHVuZXNjYXBlKHVyaUEpXG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlBLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlBID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUEgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgaWYgKHR5cGVvZiB1cmlCID09PSAnc3RyaW5nJykge1xuICAgIHVyaUIgPSB1bmVzY2FwZSh1cmlCKVxuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcocGFyc2UodXJpQiwgb3B0aW9ucyksIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpQiA9PT0gJ29iamVjdCcpIHtcbiAgICB1cmlCID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHVyaUIsIHRydWUpLCB7IC4uLm9wdGlvbnMsIHNraXBFc2NhcGU6IHRydWUgfSlcbiAgfVxuXG4gIHJldHVybiB1cmlBLnRvTG93ZXJDYXNlKCkgPT09IHVyaUIudG9Mb3dlckNhc2UoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhZG9ubHk8aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50Pn0gY21wdHNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdHNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzZXJpYWxpemUgKGNtcHRzLCBvcHRzKSB7XG4gIGNvbnN0IGNvbXBvbmVudCA9IHtcbiAgICBob3N0OiBjbXB0cy5ob3N0LFxuICAgIHNjaGVtZTogY21wdHMuc2NoZW1lLFxuICAgIHVzZXJpbmZvOiBjbXB0cy51c2VyaW5mbyxcbiAgICBwb3J0OiBjbXB0cy5wb3J0LFxuICAgIHBhdGg6IGNtcHRzLnBhdGgsXG4gICAgcXVlcnk6IGNtcHRzLnF1ZXJ5LFxuICAgIG5pZDogY21wdHMubmlkLFxuICAgIG5zczogY21wdHMubnNzLFxuICAgIHV1aWQ6IGNtcHRzLnV1aWQsXG4gICAgZnJhZ21lbnQ6IGNtcHRzLmZyYWdtZW50LFxuICAgIHJlZmVyZW5jZTogY21wdHMucmVmZXJlbmNlLFxuICAgIHJlc291cmNlTmFtZTogY21wdHMucmVzb3VyY2VOYW1lLFxuICAgIHNlY3VyZTogY21wdHMuc2VjdXJlLFxuICAgIGVycm9yOiAnJ1xuICB9XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICBjb25zdCB1cmlUb2tlbnMgPSBbXVxuXG4gIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIob3B0aW9ucy5zY2hlbWUgfHwgY29tcG9uZW50LnNjaGVtZSlcblxuICAvLyBwZXJmb3JtIHNjaGVtZSBzcGVjaWZpYyBzZXJpYWxpemF0aW9uXG4gIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZShjb21wb25lbnQsIG9wdGlvbnMpXG5cbiAgaWYgKGNvbXBvbmVudC5wYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoIW9wdGlvbnMuc2tpcEVzY2FwZSkge1xuICAgICAgY29tcG9uZW50LnBhdGggPSBlc2NhcGUoY29tcG9uZW50LnBhdGgpXG5cbiAgICAgIGlmIChjb21wb25lbnQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29tcG9uZW50LnBhdGggPSBjb21wb25lbnQucGF0aC5zcGxpdCgnJTNBJykuam9pbignOicpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBvbmVudC5wYXRoID0gdW5lc2NhcGUoY29tcG9uZW50LnBhdGgpXG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBjb21wb25lbnQuc2NoZW1lKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50LnNjaGVtZSwgJzonKVxuICB9XG5cbiAgY29uc3QgYXV0aG9yaXR5ID0gcmVjb21wb3NlQXV0aG9yaXR5KGNvbXBvbmVudClcbiAgaWYgKGF1dGhvcml0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4Jykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8vJylcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChhdXRob3JpdHkpXG5cbiAgICBpZiAoY29tcG9uZW50LnBhdGggJiYgY29tcG9uZW50LnBhdGhbMF0gIT09ICcvJykge1xuICAgICAgdXJpVG9rZW5zLnB1c2goJy8nKVxuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGxldCBzID0gY29tcG9uZW50LnBhdGhcblxuICAgIGlmICghb3B0aW9ucy5hYnNvbHV0ZVBhdGggJiYgKCFzY2hlbWVIYW5kbGVyIHx8ICFzY2hlbWVIYW5kbGVyLmFic29sdXRlUGF0aCkpIHtcbiAgICAgIHMgPSByZW1vdmVEb3RTZWdtZW50cyhzKVxuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGF1dGhvcml0eSA9PT0gdW5kZWZpbmVkICYmXG4gICAgICBzWzBdID09PSAnLycgJiZcbiAgICAgIHNbMV0gPT09ICcvJ1xuICAgICkge1xuICAgICAgLy8gZG9uJ3QgYWxsb3cgdGhlIHBhdGggdG8gc3RhcnQgd2l0aCBcIi8vXCJcbiAgICAgIHMgPSAnLyUyRicgKyBzLnNsaWNlKDIpXG4gICAgfVxuXG4gICAgdXJpVG9rZW5zLnB1c2gocylcbiAgfVxuXG4gIGlmIChjb21wb25lbnQucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIHVyaVRva2Vucy5wdXNoKCc/JywgY29tcG9uZW50LnF1ZXJ5KVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5mcmFnbWVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJyMnLCBjb21wb25lbnQuZnJhZ21lbnQpXG4gIH1cbiAgcmV0dXJuIHVyaVRva2Vucy5qb2luKCcnKVxufVxuXG5jb25zdCBVUklfUEFSU0UgPSAvXig/OihbXiMvOj9dKyk6KT8oPzpcXC9cXC8oKD86KFteIy8/QF0qKUApPyhcXFtbXiMvP1xcXV0rXFxdfFteIy86P10qKSg/OjooXFxkKikpPykpPyhbXiM/XSopKD86XFw/KFteI10qKSk/KD86IygoPzoufFtcXG5cXHJdKSopKT8vdVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmlcbiAqIEBwYXJhbSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gW29wdHNdXG4gKiBAcmV0dXJuc1xuICovXG5mdW5jdGlvbiBwYXJzZSAodXJpLCBvcHRzKSB7XG4gIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRzKVxuICAvKiogQHR5cGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH0gKi9cbiAgY29uc3QgcGFyc2VkID0ge1xuICAgIHNjaGVtZTogdW5kZWZpbmVkLFxuICAgIHVzZXJpbmZvOiB1bmRlZmluZWQsXG4gICAgaG9zdDogJycsXG4gICAgcG9ydDogdW5kZWZpbmVkLFxuICAgIHBhdGg6ICcnLFxuICAgIHF1ZXJ5OiB1bmRlZmluZWQsXG4gICAgZnJhZ21lbnQ6IHVuZGVmaW5lZFxuICB9XG5cbiAgbGV0IGlzSVAgPSBmYWxzZVxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgPT09ICdzdWZmaXgnKSB7XG4gICAgaWYgKG9wdGlvbnMuc2NoZW1lKSB7XG4gICAgICB1cmkgPSBvcHRpb25zLnNjaGVtZSArICc6JyArIHVyaVxuICAgIH0gZWxzZSB7XG4gICAgICB1cmkgPSAnLy8nICsgdXJpXG4gICAgfVxuICB9XG5cbiAgY29uc3QgbWF0Y2hlcyA9IHVyaS5tYXRjaChVUklfUEFSU0UpXG5cbiAgaWYgKG1hdGNoZXMpIHtcbiAgICAvLyBzdG9yZSBlYWNoIGNvbXBvbmVudFxuICAgIHBhcnNlZC5zY2hlbWUgPSBtYXRjaGVzWzFdXG4gICAgcGFyc2VkLnVzZXJpbmZvID0gbWF0Y2hlc1szXVxuICAgIHBhcnNlZC5ob3N0ID0gbWF0Y2hlc1s0XVxuICAgIHBhcnNlZC5wb3J0ID0gcGFyc2VJbnQobWF0Y2hlc1s1XSwgMTApXG4gICAgcGFyc2VkLnBhdGggPSBtYXRjaGVzWzZdIHx8ICcnXG4gICAgcGFyc2VkLnF1ZXJ5ID0gbWF0Y2hlc1s3XVxuICAgIHBhcnNlZC5mcmFnbWVudCA9IG1hdGNoZXNbOF1cblxuICAgIC8vIGZpeCBwb3J0IG51bWJlclxuICAgIGlmIChpc05hTihwYXJzZWQucG9ydCkpIHtcbiAgICAgIHBhcnNlZC5wb3J0ID0gbWF0Y2hlc1s1XVxuICAgIH1cbiAgICBpZiAocGFyc2VkLmhvc3QpIHtcbiAgICAgIGNvbnN0IGlwdjRyZXN1bHQgPSBpc0lQdjQocGFyc2VkLmhvc3QpXG4gICAgICBpZiAoaXB2NHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgaXB2NnJlc3VsdCA9IG5vcm1hbGl6ZUlQdjYocGFyc2VkLmhvc3QpXG4gICAgICAgIHBhcnNlZC5ob3N0ID0gaXB2NnJlc3VsdC5ob3N0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgaXNJUCA9IGlwdjZyZXN1bHQuaXNJUFY2XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpc0lQID0gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC51c2VyaW5mbyA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5ob3N0ID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnBvcnQgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucXVlcnkgPT09IHVuZGVmaW5lZCAmJiAhcGFyc2VkLnBhdGgpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnc2FtZS1kb2N1bWVudCdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5zY2hlbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdyZWxhdGl2ZSdcbiAgICB9IGVsc2UgaWYgKHBhcnNlZC5mcmFnbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ2Fic29sdXRlJ1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3VyaSdcbiAgICB9XG5cbiAgICAvLyBjaGVjayBmb3IgcmVmZXJlbmNlIGVycm9yc1xuICAgIGlmIChvcHRpb25zLnJlZmVyZW5jZSAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gJ3N1ZmZpeCcgJiYgb3B0aW9ucy5yZWZlcmVuY2UgIT09IHBhcnNlZC5yZWZlcmVuY2UpIHtcbiAgICAgIHBhcnNlZC5lcnJvciA9IHBhcnNlZC5lcnJvciB8fCAnVVJJIGlzIG5vdCBhICcgKyBvcHRpb25zLnJlZmVyZW5jZSArICcgcmVmZXJlbmNlLidcbiAgICB9XG5cbiAgICAvLyBmaW5kIHNjaGVtZSBoYW5kbGVyXG4gICAgY29uc3Qgc2NoZW1lSGFuZGxlciA9IGdldFNjaGVtZUhhbmRsZXIob3B0aW9ucy5zY2hlbWUgfHwgcGFyc2VkLnNjaGVtZSlcblxuICAgIC8vIGNoZWNrIGlmIHNjaGVtZSBjYW4ndCBoYW5kbGUgSVJJc1xuICAgIGlmICghb3B0aW9ucy51bmljb2RlU3VwcG9ydCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIudW5pY29kZVN1cHBvcnQpKSB7XG4gICAgICAvLyBpZiBob3N0IGNvbXBvbmVudCBpcyBhIGRvbWFpbiBuYW1lXG4gICAgICBpZiAocGFyc2VkLmhvc3QgJiYgKG9wdGlvbnMuZG9tYWluSG9zdCB8fCAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLmRvbWFpbkhvc3QpKSAmJiBpc0lQID09PSBmYWxzZSAmJiBub25TaW1wbGVEb21haW4ocGFyc2VkLmhvc3QpKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgVW5pY29kZSBJRE4gLT4gQVNDSUkgSUROXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSBVUkwuZG9tYWluVG9BU0NJSShwYXJzZWQuaG9zdC50b0xvd2VyQ2FzZSgpKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8IFwiSG9zdCdzIGRvbWFpbiBuYW1lIGNhbiBub3QgYmUgY29udmVydGVkIHRvIEFTQ0lJOiBcIiArIGVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gY29udmVydCBJUkkgLT4gVVJJXG4gICAgfVxuXG4gICAgaWYgKCFzY2hlbWVIYW5kbGVyIHx8IChzY2hlbWVIYW5kbGVyICYmICFzY2hlbWVIYW5kbGVyLnNraXBOb3JtYWxpemUpKSB7XG4gICAgICBpZiAodXJpLmluZGV4T2YoJyUnKSAhPT0gLTEpIHtcbiAgICAgICAgaWYgKHBhcnNlZC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHBhcnNlZC5zY2hlbWUgPSB1bmVzY2FwZShwYXJzZWQuc2NoZW1lKVxuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJzZWQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyc2VkLmhvc3QgPSB1bmVzY2FwZShwYXJzZWQuaG9zdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5wYXRoKSB7XG4gICAgICAgIHBhcnNlZC5wYXRoID0gZXNjYXBlKHVuZXNjYXBlKHBhcnNlZC5wYXRoKSlcbiAgICAgIH1cbiAgICAgIGlmIChwYXJzZWQuZnJhZ21lbnQpIHtcbiAgICAgICAgcGFyc2VkLmZyYWdtZW50ID0gZW5jb2RlVVJJKGRlY29kZVVSSUNvbXBvbmVudChwYXJzZWQuZnJhZ21lbnQpKVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHBhcnNpbmdcbiAgICBpZiAoc2NoZW1lSGFuZGxlciAmJiBzY2hlbWVIYW5kbGVyLnBhcnNlKSB7XG4gICAgICBzY2hlbWVIYW5kbGVyLnBhcnNlKHBhcnNlZCwgb3B0aW9ucylcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgY2FuIG5vdCBiZSBwYXJzZWQuJ1xuICB9XG4gIHJldHVybiBwYXJzZWRcbn1cblxuY29uc3QgZmFzdFVyaSA9IHtcbiAgU0NIRU1FUyxcbiAgbm9ybWFsaXplLFxuICByZXNvbHZlLFxuICByZXNvbHZlQ29tcG9uZW50LFxuICBlcXVhbCxcbiAgc2VyaWFsaXplLFxuICBwYXJzZVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBmYXN0VXJpXG5tb2R1bGUuZXhwb3J0cy5mYXN0VXJpID0gZmFzdFVyaVxuIiwgImltcG9ydCAqIGFzIHVyaSBmcm9tIFwiZmFzdC11cmlcIlxuXG50eXBlIFVSSSA9IHR5cGVvZiB1cmkgJiB7Y29kZTogc3RyaW5nfVxuOyh1cmkgYXMgVVJJKS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VyaVwiKS5kZWZhdWx0J1xuXG5leHBvcnQgZGVmYXVsdCB1cmkgYXMgVVJJXG4iLCAiZXhwb3J0IHtcbiAgRm9ybWF0LFxuICBGb3JtYXREZWZpbml0aW9uLFxuICBBc3luY0Zvcm1hdERlZmluaXRpb24sXG4gIEtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIE1hY3JvS2V5d29yZERlZmluaXRpb24sXG4gIEZ1bmNLZXl3b3JkRGVmaW5pdGlvbixcbiAgVm9jYWJ1bGFyeSxcbiAgU2NoZW1hLFxuICBTY2hlbWFPYmplY3QsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgQXN5bmNTY2hlbWEsXG4gIEFueVNjaGVtYSxcbiAgVmFsaWRhdGVGdW5jdGlvbixcbiAgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgRXJyb3JOb1BhcmFtcyxcbn0gZnJvbSBcIi4vdHlwZXNcIlxuXG5leHBvcnQge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi9jb21waWxlXCJcbmV4cG9ydCBpbnRlcmZhY2UgUGx1Z2luPE9wdHM+IHtcbiAgKGFqdjogQWp2LCBvcHRpb25zPzogT3B0cyk6IEFqdlxuICBbcHJvcDogc3RyaW5nXTogYW55XG59XG5cbmV4cG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcIi4vY29tcGlsZS92YWxpZGF0ZVwiXG5leHBvcnQge0RlZmluZWRFcnJvcn0gZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2Vycm9yc1wiXG5leHBvcnQge0pTT05UeXBlfSBmcm9tIFwiLi9jb21waWxlL3J1bGVzXCJcbmV4cG9ydCB7SlNPTlNjaGVtYVR5cGV9IGZyb20gXCIuL3R5cGVzL2pzb24tc2NoZW1hXCJcbmV4cG9ydCB7SlREU2NoZW1hVHlwZSwgU29tZUpURFNjaGVtYVR5cGUsIEpURERhdGFUeXBlfSBmcm9tIFwiLi90eXBlcy9qdGQtc2NoZW1hXCJcbmV4cG9ydCB7Xywgc3RyLCBzdHJpbmdpZnksIG5pbCwgTmFtZSwgQ29kZSwgQ29kZUdlbiwgQ29kZUdlbk9wdGlvbnN9IGZyb20gXCIuL2NvbXBpbGUvY29kZWdlblwiXG5cbmltcG9ydCB0eXBlIHtcbiAgU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgU2NoZW1hT2JqZWN0LFxuICBBc3luY1NjaGVtYSxcbiAgVm9jYWJ1bGFyeSxcbiAgS2V5d29yZERlZmluaXRpb24sXG4gIEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEZvcm1hdCxcbiAgQWRkZWRGb3JtYXQsXG4gIFJlZ0V4cEVuZ2luZSxcbiAgVXJpUmVzb2x2ZXIsXG59IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtKU09OU2NoZW1hVHlwZX0gZnJvbSBcIi4vdHlwZXMvanNvbi1zY2hlbWFcIlxuaW1wb3J0IHR5cGUge0pURFNjaGVtYVR5cGUsIFNvbWVKVERTY2hlbWFUeXBlLCBKVEREYXRhVHlwZX0gZnJvbSBcIi4vdHlwZXMvanRkLXNjaGVtYVwiXG5pbXBvcnQgVmFsaWRhdGlvbkVycm9yIGZyb20gXCIuL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiXG5pbXBvcnQgTWlzc2luZ1JlZkVycm9yIGZyb20gXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCJcbmltcG9ydCB7Z2V0UnVsZXMsIFZhbGlkYXRpb25SdWxlcywgUnVsZSwgUnVsZUdyb3VwLCBKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5pbXBvcnQge1NjaGVtYUVudiwgY29tcGlsZVNjaGVtYSwgcmVzb2x2ZVNjaGVtYX0gZnJvbSBcIi4vY29tcGlsZVwiXG5pbXBvcnQge0NvZGUsIFZhbHVlU2NvcGV9IGZyb20gXCIuL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge25vcm1hbGl6ZUlkLCBnZXRTY2hlbWFSZWZzfSBmcm9tIFwiLi9jb21waWxlL3Jlc29sdmVcIlxuaW1wb3J0IHtnZXRKU09OVHlwZXN9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGVcIlxuaW1wb3J0IHtlYWNoSXRlbX0gZnJvbSBcIi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCAqIGFzICRkYXRhUmVmU2NoZW1hIGZyb20gXCIuL3JlZnMvZGF0YS5qc29uXCJcblxuaW1wb3J0IERlZmF1bHRVcmlSZXNvbHZlciBmcm9tIFwiLi9ydW50aW1lL3VyaVwiXG5cbmNvbnN0IGRlZmF1bHRSZWdFeHA6IFJlZ0V4cEVuZ2luZSA9IChzdHIsIGZsYWdzKSA9PiBuZXcgUmVnRXhwKHN0ciwgZmxhZ3MpXG5kZWZhdWx0UmVnRXhwLmNvZGUgPSBcIm5ldyBSZWdFeHBcIlxuXG5jb25zdCBNRVRBX0lHTk9SRV9PUFRJT05TOiAoa2V5b2YgT3B0aW9ucylbXSA9IFtcInJlbW92ZUFkZGl0aW9uYWxcIiwgXCJ1c2VEZWZhdWx0c1wiLCBcImNvZXJjZVR5cGVzXCJdXG5jb25zdCBFWFRfU0NPUEVfTkFNRVMgPSBuZXcgU2V0KFtcbiAgXCJ2YWxpZGF0ZVwiLFxuICBcInNlcmlhbGl6ZVwiLFxuICBcInBhcnNlXCIsXG4gIFwid3JhcHBlclwiLFxuICBcInJvb3RcIixcbiAgXCJzY2hlbWFcIixcbiAgXCJrZXl3b3JkXCIsXG4gIFwicGF0dGVyblwiLFxuICBcImZvcm1hdHNcIixcbiAgXCJ2YWxpZGF0ZSRkYXRhXCIsXG4gIFwiZnVuY1wiLFxuICBcIm9ialwiLFxuICBcIkVycm9yXCIsXG5dKVxuXG5leHBvcnQgdHlwZSBPcHRpb25zID0gQ3VycmVudE9wdGlvbnMgJiBEZXByZWNhdGVkT3B0aW9uc1xuXG5leHBvcnQgaW50ZXJmYWNlIEN1cnJlbnRPcHRpb25zIHtcbiAgLy8gc3RyaWN0IG1vZGUgb3B0aW9ucyAoTkVXKVxuICBzdHJpY3Q/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RTY2hlbWE/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3ROdW1iZXJzPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgc3RyaWN0VHlwZXM/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RUdXBsZXM/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RSZXF1aXJlZD86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIGFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzPzogYm9vbGVhbiAvLyBkaXNhYmxlcyBhIHN0cmljdCBtb2RlIHJlc3RyaWN0aW9uXG4gIGFsbG93VW5pb25UeXBlcz86IGJvb2xlYW5cbiAgdmFsaWRhdGVGb3JtYXRzPzogYm9vbGVhblxuICAvLyB2YWxpZGF0aW9uIGFuZCByZXBvcnRpbmcgb3B0aW9uczpcbiAgJGRhdGE/OiBib29sZWFuXG4gIGFsbEVycm9ycz86IGJvb2xlYW5cbiAgdmVyYm9zZT86IGJvb2xlYW5cbiAgZGlzY3JpbWluYXRvcj86IGJvb2xlYW5cbiAgdW5pY29kZVJlZ0V4cD86IGJvb2xlYW5cbiAgdGltZXN0YW1wPzogXCJzdHJpbmdcIiB8IFwiZGF0ZVwiIC8vIEpURCBvbmx5XG4gIHBhcnNlRGF0ZT86IGJvb2xlYW4gLy8gSlREIG9ubHlcbiAgYWxsb3dEYXRlPzogYm9vbGVhbiAvLyBKVEQgb25seVxuICAkY29tbWVudD86XG4gICAgfCB0cnVlXG4gICAgfCAoKGNvbW1lbnQ6IHN0cmluZywgc2NoZW1hUGF0aD86IHN0cmluZywgcm9vdFNjaGVtYT86IEFueVNjaGVtYU9iamVjdCkgPT4gdW5rbm93bilcbiAgZm9ybWF0cz86IHtbTmFtZSBpbiBzdHJpbmddPzogRm9ybWF0fVxuICBrZXl3b3Jkcz86IFZvY2FidWxhcnlcbiAgc2NoZW1hcz86IEFueVNjaGVtYVtdIHwge1tLZXkgaW4gc3RyaW5nXT86IEFueVNjaGVtYX1cbiAgbG9nZ2VyPzogTG9nZ2VyIHwgZmFsc2VcbiAgbG9hZFNjaGVtYT86ICh1cmk6IHN0cmluZykgPT4gUHJvbWlzZTxBbnlTY2hlbWFPYmplY3Q+XG4gIC8vIG9wdGlvbnMgdG8gbW9kaWZ5IHZhbGlkYXRlZCBkYXRhOlxuICByZW1vdmVBZGRpdGlvbmFsPzogYm9vbGVhbiB8IFwiYWxsXCIgfCBcImZhaWxpbmdcIlxuICB1c2VEZWZhdWx0cz86IGJvb2xlYW4gfCBcImVtcHR5XCJcbiAgY29lcmNlVHlwZXM/OiBib29sZWFuIHwgXCJhcnJheVwiXG4gIC8vIGFkdmFuY2VkIG9wdGlvbnM6XG4gIG5leHQ/OiBib29sZWFuIC8vIE5FV1xuICB1bmV2YWx1YXRlZD86IGJvb2xlYW4gLy8gTkVXXG4gIGR5bmFtaWNSZWY/OiBib29sZWFuIC8vIE5FV1xuICBzY2hlbWFJZD86IFwiaWRcIiB8IFwiJGlkXCJcbiAganRkPzogYm9vbGVhbiAvLyBORVdcbiAgbWV0YT86IFNjaGVtYU9iamVjdCB8IGJvb2xlYW5cbiAgZGVmYXVsdE1ldGE/OiBzdHJpbmcgfCBBbnlTY2hlbWFPYmplY3RcbiAgdmFsaWRhdGVTY2hlbWE/OiBib29sZWFuIHwgXCJsb2dcIlxuICBhZGRVc2VkU2NoZW1hPzogYm9vbGVhblxuICBpbmxpbmVSZWZzPzogYm9vbGVhbiB8IG51bWJlclxuICBwYXNzQ29udGV4dD86IGJvb2xlYW5cbiAgbG9vcFJlcXVpcmVkPzogbnVtYmVyXG4gIGxvb3BFbnVtPzogbnVtYmVyIC8vIE5FV1xuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxuICBtdWx0aXBsZU9mUHJlY2lzaW9uPzogbnVtYmVyXG4gIGludDMycmFuZ2U/OiBib29sZWFuIC8vIEpURCBvbmx5XG4gIG1lc3NhZ2VzPzogYm9vbGVhblxuICBjb2RlPzogQ29kZU9wdGlvbnMgLy8gTkVXXG4gIHVyaVJlc29sdmVyPzogVXJpUmVzb2x2ZXJcbn1cblxuZXhwb3J0IGludGVyZmFjZSBDb2RlT3B0aW9ucyB7XG4gIGVzNT86IGJvb2xlYW5cbiAgZXNtPzogYm9vbGVhblxuICBsaW5lcz86IGJvb2xlYW5cbiAgb3B0aW1pemU/OiBib29sZWFuIHwgbnVtYmVyXG4gIGZvcm1hdHM/OiBDb2RlIC8vIGNvZGUgdG8gcmVxdWlyZSAob3IgY29uc3RydWN0KSBtYXAgb2YgYXZhaWxhYmxlIGZvcm1hdHMgLSBmb3Igc3RhbmRhbG9uZSBjb2RlXG4gIHNvdXJjZT86IGJvb2xlYW5cbiAgcHJvY2Vzcz86IChjb2RlOiBzdHJpbmcsIHNjaGVtYT86IFNjaGVtYUVudikgPT4gc3RyaW5nXG4gIHJlZ0V4cD86IFJlZ0V4cEVuZ2luZVxufVxuXG5pbnRlcmZhY2UgSW5zdGFuY2VDb2RlT3B0aW9ucyBleHRlbmRzIENvZGVPcHRpb25zIHtcbiAgcmVnRXhwOiBSZWdFeHBFbmdpbmVcbiAgb3B0aW1pemU6IG51bWJlclxufVxuXG5pbnRlcmZhY2UgRGVwcmVjYXRlZE9wdGlvbnMge1xuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgaWdub3JlS2V5d29yZHNXaXRoUmVmPzogYm9vbGVhblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAganNQcm9wZXJ0eVN5bnRheD86IGJvb2xlYW4gLy8gYWRkZWQgaW5zdGVhZCBvZiBqc29uUG9pbnRlcnNcbiAgLyoqIEBkZXByZWNhdGVkICovXG4gIHVuaWNvZGU/OiBib29sZWFuXG59XG5cbmludGVyZmFjZSBSZW1vdmVkT3B0aW9ucyB7XG4gIGZvcm1hdD86IGJvb2xlYW5cbiAgZXJyb3JEYXRhUGF0aD86IFwib2JqZWN0XCIgfCBcInByb3BlcnR5XCJcbiAgbnVsbGFibGU/OiBib29sZWFuIC8vIFwibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0XG4gIGpzb25Qb2ludGVycz86IGJvb2xlYW5cbiAgZXh0ZW5kUmVmcz86IHRydWUgfCBcImlnbm9yZVwiIHwgXCJmYWlsXCJcbiAgbWlzc2luZ1JlZnM/OiB0cnVlIHwgXCJpZ25vcmVcIiB8IFwiZmFpbFwiXG4gIHByb2Nlc3NDb2RlPzogKGNvZGU6IHN0cmluZywgc2NoZW1hPzogU2NoZW1hRW52KSA9PiBzdHJpbmdcbiAgc291cmNlQ29kZT86IGJvb2xlYW5cbiAgc3RyaWN0RGVmYXVsdHM/OiBib29sZWFuXG4gIHN0cmljdEtleXdvcmRzPzogYm9vbGVhblxuICB1bmlxdWVJdGVtcz86IGJvb2xlYW5cbiAgdW5rbm93bkZvcm1hdHM/OiB0cnVlIHwgc3RyaW5nW10gfCBcImlnbm9yZVwiXG4gIGNhY2hlPzogYW55XG4gIHNlcmlhbGl6ZT86IChzY2hlbWE6IEFueVNjaGVtYSkgPT4gdW5rbm93blxuICBhanZFcnJvcnM/OiBib29sZWFuXG59XG5cbnR5cGUgT3B0aW9uc0luZm88VCBleHRlbmRzIFJlbW92ZWRPcHRpb25zIHwgRGVwcmVjYXRlZE9wdGlvbnM+ID0ge1xuICBbSyBpbiBrZXlvZiBUXS0/OiBzdHJpbmcgfCB1bmRlZmluZWRcbn1cblxuY29uc3QgcmVtb3ZlZE9wdGlvbnM6IE9wdGlvbnNJbmZvPFJlbW92ZWRPcHRpb25zPiA9IHtcbiAgZXJyb3JEYXRhUGF0aDogXCJcIixcbiAgZm9ybWF0OiBcImB2YWxpZGF0ZUZvcm1hdHM6IGZhbHNlYCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICBudWxsYWJsZTogJ1wibnVsbGFibGVcIiBrZXl3b3JkIGlzIHN1cHBvcnRlZCBieSBkZWZhdWx0LicsXG4gIGpzb25Qb2ludGVyczogXCJEZXByZWNhdGVkIGpzUHJvcGVydHlTeW50YXggY2FuIGJlIHVzZWQgaW5zdGVhZC5cIixcbiAgZXh0ZW5kUmVmczogXCJEZXByZWNhdGVkIGlnbm9yZUtleXdvcmRzV2l0aFJlZiBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICBtaXNzaW5nUmVmczogXCJQYXNzIGVtcHR5IHNjaGVtYSB3aXRoICRpZCB0aGF0IHNob3VsZCBiZSBpZ25vcmVkIHRvIGFqdi5hZGRTY2hlbWEuXCIsXG4gIHByb2Nlc3NDb2RlOiBcIlVzZSBvcHRpb24gYGNvZGU6IHtwcm9jZXNzOiAoY29kZSwgc2NoZW1hRW52OiBvYmplY3QpID0+IHN0cmluZ31gXCIsXG4gIHNvdXJjZUNvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3NvdXJjZTogdHJ1ZX1gXCIsXG4gIHN0cmljdERlZmF1bHRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICBzdHJpY3RLZXl3b3JkczogXCJJdCBpcyBkZWZhdWx0IG5vdywgc2VlIG9wdGlvbiBgc3RyaWN0YC5cIixcbiAgdW5pcXVlSXRlbXM6ICdcInVuaXF1ZUl0ZW1zXCIga2V5d29yZCBpcyBhbHdheXMgdmFsaWRhdGVkLicsXG4gIHVua25vd25Gb3JtYXRzOiBcIkRpc2FibGUgc3RyaWN0IG1vZGUgb3IgcGFzcyBgdHJ1ZWAgdG8gYGFqdi5hZGRGb3JtYXRgIChvciBgZm9ybWF0c2Agb3B0aW9uKS5cIixcbiAgY2FjaGU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICBzZXJpYWxpemU6IFwiTWFwIGlzIHVzZWQgYXMgY2FjaGUsIHNjaGVtYSBvYmplY3QgYXMga2V5LlwiLFxuICBhanZFcnJvcnM6IFwiSXQgaXMgZGVmYXVsdCBub3cuXCIsXG59XG5cbmNvbnN0IGRlcHJlY2F0ZWRPcHRpb25zOiBPcHRpb25zSW5mbzxEZXByZWNhdGVkT3B0aW9ucz4gPSB7XG4gIGlnbm9yZUtleXdvcmRzV2l0aFJlZjogXCJcIixcbiAganNQcm9wZXJ0eVN5bnRheDogXCJcIixcbiAgdW5pY29kZTogJ1wibWluTGVuZ3RoXCIvXCJtYXhMZW5ndGhcIiBhY2NvdW50IGZvciB1bmljb2RlIGNoYXJhY3RlcnMgYnkgZGVmYXVsdC4nLFxufVxuXG50eXBlIFJlcXVpcmVkSW5zdGFuY2VPcHRpb25zID0ge1xuICBbSyBpblxuICAgIHwgXCJzdHJpY3RTY2hlbWFcIlxuICAgIHwgXCJzdHJpY3ROdW1iZXJzXCJcbiAgICB8IFwic3RyaWN0VHlwZXNcIlxuICAgIHwgXCJzdHJpY3RUdXBsZXNcIlxuICAgIHwgXCJzdHJpY3RSZXF1aXJlZFwiXG4gICAgfCBcImlubGluZVJlZnNcIlxuICAgIHwgXCJsb29wUmVxdWlyZWRcIlxuICAgIHwgXCJsb29wRW51bVwiXG4gICAgfCBcIm1ldGFcIlxuICAgIHwgXCJtZXNzYWdlc1wiXG4gICAgfCBcInNjaGVtYUlkXCJcbiAgICB8IFwiYWRkVXNlZFNjaGVtYVwiXG4gICAgfCBcInZhbGlkYXRlU2NoZW1hXCJcbiAgICB8IFwidmFsaWRhdGVGb3JtYXRzXCJcbiAgICB8IFwiaW50MzJyYW5nZVwiXG4gICAgfCBcInVuaWNvZGVSZWdFeHBcIlxuICAgIHwgXCJ1cmlSZXNvbHZlclwiXTogTm9uTnVsbGFibGU8T3B0aW9uc1tLXT5cbn0gJiB7Y29kZTogSW5zdGFuY2VDb2RlT3B0aW9uc31cblxuZXhwb3J0IHR5cGUgSW5zdGFuY2VPcHRpb25zID0gT3B0aW9ucyAmIFJlcXVpcmVkSW5zdGFuY2VPcHRpb25zXG5cbmNvbnN0IE1BWF9FWFBSRVNTSU9OID0gMjAwXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiByZXF1aXJlZE9wdGlvbnMobzogT3B0aW9ucyk6IFJlcXVpcmVkSW5zdGFuY2VPcHRpb25zIHtcbiAgY29uc3QgcyA9IG8uc3RyaWN0XG4gIGNvbnN0IF9vcHR6ID0gby5jb2RlPy5vcHRpbWl6ZVxuICBjb25zdCBvcHRpbWl6ZSA9IF9vcHR6ID09PSB0cnVlIHx8IF9vcHR6ID09PSB1bmRlZmluZWQgPyAxIDogX29wdHogfHwgMFxuICBjb25zdCByZWdFeHAgPSBvLmNvZGU/LnJlZ0V4cCA/PyBkZWZhdWx0UmVnRXhwXG4gIGNvbnN0IHVyaVJlc29sdmVyID0gby51cmlSZXNvbHZlciA/PyBEZWZhdWx0VXJpUmVzb2x2ZXJcbiAgcmV0dXJuIHtcbiAgICBzdHJpY3RTY2hlbWE6IG8uc3RyaWN0U2NoZW1hID8/IHMgPz8gdHJ1ZSxcbiAgICBzdHJpY3ROdW1iZXJzOiBvLnN0cmljdE51bWJlcnMgPz8gcyA/PyB0cnVlLFxuICAgIHN0cmljdFR5cGVzOiBvLnN0cmljdFR5cGVzID8/IHMgPz8gXCJsb2dcIixcbiAgICBzdHJpY3RUdXBsZXM6IG8uc3RyaWN0VHVwbGVzID8/IHMgPz8gXCJsb2dcIixcbiAgICBzdHJpY3RSZXF1aXJlZDogby5zdHJpY3RSZXF1aXJlZCA/PyBzID8/IGZhbHNlLFxuICAgIGNvZGU6IG8uY29kZSA/IHsuLi5vLmNvZGUsIG9wdGltaXplLCByZWdFeHB9IDoge29wdGltaXplLCByZWdFeHB9LFxuICAgIGxvb3BSZXF1aXJlZDogby5sb29wUmVxdWlyZWQgPz8gTUFYX0VYUFJFU1NJT04sXG4gICAgbG9vcEVudW06IG8ubG9vcEVudW0gPz8gTUFYX0VYUFJFU1NJT04sXG4gICAgbWV0YTogby5tZXRhID8/IHRydWUsXG4gICAgbWVzc2FnZXM6IG8ubWVzc2FnZXMgPz8gdHJ1ZSxcbiAgICBpbmxpbmVSZWZzOiBvLmlubGluZVJlZnMgPz8gdHJ1ZSxcbiAgICBzY2hlbWFJZDogby5zY2hlbWFJZCA/PyBcIiRpZFwiLFxuICAgIGFkZFVzZWRTY2hlbWE6IG8uYWRkVXNlZFNjaGVtYSA/PyB0cnVlLFxuICAgIHZhbGlkYXRlU2NoZW1hOiBvLnZhbGlkYXRlU2NoZW1hID8/IHRydWUsXG4gICAgdmFsaWRhdGVGb3JtYXRzOiBvLnZhbGlkYXRlRm9ybWF0cyA/PyB0cnVlLFxuICAgIHVuaWNvZGVSZWdFeHA6IG8udW5pY29kZVJlZ0V4cCA/PyB0cnVlLFxuICAgIGludDMycmFuZ2U6IG8uaW50MzJyYW5nZSA/PyB0cnVlLFxuICAgIHVyaVJlc29sdmVyOiB1cmlSZXNvbHZlcixcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIExvZ2dlciB7XG4gIGxvZyguLi5hcmdzOiB1bmtub3duW10pOiB1bmtub3duXG4gIHdhcm4oLi4uYXJnczogdW5rbm93bltdKTogdW5rbm93blxuICBlcnJvciguLi5hcmdzOiB1bmtub3duW10pOiB1bmtub3duXG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFqdiB7XG4gIG9wdHM6IEluc3RhbmNlT3B0aW9uc1xuICBlcnJvcnM/OiBFcnJvck9iamVjdFtdIHwgbnVsbCAvLyBlcnJvcnMgZnJvbSB0aGUgbGFzdCB2YWxpZGF0aW9uXG4gIGxvZ2dlcjogTG9nZ2VyXG4gIC8vIHNoYXJlZCBleHRlcm5hbCBzY29wZSB2YWx1ZXMgZm9yIGNvbXBpbGVkIGZ1bmN0aW9uc1xuICByZWFkb25seSBzY29wZTogVmFsdWVTY29wZVxuICByZWFkb25seSBzY2hlbWFzOiB7W0tleSBpbiBzdHJpbmddPzogU2NoZW1hRW52fSA9IHt9XG4gIHJlYWRvbmx5IHJlZnM6IHtbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBzdHJpbmd9ID0ge31cbiAgcmVhZG9ubHkgZm9ybWF0czoge1tOYW1lIGluIHN0cmluZ10/OiBBZGRlZEZvcm1hdH0gPSB7fVxuICByZWFkb25seSBSVUxFUzogVmFsaWRhdGlvblJ1bGVzXG4gIHJlYWRvbmx5IF9jb21waWxhdGlvbnM6IFNldDxTY2hlbWFFbnY+ID0gbmV3IFNldCgpXG4gIHByaXZhdGUgcmVhZG9ubHkgX2xvYWRpbmc6IHtbUmVmIGluIHN0cmluZ10/OiBQcm9taXNlPEFueVNjaGVtYU9iamVjdD59ID0ge31cbiAgcHJpdmF0ZSByZWFkb25seSBfY2FjaGU6IE1hcDxBbnlTY2hlbWEsIFNjaGVtYUVudj4gPSBuZXcgTWFwKClcbiAgcHJpdmF0ZSByZWFkb25seSBfbWV0YU9wdHM6IEluc3RhbmNlT3B0aW9uc1xuXG4gIHN0YXRpYyBWYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3JcbiAgc3RhdGljIE1pc3NpbmdSZWZFcnJvciA9IE1pc3NpbmdSZWZFcnJvclxuXG4gIGNvbnN0cnVjdG9yKG9wdHM6IE9wdGlvbnMgPSB7fSkge1xuICAgIG9wdHMgPSB0aGlzLm9wdHMgPSB7Li4ub3B0cywgLi4ucmVxdWlyZWRPcHRpb25zKG9wdHMpfVxuICAgIGNvbnN0IHtlczUsIGxpbmVzfSA9IHRoaXMub3B0cy5jb2RlXG5cbiAgICB0aGlzLnNjb3BlID0gbmV3IFZhbHVlU2NvcGUoe3Njb3BlOiB7fSwgcHJlZml4ZXM6IEVYVF9TQ09QRV9OQU1FUywgZXM1LCBsaW5lc30pXG4gICAgdGhpcy5sb2dnZXIgPSBnZXRMb2dnZXIob3B0cy5sb2dnZXIpXG4gICAgY29uc3QgZm9ybWF0T3B0ID0gb3B0cy52YWxpZGF0ZUZvcm1hdHNcbiAgICBvcHRzLnZhbGlkYXRlRm9ybWF0cyA9IGZhbHNlXG5cbiAgICB0aGlzLlJVTEVTID0gZ2V0UnVsZXMoKVxuICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIHJlbW92ZWRPcHRpb25zLCBvcHRzLCBcIk5PVCBTVVBQT1JURURcIilcbiAgICBjaGVja09wdGlvbnMuY2FsbCh0aGlzLCBkZXByZWNhdGVkT3B0aW9ucywgb3B0cywgXCJERVBSRUNBVEVEXCIsIFwid2FyblwiKVxuICAgIHRoaXMuX21ldGFPcHRzID0gZ2V0TWV0YVNjaGVtYU9wdGlvbnMuY2FsbCh0aGlzKVxuXG4gICAgaWYgKG9wdHMuZm9ybWF0cykgYWRkSW5pdGlhbEZvcm1hdHMuY2FsbCh0aGlzKVxuICAgIHRoaXMuX2FkZFZvY2FidWxhcmllcygpXG4gICAgdGhpcy5fYWRkRGVmYXVsdE1ldGFTY2hlbWEoKVxuICAgIGlmIChvcHRzLmtleXdvcmRzKSBhZGRJbml0aWFsS2V5d29yZHMuY2FsbCh0aGlzLCBvcHRzLmtleXdvcmRzKVxuICAgIGlmICh0eXBlb2Ygb3B0cy5tZXRhID09IFwib2JqZWN0XCIpIHRoaXMuYWRkTWV0YVNjaGVtYShvcHRzLm1ldGEpXG4gICAgYWRkSW5pdGlhbFNjaGVtYXMuY2FsbCh0aGlzKVxuICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZm9ybWF0T3B0XG4gIH1cblxuICBfYWRkVm9jYWJ1bGFyaWVzKCk6IHZvaWQge1xuICAgIHRoaXMuYWRkS2V5d29yZChcIiRhc3luY1wiKVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk6IHZvaWQge1xuICAgIGNvbnN0IHskZGF0YSwgbWV0YSwgc2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgbGV0IF9kYXRhUmVmU2NoZW1hOiBTY2hlbWFPYmplY3QgPSAkZGF0YVJlZlNjaGVtYVxuICAgIGlmIChzY2hlbWFJZCA9PT0gXCJpZFwiKSB7XG4gICAgICBfZGF0YVJlZlNjaGVtYSA9IHsuLi4kZGF0YVJlZlNjaGVtYX1cbiAgICAgIF9kYXRhUmVmU2NoZW1hLmlkID0gX2RhdGFSZWZTY2hlbWEuJGlkXG4gICAgICBkZWxldGUgX2RhdGFSZWZTY2hlbWEuJGlkXG4gICAgfVxuICAgIGlmIChtZXRhICYmICRkYXRhKSB0aGlzLmFkZE1ldGFTY2hlbWEoX2RhdGFSZWZTY2hlbWEsIF9kYXRhUmVmU2NoZW1hW3NjaGVtYUlkXSwgZmFsc2UpXG4gIH1cblxuICBkZWZhdWx0TWV0YSgpOiBzdHJpbmcgfCBBbnlTY2hlbWFPYmplY3QgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IHttZXRhLCBzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9IHR5cGVvZiBtZXRhID09IFwib2JqZWN0XCIgPyBtZXRhW3NjaGVtYUlkXSB8fCBtZXRhIDogdW5kZWZpbmVkKVxuICB9XG5cbiAgLy8gVmFsaWRhdGUgZGF0YSB1c2luZyBzY2hlbWFcbiAgLy8gQW55U2NoZW1hIHdpbGwgYmUgY29tcGlsZWQgYW5kIGNhY2hlZCB1c2luZyBzY2hlbWEgaXRzZWxmIGFzIGEga2V5IGZvciBNYXBcbiAgdmFsaWRhdGUoc2NoZW1hOiBTY2hlbWEgfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBib29sZWFuXG4gIHZhbGlkYXRlKHNjaGVtYUtleVJlZjogQW55U2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogYm9vbGVhbiB8IFByb21pc2U8dW5rbm93bj5cbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBTY2hlbWEgfCBKU09OU2NoZW1hVHlwZTxUPiB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVFxuICAvLyBTZXBhcmF0ZWQgZm9yIHR5cGUgaW5mZXJlbmNlIHRvIHdvcmtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBKVERTY2hlbWFUeXBlPFQ+LCBkYXRhOiB1bmtub3duKTogZGF0YSBpcyBUXG4gIC8vIFRoaXMgb3ZlcmxvYWQgaXMgb25seSBpbnRlbmRlZCBmb3IgdHlwZXNjcmlwdCBpbmZlcmVuY2UsIHRoZSBmaXJzdFxuICAvLyBhcmd1bWVudCBwcmV2ZW50cyBtYW51YWwgdHlwZSBhbm5vdGF0aW9uIGZyb20gbWF0Y2hpbmcgdGhpcyBvdmVybG9hZFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIHZhbGlkYXRlPE4gZXh0ZW5kcyBuZXZlciwgVCBleHRlbmRzIFNvbWVKVERTY2hlbWFUeXBlPihcbiAgICBzY2hlbWE6IFQsXG4gICAgZGF0YTogdW5rbm93blxuICApOiBkYXRhIGlzIEpURERhdGFUeXBlPFQ+XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gIHZhbGlkYXRlPFQ+KHNjaGVtYTogQXN5bmNTY2hlbWEsIGRhdGE6IHVua25vd24gfCBUKTogUHJvbWlzZTxUPlxuICB2YWxpZGF0ZTxUPihzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGRhdGEgaXMgVCB8IFByb21pc2U8VD5cbiAgdmFsaWRhdGU8VD4oXG4gICAgc2NoZW1hS2V5UmVmOiBBbnlTY2hlbWEgfCBzdHJpbmcsIC8vIGtleSwgcmVmIG9yIHNjaGVtYSBvYmplY3RcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlZHVuZGFudC10eXBlLWNvbnN0aXR1ZW50c1xuICAgIGRhdGE6IHVua25vd24gfCBUIC8vIHRvIGJlIHZhbGlkYXRlZFxuICApOiBib29sZWFuIHwgUHJvbWlzZTxUPiB7XG4gICAgbGV0IHY6IEFueVZhbGlkYXRlRnVuY3Rpb24gfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIHNjaGVtYUtleVJlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB2ID0gdGhpcy5nZXRTY2hlbWE8VD4oc2NoZW1hS2V5UmVmKVxuICAgICAgaWYgKCF2KSB0aHJvdyBuZXcgRXJyb3IoYG5vIHNjaGVtYSB3aXRoIGtleSBvciByZWYgXCIke3NjaGVtYUtleVJlZn1cImApXG4gICAgfSBlbHNlIHtcbiAgICAgIHYgPSB0aGlzLmNvbXBpbGU8VD4oc2NoZW1hS2V5UmVmKVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gdihkYXRhKVxuICAgIGlmICghKFwiJGFzeW5jXCIgaW4gdikpIHRoaXMuZXJyb3JzID0gdi5lcnJvcnNcbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIC8vIENyZWF0ZSB2YWxpZGF0aW9uIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hXG4gIC8vIF9tZXRhOiB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHkgdG8gY29tcGlsZSBtZXRhIHNjaGVtYXMgb2YgdXNlci1kZWZpbmVkIGtleXdvcmRzLlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IFNjaGVtYSB8IEpTT05TY2hlbWFUeXBlPFQ+LCBfbWV0YT86IGJvb2xlYW4pOiBWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFZhbGlkYXRlRnVuY3Rpb248VD5cbiAgLy8gVGhpcyBvdmVybG9hZCBpcyBvbmx5IGludGVuZGVkIGZvciB0eXBlc2NyaXB0IGluZmVyZW5jZSwgdGhlIGZpcnN0XG4gIC8vIGFyZ3VtZW50IHByZXZlbnRzIG1hbnVhbCB0eXBlIGFubm90YXRpb24gZnJvbSBtYXRjaGluZyB0aGlzIG92ZXJsb2FkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29tcGlsZTxOIGV4dGVuZHMgbmV2ZXIsIFQgZXh0ZW5kcyBTb21lSlREU2NoZW1hVHlwZT4oXG4gICAgc2NoZW1hOiBULFxuICAgIF9tZXRhPzogYm9vbGVhblxuICApOiBWYWxpZGF0ZUZ1bmN0aW9uPEpURERhdGFUeXBlPFQ+PlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEFzeW5jU2NoZW1hLCBfbWV0YT86IGJvb2xlYW4pOiBBc3luY1ZhbGlkYXRlRnVuY3Rpb248VD5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBbnlTY2hlbWEsIF9tZXRhPzogYm9vbGVhbik6IEFueVZhbGlkYXRlRnVuY3Rpb248VD5cbiAgY29tcGlsZTxUID0gdW5rbm93bj4oc2NoZW1hOiBBbnlTY2hlbWEsIF9tZXRhPzogYm9vbGVhbik6IEFueVZhbGlkYXRlRnVuY3Rpb248VD4ge1xuICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhKVxuICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSkgYXMgQW55VmFsaWRhdGVGdW5jdGlvbjxUPlxuICB9XG5cbiAgLy8gQ3JlYXRlcyB2YWxpZGF0aW5nIGZ1bmN0aW9uIGZvciBwYXNzZWQgc2NoZW1hIHdpdGggYXN5bmNocm9ub3VzIGxvYWRpbmcgb2YgbWlzc2luZyBzY2hlbWFzLlxuICAvLyBgbG9hZFNjaGVtYWAgb3B0aW9uIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBzY2hlbWEgdXJpIGFuZCByZXR1cm5zIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aXRoIHRoZSBzY2hlbWEuXG4gIC8vIFRPRE8gYWxsb3cgcGFzc2luZyBzY2hlbWEgVVJJXG4gIC8vIG1ldGEgLSBvcHRpb25hbCB0cnVlIHRvIGNvbXBpbGUgbWV0YS1zY2hlbWFcbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihcbiAgICBzY2hlbWE6IFNjaGVtYU9iamVjdCB8IEpTT05TY2hlbWFUeXBlPFQ+LFxuICAgIF9tZXRhPzogYm9vbGVhblxuICApOiBQcm9taXNlPFZhbGlkYXRlRnVuY3Rpb248VD4+XG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KHNjaGVtYTogSlREU2NoZW1hVHlwZTxUPiwgX21ldGE/OiBib29sZWFuKTogUHJvbWlzZTxWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KHNjaGVtYTogQXN5bmNTY2hlbWEsIG1ldGE/OiBib29sZWFuKTogUHJvbWlzZTxBc3luY1ZhbGlkYXRlRnVuY3Rpb248VD4+XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oXG4gICAgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAgbWV0YT86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+PlxuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIG1ldGE/OiBib29sZWFuXG4gICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbjxUPj4ge1xuICAgIGlmICh0eXBlb2YgdGhpcy5vcHRzLmxvYWRTY2hlbWEgIT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJvcHRpb25zLmxvYWRTY2hlbWEgc2hvdWxkIGJlIGEgZnVuY3Rpb25cIilcbiAgICB9XG4gICAgY29uc3Qge2xvYWRTY2hlbWF9ID0gdGhpcy5vcHRzXG4gICAgcmV0dXJuIHJ1bkNvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaGVtYSwgbWV0YSlcblxuICAgIGFzeW5jIGZ1bmN0aW9uIHJ1bkNvbXBpbGVBc3luYyhcbiAgICAgIHRoaXM6IEFqdixcbiAgICAgIF9zY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICAgIF9tZXRhPzogYm9vbGVhblxuICAgICk6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbj4ge1xuICAgICAgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpXG4gICAgICBjb25zdCBzY2ggPSB0aGlzLl9hZGRTY2hlbWEoX3NjaGVtYSwgX21ldGEpXG4gICAgICByZXR1cm4gc2NoLnZhbGlkYXRlIHx8IF9jb21waWxlQXN5bmMuY2FsbCh0aGlzLCBzY2gpXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1ldGFTY2hlbWEodGhpczogQWp2LCAkcmVmPzogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBpZiAoJHJlZiAmJiAhdGhpcy5nZXRTY2hlbWEoJHJlZikpIHtcbiAgICAgICAgYXdhaXQgcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgeyRyZWZ9LCB0cnVlKVxuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uIF9jb21waWxlQXN5bmModGhpczogQWp2LCBzY2g6IFNjaGVtYUVudik6IFByb21pc2U8QW55VmFsaWRhdGVGdW5jdGlvbj4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgTWlzc2luZ1JlZkVycm9yKSkgdGhyb3cgZVxuICAgICAgICBjaGVja0xvYWRlZC5jYWxsKHRoaXMsIGUpXG4gICAgICAgIGF3YWl0IGxvYWRNaXNzaW5nU2NoZW1hLmNhbGwodGhpcywgZS5taXNzaW5nU2NoZW1hKVxuICAgICAgICByZXR1cm4gX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0xvYWRlZCh0aGlzOiBBanYsIHttaXNzaW5nU2NoZW1hOiByZWYsIG1pc3NpbmdSZWZ9OiBNaXNzaW5nUmVmRXJyb3IpOiB2b2lkIHtcbiAgICAgIGlmICh0aGlzLnJlZnNbcmVmXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFueVNjaGVtYSAke3JlZn0gaXMgbG9hZGVkIGJ1dCAke21pc3NpbmdSZWZ9IGNhbm5vdCBiZSByZXNvbHZlZGApXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gbG9hZE1pc3NpbmdTY2hlbWEodGhpczogQWp2LCByZWY6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgX3NjaGVtYSA9IGF3YWl0IF9sb2FkU2NoZW1hLmNhbGwodGhpcywgcmVmKVxuICAgICAgaWYgKCF0aGlzLnJlZnNbcmVmXSkgYXdhaXQgbG9hZE1ldGFTY2hlbWEuY2FsbCh0aGlzLCBfc2NoZW1hLiRzY2hlbWEpXG4gICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKSB0aGlzLmFkZFNjaGVtYShfc2NoZW1hLCByZWYsIG1ldGEpXG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2xvYWRTY2hlbWEodGhpczogQWp2LCByZWY6IHN0cmluZyk6IFByb21pc2U8QW55U2NoZW1hT2JqZWN0PiB7XG4gICAgICBjb25zdCBwID0gdGhpcy5fbG9hZGluZ1tyZWZdXG4gICAgICBpZiAocCkgcmV0dXJuIHBcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhd2FpdCAodGhpcy5fbG9hZGluZ1tyZWZdID0gbG9hZFNjaGVtYShyZWYpKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xvYWRpbmdbcmVmXVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIEFkZHMgc2NoZW1hIHRvIHRoZSBpbnN0YW5jZVxuICBhZGRTY2hlbWEoXG4gICAgc2NoZW1hOiBBbnlTY2hlbWEgfCBBbnlTY2hlbWFbXSwgLy8gSWYgYXJyYXkgaXMgcGFzc2VkLCBga2V5YCB3aWxsIGJlIGlnbm9yZWRcbiAgICBrZXk/OiBzdHJpbmcsIC8vIE9wdGlvbmFsIHNjaGVtYSBrZXkuIENhbiBiZSBwYXNzZWQgdG8gYHZhbGlkYXRlYCBtZXRob2QgaW5zdGVhZCBvZiBzY2hlbWEgb2JqZWN0IG9yIGlkL3JlZi4gT25lIHNjaGVtYSBwZXIgaW5zdGFuY2UgY2FuIGhhdmUgZW1wdHkgYGlkYCBhbmQgYGtleWAuXG4gICAgX21ldGE/OiBib29sZWFuLCAvLyB0cnVlIGlmIHNjaGVtYSBpcyBhIG1ldGEtc2NoZW1hLiBVc2VkIGludGVybmFsbHksIGFkZE1ldGFTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgICBfdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgLy8gZmFsc2UgdG8gc2tpcCBzY2hlbWEgdmFsaWRhdGlvbi4gVXNlZCBpbnRlcm5hbGx5LCBvcHRpb24gdmFsaWRhdGVTY2hlbWEgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cbiAgKTogQWp2IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgICBmb3IgKGNvbnN0IHNjaCBvZiBzY2hlbWEpIHRoaXMuYWRkU2NoZW1hKHNjaCwgdW5kZWZpbmVkLCBfbWV0YSwgX3ZhbGlkYXRlU2NoZW1hKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgbGV0IGlkOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgICAgaWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgaWQgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHNjaGVtYSAke3NjaGVtYUlkfSBtdXN0IGJlIHN0cmluZ2ApXG4gICAgICB9XG4gICAgfVxuICAgIGtleSA9IG5vcm1hbGl6ZUlkKGtleSB8fCBpZClcbiAgICB0aGlzLl9jaGVja1VuaXF1ZShrZXkpXG4gICAgdGhpcy5zY2hlbWFzW2tleV0gPSB0aGlzLl9hZGRTY2hlbWEoc2NoZW1hLCBfbWV0YSwga2V5LCBfdmFsaWRhdGVTY2hlbWEsIHRydWUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIEFkZCBzY2hlbWEgdGhhdCB3aWxsIGJlIHVzZWQgdG8gdmFsaWRhdGUgb3RoZXIgc2NoZW1hc1xuICAvLyBvcHRpb25zIGluIE1FVEFfSUdOT1JFX09QVElPTlMgYXJlIGFsd2F5IHNldCB0byBmYWxzZVxuICBhZGRNZXRhU2NoZW1hKFxuICAgIHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgIGtleT86IHN0cmluZywgLy8gc2NoZW1hIGtleVxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLCBjYW4gYmUgdXNlZCB0byBvdmVycmlkZSB2YWxpZGF0ZVNjaGVtYSBvcHRpb24gZm9yIG1ldGEtc2NoZW1hXG4gICk6IEFqdiB7XG4gICAgdGhpcy5hZGRTY2hlbWEoc2NoZW1hLCBrZXksIHRydWUsIF92YWxpZGF0ZVNjaGVtYSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gIFZhbGlkYXRlIHNjaGVtYSBhZ2FpbnN0IGl0cyBtZXRhLXNjaGVtYVxuICB2YWxpZGF0ZVNjaGVtYShzY2hlbWE6IEFueVNjaGVtYSwgdGhyb3dPckxvZ0Vycm9yPzogYm9vbGVhbik6IGJvb2xlYW4gfCBQcm9taXNlPHVua25vd24+IHtcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcImJvb2xlYW5cIikgcmV0dXJuIHRydWVcbiAgICBsZXQgJHNjaGVtYTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hXG4gICAgaWYgKCRzY2hlbWEgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgJHNjaGVtYSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCIkc2NoZW1hIG11c3QgYmUgYSBzdHJpbmdcIilcbiAgICB9XG4gICAgJHNjaGVtYSA9ICRzY2hlbWEgfHwgdGhpcy5vcHRzLmRlZmF1bHRNZXRhIHx8IHRoaXMuZGVmYXVsdE1ldGEoKVxuICAgIGlmICghJHNjaGVtYSkge1xuICAgICAgdGhpcy5sb2dnZXIud2FybihcIm1ldGEtc2NoZW1hIG5vdCBhdmFpbGFibGVcIilcbiAgICAgIHRoaXMuZXJyb3JzID0gbnVsbFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY29uc3QgdmFsaWQgPSB0aGlzLnZhbGlkYXRlKCRzY2hlbWEsIHNjaGVtYSlcbiAgICBpZiAoIXZhbGlkICYmIHRocm93T3JMb2dFcnJvcikge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IFwic2NoZW1hIGlzIGludmFsaWQ6IFwiICsgdGhpcy5lcnJvcnNUZXh0KClcbiAgICAgIGlmICh0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEgPT09IFwibG9nXCIpIHRoaXMubG9nZ2VyLmVycm9yKG1lc3NhZ2UpXG4gICAgICBlbHNlIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKVxuICAgIH1cbiAgICByZXR1cm4gdmFsaWRcbiAgfVxuXG4gIC8vIEdldCBjb21waWxlZCBzY2hlbWEgYnkgYGtleWAgb3IgYHJlZmAuXG4gIC8vIChga2V5YCB0aGF0IHdhcyBwYXNzZWQgdG8gYGFkZFNjaGVtYWAgb3IgZnVsbCBzY2hlbWEgcmVmZXJlbmNlIC0gYHNjaGVtYS4kaWRgIG9yIHJlc29sdmVkIGlkKVxuICBnZXRTY2hlbWE8VCA9IHVua25vd24+KGtleVJlZjogc3RyaW5nKTogQW55VmFsaWRhdGVGdW5jdGlvbjxUPiB8IHVuZGVmaW5lZCB7XG4gICAgbGV0IHNjaFxuICAgIHdoaWxlICh0eXBlb2YgKHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIGtleVJlZikpID09IFwic3RyaW5nXCIpIGtleVJlZiA9IHNjaFxuICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgICAgY29uc3Qgcm9vdCA9IG5ldyBTY2hlbWFFbnYoe3NjaGVtYToge30sIHNjaGVtYUlkfSlcbiAgICAgIHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBrZXlSZWYpXG4gICAgICBpZiAoIXNjaCkgcmV0dXJuXG4gICAgICB0aGlzLnJlZnNba2V5UmVmXSA9IHNjaFxuICAgIH1cbiAgICByZXR1cm4gKHNjaC52YWxpZGF0ZSB8fCB0aGlzLl9jb21waWxlU2NoZW1hRW52KHNjaCkpIGFzIEFueVZhbGlkYXRlRnVuY3Rpb248VD4gfCB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIFJlbW92ZSBjYWNoZWQgc2NoZW1hKHMpLlxuICAvLyBJZiBubyBwYXJhbWV0ZXIgaXMgcGFzc2VkIGFsbCBzY2hlbWFzIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gIC8vIElmIFJlZ0V4cCBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgd2l0aCBrZXkvaWQgbWF0Y2hpbmcgcGF0dGVybiBidXQgbWV0YS1zY2hlbWFzIGFyZSByZW1vdmVkLlxuICAvLyBFdmVuIGlmIHNjaGVtYSBpcyByZWZlcmVuY2VkIGJ5IG90aGVyIHNjaGVtYXMgaXQgc3RpbGwgY2FuIGJlIHJlbW92ZWQgYXMgb3RoZXIgc2NoZW1hcyBoYXZlIGxvY2FsIHJlZmVyZW5jZXMuXG4gIHJlbW92ZVNjaGVtYShzY2hlbWFLZXlSZWY/OiBBbnlTY2hlbWEgfCBzdHJpbmcgfCBSZWdFeHApOiBBanYge1xuICAgIGlmIChzY2hlbWFLZXlSZWYgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzLCBzY2hlbWFLZXlSZWYpXG4gICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcywgc2NoZW1hS2V5UmVmKVxuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2Ygc2NoZW1hS2V5UmVmKSB7XG4gICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5zY2hlbWFzKVxuICAgICAgICB0aGlzLl9yZW1vdmVBbGxTY2hlbWFzKHRoaXMucmVmcylcbiAgICAgICAgdGhpcy5fY2FjaGUuY2xlYXIoKVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgIGNvbnN0IHNjaCA9IGdldFNjaEVudi5jYWxsKHRoaXMsIHNjaGVtYUtleVJlZilcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJvYmplY3RcIikgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpXG4gICAgICAgIGRlbGV0ZSB0aGlzLnNjaGVtYXNbc2NoZW1hS2V5UmVmXVxuICAgICAgICBkZWxldGUgdGhpcy5yZWZzW3NjaGVtYUtleVJlZl1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHNjaGVtYUtleVJlZlxuICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoY2FjaGVLZXkpXG4gICAgICAgIGxldCBpZCA9IHNjaGVtYUtleVJlZlt0aGlzLm9wdHMuc2NoZW1hSWRdXG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gICAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tpZF1cbiAgICAgICAgICBkZWxldGUgdGhpcy5yZWZzW2lkXVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhanYucmVtb3ZlU2NoZW1hOiBpbnZhbGlkIHBhcmFtZXRlclwiKVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBcInZvY2FidWxhcnlcIiAtIGEgY29sbGVjdGlvbiBvZiBrZXl3b3Jkc1xuICBhZGRWb2NhYnVsYXJ5KGRlZmluaXRpb25zOiBWb2NhYnVsYXJ5KTogQWp2IHtcbiAgICBmb3IgKGNvbnN0IGRlZiBvZiBkZWZpbml0aW9ucykgdGhpcy5hZGRLZXl3b3JkKGRlZilcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgYWRkS2V5d29yZChcbiAgICBrd2RPckRlZjogc3RyaW5nIHwgS2V5d29yZERlZmluaXRpb24sXG4gICAgZGVmPzogS2V5d29yZERlZmluaXRpb24gLy8gZGVwcmVjYXRlZFxuICApOiBBanYge1xuICAgIGxldCBrZXl3b3JkOiBzdHJpbmcgfCBzdHJpbmdbXVxuICAgIGlmICh0eXBlb2Yga3dkT3JEZWYgPT0gXCJzdHJpbmdcIikge1xuICAgICAga2V5d29yZCA9IGt3ZE9yRGVmXG4gICAgICBpZiAodHlwZW9mIGRlZiA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyLndhcm4oXCJ0aGVzZSBwYXJhbWV0ZXJzIGFyZSBkZXByZWNhdGVkLCBzZWUgZG9jcyBmb3IgYWRkS2V5d29yZFwiKVxuICAgICAgICBkZWYua2V5d29yZCA9IGtleXdvcmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcIm9iamVjdFwiICYmIGRlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZWYgPSBrd2RPckRlZlxuICAgICAga2V5d29yZCA9IGRlZi5rZXl3b3JkXG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShrZXl3b3JkKSAmJiAha2V5d29yZC5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkS2V5d29yZHM6IGtleXdvcmQgbXVzdCBiZSBzdHJpbmcgb3Igbm9uLWVtcHR5IGFycmF5XCIpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWRkS2V5d29yZHMgcGFyYW1ldGVyc1wiKVxuICAgIH1cblxuICAgIGNoZWNrS2V5d29yZC5jYWxsKHRoaXMsIGtleXdvcmQsIGRlZilcbiAgICBpZiAoIWRlZikge1xuICAgICAgZWFjaEl0ZW0oa2V5d29yZCwgKGt3ZCkgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGt3ZCkpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBrZXl3b3JkTWV0YXNjaGVtYS5jYWxsKHRoaXMsIGRlZilcbiAgICBjb25zdCBkZWZpbml0aW9uOiBBZGRlZEtleXdvcmREZWZpbml0aW9uID0ge1xuICAgICAgLi4uZGVmLFxuICAgICAgdHlwZTogZ2V0SlNPTlR5cGVzKGRlZi50eXBlKSxcbiAgICAgIHNjaGVtYVR5cGU6IGdldEpTT05UeXBlcyhkZWYuc2NoZW1hVHlwZSksXG4gICAgfVxuICAgIGVhY2hJdGVtKFxuICAgICAga2V5d29yZCxcbiAgICAgIGRlZmluaXRpb24udHlwZS5sZW5ndGggPT09IDBcbiAgICAgICAgPyAoaykgPT4gYWRkUnVsZS5jYWxsKHRoaXMsIGssIGRlZmluaXRpb24pXG4gICAgICAgIDogKGspID0+IGRlZmluaXRpb24udHlwZS5mb3JFYWNoKCh0KSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbiwgdCkpXG4gICAgKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXRLZXl3b3JkKGtleXdvcmQ6IHN0cmluZyk6IEFkZGVkS2V5d29yZERlZmluaXRpb24gfCBib29sZWFuIHtcbiAgICBjb25zdCBydWxlID0gdGhpcy5SVUxFUy5hbGxba2V5d29yZF1cbiAgICByZXR1cm4gdHlwZW9mIHJ1bGUgPT0gXCJvYmplY3RcIiA/IHJ1bGUuZGVmaW5pdGlvbiA6ICEhcnVsZVxuICB9XG5cbiAgLy8gUmVtb3ZlIGtleXdvcmRcbiAgcmVtb3ZlS2V5d29yZChrZXl3b3JkOiBzdHJpbmcpOiBBanYge1xuICAgIC8vIFRPRE8gcmV0dXJuIHR5cGUgc2hvdWxkIGJlIEFqdlxuICAgIGNvbnN0IHtSVUxFU30gPSB0aGlzXG4gICAgZGVsZXRlIFJVTEVTLmtleXdvcmRzW2tleXdvcmRdXG4gICAgZGVsZXRlIFJVTEVTLmFsbFtrZXl3b3JkXVxuICAgIGZvciAoY29uc3QgZ3JvdXAgb2YgUlVMRVMucnVsZXMpIHtcbiAgICAgIGNvbnN0IGkgPSBncm91cC5ydWxlcy5maW5kSW5kZXgoKHJ1bGUpID0+IHJ1bGUua2V5d29yZCA9PT0ga2V5d29yZClcbiAgICAgIGlmIChpID49IDApIGdyb3VwLnJ1bGVzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQWRkIGZvcm1hdFxuICBhZGRGb3JtYXQobmFtZTogc3RyaW5nLCBmb3JtYXQ6IEZvcm1hdCk6IEFqdiB7XG4gICAgaWYgKHR5cGVvZiBmb3JtYXQgPT0gXCJzdHJpbmdcIikgZm9ybWF0ID0gbmV3IFJlZ0V4cChmb3JtYXQpXG4gICAgdGhpcy5mb3JtYXRzW25hbWVdID0gZm9ybWF0XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGVycm9yc1RleHQoXG4gICAgZXJyb3JzOiBFcnJvck9iamVjdFtdIHwgbnVsbCB8IHVuZGVmaW5lZCA9IHRoaXMuZXJyb3JzLCAvLyBvcHRpb25hbCBhcnJheSBvZiB2YWxpZGF0aW9uIGVycm9yc1xuICAgIHtzZXBhcmF0b3IgPSBcIiwgXCIsIGRhdGFWYXIgPSBcImRhdGFcIn06IEVycm9yc1RleHRPcHRpb25zID0ge30gLy8gb3B0aW9uYWwgb3B0aW9ucyB3aXRoIHByb3BlcnRpZXMgYHNlcGFyYXRvcmAgYW5kIGBkYXRhVmFyYFxuICApOiBzdHJpbmcge1xuICAgIGlmICghZXJyb3JzIHx8IGVycm9ycy5sZW5ndGggPT09IDApIHJldHVybiBcIk5vIGVycm9yc1wiXG4gICAgcmV0dXJuIGVycm9yc1xuICAgICAgLm1hcCgoZSkgPT4gYCR7ZGF0YVZhcn0ke2UuaW5zdGFuY2VQYXRofSAke2UubWVzc2FnZX1gKVxuICAgICAgLnJlZHVjZSgodGV4dCwgbXNnKSA9PiB0ZXh0ICsgc2VwYXJhdG9yICsgbXNnKVxuICB9XG5cbiAgJGRhdGFNZXRhU2NoZW1hKG1ldGFTY2hlbWE6IEFueVNjaGVtYU9iamVjdCwga2V5d29yZHNKc29uUG9pbnRlcnM6IHN0cmluZ1tdKTogQW55U2NoZW1hT2JqZWN0IHtcbiAgICBjb25zdCBydWxlcyA9IHRoaXMuUlVMRVMuYWxsXG4gICAgbWV0YVNjaGVtYSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobWV0YVNjaGVtYSkpXG4gICAgZm9yIChjb25zdCBqc29uUG9pbnRlciBvZiBrZXl3b3Jkc0pzb25Qb2ludGVycykge1xuICAgICAgY29uc3Qgc2VnbWVudHMgPSBqc29uUG9pbnRlci5zcGxpdChcIi9cIikuc2xpY2UoMSkgLy8gZmlyc3Qgc2VnbWVudCBpcyBhbiBlbXB0eSBzdHJpbmdcbiAgICAgIGxldCBrZXl3b3JkcyA9IG1ldGFTY2hlbWFcbiAgICAgIGZvciAoY29uc3Qgc2VnIG9mIHNlZ21lbnRzKSBrZXl3b3JkcyA9IGtleXdvcmRzW3NlZ10gYXMgQW55U2NoZW1hT2JqZWN0XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXldXG4gICAgICAgIGlmICh0eXBlb2YgcnVsZSAhPSBcIm9iamVjdFwiKSBjb250aW51ZVxuICAgICAgICBjb25zdCB7JGRhdGF9ID0gcnVsZS5kZWZpbml0aW9uXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IGtleXdvcmRzW2tleV0gYXMgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgICAgIGlmICgkZGF0YSAmJiBzY2hlbWEpIGtleXdvcmRzW2tleV0gPSBzY2hlbWFPckRhdGEoc2NoZW1hKVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtZXRhU2NoZW1hXG4gIH1cblxuICBwcml2YXRlIF9yZW1vdmVBbGxTY2hlbWFzKHNjaGVtYXM6IHtbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBzdHJpbmd9LCByZWdleD86IFJlZ0V4cCk6IHZvaWQge1xuICAgIGZvciAoY29uc3Qga2V5UmVmIGluIHNjaGVtYXMpIHtcbiAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYXNba2V5UmVmXVxuICAgICAgaWYgKCFyZWdleCB8fCByZWdleC50ZXN0KGtleVJlZikpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzY2ggPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgIGRlbGV0ZSBzY2hlbWFzW2tleVJlZl1cbiAgICAgICAgfSBlbHNlIGlmIChzY2ggJiYgIXNjaC5tZXRhKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGUuZGVsZXRlKHNjaC5zY2hlbWEpXG4gICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FkZFNjaGVtYShcbiAgICBzY2hlbWE6IEFueVNjaGVtYSxcbiAgICBtZXRhPzogYm9vbGVhbixcbiAgICBiYXNlSWQ/OiBzdHJpbmcsXG4gICAgdmFsaWRhdGVTY2hlbWEgPSB0aGlzLm9wdHMudmFsaWRhdGVTY2hlbWEsXG4gICAgYWRkU2NoZW1hID0gdGhpcy5vcHRzLmFkZFVzZWRTY2hlbWFcbiAgKTogU2NoZW1hRW52IHtcbiAgICBsZXQgaWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IHtzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMub3B0cy5qdGQpIHRocm93IG5ldyBFcnJvcihcInNjaGVtYSBtdXN0IGJlIG9iamVjdFwiKVxuICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYSAhPSBcImJvb2xlYW5cIikgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0IG9yIGJvb2xlYW5cIilcbiAgICB9XG4gICAgbGV0IHNjaCA9IHRoaXMuX2NhY2hlLmdldChzY2hlbWEpXG4gICAgaWYgKHNjaCAhPT0gdW5kZWZpbmVkKSByZXR1cm4gc2NoXG5cbiAgICBiYXNlSWQgPSBub3JtYWxpemVJZChpZCB8fCBiYXNlSWQpXG4gICAgY29uc3QgbG9jYWxSZWZzID0gZ2V0U2NoZW1hUmVmcy5jYWxsKHRoaXMsIHNjaGVtYSwgYmFzZUlkKVxuICAgIHNjaCA9IG5ldyBTY2hlbWFFbnYoe3NjaGVtYSwgc2NoZW1hSWQsIG1ldGEsIGJhc2VJZCwgbG9jYWxSZWZzfSlcbiAgICB0aGlzLl9jYWNoZS5zZXQoc2NoLnNjaGVtYSwgc2NoKVxuICAgIGlmIChhZGRTY2hlbWEgJiYgIWJhc2VJZC5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgLy8gVE9ETyBhdG0gaXQgaXMgYWxsb3dlZCB0byBvdmVyd3JpdGUgc2NoZW1hcyB3aXRob3V0IGlkIChpbnN0ZWFkIG9mIG5vdCBhZGRpbmcgdGhlbSlcbiAgICAgIGlmIChiYXNlSWQpIHRoaXMuX2NoZWNrVW5pcXVlKGJhc2VJZClcbiAgICAgIHRoaXMucmVmc1tiYXNlSWRdID0gc2NoXG4gICAgfVxuICAgIGlmICh2YWxpZGF0ZVNjaGVtYSkgdGhpcy52YWxpZGF0ZVNjaGVtYShzY2hlbWEsIHRydWUpXG4gICAgcmV0dXJuIHNjaFxuICB9XG5cbiAgcHJpdmF0ZSBfY2hlY2tVbmlxdWUoaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmICh0aGlzLnNjaGVtYXNbaWRdIHx8IHRoaXMucmVmc1tpZF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hIHdpdGgga2V5IG9yIGlkIFwiJHtpZH1cIiBhbHJlYWR5IGV4aXN0c2ApXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfY29tcGlsZVNjaGVtYUVudihzY2g6IFNjaGVtYUVudik6IEFueVZhbGlkYXRlRnVuY3Rpb24ge1xuICAgIGlmIChzY2gubWV0YSkgdGhpcy5fY29tcGlsZU1ldGFTY2hlbWEoc2NoKVxuICAgIGVsc2UgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaClcblxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghc2NoLnZhbGlkYXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICByZXR1cm4gc2NoLnZhbGlkYXRlXG4gIH1cblxuICBwcml2YXRlIF9jb21waWxlTWV0YVNjaGVtYShzY2g6IFNjaGVtYUVudik6IHZvaWQge1xuICAgIGNvbnN0IGN1cnJlbnRPcHRzID0gdGhpcy5vcHRzXG4gICAgdGhpcy5vcHRzID0gdGhpcy5fbWV0YU9wdHNcbiAgICB0cnkge1xuICAgICAgY29tcGlsZVNjaGVtYS5jYWxsKHRoaXMsIHNjaClcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdGhpcy5vcHRzID0gY3VycmVudE9wdHNcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBFcnJvcnNUZXh0T3B0aW9ucyB7XG4gIHNlcGFyYXRvcj86IHN0cmluZ1xuICBkYXRhVmFyPzogc3RyaW5nXG59XG5cbmZ1bmN0aW9uIGNoZWNrT3B0aW9ucyhcbiAgdGhpczogQWp2LFxuICBjaGVja09wdHM6IE9wdGlvbnNJbmZvPFJlbW92ZWRPcHRpb25zIHwgRGVwcmVjYXRlZE9wdGlvbnM+LFxuICBvcHRpb25zOiBPcHRpb25zICYgUmVtb3ZlZE9wdGlvbnMsXG4gIG1zZzogc3RyaW5nLFxuICBsb2c6IFwid2FyblwiIHwgXCJlcnJvclwiID0gXCJlcnJvclwiXG4pOiB2b2lkIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gY2hlY2tPcHRzKSB7XG4gICAgY29uc3Qgb3B0ID0ga2V5IGFzIGtleW9mIHR5cGVvZiBjaGVja09wdHNcbiAgICBpZiAob3B0IGluIG9wdGlvbnMpIHRoaXMubG9nZ2VyW2xvZ10oYCR7bXNnfTogb3B0aW9uICR7a2V5fS4gJHtjaGVja09wdHNbb3B0XX1gKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNjaEVudih0aGlzOiBBanYsIGtleVJlZjogc3RyaW5nKTogU2NoZW1hRW52IHwgc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAga2V5UmVmID0gbm9ybWFsaXplSWQoa2V5UmVmKSAvLyBUT0RPIHRlc3RzIGZhaWwgd2l0aG91dCB0aGlzIGxpbmVcbiAgcmV0dXJuIHRoaXMuc2NoZW1hc1trZXlSZWZdIHx8IHRoaXMucmVmc1trZXlSZWZdXG59XG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxTY2hlbWFzKHRoaXM6IEFqdik6IHZvaWQge1xuICBjb25zdCBvcHRzU2NoZW1hcyA9IHRoaXMub3B0cy5zY2hlbWFzXG4gIGlmICghb3B0c1NjaGVtYXMpIHJldHVyblxuICBpZiAoQXJyYXkuaXNBcnJheShvcHRzU2NoZW1hcykpIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzKVxuICBlbHNlIGZvciAoY29uc3Qga2V5IGluIG9wdHNTY2hlbWFzKSB0aGlzLmFkZFNjaGVtYShvcHRzU2NoZW1hc1trZXldIGFzIEFueVNjaGVtYSwga2V5KVxufVxuXG5mdW5jdGlvbiBhZGRJbml0aWFsRm9ybWF0cyh0aGlzOiBBanYpOiB2b2lkIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIHRoaXMub3B0cy5mb3JtYXRzKSB7XG4gICAgY29uc3QgZm9ybWF0ID0gdGhpcy5vcHRzLmZvcm1hdHNbbmFtZV1cbiAgICBpZiAoZm9ybWF0KSB0aGlzLmFkZEZvcm1hdChuYW1lLCBmb3JtYXQpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkSW5pdGlhbEtleXdvcmRzKFxuICB0aGlzOiBBanYsXG4gIGRlZnM6IFZvY2FidWxhcnkgfCB7W0sgaW4gc3RyaW5nXT86IEtleXdvcmREZWZpbml0aW9ufVxuKTogdm9pZCB7XG4gIGlmIChBcnJheS5pc0FycmF5KGRlZnMpKSB7XG4gICAgdGhpcy5hZGRWb2NhYnVsYXJ5KGRlZnMpXG4gICAgcmV0dXJuXG4gIH1cbiAgdGhpcy5sb2dnZXIud2FybihcImtleXdvcmRzIG9wdGlvbiBhcyBtYXAgaXMgZGVwcmVjYXRlZCwgcGFzcyBhcnJheVwiKVxuICBmb3IgKGNvbnN0IGtleXdvcmQgaW4gZGVmcykge1xuICAgIGNvbnN0IGRlZiA9IGRlZnNba2V5d29yZF0gYXMgS2V5d29yZERlZmluaXRpb25cbiAgICBpZiAoIWRlZi5rZXl3b3JkKSBkZWYua2V5d29yZCA9IGtleXdvcmRcbiAgICB0aGlzLmFkZEtleXdvcmQoZGVmKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldE1ldGFTY2hlbWFPcHRpb25zKHRoaXM6IEFqdik6IEluc3RhbmNlT3B0aW9ucyB7XG4gIGNvbnN0IG1ldGFPcHRzID0gey4uLnRoaXMub3B0c31cbiAgZm9yIChjb25zdCBvcHQgb2YgTUVUQV9JR05PUkVfT1BUSU9OUykgZGVsZXRlIG1ldGFPcHRzW29wdF1cbiAgcmV0dXJuIG1ldGFPcHRzXG59XG5cbmNvbnN0IG5vTG9ncyA9IHtsb2coKSB7fSwgd2FybigpIHt9LCBlcnJvcigpIHt9fVxuXG5mdW5jdGlvbiBnZXRMb2dnZXIobG9nZ2VyPzogUGFydGlhbDxMb2dnZXI+IHwgZmFsc2UpOiBMb2dnZXIge1xuICBpZiAobG9nZ2VyID09PSBmYWxzZSkgcmV0dXJuIG5vTG9nc1xuICBpZiAobG9nZ2VyID09PSB1bmRlZmluZWQpIHJldHVybiBjb25zb2xlXG4gIGlmIChsb2dnZXIubG9nICYmIGxvZ2dlci53YXJuICYmIGxvZ2dlci5lcnJvcikgcmV0dXJuIGxvZ2dlciBhcyBMb2dnZXJcbiAgdGhyb3cgbmV3IEVycm9yKFwibG9nZ2VyIG11c3QgaW1wbGVtZW50IGxvZywgd2FybiBhbmQgZXJyb3IgbWV0aG9kc1wiKVxufVxuXG5jb25zdCBLRVlXT1JEX05BTUUgPSAvXlthLXpfJF1bYS16MC05XyQ6LV0qJC9pXG5cbmZ1bmN0aW9uIGNoZWNrS2V5d29yZCh0aGlzOiBBanYsIGtleXdvcmQ6IHN0cmluZyB8IHN0cmluZ1tdLCBkZWY/OiBLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7UlVMRVN9ID0gdGhpc1xuICBlYWNoSXRlbShrZXl3b3JkLCAoa3dkKSA9PiB7XG4gICAgaWYgKFJVTEVTLmtleXdvcmRzW2t3ZF0pIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaXMgYWxyZWFkeSBkZWZpbmVkYClcbiAgICBpZiAoIUtFWVdPUkRfTkFNRS50ZXN0KGt3ZCkpIHRocm93IG5ldyBFcnJvcihgS2V5d29yZCAke2t3ZH0gaGFzIGludmFsaWQgbmFtZWApXG4gIH0pXG4gIGlmICghZGVmKSByZXR1cm5cbiAgaWYgKGRlZi4kZGF0YSAmJiAhKFwiY29kZVwiIGluIGRlZiB8fCBcInZhbGlkYXRlXCIgaW4gZGVmKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignJGRhdGEga2V5d29yZCBtdXN0IGhhdmUgXCJjb2RlXCIgb3IgXCJ2YWxpZGF0ZVwiIGZ1bmN0aW9uJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRSdWxlKFxuICB0aGlzOiBBanYsXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgZGVmaW5pdGlvbj86IEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIGRhdGFUeXBlPzogSlNPTlR5cGVcbik6IHZvaWQge1xuICBjb25zdCBwb3N0ID0gZGVmaW5pdGlvbj8ucG9zdFxuICBpZiAoZGF0YVR5cGUgJiYgcG9zdCkgdGhyb3cgbmV3IEVycm9yKCdrZXl3b3JkIHdpdGggXCJwb3N0XCIgZmxhZyBjYW5ub3QgaGF2ZSBcInR5cGVcIicpXG4gIGNvbnN0IHtSVUxFU30gPSB0aGlzXG4gIGxldCBydWxlR3JvdXAgPSBwb3N0ID8gUlVMRVMucG9zdCA6IFJVTEVTLnJ1bGVzLmZpbmQoKHt0eXBlOiB0fSkgPT4gdCA9PT0gZGF0YVR5cGUpXG4gIGlmICghcnVsZUdyb3VwKSB7XG4gICAgcnVsZUdyb3VwID0ge3R5cGU6IGRhdGFUeXBlLCBydWxlczogW119XG4gICAgUlVMRVMucnVsZXMucHVzaChydWxlR3JvdXApXG4gIH1cbiAgUlVMRVMua2V5d29yZHNba2V5d29yZF0gPSB0cnVlXG4gIGlmICghZGVmaW5pdGlvbikgcmV0dXJuXG5cbiAgY29uc3QgcnVsZTogUnVsZSA9IHtcbiAgICBrZXl3b3JkLFxuICAgIGRlZmluaXRpb246IHtcbiAgICAgIC4uLmRlZmluaXRpb24sXG4gICAgICB0eXBlOiBnZXRKU09OVHlwZXMoZGVmaW5pdGlvbi50eXBlKSxcbiAgICAgIHNjaGVtYVR5cGU6IGdldEpTT05UeXBlcyhkZWZpbml0aW9uLnNjaGVtYVR5cGUpLFxuICAgIH0sXG4gIH1cbiAgaWYgKGRlZmluaXRpb24uYmVmb3JlKSBhZGRCZWZvcmVSdWxlLmNhbGwodGhpcywgcnVsZUdyb3VwLCBydWxlLCBkZWZpbml0aW9uLmJlZm9yZSlcbiAgZWxzZSBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKVxuICBSVUxFUy5hbGxba2V5d29yZF0gPSBydWxlXG4gIGRlZmluaXRpb24uaW1wbGVtZW50cz8uZm9yRWFjaCgoa3dkKSA9PiB0aGlzLmFkZEtleXdvcmQoa3dkKSlcbn1cblxuZnVuY3Rpb24gYWRkQmVmb3JlUnVsZSh0aGlzOiBBanYsIHJ1bGVHcm91cDogUnVsZUdyb3VwLCBydWxlOiBSdWxlLCBiZWZvcmU6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCBpID0gcnVsZUdyb3VwLnJ1bGVzLmZpbmRJbmRleCgoX3J1bGUpID0+IF9ydWxlLmtleXdvcmQgPT09IGJlZm9yZSlcbiAgaWYgKGkgPj0gMCkge1xuICAgIHJ1bGVHcm91cC5ydWxlcy5zcGxpY2UoaSwgMCwgcnVsZSlcbiAgfSBlbHNlIHtcbiAgICBydWxlR3JvdXAucnVsZXMucHVzaChydWxlKVxuICAgIHRoaXMubG9nZ2VyLndhcm4oYHJ1bGUgJHtiZWZvcmV9IGlzIG5vdCBkZWZpbmVkYClcbiAgfVxufVxuXG5mdW5jdGlvbiBrZXl3b3JkTWV0YXNjaGVtYSh0aGlzOiBBanYsIGRlZjogS2V5d29yZERlZmluaXRpb24pOiB2b2lkIHtcbiAgbGV0IHttZXRhU2NoZW1hfSA9IGRlZlxuICBpZiAobWV0YVNjaGVtYSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgaWYgKGRlZi4kZGF0YSAmJiB0aGlzLm9wdHMuJGRhdGEpIG1ldGFTY2hlbWEgPSBzY2hlbWFPckRhdGEobWV0YVNjaGVtYSlcbiAgZGVmLnZhbGlkYXRlU2NoZW1hID0gdGhpcy5jb21waWxlKG1ldGFTY2hlbWEsIHRydWUpXG59XG5cbmNvbnN0ICRkYXRhUmVmID0ge1xuICAkcmVmOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxufVxuXG5mdW5jdGlvbiBzY2hlbWFPckRhdGEoc2NoZW1hOiBBbnlTY2hlbWEpOiBBbnlTY2hlbWFPYmplY3Qge1xuICByZXR1cm4ge2FueU9mOiBbc2NoZW1hLCAkZGF0YVJlZl19XG59XG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiaWRcIixcbiAgY29kZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05PVCBTVVBQT1JURUQ6IGtleXdvcmQgXCJpZFwiLCB1c2UgXCIkaWRcIiBmb3Igc2NoZW1hIElEJylcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCBNaXNzaW5nUmVmRXJyb3IgZnJvbSBcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCJcbmltcG9ydCB7Y2FsbFZhbGlkYXRlQ29kZX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBuaWwsIHN0cmluZ2lmeSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiXG5pbXBvcnQge1NjaGVtYUVudiwgcmVzb2x2ZVJlZn0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuaW1wb3J0IHttZXJnZUV2YWx1YXRlZH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIiRyZWZcIixcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWE6ICRyZWYsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtiYXNlSWQsIHNjaGVtYUVudjogZW52LCB2YWxpZGF0ZU5hbWUsIG9wdHMsIHNlbGZ9ID0gaXRcbiAgICBjb25zdCB7cm9vdH0gPSBlbnZcbiAgICBpZiAoKCRyZWYgPT09IFwiI1wiIHx8ICRyZWYgPT09IFwiIy9cIikgJiYgYmFzZUlkID09PSByb290LmJhc2VJZCkgcmV0dXJuIGNhbGxSb290UmVmKClcbiAgICBjb25zdCBzY2hPckVudiA9IHJlc29sdmVSZWYuY2FsbChzZWxmLCByb290LCBiYXNlSWQsICRyZWYpXG4gICAgaWYgKHNjaE9yRW52ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBNaXNzaW5nUmVmRXJyb3IoaXQub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCAkcmVmKVxuICAgIGlmIChzY2hPckVudiBpbnN0YW5jZW9mIFNjaGVtYUVudikgcmV0dXJuIGNhbGxWYWxpZGF0ZShzY2hPckVudilcbiAgICByZXR1cm4gaW5saW5lUmVmU2NoZW1hKHNjaE9yRW52KVxuXG4gICAgZnVuY3Rpb24gY2FsbFJvb3RSZWYoKTogdm9pZCB7XG4gICAgICBpZiAoZW52ID09PSByb290KSByZXR1cm4gY2FsbFJlZihjeHQsIHZhbGlkYXRlTmFtZSwgZW52LCBlbnYuJGFzeW5jKVxuICAgICAgY29uc3Qgcm9vdE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcInJvb3RcIiwge3JlZjogcm9vdH0pXG4gICAgICByZXR1cm4gY2FsbFJlZihjeHQsIF9gJHtyb290TmFtZX0udmFsaWRhdGVgLCByb290LCByb290LiRhc3luYylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxsVmFsaWRhdGUoc2NoOiBTY2hlbWFFbnYpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHYgPSBnZXRWYWxpZGF0ZShjeHQsIHNjaClcbiAgICAgIGNhbGxSZWYoY3h0LCB2LCBzY2gsIHNjaC4kYXN5bmMpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5saW5lUmVmU2NoZW1hKHNjaDogQW55U2NoZW1hKTogdm9pZCB7XG4gICAgICBjb25zdCBzY2hOYW1lID0gZ2VuLnNjb3BlVmFsdWUoXG4gICAgICAgIFwic2NoZW1hXCIsXG4gICAgICAgIG9wdHMuY29kZS5zb3VyY2UgPT09IHRydWUgPyB7cmVmOiBzY2gsIGNvZGU6IHN0cmluZ2lmeShzY2gpfSA6IHtyZWY6IHNjaH1cbiAgICAgIClcbiAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIHNjaGVtYTogc2NoLFxuICAgICAgICAgIGRhdGFUeXBlczogW10sXG4gICAgICAgICAgc2NoZW1hUGF0aDogbmlsLFxuICAgICAgICAgIHRvcFNjaGVtYVJlZjogc2NoTmFtZSxcbiAgICAgICAgICBlcnJTY2hlbWFQYXRoOiAkcmVmLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRWYWxpZGF0ZShjeHQ6IEtleXdvcmRDeHQsIHNjaDogU2NoZW1hRW52KTogQ29kZSB7XG4gIGNvbnN0IHtnZW59ID0gY3h0XG4gIHJldHVybiBzY2gudmFsaWRhdGVcbiAgICA/IGdlbi5zY29wZVZhbHVlKFwidmFsaWRhdGVcIiwge3JlZjogc2NoLnZhbGlkYXRlfSlcbiAgICA6IF9gJHtnZW4uc2NvcGVWYWx1ZShcIndyYXBwZXJcIiwge3JlZjogc2NofSl9LnZhbGlkYXRlYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbFJlZihjeHQ6IEtleXdvcmRDeHQsIHY6IENvZGUsIHNjaD86IFNjaGVtYUVudiwgJGFzeW5jPzogYm9vbGVhbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBpdH0gPSBjeHRcbiAgY29uc3Qge2FsbEVycm9ycywgc2NoZW1hRW52OiBlbnYsIG9wdHN9ID0gaXRcbiAgY29uc3QgcGFzc0N4dCA9IG9wdHMucGFzc0NvbnRleHQgPyBOLnRoaXMgOiBuaWxcbiAgaWYgKCRhc3luYykgY2FsbEFzeW5jUmVmKClcbiAgZWxzZSBjYWxsU3luY1JlZigpXG5cbiAgZnVuY3Rpb24gY2FsbEFzeW5jUmVmKCk6IHZvaWQge1xuICAgIGlmICghZW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgc2NoZW1hIHJlZmVyZW5jZWQgYnkgc3luYyBzY2hlbWFcIilcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICAgIGdlbi50cnkoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGdlbi5jb2RlKF9gYXdhaXQgJHtjYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCl9YClcbiAgICAgICAgYWRkRXZhbHVhdGVkRnJvbSh2KSAvLyBUT0RPIHdpbGwgbm90IHdvcmsgd2l0aCBhc3luYywgaXQgaGFzIHRvIGJlIHJldHVybmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICAgIH0sXG4gICAgICAoZSkgPT4ge1xuICAgICAgICBnZW4uaWYoX2AhKCR7ZX0gaW5zdGFuY2VvZiAke2l0LlZhbGlkYXRpb25FcnJvciBhcyBOYW1lfSlgLCAoKSA9PiBnZW4udGhyb3coZSkpXG4gICAgICAgIGFkZEVycm9yc0Zyb20oZSlcbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgfVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG4gIH1cblxuICBmdW5jdGlvbiBjYWxsU3luY1JlZigpOiB2b2lkIHtcbiAgICBjeHQucmVzdWx0KFxuICAgICAgY2FsbFZhbGlkYXRlQ29kZShjeHQsIHYsIHBhc3NDeHQpLFxuICAgICAgKCkgPT4gYWRkRXZhbHVhdGVkRnJvbSh2KSxcbiAgICAgICgpID0+IGFkZEVycm9yc0Zyb20odilcbiAgICApXG4gIH1cblxuICBmdW5jdGlvbiBhZGRFcnJvcnNGcm9tKHNvdXJjZTogQ29kZSk6IHZvaWQge1xuICAgIGNvbnN0IGVycnMgPSBfYCR7c291cmNlfS5lcnJvcnNgXG4gICAgZ2VuLmFzc2lnbihOLnZFcnJvcnMsIF9gJHtOLnZFcnJvcnN9ID09PSBudWxsID8gJHtlcnJzfSA6ICR7Ti52RXJyb3JzfS5jb25jYXQoJHtlcnJzfSlgKSAvLyBUT0RPIHRhZ2dlZFxuICAgIGdlbi5hc3NpZ24oTi5lcnJvcnMsIF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGApXG4gIH1cblxuICBmdW5jdGlvbiBhZGRFdmFsdWF0ZWRGcm9tKHNvdXJjZTogQ29kZSk6IHZvaWQge1xuICAgIGlmICghaXQub3B0cy51bmV2YWx1YXRlZCkgcmV0dXJuXG4gICAgY29uc3Qgc2NoRXZhbHVhdGVkID0gc2NoPy52YWxpZGF0ZT8uZXZhbHVhdGVkXG4gICAgLy8gVE9ETyByZWZhY3RvclxuICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSkge1xuICAgICAgaWYgKHNjaEV2YWx1YXRlZCAmJiAhc2NoRXZhbHVhdGVkLmR5bmFtaWNQcm9wcykge1xuICAgICAgICBpZiAoc2NoRXZhbHVhdGVkLnByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgc2NoRXZhbHVhdGVkLnByb3BzLCBpdC5wcm9wcylcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcHJvcHMgPSBnZW4udmFyKFwicHJvcHNcIiwgX2Ake3NvdXJjZX0uZXZhbHVhdGVkLnByb3BzYClcbiAgICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHByb3BzLCBpdC5wcm9wcywgTmFtZSlcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY0l0ZW1zKSB7XG4gICAgICAgIGlmIChzY2hFdmFsdWF0ZWQuaXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hFdmFsdWF0ZWQuaXRlbXMsIGl0Lml0ZW1zKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpdGVtcyA9IGdlbi52YXIoXCJpdGVtc1wiLCBfYCR7c291cmNlfS5ldmFsdWF0ZWQuaXRlbXNgKVxuICAgICAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgaXRlbXMsIGl0Lml0ZW1zLCBOYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBpZEtleXdvcmQgZnJvbSBcIi4vaWRcIlxuaW1wb3J0IHJlZktleXdvcmQgZnJvbSBcIi4vcmVmXCJcblxuY29uc3QgY29yZTogVm9jYWJ1bGFyeSA9IFtcbiAgXCIkc2NoZW1hXCIsXG4gIFwiJGlkXCIsXG4gIFwiJGRlZnNcIixcbiAgXCIkdm9jYWJ1bGFyeVwiLFxuICB7a2V5d29yZDogXCIkY29tbWVudFwifSxcbiAgXCJkZWZpbml0aW9uc1wiLFxuICBpZEtleXdvcmQsXG4gIHJlZktleXdvcmQsXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGNvcmVcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuY29uc3Qgb3BzID0gb3BlcmF0b3JzXG5cbnR5cGUgS3dkID0gXCJtYXhpbXVtXCIgfCBcIm1pbmltdW1cIiB8IFwiZXhjbHVzaXZlTWF4aW11bVwiIHwgXCJleGNsdXNpdmVNaW5pbXVtXCJcblxudHlwZSBDb21wYXJpc29uID0gXCI8PVwiIHwgXCI+PVwiIHwgXCI8XCIgfCBcIj5cIlxuXG5jb25zdCBLV0RzOiB7W0sgaW4gS3dkXToge29rU3RyOiBDb21wYXJpc29uOyBvazogQ29kZTsgZmFpbDogQ29kZX19ID0ge1xuICBtYXhpbXVtOiB7b2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVH0sXG4gIG1pbmltdW06IHtva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUfSxcbiAgZXhjbHVzaXZlTWF4aW11bToge29rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURX0sXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHtva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEV9LFxufVxuXG5leHBvcnQgdHlwZSBMaW1pdE51bWJlckVycm9yID0gRXJyb3JPYmplY3Q8XG4gIEt3ZCxcbiAge2xpbWl0OiBudW1iZXI7IGNvbXBhcmlzb246IENvbXBhcmlzb259LFxuICBudW1iZXIgfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IGJlICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICBwYXJhbXM6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+XG4gICAgX2B7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgdHlwZTogXCJudW1iZXJcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlfSA9IGN4dFxuICAgIGN4dC5mYWlsJGRhdGEoX2Ake2RhdGF9ICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0uZmFpbH0gJHtzY2hlbWFDb2RlfSB8fCBpc05hTigke2RhdGF9KWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuZXhwb3J0IHR5cGUgTXVsdGlwbGVPZkVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwibXVsdGlwbGVPZlwiLFxuICB7bXVsdGlwbGVPZjogbnVtYmVyfSxcbiAgbnVtYmVyIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBiZSBtdWx0aXBsZSBvZiAke3NjaGVtYUNvZGV9YCxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHttdWx0aXBsZU9mOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIm11bHRpcGxlT2ZcIixcbiAgdHlwZTogXCJudW1iZXJcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIC8vIGNvbnN0IGJkdCA9IGJhZCREYXRhVHlwZShzY2hlbWFDb2RlLCA8c3RyaW5nPmRlZi5zY2hlbWFUeXBlLCAkZGF0YSlcbiAgICBjb25zdCBwcmVjID0gaXQub3B0cy5tdWx0aXBsZU9mUHJlY2lzaW9uXG4gICAgY29uc3QgcmVzID0gZ2VuLmxldChcInJlc1wiKVxuICAgIGNvbnN0IGludmFsaWQgPSBwcmVjXG4gICAgICA/IF9gTWF0aC5hYnMoTWF0aC5yb3VuZCgke3Jlc30pIC0gJHtyZXN9KSA+IDFlLSR7cHJlY31gXG4gICAgICA6IF9gJHtyZXN9ICE9PSBwYXJzZUludCgke3Jlc30pYFxuICAgIGN4dC5mYWlsJGRhdGEoX2AoJHtzY2hlbWFDb2RlfSA9PT0gMCB8fCAoJHtyZXN9ID0gJHtkYXRhfS8ke3NjaGVtYUNvZGV9LCAke2ludmFsaWR9KSlgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICIvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZ1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jlc3RpZWpzL3B1bnljb2RlLmpzIC0gcHVueWNvZGUudWNzMi5kZWNvZGVcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVjczJsZW5ndGgoc3RyOiBzdHJpbmcpOiBudW1iZXIge1xuICBjb25zdCBsZW4gPSBzdHIubGVuZ3RoXG4gIGxldCBsZW5ndGggPSAwXG4gIGxldCBwb3MgPSAwXG4gIGxldCB2YWx1ZTogbnVtYmVyXG4gIHdoaWxlIChwb3MgPCBsZW4pIHtcbiAgICBsZW5ndGgrK1xuICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKyspXG4gICAgaWYgKHZhbHVlID49IDB4ZDgwMCAmJiB2YWx1ZSA8PSAweGRiZmYgJiYgcG9zIDwgbGVuKSB7XG4gICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgIHZhbHVlID0gc3RyLmNoYXJDb2RlQXQocG9zKVxuICAgICAgaWYgKCh2YWx1ZSAmIDB4ZmMwMCkgPT09IDB4ZGMwMCkgcG9zKysgLy8gbG93IHN1cnJvZ2F0ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuZ3RoXG59XG5cbnVjczJsZW5ndGguY29kZSA9ICdyZXF1aXJlKFwiYWp2L2Rpc3QvcnVudGltZS91Y3MybGVuZ3RoXCIpLmRlZmF1bHQnXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgdWNzMmxlbmd0aCBmcm9tIFwiLi4vLi4vcnVudGltZS91Y3MybGVuZ3RoXCJcblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2Uoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSB7XG4gICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIlxuICAgIHJldHVybiBzdHJgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBjaGFyYWN0ZXJzYFxuICB9LFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJtYXhMZW5ndGhcIiwgXCJtaW5MZW5ndGhcIl0sXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heExlbmd0aFwiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY29uc3QgbGVuID1cbiAgICAgIGl0Lm9wdHMudW5pY29kZSA9PT0gZmFsc2UgPyBfYCR7ZGF0YX0ubGVuZ3RoYCA6IF9gJHt1c2VGdW5jKGN4dC5nZW4sIHVjczJsZW5ndGgpfSgke2RhdGF9KWBcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtsZW59ICR7b3B9ICR7c2NoZW1hQ29kZX1gKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge3VzZVBhdHRlcm59IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuZXhwb3J0IHR5cGUgUGF0dGVybkVycm9yID0gRXJyb3JPYmplY3Q8XCJwYXR0ZXJuXCIsIHtwYXR0ZXJuOiBzdHJpbmd9LCBzdHJpbmcgfCB7JGRhdGE6IHN0cmluZ30+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBtYXRjaCBwYXR0ZXJuIFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtwYXR0ZXJuOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInBhdHRlcm5cIixcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICAvLyBUT0RPIHJlZ2V4cCBzaG91bGQgYmUgd3JhcHBlZCBpbiB0cnkvY2F0Y2hzXG4gICAgY29uc3QgdSA9IGl0Lm9wdHMudW5pY29kZVJlZ0V4cCA/IFwidVwiIDogXCJcIlxuICAgIGNvbnN0IHJlZ0V4cCA9ICRkYXRhID8gX2AobmV3IFJlZ0V4cCgke3NjaGVtYUNvZGV9LCAke3V9KSlgIDogdXNlUGF0dGVybihjeHQsIHNjaGVtYSlcbiAgICBjeHQuZmFpbCRkYXRhKF9gISR7cmVnRXhwfS50ZXN0KCR7ZGF0YX0pYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2Uoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSB7XG4gICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gXCJtb3JlXCIgOiBcImZld2VyXCJcbiAgICByZXR1cm4gc3RyYG11c3QgTk9UIGhhdmUgJHtjb21wfSB0aGFuICR7c2NoZW1hQ29kZX0gcHJvcGVydGllc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4UHJvcGVydGllc1wiLCBcIm1pblByb3BlcnRpZXNcIl0sXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZX0gPSBjeHRcbiAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4UHJvcGVydGllc1wiID8gb3BlcmF0b3JzLkdUIDogb3BlcmF0b3JzLkxUXG4gICAgY3h0LmZhaWwkZGF0YShfYE9iamVjdC5rZXlzKCR7ZGF0YX0pLmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtcbiAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcCxcbiAgY2hlY2tNaXNzaW5nUHJvcCxcbiAgcmVwb3J0TWlzc2luZ1Byb3AsXG4gIHByb3BlcnR5SW5EYXRhLFxuICBub1Byb3BlcnR5SW5EYXRhLFxufSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIHN0ciwgbmlsLCBub3QsIE5hbWUsIENvZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHtjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBSZXF1aXJlZEVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwicmVxdWlyZWRcIixcbiAge21pc3NpbmdQcm9wZXJ0eTogc3RyaW5nfSxcbiAgc3RyaW5nW10gfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bWlzc2luZ1Byb3BlcnR5fX0pID0+IHN0cmBtdXN0IGhhdmUgcmVxdWlyZWQgcHJvcGVydHkgJyR7bWlzc2luZ1Byb3BlcnR5fSdgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bWlzc2luZ1Byb3BlcnR5fX0pID0+IF9ge21pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInJlcXVpcmVkXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgc2NoZW1hQ29kZSwgZGF0YSwgJGRhdGEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvcHRzfSA9IGl0XG4gICAgaWYgKCEkZGF0YSAmJiBzY2hlbWEubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgICBjb25zdCB1c2VMb29wID0gc2NoZW1hLmxlbmd0aCA+PSBvcHRzLmxvb3BSZXF1aXJlZFxuICAgIGlmIChpdC5hbGxFcnJvcnMpIGFsbEVycm9yc01vZGUoKVxuICAgIGVsc2UgZXhpdE9uRXJyb3JNb2RlKClcblxuICAgIGlmIChvcHRzLnN0cmljdFJlcXVpcmVkKSB7XG4gICAgICBjb25zdCBwcm9wcyA9IGN4dC5wYXJlbnRTY2hlbWEucHJvcGVydGllc1xuICAgICAgY29uc3Qge2RlZmluZWRQcm9wZXJ0aWVzfSA9IGN4dC5pdFxuICAgICAgZm9yIChjb25zdCByZXF1aXJlZEtleSBvZiBzY2hlbWEpIHtcbiAgICAgICAgaWYgKHByb3BzPy5bcmVxdWlyZWRLZXldID09PSB1bmRlZmluZWQgJiYgIWRlZmluZWRQcm9wZXJ0aWVzLmhhcyhyZXF1aXJlZEtleSkpIHtcbiAgICAgICAgICBjb25zdCBzY2hlbWFQYXRoID0gaXQuc2NoZW1hRW52LmJhc2VJZCArIGl0LmVyclNjaGVtYVBhdGhcbiAgICAgICAgICBjb25zdCBtc2cgPSBgcmVxdWlyZWQgcHJvcGVydHkgXCIke3JlcXVpcmVkS2V5fVwiIGlzIG5vdCBkZWZpbmVkIGF0IFwiJHtzY2hlbWFQYXRofVwiIChzdHJpY3RSZXF1aXJlZClgXG4gICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBtc2csIGl0Lm9wdHMuc3RyaWN0UmVxdWlyZWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhbGxFcnJvcnNNb2RlKCk6IHZvaWQge1xuICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEobmlsLCBsb29wQWxsUmVxdWlyZWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IHByb3Agb2Ygc2NoZW1hKSB7XG4gICAgICAgICAgY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQsIHByb3ApXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleGl0T25FcnJvck1vZGUoKTogdm9pZCB7XG4gICAgICBjb25zdCBtaXNzaW5nID0gZ2VuLmxldChcIm1pc3NpbmdcIilcbiAgICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCAoKSA9PiBsb29wVW50aWxNaXNzaW5nKG1pc3NpbmcsIHZhbGlkKSlcbiAgICAgICAgY3h0Lm9rKHZhbGlkKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuLmlmKGNoZWNrTWlzc2luZ1Byb3AoY3h0LCBzY2hlbWEsIG1pc3NpbmcpKVxuICAgICAgICByZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpXG4gICAgICAgIGdlbi5lbHNlKClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wQWxsUmVxdWlyZWQoKTogdm9pZCB7XG4gICAgICBnZW4uZm9yT2YoXCJwcm9wXCIsIHNjaGVtYUNvZGUgYXMgQ29kZSwgKHByb3ApID0+IHtcbiAgICAgICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBwcm9wfSlcbiAgICAgICAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiBjeHQuZXJyb3IoKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcFVudGlsTWlzc2luZyhtaXNzaW5nOiBOYW1lLCB2YWxpZDogTmFtZSk6IHZvaWQge1xuICAgICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBtaXNzaW5nfSlcbiAgICAgIGdlbi5mb3JPZihcbiAgICAgICAgbWlzc2luZyxcbiAgICAgICAgc2NoZW1hQ29kZSBhcyBDb2RlLFxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBtaXNzaW5nLCBvcHRzLm93blByb3BlcnRpZXMpKVxuICAgICAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICAgICAgZ2VuLmJyZWFrKClcbiAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBuaWxcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG9wZXJhdG9yc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkge1xuICAgIGNvbnN0IGNvbXAgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIlxuICAgIHJldHVybiBzdHJgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBpdGVtc2BcbiAgfSxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtsaW1pdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1wibWF4SXRlbXNcIiwgXCJtaW5JdGVtc1wiXSxcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGV9ID0gY3h0XG4gICAgY29uc3Qgb3AgPSBrZXl3b3JkID09PSBcIm1heEl0ZW1zXCIgPyBvcGVyYXRvcnMuR1QgOiBvcGVyYXRvcnMuTFRcbiAgICBjeHQuZmFpbCRkYXRhKF9gJHtkYXRhfS5sZW5ndGggJHtvcH0gJHtzY2hlbWFDb2RlfWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9pc3N1ZXMvODg5XG5pbXBvcnQgKiBhcyBlcXVhbCBmcm9tIFwiZmFzdC1kZWVwLWVxdWFsXCJcblxudHlwZSBFcXVhbCA9IHR5cGVvZiBlcXVhbCAmIHtjb2RlOiBzdHJpbmd9XG47KGVxdWFsIGFzIEVxdWFsKS5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL2VxdWFsXCIpLmRlZmF1bHQnXG5cbmV4cG9ydCBkZWZhdWx0IGVxdWFsIGFzIEVxdWFsXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtjaGVja0RhdGFUeXBlcywgZ2V0U2NoZW1hVHlwZXMsIERhdGFUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiXG5pbXBvcnQge18sIHN0ciwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgVW5pcXVlSXRlbXNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcInVuaXF1ZUl0ZW1zXCIsXG4gIHtpOiBudW1iZXI7IGo6IG51bWJlcn0sXG4gIGJvb2xlYW4gfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7aSwgan19KSA9PlxuICAgIHN0cmBtdXN0IE5PVCBoYXZlIGR1cGxpY2F0ZSBpdGVtcyAoaXRlbXMgIyMgJHtqfSBhbmQgJHtpfSBhcmUgaWRlbnRpY2FsKWAsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtpLCBqfX0pID0+IF9ge2k6ICR7aX0sIGo6ICR7an19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwidW5pcXVlSXRlbXNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBcImJvb2xlYW5cIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgaWYgKCEkZGF0YSAmJiAhc2NoZW1hKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICAgIGNvbnN0IGl0ZW1UeXBlcyA9IHBhcmVudFNjaGVtYS5pdGVtcyA/IGdldFNjaGVtYVR5cGVzKHBhcmVudFNjaGVtYS5pdGVtcykgOiBbXVxuICAgIGN4dC5ibG9jayRkYXRhKHZhbGlkLCB2YWxpZGF0ZVVuaXF1ZUl0ZW1zLCBfYCR7c2NoZW1hQ29kZX0gPT09IGZhbHNlYClcbiAgICBjeHQub2sodmFsaWQpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVVuaXF1ZUl0ZW1zKCk6IHZvaWQge1xuICAgICAgY29uc3QgaSA9IGdlbi5sZXQoXCJpXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICAgICAgY29uc3QgaiA9IGdlbi5sZXQoXCJqXCIpXG4gICAgICBjeHQuc2V0UGFyYW1zKHtpLCBqfSlcbiAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICBnZW4uaWYoX2Ake2l9ID4gMWAsICgpID0+IChjYW5PcHRpbWl6ZSgpID8gbG9vcE4gOiBsb29wTjIpKGksIGopKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbk9wdGltaXplKCk6IGJvb2xlYW4ge1xuICAgICAgcmV0dXJuIGl0ZW1UeXBlcy5sZW5ndGggPiAwICYmICFpdGVtVHlwZXMuc29tZSgodCkgPT4gdCA9PT0gXCJvYmplY3RcIiB8fCB0ID09PSBcImFycmF5XCIpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9vcE4oaTogTmFtZSwgajogTmFtZSk6IHZvaWQge1xuICAgICAgY29uc3QgaXRlbSA9IGdlbi5uYW1lKFwiaXRlbVwiKVxuICAgICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXMoaXRlbVR5cGVzLCBpdGVtLCBpdC5vcHRzLnN0cmljdE51bWJlcnMsIERhdGFUeXBlLldyb25nKVxuICAgICAgY29uc3QgaW5kaWNlcyA9IGdlbi5jb25zdChcImluZGljZXNcIiwgX2B7fWApXG4gICAgICBnZW4uZm9yKF9gOyR7aX0tLTtgLCAoKSA9PiB7XG4gICAgICAgIGdlbi5sZXQoaXRlbSwgX2Ake2RhdGF9WyR7aX1dYClcbiAgICAgICAgZ2VuLmlmKHdyb25nVHlwZSwgX2Bjb250aW51ZWApXG4gICAgICAgIGlmIChpdGVtVHlwZXMubGVuZ3RoID4gMSkgZ2VuLmlmKF9gdHlwZW9mICR7aXRlbX0gPT0gXCJzdHJpbmdcImAsIF9gJHtpdGVtfSArPSBcIl9cImApXG4gICAgICAgIGdlblxuICAgICAgICAgIC5pZihfYHR5cGVvZiAke2luZGljZXN9WyR7aXRlbX1dID09IFwibnVtYmVyXCJgLCAoKSA9PiB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKGosIF9gJHtpbmRpY2VzfVske2l0ZW19XWApXG4gICAgICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKClcbiAgICAgICAgICB9KVxuICAgICAgICAgIC5jb2RlKF9gJHtpbmRpY2VzfVske2l0ZW19XSA9ICR7aX1gKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wTjIoaTogTmFtZSwgajogTmFtZSk6IHZvaWQge1xuICAgICAgY29uc3QgZXFsID0gdXNlRnVuYyhnZW4sIGVxdWFsKVxuICAgICAgY29uc3Qgb3V0ZXIgPSBnZW4ubmFtZShcIm91dGVyXCIpXG4gICAgICBnZW4ubGFiZWwob3V0ZXIpLmZvcihfYDske2l9LS07YCwgKCkgPT5cbiAgICAgICAgZ2VuLmZvcihfYCR7an0gPSAke2l9OyAke2p9LS07YCwgKCkgPT5cbiAgICAgICAgICBnZW4uaWYoX2Ake2VxbH0oJHtkYXRhfVske2l9XSwgJHtkYXRhfVske2p9XSlgLCAoKSA9PiB7XG4gICAgICAgICAgICBjeHQuZXJyb3IoKVxuICAgICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmJyZWFrKG91dGVyKVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7X30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge3VzZUZ1bmN9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGVxdWFsIGZyb20gXCIuLi8uLi9ydW50aW1lL2VxdWFsXCJcblxuZXhwb3J0IHR5cGUgQ29uc3RFcnJvciA9IEVycm9yT2JqZWN0PFwiY29uc3RcIiwge2FsbG93ZWRWYWx1ZTogYW55fT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBjb25zdGFudFwiLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2FsbG93ZWRWYWx1ZTogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJjb25zdFwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYUNvZGUsIHNjaGVtYX0gPSBjeHRcbiAgICBpZiAoJGRhdGEgfHwgKHNjaGVtYSAmJiB0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpKSB7XG4gICAgICBjeHQuZmFpbCRkYXRhKF9gISR7dXNlRnVuYyhnZW4sIGVxdWFsKX0oJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSlgKVxuICAgIH0gZWxzZSB7XG4gICAgICBjeHQuZmFpbChfYCR7c2NoZW1hfSAhPT0gJHtkYXRhfWApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIG9yLCBOYW1lLCBDb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgZXF1YWwgZnJvbSBcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIlxuXG5leHBvcnQgdHlwZSBFbnVtRXJyb3IgPSBFcnJvck9iamVjdDxcImVudW1cIiwge2FsbG93ZWRWYWx1ZXM6IGFueVtdfSwgYW55W10gfCB7JGRhdGE6IHN0cmluZ30+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgYmUgZXF1YWwgdG8gb25lIG9mIHRoZSBhbGxvd2VkIHZhbHVlc1wiLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2FsbG93ZWRWYWx1ZXM6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZW51bVwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApIHRocm93IG5ldyBFcnJvcihcImVudW0gbXVzdCBoYXZlIG5vbi1lbXB0eSBhcnJheVwiKVxuICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IGl0Lm9wdHMubG9vcEVudW1cbiAgICBsZXQgZXFsOiBOYW1lIHwgdW5kZWZpbmVkXG4gICAgY29uc3QgZ2V0RXFsID0gKCk6IE5hbWUgPT4gKGVxbCA/Pz0gdXNlRnVuYyhnZW4sIGVxdWFsKSlcblxuICAgIGxldCB2YWxpZDogQ29kZVxuICAgIGlmICh1c2VMb29wIHx8ICRkYXRhKSB7XG4gICAgICB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIGxvb3BFbnVtKVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICAgIGNvbnN0IHZTY2hlbWEgPSBnZW4uY29uc3QoXCJ2U2NoZW1hXCIsIHNjaGVtYUNvZGUpXG4gICAgICB2YWxpZCA9IG9yKC4uLnNjaGVtYS5tYXAoKF94OiB1bmtub3duLCBpOiBudW1iZXIpID0+IGVxdWFsQ29kZSh2U2NoZW1hLCBpKSkpXG4gICAgfVxuICAgIGN4dC5wYXNzKHZhbGlkKVxuXG4gICAgZnVuY3Rpb24gbG9vcEVudW0oKTogdm9pZCB7XG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgIGdlbi5mb3JPZihcInZcIiwgc2NoZW1hQ29kZSBhcyBDb2RlLCAodikgPT5cbiAgICAgICAgZ2VuLmlmKF9gJHtnZXRFcWwoKX0oJHtkYXRhfSwgJHt2fSlgLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVxdWFsQ29kZSh2U2NoZW1hOiBOYW1lLCBpOiBudW1iZXIpOiBDb2RlIHtcbiAgICAgIGNvbnN0IHNjaCA9IHNjaGVtYVtpXVxuICAgICAgcmV0dXJuIHR5cGVvZiBzY2ggPT09IFwib2JqZWN0XCIgJiYgc2NoICE9PSBudWxsXG4gICAgICAgID8gX2Ake2dldEVxbCgpfSgke2RhdGF9LCAke3ZTY2hlbWF9WyR7aX1dKWBcbiAgICAgICAgOiBfYCR7ZGF0YX0gPT09ICR7c2NofWBcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtFcnJvck9iamVjdCwgVm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBsaW1pdE51bWJlciwge0xpbWl0TnVtYmVyRXJyb3J9IGZyb20gXCIuL2xpbWl0TnVtYmVyXCJcbmltcG9ydCBtdWx0aXBsZU9mLCB7TXVsdGlwbGVPZkVycm9yfSBmcm9tIFwiLi9tdWx0aXBsZU9mXCJcbmltcG9ydCBsaW1pdExlbmd0aCBmcm9tIFwiLi9saW1pdExlbmd0aFwiXG5pbXBvcnQgcGF0dGVybiwge1BhdHRlcm5FcnJvcn0gZnJvbSBcIi4vcGF0dGVyblwiXG5pbXBvcnQgbGltaXRQcm9wZXJ0aWVzIGZyb20gXCIuL2xpbWl0UHJvcGVydGllc1wiXG5pbXBvcnQgcmVxdWlyZWQsIHtSZXF1aXJlZEVycm9yfSBmcm9tIFwiLi9yZXF1aXJlZFwiXG5pbXBvcnQgbGltaXRJdGVtcyBmcm9tIFwiLi9saW1pdEl0ZW1zXCJcbmltcG9ydCB1bmlxdWVJdGVtcywge1VuaXF1ZUl0ZW1zRXJyb3J9IGZyb20gXCIuL3VuaXF1ZUl0ZW1zXCJcbmltcG9ydCBjb25zdEtleXdvcmQsIHtDb25zdEVycm9yfSBmcm9tIFwiLi9jb25zdFwiXG5pbXBvcnQgZW51bUtleXdvcmQsIHtFbnVtRXJyb3J9IGZyb20gXCIuL2VudW1cIlxuXG5jb25zdCB2YWxpZGF0aW9uOiBWb2NhYnVsYXJ5ID0gW1xuICAvLyBudW1iZXJcbiAgbGltaXROdW1iZXIsXG4gIG11bHRpcGxlT2YsXG4gIC8vIHN0cmluZ1xuICBsaW1pdExlbmd0aCxcbiAgcGF0dGVybixcbiAgLy8gb2JqZWN0XG4gIGxpbWl0UHJvcGVydGllcyxcbiAgcmVxdWlyZWQsXG4gIC8vIGFycmF5XG4gIGxpbWl0SXRlbXMsXG4gIHVuaXF1ZUl0ZW1zLFxuICAvLyBhbnlcbiAge2tleXdvcmQ6IFwidHlwZVwiLCBzY2hlbWFUeXBlOiBbXCJzdHJpbmdcIiwgXCJhcnJheVwiXX0sXG4gIHtrZXl3b3JkOiBcIm51bGxhYmxlXCIsIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwifSxcbiAgY29uc3RLZXl3b3JkLFxuICBlbnVtS2V5d29yZCxcbl1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGlvblxuXG50eXBlIExpbWl0RXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJtYXhJdGVtc1wiIHwgXCJtaW5JdGVtc1wiIHwgXCJtaW5Qcm9wZXJ0aWVzXCIgfCBcIm1heFByb3BlcnRpZXNcIiB8IFwibWluTGVuZ3RoXCIgfCBcIm1heExlbmd0aFwiLFxuICB7bGltaXQ6IG51bWJlcn0sXG4gIG51bWJlciB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5leHBvcnQgdHlwZSBWYWxpZGF0aW9uS2V5d29yZEVycm9yID1cbiAgfCBMaW1pdEVycm9yXG4gIHwgTGltaXROdW1iZXJFcnJvclxuICB8IE11bHRpcGxlT2ZFcnJvclxuICB8IFBhdHRlcm5FcnJvclxuICB8IFJlcXVpcmVkRXJyb3JcbiAgfCBVbmlxdWVJdGVtc0Vycm9yXG4gIHwgQ29uc3RFcnJvclxuICB8IEVudW1FcnJvclxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBub3QsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgQWRkaXRpb25hbEl0ZW1zRXJyb3IgPSBFcnJvck9iamVjdDxcImFkZGl0aW9uYWxJdGVtc1wiLCB7bGltaXQ6IG51bWJlcn0sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bGVufX0pID0+IHN0cmBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bGVufX0pID0+IF9ge2xpbWl0OiAke2xlbn19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYWRkaXRpb25hbEl0ZW1zXCIgYXMgY29uc3QsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtpdGVtc30gPSBwYXJlbnRTY2hlbWFcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsICdcImFkZGl0aW9uYWxJdGVtc1wiIGlzIGlnbm9yZWQgd2hlbiBcIml0ZW1zXCIgaXMgbm90IGFuIGFycmF5IG9mIHNjaGVtYXMnKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgaXRlbXMpXG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQ6IEtleXdvcmRDeHQsIGl0ZW1zOiBBbnlTY2hlbWFbXSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBpdC5pdGVtcyA9IHRydWVcbiAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGN4dC5zZXRQYXJhbXMoe2xlbjogaXRlbXMubGVuZ3RofSlcbiAgICBjeHQucGFzcyhfYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICBjb25zdCB2YWxpZCA9IGdlbi52YXIoXCJ2YWxpZFwiLCBfYCR7bGVufSA8PSAke2l0ZW1zLmxlbmd0aH1gKSAvLyBUT0RPIHZhclxuICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB2YWxpZGF0ZUl0ZW1zKHZhbGlkKSlcbiAgICBjeHQub2sodmFsaWQpXG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gICAgZ2VuLmZvclJhbmdlKFwiaVwiLCBpdGVtcy5sZW5ndGgsIGxlbiwgKGkpID0+IHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoe2tleXdvcmQsIGRhdGFQcm9wOiBpLCBkYXRhUHJvcFR5cGU6IFR5cGUuTnVtfSwgdmFsaWQpXG4gICAgICBpZiAoIWl0LmFsbEVycm9ycykgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKVxuICAgIH0pXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hLCBBbnlTY2hlbWFPYmplY3R9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtffSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIG1lcmdlRXZhbHVhdGVkLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHt2YWxpZGF0ZUFycmF5fSBmcm9tIFwiLi4vY29kZVwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYXJyYXlcIiwgXCJib29sZWFuXCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7c2NoZW1hLCBpdH0gPSBjeHRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpKSByZXR1cm4gdmFsaWRhdGVUdXBsZShjeHQsIFwiYWRkaXRpb25hbEl0ZW1zXCIsIHNjaGVtYSlcbiAgICBpdC5pdGVtcyA9IHRydWVcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGN4dC5vayh2YWxpZGF0ZUFycmF5KGN4dCkpXG4gIH0sXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVR1cGxlKFxuICBjeHQ6IEtleXdvcmRDeHQsXG4gIGV4dHJhSXRlbXM6IHN0cmluZyxcbiAgc2NoQXJyOiBBbnlTY2hlbWFbXSA9IGN4dC5zY2hlbWFcbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBjaGVja1N0cmljdFR1cGxlKHBhcmVudFNjaGVtYSlcbiAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgc2NoQXJyLmxlbmd0aCAmJiBpdC5pdGVtcyAhPT0gdHJ1ZSkge1xuICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBzY2hBcnIubGVuZ3RoLCBpdC5pdGVtcylcbiAgfVxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICBzY2hBcnIuZm9yRWFjaCgoc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkgcmV0dXJuXG4gICAgZ2VuLmlmKF9gJHtsZW59ID4gJHtpfWAsICgpID0+XG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gY2hlY2tTdHJpY3RUdXBsZShzY2g6IEFueVNjaGVtYU9iamVjdCk6IHZvaWQge1xuICAgIGNvbnN0IHtvcHRzLCBlcnJTY2hlbWFQYXRofSA9IGl0XG4gICAgY29uc3QgbCA9IHNjaEFyci5sZW5ndGhcbiAgICBjb25zdCBmdWxsVHVwbGUgPSBsID09PSBzY2gubWluSXRlbXMgJiYgKGwgPT09IHNjaC5tYXhJdGVtcyB8fCBzY2hbZXh0cmFJdGVtc10gPT09IGZhbHNlKVxuICAgIGlmIChvcHRzLnN0cmljdFR1cGxlcyAmJiAhZnVsbFR1cGxlKSB7XG4gICAgICBjb25zdCBtc2cgPSBgXCIke2tleXdvcmR9XCIgaXMgJHtsfS10dXBsZSwgYnV0IG1pbkl0ZW1zIG9yIG1heEl0ZW1zLyR7ZXh0cmFJdGVtc30gYXJlIG5vdCBzcGVjaWZpZWQgb3IgZGlmZmVyZW50IGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgXG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgb3B0cy5zdHJpY3RUdXBsZXMpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQge3ZhbGlkYXRlVHVwbGV9IGZyb20gXCIuL2l0ZW1zXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicHJlZml4SXRlbXNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJhcnJheVwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGNvZGU6IChjeHQpID0+IHZhbGlkYXRlVHVwbGUoY3h0LCBcIml0ZW1zXCIpLFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7dmFsaWRhdGVBcnJheX0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHt2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtc30gZnJvbSBcIi4vYWRkaXRpb25hbEl0ZW1zXCJcblxuZXhwb3J0IHR5cGUgSXRlbXNFcnJvciA9IEVycm9yT2JqZWN0PFwiaXRlbXNcIiwge2xpbWl0OiBudW1iZXJ9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2xlbn19KSA9PiBzdHJgbXVzdCBOT1QgaGF2ZSBtb3JlIHRoYW4gJHtsZW59IGl0ZW1zYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2xlbn19KSA9PiBfYHtsaW1pdDogJHtsZW59fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcIml0ZW1zXCIsXG4gIHR5cGU6IFwiYXJyYXlcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgYmVmb3JlOiBcInVuaXF1ZUl0ZW1zXCIsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge3ByZWZpeEl0ZW1zfSA9IHBhcmVudFNjaGVtYVxuICAgIGl0Lml0ZW1zID0gdHJ1ZVxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgaWYgKHByZWZpeEl0ZW1zKSB2YWxpZGF0ZUFkZGl0aW9uYWxJdGVtcyhjeHQsIHByZWZpeEl0ZW1zKVxuICAgIGVsc2UgY3h0Lm9rKHZhbGlkYXRlQXJyYXkoY3h0KSlcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgQ29udGFpbnNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcImNvbnRhaW5zXCIsXG4gIHttaW5Db250YWluczogbnVtYmVyOyBtYXhDb250YWlucz86IG51bWJlcn0sXG4gIEFueVNjaGVtYVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHttaW4sIG1heH19KSA9PlxuICAgIG1heCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHN0cmBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IHZhbGlkIGl0ZW0ocylgXG4gICAgICA6IHN0cmBtdXN0IGNvbnRhaW4gYXQgbGVhc3QgJHttaW59IGFuZCBubyBtb3JlIHRoYW4gJHttYXh9IHZhbGlkIGl0ZW0ocylgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bWluLCBtYXh9fSkgPT5cbiAgICBtYXggPT09IHVuZGVmaW5lZCA/IF9ge21pbkNvbnRhaW5zOiAke21pbn19YCA6IF9ge21pbkNvbnRhaW5zOiAke21pbn0sIG1heENvbnRhaW5zOiAke21heH19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdH0gPSBjeHRcbiAgICBsZXQgbWluOiBudW1iZXJcbiAgICBsZXQgbWF4OiBudW1iZXIgfCB1bmRlZmluZWRcbiAgICBjb25zdCB7bWluQ29udGFpbnMsIG1heENvbnRhaW5zfSA9IHBhcmVudFNjaGVtYVxuICAgIGlmIChpdC5vcHRzLm5leHQpIHtcbiAgICAgIG1pbiA9IG1pbkNvbnRhaW5zID09PSB1bmRlZmluZWQgPyAxIDogbWluQ29udGFpbnNcbiAgICAgIG1heCA9IG1heENvbnRhaW5zXG4gICAgfSBlbHNlIHtcbiAgICAgIG1pbiA9IDFcbiAgICB9XG4gICAgY29uc3QgbGVuID0gZ2VuLmNvbnN0KFwibGVuXCIsIF9gJHtkYXRhfS5sZW5ndGhgKVxuICAgIGN4dC5zZXRQYXJhbXMoe21pbiwgbWF4fSlcbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAwKSB7XG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPT0gMCB3aXRob3V0IFwibWF4Q29udGFpbnNcIjogXCJjb250YWluc1wiIGtleXdvcmQgaWdub3JlZGApXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIG1pbiA+IG1heCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCJtaW5Db250YWluc1wiID4gXCJtYXhDb250YWluc1wiIGlzIGFsd2F5cyBpbnZhbGlkYClcbiAgICAgIGN4dC5mYWlsKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgIGxldCBjb25kID0gX2Ake2xlbn0gPj0gJHttaW59YFxuICAgICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSBjb25kID0gX2Ake2NvbmR9ICYmICR7bGVufSA8PSAke21heH1gXG4gICAgICBjeHQucGFzcyhjb25kKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaXQuaXRlbXMgPSB0cnVlXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkICYmIG1pbiA9PT0gMSkge1xuICAgICAgdmFsaWRhdGVJdGVtcyh2YWxpZCwgKCkgPT4gZ2VuLmlmKHZhbGlkLCAoKSA9PiBnZW4uYnJlYWsoKSkpXG4gICAgfSBlbHNlIGlmIChtaW4gPT09IDApIHtcbiAgICAgIGdlbi5sZXQodmFsaWQsIHRydWUpXG4gICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIGdlbi5pZihfYCR7ZGF0YX0ubGVuZ3RoID4gMGAsIHZhbGlkYXRlSXRlbXNXaXRoQ291bnQpXG4gICAgfSBlbHNlIHtcbiAgICAgIGdlbi5sZXQodmFsaWQsIGZhbHNlKVxuICAgICAgdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpXG4gICAgfVxuICAgIGN4dC5yZXN1bHQodmFsaWQsICgpID0+IGN4dC5yZXNldCgpKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtc1dpdGhDb3VudCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcbiAgICAgIGNvbnN0IGNvdW50ID0gZ2VuLmxldChcImNvdW50XCIsIDApXG4gICAgICB2YWxpZGF0ZUl0ZW1zKHNjaFZhbGlkLCAoKSA9PiBnZW4uaWYoc2NoVmFsaWQsICgpID0+IGNoZWNrTGltaXRzKGNvdW50KSkpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhfdmFsaWQ6IE5hbWUsIGJsb2NrOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBrZXl3b3JkOiBcImNvbnRhaW5zXCIsXG4gICAgICAgICAgICBkYXRhUHJvcDogaSxcbiAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5OdW0sXG4gICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgIH0sXG4gICAgICAgICAgX3ZhbGlkXG4gICAgICAgIClcbiAgICAgICAgYmxvY2soKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja0xpbWl0cyhjb3VudDogTmFtZSk6IHZvaWQge1xuICAgICAgZ2VuLmNvZGUoX2Ake2NvdW50fSsrYClcbiAgICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnZW4uaWYoX2Ake2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKS5icmVhaygpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuLmlmKF9gJHtjb3VudH0gPiAke21heH1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKSlcbiAgICAgICAgaWYgKG1pbiA9PT0gMSkgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICAgICAgZWxzZSBnZW4uaWYoX2Ake2NvdW50fSA+PSAke21pbn1gLCAoKSA9PiBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKSlcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgU2NoZW1hTWFwLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge2NoZWNrUmVwb3J0TWlzc2luZ1Byb3AsIGNoZWNrTWlzc2luZ1Byb3AsIHJlcG9ydE1pc3NpbmdQcm9wLCBwcm9wZXJ0eUluRGF0YX0gZnJvbSBcIi4uL2NvZGVcIlxuXG5leHBvcnQgdHlwZSBQcm9wZXJ0eURlcGVuZGVuY2llcyA9IHtbSyBpbiBzdHJpbmddPzogc3RyaW5nW119XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwZW5kZW5jaWVzRXJyb3JQYXJhbXMge1xuICBwcm9wZXJ0eTogc3RyaW5nXG4gIG1pc3NpbmdQcm9wZXJ0eTogc3RyaW5nXG4gIGRlcHNDb3VudDogbnVtYmVyXG4gIGRlcHM6IHN0cmluZyAvLyBUT0RPIGNoYW5nZSB0byBzdHJpbmdbXVxufVxuXG50eXBlIFNjaGVtYURlcGVuZGVuY2llcyA9IFNjaGVtYU1hcFxuXG5leHBvcnQgdHlwZSBEZXBlbmRlbmNpZXNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcImRlcGVuZGVuY2llc1wiLFxuICBEZXBlbmRlbmNpZXNFcnJvclBhcmFtcyxcbiAge1tLIGluIHN0cmluZ10/OiBzdHJpbmdbXSB8IEFueVNjaGVtYX1cbj5cblxuZXhwb3J0IGNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge3Byb3BlcnR5LCBkZXBzQ291bnQsIGRlcHN9fSkgPT4ge1xuICAgIGNvbnN0IHByb3BlcnR5X2llcyA9IGRlcHNDb3VudCA9PT0gMSA/IFwicHJvcGVydHlcIiA6IFwicHJvcGVydGllc1wiXG4gICAgcmV0dXJuIHN0cmBtdXN0IGhhdmUgJHtwcm9wZXJ0eV9pZXN9ICR7ZGVwc30gd2hlbiBwcm9wZXJ0eSAke3Byb3BlcnR5fSBpcyBwcmVzZW50YFxuICB9LFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7cHJvcGVydHksIGRlcHNDb3VudCwgZGVwcywgbWlzc2luZ1Byb3BlcnR5fX0pID0+XG4gICAgX2B7cHJvcGVydHk6ICR7cHJvcGVydHl9LFxuICAgIG1pc3NpbmdQcm9wZXJ0eTogJHttaXNzaW5nUHJvcGVydHl9LFxuICAgIGRlcHNDb3VudDogJHtkZXBzQ291bnR9LFxuICAgIGRlcHM6ICR7ZGVwc319YCwgLy8gVE9ETyBjaGFuZ2UgdG8gcmVmZXJlbmNlXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImRlcGVuZGVuY2llc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCBbcHJvcERlcHMsIHNjaERlcHNdID0gc3BsaXREZXBlbmRlbmNpZXMoY3h0KVxuICAgIHZhbGlkYXRlUHJvcGVydHlEZXBzKGN4dCwgcHJvcERlcHMpXG4gICAgdmFsaWRhdGVTY2hlbWFEZXBzKGN4dCwgc2NoRGVwcylcbiAgfSxcbn1cblxuZnVuY3Rpb24gc3BsaXREZXBlbmRlbmNpZXMoe3NjaGVtYX06IEtleXdvcmRDeHQpOiBbUHJvcGVydHlEZXBlbmRlbmNpZXMsIFNjaGVtYURlcGVuZGVuY2llc10ge1xuICBjb25zdCBwcm9wZXJ0eURlcHM6IFByb3BlcnR5RGVwZW5kZW5jaWVzID0ge31cbiAgY29uc3Qgc2NoZW1hRGVwczogU2NoZW1hRGVwZW5kZW5jaWVzID0ge31cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIikgY29udGludWVcbiAgICBjb25zdCBkZXBzID0gQXJyYXkuaXNBcnJheShzY2hlbWFba2V5XSkgPyBwcm9wZXJ0eURlcHMgOiBzY2hlbWFEZXBzXG4gICAgZGVwc1trZXldID0gc2NoZW1hW2tleV1cbiAgfVxuICByZXR1cm4gW3Byb3BlcnR5RGVwcywgc2NoZW1hRGVwc11cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHlEZXBzKFxuICBjeHQ6IEtleXdvcmRDeHQsXG4gIHByb3BlcnR5RGVwczoge1tLIGluIHN0cmluZ10/OiBzdHJpbmdbXX0gPSBjeHQuc2NoZW1hXG4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgaXR9ID0gY3h0XG4gIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0eURlcHMpLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKVxuICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcGVydHlEZXBzKSB7XG4gICAgY29uc3QgZGVwcyA9IHByb3BlcnR5RGVwc1twcm9wXSBhcyBzdHJpbmdbXVxuICAgIGlmIChkZXBzLmxlbmd0aCA9PT0gMCkgY29udGludWVcbiAgICBjb25zdCBoYXNQcm9wZXJ0eSA9IHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKVxuICAgIGN4dC5zZXRQYXJhbXMoe1xuICAgICAgcHJvcGVydHk6IHByb3AsXG4gICAgICBkZXBzQ291bnQ6IGRlcHMubGVuZ3RoLFxuICAgICAgZGVwczogZGVwcy5qb2luKFwiLCBcIiksXG4gICAgfSlcbiAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICBnZW4uaWYoaGFzUHJvcGVydHksICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBkZXBQcm9wIG9mIGRlcHMpIHtcbiAgICAgICAgICBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgZGVwUHJvcClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuLmlmKF9gJHtoYXNQcm9wZXJ0eX0gJiYgKCR7Y2hlY2tNaXNzaW5nUHJvcChjeHQsIGRlcHMsIG1pc3NpbmcpfSlgKVxuICAgICAgcmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBtaXNzaW5nKVxuICAgICAgZ2VuLmVsc2UoKVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTY2hlbWFEZXBzKGN4dDogS2V5d29yZEN4dCwgc2NoZW1hRGVwczogU2NoZW1hTWFwID0gY3h0LnNjaGVtYSk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gIGZvciAoY29uc3QgcHJvcCBpbiBzY2hlbWFEZXBzKSB7XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFEZXBzW3Byb3BdIGFzIEFueVNjaGVtYSkpIGNvbnRpbnVlXG4gICAgZ2VuLmlmKFxuICAgICAgcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLFxuICAgICAgKCkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkLCBzY2hlbWFQcm9wOiBwcm9wfSwgdmFsaWQpXG4gICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpXG4gICAgICB9LFxuICAgICAgKCkgPT4gZ2VuLnZhcih2YWxpZCwgdHJ1ZSkgLy8gVE9ETyB2YXJcbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgbm90fSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBQcm9wZXJ0eU5hbWVzRXJyb3IgPSBFcnJvck9iamVjdDxcInByb3BlcnR5TmFtZXNcIiwge3Byb3BlcnR5TmFtZTogc3RyaW5nfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJwcm9wZXJ0eSBuYW1lIG11c3QgYmUgdmFsaWRcIixcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge3Byb3BlcnR5TmFtZTogJHtwYXJhbXMucHJvcGVydHlOYW1lfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcblxuICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5KSA9PiB7XG4gICAgICBjeHQuc2V0UGFyYW1zKHtwcm9wZXJ0eU5hbWU6IGtleX0pXG4gICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZDogXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgICAgICAgZGF0YToga2V5LFxuICAgICAgICAgIGRhdGFUeXBlczogW1wic3RyaW5nXCJdLFxuICAgICAgICAgIHByb3BlcnR5TmFtZToga2V5LFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgICBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4ge1xuICAgICAgICBjeHQuZXJyb3IodHJ1ZSlcbiAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5icmVhaygpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjeHQub2sodmFsaWQpXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBBZGRlZEtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHthbGxTY2hlbWFQcm9wZXJ0aWVzLCB1c2VQYXR0ZXJuLCBpc093blByb3BlcnR5fSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIG5pbCwgb3IsIG5vdCwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vLi4vY29tcGlsZS9uYW1lc1wiXG5pbXBvcnQgdHlwZSB7U3Vic2NoZW1hQXJnc30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIHNjaGVtYVJlZk9yVmFsLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuZXhwb3J0IHR5cGUgQWRkaXRpb25hbFByb3BlcnRpZXNFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gIHthZGRpdGlvbmFsUHJvcGVydHk6IHN0cmluZ30sXG4gIEFueVNjaGVtYVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IE5PVCBoYXZlIGFkZGl0aW9uYWwgcHJvcGVydGllc1wiLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7YWRkaXRpb25hbFByb3BlcnR5OiAke3BhcmFtcy5hZGRpdGlvbmFsUHJvcGVydHl9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uICYgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICB0eXBlOiBbXCJvYmplY3RcIl0sXG4gIHNjaGVtYVR5cGU6IFtcImJvb2xlYW5cIiwgXCJvYmplY3RcIl0sXG4gIGFsbG93VW5kZWZpbmVkOiB0cnVlLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGVycnNDb3VudCwgaXR9ID0gY3h0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFlcnJzQ291bnQpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIGNvbnN0IHthbGxFcnJvcnMsIG9wdHN9ID0gaXRcbiAgICBpdC5wcm9wcyA9IHRydWVcbiAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsICE9PSBcImFsbFwiICYmIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBjb25zdCBwcm9wcyA9IGFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnByb3BlcnRpZXMpXG4gICAgY29uc3QgcGF0UHJvcHMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHBhcmVudFNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcylcbiAgICBjaGVja0FkZGl0aW9uYWxQcm9wZXJ0aWVzKClcbiAgICBjeHQub2soX2Ake2VycnNDb3VudH0gPT09ICR7Ti5lcnJvcnN9YClcblxuICAgIGZ1bmN0aW9uIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKTogdm9pZCB7XG4gICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleTogTmFtZSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BzLmxlbmd0aCAmJiAhcGF0UHJvcHMubGVuZ3RoKSBhZGRpdGlvbmFsUHJvcGVydHlDb2RlKGtleSlcbiAgICAgICAgZWxzZSBnZW4uaWYoaXNBZGRpdGlvbmFsKGtleSksICgpID0+IGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNBZGRpdGlvbmFsKGtleTogTmFtZSk6IENvZGUge1xuICAgICAgbGV0IGRlZmluZWRQcm9wOiBDb2RlXG4gICAgICBpZiAocHJvcHMubGVuZ3RoID4gOCkge1xuICAgICAgICAvLyBUT0RPIG1heWJlIGFuIG9wdGlvbiBpbnN0ZWFkIG9mIGhhcmQtY29kZWQgOD9cbiAgICAgICAgY29uc3QgcHJvcHNTY2hlbWEgPSBzY2hlbWFSZWZPclZhbChpdCwgcGFyZW50U2NoZW1hLnByb3BlcnRpZXMsIFwicHJvcGVydGllc1wiKVxuICAgICAgICBkZWZpbmVkUHJvcCA9IGlzT3duUHJvcGVydHkoZ2VuLCBwcm9wc1NjaGVtYSBhcyBDb2RlLCBrZXkpXG4gICAgICB9IGVsc2UgaWYgKHByb3BzLmxlbmd0aCkge1xuICAgICAgICBkZWZpbmVkUHJvcCA9IG9yKC4uLnByb3BzLm1hcCgocCkgPT4gX2Ake2tleX0gPT09ICR7cH1gKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlZmluZWRQcm9wID0gbmlsXG4gICAgICB9XG4gICAgICBpZiAocGF0UHJvcHMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluZWRQcm9wID0gb3IoZGVmaW5lZFByb3AsIC4uLnBhdFByb3BzLm1hcCgocCkgPT4gX2Ake3VzZVBhdHRlcm4oY3h0LCBwKX0udGVzdCgke2tleX0pYCkpXG4gICAgICB9XG4gICAgICByZXR1cm4gbm90KGRlZmluZWRQcm9wKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlbGV0ZUFkZGl0aW9uYWwoa2V5OiBOYW1lKTogdm9pZCB7XG4gICAgICBnZW4uY29kZShfYGRlbGV0ZSAke2RhdGF9WyR7a2V5fV1gKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5OiBOYW1lKTogdm9pZCB7XG4gICAgICBpZiAob3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiIHx8IChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgJiYgc2NoZW1hID09PSBmYWxzZSkpIHtcbiAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHthZGRpdGlvbmFsUHJvcGVydHk6IGtleX0pXG4gICAgICAgIGN4dC5lcnJvcigpXG4gICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uYnJlYWsoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiZmFpbGluZ1wiKSB7XG4gICAgICAgICAgYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleSwgdmFsaWQsIGZhbHNlKVxuICAgICAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgICAgICBjeHQucmVzZXQoKVxuICAgICAgICAgICAgZGVsZXRlQWRkaXRpb25hbChrZXkpXG4gICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZClcbiAgICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlBZGRpdGlvbmFsU2NoZW1hKGtleTogTmFtZSwgdmFsaWQ6IE5hbWUsIGVycm9ycz86IGZhbHNlKTogdm9pZCB7XG4gICAgICBjb25zdCBzdWJzY2hlbWE6IFN1YnNjaGVtYUFyZ3MgPSB7XG4gICAgICAgIGtleXdvcmQ6IFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLlN0cixcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvcnMgPT09IGZhbHNlKSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oc3Vic2NoZW1hLCB7XG4gICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBjeHQuc3Vic2NoZW1hKHN1YnNjaGVtYSwgdmFsaWQpXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge3Byb3BlcnR5SW5EYXRhLCBhbGxTY2hlbWFQcm9wZXJ0aWVzfSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCB0b0hhc2gsIG1lcmdlRXZhbHVhdGVkfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBhcERlZiBmcm9tIFwiLi9hZGRpdGlvbmFsUHJvcGVydGllc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJvYmplY3RcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgaXR9ID0gY3h0XG4gICAgaWYgKGl0Lm9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJhbGxcIiAmJiBwYXJlbnRTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXBEZWYuY29kZShuZXcgS2V5d29yZEN4dChpdCwgYXBEZWYsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIikpXG4gICAgfVxuICAgIGNvbnN0IGFsbFByb3BzID0gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIGFsbFByb3BzKSB7XG4gICAgICBpdC5kZWZpbmVkUHJvcGVydGllcy5hZGQocHJvcClcbiAgICB9XG4gICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgYWxsUHJvcHMubGVuZ3RoICYmIGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgdG9IYXNoKGFsbFByb3BzKSwgaXQucHJvcHMpXG4gICAgfVxuICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhbGxQcm9wcy5maWx0ZXIoKHApID0+ICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hW3BdKSlcbiAgICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApIHJldHVyblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BlcnRpZXMpIHtcbiAgICAgIGlmIChoYXNEZWZhdWx0KHByb3ApKSB7XG4gICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbi5pZihwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcykpXG4gICAgICAgIGFwcGx5UHJvcGVydHlTY2hlbWEocHJvcClcbiAgICAgICAgaWYgKCFpdC5hbGxFcnJvcnMpIGdlbi5lbHNlKCkudmFyKHZhbGlkLCB0cnVlKVxuICAgICAgICBnZW4uZW5kSWYoKVxuICAgICAgfVxuICAgICAgY3h0Lml0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKVxuICAgICAgY3h0Lm9rKHZhbGlkKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhc0RlZmF1bHQocHJvcDogc3RyaW5nKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gICAgICByZXR1cm4gaXQub3B0cy51c2VEZWZhdWx0cyAmJiAhaXQuY29tcG9zaXRlUnVsZSAmJiBzY2hlbWFbcHJvcF0uZGVmYXVsdCAhPT0gdW5kZWZpbmVkXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wOiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnRpZXNcIixcbiAgICAgICAgICBzY2hlbWFQcm9wOiBwcm9wLFxuICAgICAgICAgIGRhdGFQcm9wOiBwcm9wLFxuICAgICAgICB9LFxuICAgICAgICB2YWxpZFxuICAgICAgKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2FsbFNjaGVtYVByb3BlcnRpZXMsIHVzZVBhdHRlcm59IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7Xywgbm90LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge2V2YWx1YXRlZFByb3BzVG9OYW1lLCBUeXBlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7QW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0c30gPSBpdFxuICAgIGNvbnN0IHBhdHRlcm5zID0gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWEpXG4gICAgY29uc3QgYWx3YXlzVmFsaWRQYXR0ZXJucyA9IHBhdHRlcm5zLmZpbHRlcigocCkgPT5cbiAgICAgIGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0gYXMgQW55U2NoZW1hKVxuICAgIClcblxuICAgIGlmIChcbiAgICAgIHBhdHRlcm5zLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgKGFsd2F5c1ZhbGlkUGF0dGVybnMubGVuZ3RoID09PSBwYXR0ZXJucy5sZW5ndGggJiZcbiAgICAgICAgKCFpdC5vcHRzLnVuZXZhbHVhdGVkIHx8IGl0LnByb3BzID09PSB0cnVlKSlcbiAgICApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGNoZWNrUHJvcGVydGllcyA9XG4gICAgICBvcHRzLnN0cmljdFNjaGVtYSAmJiAhb3B0cy5hbGxvd01hdGNoaW5nUHJvcGVydGllcyAmJiBwYXJlbnRTY2hlbWEucHJvcGVydGllc1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiAhKGl0LnByb3BzIGluc3RhbmNlb2YgTmFtZSkpIHtcbiAgICAgIGl0LnByb3BzID0gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuLCBpdC5wcm9wcylcbiAgICB9XG4gICAgY29uc3Qge3Byb3BzfSA9IGl0XG4gICAgdmFsaWRhdGVQYXR0ZXJuUHJvcGVydGllcygpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKCk6IHZvaWQge1xuICAgICAgZm9yIChjb25zdCBwYXQgb2YgcGF0dGVybnMpIHtcbiAgICAgICAgaWYgKGNoZWNrUHJvcGVydGllcykgY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0KVxuICAgICAgICBpZiAoaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICAgICAgICAgIHZhbGlkYXRlUHJvcGVydGllcyhwYXQpXG4gICAgICAgICAgZ2VuLmlmKHZhbGlkKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2tNYXRjaGluZ1Byb3BlcnRpZXMocGF0OiBzdHJpbmcpOiB2b2lkIHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBpbiBjaGVja1Byb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKG5ldyBSZWdFeHAocGF0KS50ZXN0KHByb3ApKSB7XG4gICAgICAgICAgY2hlY2tTdHJpY3RNb2RlKFxuICAgICAgICAgICAgaXQsXG4gICAgICAgICAgICBgcHJvcGVydHkgJHtwcm9wfSBtYXRjaGVzIHBhdHRlcm4gJHtwYXR9ICh1c2UgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXMpYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyhwYXQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgICAgZ2VuLmlmKF9gJHt1c2VQYXR0ZXJuKGN4dCwgcGF0KX0udGVzdCgke2tleX0pYCwgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGFsd2F5c1ZhbGlkID0gYWx3YXlzVmFsaWRQYXR0ZXJucy5pbmNsdWRlcyhwYXQpXG4gICAgICAgICAgaWYgKCFhbHdheXNWYWxpZCkge1xuICAgICAgICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGtleXdvcmQ6IFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBwYXQsXG4gICAgICAgICAgICAgICAgZGF0YVByb3A6IGtleSxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuU3RyLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWxpZFxuICAgICAgICAgICAgKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpdC5vcHRzLnVuZXZhbHVhdGVkICYmIHByb3BzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBnZW4uYXNzaWduKF9gJHtwcm9wc31bJHtrZXl9XWAsIHRydWUpXG4gICAgICAgICAgfSBlbHNlIGlmICghYWx3YXlzVmFsaWQgJiYgIWl0LmFsbEVycm9ycykge1xuICAgICAgICAgICAgLy8gY2FuIHNob3J0LWNpcmN1aXQgaWYgYHVuZXZhbHVhdGVkUHJvcGVydGllc2AgaXMgbm90IHN1cHBvcnRlZCAob3B0cy5uZXh0ID09PSBmYWxzZSlcbiAgICAgICAgICAgIC8vIG9yIGlmIGFsbCBwcm9wZXJ0aWVzIHdlcmUgZXZhbHVhdGVkIChwcm9wcyA9PT0gdHJ1ZSlcbiAgICAgICAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiBnZW4uYnJlYWsoKSlcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JOb1BhcmFtcywgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBOb3RLZXl3b3JkRXJyb3IgPSBFcnJvck5vUGFyYW1zPFwibm90XCIsIEFueVNjaGVtYT5cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwibm90XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSB7XG4gICAgICBjeHQuZmFpbCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAge1xuICAgICAgICBrZXl3b3JkOiBcIm5vdFwiLFxuICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICBhbGxFcnJvcnM6IGZhbHNlLFxuICAgICAgfSxcbiAgICAgIHZhbGlkXG4gICAgKVxuXG4gICAgY3h0LmZhaWxSZXN1bHQoXG4gICAgICB2YWxpZCxcbiAgICAgICgpID0+IGN4dC5yZXNldCgpLFxuICAgICAgKCkgPT4gY3h0LmVycm9yKClcbiAgICApXG4gIH0sXG4gIGVycm9yOiB7bWVzc2FnZTogXCJtdXN0IE5PVCBiZSB2YWxpZFwifSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JOb1BhcmFtcywgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHt2YWxpZGF0ZVVuaW9ufSBmcm9tIFwiLi4vY29kZVwiXG5cbmV4cG9ydCB0eXBlIEFueU9mRXJyb3IgPSBFcnJvck5vUGFyYW1zPFwiYW55T2ZcIiwgQW55U2NoZW1hW10+XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFueU9mXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGNvZGU6IHZhbGlkYXRlVW5pb24sXG4gIGVycm9yOiB7bWVzc2FnZTogXCJtdXN0IG1hdGNoIGEgc2NoZW1hIGluIGFueU9mXCJ9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge1NjaGVtYUN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuXG5leHBvcnQgdHlwZSBPbmVPZkVycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwib25lT2ZcIixcbiAge3Bhc3NpbmdTY2hlbWFzOiBbbnVtYmVyLCBudW1iZXJdIHwgbnVsbH0sXG4gIEFueVNjaGVtYVtdXG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgbWF0Y2ggZXhhY3RseSBvbmUgc2NoZW1hIGluIG9uZU9mXCIsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHtwYXNzaW5nU2NoZW1hczogJHtwYXJhbXMucGFzc2luZ319YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICBpZiAoaXQub3B0cy5kaXNjcmltaW5hdG9yICYmIHBhcmVudFNjaGVtYS5kaXNjcmltaW5hdG9yKSByZXR1cm5cbiAgICBjb25zdCBzY2hBcnI6IEFueVNjaGVtYVtdID0gc2NoZW1hXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgZmFsc2UpXG4gICAgY29uc3QgcGFzc2luZyA9IGdlbi5sZXQoXCJwYXNzaW5nXCIsIG51bGwpXG4gICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuICAgIGN4dC5zZXRQYXJhbXMoe3Bhc3Npbmd9KVxuICAgIC8vIFRPRE8gcG9zc2libHkgZmFpbCBzdHJhaWdodCBhd2F5ICh3aXRoIHdhcm5pbmcgb3IgZXhjZXB0aW9uKSBpZiB0aGVyZSBhcmUgdHdvIGVtcHR5IGFsd2F5cyB2YWxpZCBzY2hlbWFzXG5cbiAgICBnZW4uYmxvY2sodmFsaWRhdGVPbmVPZilcblxuICAgIGN4dC5yZXN1bHQoXG4gICAgICB2YWxpZCxcbiAgICAgICgpID0+IGN4dC5yZXNldCgpLFxuICAgICAgKCkgPT4gY3h0LmVycm9yKHRydWUpXG4gICAgKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVPbmVPZigpOiB2b2lkIHtcbiAgICAgIHNjaEFyci5mb3JFYWNoKChzY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICAgIGxldCBzY2hDeHQ6IFNjaGVtYUN4dCB8IHVuZGVmaW5lZFxuICAgICAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaCkpIHtcbiAgICAgICAgICBnZW4udmFyKHNjaFZhbGlkLCB0cnVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGtleXdvcmQ6IFwib25lT2ZcIixcbiAgICAgICAgICAgICAgc2NoZW1hUHJvcDogaSxcbiAgICAgICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY2hWYWxpZFxuICAgICAgICAgIClcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgIGdlblxuICAgICAgICAgICAgLmlmKF9gJHtzY2hWYWxpZH0gJiYgJHt2YWxpZH1gKVxuICAgICAgICAgICAgLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgICAuYXNzaWduKHBhc3NpbmcsIF9gWyR7cGFzc2luZ30sICR7aX1dYClcbiAgICAgICAgICAgIC5lbHNlKClcbiAgICAgICAgfVxuXG4gICAgICAgIGdlbi5pZihzY2hWYWxpZCwgKCkgPT4ge1xuICAgICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHRydWUpXG4gICAgICAgICAgZ2VuLmFzc2lnbihwYXNzaW5nLCBpKVxuICAgICAgICAgIGlmIChzY2hDeHQpIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQsIE5hbWUpXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hfSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhbGxPZlwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBpdH0gPSBjeHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc2NoZW1hKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgc2NoZW1hLmZvckVhY2goKHNjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkgcmV0dXJuXG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkOiBcImFsbE9mXCIsIHNjaGVtYVByb3A6IGl9LCB2YWxpZClcbiAgICAgIGN4dC5vayh2YWxpZClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpXG4gICAgfSlcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5vdCwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBJZktleXdvcmRFcnJvciA9IEVycm9yT2JqZWN0PFwiaWZcIiwge2ZhaWxpbmdLZXl3b3JkOiBzdHJpbmd9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtc30pID0+IHN0cmBtdXN0IG1hdGNoIFwiJHtwYXJhbXMuaWZDbGF1c2V9XCIgc2NoZW1hYCxcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge2ZhaWxpbmdLZXl3b3JkOiAke3BhcmFtcy5pZkNsYXVzZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiaWZcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgaWYgKHBhcmVudFNjaGVtYS50aGVuID09PSB1bmRlZmluZWQgJiYgcGFyZW50U2NoZW1hLmVsc2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY2hlY2tTdHJpY3RNb2RlKGl0LCAnXCJpZlwiIHdpdGhvdXQgXCJ0aGVuXCIgYW5kIFwiZWxzZVwiIGlzIGlnbm9yZWQnKVxuICAgIH1cbiAgICBjb25zdCBoYXNUaGVuID0gaGFzU2NoZW1hKGl0LCBcInRoZW5cIilcbiAgICBjb25zdCBoYXNFbHNlID0gaGFzU2NoZW1hKGl0LCBcImVsc2VcIilcbiAgICBpZiAoIWhhc1RoZW4gJiYgIWhhc0Vsc2UpIHJldHVyblxuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSlcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG4gICAgdmFsaWRhdGVJZigpXG4gICAgY3h0LnJlc2V0KClcblxuICAgIGlmIChoYXNUaGVuICYmIGhhc0Vsc2UpIHtcbiAgICAgIGNvbnN0IGlmQ2xhdXNlID0gZ2VuLmxldChcImlmQ2xhdXNlXCIpXG4gICAgICBjeHQuc2V0UGFyYW1zKHtpZkNsYXVzZX0pXG4gICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiLCBpZkNsYXVzZSksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiLCBpZkNsYXVzZSkpXG4gICAgfSBlbHNlIGlmIChoYXNUaGVuKSB7XG4gICAgICBnZW4uaWYoc2NoVmFsaWQsIHZhbGlkYXRlQ2xhdXNlKFwidGhlblwiKSlcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuLmlmKG5vdChzY2hWYWxpZCksIHZhbGlkYXRlQ2xhdXNlKFwiZWxzZVwiKSlcbiAgICB9XG5cbiAgICBjeHQucGFzcyh2YWxpZCwgKCkgPT4gY3h0LmVycm9yKHRydWUpKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVJZigpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkOiBcImlmXCIsXG4gICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgICBjcmVhdGVFcnJvcnM6IGZhbHNlLFxuICAgICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHNjaFZhbGlkXG4gICAgICApXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2xhdXNlKGtleXdvcmQ6IHN0cmluZywgaWZDbGF1c2U/OiBOYW1lKTogKCkgPT4gdm9pZCB7XG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkfSwgc2NoVmFsaWQpXG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIHNjaFZhbGlkKVxuICAgICAgICBjeHQubWVyZ2VWYWxpZEV2YWx1YXRlZChzY2hDeHQsIHZhbGlkKVxuICAgICAgICBpZiAoaWZDbGF1c2UpIGdlbi5hc3NpZ24oaWZDbGF1c2UsIF9gJHtrZXl3b3JkfWApXG4gICAgICAgIGVsc2UgY3h0LnNldFBhcmFtcyh7aWZDbGF1c2U6IGtleXdvcmR9KVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZnVuY3Rpb24gaGFzU2NoZW1hKGl0OiBTY2hlbWFPYmpDeHQsIGtleXdvcmQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuICBjb25zdCBzY2hlbWEgPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgcmV0dXJuIHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Y2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcInRoZW5cIiwgXCJlbHNlXCJdLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBjb2RlKHtrZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGl0fTogS2V5d29yZEN4dCkge1xuICAgIGlmIChwYXJlbnRTY2hlbWEuaWYgPT09IHVuZGVmaW5lZCkgY2hlY2tTdHJpY3RNb2RlKGl0LCBgXCIke2tleXdvcmR9XCIgd2l0aG91dCBcImlmXCIgaXMgaWdub3JlZGApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtFcnJvck5vUGFyYW1zLCBWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IGFkZGl0aW9uYWxJdGVtcywge0FkZGl0aW9uYWxJdGVtc0Vycm9yfSBmcm9tIFwiLi9hZGRpdGlvbmFsSXRlbXNcIlxuaW1wb3J0IHByZWZpeEl0ZW1zIGZyb20gXCIuL3ByZWZpeEl0ZW1zXCJcbmltcG9ydCBpdGVtcyBmcm9tIFwiLi9pdGVtc1wiXG5pbXBvcnQgaXRlbXMyMDIwLCB7SXRlbXNFcnJvcn0gZnJvbSBcIi4vaXRlbXMyMDIwXCJcbmltcG9ydCBjb250YWlucywge0NvbnRhaW5zRXJyb3J9IGZyb20gXCIuL2NvbnRhaW5zXCJcbmltcG9ydCBkZXBlbmRlbmNpZXMsIHtEZXBlbmRlbmNpZXNFcnJvcn0gZnJvbSBcIi4vZGVwZW5kZW5jaWVzXCJcbmltcG9ydCBwcm9wZXJ0eU5hbWVzLCB7UHJvcGVydHlOYW1lc0Vycm9yfSBmcm9tIFwiLi9wcm9wZXJ0eU5hbWVzXCJcbmltcG9ydCBhZGRpdGlvbmFsUHJvcGVydGllcywge0FkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3J9IGZyb20gXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCJcbmltcG9ydCBwcm9wZXJ0aWVzIGZyb20gXCIuL3Byb3BlcnRpZXNcIlxuaW1wb3J0IHBhdHRlcm5Qcm9wZXJ0aWVzIGZyb20gXCIuL3BhdHRlcm5Qcm9wZXJ0aWVzXCJcbmltcG9ydCBub3RLZXl3b3JkLCB7Tm90S2V5d29yZEVycm9yfSBmcm9tIFwiLi9ub3RcIlxuaW1wb3J0IGFueU9mLCB7QW55T2ZFcnJvcn0gZnJvbSBcIi4vYW55T2ZcIlxuaW1wb3J0IG9uZU9mLCB7T25lT2ZFcnJvcn0gZnJvbSBcIi4vb25lT2ZcIlxuaW1wb3J0IGFsbE9mIGZyb20gXCIuL2FsbE9mXCJcbmltcG9ydCBpZktleXdvcmQsIHtJZktleXdvcmRFcnJvcn0gZnJvbSBcIi4vaWZcIlxuaW1wb3J0IHRoZW5FbHNlIGZyb20gXCIuL3RoZW5FbHNlXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0QXBwbGljYXRvcihkcmFmdDIwMjAgPSBmYWxzZSk6IFZvY2FidWxhcnkge1xuICBjb25zdCBhcHBsaWNhdG9yID0gW1xuICAgIC8vIGFueVxuICAgIG5vdEtleXdvcmQsXG4gICAgYW55T2YsXG4gICAgb25lT2YsXG4gICAgYWxsT2YsXG4gICAgaWZLZXl3b3JkLFxuICAgIHRoZW5FbHNlLFxuICAgIC8vIG9iamVjdFxuICAgIHByb3BlcnR5TmFtZXMsXG4gICAgYWRkaXRpb25hbFByb3BlcnRpZXMsXG4gICAgZGVwZW5kZW5jaWVzLFxuICAgIHByb3BlcnRpZXMsXG4gICAgcGF0dGVyblByb3BlcnRpZXMsXG4gIF1cbiAgLy8gYXJyYXlcbiAgaWYgKGRyYWZ0MjAyMCkgYXBwbGljYXRvci5wdXNoKHByZWZpeEl0ZW1zLCBpdGVtczIwMjApXG4gIGVsc2UgYXBwbGljYXRvci5wdXNoKGFkZGl0aW9uYWxJdGVtcywgaXRlbXMpXG4gIGFwcGxpY2F0b3IucHVzaChjb250YWlucylcbiAgcmV0dXJuIGFwcGxpY2F0b3Jcbn1cblxuZXhwb3J0IHR5cGUgQXBwbGljYXRvcktleXdvcmRFcnJvciA9XG4gIHwgRXJyb3JOb1BhcmFtczxcImZhbHNlIHNjaGVtYVwiPlxuICB8IEFkZGl0aW9uYWxJdGVtc0Vycm9yXG4gIHwgSXRlbXNFcnJvclxuICB8IENvbnRhaW5zRXJyb3JcbiAgfCBBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yXG4gIHwgRGVwZW5kZW5jaWVzRXJyb3JcbiAgfCBJZktleXdvcmRFcnJvclxuICB8IEFueU9mRXJyb3JcbiAgfCBPbmVPZkVycm9yXG4gIHwgTm90S2V5d29yZEVycm9yXG4gIHwgUHJvcGVydHlOYW1lc0Vycm9yXG4iLCAiaW1wb3J0IHR5cGUge1xuICBBZGRlZEZvcm1hdCxcbiAgRm9ybWF0VmFsaWRhdG9yLFxuICBBc3luY0Zvcm1hdFZhbGlkYXRvcixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgbmlsLCBvciwgQ29kZSwgZ2V0UHJvcGVydHksIHJlZ2V4cENvZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG50eXBlIEZvcm1hdFZhbGlkYXRlID1cbiAgfCBGb3JtYXRWYWxpZGF0b3I8c3RyaW5nPlxuICB8IEZvcm1hdFZhbGlkYXRvcjxudW1iZXI+XG4gIHwgQXN5bmNGb3JtYXRWYWxpZGF0b3I8c3RyaW5nPlxuICB8IEFzeW5jRm9ybWF0VmFsaWRhdG9yPG51bWJlcj5cbiAgfCBSZWdFeHBcbiAgfCBzdHJpbmdcbiAgfCB0cnVlXG5cbmV4cG9ydCB0eXBlIEZvcm1hdEVycm9yID0gRXJyb3JPYmplY3Q8XCJmb3JtYXRcIiwge2Zvcm1hdDogc3RyaW5nfSwgc3RyaW5nIHwgeyRkYXRhOiBzdHJpbmd9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgbWF0Y2ggZm9ybWF0IFwiJHtzY2hlbWFDb2RlfVwiYCxcbiAgcGFyYW1zOiAoe3NjaGVtYUNvZGV9KSA9PiBfYHtmb3JtYXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZm9ybWF0XCIsXG4gIHR5cGU6IFtcIm51bWJlclwiLCBcInN0cmluZ1wiXSxcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCwgcnVsZVR5cGU/OiBzdHJpbmcpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0cywgZXJyU2NoZW1hUGF0aCwgc2NoZW1hRW52LCBzZWxmfSA9IGl0XG4gICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cykgcmV0dXJuXG5cbiAgICBpZiAoJGRhdGEpIHZhbGlkYXRlJERhdGFGb3JtYXQoKVxuICAgIGVsc2UgdmFsaWRhdGVGb3JtYXQoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICB9KVxuICAgICAgY29uc3QgZkRlZiA9IGdlbi5jb25zdChcImZEZWZcIiwgX2Ake2ZtdHN9WyR7c2NoZW1hQ29kZX1dYClcbiAgICAgIGNvbnN0IGZUeXBlID0gZ2VuLmxldChcImZUeXBlXCIpXG4gICAgICBjb25zdCBmb3JtYXQgPSBnZW4ubGV0KFwiZm9ybWF0XCIpXG4gICAgICAvLyBUT0RPIHNpbXBsaWZ5XG4gICAgICBnZW4uaWYoXG4gICAgICAgIF9gdHlwZW9mICR7ZkRlZn0gPT0gXCJvYmplY3RcIiAmJiAhKCR7ZkRlZn0gaW5zdGFuY2VvZiBSZWdFeHApYCxcbiAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbihmVHlwZSwgX2Ake2ZEZWZ9LnR5cGUgfHwgXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIF9gJHtmRGVmfS52YWxpZGF0ZWApLFxuICAgICAgICAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCBfYFwic3RyaW5nXCJgKS5hc3NpZ24oZm9ybWF0LCBmRGVmKVxuICAgICAgKVxuICAgICAgY3h0LmZhaWwkZGF0YShvcih1bmtub3duRm10KCksIGludmFsaWRGbXQoKSkpXG5cbiAgICAgIGZ1bmN0aW9uIHVua25vd25GbXQoKTogQ29kZSB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHJldHVybiBuaWxcbiAgICAgICAgcmV0dXJuIF9gJHtzY2hlbWFDb2RlfSAmJiAhJHtmb3JtYXR9YFxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZhbGlkRm10KCk6IENvZGUge1xuICAgICAgICBjb25zdCBjYWxsRm9ybWF0ID0gc2NoZW1hRW52LiRhc3luY1xuICAgICAgICAgID8gX2AoJHtmRGVmfS5hc3luYyA/IGF3YWl0ICR7Zm9ybWF0fSgke2RhdGF9KSA6ICR7Zm9ybWF0fSgke2RhdGF9KSlgXG4gICAgICAgICAgOiBfYCR7Zm9ybWF0fSgke2RhdGF9KWBcbiAgICAgICAgY29uc3QgdmFsaWREYXRhID0gX2AodHlwZW9mICR7Zm9ybWF0fSA9PSBcImZ1bmN0aW9uXCIgPyAke2NhbGxGb3JtYXR9IDogJHtmb3JtYXR9LnRlc3QoJHtkYXRhfSkpYFxuICAgICAgICByZXR1cm4gX2Ake2Zvcm1hdH0gJiYgJHtmb3JtYXR9ICE9PSB0cnVlICYmICR7ZlR5cGV9ID09PSAke3J1bGVUeXBlfSAmJiAhJHt2YWxpZERhdGF9YFxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCk6IHZvaWQge1xuICAgICAgY29uc3QgZm9ybWF0RGVmOiBBZGRlZEZvcm1hdCB8IHVuZGVmaW5lZCA9IHNlbGYuZm9ybWF0c1tzY2hlbWFdXG4gICAgICBpZiAoIWZvcm1hdERlZikge1xuICAgICAgICB1bmtub3duRm9ybWF0KClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBpZiAoZm9ybWF0RGVmID09PSB0cnVlKSByZXR1cm5cbiAgICAgIGNvbnN0IFtmbXRUeXBlLCBmb3JtYXQsIGZtdFJlZl0gPSBnZXRGb3JtYXQoZm9ybWF0RGVmKVxuICAgICAgaWYgKGZtdFR5cGUgPT09IHJ1bGVUeXBlKSBjeHQucGFzcyh2YWxpZENvbmRpdGlvbigpKVxuXG4gICAgICBmdW5jdGlvbiB1bmtub3duRm9ybWF0KCk6IHZvaWQge1xuICAgICAgICBpZiAob3B0cy5zdHJpY3RTY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgc2VsZi5sb2dnZXIud2Fybih1bmtub3duTXNnKCkpXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVua25vd25Nc2coKSlcblxuICAgICAgICBmdW5jdGlvbiB1bmtub3duTXNnKCk6IHN0cmluZyB7XG4gICAgICAgICAgcmV0dXJuIGB1bmtub3duIGZvcm1hdCBcIiR7c2NoZW1hIGFzIHN0cmluZ31cIiBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldEZvcm1hdChmbXREZWY6IEFkZGVkRm9ybWF0KTogW3N0cmluZywgRm9ybWF0VmFsaWRhdGUsIENvZGVdIHtcbiAgICAgICAgY29uc3QgY29kZSA9XG4gICAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwXG4gICAgICAgICAgICA/IHJlZ2V4cENvZGUoZm10RGVmKVxuICAgICAgICAgICAgOiBvcHRzLmNvZGUuZm9ybWF0c1xuICAgICAgICAgICAgPyBfYCR7b3B0cy5jb2RlLmZvcm1hdHN9JHtnZXRQcm9wZXJ0eShzY2hlbWEpfWBcbiAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgIGNvbnN0IGZtdCA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7a2V5OiBzY2hlbWEsIHJlZjogZm10RGVmLCBjb2RlfSlcbiAgICAgICAgaWYgKHR5cGVvZiBmbXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZtdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkpIHtcbiAgICAgICAgICByZXR1cm4gW2ZtdERlZi50eXBlIHx8IFwic3RyaW5nXCIsIGZtdERlZi52YWxpZGF0ZSwgX2Ake2ZtdH0udmFsaWRhdGVgXVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIFtcInN0cmluZ1wiLCBmbXREZWYsIGZtdF1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gdmFsaWRDb25kaXRpb24oKTogQ29kZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0RGVmID09IFwib2JqZWN0XCIgJiYgIShmb3JtYXREZWYgaW5zdGFuY2VvZiBSZWdFeHApICYmIGZvcm1hdERlZi5hc3luYykge1xuICAgICAgICAgIGlmICghc2NoZW1hRW52LiRhc3luYykgdGhyb3cgbmV3IEVycm9yKFwiYXN5bmMgZm9ybWF0IGluIHN5bmMgc2NoZW1hXCIpXG4gICAgICAgICAgcmV0dXJuIF9gYXdhaXQgJHtmbXRSZWZ9KCR7ZGF0YX0pYFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0eXBlb2YgZm9ybWF0ID09IFwiZnVuY3Rpb25cIiA/IF9gJHtmbXRSZWZ9KCR7ZGF0YX0pYCA6IF9gJHtmbXRSZWZ9LnRlc3QoJHtkYXRhfSlgXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCBmb3JtYXRLZXl3b3JkIGZyb20gXCIuL2Zvcm1hdFwiXG5cbmNvbnN0IGZvcm1hdDogVm9jYWJ1bGFyeSA9IFtmb3JtYXRLZXl3b3JkXVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRcbiIsICJpbXBvcnQgdHlwZSB7Vm9jYWJ1bGFyeX0gZnJvbSBcIi4uL3R5cGVzXCJcblxuZXhwb3J0IGNvbnN0IG1ldGFkYXRhVm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSA9IFtcbiAgXCJ0aXRsZVwiLFxuICBcImRlc2NyaXB0aW9uXCIsXG4gIFwiZGVmYXVsdFwiLFxuICBcImRlcHJlY2F0ZWRcIixcbiAgXCJyZWFkT25seVwiLFxuICBcIndyaXRlT25seVwiLFxuICBcImV4YW1wbGVzXCIsXG5dXG5cbmV4cG9ydCBjb25zdCBjb250ZW50Vm9jYWJ1bGFyeTogVm9jYWJ1bGFyeSA9IFtcbiAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gIFwiY29udGVudEVuY29kaW5nXCIsXG4gIFwiY29udGVudFNjaGVtYVwiLFxuXVxuIiwgImltcG9ydCB0eXBlIHtWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IGNvcmVWb2NhYnVsYXJ5IGZyb20gXCIuL2NvcmVcIlxuaW1wb3J0IHZhbGlkYXRpb25Wb2NhYnVsYXJ5IGZyb20gXCIuL3ZhbGlkYXRpb25cIlxuaW1wb3J0IGdldEFwcGxpY2F0b3JWb2NhYnVsYXJ5IGZyb20gXCIuL2FwcGxpY2F0b3JcIlxuaW1wb3J0IGZvcm1hdFZvY2FidWxhcnkgZnJvbSBcIi4vZm9ybWF0XCJcbmltcG9ydCB7bWV0YWRhdGFWb2NhYnVsYXJ5LCBjb250ZW50Vm9jYWJ1bGFyeX0gZnJvbSBcIi4vbWV0YWRhdGFcIlxuXG5jb25zdCBkcmFmdDdWb2NhYnVsYXJpZXM6IFZvY2FidWxhcnlbXSA9IFtcbiAgY29yZVZvY2FidWxhcnksXG4gIHZhbGlkYXRpb25Wb2NhYnVsYXJ5LFxuICBnZXRBcHBsaWNhdG9yVm9jYWJ1bGFyeSgpLFxuICBmb3JtYXRWb2NhYnVsYXJ5LFxuICBtZXRhZGF0YVZvY2FidWxhcnksXG4gIGNvbnRlbnRWb2NhYnVsYXJ5LFxuXVxuXG5leHBvcnQgZGVmYXVsdCBkcmFmdDdWb2NhYnVsYXJpZXNcbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JPYmplY3R9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5cbmV4cG9ydCBlbnVtIERpc2NyRXJyb3Ige1xuICBUYWcgPSBcInRhZ1wiLFxuICBNYXBwaW5nID0gXCJtYXBwaW5nXCIsXG59XG5cbmV4cG9ydCB0eXBlIERpc2NyRXJyb3JPYmo8RSBleHRlbmRzIERpc2NyRXJyb3I+ID0gRXJyb3JPYmplY3Q8XG4gIFwiZGlzY3JpbWluYXRvclwiLFxuICB7ZXJyb3I6IEU7IHRhZzogc3RyaW5nOyB0YWdWYWx1ZTogdW5rbm93bn0sXG4gIHN0cmluZ1xuPlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEFueVNjaGVtYU9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIGdldFByb3BlcnR5LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7RGlzY3JFcnJvciwgRGlzY3JFcnJvck9ian0gZnJvbSBcIi4uL2Rpc2NyaW1pbmF0b3IvdHlwZXNcIlxuaW1wb3J0IHtyZXNvbHZlUmVmLCBTY2hlbWFFbnZ9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcbmltcG9ydCBNaXNzaW5nUmVmRXJyb3IgZnJvbSBcIi4uLy4uL2NvbXBpbGUvcmVmX2Vycm9yXCJcbmltcG9ydCB7c2NoZW1hSGFzUnVsZXNCdXRSZWZ9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBEaXNjcmltaW5hdG9yRXJyb3IgPSBEaXNjckVycm9yT2JqPERpc2NyRXJyb3IuVGFnPiB8IERpc2NyRXJyb3JPYmo8RGlzY3JFcnJvci5NYXBwaW5nPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtkaXNjckVycm9yLCB0YWdOYW1lfX0pID0+XG4gICAgZGlzY3JFcnJvciA9PT0gRGlzY3JFcnJvci5UYWdcbiAgICAgID8gYHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHN0cmluZ2BcbiAgICAgIDogYHZhbHVlIG9mIHRhZyBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIGluIG9uZU9mYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2Rpc2NyRXJyb3IsIHRhZywgdGFnTmFtZX19KSA9PlxuICAgIF9ge2Vycm9yOiAke2Rpc2NyRXJyb3J9LCB0YWc6ICR7dGFnTmFtZX0sIHRhZ1ZhbHVlOiAke3RhZ319YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZGlzY3JpbWluYXRvclwiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29uZU9mfSA9IHBhcmVudFNjaGVtYVxuICAgIGlmICghaXQub3B0cy5kaXNjcmltaW5hdG9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBkaXNjcmltaW5hdG9yIG9wdGlvblwiKVxuICAgIH1cbiAgICBjb25zdCB0YWdOYW1lID0gc2NoZW1hLnByb3BlcnR5TmFtZVxuICAgIGlmICh0eXBlb2YgdGFnTmFtZSAhPSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgRXJyb3IoXCJkaXNjcmltaW5hdG9yOiByZXF1aXJlcyBwcm9wZXJ0eU5hbWVcIilcbiAgICBpZiAoc2NoZW1hLm1hcHBpbmcpIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IG1hcHBpbmcgaXMgbm90IHN1cHBvcnRlZFwiKVxuICAgIGlmICghb25lT2YpIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIG9uZU9mIGtleXdvcmRcIilcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSlcbiAgICBjb25zdCB0YWcgPSBnZW4uY29uc3QoXCJ0YWdcIiwgX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eSh0YWdOYW1lKX1gKVxuICAgIGdlbi5pZihcbiAgICAgIF9gdHlwZW9mICR7dGFnfSA9PSBcInN0cmluZ1wiYCxcbiAgICAgICgpID0+IHZhbGlkYXRlTWFwcGluZygpLFxuICAgICAgKCkgPT4gY3h0LmVycm9yKGZhbHNlLCB7ZGlzY3JFcnJvcjogRGlzY3JFcnJvci5UYWcsIHRhZywgdGFnTmFtZX0pXG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlTWFwcGluZygpOiB2b2lkIHtcbiAgICAgIGNvbnN0IG1hcHBpbmcgPSBnZXRNYXBwaW5nKClcbiAgICAgIGdlbi5pZihmYWxzZSlcbiAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgaW4gbWFwcGluZykge1xuICAgICAgICBnZW4uZWxzZUlmKF9gJHt0YWd9ID09PSAke3RhZ1ZhbHVlfWApXG4gICAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGFwcGx5VGFnU2NoZW1hKG1hcHBpbmdbdGFnVmFsdWVdKSlcbiAgICAgIH1cbiAgICAgIGdlbi5lbHNlKClcbiAgICAgIGN4dC5lcnJvcihmYWxzZSwge2Rpc2NyRXJyb3I6IERpc2NyRXJyb3IuTWFwcGluZywgdGFnLCB0YWdOYW1lfSlcbiAgICAgIGdlbi5lbmRJZigpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYXBwbHlUYWdTY2hlbWEoc2NoZW1hUHJvcD86IG51bWJlcik6IE5hbWUge1xuICAgICAgY29uc3QgX3ZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYSh7a2V5d29yZDogXCJvbmVPZlwiLCBzY2hlbWFQcm9wfSwgX3ZhbGlkKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgTmFtZSlcbiAgICAgIHJldHVybiBfdmFsaWRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRNYXBwaW5nKCk6IHtbVCBpbiBzdHJpbmddPzogbnVtYmVyfSB7XG4gICAgICBjb25zdCBvbmVPZk1hcHBpbmc6IHtbVCBpbiBzdHJpbmddPzogbnVtYmVyfSA9IHt9XG4gICAgICBjb25zdCB0b3BSZXF1aXJlZCA9IGhhc1JlcXVpcmVkKHBhcmVudFNjaGVtYSlcbiAgICAgIGxldCB0YWdSZXF1aXJlZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb25lT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHNjaCA9IG9uZU9mW2ldXG4gICAgICAgIGlmIChzY2g/LiRyZWYgJiYgIXNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaCwgaXQuc2VsZi5SVUxFUykpIHtcbiAgICAgICAgICBjb25zdCByZWYgPSBzY2guJHJlZlxuICAgICAgICAgIHNjaCA9IHJlc29sdmVSZWYuY2FsbChpdC5zZWxmLCBpdC5zY2hlbWFFbnYucm9vdCwgaXQuYmFzZUlkLCByZWYpXG4gICAgICAgICAgaWYgKHNjaCBpbnN0YW5jZW9mIFNjaGVtYUVudikgc2NoID0gc2NoLnNjaGVtYVxuICAgICAgICAgIGlmIChzY2ggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IE1pc3NpbmdSZWZFcnJvcihpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHJlZilcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9wU2NoID0gc2NoPy5wcm9wZXJ0aWVzPy5bdGFnTmFtZV1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm9wU2NoICE9IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgZGlzY3JpbWluYXRvcjogb25lT2Ygc3Vic2NoZW1hcyAob3IgcmVmZXJlbmNlZCBzY2hlbWFzKSBtdXN0IGhhdmUgXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cImBcbiAgICAgICAgICApXG4gICAgICAgIH1cbiAgICAgICAgdGFnUmVxdWlyZWQgPSB0YWdSZXF1aXJlZCAmJiAodG9wUmVxdWlyZWQgfHwgaGFzUmVxdWlyZWQoc2NoKSlcbiAgICAgICAgYWRkTWFwcGluZ3MocHJvcFNjaCwgaSlcbiAgICAgIH1cbiAgICAgIGlmICghdGFnUmVxdWlyZWQpIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgbXVzdCBiZSByZXF1aXJlZGApXG4gICAgICByZXR1cm4gb25lT2ZNYXBwaW5nXG5cbiAgICAgIGZ1bmN0aW9uIGhhc1JlcXVpcmVkKHtyZXF1aXJlZH06IEFueVNjaGVtYU9iamVjdCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShyZXF1aXJlZCkgJiYgcmVxdWlyZWQuaW5jbHVkZXModGFnTmFtZSlcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZ3Moc2NoOiBBbnlTY2hlbWFPYmplY3QsIGk6IG51bWJlcik6IHZvaWQge1xuICAgICAgICBpZiAoc2NoLmNvbnN0KSB7XG4gICAgICAgICAgYWRkTWFwcGluZyhzY2guY29uc3QsIGkpXG4gICAgICAgIH0gZWxzZSBpZiAoc2NoLmVudW0pIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHRhZ1ZhbHVlIG9mIHNjaC5lbnVtKSB7XG4gICAgICAgICAgICBhZGRNYXBwaW5nKHRhZ1ZhbHVlLCBpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwicHJvcGVydGllcy8ke3RhZ05hbWV9XCIgbXVzdCBoYXZlIFwiY29uc3RcIiBvciBcImVudW1cImApXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gYWRkTWFwcGluZyh0YWdWYWx1ZTogdW5rbm93biwgaTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmICh0eXBlb2YgdGFnVmFsdWUgIT0gXCJzdHJpbmdcIiB8fCB0YWdWYWx1ZSBpbiBvbmVPZk1hcHBpbmcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGRpc2NyaW1pbmF0b3I6IFwiJHt0YWdOYW1lfVwiIHZhbHVlcyBtdXN0IGJlIHVuaXF1ZSBzdHJpbmdzYClcbiAgICAgICAgfVxuICAgICAgICBvbmVPZk1hcHBpbmdbdGFnVmFsdWVdID0gaVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAie1xuICBcIiRzY2hlbWFcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgXCIkaWRcIjogXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIixcbiAgXCJ0aXRsZVwiOiBcIkNvcmUgc2NoZW1hIG1ldGEtc2NoZW1hXCIsXG4gIFwiZGVmaW5pdGlvbnNcIjoge1xuICAgIFwic2NoZW1hQXJyYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgIFwiaXRlbXNcIjoge1wiJHJlZlwiOiBcIiNcIn1cbiAgICB9LFxuICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImludGVnZXJcIixcbiAgICAgIFwibWluaW11bVwiOiAwXG4gICAgfSxcbiAgICBcIm5vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCI6IHtcbiAgICAgIFwiYWxsT2ZcIjogW3tcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSwge1wiZGVmYXVsdFwiOiAwfV1cbiAgICB9LFxuICAgIFwic2ltcGxlVHlwZXNcIjoge1xuICAgICAgXCJlbnVtXCI6IFtcImFycmF5XCIsIFwiYm9vbGVhblwiLCBcImludGVnZXJcIiwgXCJudWxsXCIsIFwibnVtYmVyXCIsIFwib2JqZWN0XCIsIFwic3RyaW5nXCJdXG4gICAgfSxcbiAgICBcInN0cmluZ0FycmF5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWUsXG4gICAgICBcImRlZmF1bHRcIjogW11cbiAgICB9XG4gIH0sXG4gIFwidHlwZVwiOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBcInByb3BlcnRpZXNcIjoge1xuICAgIFwiJGlkXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICB9LFxuICAgIFwiJHNjaGVtYVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpXCJcbiAgICB9LFxuICAgIFwiJHJlZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJzdHJpbmdcIixcbiAgICAgIFwiZm9ybWF0XCI6IFwidXJpLXJlZmVyZW5jZVwiXG4gICAgfSxcbiAgICBcIiRjb21tZW50XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcInRpdGxlXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcImRlc2NyaXB0aW9uXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiXG4gICAgfSxcbiAgICBcImRlZmF1bHRcIjogdHJ1ZSxcbiAgICBcInJlYWRPbmx5XCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJleGFtcGxlc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcIm11bHRpcGxlT2ZcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCIsXG4gICAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjogMFxuICAgIH0sXG4gICAgXCJtYXhpbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcImV4Y2x1c2l2ZU1heGltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwibWluaW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJleGNsdXNpdmVNaW5pbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcIm1heExlbmd0aFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5MZW5ndGhcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIn0sXG4gICAgXCJwYXR0ZXJuXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJyZWdleFwiXG4gICAgfSxcbiAgICBcImFkZGl0aW9uYWxJdGVtc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcIml0ZW1zXCI6IHtcbiAgICAgIFwiYW55T2ZcIjogW3tcIiRyZWZcIjogXCIjXCJ9LCB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifV0sXG4gICAgICBcImRlZmF1bHRcIjogdHJ1ZVxuICAgIH0sXG4gICAgXCJtYXhJdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5JdGVtc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInVuaXF1ZUl0ZW1zXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImJvb2xlYW5cIixcbiAgICAgIFwiZGVmYXVsdFwiOiBmYWxzZVxuICAgIH0sXG4gICAgXCJjb250YWluc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcIm1heFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LFxuICAgIFwibWluUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInJlcXVpcmVkXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3N0cmluZ0FycmF5XCJ9LFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwicHJvcGVydGllc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwib2JqZWN0XCIsXG4gICAgICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgICAgXCJwcm9wZXJ0eU5hbWVzXCI6IHtcImZvcm1hdFwiOiBcInJlZ2V4XCJ9LFxuICAgICAgXCJkZWZhdWx0XCI6IHt9XG4gICAgfSxcbiAgICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1xuICAgICAgICBcImFueU9mXCI6IFt7XCIkcmVmXCI6IFwiI1wifSwge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIn1dXG4gICAgICB9XG4gICAgfSxcbiAgICBcInByb3BlcnR5TmFtZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJjb25zdFwiOiB0cnVlLFxuICAgIFwiZW51bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJpdGVtc1wiOiB0cnVlLFxuICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgXCJ1bmlxdWVJdGVtc1wiOiB0cnVlXG4gICAgfSxcbiAgICBcInR5cGVcIjoge1xuICAgICAgXCJhbnlPZlwiOiBbXG4gICAgICAgIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCJ9LFxuICAgICAgICB7XG4gICAgICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgICAgICBcIml0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NpbXBsZVR5cGVzXCJ9LFxuICAgICAgICAgIFwibWluSXRlbXNcIjogMSxcbiAgICAgICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH0sXG4gICAgXCJmb3JtYXRcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImNvbnRlbnRNZWRpYVR5cGVcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiaWZcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJ0aGVuXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiZWxzZVwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImFsbE9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwiYW55T2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJvbmVPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcIm5vdFwiOiB7XCIkcmVmXCI6IFwiI1wifVxuICB9LFxuICBcImRlZmF1bHRcIjogdHJ1ZVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWFPYmplY3R9IGZyb20gXCIuL3R5cGVzXCJcbmltcG9ydCBBanZDb3JlIGZyb20gXCIuL2NvcmVcIlxuaW1wb3J0IGRyYWZ0N1ZvY2FidWxhcmllcyBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZHJhZnQ3XCJcbmltcG9ydCBkaXNjcmltaW5hdG9yIGZyb20gXCIuL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yXCJcbmltcG9ydCAqIGFzIGRyYWZ0N01ldGFTY2hlbWEgZnJvbSBcIi4vcmVmcy9qc29uLXNjaGVtYS1kcmFmdC0wNy5qc29uXCJcblxuY29uc3QgTUVUQV9TVVBQT1JUX0RBVEEgPSBbXCIvcHJvcGVydGllc1wiXVxuXG5jb25zdCBNRVRBX1NDSEVNQV9JRCA9IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWFcIlxuXG5leHBvcnQgY2xhc3MgQWp2IGV4dGVuZHMgQWp2Q29yZSB7XG4gIF9hZGRWb2NhYnVsYXJpZXMoKTogdm9pZCB7XG4gICAgc3VwZXIuX2FkZFZvY2FidWxhcmllcygpXG4gICAgZHJhZnQ3Vm9jYWJ1bGFyaWVzLmZvckVhY2goKHYpID0+IHRoaXMuYWRkVm9jYWJ1bGFyeSh2KSlcbiAgICBpZiAodGhpcy5vcHRzLmRpc2NyaW1pbmF0b3IpIHRoaXMuYWRkS2V5d29yZChkaXNjcmltaW5hdG9yKVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhU2NoZW1hKCk6IHZvaWQge1xuICAgIHN1cGVyLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpXG4gICAgaWYgKCF0aGlzLm9wdHMubWV0YSkgcmV0dXJuXG4gICAgY29uc3QgbWV0YVNjaGVtYSA9IHRoaXMub3B0cy4kZGF0YVxuICAgICAgPyB0aGlzLiRkYXRhTWV0YVNjaGVtYShkcmFmdDdNZXRhU2NoZW1hLCBNRVRBX1NVUFBPUlRfREFUQSlcbiAgICAgIDogZHJhZnQ3TWV0YVNjaGVtYVxuICAgIHRoaXMuYWRkTWV0YVNjaGVtYShtZXRhU2NoZW1hLCBNRVRBX1NDSEVNQV9JRCwgZmFsc2UpXG4gICAgdGhpcy5yZWZzW1wiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9zY2hlbWFcIl0gPSBNRVRBX1NDSEVNQV9JRFxuICB9XG5cbiAgZGVmYXVsdE1ldGEoKTogc3RyaW5nIHwgQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gKHRoaXMub3B0cy5kZWZhdWx0TWV0YSA9XG4gICAgICBzdXBlci5kZWZhdWx0TWV0YSgpIHx8ICh0aGlzLmdldFNjaGVtYShNRVRBX1NDSEVNQV9JRCkgPyBNRVRBX1NDSEVNQV9JRCA6IHVuZGVmaW5lZCkpXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gQWp2XG5tb2R1bGUuZXhwb3J0cy5BanYgPSBBanZcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSlcblxuZXhwb3J0IGRlZmF1bHQgQWp2XG5cbmV4cG9ydCB7XG4gIEZvcm1hdCxcbiAgRm9ybWF0RGVmaW5pdGlvbixcbiAgQXN5bmNGb3JtYXREZWZpbml0aW9uLFxuICBLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBNYWNyb0tleXdvcmREZWZpbml0aW9uLFxuICBGdW5jS2V5d29yZERlZmluaXRpb24sXG4gIFZvY2FidWxhcnksXG4gIFNjaGVtYSxcbiAgU2NoZW1hT2JqZWN0LFxuICBBbnlTY2hlbWFPYmplY3QsXG4gIEFzeW5jU2NoZW1hLFxuICBBbnlTY2hlbWEsXG4gIFZhbGlkYXRlRnVuY3Rpb24sXG4gIEFzeW5jVmFsaWRhdGVGdW5jdGlvbixcbiAgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEVycm9yTm9QYXJhbXMsXG59IGZyb20gXCIuL3R5cGVzXCJcblxuZXhwb3J0IHtQbHVnaW4sIE9wdGlvbnMsIENvZGVPcHRpb25zLCBJbnN0YW5jZU9wdGlvbnMsIExvZ2dlciwgRXJyb3JzVGV4dE9wdGlvbnN9IGZyb20gXCIuL2NvcmVcIlxuZXhwb3J0IHtTY2hlbWFDeHQsIFNjaGVtYU9iakN4dH0gZnJvbSBcIi4vY29tcGlsZVwiXG5leHBvcnQge0tleXdvcmRDeHR9IGZyb20gXCIuL2NvbXBpbGUvdmFsaWRhdGVcIlxuZXhwb3J0IHtEZWZpbmVkRXJyb3J9IGZyb20gXCIuL3ZvY2FidWxhcmllcy9lcnJvcnNcIlxuZXhwb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vY29tcGlsZS9ydWxlc1wiXG5leHBvcnQge0pTT05TY2hlbWFUeXBlfSBmcm9tIFwiLi90eXBlcy9qc29uLXNjaGVtYVwiXG5leHBvcnQge18sIHN0ciwgc3RyaW5naWZ5LCBuaWwsIE5hbWUsIENvZGUsIENvZGVHZW4sIENvZGVHZW5PcHRpb25zfSBmcm9tIFwiLi9jb21waWxlL2NvZGVnZW5cIlxuZXhwb3J0IHtkZWZhdWx0IGFzIFZhbGlkYXRpb25FcnJvcn0gZnJvbSBcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCJcbmV4cG9ydCB7ZGVmYXVsdCBhcyBNaXNzaW5nUmVmRXJyb3J9IGZyb20gXCIuL2NvbXBpbGUvcmVmX2Vycm9yXCJcbiIsICJpbXBvcnQgdHlwZSB7Rm9ybWF0LCBGb3JtYXREZWZpbml0aW9ufSBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtGb3JtYXRWYWxpZGF0b3IsIEZvcm1hdENvbXBhcmV9IGZyb20gXCJhanYvZGlzdC90eXBlc1wiXG5cbmV4cG9ydCB0eXBlIEZvcm1hdE1vZGUgPSBcImZhc3RcIiB8IFwiZnVsbFwiXG5cbmV4cG9ydCB0eXBlIEZvcm1hdE5hbWUgPVxuICB8IFwiZGF0ZVwiXG4gIHwgXCJ0aW1lXCJcbiAgfCBcImRhdGUtdGltZVwiXG4gIHwgXCJpc28tdGltZVwiXG4gIHwgXCJpc28tZGF0ZS10aW1lXCJcbiAgfCBcImR1cmF0aW9uXCJcbiAgfCBcInVyaVwiXG4gIHwgXCJ1cmktcmVmZXJlbmNlXCJcbiAgfCBcInVyaS10ZW1wbGF0ZVwiXG4gIHwgXCJ1cmxcIlxuICB8IFwiZW1haWxcIlxuICB8IFwiaG9zdG5hbWVcIlxuICB8IFwiaXB2NFwiXG4gIHwgXCJpcHY2XCJcbiAgfCBcInJlZ2V4XCJcbiAgfCBcInV1aWRcIlxuICB8IFwianNvbi1wb2ludGVyXCJcbiAgfCBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIlxuICB8IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCJcbiAgfCBcImJ5dGVcIlxuICB8IFwiaW50MzJcIlxuICB8IFwiaW50NjRcIlxuICB8IFwiZmxvYXRcIlxuICB8IFwiZG91YmxlXCJcbiAgfCBcInBhc3N3b3JkXCJcbiAgfCBcImJpbmFyeVwiXG5cbmV4cG9ydCB0eXBlIERlZmluZWRGb3JtYXRzID0ge1xuICBba2V5IGluIEZvcm1hdE5hbWVdOiBGb3JtYXRcbn1cblxuZnVuY3Rpb24gZm10RGVmKFxuICB2YWxpZGF0ZTogUmVnRXhwIHwgRm9ybWF0VmFsaWRhdG9yPHN0cmluZz4sXG4gIGNvbXBhcmU6IEZvcm1hdENvbXBhcmU8c3RyaW5nPlxuKTogRm9ybWF0RGVmaW5pdGlvbjxzdHJpbmc+IHtcbiAgcmV0dXJuIHt2YWxpZGF0ZSwgY29tcGFyZX1cbn1cblxuZXhwb3J0IGNvbnN0IGZ1bGxGb3JtYXRzOiBEZWZpbmVkRm9ybWF0cyA9IHtcbiAgLy8gZGF0ZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICBkYXRlOiBmbXREZWYoZGF0ZSwgY29tcGFyZURhdGUpLFxuICAvLyBkYXRlLXRpbWU6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgdGltZTogZm10RGVmKGdldFRpbWUodHJ1ZSksIGNvbXBhcmVUaW1lKSxcbiAgXCJkYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKHRydWUpLCBjb21wYXJlRGF0ZVRpbWUpLFxuICBcImlzby10aW1lXCI6IGZtdERlZihnZXRUaW1lKCksIGNvbXBhcmVJc29UaW1lKSxcbiAgXCJpc28tZGF0ZS10aW1lXCI6IGZtdERlZihnZXREYXRlVGltZSgpLCBjb21wYXJlSXNvRGF0ZVRpbWUpLFxuICAvLyBkdXJhdGlvbjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQVxuICBkdXJhdGlvbjogL15QKD8hJCkoKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrUyk/KT98KFxcZCtXKT8pJC8sXG4gIHVyaSxcbiAgXCJ1cmktcmVmZXJlbmNlXCI6XG4gICAgL14oPzpbYS16XVthLXowLTkrXFwtLl0qOik/KD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqfFxcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/KD86XFw/KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaSxcbiAgLy8gdXJpLXRlbXBsYXRlOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjU3MFxuICBcInVyaS10ZW1wbGF0ZVwiOlxuICAgIC9eKD86KD86W15cXHgwMC1cXHgyMFwiJzw+JVxcXFxeYHt8fV18JVswLTlhLWZdezJ9KXxcXHtbKyMuLzs/Jj0sIUB8XT8oPzpbYS16MC05X118JVswLTlhLWZdezJ9KSsoPzo6WzEtOV1bMC05XXswLDN9fFxcKik/KD86LCg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8pKlxcfSkqJC9pLFxuICAvLyBGb3IgdGhlIHNvdXJjZTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZHBlcmluaS83MjkyOTRcbiAgLy8gRm9yIHRlc3QgY2FzZXM6IGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9kZW1vL3VybC1yZWdleFxuICB1cmw6IC9eKD86aHR0cHM/fGZ0cCk6XFwvXFwvKD86XFxTKyg/OjpcXFMqKT9AKT8oPzooPyEoPzoxMHwxMjcpKD86XFwuXFxkezEsM30pezN9KSg/ISg/OjE2OVxcLjI1NHwxOTJcXC4xNjgpKD86XFwuXFxkezEsM30pezJ9KSg/ITE3MlxcLig/OjFbNi05XXwyXFxkfDNbMC0xXSkoPzpcXC5cXGR7MSwzfSl7Mn0pKD86WzEtOV1cXGQ/fDFcXGRcXGR8MlswMV1cXGR8MjJbMC0zXSkoPzpcXC4oPzoxP1xcZHsxLDJ9fDJbMC00XVxcZHwyNVswLTVdKSl7Mn0oPzpcXC4oPzpbMS05XVxcZD98MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC00XSkpfCg/Oig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSg/OlxcLig/OlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSstKSpbYS16MC05XFx1ezAwYTF9LVxcdXtmZmZmfV0rKSooPzpcXC4oPzpbYS16XFx1ezAwYTF9LVxcdXtmZmZmfV17Mix9KSkpKD86OlxcZHsyLDV9KT8oPzpcXC9bXlxcc10qKT8kL2l1LFxuICBlbWFpbDpcbiAgICAvXlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSpAKD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pPyQvaSxcbiAgaG9zdG5hbWU6XG4gICAgL14oPz0uezEsMjUzfVxcLj8kKVthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86Wy0wLTlhLXpdezAsNjF9WzAtOWEtel0pPykqXFwuPyQvaSxcbiAgLy8gb3B0aW1pemVkIGh0dHBzOi8vd3d3LnNhZmFyaWJvb2tzb25saW5lLmNvbS9saWJyYXJ5L3ZpZXcvcmVndWxhci1leHByZXNzaW9ucy1jb29rYm9vay85NzgwNTk2ODAyODM3L2NoMDdzMTYuaHRtbFxuICBpcHY0OiAvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkkLyxcbiAgaXB2NjogL14oKChbMC05YS1mXXsxLDR9Oil7N30oWzAtOWEtZl17MSw0fXw6KSl8KChbMC05YS1mXXsxLDR9Oil7Nn0oOlswLTlhLWZdezEsNH18KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs1fSgoKDpbMC05YS1mXXsxLDR9KXsxLDJ9KXw6KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pfDopKXwoKFswLTlhLWZdezEsNH06KXs0fSgoKDpbMC05YS1mXXsxLDR9KXsxLDN9KXwoKDpbMC05YS1mXXsxLDR9KT86KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7M30oKCg6WzAtOWEtZl17MSw0fSl7MSw0fSl8KCg6WzAtOWEtZl17MSw0fSl7MCwyfTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXsyfSgoKDpbMC05YS1mXXsxLDR9KXsxLDV9KXwoKDpbMC05YS1mXXsxLDR9KXswLDN9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezF9KCgoOlswLTlhLWZdezEsNH0pezEsNn0pfCgoOlswLTlhLWZdezEsNH0pezAsNH06KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KDooKCg6WzAtOWEtZl17MSw0fSl7MSw3fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw1fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKSkkL2ksXG4gIHJlZ2V4LFxuICAvLyB1dWlkOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM0MTIyXG4gIHV1aWQ6IC9eKD86dXJuOnV1aWQ6KT9bMC05YS1mXXs4fS0oPzpbMC05YS1mXXs0fS0pezN9WzAtOWEtZl17MTJ9JC9pLFxuICAvLyBKU09OLXBvaW50ZXI6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2OTAxXG4gIC8vIHVyaSBmcmFnbWVudDogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjYXBwZW5kaXgtQVxuICBcImpzb24tcG9pbnRlclwiOiAvXig/OlxcLyg/Oltefi9dfH4wfH4xKSopKiQvLFxuICBcImpzb24tcG9pbnRlci11cmktZnJhZ21lbnRcIjogL14jKD86XFwvKD86W2EtejAtOV9cXC0uISQmJygpKissOzo9QF18JVswLTlhLWZdezJ9fH4wfH4xKSopKiQvaSxcbiAgLy8gcmVsYXRpdmUgSlNPTi1wb2ludGVyOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1sdWZmLXJlbGF0aXZlLWpzb24tcG9pbnRlci0wMFxuICBcInJlbGF0aXZlLWpzb24tcG9pbnRlclwiOiAvXig/OjB8WzEtOV1bMC05XSopKD86I3woPzpcXC8oPzpbXn4vXXx+MHx+MSkqKSopJC8sXG4gIC8vIHRoZSBmb2xsb3dpbmcgZm9ybWF0cyBhcmUgdXNlZCBieSB0aGUgb3BlbmFwaSBzcGVjaWZpY2F0aW9uOiBodHRwczovL3NwZWMub3BlbmFwaXMub3JnL29hcy92My4wLjAjZGF0YS10eXBlc1xuICAvLyBieXRlOiBodHRwczovL2dpdGh1Yi5jb20vbWlndWVsbW90YS9pcy1iYXNlNjRcbiAgYnl0ZSxcbiAgLy8gc2lnbmVkIDMyIGJpdCBpbnRlZ2VyXG4gIGludDMyOiB7dHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlSW50MzJ9LFxuICAvLyBzaWduZWQgNjQgYml0IGludGVnZXJcbiAgaW50NjQ6IHt0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQ2NH0sXG4gIC8vIEMtdHlwZSBmbG9hdFxuICBmbG9hdDoge3R5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlcn0sXG4gIC8vIEMtdHlwZSBkb3VibGVcbiAgZG91YmxlOiB7dHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyfSxcbiAgLy8gaGludCB0byB0aGUgVUkgdG8gaGlkZSBpbnB1dCBzdHJpbmdzXG4gIHBhc3N3b3JkOiB0cnVlLFxuICAvLyB1bmNoZWNrZWQgc3RyaW5nIHBheWxvYWRcbiAgYmluYXJ5OiB0cnVlLFxufVxuXG5leHBvcnQgY29uc3QgZmFzdEZvcm1hdHM6IERlZmluZWRGb3JtYXRzID0ge1xuICAuLi5mdWxsRm9ybWF0cyxcbiAgZGF0ZTogZm10RGVmKC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkJC8sIGNvbXBhcmVEYXRlKSxcbiAgdGltZTogZm10RGVmKFxuICAgIC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksXG4gICAgY29tcGFyZVRpbWVcbiAgKSxcbiAgXCJkYXRlLXRpbWVcIjogZm10RGVmKFxuICAgIC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkdCg/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pJC9pLFxuICAgIGNvbXBhcmVEYXRlVGltZVxuICApLFxuICBcImlzby10aW1lXCI6IGZtdERlZihcbiAgICAvXig/OlswLTJdXFxkOlswLTVdXFxkOlswLTVdXFxkfDIzOjU5OjYwKSg/OlxcLlxcZCspPyg/Onp8WystXVxcZFxcZCg/Ojo/XFxkXFxkKT8pPyQvaSxcbiAgICBjb21wYXJlSXNvVGltZVxuICApLFxuICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKFxuICAgIC9eXFxkXFxkXFxkXFxkLVswLTFdXFxkLVswLTNdXFxkW3RcXHNdKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLFxuICAgIGNvbXBhcmVJc29EYXRlVGltZVxuICApLFxuICAvLyB1cmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9tYWZpbnRvc2gvaXMtbXktanNvbi12YWxpZC9ibG9iL21hc3Rlci9mb3JtYXRzLmpzXG4gIHVyaTogL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKT9bXlxcc10qJC9pLFxuICBcInVyaS1yZWZlcmVuY2VcIjogL14oPzooPzpbYS16XVthLXowLTkrXFwtLl0qOik/XFwvP1xcLyk/KD86W15cXFxcXFxzI11bXlxccyNdKik/KD86I1teXFxcXFxcc10qKT8kL2ksXG4gIC8vIGVtYWlsIChzb3VyY2VzIGZyb20ganNlbiB2YWxpZGF0b3IpOlxuICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzIwMTMyMy91c2luZy1hLXJlZ3VsYXItZXhwcmVzc2lvbi10by12YWxpZGF0ZS1hbi1lbWFpbC1hZGRyZXNzI2Fuc3dlci04ODI5MzYzXG4gIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2Zvcm1zLmh0bWwjdmFsaWQtZS1tYWlsLWFkZHJlc3MgKHNlYXJjaCBmb3IgJ3dpbGZ1bCB2aW9sYXRpb24nKVxuICBlbWFpbDpcbiAgICAvXlthLXowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPyg/OlxcLlthLXowLTldKD86W2EtejAtOS1dezAsNjF9W2EtejAtOV0pPykqJC9pLFxufVxuXG5leHBvcnQgY29uc3QgZm9ybWF0TmFtZXMgPSBPYmplY3Qua2V5cyhmdWxsRm9ybWF0cykgYXMgRm9ybWF0TmFtZVtdXG5cbmZ1bmN0aW9uIGlzTGVhcFllYXIoeWVhcjogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I2FwcGVuZGl4LUNcbiAgcmV0dXJuIHllYXIgJSA0ID09PSAwICYmICh5ZWFyICUgMTAwICE9PSAwIHx8IHllYXIgJSA0MDAgPT09IDApXG59XG5cbmNvbnN0IERBVEUgPSAvXihcXGRcXGRcXGRcXGQpLShcXGRcXGQpLShcXGRcXGQpJC9cbmNvbnN0IERBWVMgPSBbMCwgMzEsIDI4LCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV1cblxuZnVuY3Rpb24gZGF0ZShzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAvLyBmdWxsLWRhdGUgZnJvbSBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIGNvbnN0IG1hdGNoZXM6IHN0cmluZ1tdIHwgbnVsbCA9IERBVEUuZXhlYyhzdHIpXG4gIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlXG4gIGNvbnN0IHllYXI6IG51bWJlciA9ICttYXRjaGVzWzFdXG4gIGNvbnN0IG1vbnRoOiBudW1iZXIgPSArbWF0Y2hlc1syXVxuICBjb25zdCBkYXk6IG51bWJlciA9ICttYXRjaGVzWzNdXG4gIHJldHVybiAoXG4gICAgbW9udGggPj0gMSAmJlxuICAgIG1vbnRoIDw9IDEyICYmXG4gICAgZGF5ID49IDEgJiZcbiAgICBkYXkgPD0gKG1vbnRoID09PSAyICYmIGlzTGVhcFllYXIoeWVhcikgPyAyOSA6IERBWVNbbW9udGhdKVxuICApXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlKGQxOiBzdHJpbmcsIGQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShkMSAmJiBkMikpIHJldHVybiB1bmRlZmluZWRcbiAgaWYgKGQxID4gZDIpIHJldHVybiAxXG4gIGlmIChkMSA8IGQyKSByZXR1cm4gLTFcbiAgcmV0dXJuIDBcbn1cblxuY29uc3QgVElNRSA9IC9eKFxcZFxcZCk6KFxcZFxcZCk6KFxcZFxcZCg/OlxcLlxcZCspPykoenwoWystXSkoXFxkXFxkKSg/Ojo/KFxcZFxcZCkpPyk/JC9pXG5cbmZ1bmN0aW9uIGdldFRpbWUoc3RyaWN0VGltZVpvbmU/OiBib29sZWFuKTogKHN0cjogc3RyaW5nKSA9PiBib29sZWFuIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHRpbWUoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICBjb25zdCBtYXRjaGVzOiBzdHJpbmdbXSB8IG51bGwgPSBUSU1FLmV4ZWMoc3RyKVxuICAgIGlmICghbWF0Y2hlcykgcmV0dXJuIGZhbHNlXG4gICAgY29uc3QgaHI6IG51bWJlciA9ICttYXRjaGVzWzFdXG4gICAgY29uc3QgbWluOiBudW1iZXIgPSArbWF0Y2hlc1syXVxuICAgIGNvbnN0IHNlYzogbnVtYmVyID0gK21hdGNoZXNbM11cbiAgICBjb25zdCB0ejogc3RyaW5nIHwgdW5kZWZpbmVkID0gbWF0Y2hlc1s0XVxuICAgIGNvbnN0IHR6U2lnbjogbnVtYmVyID0gbWF0Y2hlc1s1XSA9PT0gXCItXCIgPyAtMSA6IDFcbiAgICBjb25zdCB0ekg6IG51bWJlciA9ICsobWF0Y2hlc1s2XSB8fCAwKVxuICAgIGNvbnN0IHR6TTogbnVtYmVyID0gKyhtYXRjaGVzWzddIHx8IDApXG4gICAgaWYgKHR6SCA+IDIzIHx8IHR6TSA+IDU5IHx8IChzdHJpY3RUaW1lWm9uZSAmJiAhdHopKSByZXR1cm4gZmFsc2VcbiAgICBpZiAoaHIgPD0gMjMgJiYgbWluIDw9IDU5ICYmIHNlYyA8IDYwKSByZXR1cm4gdHJ1ZVxuICAgIC8vIGxlYXAgc2Vjb25kXG4gICAgY29uc3QgdXRjTWluID0gbWluIC0gdHpNICogdHpTaWduXG4gICAgY29uc3QgdXRjSHIgPSBociAtIHR6SCAqIHR6U2lnbiAtICh1dGNNaW4gPCAwID8gMSA6IDApXG4gICAgcmV0dXJuICh1dGNIciA9PT0gMjMgfHwgdXRjSHIgPT09IC0xKSAmJiAodXRjTWluID09PSA1OSB8fCB1dGNNaW4gPT09IC0xKSAmJiBzZWMgPCA2MVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUaW1lKHMxOiBzdHJpbmcsIHMyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShzMSAmJiBzMikpIHJldHVybiB1bmRlZmluZWRcbiAgY29uc3QgdDEgPSBuZXcgRGF0ZShcIjIwMjAtMDEtMDFUXCIgKyBzMSkudmFsdWVPZigpXG4gIGNvbnN0IHQyID0gbmV3IERhdGUoXCIyMDIwLTAxLTAxVFwiICsgczIpLnZhbHVlT2YoKVxuICBpZiAoISh0MSAmJiB0MikpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIHQxIC0gdDJcbn1cblxuZnVuY3Rpb24gY29tcGFyZUlzb1RpbWUodDE6IHN0cmluZywgdDI6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICghKHQxICYmIHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBhMSA9IFRJTUUuZXhlYyh0MSlcbiAgY29uc3QgYTIgPSBUSU1FLmV4ZWModDIpXG4gIGlmICghKGExICYmIGEyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICB0MSA9IGExWzFdICsgYTFbMl0gKyBhMVszXVxuICB0MiA9IGEyWzFdICsgYTJbMl0gKyBhMlszXVxuICBpZiAodDEgPiB0MikgcmV0dXJuIDFcbiAgaWYgKHQxIDwgdDIpIHJldHVybiAtMVxuICByZXR1cm4gMFxufVxuXG5jb25zdCBEQVRFX1RJTUVfU0VQQVJBVE9SID0gL3R8XFxzL2lcbmZ1bmN0aW9uIGdldERhdGVUaW1lKHN0cmljdFRpbWVab25lPzogYm9vbGVhbik6IChzdHI6IHN0cmluZykgPT4gYm9vbGVhbiB7XG4gIGNvbnN0IHRpbWUgPSBnZXRUaW1lKHN0cmljdFRpbWVab25lKVxuXG4gIHJldHVybiBmdW5jdGlvbiBkYXRlX3RpbWUoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAvLyBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gICAgY29uc3QgZGF0ZVRpbWU6IHN0cmluZ1tdID0gc3RyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpXG4gICAgcmV0dXJuIGRhdGVUaW1lLmxlbmd0aCA9PT0gMiAmJiBkYXRlKGRhdGVUaW1lWzBdKSAmJiB0aW1lKGRhdGVUaW1lWzFdKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVEYXRlVGltZShkdDE6IHN0cmluZywgZHQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShkdDEgJiYgZHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBkMSA9IG5ldyBEYXRlKGR0MSkudmFsdWVPZigpXG4gIGNvbnN0IGQyID0gbmV3IERhdGUoZHQyKS52YWx1ZU9mKClcbiAgaWYgKCEoZDEgJiYgZDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIHJldHVybiBkMSAtIGQyXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVJc29EYXRlVGltZShkdDE6IHN0cmluZywgZHQyOiBzdHJpbmcpOiBudW1iZXIgfCB1bmRlZmluZWQge1xuICBpZiAoIShkdDEgJiYgZHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCBbZDEsIHQxXSA9IGR0MS5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKVxuICBjb25zdCBbZDIsIHQyXSA9IGR0Mi5zcGxpdChEQVRFX1RJTUVfU0VQQVJBVE9SKVxuICBjb25zdCByZXMgPSBjb21wYXJlRGF0ZShkMSwgZDIpXG4gIGlmIChyZXMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHVuZGVmaW5lZFxuICByZXR1cm4gcmVzIHx8IGNvbXBhcmVUaW1lKHQxLCB0Milcbn1cblxuY29uc3QgTk9UX1VSSV9GUkFHTUVOVCA9IC9cXC98Oi9cbmNvbnN0IFVSSSA9XG4gIC9eKD86W2Etel1bYS16MC05K1xcLS5dKjopKD86XFwvP1xcLyg/Oig/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpdfCVbMC05YS1mXXsyfSkqQCk/KD86XFxbKD86KD86KD86KD86WzAtOWEtZl17MSw0fTopezZ9fDo6KD86WzAtOWEtZl17MSw0fTopezV9fCg/OlswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDF9WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7M318KD86KD86WzAtOWEtZl17MSw0fTopezAsMn1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXsyfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwzfVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fTp8KD86KD86WzAtOWEtZl17MSw0fTopezAsNH1bMC05YS1mXXsxLDR9KT86OikoPzpbMC05YS1mXXsxLDR9OlswLTlhLWZdezEsNH18KD86KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pKXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw1fVswLTlhLWZdezEsNH0pPzo6WzAtOWEtZl17MSw0fXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw2fVswLTlhLWZdezEsNH0pPzo6KXxbVnZdWzAtOWEtZl0rXFwuW2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol0rKVxcXXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPyl8KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9XXwlWzAtOWEtZl17Mn0pKikoPzo6XFxkKik/KD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkrKD86XFwvKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSopP3woPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKikoPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/KD86Iyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8kL2lcblxuZnVuY3Rpb24gdXJpKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIGh0dHA6Ly9qbXJ3YXJlLmNvbS9hcnRpY2xlcy8yMDA5L3VyaV9yZWdleHAvVVJJX3JlZ2V4Lmh0bWwgKyBvcHRpb25hbCBwcm90b2NvbCArIHJlcXVpcmVkIFwiLlwiXG4gIHJldHVybiBOT1RfVVJJX0ZSQUdNRU5ULnRlc3Qoc3RyKSAmJiBVUkkudGVzdChzdHIpXG59XG5cbmNvbnN0IEJZVEUgPSAvXig/OltBLVphLXowLTkrL117NH0pKig/OltBLVphLXowLTkrL117Mn09PXxbQS1aYS16MC05Ky9dezN9PSk/JC9nbVxuXG5mdW5jdGlvbiBieXRlKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIEJZVEUubGFzdEluZGV4ID0gMFxuICByZXR1cm4gQllURS50ZXN0KHN0cilcbn1cblxuY29uc3QgTUlOX0lOVDMyID0gLSgyICoqIDMxKVxuY29uc3QgTUFYX0lOVDMyID0gMiAqKiAzMSAtIDFcblxuZnVuY3Rpb24gdmFsaWRhdGVJbnQzMih2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKSAmJiB2YWx1ZSA8PSBNQVhfSU5UMzIgJiYgdmFsdWUgPj0gTUlOX0lOVDMyXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlSW50NjQodmFsdWU6IG51bWJlcik6IGJvb2xlYW4ge1xuICAvLyBKU09OIGFuZCBqYXZhc2NyaXB0IG1heCBJbnQgaXMgMioqNTMsIHNvIGFueSBpbnQgdGhhdCBwYXNzZXMgaXNJbnRlZ2VyIGlzIHZhbGlkIGZvciBJbnQ2NFxuICByZXR1cm4gTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSlcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIoKTogYm9vbGVhbiB7XG4gIHJldHVybiB0cnVlXG59XG5cbmNvbnN0IFpfQU5DSE9SID0gL1teXFxcXF1cXFxcWi9cbmZ1bmN0aW9uIHJlZ2V4KHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGlmIChaX0FOQ0hPUi50ZXN0KHN0cikpIHJldHVybiBmYWxzZVxuICB0cnkge1xuICAgIG5ldyBSZWdFeHAoc3RyKVxuICAgIHJldHVybiB0cnVlXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIEFqdiBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtcbiAgUGx1Z2luLFxuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIENvZGUsXG4gIE5hbWUsXG4gIEVycm9yT2JqZWN0LFxufSBmcm9tIFwiYWp2XCJcbmltcG9ydCB0eXBlIHtBZGRlZEZvcm1hdH0gZnJvbSBcImFqdi9kaXN0L3R5cGVzXCJcbmltcG9ydCB0eXBlIHtSdWxlfSBmcm9tIFwiYWp2L2Rpc3QvY29tcGlsZS9ydWxlc1wiXG5pbXBvcnQge0tleXdvcmRDeHR9IGZyb20gXCJhanZcIlxuaW1wb3J0IHtfLCBzdHIsIG9yLCBnZXRQcm9wZXJ0eSwgb3BlcmF0b3JzfSBmcm9tIFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCJcblxudHlwZSBLd2QgPSBcImZvcm1hdE1heGltdW1cIiB8IFwiZm9ybWF0TWluaW11bVwiIHwgXCJmb3JtYXRFeGNsdXNpdmVNYXhpbXVtXCIgfCBcImZvcm1hdEV4Y2x1c2l2ZU1pbmltdW1cIlxuXG50eXBlIENvbXBhcmlzb24gPSBcIjw9XCIgfCBcIj49XCIgfCBcIjxcIiB8IFwiPlwiXG5cbmNvbnN0IG9wcyA9IG9wZXJhdG9yc1xuXG5jb25zdCBLV0RzOiB7W0sgaW4gS3dkXToge29rU3RyOiBDb21wYXJpc29uOyBvazogQ29kZTsgZmFpbDogQ29kZX19ID0ge1xuICBmb3JtYXRNYXhpbXVtOiB7b2tTdHI6IFwiPD1cIiwgb2s6IG9wcy5MVEUsIGZhaWw6IG9wcy5HVH0sXG4gIGZvcm1hdE1pbmltdW06IHtva1N0cjogXCI+PVwiLCBvazogb3BzLkdURSwgZmFpbDogb3BzLkxUfSxcbiAgZm9ybWF0RXhjbHVzaXZlTWF4aW11bToge29rU3RyOiBcIjxcIiwgb2s6IG9wcy5MVCwgZmFpbDogb3BzLkdURX0sXG4gIGZvcm1hdEV4Y2x1c2l2ZU1pbmltdW06IHtva1N0cjogXCI+XCIsIG9rOiBvcHMuR1QsIGZhaWw6IG9wcy5MVEV9LFxufVxuXG5leHBvcnQgdHlwZSBMaW1pdEZvcm1hdEVycm9yID0gRXJyb3JPYmplY3Q8S3dkLCB7bGltaXQ6IHN0cmluZzsgY29tcGFyaXNvbjogQ29tcGFyaXNvbn0+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSA9PiBzdHJgc2hvdWxkIGJlICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0ub2tTdHJ9ICR7c2NoZW1hQ29kZX1gLFxuICBwYXJhbXM6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+XG4gICAgX2B7Y29tcGFyaXNvbjogJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5va1N0cn0sIGxpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmV4cG9ydCBjb25zdCBmb3JtYXRMaW1pdERlZmluaXRpb246IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogT2JqZWN0LmtleXMoS1dEcyksXG4gIHR5cGU6IFwic3RyaW5nXCIsXG4gIHNjaGVtYVR5cGU6IFwic3RyaW5nXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWFDb2RlLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b3B0cywgc2VsZn0gPSBpdFxuICAgIGlmICghb3B0cy52YWxpZGF0ZUZvcm1hdHMpIHJldHVyblxuXG4gICAgY29uc3QgZkN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCAoc2VsZi5SVUxFUy5hbGwuZm9ybWF0IGFzIFJ1bGUpLmRlZmluaXRpb24sIFwiZm9ybWF0XCIpXG4gICAgaWYgKGZDeHQuJGRhdGEpIHZhbGlkYXRlJERhdGFGb3JtYXQoKVxuICAgIGVsc2UgdmFsaWRhdGVGb3JtYXQoKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUkRGF0YUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZtdHMgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICByZWY6IHNlbGYuZm9ybWF0cyxcbiAgICAgICAgY29kZTogb3B0cy5jb2RlLmZvcm1hdHMsXG4gICAgICB9KVxuICAgICAgY29uc3QgZm10ID0gZ2VuLmNvbnN0KFwiZm10XCIsIF9gJHtmbXRzfVske2ZDeHQuc2NoZW1hQ29kZX1dYClcbiAgICAgIGN4dC5mYWlsJGRhdGEoXG4gICAgICAgIG9yKFxuICAgICAgICAgIF9gdHlwZW9mICR7Zm10fSAhPSBcIm9iamVjdFwiYCxcbiAgICAgICAgICBfYCR7Zm10fSBpbnN0YW5jZW9mIFJlZ0V4cGAsXG4gICAgICAgICAgX2B0eXBlb2YgJHtmbXR9LmNvbXBhcmUgIT0gXCJmdW5jdGlvblwiYCxcbiAgICAgICAgICBjb21wYXJlQ29kZShmbXQpXG4gICAgICAgIClcbiAgICAgIClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdCgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGZDeHQuc2NoZW1hIGFzIHN0cmluZ1xuICAgICAgY29uc3QgZm10RGVmOiBBZGRlZEZvcm1hdCB8IHVuZGVmaW5lZCA9IHNlbGYuZm9ybWF0c1tmb3JtYXRdXG4gICAgICBpZiAoIWZtdERlZiB8fCBmbXREZWYgPT09IHRydWUpIHJldHVyblxuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgZm10RGVmICE9IFwib2JqZWN0XCIgfHxcbiAgICAgICAgZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwIHx8XG4gICAgICAgIHR5cGVvZiBmbXREZWYuY29tcGFyZSAhPSBcImZ1bmN0aW9uXCJcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHtrZXl3b3JkfVwiOiBmb3JtYXQgXCIke2Zvcm1hdH1cIiBkb2VzIG5vdCBkZWZpbmUgXCJjb21wYXJlXCIgZnVuY3Rpb25gKVxuICAgICAgfVxuICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtcbiAgICAgICAga2V5OiBmb3JtYXQsXG4gICAgICAgIHJlZjogZm10RGVmLFxuICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyA/IF9gJHtvcHRzLmNvZGUuZm9ybWF0c30ke2dldFByb3BlcnR5KGZvcm1hdCl9YCA6IHVuZGVmaW5lZCxcbiAgICAgIH0pXG5cbiAgICAgIGN4dC5mYWlsJGRhdGEoY29tcGFyZUNvZGUoZm10KSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjb21wYXJlQ29kZShmbXQ6IE5hbWUpOiBDb2RlIHtcbiAgICAgIHJldHVybiBfYCR7Zm10fS5jb21wYXJlKCR7ZGF0YX0sICR7c2NoZW1hQ29kZX0pICR7S1dEc1trZXl3b3JkIGFzIEt3ZF0uZmFpbH0gMGBcbiAgICB9XG4gIH0sXG4gIGRlcGVuZGVuY2llczogW1wiZm9ybWF0XCJdLFxufVxuXG5jb25zdCBmb3JtYXRMaW1pdFBsdWdpbjogUGx1Z2luPHVuZGVmaW5lZD4gPSAoYWp2OiBBanYpOiBBanYgPT4ge1xuICBhanYuYWRkS2V5d29yZChmb3JtYXRMaW1pdERlZmluaXRpb24pXG4gIHJldHVybiBhanZcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0TGltaXRQbHVnaW5cbiIsICJpbXBvcnQge1xuICBEZWZpbmVkRm9ybWF0cyxcbiAgRm9ybWF0TW9kZSxcbiAgRm9ybWF0TmFtZSxcbiAgZm9ybWF0TmFtZXMsXG4gIGZhc3RGb3JtYXRzLFxuICBmdWxsRm9ybWF0cyxcbn0gZnJvbSBcIi4vZm9ybWF0c1wiXG5pbXBvcnQgZm9ybWF0TGltaXQgZnJvbSBcIi4vbGltaXRcIlxuaW1wb3J0IHR5cGUgQWp2IGZyb20gXCJhanZcIlxuaW1wb3J0IHR5cGUge1BsdWdpbiwgRm9ybWF0fSBmcm9tIFwiYWp2XCJcbmltcG9ydCB7XywgTmFtZX0gZnJvbSBcImFqdi9kaXN0L2NvbXBpbGUvY29kZWdlblwiXG5cbmV4cG9ydCB7Rm9ybWF0TW9kZSwgRm9ybWF0TmFtZX0gZnJvbSBcIi4vZm9ybWF0c1wiXG5leHBvcnQge0xpbWl0Rm9ybWF0RXJyb3J9IGZyb20gXCIuL2xpbWl0XCJcbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0T3B0aW9ucyB7XG4gIG1vZGU/OiBGb3JtYXRNb2RlXG4gIGZvcm1hdHM/OiBGb3JtYXROYW1lW11cbiAga2V5d29yZHM/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIEZvcm1hdHNQbHVnaW5PcHRpb25zID0gRm9ybWF0TmFtZVtdIHwgRm9ybWF0T3B0aW9uc1xuXG5leHBvcnQgaW50ZXJmYWNlIEZvcm1hdHNQbHVnaW4gZXh0ZW5kcyBQbHVnaW48Rm9ybWF0c1BsdWdpbk9wdGlvbnM+IHtcbiAgZ2V0OiAoZm9ybWF0OiBGb3JtYXROYW1lLCBtb2RlPzogRm9ybWF0TW9kZSkgPT4gRm9ybWF0XG59XG5cbmNvbnN0IGZ1bGxOYW1lID0gbmV3IE5hbWUoXCJmdWxsRm9ybWF0c1wiKVxuY29uc3QgZmFzdE5hbWUgPSBuZXcgTmFtZShcImZhc3RGb3JtYXRzXCIpXG5cbmNvbnN0IGZvcm1hdHNQbHVnaW46IEZvcm1hdHNQbHVnaW4gPSAoXG4gIGFqdjogQWp2LFxuICBvcHRzOiBGb3JtYXRzUGx1Z2luT3B0aW9ucyA9IHtrZXl3b3JkczogdHJ1ZX1cbik6IEFqdiA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHMpKSB7XG4gICAgYWRkRm9ybWF0cyhhanYsIG9wdHMsIGZ1bGxGb3JtYXRzLCBmdWxsTmFtZSlcbiAgICByZXR1cm4gYWp2XG4gIH1cbiAgY29uc3QgW2Zvcm1hdHMsIGV4cG9ydE5hbWVdID1cbiAgICBvcHRzLm1vZGUgPT09IFwiZmFzdFwiID8gW2Zhc3RGb3JtYXRzLCBmYXN0TmFtZV0gOiBbZnVsbEZvcm1hdHMsIGZ1bGxOYW1lXVxuICBjb25zdCBsaXN0ID0gb3B0cy5mb3JtYXRzIHx8IGZvcm1hdE5hbWVzXG4gIGFkZEZvcm1hdHMoYWp2LCBsaXN0LCBmb3JtYXRzLCBleHBvcnROYW1lKVxuICBpZiAob3B0cy5rZXl3b3JkcykgZm9ybWF0TGltaXQoYWp2KVxuICByZXR1cm4gYWp2XG59XG5cbmZvcm1hdHNQbHVnaW4uZ2V0ID0gKG5hbWU6IEZvcm1hdE5hbWUsIG1vZGU6IEZvcm1hdE1vZGUgPSBcImZ1bGxcIik6IEZvcm1hdCA9PiB7XG4gIGNvbnN0IGZvcm1hdHMgPSBtb2RlID09PSBcImZhc3RcIiA/IGZhc3RGb3JtYXRzIDogZnVsbEZvcm1hdHNcbiAgY29uc3QgZiA9IGZvcm1hdHNbbmFtZV1cbiAgaWYgKCFmKSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZm9ybWF0IFwiJHtuYW1lfVwiYClcbiAgcmV0dXJuIGZcbn1cblxuZnVuY3Rpb24gYWRkRm9ybWF0cyhhanY6IEFqdiwgbGlzdDogRm9ybWF0TmFtZVtdLCBmczogRGVmaW5lZEZvcm1hdHMsIGV4cG9ydE5hbWU6IE5hbWUpOiB2b2lkIHtcbiAgYWp2Lm9wdHMuY29kZS5mb3JtYXRzID8/PSBfYHJlcXVpcmUoXCJhanYtZm9ybWF0cy9kaXN0L2Zvcm1hdHNcIikuJHtleHBvcnROYW1lfWBcbiAgZm9yIChjb25zdCBmIG9mIGxpc3QpIGFqdi5hZGRGb3JtYXQoZiwgZnNbZl0pXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZvcm1hdHNQbHVnaW5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge3ZhbHVlOiB0cnVlfSlcblxuZXhwb3J0IGRlZmF1bHQgZm9ybWF0c1BsdWdpblxuIiwgImV4cG9ydCB2YXIgdXRpbDtcbihmdW5jdGlvbiAodXRpbCkge1xuICAgIHV0aWwuYXNzZXJ0RXF1YWwgPSAoXykgPT4geyB9O1xuICAgIGZ1bmN0aW9uIGFzc2VydElzKF9hcmcpIHsgfVxuICAgIHV0aWwuYXNzZXJ0SXMgPSBhc3NlcnRJcztcbiAgICBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICB9XG4gICAgdXRpbC5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xuICAgIHV0aWwuYXJyYXlUb0VudW0gPSAoaXRlbXMpID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgb2JqW2l0ZW1dID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gICAgdXRpbC5nZXRWYWxpZEVudW1WYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbGlkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhvYmopLmZpbHRlcigoaykgPT4gdHlwZW9mIG9ialtvYmpba11dICE9PSBcIm51bWJlclwiKTtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIHZhbGlkS2V5cykge1xuICAgICAgICAgICAgZmlsdGVyZWRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHV0aWwub2JqZWN0VmFsdWVzKGZpbHRlcmVkKTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0VmFsdWVzID0gKG9iaikgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RLZXlzKG9iaikubWFwKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqW2VdO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHV0aWwub2JqZWN0S2V5cyA9IHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gXCJmdW5jdGlvblwiIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA/IChvYmopID0+IE9iamVjdC5rZXlzKG9iaikgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKG9iamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGtleXM7XG4gICAgICAgIH07XG4gICAgdXRpbC5maW5kID0gKGFyciwgY2hlY2tlcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgYXJyKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlcihpdGVtKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdXRpbC5pc0ludGVnZXIgPSB0eXBlb2YgTnVtYmVyLmlzSW50ZWdlciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gKHZhbCkgPT4gTnVtYmVyLmlzSW50ZWdlcih2YWwpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgYmFuL2JhblxuICAgICAgICA6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09IFwibnVtYmVyXCIgJiYgTnVtYmVyLmlzRmluaXRlKHZhbCkgJiYgTWF0aC5mbG9vcih2YWwpID09PSB2YWw7XG4gICAgZnVuY3Rpb24gam9pblZhbHVlcyhhcnJheSwgc2VwYXJhdG9yID0gXCIgfCBcIikge1xuICAgICAgICByZXR1cm4gYXJyYXkubWFwKCh2YWwpID0+ICh0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiID8gYCcke3ZhbH0nYCA6IHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9XG4gICAgdXRpbC5qb2luVmFsdWVzID0gam9pblZhbHVlcztcbiAgICB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciA9IChfLCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbn0pKHV0aWwgfHwgKHV0aWwgPSB7fSkpO1xuZXhwb3J0IHZhciBvYmplY3RVdGlsO1xuKGZ1bmN0aW9uIChvYmplY3RVdGlsKSB7XG4gICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyA9IChmaXJzdCwgc2Vjb25kKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5maXJzdCxcbiAgICAgICAgICAgIC4uLnNlY29uZCwgLy8gc2Vjb25kIG92ZXJ3cml0ZXMgZmlyc3RcbiAgICAgICAgfTtcbiAgICB9O1xufSkob2JqZWN0VXRpbCB8fCAob2JqZWN0VXRpbCA9IHt9KSk7XG5leHBvcnQgY29uc3QgWm9kUGFyc2VkVHlwZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwic3RyaW5nXCIsXG4gICAgXCJuYW5cIixcbiAgICBcIm51bWJlclwiLFxuICAgIFwiaW50ZWdlclwiLFxuICAgIFwiZmxvYXRcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcImRhdGVcIixcbiAgICBcImJpZ2ludFwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJmdW5jdGlvblwiLFxuICAgIFwidW5kZWZpbmVkXCIsXG4gICAgXCJudWxsXCIsXG4gICAgXCJhcnJheVwiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJ1bmtub3duXCIsXG4gICAgXCJwcm9taXNlXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwibWFwXCIsXG4gICAgXCJzZXRcIixcbl0pO1xuZXhwb3J0IGNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zdHJpbmc7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBab2RQYXJzZWRUeXBlLm5hbiA6IFpvZFBhcnNlZFR5cGUubnVtYmVyO1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYm9vbGVhbjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5mdW5jdGlvbjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYmlnaW50O1xuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zeW1ib2w7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUuYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS50aGVuICYmIHR5cGVvZiBkYXRhLnRoZW4gPT09IFwiZnVuY3Rpb25cIiAmJiBkYXRhLmNhdGNoICYmIHR5cGVvZiBkYXRhLmNhdGNoID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLm1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5zZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIERhdGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5kYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUub2JqZWN0O1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUudW5rbm93bjtcbiAgICB9XG59O1xuIiwgImltcG9ydCB7IHV0aWwgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCBab2RJc3N1ZUNvZGUgPSB1dGlsLmFycmF5VG9FbnVtKFtcbiAgICBcImludmFsaWRfdHlwZVwiLFxuICAgIFwiaW52YWxpZF9saXRlcmFsXCIsXG4gICAgXCJjdXN0b21cIixcbiAgICBcImludmFsaWRfdW5pb25cIixcbiAgICBcImludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvclwiLFxuICAgIFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIsXG4gICAgXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIFwiaW52YWxpZF9hcmd1bWVudHNcIixcbiAgICBcImludmFsaWRfcmV0dXJuX3R5cGVcIixcbiAgICBcImludmFsaWRfZGF0ZVwiLFxuICAgIFwiaW52YWxpZF9zdHJpbmdcIixcbiAgICBcInRvb19zbWFsbFwiLFxuICAgIFwidG9vX2JpZ1wiLFxuICAgIFwiaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXNcIixcbiAgICBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgIFwibm90X2Zpbml0ZVwiLFxuXSk7XG5leHBvcnQgY29uc3QgcXVvdGVsZXNzSnNvbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5zdHJpbmdpZnkob2JqLCBudWxsLCAyKTtcbiAgICByZXR1cm4ganNvbi5yZXBsYWNlKC9cIihbXlwiXSspXCI6L2csIFwiJDE6XCIpO1xufTtcbmV4cG9ydCBjbGFzcyBab2RFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc3N1ZXM7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlzc3Vlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IFtdO1xuICAgICAgICB0aGlzLmFkZElzc3VlID0gKHN1YikgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIHN1Yl07XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkSXNzdWVzID0gKHN1YnMgPSBbXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5pc3N1ZXMgPSBbLi4udGhpcy5pc3N1ZXMsIC4uLnN1YnNdO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBhY3R1YWxQcm90byA9IG5ldy50YXJnZXQucHJvdG90eXBlO1xuICAgICAgICBpZiAoT2JqZWN0LnNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHRoaXMsIGFjdHVhbFByb3RvKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX19wcm90b19fID0gYWN0dWFsUHJvdG87XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgICAgICB0aGlzLmlzc3VlcyA9IGlzc3VlcztcbiAgICB9XG4gICAgZm9ybWF0KF9tYXBwZXIpIHtcbiAgICAgICAgY29uc3QgbWFwcGVyID0gX21hcHBlciB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGlzc3VlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzc3VlLm1lc3NhZ2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfdW5pb25cIikge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZS51bmlvbkVycm9ycy5tYXAocHJvY2Vzc0Vycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3JldHVybl90eXBlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKGlzc3VlLnJldHVyblR5cGVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9hcmd1bWVudHNcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUuYXJndW1lbnRzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5wYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgaXNzdWUucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH0gZWxzZSBpZiAodHlwZW9mIGVsID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjb25zdCBlcnJvckFycmF5OiBhbnkgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGVycm9yQXJyYXkuX2Vycm9ycyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCBlcnJvckFycmF5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2Vzc0Vycm9yKHRoaXMpO1xuICAgICAgICByZXR1cm4gZmllbGRFcnJvcnM7XG4gICAgfVxuICAgIHN0YXRpYyBhc3NlcnQodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBab2RFcnJvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm90IGEgWm9kRXJyb3I6ICR7dmFsdWV9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lc3NhZ2U7XG4gICAgfVxuICAgIGdldCBtZXNzYWdlKCkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGZsYXR0ZW4obWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgY29uc3QgZm9ybUVycm9ycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHN1YiBvZiB0aGlzLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdEVsID0gc3ViLnBhdGhbMF07XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnNbZmlyc3RFbF0gPSBmaWVsZEVycm9yc1tmaXJzdEVsXSB8fCBbXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbiAgICB9XG4gICAgZ2V0IGZvcm1FcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZsYXR0ZW4oKTtcbiAgICB9XG59XG5ab2RFcnJvci5jcmVhdGUgPSAoaXNzdWVzKSA9PiB7XG4gICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoaXNzdWVzKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuIiwgImltcG9ydCB7IFpvZElzc3VlQ29kZSB9IGZyb20gXCIuLi9ab2RFcnJvci5qc1wiO1xuaW1wb3J0IHsgdXRpbCwgWm9kUGFyc2VkVHlwZSB9IGZyb20gXCIuLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNvbnN0IGVycm9yTWFwID0gKGlzc3VlLCBfY3R4KSA9PiB7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgc3dpdGNoIChpc3N1ZS5jb2RlKSB7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZTpcbiAgICAgICAgICAgIGlmIChpc3N1ZS5yZWNlaXZlZCA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJSZXF1aXJlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBFeHBlY3RlZCAke2lzc3VlLmV4cGVjdGVkfSwgcmVjZWl2ZWQgJHtpc3N1ZS5yZWNlaXZlZH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbDpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBsaXRlcmFsIHZhbHVlLCBleHBlY3RlZCAke0pTT04uc3RyaW5naWZ5KGlzc3VlLmV4cGVjdGVkLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlcil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgVW5yZWNvZ25pemVkIGtleShzKSBpbiBvYmplY3Q6ICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLmtleXMsIFwiLCBcIil9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3I6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZW51bSB2YWx1ZS4gRXhwZWN0ZWQgJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUub3B0aW9ucyl9LCByZWNlaXZlZCAnJHtpc3N1ZS5yZWNlaXZlZH0nYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2FyZ3VtZW50czpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiBhcmd1bWVudHNgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgZnVuY3Rpb24gcmV0dXJuIHR5cGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZGF0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkYXRlYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZzpcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChcImluY2x1ZGVzXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgaW5jbHVkZSBcIiR7aXNzdWUudmFsaWRhdGlvbi5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUudmFsaWRhdGlvbi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGAke21lc3NhZ2V9IGF0IG9uZSBvciBtb3JlIHBvc2l0aW9ucyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHtpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9ufWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJzdGFydHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3Qgc3RhcnQgd2l0aCBcIiR7aXNzdWUudmFsaWRhdGlvbi5zdGFydHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoXCJlbmRzV2l0aFwiIGluIGlzc3VlLnZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0OiBtdXN0IGVuZCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmVuZHNXaXRofVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoaXNzdWUudmFsaWRhdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudmFsaWRhdGlvbiAhPT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkICR7aXNzdWUudmFsaWRhdGlvbn1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19zbWFsbDpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBtb3JlIHRoYW5gfSAke2lzc3VlLm1pbmltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IFwiZXhhY3RseVwiIDogaXNzdWUuaW5jbHVzaXZlID8gYGF0IGxlYXN0YCA6IGBvdmVyYH0gJHtpc3N1ZS5taW5pbXVtfSBjaGFyYWN0ZXIocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseSBlcXVhbCB0byBgIDogaXNzdWUuaW5jbHVzaXZlID8gYGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgIDogYGdyZWF0ZXIgdGhhbiBgfSR7aXNzdWUubWluaW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtuZXcgRGF0ZShOdW1iZXIoaXNzdWUubWluaW11bSkpfWA7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnRvb19iaWc6XG4gICAgICAgICAgICBpZiAoaXNzdWUudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQXJyYXkgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfSBlbGVtZW50KHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBTdHJpbmcgbXVzdCBjb250YWluICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbW9zdGAgOiBgdW5kZXJgfSAke2lzc3VlLm1heGltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEJpZ0ludCBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgbGVzcyB0aGFuIG9yIGVxdWFsIHRvYCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19YDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwiZGF0ZVwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgRGF0ZSBtdXN0IGJlICR7aXNzdWUuZXhhY3QgPyBgZXhhY3RseWAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgc21hbGxlciB0aGFuIG9yIGVxdWFsIHRvYCA6IGBzbWFsbGVyIHRoYW5gfSAke25ldyBEYXRlKE51bWJlcihpc3N1ZS5tYXhpbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuY3VzdG9tOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlczpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW50ZXJzZWN0aW9uIHJlc3VsdHMgY291bGQgbm90IGJlIG1lcmdlZGA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUubXVsdGlwbGVPZn1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLm5vdF9maW5pdGU6XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJOdW1iZXIgbXVzdCBiZSBmaW5pdGVcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbWVzc2FnZSA9IF9jdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7IG1lc3NhZ2UgfTtcbn07XG5leHBvcnQgZGVmYXVsdCBlcnJvck1hcDtcbiIsICJpbXBvcnQgZGVmYXVsdEVycm9yTWFwIGZyb20gXCIuL2xvY2FsZXMvZW4uanNcIjtcbmxldCBvdmVycmlkZUVycm9yTWFwID0gZGVmYXVsdEVycm9yTWFwO1xuZXhwb3J0IHsgZGVmYXVsdEVycm9yTWFwIH07XG5leHBvcnQgZnVuY3Rpb24gc2V0RXJyb3JNYXAobWFwKSB7XG4gICAgb3ZlcnJpZGVFcnJvck1hcCA9IG1hcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFcnJvck1hcCgpIHtcbiAgICByZXR1cm4gb3ZlcnJpZGVFcnJvck1hcDtcbn1cbiIsICJpbXBvcnQgeyBnZXRFcnJvck1hcCB9IGZyb20gXCIuLi9lcnJvcnMuanNcIjtcbmltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4uL2xvY2FsZXMvZW4uanNcIjtcbmV4cG9ydCBjb25zdCBtYWtlSXNzdWUgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgeyBkYXRhLCBwYXRoLCBlcnJvck1hcHMsIGlzc3VlRGF0YSB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGZ1bGxQYXRoID0gWy4uLnBhdGgsIC4uLihpc3N1ZURhdGEucGF0aCB8fCBbXSldO1xuICAgIGNvbnN0IGZ1bGxJc3N1ZSA9IHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICB9O1xuICAgIGlmIChpc3N1ZURhdGEubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzc3VlRGF0YS5tZXNzYWdlLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBsZXQgZXJyb3JNZXNzYWdlID0gXCJcIjtcbiAgICBjb25zdCBtYXBzID0gZXJyb3JNYXBzXG4gICAgICAgIC5maWx0ZXIoKG0pID0+ICEhbSlcbiAgICAgICAgLnNsaWNlKClcbiAgICAgICAgLnJldmVyc2UoKTtcbiAgICBmb3IgKGNvbnN0IG1hcCBvZiBtYXBzKSB7XG4gICAgICAgIGVycm9yTWVzc2FnZSA9IG1hcChmdWxsSXNzdWUsIHsgZGF0YSwgZGVmYXVsdEVycm9yOiBlcnJvck1lc3NhZ2UgfSkubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uaXNzdWVEYXRhLFxuICAgICAgICBwYXRoOiBmdWxsUGF0aCxcbiAgICAgICAgbWVzc2FnZTogZXJyb3JNZXNzYWdlLFxuICAgIH07XG59O1xuZXhwb3J0IGNvbnN0IEVNUFRZX1BBVEggPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGlzc3VlRGF0YSkge1xuICAgIGNvbnN0IG92ZXJyaWRlTWFwID0gZ2V0RXJyb3JNYXAoKTtcbiAgICBjb25zdCBpc3N1ZSA9IG1ha2VJc3N1ZSh7XG4gICAgICAgIGlzc3VlRGF0YTogaXNzdWVEYXRhLFxuICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgIGVycm9yTWFwczogW1xuICAgICAgICAgICAgY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIC8vIGNvbnRleHR1YWwgZXJyb3IgbWFwIGlzIGZpcnN0IHByaW9yaXR5XG4gICAgICAgICAgICBjdHguc2NoZW1hRXJyb3JNYXAsIC8vIHRoZW4gc2NoZW1hLWJvdW5kIG1hcCBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwLCAvLyB0aGVuIGdsb2JhbCBvdmVycmlkZSBtYXBcbiAgICAgICAgICAgIG92ZXJyaWRlTWFwID09PSBkZWZhdWx0RXJyb3JNYXAgPyB1bmRlZmluZWQgOiBkZWZhdWx0RXJyb3JNYXAsIC8vIHRoZW4gZ2xvYmFsIGRlZmF1bHQgbWFwXG4gICAgICAgIF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgIH0pO1xuICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goaXNzdWUpO1xufVxuZXhwb3J0IGNsYXNzIFBhcnNlU3RhdHVzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IFwidmFsaWRcIjtcbiAgICB9XG4gICAgZGlydHkoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlID09PSBcInZhbGlkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJkaXJ0eVwiO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgdGhpcy52YWx1ZSA9IFwiYWJvcnRlZFwiO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VBcnJheShzdGF0dXMsIHJlc3VsdHMpIHtcbiAgICAgICAgY29uc3QgYXJyYXlWYWx1ZSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChzLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgYXJyYXlWYWx1ZS5wdXNoKHMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogYXJyYXlWYWx1ZSB9O1xuICAgIH1cbiAgICBzdGF0aWMgYXN5bmMgbWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKSB7XG4gICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgc3luY1BhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBzeW5jUGFpcnMpO1xuICAgIH1cbiAgICBzdGF0aWMgbWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3QgZmluYWxPYmplY3QgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IHBhaXI7XG4gICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAodmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBpZiAoa2V5LnZhbHVlICE9PSBcIl9fcHJvdG9fX1wiICYmICh0eXBlb2YgdmFsdWUudmFsdWUgIT09IFwidW5kZWZpbmVkXCIgfHwgcGFpci5hbHdheXNTZXQpKSB7XG4gICAgICAgICAgICAgICAgZmluYWxPYmplY3Rba2V5LnZhbHVlXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogZmluYWxPYmplY3QgfTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgSU5WQUxJRCA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmV4cG9ydCBjb25zdCBESVJUWSA9ICh2YWx1ZSkgPT4gKHsgc3RhdHVzOiBcImRpcnR5XCIsIHZhbHVlIH0pO1xuZXhwb3J0IGNvbnN0IE9LID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWUgfSk7XG5leHBvcnQgY29uc3QgaXNBYm9ydGVkID0gKHgpID0+IHguc3RhdHVzID09PSBcImFib3J0ZWRcIjtcbmV4cG9ydCBjb25zdCBpc0RpcnR5ID0gKHgpID0+IHguc3RhdHVzID09PSBcImRpcnR5XCI7XG5leHBvcnQgY29uc3QgaXNWYWxpZCA9ICh4KSA9PiB4LnN0YXR1cyA9PT0gXCJ2YWxpZFwiO1xuZXhwb3J0IGNvbnN0IGlzQXN5bmMgPSAoeCkgPT4gdHlwZW9mIFByb21pc2UgIT09IFwidW5kZWZpbmVkXCIgJiYgeCBpbnN0YW5jZW9mIFByb21pc2U7XG4iLCAiZXhwb3J0IHZhciBlcnJvclV0aWw7XG4oZnVuY3Rpb24gKGVycm9yVXRpbCkge1xuICAgIGVycm9yVXRpbC5lcnJUb09iaiA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZSB9IDogbWVzc2FnZSB8fCB7fTtcbiAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICBlcnJvclV0aWwudG9TdHJpbmcgPSAobWVzc2FnZSkgPT4gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZT8ubWVzc2FnZTtcbn0pKGVycm9yVXRpbCB8fCAoZXJyb3JVdGlsID0ge30pKTtcbiIsICJpbXBvcnQgeyBab2RFcnJvciwgWm9kSXNzdWVDb2RlLCB9IGZyb20gXCIuL1pvZEVycm9yLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0RXJyb3JNYXAsIGdldEVycm9yTWFwIH0gZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5pbXBvcnQgeyBlcnJvclV0aWwgfSBmcm9tIFwiLi9oZWxwZXJzL2Vycm9yVXRpbC5qc1wiO1xuaW1wb3J0IHsgRElSVFksIElOVkFMSUQsIE9LLCBQYXJzZVN0YXR1cywgYWRkSXNzdWVUb0NvbnRleHQsIGlzQWJvcnRlZCwgaXNBc3luYywgaXNEaXJ0eSwgaXNWYWxpZCwgbWFrZUlzc3VlLCB9IGZyb20gXCIuL2hlbHBlcnMvcGFyc2VVdGlsLmpzXCI7XG5pbXBvcnQgeyB1dGlsLCBab2RQYXJzZWRUeXBlLCBnZXRQYXJzZWRUeXBlIH0gZnJvbSBcIi4vaGVscGVycy91dGlsLmpzXCI7XG5jbGFzcyBQYXJzZUlucHV0TGF6eVBhdGgge1xuICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgdmFsdWUsIHBhdGgsIGtleSkge1xuICAgICAgICB0aGlzLl9jYWNoZWRQYXRoID0gW107XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLmRhdGEgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fcGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMuX2tleSA9IGtleTtcbiAgICB9XG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVkUGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuX2tleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZWRQYXRoLnB1c2goLi4udGhpcy5fcGF0aCwgLi4udGhpcy5fa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCB0aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWRQYXRoO1xuICAgIH1cbn1cbmNvbnN0IGhhbmRsZVJlc3VsdCA9IChjdHgsIHJlc3VsdCkgPT4ge1xuICAgIGlmIChpc1ZhbGlkKHJlc3VsdCkpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoIWN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVmFsaWRhdGlvbiBmYWlsZWQgYnV0IG5vIGlzc3VlcyBkZXRlY3RlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9lcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKGN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9lcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxufTtcbmZ1bmN0aW9uIHByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXMpXG4gICAgICAgIHJldHVybiB7fTtcbiAgICBjb25zdCB7IGVycm9yTWFwLCBpbnZhbGlkX3R5cGVfZXJyb3IsIHJlcXVpcmVkX2Vycm9yLCBkZXNjcmlwdGlvbiB9ID0gcGFyYW1zO1xuICAgIGlmIChlcnJvck1hcCAmJiAoaW52YWxpZF90eXBlX2Vycm9yIHx8IHJlcXVpcmVkX2Vycm9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IHVzZSBcImludmFsaWRfdHlwZV9lcnJvclwiIG9yIFwicmVxdWlyZWRfZXJyb3JcIiBpbiBjb25qdW5jdGlvbiB3aXRoIGN1c3RvbSBlcnJvciBtYXAuYCk7XG4gICAgfVxuICAgIGlmIChlcnJvck1hcClcbiAgICAgICAgcmV0dXJuIHsgZXJyb3JNYXA6IGVycm9yTWFwLCBkZXNjcmlwdGlvbiB9O1xuICAgIGNvbnN0IGN1c3RvbU1hcCA9IChpc3MsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCB7IG1lc3NhZ2UgfSA9IHBhcmFtcztcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcImludmFsaWRfZW51bV92YWx1ZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGN0eC5kYXRhID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBtZXNzYWdlID8/IHJlcXVpcmVkX2Vycm9yID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNzLmNvZGUgIT09IFwiaW52YWxpZF90eXBlXCIpXG4gICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlOiBjdHguZGVmYXVsdEVycm9yIH07XG4gICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gaW52YWxpZF90eXBlX2Vycm9yID8/IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICB9O1xuICAgIHJldHVybiB7IGVycm9yTWFwOiBjdXN0b21NYXAsIGRlc2NyaXB0aW9uIH07XG59XG5leHBvcnQgY2xhc3MgWm9kVHlwZSB7XG4gICAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICBfZ2V0VHlwZShpbnB1dCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpIHtcbiAgICAgICAgcmV0dXJuIChjdHggfHwge1xuICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgZGF0YTogaW5wdXQuZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGF0aDogaW5wdXQucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBuZXcgUGFyc2VTdGF0dXMoKSxcbiAgICAgICAgICAgIGN0eDoge1xuICAgICAgICAgICAgICAgIGNvbW1vbjogaW5wdXQucGFyZW50LmNvbW1vbixcbiAgICAgICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoaW5wdXQuZGF0YSksXG4gICAgICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogaW5wdXQucGFyZW50LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX3BhcnNlU3luYyhpbnB1dCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZShpbnB1dCk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bmNocm9ub3VzIHBhcnNlIGVuY291bnRlcmVkIHByb21pc2UuXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIF9wYXJzZUFzeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgIH1cbiAgICBwYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zYWZlUGFyc2UoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIHNhZmVQYXJzZShkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogcGFyYW1zPy5hc3luYyA/PyBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICBcIn52YWxpZGF0ZVwiKGRhdGEpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBhc3luYzogISF0aGlzW1wifnN0YW5kYXJkXCJdLmFzeW5jLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhdGg6IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2VTeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyPy5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpPy5pbmNsdWRlcyhcImVuY291bnRlcmVkXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdHguY29tbW9uID0ge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXJzZUFzeW5jKHsgZGF0YSwgcGF0aDogW10sIHBhcmVudDogY3R4IH0pLnRoZW4oKHJlc3VsdCkgPT4gaXNWYWxpZChyZXN1bHQpXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBjdHguY29tbW9uLmlzc3VlcyxcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyBwYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcyk7XG4gICAgICAgIGlmIChyZXN1bHQuc3VjY2VzcylcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuZGF0YTtcbiAgICAgICAgdGhyb3cgcmVzdWx0LmVycm9yO1xuICAgIH1cbiAgICBhc3luYyBzYWZlUGFyc2VBc3luYyhkYXRhLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0dWFsRXJyb3JNYXA6IHBhcmFtcz8uZXJyb3JNYXAsXG4gICAgICAgICAgICAgICAgYXN5bmM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogcGFyYW1zPy5wYXRoIHx8IFtdLFxuICAgICAgICAgICAgc2NoZW1hRXJyb3JNYXA6IHRoaXMuX2RlZi5lcnJvck1hcCxcbiAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXJzZWRUeXBlOiBnZXRQYXJzZWRUeXBlKGRhdGEpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBtYXliZUFzeW5jUmVzdWx0ID0gdGhpcy5fcGFyc2UoeyBkYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IChpc0FzeW5jKG1heWJlQXN5bmNSZXN1bHQpID8gbWF5YmVBc3luY1Jlc3VsdCA6IFByb21pc2UucmVzb2x2ZShtYXliZUFzeW5jUmVzdWx0KSk7XG4gICAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQoY3R4LCByZXN1bHQpO1xuICAgIH1cbiAgICByZWZpbmUoY2hlY2ssIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZ2V0SXNzdWVQcm9wZXJ0aWVzID0gKHZhbCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBtZXNzYWdlID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlKHZhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlZmluZW1lbnQoKHZhbCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBjaGVjayh2YWwpO1xuICAgICAgICAgICAgY29uc3Qgc2V0RXJyb3IgPSAoKSA9PiBjdHguYWRkSXNzdWUoe1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5jdXN0b20sXG4gICAgICAgICAgICAgICAgLi4uZ2V0SXNzdWVQcm9wZXJ0aWVzKHZhbCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiByZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHNldEVycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZWZpbmVtZW50KGNoZWNrLCByZWZpbmVtZW50RGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmICghY2hlY2sodmFsKSkge1xuICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh0eXBlb2YgcmVmaW5lbWVudERhdGEgPT09IFwiZnVuY3Rpb25cIiA/IHJlZmluZW1lbnREYXRhKHZhbCwgY3R4KSA6IHJlZmluZW1lbnREYXRhKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9yZWZpbmVtZW50KHJlZmluZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInJlZmluZW1lbnRcIiwgcmVmaW5lbWVudCB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3VwZXJSZWZpbmUocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudChyZWZpbmVtZW50KTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZGVmKSB7XG4gICAgICAgIC8qKiBBbGlhcyBvZiBzYWZlUGFyc2VBc3luYyAqL1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc2FmZVBhcnNlQXN5bmM7XG4gICAgICAgIHRoaXMuX2RlZiA9IGRlZjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMucGFyc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2UgPSB0aGlzLnNhZmVQYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhcnNlQXN5bmMgPSB0aGlzLnBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zYWZlUGFyc2VBc3luYyA9IHRoaXMuc2FmZVBhcnNlQXN5bmMuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5zcGEgPSB0aGlzLnNwYS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnJlZmluZSA9IHRoaXMucmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lbWVudCA9IHRoaXMucmVmaW5lbWVudC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnN1cGVyUmVmaW5lID0gdGhpcy5zdXBlclJlZmluZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9wdGlvbmFsID0gdGhpcy5vcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxhYmxlID0gdGhpcy5udWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm51bGxpc2ggPSB0aGlzLm51bGxpc2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hcnJheSA9IHRoaXMuYXJyYXkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gdGhpcy5wcm9taXNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSB0aGlzLm9yLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYW5kID0gdGhpcy5hbmQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm0gPSB0aGlzLnRyYW5zZm9ybS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJyYW5kID0gdGhpcy5icmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlZmF1bHQgPSB0aGlzLmRlZmF1bHQuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5jYXRjaCA9IHRoaXMuY2F0Y2guYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5kZXNjcmliZSA9IHRoaXMuZGVzY3JpYmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5waXBlID0gdGhpcy5waXBlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVhZG9ubHkgPSB0aGlzLnJlYWRvbmx5LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNOdWxsYWJsZSA9IHRoaXMuaXNOdWxsYWJsZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmlzT3B0aW9uYWwgPSB0aGlzLmlzT3B0aW9uYWwuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXSA9IHtcbiAgICAgICAgICAgIHZlcnNpb246IDEsXG4gICAgICAgICAgICB2ZW5kb3I6IFwiem9kXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogKGRhdGEpID0+IHRoaXNbXCJ+dmFsaWRhdGVcIl0oZGF0YSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG51bGxpc2goKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm51bGxhYmxlKCkub3B0aW9uYWwoKTtcbiAgICB9XG4gICAgYXJyYXkoKSB7XG4gICAgICAgIHJldHVybiBab2RBcnJheS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIHByb21pc2UoKSB7XG4gICAgICAgIHJldHVybiBab2RQcm9taXNlLmNyZWF0ZSh0aGlzLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBvcihvcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvZFVuaW9uLmNyZWF0ZShbdGhpcywgb3B0aW9uXSwgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgYW5kKGluY29taW5nKSB7XG4gICAgICAgIHJldHVybiBab2RJbnRlcnNlY3Rpb24uY3JlYXRlKHRoaXMsIGluY29taW5nLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICB0cmFuc2Zvcm0odHJhbnNmb3JtKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgICAgICBlZmZlY3Q6IHsgdHlwZTogXCJ0cmFuc2Zvcm1cIiwgdHJhbnNmb3JtIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0KGRlZikge1xuICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgZGVmYXVsdFZhbHVlOiBkZWZhdWx0VmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REZWZhdWx0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYnJhbmQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQnJhbmRlZCh7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJyYW5kZWQsXG4gICAgICAgICAgICB0eXBlOiB0aGlzLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2goZGVmKSB7XG4gICAgICAgIGNvbnN0IGNhdGNoVmFsdWVGdW5jID0gdHlwZW9mIGRlZiA9PT0gXCJmdW5jdGlvblwiID8gZGVmIDogKCkgPT4gZGVmO1xuICAgICAgICByZXR1cm4gbmV3IFpvZENhdGNoKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIGlubmVyVHlwZTogdGhpcyxcbiAgICAgICAgICAgIGNhdGNoVmFsdWU6IGNhdGNoVmFsdWVGdW5jLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGNvbnN0IFRoaXMgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICByZXR1cm4gbmV3IFRoaXMoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZGVzY3JpcHRpb24sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwaXBlKHRhcmdldCkge1xuICAgICAgICByZXR1cm4gWm9kUGlwZWxpbmUuY3JlYXRlKHRoaXMsIHRhcmdldCk7XG4gICAgfVxuICAgIHJlYWRvbmx5KCkge1xuICAgICAgICByZXR1cm4gWm9kUmVhZG9ubHkuY3JlYXRlKHRoaXMpO1xuICAgIH1cbiAgICBpc09wdGlvbmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UodW5kZWZpbmVkKS5zdWNjZXNzO1xuICAgIH1cbiAgICBpc051bGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICB9XG59XG5jb25zdCBjdWlkUmVnZXggPSAvXmNbXlxccy1dezgsfSQvaTtcbmNvbnN0IGN1aWQyUmVnZXggPSAvXlswLTlhLXpdKyQvO1xuY29uc3QgdWxpZFJlZ2V4ID0gL15bMC05QS1ISktNTlAtVFYtWl17MjZ9JC9pO1xuLy8gY29uc3QgdXVpZFJlZ2V4ID1cbi8vICAgL14oW2EtZjAtOV17OH0tW2EtZjAtOV17NH0tWzEtNV1bYS1mMC05XXszfS1bYS1mMC05XXs0fS1bYS1mMC05XXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmNvbnN0IHV1aWRSZWdleCA9IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC9pO1xuY29uc3QgbmFub2lkUmVnZXggPSAvXlthLXowLTlfLV17MjF9JC9pO1xuY29uc3Qgand0UmVnZXggPSAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvO1xuY29uc3QgZHVyYXRpb25SZWdleCA9IC9eWy0rXT9QKD8hJCkoPzooPzpbLStdP1xcZCtZKXwoPzpbLStdP1xcZCtbLixdXFxkK1kkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/Oig/OlstK10/XFxkK1cpfCg/OlstK10/XFxkK1suLF1cXGQrVyQpKT8oPzooPzpbLStdP1xcZCtEKXwoPzpbLStdP1xcZCtbLixdXFxkK0QkKSk/KD86VCg/PVtcXGQrLV0pKD86KD86Wy0rXT9cXGQrSCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtIJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzpbLStdP1xcZCsoPzpbLixdXFxkKyk/Uyk/KT8/JC87XG4vLyBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS80NjE4MS8xNTUwMTU1XG4vLyBvbGQgdmVyc2lvbjogdG9vIHNsb3csIGRpZG4ndCBzdXBwb3J0IHVuaWNvZGVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPSAvXigoKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSsoXFwuKFthLXpdfFxcZHxbISNcXCQlJidcXCpcXCtcXC1cXC89XFw/XFxeX2B7XFx8fX5dfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSspKil8KChcXHgyMikoKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPygoW1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4N2ZdfFxceDIxfFtcXHgyMy1cXHg1Yl18W1xceDVkLVxceDdlXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KFxcXFwoW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBkLVxceDdmXXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSkqKCgoXFx4MjB8XFx4MDkpKihcXHgwZFxceDBhKSk/KFxceDIwfFxceDA5KSspPyhcXHgyMikpKUAoKChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18XFxkfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpXFwuKSsoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoKFthLXpdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKShbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSooW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSkkL2k7XG4vL29sZCBlbWFpbCByZWdleFxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKChbXjw+KClbXFxdLiw7Olxcc0BcIl0rKFxcLltePD4oKVtcXF0uLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoPyEtKShbXjw+KClbXFxdLiw7Olxcc0BcIl0rXFwuKStbXjw+KClbXFxdLiw7Olxcc0BcIl17MSx9KVteLTw+KClbXFxdLiw7Olxcc0BcIl0kL2k7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXigoW148PigpW1xcXVxcXFwuLDs6XFxzQFxcXCJdKyhcXC5bXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKSopfChcXFwiLitcXFwiKSlAKChcXFsoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXF0pfChcXFtJUHY2OigoW2EtZjAtOV17MSw0fTopezd9fDo6KFthLWYwLTldezEsNH06KXswLDZ9fChbYS1mMC05XXsxLDR9Oil7MX06KFthLWYwLTldezEsNH06KXswLDV9fChbYS1mMC05XXsxLDR9Oil7Mn06KFthLWYwLTldezEsNH06KXswLDR9fChbYS1mMC05XXsxLDR9Oil7M306KFthLWYwLTldezEsNH06KXswLDN9fChbYS1mMC05XXsxLDR9Oil7NH06KFthLWYwLTldezEsNH06KXswLDJ9fChbYS1mMC05XXsxLDR9Oil7NX06KFthLWYwLTldezEsNH06KXswLDF9KShbYS1mMC05XXsxLDR9fCgoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKSlcXF0pfChbQS1aYS16MC05XShbQS1aYS16MC05LV0qW0EtWmEtejAtOV0pKihcXC5bQS1aYS16XXsyLH0pKykpJC87XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16QS1aMC05XFwuXFwhXFwjXFwkXFwlXFwmXFwnXFwqXFwrXFwvXFw9XFw/XFxeXFxfXFxgXFx7XFx8XFx9XFx+XFwtXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXig/OlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSsoPzpcXC5bYS16MC05ISMkJSYnKisvPT9eX2B7fH1+LV0rKSp8XCIoPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMVxceDIzLVxceDViXFx4NWQtXFx4N2ZdfFxcXFxbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGUtXFx4N2ZdKSpcIilAKD86KD86W2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP1xcLikrW2EtejAtOV0oPzpbYS16MC05LV0qW2EtejAtOV0pP3xcXFsoPzooPzoyNVswLTVdfDJbMC00XVswLTldfFswMV0/WzAtOV1bMC05XT8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldP3xbYS16MC05LV0qW2EtejAtOV06KD86W1xceDAxLVxceDA4XFx4MGJcXHgwY1xceDBlLVxceDFmXFx4MjEtXFx4NWFcXHg1My1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKylcXF0pJC9pO1xuY29uc3QgZW1haWxSZWdleCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aMC05XycrXFwtXFwuXSopW0EtWjAtOV8rLV1AKFtBLVowLTldW0EtWjAtOVxcLV0qXFwuKStbQS1aXXsyLH0kL2k7XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID1cbi8vICAgL15bYS16MC05LiEjJCUmXHUyMDE5KisvPT9eX2B7fH1+LV0rQFthLXowLTktXSsoPzpcXC5bYS16MC05XFwtXSspKiQvaTtcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxuY29uc3QgX2Vtb2ppUmVnZXggPSBgXihcXFxccHtFeHRlbmRlZF9QaWN0b2dyYXBoaWN9fFxcXFxwe0Vtb2ppX0NvbXBvbmVudH0pKyRgO1xubGV0IGVtb2ppUmVnZXg7XG4vLyBmYXN0ZXIsIHNpbXBsZXIsIHNhZmVyXG5jb25zdCBpcHY0UmVnZXggPSAvXig/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKSQvO1xuY29uc3QgaXB2NENpZHJSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvO1xuLy8gY29uc3QgaXB2NlJlZ2V4ID1cbi8vIC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvO1xuY29uc3QgaXB2NlJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpJC87XG5jb25zdCBpcHY2Q2lkclJlZ2V4ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3LDd9WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsN306fChbMC05YS1mQS1GXXsxLDR9Oil7MSw2fTpbMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw1fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwyfXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH0oOlswLTlhLWZBLUZdezEsNH0pezEsM318KFswLTlhLWZBLUZdezEsNH06KXsxLDN9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwyfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw1fXxbMC05YS1mQS1GXXsxLDR9OigoOlswLTlhLWZBLUZdezEsNH0pezEsNn0pfDooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDd9fDopfGZlODA6KDpbMC05YS1mQS1GXXswLDR9KXswLDR9JVswLTlhLXpBLVpdezEsfXw6OihmZmZmKDowezEsNH0pezAsMX06KXswLDF9KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pfChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fTooKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSkpXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuY29uc3QgYmFzZTY0UmVnZXggPSAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC87XG4vLyBodHRwczovL2Jhc2U2NC5ndXJ1L3N0YW5kYXJkcy9iYXNlNjR1cmxcbmNvbnN0IGJhc2U2NHVybFJlZ2V4ID0gL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvO1xuLy8gc2ltcGxlXG4vLyBjb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgXFxcXGR7NH0tXFxcXGR7Mn0tXFxcXGR7Mn1gO1xuLy8gbm8gbGVhcCB5ZWFyIHZhbGlkYXRpb25cbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS0oKDBbMTM1NzhdfDEwfDEyKS0zMXwoMFsxMy05XXwxWzAtMl0pLTMwfCgwWzEtOV18MVswLTJdKS0oMFsxLTldfDFcXFxcZHwyXFxcXGQpKWA7XG4vLyB3aXRoIGxlYXAgeWVhciB2YWxpZGF0aW9uXG5jb25zdCBkYXRlUmVnZXhTb3VyY2UgPSBgKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmNvbnN0IGRhdGVSZWdleCA9IG5ldyBSZWdFeHAoYF4ke2RhdGVSZWdleFNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lUmVnZXhTb3VyY2UoYXJncykge1xuICAgIGxldCBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgWzAtNV1cXFxcZGA7XG4gICAgaWYgKGFyZ3MucHJlY2lzaW9uKSB7XG4gICAgICAgIHNlY29uZHNSZWdleFNvdXJjZSA9IGAke3NlY29uZHNSZWdleFNvdXJjZX1cXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFyZ3MucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfShcXFxcLlxcXFxkKyk/YDtcbiAgICB9XG4gICAgY29uc3Qgc2Vjb25kc1F1YW50aWZpZXIgPSBhcmdzLnByZWNpc2lvbiA/IFwiK1wiIDogXCI/XCI7IC8vIHJlcXVpcmUgc2Vjb25kcyBpZiBwcmVjaXNpb24gaXMgbm9uemVyb1xuICAgIHJldHVybiBgKFswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQoOiR7c2Vjb25kc1JlZ2V4U291cmNlfSkke3NlY29uZHNRdWFudGlmaWVyfWA7XG59XG5mdW5jdGlvbiB0aW1lUmVnZXgoYXJncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHt0aW1lUmVnZXhTb3VyY2UoYXJncyl9JGApO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5leHBvcnQgZnVuY3Rpb24gZGF0ZXRpbWVSZWdleChhcmdzKSB7XG4gICAgbGV0IHJlZ2V4ID0gYCR7ZGF0ZVJlZ2V4U291cmNlfVQke3RpbWVSZWdleFNvdXJjZShhcmdzKX1gO1xuICAgIGNvbnN0IG9wdHMgPSBbXTtcbiAgICBvcHRzLnB1c2goYXJncy5sb2NhbCA/IGBaP2AgOiBgWmApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9Oj9cXFxcZHsyfSlgKTtcbiAgICByZWdleCA9IGAke3JlZ2V4fSgke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRJUChpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2UmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRKV1Qoand0LCBhbGcpIHtcbiAgICBpZiAoIWp3dFJlZ2V4LnRlc3Qoand0KSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IFtoZWFkZXJdID0gand0LnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIENvbnZlcnQgYmFzZTY0dXJsIHRvIGJhc2U2NFxuICAgICAgICBjb25zdCBiYXNlNjQgPSBoZWFkZXJcbiAgICAgICAgICAgIC5yZXBsYWNlKC8tL2csIFwiK1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoL18vZywgXCIvXCIpXG4gICAgICAgICAgICAucGFkRW5kKGhlYWRlci5sZW5ndGggKyAoKDQgLSAoaGVhZGVyLmxlbmd0aCAlIDQpKSAlIDQpLCBcIj1cIik7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IEpTT04ucGFyc2UoYXRvYihiYXNlNjQpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkZWNvZGVkICE9PSBcIm9iamVjdFwiIHx8IGRlY29kZWQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChcInR5cFwiIGluIGRlY29kZWQgJiYgZGVjb2RlZD8udHlwICE9PSBcIkpXVFwiKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIWRlY29kZWQuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnICYmIGRlY29kZWQuYWxnICE9PSBhbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1ZhbGlkQ2lkcihpcCwgdmVyc2lvbikge1xuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NFwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY0Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoKHZlcnNpb24gPT09IFwidjZcIiB8fCAhdmVyc2lvbikgJiYgaXB2NkNpZHJSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGNsYXNzIFpvZFN0cmluZyBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IFN0cmluZyhpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zdHJpbmcsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5kYXRhLmxlbmd0aCA+IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb1NtYWxsID0gaW5wdXQuZGF0YS5sZW5ndGggPCBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1haWxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZW1haWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVtb2ppXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1vamlSZWdleCA9IG5ldyBSZWdFeHAoX2Vtb2ppUmVnZXgsIFwidVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFlbW9qaVJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbW9qaVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidXVpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dWlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInV1aWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFuYW5vaWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwibmFub2lkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWN1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZDJSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY3VpZDJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghdWxpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJ1bGlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1cmxcIikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgbmV3IFVSTChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwicmVnZXhcIikge1xuICAgICAgICAgICAgICAgIGNoZWNrLnJlZ2V4Lmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgdGVzdFJlc3VsdCA9IGNoZWNrLnJlZ2V4LnRlc3QoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0ZXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwicmVnZXhcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRyaW1cIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRyaW0oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW5jbHVkZXNcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5pbmNsdWRlcyhjaGVjay52YWx1ZSwgY2hlY2sucG9zaXRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgaW5jbHVkZXM6IGNoZWNrLnZhbHVlLCBwb3NpdGlvbjogY2hlY2sucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvTG93ZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0b1VwcGVyQ2FzZVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwic3RhcnRzV2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLnN0YXJ0c1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgc3RhcnRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImVuZHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuZW5kc1dpdGgoY2hlY2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IHsgZW5kc1dpdGg6IGNoZWNrLnZhbHVlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRldGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRldGltZVJlZ2V4KGNoZWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZGF0ZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSBkYXRlUmVnZXg7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVnZXggPSB0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWR1cmF0aW9uUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImR1cmF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpcFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkSVAoaW5wdXQuZGF0YSwgY2hlY2sudmVyc2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJpcFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiand0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRKV1QoaW5wdXQuZGF0YSwgY2hlY2suYWxnKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImp3dFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiY2lkclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkQ2lkcihpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImNpZHJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJiYXNlNjR1cmxcIikge1xuICAgICAgICAgICAgICAgIGlmICghYmFzZTY0dXJsUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfcmVnZXgocmVnZXgsIHZhbGlkYXRpb24sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmaW5lbWVudCgoZGF0YSkgPT4gcmVnZXgudGVzdChkYXRhKSwge1xuICAgICAgICAgICAgdmFsaWRhdGlvbixcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbWFpbChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZW1haWxcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1cmwobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVybFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGVtb2ppKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbW9qaVwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHV1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInV1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBuYW5vaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcIm5hbm9pZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImN1aWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBjdWlkMihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZDJcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICB1bGlkKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJ1bGlkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgYmFzZTY0KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJiYXNlNjRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjR1cmwobWVzc2FnZSkge1xuICAgICAgICAvLyBiYXNlNjR1cmwgZW5jb2RpbmcgaXMgYSBtb2RpZmljYXRpb24gb2YgYmFzZTY0IHRoYXQgY2FuIHNhZmVseSBiZSB1c2VkIGluIFVSTHMgYW5kIGZpbGVuYW1lc1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGp3dChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiand0XCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgaXAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImlwXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgY2lkcihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY2lkclwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucykgfSk7XG4gICAgfVxuICAgIGRhdGV0aW1lKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgb2Zmc2V0OiBvcHRpb25zPy5vZmZzZXQgPz8gZmFsc2UsXG4gICAgICAgICAgICBsb2NhbDogb3B0aW9ucz8ubG9jYWwgPz8gZmFsc2UsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkYXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJkYXRlXCIsIG1lc3NhZ2UgfSk7XG4gICAgfVxuICAgIHRpbWUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG9wdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJ0aW1lXCIsXG4gICAgICAgICAgICBwcmVjaXNpb246IHR5cGVvZiBvcHRpb25zPy5wcmVjaXNpb24gPT09IFwidW5kZWZpbmVkXCIgPyBudWxsIDogb3B0aW9ucz8ucHJlY2lzaW9uLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnM/Lm1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZHVyYXRpb24obWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImR1cmF0aW9uXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgcmVnZXgocmVnZXgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIHJlZ2V4OiByZWdleCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGluY2x1ZGVzKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBwb3NpdGlvbjogb3B0aW9ucz8ucG9zaXRpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGFydHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInN0YXJ0c1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVuZHNXaXRoKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImVuZHNXaXRoXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkxlbmd0aCxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4TGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGVuZ3RoKGxlbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJsZW5ndGhcIixcbiAgICAgICAgICAgIHZhbHVlOiBsZW4sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFcXVpdmFsZW50IHRvIGAubWluKDEpYFxuICAgICAqL1xuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSk7XG4gICAgfVxuICAgIHRyaW0oKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIHsga2luZDogXCJ0cmltXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b0xvd2VyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvTG93ZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0b1VwcGVyQ2FzZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRvVXBwZXJDYXNlXCIgfV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgaXNEYXRldGltZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRldGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJkYXRlXCIpO1xuICAgIH1cbiAgICBnZXQgaXNUaW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInRpbWVcIik7XG4gICAgfVxuICAgIGdldCBpc0R1cmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImR1cmF0aW9uXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbWFpbCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbWFpbFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVJMKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVybFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRW1vamkoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZW1vamlcIik7XG4gICAgfVxuICAgIGdldCBpc1VVSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXVpZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzTkFOT0lEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcIm5hbm9pZFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ1VJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEMigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjdWlkMlwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVUxJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1bGlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNJUCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpcFwiKTtcbiAgICB9XG4gICAgZ2V0IGlzQ0lEUigpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJjaWRyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0XCIpO1xuICAgIH1cbiAgICBnZXQgaXNCYXNlNjR1cmwoKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiYmFzZTY0dXJsXCIpO1xuICAgIH1cbiAgICBnZXQgbWluTGVuZ3RoKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhMZW5ndGgoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RTdHJpbmcuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RTdHJpbmcsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgPz8gZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zOTY2NDg0L3doeS1kb2VzLW1vZHVsdXMtb3BlcmF0b3ItcmV0dXJuLWZyYWN0aW9uYWwtbnVtYmVyLWluLWphdmFzY3JpcHQvMzE3MTEwMzQjMzE3MTEwMzRcbmZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBEZWNDb3VudCA9IChzdGVwLnRvU3RyaW5nKCkuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IE51bWJlci5wYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gMTAgKiogZGVjQ291bnQ7XG59XG5leHBvcnQgY2xhc3MgWm9kTnVtYmVyIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWluID0gdGhpcy5ndGU7XG4gICAgICAgIHRoaXMubWF4ID0gdGhpcy5sdGU7XG4gICAgICAgIHRoaXMuc3RlcCA9IHRoaXMubXVsdGlwbGVPZjtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gTnVtYmVyKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bWJlcixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcImludFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1dGlsLmlzSW50ZWdlcihpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiaW50ZWdlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IFwiZmxvYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZsb2F0U2FmZVJlbWFpbmRlcihpbnB1dC5kYXRhLCBjaGVjay52YWx1ZSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZmluaXRlXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ3RlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBndCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHQodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBzZXRMaW1pdChraW5kLCB2YWx1ZSwgaW5jbHVzaXZlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kTnVtYmVyKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5jaGVja3MsXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgY2hlY2tdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW50KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW50XCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG11bHRpcGxlT2YodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibXVsdGlwbGVPZlwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmluaXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZmluaXRlXCIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzYWZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbiAgICBnZXQgaXNJbnQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgKGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiICYmIHV0aWwuaXNJbnRlZ2VyKGNoLnZhbHVlKSkpO1xuICAgIH1cbiAgICBnZXQgaXNGaW5pdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJmaW5pdGVcIiB8fCBjaC5raW5kID09PSBcImludFwiIHx8IGNoLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE51bWJlci5pc0Zpbml0ZShtaW4pICYmIE51bWJlci5pc0Zpbml0ZShtYXgpO1xuICAgIH1cbn1cblpvZE51bWJlci5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bWJlcixcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RCaWdJbnQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBCaWdJbnQoaW5wdXQuZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5iaWdpbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRJbnZhbGlkSW5wdXQoaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjdHggPSB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjaGVjay5pbmNsdXNpdmUgPyBpbnB1dC5kYXRhIDwgY2hlY2sudmFsdWUgOiBpbnB1dC5kYXRhIDw9IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPiBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPj0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb0JpZykge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogY2hlY2suaW5jbHVzaXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibXVsdGlwbGVPZlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEgJSBjaGVjay52YWx1ZSAhPT0gQmlnSW50KDApKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2YsXG4gICAgICAgICAgICAgICAgICAgICAgICBtdWx0aXBsZU9mOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgX2dldEludmFsaWRJbnB1dChpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJpZ2ludCxcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25wb3NpdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ0ludCgwKSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbm5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBtaW5WYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluO1xuICAgIH1cbiAgICBnZXQgbWF4VmFsdWUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICB9XG59XG5ab2RCaWdJbnQuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCaWdJbnQsXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgPz8gZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQm9vbGVhbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJvb2xlYW4oaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5ib29sZWFuKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmJvb2xlYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kQm9vbGVhbi5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCb29sZWFuKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RCb29sZWFuLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZERhdGUgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBuZXcgRGF0ZShpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZGF0ZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oaW5wdXQuZGF0YS5nZXRUaW1lKCkpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGF0dXMgPSBuZXcgUGFyc2VTdGF0dXMoKTtcbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2hlY2sua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA8IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhhY3Q6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YS5nZXRUaW1lKCkgPiBjaGVjay52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgdmFsdWU6IG5ldyBEYXRlKGlucHV0LmRhdGEuZ2V0VGltZSgpKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtaW4obWluRGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBtaW5EYXRlLmdldFRpbWUoKSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhEYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IG1heERhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pbkRhdGUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbiAhPSBudWxsID8gbmV3IERhdGUobWluKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBtYXhEYXRlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXggIT0gbnVsbCA/IG5ldyBEYXRlKG1heCkgOiBudWxsO1xuICAgIH1cbn1cblpvZERhdGUuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRGF0ZSh7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGF0ZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RTeW1ib2wgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zeW1ib2wpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuc3ltYm9sLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFN5bWJvbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTeW1ib2woe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN5bWJvbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmRlZmluZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVuZGVmaW5lZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmRlZmluZWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuZGVmaW5lZCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROdWxsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5udWxsLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZE51bGwuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RBbnkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLy8gdG8gcHJldmVudCBpbnN0YW5jZXMgb2Ygb3RoZXIgY2xhc3NlcyBmcm9tIGV4dGVuZGluZyBab2RBbnkuIHRoaXMgY2F1c2VzIGlzc3VlcyB3aXRoIGNhdGNoYWxsIGluIFpvZE9iamVjdC5cbiAgICAgICAgdGhpcy5fYW55ID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RBbnkuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQW55KHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBbnksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kVW5rbm93biBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyByZXF1aXJlZFxuICAgICAgICB0aGlzLl91bmtub3duID0gdHJ1ZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RVbmtub3duLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVua25vd24oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVua25vd24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTmV2ZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uZXZlcixcbiAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgIH1cbn1cblpvZE5ldmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5ldmVyKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROZXZlcixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RWb2lkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnZvaWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVm9pZC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RWb2lkKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RWb2lkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEFycmF5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4LCBzdGF0dXMgfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmFycmF5LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5leGFjdExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY3R4LmRhdGEubGVuZ3RoID4gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBjdHguZGF0YS5sZW5ndGggPCBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IHRvb0JpZyA/IFpvZElzc3VlQ29kZS50b29fYmlnIDogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogKHRvb1NtYWxsID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogKHRvb0JpZyA/IGRlZi5leGFjdExlbmd0aC52YWx1ZSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLmV4YWN0TGVuZ3RoLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5taW5MZW5ndGggIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCBkZWYubWluTGVuZ3RoLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5MZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5MZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heExlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA+IGRlZi5tYXhMZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhMZW5ndGgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlZi50eXBlLl9wYXJzZUFzeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICAgICAgfSkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFsuLi5jdHguZGF0YV0ubWFwKChpdGVtLCBpKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlU3luYyhuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgaXRlbSwgY3R4LnBhdGgsIGkpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0KTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgbWluKG1pbkxlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pbkxlbmd0aDogeyB2YWx1ZTogbWluTGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1heChtYXhMZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhMZW5ndGg6IHsgdmFsdWU6IG1heExlbmd0aCwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgZXhhY3RMZW5ndGg6IHsgdmFsdWU6IGxlbiwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RBcnJheS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICBtaW5MZW5ndGg6IG51bGwsXG4gICAgICAgIG1heExlbmd0aDogbnVsbCxcbiAgICAgICAgZXhhY3RMZW5ndGg6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQXJyYXksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBkZWVwUGFydGlhbGlmeShzY2hlbWEpIHtcbiAgICBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kT2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYS5zaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRTY2hlbWEgPSBzY2hlbWEuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoZmllbGRTY2hlbWEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZEFycmF5KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4uc2NoZW1hLl9kZWYsXG4gICAgICAgICAgICB0eXBlOiBkZWVwUGFydGlhbGlmeShzY2hlbWEuZWxlbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gWm9kT3B0aW9uYWwuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gWm9kTnVsbGFibGUuY3JlYXRlKGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS51bndyYXAoKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RUdXBsZSkge1xuICAgICAgICByZXR1cm4gWm9kVHVwbGUuY3JlYXRlKHNjaGVtYS5pdGVtcy5tYXAoKGl0ZW0pID0+IGRlZXBQYXJ0aWFsaWZ5KGl0ZW0pKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gc2NoZW1hO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RPYmplY3QgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIEluIG1vc3QgY2FzZXMsIHRoaXMgaXMgbm8gbG9uZ2VyIG5lZWRlZCAtIHVua25vd24gcHJvcGVydGllcyBhcmUgbm93IHNpbGVudGx5IHN0cmlwcGVkLlxuICAgICAgICAgKiBJZiB5b3Ugd2FudCB0byBwYXNzIHRocm91Z2ggdW5rbm93biBwcm9wZXJ0aWVzLCB1c2UgYC5wYXNzdGhyb3VnaCgpYCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub25zdHJpY3QgPSB0aGlzLnBhc3N0aHJvdWdoO1xuICAgICAgICAvLyBleHRlbmQ8XG4gICAgICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGUsXG4gICAgICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIE91dHB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAgICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgICAgICAvLyAgICAgICA/IE91dHB1dFtrXVxuICAgICAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgICAgICAvLyAgIH0+LFxuICAgICAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMgdXRpbC5mbGF0dGVuPHtcbiAgICAgICAgLy8gICAgIFtrIGluIGtleW9mIEF1Z21lbnRhdGlvbiB8IGtleW9mIElucHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgICAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgICAgICAvLyAgICAgICA/IElucHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT5cbiAgICAgICAgLy8gPihcbiAgICAgICAgLy8gICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgICAgICAvLyApOiBab2RPYmplY3Q8XG4gICAgICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgQXVnbWVudGF0aW9uPixcbiAgICAgICAgLy8gICBVbmtub3duS2V5cyxcbiAgICAgICAgLy8gICBDYXRjaGFsbCxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQsXG4gICAgICAgIC8vICAgTmV3SW5wdXRcbiAgICAgICAgLy8gPiB7XG4gICAgICAgIC8vICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAvLyAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAvLyAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgIC8vICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAvLyAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgIC8vICAgICB9KSxcbiAgICAgICAgLy8gICB9KSBhcyBhbnk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXByZWNhdGVkIFVzZSBgLmV4dGVuZGAgaW5zdGVhZFxuICAgICAgICAgKiAgKi9cbiAgICAgICAgdGhpcy5hdWdtZW50ID0gdGhpcy5leHRlbmQ7XG4gICAgfVxuICAgIF9nZXRDYWNoZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWNoZWQgIT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuX2RlZi5zaGFwZSgpO1xuICAgICAgICBjb25zdCBrZXlzID0gdXRpbC5vYmplY3RLZXlzKHNoYXBlKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkID0geyBzaGFwZSwga2V5cyB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVkO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgeyBzaGFwZSwga2V5czogc2hhcGVLZXlzIH0gPSB0aGlzLl9nZXRDYWNoZWQoKTtcbiAgICAgICAgY29uc3QgZXh0cmFLZXlzID0gW107XG4gICAgICAgIGlmICghKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyICYmIHRoaXMuX2RlZi51bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3R4LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXNoYXBlS2V5cy5pbmNsdWRlcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXBlS2V5cykge1xuICAgICAgICAgICAgY29uc3Qga2V5VmFsaWRhdG9yID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgIGtleTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGtleSB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiBrZXlWYWxpZGF0b3IuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jYXRjaGFsbCBpbnN0YW5jZW9mIFpvZE5ldmVyKSB7XG4gICAgICAgICAgICBjb25zdCB1bmtub3duS2V5cyA9IHRoaXMuX2RlZi51bmtub3duS2V5cztcbiAgICAgICAgICAgIGlmICh1bmtub3duS2V5cyA9PT0gXCJwYXNzdGhyb3VnaFwiKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogeyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGN0eC5kYXRhW2tleV0gfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodW5rbm93bktleXMgPT09IFwic3RyaWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFLZXlzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudW5yZWNvZ25pemVkX2tleXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBleHRyYUtleXMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpcFwiKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludGVybmFsIFpvZE9iamVjdCBlcnJvcjogaW52YWxpZCB1bmtub3duS2V5cyB2YWx1ZS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIHJ1biBjYXRjaGFsbCB2YWxpZGF0aW9uXG4gICAgICAgICAgICBjb25zdCBjYXRjaGFsbCA9IHRoaXMuX2RlZi5jYXRjaGFsbDtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIGV4dHJhS2V5cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY3R4LmRhdGFba2V5XTtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBjYXRjaGFsbC5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSAvLywgY3R4LmNoaWxkKGtleSksIHZhbHVlLCBnZXRQYXJzZWRUeXBlKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG4gICAgICAgICAgICAgICAgLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN5bmNQYWlycyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDogcGFpci5hbHdheXNTZXQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3luY1BhaXJzO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAudGhlbigoc3luY1BhaXJzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgfVxuICAgIHN0cmljdChtZXNzYWdlKSB7XG4gICAgICAgIGVycm9yVXRpbC5lcnJUb09iajtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWFwOiAoaXNzdWUsIGN0eCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEVycm9yID0gdGhpcy5fZGVmLmVycm9yTWFwPy4oaXNzdWUsIGN0eCkubWVzc2FnZSA/PyBjdHguZGVmYXVsdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkubWVzc2FnZSA/PyBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmYXVsdEVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdHJpcCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhc3N0aHJvdWdoKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJwYXNzdGhyb3VnaFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gY29uc3QgQXVnbWVudEZhY3RvcnkgPVxuICAgIC8vICAgPERlZiBleHRlbmRzIFpvZE9iamVjdERlZj4oZGVmOiBEZWYpID0+XG4gICAgLy8gICA8QXVnbWVudGF0aW9uIGV4dGVuZHMgWm9kUmF3U2hhcGU+KFxuICAgIC8vICAgICBhdWdtZW50YXRpb246IEF1Z21lbnRhdGlvblxuICAgIC8vICAgKTogWm9kT2JqZWN0PFxuICAgIC8vICAgICBleHRlbmRTaGFwZTxSZXR1cm5UeXBlPERlZltcInNoYXBlXCJdPiwgQXVnbWVudGF0aW9uPixcbiAgICAvLyAgICAgRGVmW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICAgIERlZltcImNhdGNoYWxsXCJdXG4gICAgLy8gICA+ID0+IHtcbiAgICAvLyAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICAgIC4uLmRlZixcbiAgICAvLyAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAvLyAgICAgICAgIC4uLmRlZi5zaGFwZSgpLFxuICAgIC8vICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgIC8vICAgICAgIH0pLFxuICAgIC8vICAgICB9KSBhcyBhbnk7XG4gICAgLy8gICB9O1xuICAgIGV4dGVuZChhdWdtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+ICh7XG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgICAgICAgICAgLi4uYXVnbWVudGF0aW9uLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcmlvciB0byB6b2RAMS4wLjEyIHRoZXJlIHdhcyBhIGJ1ZyBpbiB0aGVcbiAgICAgKiBpbmZlcnJlZCB0eXBlIG9mIG1lcmdlZCBvYmplY3RzLiBQbGVhc2VcbiAgICAgKiB1cGdyYWRlIGlmIHlvdSBhcmUgZXhwZXJpZW5jaW5nIGlzc3Vlcy5cbiAgICAgKi9cbiAgICBtZXJnZShtZXJnaW5nKSB7XG4gICAgICAgIGNvbnN0IG1lcmdlZCA9IG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAgICAgICAgIGNhdGNoYWxsOiBtZXJnaW5nLl9kZWYuY2F0Y2hhbGwsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5tZXJnaW5nLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVyZ2VkO1xuICAgIH1cbiAgICAvLyBtZXJnZTxcbiAgICAvLyAgIEluY29taW5nIGV4dGVuZHMgQW55Wm9kT2JqZWN0LFxuICAgIC8vICAgQXVnbWVudGF0aW9uIGV4dGVuZHMgSW5jb21pbmdbXCJzaGFwZVwiXSxcbiAgICAvLyAgIE5ld091dHB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX291dHB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIE91dHB1dFxuICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAvLyAgIH0sXG4gICAgLy8gICBOZXdJbnB1dCBleHRlbmRzIHtcbiAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfaW5wdXRcIl1cbiAgICAvLyAgICAgICA6IGsgZXh0ZW5kcyBrZXlvZiBJbnB1dFxuICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfVxuICAgIC8vID4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl0sXG4gICAgLy8gICBOZXdPdXRwdXQsXG4gICAgLy8gICBOZXdJbnB1dFxuICAgIC8vID4ge1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIHNldEtleShrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdWdtZW50KHsgW2tleV06IHNjaGVtYSB9KTtcbiAgICB9XG4gICAgLy8gbWVyZ2U8SW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3Q+KFxuICAgIC8vICAgbWVyZ2luZzogSW5jb21pbmdcbiAgICAvLyApOiAvL1pvZE9iamVjdDxUICYgSW5jb21pbmdbXCJfc2hhcGVcIl0sIFVua25vd25LZXlzLCBDYXRjaGFsbD4gPSAobWVyZ2luZykgPT4ge1xuICAgIC8vIFpvZE9iamVjdDxcbiAgICAvLyAgIGV4dGVuZFNoYXBlPFQsIFJldHVyblR5cGU8SW5jb21pbmdbXCJfZGVmXCJdW1wic2hhcGVcIl0+PixcbiAgICAvLyAgIEluY29taW5nW1wiX2RlZlwiXVtcInVua25vd25LZXlzXCJdLFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyA+IHtcbiAgICAvLyAgIC8vIGNvbnN0IG1lcmdlZFNoYXBlID0gb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyhcbiAgICAvLyAgIC8vICAgdGhpcy5fZGVmLnNoYXBlKCksXG4gICAgLy8gICAvLyAgIG1lcmdpbmcuX2RlZi5zaGFwZSgpXG4gICAgLy8gICAvLyApO1xuICAgIC8vICAgY29uc3QgbWVyZ2VkOiBhbnkgPSBuZXcgWm9kT2JqZWN0KHtcbiAgICAvLyAgICAgdW5rbm93bktleXM6IG1lcmdpbmcuX2RlZi51bmtub3duS2V5cyxcbiAgICAvLyAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAvLyAgICAgc2hhcGU6ICgpID0+XG4gICAgLy8gICAgICAgb2JqZWN0VXRpbC5tZXJnZVNoYXBlcyh0aGlzLl9kZWYuc2hhcGUoKSwgbWVyZ2luZy5fZGVmLnNoYXBlKCkpLFxuICAgIC8vICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAvLyAgIHJldHVybiBtZXJnZWQ7XG4gICAgLy8gfVxuICAgIGNhdGNoYWxsKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNhdGNoYWxsOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpY2sobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXMobWFzaykpIHtcbiAgICAgICAgICAgIGlmIChtYXNrW2tleV0gJiYgdGhpcy5zaGFwZVtrZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbWl0KG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAoIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBkZWVwUGFydGlhbCgpIHtcbiAgICAgICAgcmV0dXJuIGRlZXBQYXJ0aWFsaWZ5KHRoaXMpO1xuICAgIH1cbiAgICBwYXJ0aWFsKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGlmIChtYXNrICYmICFtYXNrW2tleV0pIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gZmllbGRTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXF1aXJlZChtYXNrKSB7XG4gICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSkge1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSB0aGlzLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICBsZXQgbmV3RmllbGQgPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3RmllbGQgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdGaWVsZCA9IG5ld0ZpZWxkLl9kZWYuaW5uZXJUeXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXdTaGFwZVtrZXldID0gbmV3RmllbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAga2V5b2YoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVab2RFbnVtKHV0aWwub2JqZWN0S2V5cyh0aGlzLnNoYXBlKSk7XG4gICAgfVxufVxuWm9kT2JqZWN0LmNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIHVua25vd25LZXlzOiBcInN0cmlwXCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3Quc3RyaWN0Q3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaWN0XCIsXG4gICAgICAgIGNhdGNoYWxsOiBab2ROZXZlci5jcmVhdGUoKSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPYmplY3QsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5ab2RPYmplY3QubGF6eWNyZWF0ZSA9IChzaGFwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2RlZi5vcHRpb25zO1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVSZXN1bHRzKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIC8vIHJldHVybiBmaXJzdCBpc3N1ZS1mcmVlIHZhbGlkYXRpb24gaWYgaXQgZXhpc3RzXG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQucmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGFkZCBpc3N1ZXMgZnJvbSBkaXJ0eSBvcHRpb25cbiAgICAgICAgICAgICAgICAgICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaCguLi5yZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZXR1cm4gaW52YWxpZFxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiBuZXcgWm9kRXJyb3IocmVzdWx0LmN0eC5jb21tb24uaXNzdWVzKSk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbixcbiAgICAgICAgICAgICAgICB1bmlvbkVycm9ycyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChvcHRpb25zLm1hcChhc3luYyAob3B0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBvcHRpb24uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBjdHg6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KSkudGhlbihoYW5kbGVSZXN1bHRzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBkaXJ0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzc3VlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkQ3R4ID0ge1xuICAgICAgICAgICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICAgICAgICAgIGNvbW1vbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGNoaWxkQ3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiICYmICFkaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eSA9IHsgcmVzdWx0LCBjdHg6IGNoaWxkQ3R4IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGlsZEN0eC5jb21tb24uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXMucHVzaChjaGlsZEN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGlydHkpIHtcbiAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLmRpcnR5LmN0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlydHkucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdW5pb25FcnJvcnMgPSBpc3N1ZXMubWFwKChpc3N1ZXMpID0+IG5ldyBab2RFcnJvcihpc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbn1cblpvZFVuaW9uLmNyZWF0ZSA9ICh0eXBlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RVbmlvbih7XG4gICAgICAgIG9wdGlvbnM6IHR5cGVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFVuaW9uLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgIFpvZERpc2NyaW1pbmF0ZWRVbmlvbiAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmNvbnN0IGdldERpc2NyaW1pbmF0b3IgPSAodHlwZSkgPT4ge1xuICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGF6eSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnNjaGVtYSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFZmZlY3RzKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuaW5uZXJUeXBlKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTGl0ZXJhbCkge1xuICAgICAgICByZXR1cm4gW3R5cGUudmFsdWVdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRW51bSkge1xuICAgICAgICByZXR1cm4gdHlwZS5vcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTmF0aXZlRW51bSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgYmFuL2JhblxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXModHlwZS5lbnVtKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZERlZmF1bHQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RVbmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWRdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbCkge1xuICAgICAgICByZXR1cm4gW251bGxdO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpIHtcbiAgICAgICAgcmV0dXJuIFt1bmRlZmluZWQsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kTnVsbGFibGUpIHtcbiAgICAgICAgcmV0dXJuIFtudWxsLCAuLi5nZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpXTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEJyYW5kZWQpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RSZWFkb25seSkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZENhdGNoKSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuX2RlZi5pbm5lclR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbn07XG5leHBvcnQgY2xhc3MgWm9kRGlzY3JpbWluYXRlZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm9iamVjdCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3IgPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZSA9IGN0eC5kYXRhW2Rpc2NyaW1pbmF0b3JdO1xuICAgICAgICBjb25zdCBvcHRpb24gPSB0aGlzLm9wdGlvbnNNYXAuZ2V0KGRpc2NyaW1pbmF0b3JWYWx1ZSk7XG4gICAgICAgIGlmICghb3B0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yLFxuICAgICAgICAgICAgICAgIG9wdGlvbnM6IEFycmF5LmZyb20odGhpcy5vcHRpb25zTWFwLmtleXMoKSksXG4gICAgICAgICAgICAgICAgcGF0aDogW2Rpc2NyaW1pbmF0b3JdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBvcHRpb24uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZGlzY3JpbWluYXRvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5kaXNjcmltaW5hdG9yO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zO1xuICAgIH1cbiAgICBnZXQgb3B0aW9uc01hcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vcHRpb25zTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY29uc3RydWN0b3Igb2YgdGhlIGRpc2NyaW1pbmF0ZWQgdW5pb24gc2NoZW1hLiBJdHMgYmVoYXZpb3VyIGlzIHZlcnkgc2ltaWxhciB0byB0aGF0IG9mIHRoZSBub3JtYWwgei51bmlvbigpIGNvbnN0cnVjdG9yLlxuICAgICAqIEhvd2V2ZXIsIGl0IG9ubHkgYWxsb3dzIGEgdW5pb24gb2Ygb2JqZWN0cywgYWxsIG9mIHdoaWNoIG5lZWQgdG8gc2hhcmUgYSBkaXNjcmltaW5hdG9yIHByb3BlcnR5LiBUaGlzIHByb3BlcnR5IG11c3RcbiAgICAgKiBoYXZlIGEgZGlmZmVyZW50IHZhbHVlIGZvciBlYWNoIG9iamVjdCBpbiB0aGUgdW5pb24uXG4gICAgICogQHBhcmFtIGRpc2NyaW1pbmF0b3IgdGhlIG5hbWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0gdHlwZXMgYW4gYXJyYXkgb2Ygb2JqZWN0IHNjaGVtYXNcbiAgICAgKiBAcGFyYW0gcGFyYW1zXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZShkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gR2V0IGFsbCB0aGUgdmFsaWQgZGlzY3JpbWluYXRvciB2YWx1ZXNcbiAgICAgICAgY29uc3Qgb3B0aW9uc01hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgZm9yIChjb25zdCB0eXBlIG9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpc2NyaW1pbmF0b3JWYWx1ZXMgPSBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2hhcGVbZGlzY3JpbWluYXRvcl0pO1xuICAgICAgICAgICAgaWYgKCFkaXNjcmltaW5hdG9yVmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQSBkaXNjcmltaW5hdG9yIHZhbHVlIGZvciBrZXkgXFxgJHtkaXNjcmltaW5hdG9yfVxcYCBjb3VsZCBub3QgYmUgZXh0cmFjdGVkIGZyb20gYWxsIHNjaGVtYSBvcHRpb25zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIGRpc2NyaW1pbmF0b3JWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9uc01hcC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGlzY3JpbWluYXRvciBwcm9wZXJ0eSAke1N0cmluZyhkaXNjcmltaW5hdG9yKX0gaGFzIGR1cGxpY2F0ZSB2YWx1ZSAke1N0cmluZyh2YWx1ZSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wdGlvbnNNYXAuc2V0KHZhbHVlLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZERpc2NyaW1pbmF0ZWRVbmlvbih7XG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERpc2NyaW1pbmF0ZWRVbmlvbixcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgb3B0aW9uc01hcCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIGNvbnN0IGFUeXBlID0gZ2V0UGFyc2VkVHlwZShhKTtcbiAgICBjb25zdCBiVHlwZSA9IGdldFBhcnNlZFR5cGUoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhiKTtcbiAgICAgICAgY29uc3Qgc2hhcmVkS2V5cyA9IHV0aWwub2JqZWN0S2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5ICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmFycmF5KSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0FycmF5ID0gW107XG4gICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBhLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbUEgPSBhW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1CID0gYltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGl0ZW1BLCBpdGVtQik7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5kYXRlICYmIGJUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kSW50ZXJzZWN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGhhbmRsZVBhcnNlZCA9IChwYXJzZWRMZWZ0LCBwYXJzZWRSaWdodCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzQWJvcnRlZChwYXJzZWRMZWZ0KSB8fCBpc0Fib3J0ZWQocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhwYXJzZWRMZWZ0LnZhbHVlLCBwYXJzZWRSaWdodC52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9pbnRlcnNlY3Rpb25fdHlwZXMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eShwYXJzZWRMZWZ0KSB8fCBpc0RpcnR5KHBhcnNlZFJpZ2h0KSkge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBtZXJnZWQuZGF0YSB9O1xuICAgICAgICB9O1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYubGVmdC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVmLnJpZ2h0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IGhhbmRsZVBhcnNlZChsZWZ0LCByaWdodCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBhcnNlZCh0aGlzLl9kZWYubGVmdC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pLCB0aGlzLl9kZWYucmlnaHQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RJbnRlcnNlY3Rpb24uY3JlYXRlID0gKGxlZnQsIHJpZ2h0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RJbnRlcnNlY3Rpb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLyB0eXBlIFpvZFR1cGxlSXRlbXMgPSBbWm9kVHlwZUFueSwgLi4uWm9kVHlwZUFueVtdXTtcbmV4cG9ydCBjbGFzcyBab2RUdXBsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoIDwgdGhpcy5fZGVmLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN0ID0gdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgIGlmICghcmVzdCAmJiBjdHguZGF0YS5sZW5ndGggPiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IFsuLi5jdHguZGF0YV1cbiAgICAgICAgICAgIC5tYXAoKGl0ZW0sIGl0ZW1JbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5fZGVmLml0ZW1zW2l0ZW1JbmRleF0gfHwgdGhpcy5fZGVmLnJlc3Q7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBzY2hlbWEuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaXRlbUluZGV4KSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuZmlsdGVyKCh4KSA9PiAhIXgpOyAvLyBmaWx0ZXIgbnVsbHNcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChpdGVtcykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZUFycmF5KHN0YXR1cywgaXRlbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpdGVtcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pdGVtcztcbiAgICB9XG4gICAgcmVzdChyZXN0KSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kVHVwbGUoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmVzdCxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kVHVwbGUuY3JlYXRlID0gKHNjaGVtYXMsIHBhcmFtcykgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWFzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJZb3UgbXVzdCBwYXNzIGFuIGFycmF5IG9mIHNjaGVtYXMgdG8gei50dXBsZShbIC4uLiBdKVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIGl0ZW1zOiBzY2hlbWFzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFR1cGxlLFxuICAgICAgICByZXN0OiBudWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFJlY29yZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGN0eC5kYXRhW2tleV0sIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICBhbHdheXNTZXQ6IGtleSBpbiBjdHguZGF0YSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RBc3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGZpcnN0LCBzZWNvbmQsIHRoaXJkKSB7XG4gICAgICAgIGlmIChzZWNvbmQgaW5zdGFuY2VvZiBab2RUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICAgICAga2V5VHlwZTogZmlyc3QsXG4gICAgICAgICAgICAgICAgdmFsdWVUeXBlOiBzZWNvbmQsXG4gICAgICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlyZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgICAgICBrZXlUeXBlOiBab2RTdHJpbmcuY3JlYXRlKCksXG4gICAgICAgICAgICB2YWx1ZVR5cGU6IGZpcnN0LFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWNvcmQsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHNlY29uZCksXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RNYXAgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQga2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgfVxuICAgIGdldCB2YWx1ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubWFwKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm1hcCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGtleVR5cGUgPSB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgY29uc3QgcGFpcnMgPSBbLi4uY3R4LmRhdGEuZW50cmllcygpXS5tYXAoKFtrZXksIHZhbHVlXSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5OiBrZXlUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwga2V5LCBjdHgucGF0aCwgW2luZGV4LCBcImtleVwiXSkpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCB2YWx1ZSwgY3R4LnBhdGgsIFtpbmRleCwgXCJ2YWx1ZVwiXSkpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImRpcnR5XCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsTWFwLnNldChrZXkudmFsdWUsIHZhbHVlLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFpci52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE1hcCB9O1xuICAgICAgICB9XG4gICAgfVxufVxuWm9kTWFwLmNyZWF0ZSA9IChrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTWFwKHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE1hcCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RTZXQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnNldCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zZXQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWY7XG4gICAgICAgIGlmIChkZWYubWluU2l6ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLnNpemUgPCBkZWYubWluU2l6ZS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluU2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5taW5TaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5tYXhTaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA+IGRlZi5tYXhTaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4U2l6ZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGRlZi5tYXhTaXplLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUeXBlID0gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICAgICAgZnVuY3Rpb24gZmluYWxpemVTZXQoZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICBwYXJzZWRTZXQuYWRkKGVsZW1lbnQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBwYXJzZWRTZXQgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50cyA9IFsuLi5jdHguZGF0YS52YWx1ZXMoKV0ubWFwKChpdGVtLCBpKSA9PiB2YWx1ZVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpKTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChlbGVtZW50cykudGhlbigoZWxlbWVudHMpID0+IGZpbmFsaXplU2V0KGVsZW1lbnRzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmluYWxpemVTZXQoZWxlbWVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1pbihtaW5TaXplLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1pblNpemU6IHsgdmFsdWU6IG1pblNpemUsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heFNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWF4U2l6ZTogeyB2YWx1ZTogbWF4U2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaXplKHNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKHNpemUsIG1lc3NhZ2UpLm1heChzaXplLCBtZXNzYWdlKTtcbiAgICB9XG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgbWVzc2FnZSk7XG4gICAgfVxufVxuWm9kU2V0LmNyZWF0ZSA9ICh2YWx1ZVR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kU2V0KHtcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICBtaW5TaXplOiBudWxsLFxuICAgICAgICBtYXhTaXplOiBudWxsLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFNldCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RGdW5jdGlvbiBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlID0gdGhpcy5pbXBsZW1lbnQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZUFyZ3NJc3N1ZShhcmdzLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgY3R4LnNjaGVtYUVycm9yTWFwLCBnZXRFcnJvck1hcCgpLCBkZWZhdWx0RXJyb3JNYXBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzLFxuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHNFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG1ha2VSZXR1cm5zSXNzdWUocmV0dXJucywgZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBtYWtlSXNzdWUoe1xuICAgICAgICAgICAgICAgIGRhdGE6IHJldHVybnMsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgZXJyb3JNYXBzOiBbY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsIGN0eC5zY2hlbWFFcnJvck1hcCwgZ2V0RXJyb3JNYXAoKSwgZGVmYXVsdEVycm9yTWFwXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgICAgICAgICAgICAgaXNzdWVEYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3JldHVybl90eXBlLFxuICAgICAgICAgICAgICAgICAgICByZXR1cm5UeXBlRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7IGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCB9O1xuICAgICAgICBjb25zdCBmbiA9IGN0eC5kYXRhO1xuICAgICAgICBpZiAodGhpcy5fZGVmLnJldHVybnMgaW5zdGFuY2VvZiBab2RQcm9taXNlKSB7XG4gICAgICAgICAgICAvLyBXb3VsZCBsb3ZlIGEgd2F5IHRvIGF2b2lkIGRpc2FibGluZyB0aGlzIHJ1bGUsIGJ1dCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyBhbiBhbGlhcyAodXNpbmcgYW4gYXJyb3cgZnVuY3Rpb24gd2FzIHdoYXQgY2F1c2VkIDI2NTEpLlxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzXG4gICAgICAgICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gT0soYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihbXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGF3YWl0IG1lLl9kZWYuYXJncy5wYXJzZUFzeW5jKGFyZ3MsIHBhcmFtcykuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZUFyZ3NJc3N1ZShhcmdzLCBlKSk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZFJldHVybnMgPSBhd2FpdCBtZS5fZGVmLnJldHVybnMuX2RlZi50eXBlXG4gICAgICAgICAgICAgICAgICAgIC5wYXJzZUFzeW5jKHJlc3VsdCwgcGFyYW1zKVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuYWRkSXNzdWUobWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBtZS5fZGVmLmFyZ3Muc2FmZVBhcnNlKGFyZ3MsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRBcmdzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlQXJnc0lzc3VlKGFyZ3MsIHBhcnNlZEFyZ3MuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZm4sIHRoaXMsIHBhcnNlZEFyZ3MuZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IG1lLl9kZWYucmV0dXJucy5zYWZlUGFyc2UocmVzdWx0LCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmV0dXJucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBab2RFcnJvcihbbWFrZVJldHVybnNJc3N1ZShyZXN1bHQsIHBhcnNlZFJldHVybnMuZXJyb3IpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZWRSZXR1cm5zLmRhdGE7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmFyZ3M7XG4gICAgfVxuICAgIHJldHVyblR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYucmV0dXJucztcbiAgICB9XG4gICAgYXJncyguLi5pdGVtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGFyZ3M6IFpvZFR1cGxlLmNyZWF0ZShpdGVtcykucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybnMocmV0dXJuVHlwZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHJldHVybnM6IHJldHVyblR5cGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbXBsZW1lbnQoZnVuYykge1xuICAgICAgICBjb25zdCB2YWxpZGF0ZWRGdW5jID0gdGhpcy5wYXJzZShmdW5jKTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlZEZ1bmM7XG4gICAgfVxuICAgIHN0cmljdEltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShhcmdzLCByZXR1cm5zLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RGdW5jdGlvbih7XG4gICAgICAgICAgICBhcmdzOiAoYXJncyA/IGFyZ3MgOiBab2RUdXBsZS5jcmVhdGUoW10pLnJlc3QoWm9kVW5rbm93bi5jcmVhdGUoKSkpLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJucyB8fCBab2RVbmtub3duLmNyZWF0ZSgpLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RGdW5jdGlvbixcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZExhenkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmdldHRlcigpO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGxhenlTY2hlbWEgPSB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgICAgIHJldHVybiBsYXp5U2NoZW1hLl9wYXJzZSh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSk7XG4gICAgfVxufVxuWm9kTGF6eS5jcmVhdGUgPSAoZ2V0dGVyLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RMYXp5LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZExpdGVyYWwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0LmRhdGEgIT09IHRoaXMuX2RlZi52YWx1ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2xpdGVyYWwsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHRoaXMuX2RlZi52YWx1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZTtcbiAgICB9XG59XG5ab2RMaXRlcmFsLmNyZWF0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RMaXRlcmFsKHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExpdGVyYWwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBjcmVhdGVab2RFbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVudW0sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjbGFzcyBab2RFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlLmhhcyhpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB0aGlzLl9kZWYudmFsdWVzO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IG9wdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBWYWx1ZXMoKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWwgb2YgdGhpcy5fZGVmLnZhbHVlcykge1xuICAgICAgICAgICAgZW51bVZhbHVlc1t2YWxdID0gdmFsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnVtVmFsdWVzO1xuICAgIH1cbiAgICBnZXQgRW51bSgpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGV4dHJhY3QodmFsdWVzLCBuZXdEZWYgPSB0aGlzLl9kZWYpIHtcbiAgICAgICAgcmV0dXJuIFpvZEVudW0uY3JlYXRlKHZhbHVlcywge1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgLi4ubmV3RGVmLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZSh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodGhpcy5vcHRpb25zLmZpbHRlcigob3B0KSA9PiAhdmFsdWVzLmluY2x1ZGVzKG9wdCkpLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblpvZEVudW0uY3JlYXRlID0gY3JlYXRlWm9kRW51bTtcbmV4cG9ydCBjbGFzcyBab2ROYXRpdmVFbnVtIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IG5hdGl2ZUVudW1WYWx1ZXMgPSB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKTtcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nICYmIGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm51bWJlcikge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRWYWx1ZXMgPSB1dGlsLm9iamVjdFZhbHVlcyhuYXRpdmVFbnVtVmFsdWVzKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB1dGlsLmpvaW5WYWx1ZXMoZXhwZWN0ZWRWYWx1ZXMpLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZSA9IG5ldyBTZXQodXRpbC5nZXRWYWxpZEVudW1WYWx1ZXModGhpcy5fZGVmLnZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2VudW1fdmFsdWUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogZXhwZWN0ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG4gICAgZ2V0IGVudW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVzO1xuICAgIH1cbn1cblpvZE5hdGl2ZUVudW0uY3JlYXRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROYXRpdmVFbnVtKHtcbiAgICAgICAgdmFsdWVzOiB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmF0aXZlRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RQcm9taXNlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnByb21pc2UgJiYgY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUucHJvbWlzZSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21pc2lmaWVkID0gY3R4LnBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSA/IGN0eC5kYXRhIDogUHJvbWlzZS5yZXNvbHZlKGN0eC5kYXRhKTtcbiAgICAgICAgcmV0dXJuIE9LKHByb21pc2lmaWVkLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZS5wYXJzZUFzeW5jKGRhdGEsIHtcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcDogY3R4LmNvbW1vbi5jb250ZXh0dWFsRXJyb3JNYXAsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgIH1cbn1cblpvZFByb21pc2UuY3JlYXRlID0gKHNjaGVtYSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFByb21pc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRWZmZWN0cyBleHRlbmRzIFpvZFR5cGUge1xuICAgIGlubmVyVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIHNvdXJjZVR5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2NoZW1hLl9kZWYudHlwZU5hbWUgPT09IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzXG4gICAgICAgICAgICA/IHRoaXMuX2RlZi5zY2hlbWEuc291cmNlVHlwZSgpXG4gICAgICAgICAgICA6IHRoaXMuX2RlZi5zY2hlbWE7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBlZmZlY3QgPSB0aGlzLl9kZWYuZWZmZWN0IHx8IG51bGw7XG4gICAgICAgIGNvbnN0IGNoZWNrQ3R4ID0ge1xuICAgICAgICAgICAgYWRkSXNzdWU6IChhcmcpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIGFyZyk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5mYXRhbCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3R4LnBhdGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjaGVja0N0eC5hZGRJc3N1ZSA9IGNoZWNrQ3R4LmFkZElzc3VlLmJpbmQoY2hlY2tDdHgpO1xuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicHJlcHJvY2Vzc1wiKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzZWQgPSBlZmZlY3QudHJhbnNmb3JtKGN0eC5kYXRhLCBjaGVja0N0eCk7XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocHJvY2Vzc2VkKS50aGVuKGFzeW5jIChwcm9jZXNzZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cy52YWx1ZSA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcHJvY2Vzc2VkLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVmZmVjdC50eXBlID09PSBcInJlZmluZW1lbnRcIikge1xuICAgICAgICAgICAgY29uc3QgZXhlY3V0ZVJlZmluZW1lbnQgPSAoYWNjKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnJlZmluZW1lbnQoYWNjLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyByZWZpbmVtZW50IGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjYztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbm5lciA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgLy8gcmV0dXJuIHZhbHVlIGlzIGlnbm9yZWRcbiAgICAgICAgICAgICAgICBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGlubmVyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbm5lci5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXhlY3V0ZVJlZmluZW1lbnQoaW5uZXIudmFsdWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbm5lci52YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwidHJhbnNmb3JtXCIpIHtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2UgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZChiYXNlKSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBc3luY2hyb25vdXMgdHJhbnNmb3JtIGVuY291bnRlcmVkIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZSBvcGVyYXRpb24uIFVzZSAucGFyc2VBc3luYyBpbnN0ZWFkLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHJlc3VsdCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlQXN5bmMoeyBkYXRhOiBjdHguZGF0YSwgcGF0aDogY3R4LnBhdGgsIHBhcmVudDogY3R4IH0pLnRoZW4oKGJhc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZWZmZWN0LnRyYW5zZm9ybShiYXNlLnZhbHVlLCBjaGVja0N0eCkpLnRoZW4oKHJlc3VsdCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogc3RhdHVzLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdCxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoZWZmZWN0KTtcbiAgICB9XG59XG5ab2RFZmZlY3RzLmNyZWF0ZSA9IChzY2hlbWEsIGVmZmVjdCwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHMsXG4gICAgICAgIGVmZmVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZEVmZmVjdHMuY3JlYXRlV2l0aFByZXByb2Nlc3MgPSAocHJlcHJvY2Vzcywgc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInByZXByb2Nlc3NcIiwgdHJhbnNmb3JtOiBwcmVwcm9jZXNzIH0sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCB7IFpvZEVmZmVjdHMgYXMgWm9kVHJhbnNmb3JtZXIgfTtcbmV4cG9ydCBjbGFzcyBab2RPcHRpb25hbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RPcHRpb25hbC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RPcHRpb25hbCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RPcHRpb25hbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROdWxsYWJsZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLm51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBPSyhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE51bGxhYmxlLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bGxhYmxlKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE51bGxhYmxlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZERlZmF1bHQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGxldCBkYXRhID0gY3R4LmRhdGE7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9kZWYuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kRGVmYXVsdC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogdHlwZW9mIHBhcmFtcy5kZWZhdWx0ID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMuZGVmYXVsdCA6ICgpID0+IHBhcmFtcy5kZWZhdWx0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZENhdGNoIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICAvLyBuZXdDdHggaXMgdXNlZCB0byBub3QgY29sbGVjdCBpc3N1ZXMgZnJvbSBpbm5lciB0eXBlcyBpbiBjdHhcbiAgICAgICAgY29uc3QgbmV3Q3R4ID0ge1xuICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgLi4uY3R4LmNvbW1vbixcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YTogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICBwYXRoOiBuZXdDdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDoge1xuICAgICAgICAgICAgICAgIC4uLm5ld0N0eCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNBc3luYyhyZXN1bHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJ2YWxpZFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl9kZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIlxuICAgICAgICAgICAgICAgICAgICA/IHJlc3VsdC52YWx1ZVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFpvZEVycm9yKG5ld0N0eC5jb21tb24uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogbmV3Q3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVDYXRjaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kQ2F0Y2guY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQ2F0Y2gsXG4gICAgICAgIGNhdGNoVmFsdWU6IHR5cGVvZiBwYXJhbXMuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5jYXRjaCA6ICgpID0+IHBhcmFtcy5jYXRjaCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROYU4gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5uYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubmFuLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxufVxuWm9kTmFOLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hTih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTmFOLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0IEJSQU5EID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuZXhwb3J0IGNsYXNzIFpvZEJyYW5kZWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RQaXBlbGluZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQXN5bmMgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuaW4uX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShpblJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm91dC5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGluUmVzdWx0ID0gdGhpcy5fZGVmLmluLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaW5SZXN1bHQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1czogXCJkaXJ0eVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaW5SZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoYSwgYikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFBpcGVsaW5lKHtcbiAgICAgICAgICAgIGluOiBhLFxuICAgICAgICAgICAgb3V0OiBiLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RQaXBlbGluZSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZFJlYWRvbmx5IGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX2RlZi5pbm5lclR5cGUuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgY29uc3QgZnJlZXplID0gKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgZGF0YS52YWx1ZSA9IE9iamVjdC5mcmVlemUoZGF0YS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzQXN5bmMocmVzdWx0KSA/IHJlc3VsdC50aGVuKChkYXRhKSA9PiBmcmVlemUoZGF0YSkpIDogZnJlZXplKHJlc3VsdCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kUmVhZG9ubHkuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kUmVhZG9ubHkoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUmVhZG9ubHksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgei5jdXN0b20gICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5mdW5jdGlvbiBjbGVhblBhcmFtcyhwYXJhbXMsIGRhdGEpIHtcbiAgICBjb25zdCBwID0gdHlwZW9mIHBhcmFtcyA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zKGRhdGEpIDogdHlwZW9mIHBhcmFtcyA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcGFyYW1zIH0gOiBwYXJhbXM7XG4gICAgY29uc3QgcDIgPSB0eXBlb2YgcCA9PT0gXCJzdHJpbmdcIiA/IHsgbWVzc2FnZTogcCB9IDogcDtcbiAgICByZXR1cm4gcDI7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tKGNoZWNrLCBfcGFyYW1zID0ge30sIFxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIFBhc3MgYGZhdGFsYCBpbnRvIHRoZSBwYXJhbXMgb2JqZWN0IGluc3RlYWQ6XG4gKlxuICogYGBgdHNcbiAqIHouc3RyaW5nKCkuY3VzdG9tKCh2YWwpID0+IHZhbC5sZW5ndGggPiA1LCB7IGZhdGFsOiBmYWxzZSB9KVxuICogYGBgXG4gKlxuICovXG5mYXRhbCkge1xuICAgIGlmIChjaGVjaylcbiAgICAgICAgcmV0dXJuIFpvZEFueS5jcmVhdGUoKS5zdXBlclJlZmluZSgoZGF0YSwgY3R4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCByID0gY2hlY2soZGF0YSk7XG4gICAgICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gci50aGVuKChyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSBwYXJhbXMuZmF0YWwgPz8gZmF0YWwgPz8gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN0eC5hZGRJc3N1ZSh7IGNvZGU6IFwiY3VzdG9tXCIsIC4uLnBhcmFtcywgZmF0YWw6IF9mYXRhbCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyYW1zID0gY2xlYW5QYXJhbXMoX3BhcmFtcywgZGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgX2ZhdGFsID0gcGFyYW1zLmZhdGFsID8/IGZhdGFsID8/IHRydWU7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9KTtcbiAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpO1xufVxuZXhwb3J0IHsgWm9kVHlwZSBhcyBTY2hlbWEsIFpvZFR5cGUgYXMgWm9kU2NoZW1hIH07XG5leHBvcnQgY29uc3QgbGF0ZSA9IHtcbiAgICBvYmplY3Q6IFpvZE9iamVjdC5sYXp5Y3JlYXRlLFxufTtcbmV4cG9ydCB2YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTdHJpbmdcIl0gPSBcIlpvZFN0cmluZ1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bWJlclwiXSA9IFwiWm9kTnVtYmVyXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmFOXCJdID0gXCJab2ROYU5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RCaWdJbnRcIl0gPSBcIlpvZEJpZ0ludFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJvb2xlYW5cIl0gPSBcIlpvZEJvb2xlYW5cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REYXRlXCJdID0gXCJab2REYXRlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU3ltYm9sXCJdID0gXCJab2RTeW1ib2xcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmRlZmluZWRcIl0gPSBcIlpvZFVuZGVmaW5lZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxcIl0gPSBcIlpvZE51bGxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBbnlcIl0gPSBcIlpvZEFueVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVua25vd25cIl0gPSBcIlpvZFVua25vd25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROZXZlclwiXSA9IFwiWm9kTmV2ZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RWb2lkXCJdID0gXCJab2RWb2lkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQXJyYXlcIl0gPSBcIlpvZEFycmF5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kT2JqZWN0XCJdID0gXCJab2RPYmplY3RcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RVbmlvblwiXSA9IFwiWm9kVW5pb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REaXNjcmltaW5hdGVkVW5pb25cIl0gPSBcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEludGVyc2VjdGlvblwiXSA9IFwiWm9kSW50ZXJzZWN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVHVwbGVcIl0gPSBcIlpvZFR1cGxlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUmVjb3JkXCJdID0gXCJab2RSZWNvcmRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RNYXBcIl0gPSBcIlpvZE1hcFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFNldFwiXSA9IFwiWm9kU2V0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRnVuY3Rpb25cIl0gPSBcIlpvZEZ1bmN0aW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGF6eVwiXSA9IFwiWm9kTGF6eVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZExpdGVyYWxcIl0gPSBcIlpvZExpdGVyYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFbnVtXCJdID0gXCJab2RFbnVtXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kRWZmZWN0c1wiXSA9IFwiWm9kRWZmZWN0c1wiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5hdGl2ZUVudW1cIl0gPSBcIlpvZE5hdGl2ZUVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPcHRpb25hbFwiXSA9IFwiWm9kT3B0aW9uYWxcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROdWxsYWJsZVwiXSA9IFwiWm9kTnVsbGFibGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2REZWZhdWx0XCJdID0gXCJab2REZWZhdWx0XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQ2F0Y2hcIl0gPSBcIlpvZENhdGNoXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kUHJvbWlzZVwiXSA9IFwiWm9kUHJvbWlzZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJyYW5kZWRcIl0gPSBcIlpvZEJyYW5kZWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQaXBlbGluZVwiXSA9IFwiWm9kUGlwZWxpbmVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWFkb25seVwiXSA9IFwiWm9kUmVhZG9ubHlcIjtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbi8vIHJlcXVpcmVzIFRTIDQuNCtcbmNsYXNzIENsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciguLi5fKSB7IH1cbn1cbmNvbnN0IGluc3RhbmNlT2ZUeXBlID0gKFxuLy8gY29uc3QgaW5zdGFuY2VPZlR5cGUgPSA8VCBleHRlbmRzIG5ldyAoLi4uYXJnczogYW55W10pID0+IGFueT4oXG5jbHMsIHBhcmFtcyA9IHtcbiAgICBtZXNzYWdlOiBgSW5wdXQgbm90IGluc3RhbmNlIG9mICR7Y2xzLm5hbWV9YCxcbn0pID0+IGN1c3RvbSgoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscywgcGFyYW1zKTtcbmNvbnN0IHN0cmluZ1R5cGUgPSBab2RTdHJpbmcuY3JlYXRlO1xuY29uc3QgbnVtYmVyVHlwZSA9IFpvZE51bWJlci5jcmVhdGU7XG5jb25zdCBuYW5UeXBlID0gWm9kTmFOLmNyZWF0ZTtcbmNvbnN0IGJpZ0ludFR5cGUgPSBab2RCaWdJbnQuY3JlYXRlO1xuY29uc3QgYm9vbGVhblR5cGUgPSBab2RCb29sZWFuLmNyZWF0ZTtcbmNvbnN0IGRhdGVUeXBlID0gWm9kRGF0ZS5jcmVhdGU7XG5jb25zdCBzeW1ib2xUeXBlID0gWm9kU3ltYm9sLmNyZWF0ZTtcbmNvbnN0IHVuZGVmaW5lZFR5cGUgPSBab2RVbmRlZmluZWQuY3JlYXRlO1xuY29uc3QgbnVsbFR5cGUgPSBab2ROdWxsLmNyZWF0ZTtcbmNvbnN0IGFueVR5cGUgPSBab2RBbnkuY3JlYXRlO1xuY29uc3QgdW5rbm93blR5cGUgPSBab2RVbmtub3duLmNyZWF0ZTtcbmNvbnN0IG5ldmVyVHlwZSA9IFpvZE5ldmVyLmNyZWF0ZTtcbmNvbnN0IHZvaWRUeXBlID0gWm9kVm9pZC5jcmVhdGU7XG5jb25zdCBhcnJheVR5cGUgPSBab2RBcnJheS5jcmVhdGU7XG5jb25zdCBvYmplY3RUeXBlID0gWm9kT2JqZWN0LmNyZWF0ZTtcbmNvbnN0IHN0cmljdE9iamVjdFR5cGUgPSBab2RPYmplY3Quc3RyaWN0Q3JlYXRlO1xuY29uc3QgdW5pb25UeXBlID0gWm9kVW5pb24uY3JlYXRlO1xuY29uc3QgZGlzY3JpbWluYXRlZFVuaW9uVHlwZSA9IFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5jcmVhdGU7XG5jb25zdCBpbnRlcnNlY3Rpb25UeXBlID0gWm9kSW50ZXJzZWN0aW9uLmNyZWF0ZTtcbmNvbnN0IHR1cGxlVHlwZSA9IFpvZFR1cGxlLmNyZWF0ZTtcbmNvbnN0IHJlY29yZFR5cGUgPSBab2RSZWNvcmQuY3JlYXRlO1xuY29uc3QgbWFwVHlwZSA9IFpvZE1hcC5jcmVhdGU7XG5jb25zdCBzZXRUeXBlID0gWm9kU2V0LmNyZWF0ZTtcbmNvbnN0IGZ1bmN0aW9uVHlwZSA9IFpvZEZ1bmN0aW9uLmNyZWF0ZTtcbmNvbnN0IGxhenlUeXBlID0gWm9kTGF6eS5jcmVhdGU7XG5jb25zdCBsaXRlcmFsVHlwZSA9IFpvZExpdGVyYWwuY3JlYXRlO1xuY29uc3QgZW51bVR5cGUgPSBab2RFbnVtLmNyZWF0ZTtcbmNvbnN0IG5hdGl2ZUVudW1UeXBlID0gWm9kTmF0aXZlRW51bS5jcmVhdGU7XG5jb25zdCBwcm9taXNlVHlwZSA9IFpvZFByb21pc2UuY3JlYXRlO1xuY29uc3QgZWZmZWN0c1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZTtcbmNvbnN0IG9wdGlvbmFsVHlwZSA9IFpvZE9wdGlvbmFsLmNyZWF0ZTtcbmNvbnN0IG51bGxhYmxlVHlwZSA9IFpvZE51bGxhYmxlLmNyZWF0ZTtcbmNvbnN0IHByZXByb2Nlc3NUeXBlID0gWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcztcbmNvbnN0IHBpcGVsaW5lVHlwZSA9IFpvZFBpcGVsaW5lLmNyZWF0ZTtcbmNvbnN0IG9zdHJpbmcgPSAoKSA9PiBzdHJpbmdUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9udW1iZXIgPSAoKSA9PiBudW1iZXJUeXBlKCkub3B0aW9uYWwoKTtcbmNvbnN0IG9ib29sZWFuID0gKCkgPT4gYm9vbGVhblR5cGUoKS5vcHRpb25hbCgpO1xuZXhwb3J0IGNvbnN0IGNvZXJjZSA9IHtcbiAgICBzdHJpbmc6ICgoYXJnKSA9PiBab2RTdHJpbmcuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxuICAgIG51bWJlcjogKChhcmcpID0+IFpvZE51bWJlci5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgYm9vbGVhbjogKChhcmcpID0+IFpvZEJvb2xlYW4uY3JlYXRlKHtcbiAgICAgICAgLi4uYXJnLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgfSkpLFxuICAgIGJpZ2ludDogKChhcmcpID0+IFpvZEJpZ0ludC5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgZGF0ZTogKChhcmcpID0+IFpvZERhdGUuY3JlYXRlKHsgLi4uYXJnLCBjb2VyY2U6IHRydWUgfSkpLFxufTtcbmV4cG9ydCB7IGFueVR5cGUgYXMgYW55LCBhcnJheVR5cGUgYXMgYXJyYXksIGJpZ0ludFR5cGUgYXMgYmlnaW50LCBib29sZWFuVHlwZSBhcyBib29sZWFuLCBkYXRlVHlwZSBhcyBkYXRlLCBkaXNjcmltaW5hdGVkVW5pb25UeXBlIGFzIGRpc2NyaW1pbmF0ZWRVbmlvbiwgZWZmZWN0c1R5cGUgYXMgZWZmZWN0LCBlbnVtVHlwZSBhcyBlbnVtLCBmdW5jdGlvblR5cGUgYXMgZnVuY3Rpb24sIGluc3RhbmNlT2ZUeXBlIGFzIGluc3RhbmNlb2YsIGludGVyc2VjdGlvblR5cGUgYXMgaW50ZXJzZWN0aW9uLCBsYXp5VHlwZSBhcyBsYXp5LCBsaXRlcmFsVHlwZSBhcyBsaXRlcmFsLCBtYXBUeXBlIGFzIG1hcCwgbmFuVHlwZSBhcyBuYW4sIG5hdGl2ZUVudW1UeXBlIGFzIG5hdGl2ZUVudW0sIG5ldmVyVHlwZSBhcyBuZXZlciwgbnVsbFR5cGUgYXMgbnVsbCwgbnVsbGFibGVUeXBlIGFzIG51bGxhYmxlLCBudW1iZXJUeXBlIGFzIG51bWJlciwgb2JqZWN0VHlwZSBhcyBvYmplY3QsIG9ib29sZWFuLCBvbnVtYmVyLCBvcHRpb25hbFR5cGUgYXMgb3B0aW9uYWwsIG9zdHJpbmcsIHBpcGVsaW5lVHlwZSBhcyBwaXBlbGluZSwgcHJlcHJvY2Vzc1R5cGUgYXMgcHJlcHJvY2VzcywgcHJvbWlzZVR5cGUgYXMgcHJvbWlzZSwgcmVjb3JkVHlwZSBhcyByZWNvcmQsIHNldFR5cGUgYXMgc2V0LCBzdHJpY3RPYmplY3RUeXBlIGFzIHN0cmljdE9iamVjdCwgc3RyaW5nVHlwZSBhcyBzdHJpbmcsIHN5bWJvbFR5cGUgYXMgc3ltYm9sLCBlZmZlY3RzVHlwZSBhcyB0cmFuc2Zvcm1lciwgdHVwbGVUeXBlIGFzIHR1cGxlLCB1bmRlZmluZWRUeXBlIGFzIHVuZGVmaW5lZCwgdW5pb25UeXBlIGFzIHVuaW9uLCB1bmtub3duVHlwZSBhcyB1bmtub3duLCB2b2lkVHlwZSBhcyB2b2lkLCB9O1xuZXhwb3J0IGNvbnN0IE5FVkVSID0gSU5WQUxJRDtcbiIsICIvKiogQSBzcGVjaWFsIGNvbnN0YW50IHdpdGggdHlwZSBgbmV2ZXJgICovXG5leHBvcnQgY29uc3QgTkVWRVIgPSBPYmplY3QuZnJlZXplKHtcbiAgICBzdGF0dXM6IFwiYWJvcnRlZFwiLFxufSk7XG5leHBvcnQgLypAX19OT19TSURFX0VGRkVDVFNfXyovIGZ1bmN0aW9uICRjb25zdHJ1Y3RvcihuYW1lLCBpbml0aWFsaXplciwgcGFyYW1zKSB7XG4gICAgZnVuY3Rpb24gaW5pdChpbnN0LCBkZWYpIHtcbiAgICAgICAgaWYgKCFpbnN0Ll96b2QpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIl96b2RcIiwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGRlZixcbiAgICAgICAgICAgICAgICAgICAgY29uc3RyOiBfLFxuICAgICAgICAgICAgICAgICAgICB0cmFpdHM6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3QuX3pvZC50cmFpdHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaW5zdC5fem9kLnRyYWl0cy5hZGQobmFtZSk7XG4gICAgICAgIGluaXRpYWxpemVyKGluc3QsIGRlZik7XG4gICAgICAgIC8vIHN1cHBvcnQgcHJvdG90eXBlIG1vZGlmaWNhdGlvbnNcbiAgICAgICAgY29uc3QgcHJvdG8gPSBfLnByb3RvdHlwZTtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHByb3RvKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrID0ga2V5c1tpXTtcbiAgICAgICAgICAgIGlmICghKGsgaW4gaW5zdCkpIHtcbiAgICAgICAgICAgICAgICBpbnN0W2tdID0gcHJvdG9ba10uYmluZChpbnN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBkb2Vzbid0IHdvcmsgaWYgUGFyZW50IGhhcyBhIGNvbnN0cnVjdG9yIHdpdGggYXJndW1lbnRzXG4gICAgY29uc3QgUGFyZW50ID0gcGFyYW1zPy5QYXJlbnQgPz8gT2JqZWN0O1xuICAgIGNsYXNzIERlZmluaXRpb24gZXh0ZW5kcyBQYXJlbnQge1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRGVmaW5pdGlvbiwgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG4gICAgZnVuY3Rpb24gXyhkZWYpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBpbnN0ID0gcGFyYW1zPy5QYXJlbnQgPyBuZXcgRGVmaW5pdGlvbigpIDogdGhpcztcbiAgICAgICAgaW5pdChpbnN0LCBkZWYpO1xuICAgICAgICAoX2EgPSBpbnN0Ll96b2QpLmRlZmVycmVkID8/IChfYS5kZWZlcnJlZCA9IFtdKTtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBpbnN0Ll96b2QuZGVmZXJyZWQpIHtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcImluaXRcIiwgeyB2YWx1ZTogaW5pdCB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgICAgIHZhbHVlOiAoaW5zdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtcz8uUGFyZW50ICYmIGluc3QgaW5zdGFuY2VvZiBwYXJhbXMuUGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGluc3Q/Ll96b2Q/LnRyYWl0cz8uaGFzKG5hbWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICByZXR1cm4gXztcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFVUSUxJVElFUyAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGNvbnN0ICRicmFuZCA9IFN5bWJvbChcInpvZF9icmFuZFwiKTtcbmV4cG9ydCBjbGFzcyAkWm9kQXN5bmNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoYEVuY291bnRlcmVkIFByb21pc2UgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlLiBVc2UgLnBhcnNlQXN5bmMoKSBpbnN0ZWFkLmApO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyAkWm9kRW5jb2RlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICBzdXBlcihgRW5jb3VudGVyZWQgdW5pZGlyZWN0aW9uYWwgdHJhbnNmb3JtIGR1cmluZyBlbmNvZGU6ICR7bmFtZX1gKTtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJab2RFbmNvZGVFcnJvclwiO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBnbG9iYWxDb25maWcgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBjb25maWcobmV3Q29uZmlnKSB7XG4gICAgaWYgKG5ld0NvbmZpZylcbiAgICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxDb25maWcsIG5ld0NvbmZpZyk7XG4gICAgcmV0dXJuIGdsb2JhbENvbmZpZztcbn1cbiIsICIvLyBmdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRFcXVhbCh2YWwpIHtcbiAgICByZXR1cm4gdmFsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydE5vdEVxdWFsKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0TmV2ZXIoX3gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIHZhbHVlIGluIGV4aGF1c3RpdmUgY2hlY2tcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0KF8pIHsgfVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVudW1WYWx1ZXMoZW50cmllcykge1xuICAgIGNvbnN0IG51bWVyaWNWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGVudHJpZXMpLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpO1xuICAgIGNvbnN0IHZhbHVlcyA9IE9iamVjdC5lbnRyaWVzKGVudHJpZXMpXG4gICAgICAgIC5maWx0ZXIoKFtrLCBfXSkgPT4gbnVtZXJpY1ZhbHVlcy5pbmRleE9mKCtrKSA9PT0gLTEpXG4gICAgICAgIC5tYXAoKFtfLCB2XSkgPT4gdik7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcInxcIikge1xuICAgIHJldHVybiBhcnJheS5tYXAoKHZhbCkgPT4gc3RyaW5naWZ5UHJpbWl0aXZlKHZhbCkpLmpvaW4oc2VwYXJhdG9yKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBqc29uU3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJpZ2ludFwiKVxuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gY2FjaGVkKGdldHRlcikge1xuICAgIGNvbnN0IHNldCA9IGZhbHNlO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCB2YWx1ZSgpIHtcbiAgICAgICAgICAgIGlmICghc2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7IHZhbHVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhY2hlZCB2YWx1ZSBhbHJlYWR5IHNldFwiKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bGxpc2goaW5wdXQpIHtcbiAgICByZXR1cm4gaW5wdXQgPT09IG51bGwgfHwgaW5wdXQgPT09IHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbGVhblJlZ2V4KHNvdXJjZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gc291cmNlLnN0YXJ0c1dpdGgoXCJeXCIpID8gMSA6IDA7XG4gICAgY29uc3QgZW5kID0gc291cmNlLmVuZHNXaXRoKFwiJFwiKSA/IHNvdXJjZS5sZW5ndGggLSAxIDogc291cmNlLmxlbmd0aDtcbiAgICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZsb2F0U2FmZVJlbWFpbmRlcih2YWwsIHN0ZXApIHtcbiAgICBjb25zdCB2YWxEZWNDb3VudCA9ICh2YWwudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IHN0ZXBTdHJpbmcgPSBzdGVwLnRvU3RyaW5nKCk7XG4gICAgbGV0IHN0ZXBEZWNDb3VudCA9IChzdGVwU3RyaW5nLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgaWYgKHN0ZXBEZWNDb3VudCA9PT0gMCAmJiAvXFxkP2UtXFxkPy8udGVzdChzdGVwU3RyaW5nKSkge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHN0ZXBTdHJpbmcubWF0Y2goL1xcZD9lLShcXGQ/KS8pO1xuICAgICAgICBpZiAobWF0Y2g/LlsxXSkge1xuICAgICAgICAgICAgc3RlcERlY0NvdW50ID0gTnVtYmVyLnBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWNDb3VudCA9IHZhbERlY0NvdW50ID4gc3RlcERlY0NvdW50ID8gdmFsRGVjQ291bnQgOiBzdGVwRGVjQ291bnQ7XG4gICAgY29uc3QgdmFsSW50ID0gTnVtYmVyLnBhcnNlSW50KHZhbC50b0ZpeGVkKGRlY0NvdW50KS5yZXBsYWNlKFwiLlwiLCBcIlwiKSk7XG4gICAgY29uc3Qgc3RlcEludCA9IE51bWJlci5wYXJzZUludChzdGVwLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICByZXR1cm4gKHZhbEludCAlIHN0ZXBJbnQpIC8gMTAgKiogZGVjQ291bnQ7XG59XG5jb25zdCBFVkFMVUFUSU5HID0gU3ltYm9sKFwiZXZhbHVhdGluZ1wiKTtcbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVMYXp5KG9iamVjdCwga2V5LCBnZXR0ZXIpIHtcbiAgICBsZXQgdmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gRVZBTFVBVElORykge1xuICAgICAgICAgICAgICAgIC8vIENpcmN1bGFyIHJlZmVyZW5jZSBkZXRlY3RlZCwgcmV0dXJuIHVuZGVmaW5lZCB0byBicmVhayB0aGUgY3ljbGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IEVWQUxVQVRJTkc7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBnZXR0ZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KHYpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2LFxuICAgICAgICAgICAgICAgIC8vIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gb2JqZWN0W2tleV0gPSB2O1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0Q2xvbmUob2JqKSB7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaiksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblByb3AodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VEZWZzKC4uLmRlZnMpIHtcbiAgICBjb25zdCBtZXJnZWREZXNjcmlwdG9ycyA9IHt9O1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZnMpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhkZWYpO1xuICAgICAgICBPYmplY3QuYXNzaWduKG1lcmdlZERlc2NyaXB0b3JzLCBkZXNjcmlwdG9ycyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwgbWVyZ2VkRGVzY3JpcHRvcnMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsb25lRGVmKHNjaGVtYSkge1xuICAgIHJldHVybiBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRFbGVtZW50QXRQYXRoKG9iaiwgcGF0aCkge1xuICAgIGlmICghcGF0aClcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICByZXR1cm4gcGF0aC5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2M/LltrZXldLCBvYmopO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2VBbGxPYmplY3QocHJvbWlzZXNPYmopIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvbWlzZXNPYmopO1xuICAgIGNvbnN0IHByb21pc2VzID0ga2V5cy5tYXAoKGtleSkgPT4gcHJvbWlzZXNPYmpba2V5XSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkT2JqID0ge307XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzb2x2ZWRPYmpba2V5c1tpXV0gPSByZXN1bHRzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNvbHZlZE9iajtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21TdHJpbmcobGVuZ3RoID0gMTApIHtcbiAgICBjb25zdCBjaGFycyA9IFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgICBsZXQgc3RyID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHN0ciArPSBjaGFyc1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBjaGFycy5sZW5ndGgpXTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlc2Moc3RyKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0cik7XG59XG5leHBvcnQgZnVuY3Rpb24gc2x1Z2lmeShpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dFxuICAgICAgICAudG9Mb3dlckNhc2UoKVxuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5yZXBsYWNlKC9bXlxcd1xccy1dL2csIFwiXCIpXG4gICAgICAgIC5yZXBsYWNlKC9bXFxzXy1dKy9nLCBcIi1cIilcbiAgICAgICAgLnJlcGxhY2UoL14tK3wtKyQvZywgXCJcIik7XG59XG5leHBvcnQgY29uc3QgY2FwdHVyZVN0YWNrVHJhY2UgPSAoXCJjYXB0dXJlU3RhY2tUcmFjZVwiIGluIEVycm9yID8gRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UgOiAoLi4uX2FyZ3MpID0+IHsgfSk7XG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QoZGF0YSkge1xuICAgIHJldHVybiB0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiBkYXRhICE9PSBudWxsICYmICFBcnJheS5pc0FycmF5KGRhdGEpO1xufVxuZXhwb3J0IGNvbnN0IGFsbG93c0V2YWwgPSBjYWNoZWQoKCkgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBuYXZpZ2F0b3I/LnVzZXJBZ2VudD8uaW5jbHVkZXMoXCJDbG91ZGZsYXJlXCIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgICAgICBuZXcgRihcIlwiKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcbiAgICBpZiAoaXNPYmplY3QobykgPT09IGZhbHNlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gbW9kaWZpZWQgY29uc3RydWN0b3JcbiAgICBjb25zdCBjdG9yID0gby5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoY3RvciA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAodHlwZW9mIGN0b3IgIT09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgLy8gbW9kaWZpZWQgcHJvdG90eXBlXG4gICAgY29uc3QgcHJvdCA9IGN0b3IucHJvdG90eXBlO1xuICAgIGlmIChpc09iamVjdChwcm90KSA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBjdG9yIGRvZXNuJ3QgaGF2ZSBzdGF0aWMgYGlzUHJvdG90eXBlT2ZgXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwcm90LCBcImlzUHJvdG90eXBlT2ZcIikgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0Nsb25lKG8pIHtcbiAgICBpZiAoaXNQbGFpbk9iamVjdChvKSlcbiAgICAgICAgcmV0dXJuIHsgLi4ubyB9O1xuICAgIGlmIChBcnJheS5pc0FycmF5KG8pKVxuICAgICAgICByZXR1cm4gWy4uLm9dO1xuICAgIHJldHVybiBvO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bUtleXMoZGF0YSkge1xuICAgIGxldCBrZXlDb3VudCA9IDA7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIGtleSkpIHtcbiAgICAgICAgICAgIGtleUNvdW50Kys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtleUNvdW50O1xufVxuZXhwb3J0IGNvbnN0IGdldFBhcnNlZFR5cGUgPSAoZGF0YSkgPT4ge1xuICAgIGNvbnN0IHQgPSB0eXBlb2YgZGF0YTtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgICAgY2FzZSBcInVuZGVmaW5lZFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwidW5kZWZpbmVkXCI7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKGRhdGEpID8gXCJuYW5cIiA6IFwibnVtYmVyXCI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJib29sZWFuXCI7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiZnVuY3Rpb25cIjtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwiYmlnaW50XCI7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBcInN5bWJvbFwiO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmIGRhdGEuY2F0Y2ggJiYgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInByb21pc2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgTWFwICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJtYXBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgU2V0ICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJzZXRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImRhdGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGlmICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImZpbGVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGRhdGEgdHlwZTogJHt0fWApO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgcHJvcGVydHlLZXlUeXBlcyA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwic3ltYm9sXCJdKTtcbmV4cG9ydCBjb25zdCBwcmltaXRpdmVUeXBlcyA9IG5ldyBTZXQoW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiYmlnaW50XCIsIFwiYm9vbGVhblwiLCBcInN5bWJvbFwiLCBcInVuZGVmaW5lZFwiXSk7XG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgXCJcXFxcJCZcIik7XG59XG4vLyB6b2Qtc3BlY2lmaWMgdXRpbHNcbmV4cG9ydCBmdW5jdGlvbiBjbG9uZShpbnN0LCBkZWYsIHBhcmFtcykge1xuICAgIGNvbnN0IGNsID0gbmV3IGluc3QuX3pvZC5jb25zdHIoZGVmID8/IGluc3QuX3pvZC5kZWYpO1xuICAgIGlmICghZGVmIHx8IHBhcmFtcz8ucGFyZW50KVxuICAgICAgICBjbC5fem9kLnBhcmVudCA9IGluc3Q7XG4gICAgcmV0dXJuIGNsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gX3BhcmFtcztcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4geyBlcnJvcjogKCkgPT4gcGFyYW1zIH07XG4gICAgaWYgKHBhcmFtcz8ubWVzc2FnZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChwYXJhbXM/LmVycm9yICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc3BlY2lmeSBib3RoIGBtZXNzYWdlYCBhbmQgYGVycm9yYCBwYXJhbXNcIik7XG4gICAgICAgIHBhcmFtcy5lcnJvciA9IHBhcmFtcy5tZXNzYWdlO1xuICAgIH1cbiAgICBkZWxldGUgcGFyYW1zLm1lc3NhZ2U7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMuZXJyb3IgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB7IC4uLnBhcmFtcywgZXJyb3I6ICgpID0+IHBhcmFtcy5lcnJvciB9O1xuICAgIHJldHVybiBwYXJhbXM7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhbnNwYXJlbnRQcm94eShnZXR0ZXIpIHtcbiAgICBsZXQgdGFyZ2V0O1xuICAgIHJldHVybiBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZ2V0KF8sIHByb3AsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldCh0YXJnZXQsIHByb3AsIHJlY2VpdmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0KF8sIHByb3AsIHZhbHVlLCByZWNlaXZlcikge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5zZXQodGFyZ2V0LCBwcm9wLCB2YWx1ZSwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBoYXMoXywgcHJvcCkge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5oYXModGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvcGVydHkoXywgcHJvcCkge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWxldGVQcm9wZXJ0eSh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBvd25LZXlzKF8pIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3Qub3duS2V5cyh0YXJnZXQpO1xuICAgICAgICB9LFxuICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoXywgcHJvcCkge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBwcm9wKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVmaW5lUHJvcGVydHkoXywgcHJvcCwgZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHByb3AsIGRlc2NyaXB0b3IpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeVByaW1pdGl2ZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpICsgXCJuXCI7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsS2V5cyhzaGFwZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzaGFwZSkuZmlsdGVyKChrKSA9PiB7XG4gICAgICAgIHJldHVybiBzaGFwZVtrXS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIgJiYgc2hhcGVba10uX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBOVU1CRVJfRk9STUFUX1JBTkdFUyA9IHtcbiAgICBzYWZlaW50OiBbTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXSxcbiAgICBpbnQzMjogWy0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3XSxcbiAgICB1aW50MzI6IFswLCA0Mjk0OTY3Mjk1XSxcbiAgICBmbG9hdDMyOiBbLTMuNDAyODIzNDY2Mzg1Mjg4NmUzOCwgMy40MDI4MjM0NjYzODUyODg2ZTM4XSxcbiAgICBmbG9hdDY0OiBbLU51bWJlci5NQVhfVkFMVUUsIE51bWJlci5NQVhfVkFMVUVdLFxufTtcbmV4cG9ydCBjb25zdCBCSUdJTlRfRk9STUFUX1JBTkdFUyA9IHtcbiAgICBpbnQ2NDogWy8qIEBfX1BVUkVfXyovIEJpZ0ludChcIi05MjIzMzcyMDM2ODU0Nzc1ODA4XCIpLCAvKiBAX19QVVJFX18qLyBCaWdJbnQoXCI5MjIzMzcyMDM2ODU0Nzc1ODA3XCIpXSxcbiAgICB1aW50NjQ6IFsvKiBAX19QVVJFX18qLyBCaWdJbnQoMCksIC8qIEBfX1BVUkVfXyovIEJpZ0ludChcIjE4NDQ2NzQ0MDczNzA5NTUxNjE1XCIpXSxcbn07XG5leHBvcnQgZnVuY3Rpb24gcGljayhzY2hlbWEsIG1hc2spIHtcbiAgICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGNoZWNrcyA9IGN1cnJEZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5waWNrKCkgY2Fubm90IGJlIHVzZWQgb24gb2JqZWN0IHNjaGVtYXMgY29udGFpbmluZyByZWZpbmVtZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBjdXJyRGVmLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBjdXJyRGVmLnNoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgbmV3U2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXdTaGFwZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG9taXQoc2NoZW1hLCBtYXNrKSB7XG4gICAgY29uc3QgY3VyckRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBjaGVja3MgPSBjdXJyRGVmLmNoZWNrcztcbiAgICBjb25zdCBoYXNDaGVja3MgPSBjaGVja3MgJiYgY2hlY2tzLmxlbmd0aCA+IDA7XG4gICAgaWYgKGhhc0NoZWNrcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCIub21pdCgpIGNhbm5vdCBiZSB1c2VkIG9uIG9iamVjdCBzY2hlbWFzIGNvbnRhaW5pbmcgcmVmaW5lbWVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSB9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWFzaykge1xuICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBjdXJyRGVmLnNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdTaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIG5ld1NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gbmV3U2hhcGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQoc2NoZW1hLCBzaGFwZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzaGFwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBleHRlbmQ6IGV4cGVjdGVkIGEgcGxhaW4gb2JqZWN0XCIpO1xuICAgIH1cbiAgICBjb25zdCBjaGVja3MgPSBzY2hlbWEuX3pvZC5kZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIC8vIE9ubHkgdGhyb3cgaWYgbmV3IHNoYXBlIG92ZXJsYXBzIHdpdGggZXhpc3Rpbmcgc2hhcGVcbiAgICAgICAgLy8gVXNlIGdldE93blByb3BlcnR5RGVzY3JpcHRvciB0byBjaGVjayBrZXkgZXhpc3RlbmNlIHdpdGhvdXQgYWNjZXNzaW5nIHZhbHVlc1xuICAgICAgICBjb25zdCBleGlzdGluZ1NoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZXhpc3RpbmdTaGFwZSwga2V5KSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG92ZXJ3cml0ZSBrZXlzIG9uIG9iamVjdCBzY2hlbWFzIGNvbnRhaW5pbmcgcmVmaW5lbWVudHMuIFVzZSBgLnNhZmVFeHRlbmQoKWAgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBfc2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSwgLi4uc2hhcGUgfTtcbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzYWZlRXh0ZW5kKHNjaGVtYSwgc2hhcGUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3Qoc2hhcGUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gc2FmZUV4dGVuZDogZXhwZWN0ZWQgYSBwbGFpbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5zY2hlbWEuX3pvZC5kZWYuc2hhcGUsIC4uLnNoYXBlIH07XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gX3NoYXBlO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xuICAgIGNvbnN0IGRlZiA9IG1lcmdlRGVmcyhhLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zaGFwZSA9IHsgLi4uYS5fem9kLmRlZi5zaGFwZSwgLi4uYi5fem9kLmRlZi5zaGFwZSB9O1xuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIF9zaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIF9zaGFwZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGNhdGNoYWxsKCkge1xuICAgICAgICAgICAgcmV0dXJuIGIuX3pvZC5kZWYuY2F0Y2hhbGw7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sIC8vIGRlbGV0ZSBleGlzdGluZyBjaGVja3NcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsKENsYXNzLCBzY2hlbWEsIG1hc2spIHtcbiAgICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGNoZWNrcyA9IGN1cnJEZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5wYXJ0aWFsKCkgY2Fubm90IGJlIHVzZWQgb24gb2JqZWN0IHNjaGVtYXMgY29udGFpbmluZyByZWZpbmVtZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBvbGRTaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChvbGRTaGFwZVtrZXldIS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IENsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb2xkU2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiAob2xkU2hhcGVba2V5XSEuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IENsYXNzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IG5ldyBDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9sZFNoYXBlW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIHNoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXF1aXJlZChDbGFzcywgc2NoZW1hLCBtYXNrKSB7XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBvbGRTaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0geyAuLi5vbGRTaGFwZSB9O1xuICAgICAgICAgICAgaWYgKG1hc2spIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBzaGFwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghbWFza1trZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSB3aXRoIG5vbi1vcHRpb25hbFxuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gbmV3IENsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlubmVyVHlwZTogb2xkU2hhcGVba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2xkU2hhcGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHdpdGggbm9uLW9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBuZXcgQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuLy8gaW52YWxpZF90eXBlIHwgdG9vX2JpZyB8IHRvb19zbWFsbCB8IGludmFsaWRfZm9ybWF0IHwgbm90X211bHRpcGxlX29mIHwgdW5yZWNvZ25pemVkX2tleXMgfCBpbnZhbGlkX3VuaW9uIHwgaW52YWxpZF9rZXkgfCBpbnZhbGlkX2VsZW1lbnQgfCBpbnZhbGlkX3ZhbHVlIHwgY3VzdG9tXG5leHBvcnQgZnVuY3Rpb24gYWJvcnRlZCh4LCBzdGFydEluZGV4ID0gMCkge1xuICAgIGlmICh4LmFib3J0ZWQgPT09IHRydWUpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgeC5pc3N1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHguaXNzdWVzW2ldPy5jb250aW51ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZWZpeElzc3VlcyhwYXRoLCBpc3N1ZXMpIHtcbiAgICByZXR1cm4gaXNzdWVzLm1hcCgoaXNzKSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gaXNzKS5wYXRoID8/IChfYS5wYXRoID0gW10pO1xuICAgICAgICBpc3MucGF0aC51bnNoaWZ0KHBhdGgpO1xuICAgICAgICByZXR1cm4gaXNzO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcE1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHJldHVybiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlPy5tZXNzYWdlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZykge1xuICAgIGNvbnN0IGZ1bGwgPSB7IC4uLmlzcywgcGF0aDogaXNzLnBhdGggPz8gW10gfTtcbiAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICBpZiAoIWlzcy5tZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB1bndyYXBNZXNzYWdlKGlzcy5pbnN0Py5fem9kLmRlZj8uZXJyb3I/Lihpc3MpKSA/P1xuICAgICAgICAgICAgdW53cmFwTWVzc2FnZShjdHg/LmVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIHVud3JhcE1lc3NhZ2UoY29uZmlnLmN1c3RvbUVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIHVud3JhcE1lc3NhZ2UoY29uZmlnLmxvY2FsZUVycm9yPy4oaXNzKSkgPz9cbiAgICAgICAgICAgIFwiSW52YWxpZCBpbnB1dFwiO1xuICAgICAgICBmdWxsLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICAvLyBkZWxldGUgKGZ1bGwgYXMgYW55KS5kZWY7XG4gICAgZGVsZXRlIGZ1bGwuaW5zdDtcbiAgICBkZWxldGUgZnVsbC5jb250aW51ZTtcbiAgICBpZiAoIWN0eD8ucmVwb3J0SW5wdXQpIHtcbiAgICAgICAgZGVsZXRlIGZ1bGwuaW5wdXQ7XG4gICAgfVxuICAgIHJldHVybiBmdWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFNpemFibGVPcmlnaW4oaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQgaW5zdGFuY2VvZiBTZXQpXG4gICAgICAgIHJldHVybiBcInNldFwiO1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIE1hcClcbiAgICAgICAgcmV0dXJuIFwibWFwXCI7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgIHJldHVybiBcImZpbGVcIjtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSlcbiAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgICByZXR1cm4gXCJ1bmtub3duXCI7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VkVHlwZShkYXRhKSB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6IHtcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBcIm5hblwiIDogXCJudW1iZXJcIjtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb2JqID0gZGF0YTtcbiAgICAgICAgICAgIGlmIChvYmogJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaikgIT09IE9iamVjdC5wcm90b3R5cGUgJiYgXCJjb25zdHJ1Y3RvclwiIGluIG9iaiAmJiBvYmouY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JqLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNzdWUoLi4uYXJncykge1xuICAgIGNvbnN0IFtpc3MsIGlucHV0LCBpbnN0XSA9IGFyZ3M7XG4gICAgaWYgKHR5cGVvZiBpc3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzcyxcbiAgICAgICAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmlzcyB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuRW51bShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMob2JqKVxuICAgICAgICAuZmlsdGVyKChbaywgX10pID0+IHtcbiAgICAgICAgLy8gcmV0dXJuIHRydWUgaWYgTmFOLCBtZWFuaW5nIGl0J3Mgbm90IGEgbnVtYmVyLCB0aHVzIGEgc3RyaW5nIGtleVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzTmFOKE51bWJlci5wYXJzZUludChrLCAxMCkpO1xuICAgIH0pXG4gICAgICAgIC5tYXAoKGVsKSA9PiBlbFsxXSk7XG59XG4vLyBDb2RlYyB1dGlsaXR5IGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NFRvVWludDhBcnJheShiYXNlNjQpIHtcbiAgICBjb25zdCBiaW5hcnlTdHJpbmcgPSBhdG9iKGJhc2U2NCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShiaW5hcnlTdHJpbmcubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmFyeVN0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICBieXRlc1tpXSA9IGJpbmFyeVN0cmluZy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvQmFzZTY0KGJ5dGVzKSB7XG4gICAgbGV0IGJpbmFyeVN0cmluZyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBiaW5hcnlTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSk7XG4gICAgfVxuICAgIHJldHVybiBidG9hKGJpbmFyeVN0cmluZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0dXJsVG9VaW50OEFycmF5KGJhc2U2NHVybCkge1xuICAgIGNvbnN0IGJhc2U2NCA9IGJhc2U2NHVybC5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgICBjb25zdCBwYWRkaW5nID0gXCI9XCIucmVwZWF0KCg0IC0gKGJhc2U2NC5sZW5ndGggJSA0KSkgJSA0KTtcbiAgICByZXR1cm4gYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NCArIHBhZGRpbmcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0Jhc2U2NHVybChieXRlcykge1xuICAgIHJldHVybiB1aW50OEFycmF5VG9CYXNlNjQoYnl0ZXMpLnJlcGxhY2UoL1xcKy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC89L2csIFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvVWludDhBcnJheShoZXgpIHtcbiAgICBjb25zdCBjbGVhbkhleCA9IGhleC5yZXBsYWNlKC9eMHgvLCBcIlwiKTtcbiAgICBpZiAoY2xlYW5IZXgubGVuZ3RoICUgMiAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGhleCBzdHJpbmcgbGVuZ3RoXCIpO1xuICAgIH1cbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGNsZWFuSGV4Lmxlbmd0aCAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2xlYW5IZXgubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgYnl0ZXNbaSAvIDJdID0gTnVtYmVyLnBhcnNlSW50KGNsZWFuSGV4LnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG59XG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvSGV4KGJ5dGVzKSB7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oYnl0ZXMpXG4gICAgICAgIC5tYXAoKGIpID0+IGIudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKSlcbiAgICAgICAgLmpvaW4oXCJcIik7XG59XG4vLyBpbnN0YW5jZW9mXG5leHBvcnQgY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKC4uLl9hcmdzKSB7IH1cbn1cbiIsICJpbXBvcnQgeyAkY29uc3RydWN0b3IgfSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmNvbnN0IGluaXRpYWxpemVyID0gKGluc3QsIGRlZikgPT4ge1xuICAgIGluc3QubmFtZSA9IFwiJFpvZEVycm9yXCI7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX3pvZFwiLCB7XG4gICAgICAgIHZhbHVlOiBpbnN0Ll96b2QsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImlzc3Vlc1wiLCB7XG4gICAgICAgIHZhbHVlOiBkZWYsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIH0pO1xuICAgIGluc3QubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGRlZiwgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcInRvU3RyaW5nXCIsIHtcbiAgICAgICAgdmFsdWU6ICgpID0+IGluc3QubWVzc2FnZSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG59O1xuZXhwb3J0IGNvbnN0ICRab2RFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplcik7XG5leHBvcnQgY29uc3QgJFpvZFJlYWxFcnJvciA9ICRjb25zdHJ1Y3RvcihcIiRab2RFcnJvclwiLCBpbml0aWFsaXplciwgeyBQYXJlbnQ6IEVycm9yIH0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZsYXR0ZW5FcnJvcihlcnJvciwgbWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSB7fTtcbiAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgZm9yIChjb25zdCBzdWIgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgIGlmIChzdWIucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG4gICAgICAgICAgICBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0ucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3JtRXJyb3JzLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGZvcm1FcnJvcnMsIGZpZWxkRXJyb3JzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyb3IsIG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpc3N1ZS5lcnJvcnMubWFwKChpc3N1ZXMpID0+IHByb2Nlc3NFcnJvcih7IGlzc3VlcyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfa2V5XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlLmlzc3VlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9lbGVtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlLmlzc3VlcyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmllbGRFcnJvcnMuX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnIgPSBmaWVsZEVycm9ycztcbiAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGlzc3VlLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gaXNzdWUucGF0aC5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyW2VsXTtcbiAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcHJvY2Vzc0Vycm9yKGVycm9yKTtcbiAgICByZXR1cm4gZmllbGRFcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdHJlZWlmeUVycm9yKGVycm9yLCBtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7IGVycm9yczogW10gfTtcbiAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IsIHBhdGggPSBbXSkgPT4ge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGVycm9yLmlzc3Vlcykge1xuICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyByZWd1bGFyIHVuaW9uIGVycm9yXG4gICAgICAgICAgICAgICAgaXNzdWUuZXJyb3JzLm1hcCgoaXNzdWVzKSA9PiBwcm9jZXNzRXJyb3IoeyBpc3N1ZXMgfSwgaXNzdWUucGF0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2tleVwiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZS5pc3N1ZXMgfSwgaXNzdWUucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfZWxlbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzc0Vycm9yKHsgaXNzdWVzOiBpc3N1ZS5pc3N1ZXMgfSwgaXNzdWUucGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxscGF0aCA9IFsuLi5wYXRoLCAuLi5pc3N1ZS5wYXRoXTtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjdXJyID0gcmVzdWx0O1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGZ1bGxwYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGZ1bGxwYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXJtaW5hbCA9IGkgPT09IGZ1bGxwYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIucHJvcGVydGllcyA/PyAoY3Vyci5wcm9wZXJ0aWVzID0ge30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gY3Vyci5wcm9wZXJ0aWVzKVtlbF0gPz8gKF9hW2VsXSA9IHsgZXJyb3JzOiBbXSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnIgPSBjdXJyLnByb3BlcnRpZXNbZWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyci5pdGVtcyA/PyAoY3Vyci5pdGVtcyA9IFtdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYiA9IGN1cnIuaXRlbXMpW2VsXSA/PyAoX2JbZWxdID0geyBlcnJvcnM6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnIuaXRlbXNbZWxdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyci5lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKiogRm9ybWF0IGEgWm9kRXJyb3IgYXMgYSBodW1hbi1yZWFkYWJsZSBzdHJpbmcgaW4gdGhlIGZvbGxvd2luZyBmb3JtLlxuICpcbiAqIEZyb21cbiAqXG4gKiBgYGB0c1xuICogWm9kRXJyb3Ige1xuICogICBpc3N1ZXM6IFtcbiAqICAgICB7XG4gKiAgICAgICBleHBlY3RlZDogJ3N0cmluZycsXG4gKiAgICAgICBjb2RlOiAnaW52YWxpZF90eXBlJyxcbiAqICAgICAgIHBhdGg6IFsgJ3VzZXJuYW1lJyBdLFxuICogICAgICAgbWVzc2FnZTogJ0ludmFsaWQgaW5wdXQ6IGV4cGVjdGVkIHN0cmluZydcbiAqICAgICB9LFxuICogICAgIHtcbiAqICAgICAgIGV4cGVjdGVkOiAnbnVtYmVyJyxcbiAqICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICogICAgICAgcGF0aDogWyAnZmF2b3JpdGVOdW1iZXJzJywgMSBdLFxuICogICAgICAgbWVzc2FnZTogJ0ludmFsaWQgaW5wdXQ6IGV4cGVjdGVkIG51bWJlcidcbiAqICAgICB9XG4gKiAgIF07XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiB0b1xuICpcbiAqIGBgYFxuICogdXNlcm5hbWVcbiAqICAgXHUyNzE2IEV4cGVjdGVkIG51bWJlciwgcmVjZWl2ZWQgc3RyaW5nIGF0IFwidXNlcm5hbWVcbiAqIGZhdm9yaXRlTnVtYmVyc1swXVxuICogICBcdTI3MTYgSW52YWxpZCBpbnB1dDogZXhwZWN0ZWQgbnVtYmVyXG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvRG90UGF0aChfcGF0aCkge1xuICAgIGNvbnN0IHNlZ3MgPSBbXTtcbiAgICBjb25zdCBwYXRoID0gX3BhdGgubWFwKChzZWcpID0+ICh0eXBlb2Ygc2VnID09PSBcIm9iamVjdFwiID8gc2VnLmtleSA6IHNlZykpO1xuICAgIGZvciAoY29uc3Qgc2VnIG9mIHBhdGgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZWcgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBzZWdzLnB1c2goYFske3NlZ31dYCk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzZWcgPT09IFwic3ltYm9sXCIpXG4gICAgICAgICAgICBzZWdzLnB1c2goYFske0pTT04uc3RyaW5naWZ5KFN0cmluZyhzZWcpKX1dYCk7XG4gICAgICAgIGVsc2UgaWYgKC9bXlxcdyRdLy50ZXN0KHNlZykpXG4gICAgICAgICAgICBzZWdzLnB1c2goYFske0pTT04uc3RyaW5naWZ5KHNlZyl9XWApO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzZWdzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBzZWdzLnB1c2goXCIuXCIpO1xuICAgICAgICAgICAgc2Vncy5wdXNoKHNlZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlZ3Muam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcmV0dGlmeUVycm9yKGVycm9yKSB7XG4gICAgY29uc3QgbGluZXMgPSBbXTtcbiAgICAvLyBzb3J0IGJ5IHBhdGggbGVuZ3RoXG4gICAgY29uc3QgaXNzdWVzID0gWy4uLmVycm9yLmlzc3Vlc10uc29ydCgoYSwgYikgPT4gKGEucGF0aCA/PyBbXSkubGVuZ3RoIC0gKGIucGF0aCA/PyBbXSkubGVuZ3RoKTtcbiAgICAvLyBQcm9jZXNzIGVhY2ggaXNzdWVcbiAgICBmb3IgKGNvbnN0IGlzc3VlIG9mIGlzc3Vlcykge1xuICAgICAgICBsaW5lcy5wdXNoKGBcdTI3MTYgJHtpc3N1ZS5tZXNzYWdlfWApO1xuICAgICAgICBpZiAoaXNzdWUucGF0aD8ubGVuZ3RoKVxuICAgICAgICAgICAgbGluZXMucHVzaChgICBcdTIxOTIgYXQgJHt0b0RvdFBhdGgoaXNzdWUucGF0aCl9YCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgTWFwIHRvIGZvcm1hdHRlZCBzdHJpbmdcbiAgICByZXR1cm4gbGluZXMuam9pbihcIlxcblwiKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuL2NvcmUuanNcIjtcbmltcG9ydCAqIGFzIGVycm9ycyBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0IF9wYXJzZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IGZhbHNlIH0pIDogeyBhc3luYzogZmFsc2UgfTtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlID0gbmV3IChfcGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpO1xuICAgICAgICB1dGlsLmNhcHR1cmVTdGFja1RyYWNlKGUsIF9wYXJhbXM/LmNhbGxlZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHBhcnNlID0gLyogQF9fUFVSRV9fKi8gX3BhcnNlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfcGFyc2VBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBlID0gbmV3IChwYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSk7XG4gICAgICAgIHV0aWwuY2FwdHVyZVN0YWNrVHJhY2UoZSwgcGFyYW1zPy5jYWxsZWUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBwYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX3BhcnNlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlUGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8geyAuLi5fY3R4LCBhc3luYzogZmFsc2UgfSA6IHsgYXN5bmM6IGZhbHNlIH07XG4gICAgY29uc3QgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGhcbiAgICAgICAgPyB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICAgIGVycm9yOiBuZXcgKF9FcnIgPz8gZXJyb3JzLiRab2RFcnJvcikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpLFxuICAgICAgICB9XG4gICAgICAgIDogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZVBhcnNlID0gLyogQF9fUFVSRV9fKi8gX3NhZmVQYXJzZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVQYXJzZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcbiAgICBsZXQgcmVzdWx0ID0gc2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuICAgIHJldHVybiByZXN1bHQuaXNzdWVzLmxlbmd0aFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyBfRXJyKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKSxcbiAgICAgICAgfVxuICAgICAgICA6IHsgc3VjY2VzczogdHJ1ZSwgZGF0YTogcmVzdWx0LnZhbHVlIH07XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVQYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX3NhZmVQYXJzZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfZW5jb2RlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9KSA6IHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfTtcbiAgICByZXR1cm4gX3BhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZSA9IC8qIEBfX1BVUkVfXyovIF9lbmNvZGUoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9kZWNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3BhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGUgPSAvKiBAX19QVVJFX18qLyBfZGVjb2RlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfZW5jb2RlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH0pIDogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9O1xuICAgIHJldHVybiBfcGFyc2VBc3luYyhfRXJyKShzY2hlbWEsIHZhbHVlLCBjdHgpO1xufTtcbmV4cG9ydCBjb25zdCBlbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9lbmNvZGVBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX2RlY29kZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgcmV0dXJuIF9wYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBkZWNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9kZWNvZGVBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVFbmNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH0pIDogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9O1xuICAgIHJldHVybiBfc2FmZVBhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVFbmNvZGUgPSAvKiBAX19QVVJFX18qLyBfc2FmZUVuY29kZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVEZWNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3NhZmVQYXJzZShfRXJyKShzY2hlbWEsIHZhbHVlLCBfY3R4KTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZURlY29kZSA9IC8qIEBfX1BVUkVfXyovIF9zYWZlRGVjb2RlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZUVuY29kZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9KSA6IHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfTtcbiAgICByZXR1cm4gX3NhZmVQYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVFbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9zYWZlRW5jb2RlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlRGVjb2RlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3NhZmVQYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlRGVjb2RlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfc2FmZURlY29kZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbiIsICJpbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCBjdWlkID0gL15bY0NdW15cXHMtXXs4LH0kLztcbmV4cG9ydCBjb25zdCBjdWlkMiA9IC9eWzAtOWEtel0rJC87XG5leHBvcnQgY29uc3QgdWxpZCA9IC9eWzAtOUEtSEpLTU5QLVRWLVphLWhqa21ucC10di16XXsyNn0kLztcbmV4cG9ydCBjb25zdCB4aWQgPSAvXlswLTlhLXZBLVZdezIwfSQvO1xuZXhwb3J0IGNvbnN0IGtzdWlkID0gL15bQS1aYS16MC05XXsyN30kLztcbmV4cG9ydCBjb25zdCBuYW5vaWQgPSAvXlthLXpBLVowLTlfLV17MjF9JC87XG4vKiogSVNPIDg2MDEtMSBkdXJhdGlvbiByZWdleC4gRG9lcyBub3Qgc3VwcG9ydCB0aGUgODYwMS0yIGV4dGVuc2lvbnMgbGlrZSBuZWdhdGl2ZSBkdXJhdGlvbnMgb3IgZnJhY3Rpb25hbC9uZWdhdGl2ZSBjb21wb25lbnRzLiAqL1xuZXhwb3J0IGNvbnN0IGR1cmF0aW9uID0gL15QKD86KFxcZCtXKXwoPyEuKlcpKD89XFxkfFRcXGQpKFxcZCtZKT8oXFxkK00pPyhcXGQrRCk/KFQoPz1cXGQpKFxcZCtIKT8oXFxkK00pPyhcXGQrKFsuLF1cXGQrKT9TKT8pPykkLztcbi8qKiBJbXBsZW1lbnRzIElTTyA4NjAxLTIgZXh0ZW5zaW9ucyBsaWtlIGV4cGxpY2l0ICstIHByZWZpeGVzLCBtaXhpbmcgd2Vla3Mgd2l0aCBvdGhlciB1bml0cywgYW5kIGZyYWN0aW9uYWwvbmVnYXRpdmUgY29tcG9uZW50cy4gKi9cbmV4cG9ydCBjb25zdCBleHRlbmRlZER1cmF0aW9uID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8qKiBBIHJlZ2V4IGZvciBhbnkgVVVJRC1saWtlIGlkZW50aWZpZXI6IDgtNC00LTQtMTIgaGV4IHBhdHRlcm4gKi9cbmV4cG9ydCBjb25zdCBndWlkID0gL14oWzAtOWEtZkEtRl17OH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17NH0tWzAtOWEtZkEtRl17MTJ9KSQvO1xuLyoqIFJldHVybnMgYSByZWdleCBmb3IgdmFsaWRhdGluZyBhbiBSRkMgOTU2Mi80MTIyIFVVSUQuXG4gKlxuICogQHBhcmFtIHZlcnNpb24gT3B0aW9uYWxseSBzcGVjaWZ5IGEgdmVyc2lvbiAxLTguIElmIG5vIHZlcnNpb24gaXMgc3BlY2lmaWVkLCBhbGwgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZC4gKi9cbmV4cG9ydCBjb25zdCB1dWlkID0gKHZlcnNpb24pID0+IHtcbiAgICBpZiAoIXZlcnNpb24pXG4gICAgICAgIHJldHVybiAvXihbMC05YS1mQS1GXXs4fS1bMC05YS1mQS1GXXs0fS1bMS04XVswLTlhLWZBLUZdezN9LVs4OWFiQUJdWzAtOWEtZkEtRl17M30tWzAtOWEtZkEtRl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMHxmZmZmZmZmZi1mZmZmLWZmZmYtZmZmZi1mZmZmZmZmZmZmZmYpJC87XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oWzAtOWEtZkEtRl17OH0tWzAtOWEtZkEtRl17NH0tJHt2ZXJzaW9ufVswLTlhLWZBLUZdezN9LVs4OWFiQUJdWzAtOWEtZkEtRl17M30tWzAtOWEtZkEtRl17MTJ9KSRgKTtcbn07XG5leHBvcnQgY29uc3QgdXVpZDQgPSAvKkBfX1BVUkVfXyovIHV1aWQoNCk7XG5leHBvcnQgY29uc3QgdXVpZDYgPSAvKkBfX1BVUkVfXyovIHV1aWQoNik7XG5leHBvcnQgY29uc3QgdXVpZDcgPSAvKkBfX1BVUkVfXyovIHV1aWQoNyk7XG4vKiogUHJhY3RpY2FsIGVtYWlsIHZhbGlkYXRpb24gKi9cbmV4cG9ydCBjb25zdCBlbWFpbCA9IC9eKD8hXFwuKSg/IS4qXFwuXFwuKShbQS1aYS16MC05XycrXFwtXFwuXSopW0EtWmEtejAtOV8rLV1AKFtBLVphLXowLTldW0EtWmEtejAtOVxcLV0qXFwuKStbQS1aYS16XXsyLH0kLztcbi8qKiBFcXVpdmFsZW50IHRvIHRoZSBIVE1MNSBpbnB1dFt0eXBlPWVtYWlsXSB2YWxpZGF0aW9uIGltcGxlbWVudGVkIGJ5IGJyb3dzZXJzLiBTb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0hUTUwvRWxlbWVudC9pbnB1dC9lbWFpbCAqL1xuZXhwb3J0IGNvbnN0IGh0bWw1RW1haWwgPSAvXlthLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vKiogVGhlIGNsYXNzaWMgZW1haWxyZWdleC5jb20gcmVnZXggZm9yIFJGQyA1MzIyLWNvbXBsaWFudCBlbWFpbHMgKi9cbmV4cG9ydCBjb25zdCByZmM1MzIyRW1haWwgPSAvXigoW148PigpXFxbXFxdXFxcXC4sOzpcXHNAXCJdKyhcXC5bXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKSopfChcIi4rXCIpKUAoKFxcW1swLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfVxcLlswLTldezEsM31dKXwoKFthLXpBLVpcXC0wLTldK1xcLikrW2EtekEtWl17Mix9KSkkLztcbi8qKiBBIGxvb3NlIHJlZ2V4IHRoYXQgYWxsb3dzIFVuaWNvZGUgY2hhcmFjdGVycywgZW5mb3JjZXMgbGVuZ3RoIGxpbWl0cywgYW5kIHRoYXQncyBhYm91dCBpdC4gKi9cbmV4cG9ydCBjb25zdCB1bmljb2RlRW1haWwgPSAvXlteXFxzQFwiXXsxLDY0fUBbXlxcc0BdezEsMjU1fSQvdTtcbmV4cG9ydCBjb25zdCBpZG5FbWFpbCA9IHVuaWNvZGVFbWFpbDtcbmV4cG9ydCBjb25zdCBicm93c2VyRW1haWwgPSAvXlthLXpBLVowLTkuISMkJSYnKisvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG4vLyBmcm9tIGh0dHBzOi8vdGhla2V2aW5zY290dC5jb20vZW1vamlzLWluLWphdmFzY3JpcHQvI3dyaXRpbmctYS1yZWd1bGFyLWV4cHJlc3Npb25cbmNvbnN0IF9lbW9qaSA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5leHBvcnQgZnVuY3Rpb24gZW1vamkoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoX2Vtb2ppLCBcInVcIik7XG59XG5leHBvcnQgY29uc3QgaXB2NCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5leHBvcnQgY29uc3QgaXB2NiA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7N31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318OikpJC87XG5leHBvcnQgY29uc3QgbWFjID0gKGRlbGltaXRlcikgPT4ge1xuICAgIGNvbnN0IGVzY2FwZWREZWxpbSA9IHV0aWwuZXNjYXBlUmVnZXgoZGVsaW1pdGVyID8/IFwiOlwiKTtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXig/OlswLTlBLUZdezJ9JHtlc2NhcGVkRGVsaW19KXs1fVswLTlBLUZdezJ9JHxeKD86WzAtOWEtZl17Mn0ke2VzY2FwZWREZWxpbX0pezV9WzAtOWEtZl17Mn0kYCk7XG59O1xuZXhwb3J0IGNvbnN0IGNpZHJ2NCA9IC9eKCgyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSgyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKFswLTldfFsxLTJdWzAtOV18M1swLTJdKSQvO1xuZXhwb3J0IGNvbnN0IGNpZHJ2NiA9IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7N31bMC05YS1mQS1GXXsxLDR9fDo6fChbMC05YS1mQS1GXXsxLDR9KT86OihbMC05YS1mQS1GXXsxLDR9Oj8pezAsNn0pXFwvKDEyWzAtOF18MVswMV1bMC05XXxbMS05XT9bMC05XSkkLztcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzc4NjAzOTIvZGV0ZXJtaW5lLWlmLXN0cmluZy1pcy1pbi1iYXNlNjQtdXNpbmctamF2YXNjcmlwdFxuZXhwb3J0IGNvbnN0IGJhc2U2NCA9IC9eJHxeKD86WzAtOWEtekEtWisvXXs0fSkqKD86KD86WzAtOWEtekEtWisvXXsyfT09KXwoPzpbMC05YS16QS1aKy9dezN9PSkpPyQvO1xuZXhwb3J0IGNvbnN0IGJhc2U2NHVybCA9IC9eW0EtWmEtejAtOV8tXSokLztcbi8vIGJhc2VkIG9uIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzEwNjE3OS9yZWd1bGFyLWV4cHJlc3Npb24tdG8tbWF0Y2gtZG5zLWhvc3RuYW1lLW9yLWlwLWFkZHJlc3Ncbi8vIGV4cG9ydCBjb25zdCBob3N0bmFtZTogUmVnRXhwID0gL14oW2EtekEtWjAtOS1dK1xcLikqW2EtekEtWjAtOS1dKyQvO1xuZXhwb3J0IGNvbnN0IGhvc3RuYW1lID0gL14oPz0uezEsMjUzfVxcLj8kKVthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86Wy0wLTlhLXpBLVpdezAsNjF9WzAtOWEtekEtWl0pPykqXFwuPyQvO1xuZXhwb3J0IGNvbnN0IGRvbWFpbiA9IC9eKFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pP1xcLikrW2EtekEtWl17Mix9JC87XG4vLyBodHRwczovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL3ZhbGlkYXRlLXBob25lLW51bWJlciNyNC0zIChyZWdleCBzYW5zIHNwYWNlcylcbi8vIEUuMTY0OiBsZWFkaW5nIGRpZ2l0IG11c3QgYmUgMS05OyB0b3RhbCBkaWdpdHMgKGV4Y2x1ZGluZyAnKycpIGJldHdlZW4gNy0xNVxuZXhwb3J0IGNvbnN0IGUxNjQgPSAvXlxcK1sxLTldXFxkezYsMTR9JC87XG4vLyBjb25zdCBkYXRlU291cmNlID0gYCgoXFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKCgwWzEzNTc4XXwxWzAyXSktKDBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCgwWzQ2OV18MTEpLSgwWzEtOV18WzEyXVxcXFxkfDMwKXwoMDIpLSgwWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5jb25zdCBkYXRlU291cmNlID0gYCg/Oig/OlxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSg/Oig/OjBbMTM1NzhdfDFbMDJdKS0oPzowWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoPzowWzQ2OV18MTEpLSg/OjBbMS05XXxbMTJdXFxcXGR8MzApfCg/OjAyKS0oPzowWzEtOV18MVxcXFxkfDJbMC04XSkpKWA7XG5leHBvcnQgY29uc3QgZGF0ZSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJlZ0V4cChgXiR7ZGF0ZVNvdXJjZX0kYCk7XG5mdW5jdGlvbiB0aW1lU291cmNlKGFyZ3MpIHtcbiAgICBjb25zdCBoaG1tID0gYCg/OlswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGRgO1xuICAgIGNvbnN0IHJlZ2V4ID0gdHlwZW9mIGFyZ3MucHJlY2lzaW9uID09PSBcIm51bWJlclwiXG4gICAgICAgID8gYXJncy5wcmVjaXNpb24gPT09IC0xXG4gICAgICAgICAgICA/IGAke2hobW19YFxuICAgICAgICAgICAgOiBhcmdzLnByZWNpc2lvbiA9PT0gMFxuICAgICAgICAgICAgICAgID8gYCR7aGhtbX06WzAtNV1cXFxcZGBcbiAgICAgICAgICAgICAgICA6IGAke2hobW19OlswLTVdXFxcXGRcXFxcLlxcXFxkeyR7YXJncy5wcmVjaXNpb259fWBcbiAgICAgICAgOiBgJHtoaG1tfSg/OjpbMC01XVxcXFxkKD86XFxcXC5cXFxcZCspPyk/YDtcbiAgICByZXR1cm4gcmVnZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gdGltZShhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVTb3VyY2UoYXJncyl9JGApO1xufVxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zMTQzMjMxXG5leHBvcnQgZnVuY3Rpb24gZGF0ZXRpbWUoYXJncykge1xuICAgIGNvbnN0IHRpbWUgPSB0aW1lU291cmNlKHsgcHJlY2lzaW9uOiBhcmdzLnByZWNpc2lvbiB9KTtcbiAgICBjb25zdCBvcHRzID0gW1wiWlwiXTtcbiAgICBpZiAoYXJncy5sb2NhbClcbiAgICAgICAgb3B0cy5wdXNoKFwiXCIpO1xuICAgIC8vIGlmIChhcmdzLm9mZnNldCkgb3B0cy5wdXNoKGAoWystXVxcXFxkezJ9OlxcXFxkezJ9KWApO1xuICAgIGlmIChhcmdzLm9mZnNldClcbiAgICAgICAgb3B0cy5wdXNoKGAoWystXSg/OlswMV1cXFxcZHwyWzAtM10pOlswLTVdXFxcXGQpYCk7XG4gICAgY29uc3QgdGltZVJlZ2V4ID0gYCR7dGltZX0oPzoke29wdHMuam9pbihcInxcIil9KWA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke2RhdGVTb3VyY2V9VCg/OiR7dGltZVJlZ2V4fSkkYCk7XG59XG5leHBvcnQgY29uc3Qgc3RyaW5nID0gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHJlZ2V4ID0gcGFyYW1zID8gYFtcXFxcc1xcXFxTXXske3BhcmFtcz8ubWluaW11bSA/PyAwfSwke3BhcmFtcz8ubWF4aW11bSA/PyBcIlwifX1gIDogYFtcXFxcc1xcXFxTXSpgO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59O1xuZXhwb3J0IGNvbnN0IGJpZ2ludCA9IC9eLT9cXGQrbj8kLztcbmV4cG9ydCBjb25zdCBpbnRlZ2VyID0gL14tP1xcZCskLztcbmV4cG9ydCBjb25zdCBudW1iZXIgPSAvXi0/XFxkKyg/OlxcLlxcZCspPyQvO1xuZXhwb3J0IGNvbnN0IGJvb2xlYW4gPSAvXig/OnRydWV8ZmFsc2UpJC9pO1xuY29uc3QgX251bGwgPSAvXm51bGwkL2k7XG5leHBvcnQgeyBfbnVsbCBhcyBudWxsIH07XG5jb25zdCBfdW5kZWZpbmVkID0gL151bmRlZmluZWQkL2k7XG5leHBvcnQgeyBfdW5kZWZpbmVkIGFzIHVuZGVmaW5lZCB9O1xuLy8gcmVnZXggZm9yIHN0cmluZyB3aXRoIG5vIHVwcGVyY2FzZSBsZXR0ZXJzXG5leHBvcnQgY29uc3QgbG93ZXJjYXNlID0gL15bXkEtWl0qJC87XG4vLyByZWdleCBmb3Igc3RyaW5nIHdpdGggbm8gbG93ZXJjYXNlIGxldHRlcnNcbmV4cG9ydCBjb25zdCB1cHBlcmNhc2UgPSAvXlteYS16XSokLztcbi8vIHJlZ2V4IGZvciBoZXhhZGVjaW1hbCBzdHJpbmdzIChhbnkgbGVuZ3RoKVxuZXhwb3J0IGNvbnN0IGhleCA9IC9eWzAtOWEtZkEtRl0qJC87XG4vLyBIYXNoIHJlZ2V4ZXMgZm9yIGRpZmZlcmVudCBhbGdvcml0aG1zIGFuZCBlbmNvZGluZ3Ncbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYmFzZTY0IHJlZ2V4IHdpdGggZXhhY3QgbGVuZ3RoIGFuZCBwYWRkaW5nXG5mdW5jdGlvbiBmaXhlZEJhc2U2NChib2R5TGVuZ3RoLCBwYWRkaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5bQS1aYS16MC05Ky9deyR7Ym9keUxlbmd0aH19JHtwYWRkaW5nfSRgKTtcbn1cbi8vIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYmFzZTY0dXJsIHJlZ2V4IHdpdGggZXhhY3QgbGVuZ3RoIChubyBwYWRkaW5nKVxuZnVuY3Rpb24gZml4ZWRCYXNlNjR1cmwobGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF5bQS1aYS16MC05Xy1deyR7bGVuZ3RofX0kYCk7XG59XG4vLyBNRDUgKDE2IGJ5dGVzKTogYmFzZTY0ID0gMjQgY2hhcnMgdG90YWwgKDIyICsgXCI9PVwiKVxuZXhwb3J0IGNvbnN0IG1kNV9oZXggPSAvXlswLTlhLWZBLUZdezMyfSQvO1xuZXhwb3J0IGNvbnN0IG1kNV9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDIyLCBcIj09XCIpO1xuZXhwb3J0IGNvbnN0IG1kNV9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDIyKTtcbi8vIFNIQTEgKDIwIGJ5dGVzKTogYmFzZTY0ID0gMjggY2hhcnMgdG90YWwgKDI3ICsgXCI9XCIpXG5leHBvcnQgY29uc3Qgc2hhMV9oZXggPSAvXlswLTlhLWZBLUZdezQwfSQvO1xuZXhwb3J0IGNvbnN0IHNoYTFfYmFzZTY0ID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NCgyNywgXCI9XCIpO1xuZXhwb3J0IGNvbnN0IHNoYTFfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCgyNyk7XG4vLyBTSEEyNTYgKDMyIGJ5dGVzKTogYmFzZTY0ID0gNDQgY2hhcnMgdG90YWwgKDQzICsgXCI9XCIpXG5leHBvcnQgY29uc3Qgc2hhMjU2X2hleCA9IC9eWzAtOWEtZkEtRl17NjR9JC87XG5leHBvcnQgY29uc3Qgc2hhMjU2X2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoNDMsIFwiPVwiKTtcbmV4cG9ydCBjb25zdCBzaGEyNTZfYmFzZTY0dXJsID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NHVybCg0Myk7XG4vLyBTSEEzODQgKDQ4IGJ5dGVzKTogYmFzZTY0ID0gNjQgY2hhcnMgdG90YWwgKG5vIHBhZGRpbmcpXG5leHBvcnQgY29uc3Qgc2hhMzg0X2hleCA9IC9eWzAtOWEtZkEtRl17OTZ9JC87XG5leHBvcnQgY29uc3Qgc2hhMzg0X2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoNjQsIFwiXCIpO1xuZXhwb3J0IGNvbnN0IHNoYTM4NF9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDY0KTtcbi8vIFNIQTUxMiAoNjQgYnl0ZXMpOiBiYXNlNjQgPSA4OCBjaGFycyB0b3RhbCAoODYgKyBcIj09XCIpXG5leHBvcnQgY29uc3Qgc2hhNTEyX2hleCA9IC9eWzAtOWEtZkEtRl17MTI4fSQvO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDg2LCBcIj09XCIpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDg2KTtcbiIsICIvLyBpbXBvcnQgeyAkWm9kVHlwZSB9IGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vY29yZS5qc1wiO1xuaW1wb3J0ICogYXMgcmVnZXhlcyBmcm9tIFwiLi9yZWdleGVzLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2sgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaW5zdC5fem9kID8/IChpbnN0Ll96b2QgPSB7fSk7XG4gICAgaW5zdC5fem9kLmRlZiA9IGRlZjtcbiAgICAoX2EgPSBpbnN0Ll96b2QpLm9uYXR0YWNoID8/IChfYS5vbmF0dGFjaCA9IFtdKTtcbn0pO1xuY29uc3QgbnVtZXJpY09yaWdpbk1hcCA9IHtcbiAgICBudW1iZXI6IFwibnVtYmVyXCIsXG4gICAgYmlnaW50OiBcImJpZ2ludFwiLFxuICAgIG9iamVjdDogXCJkYXRlXCIsXG59O1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0xlc3NUaGFuID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0xlc3NUaGFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG51bWVyaWNPcmlnaW5NYXBbdHlwZW9mIGRlZi52YWx1ZV07XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgY29uc3QgY3VyciA9IChkZWYuaW5jbHVzaXZlID8gYmFnLm1heGltdW0gOiBiYWcuZXhjbHVzaXZlTWF4aW11bSkgPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgICBpZiAoZGVmLnZhbHVlIDwgY3Vycikge1xuICAgICAgICAgICAgaWYgKGRlZi5pbmNsdXNpdmUpXG4gICAgICAgICAgICAgICAgYmFnLm1heGltdW0gPSBkZWYudmFsdWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgYmFnLmV4Y2x1c2l2ZU1heGltdW0gPSBkZWYudmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmluY2x1c2l2ZSA/IHBheWxvYWQudmFsdWUgPD0gZGVmLnZhbHVlIDogcGF5bG9hZC52YWx1ZSA8IGRlZi52YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICBtYXhpbXVtOiB0eXBlb2YgZGVmLnZhbHVlID09PSBcIm9iamVjdFwiID8gZGVmLnZhbHVlLmdldFRpbWUoKSA6IGRlZi52YWx1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBkZWYuaW5jbHVzaXZlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrR3JlYXRlclRoYW4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrR3JlYXRlclRoYW5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3Qgb3JpZ2luID0gbnVtZXJpY09yaWdpbk1hcFt0eXBlb2YgZGVmLnZhbHVlXTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBjb25zdCBjdXJyID0gKGRlZi5pbmNsdXNpdmUgPyBiYWcubWluaW11bSA6IGJhZy5leGNsdXNpdmVNaW5pbXVtKSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGlmIChkZWYudmFsdWUgPiBjdXJyKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmluY2x1c2l2ZSlcbiAgICAgICAgICAgICAgICBiYWcubWluaW11bSA9IGRlZi52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiYWcuZXhjbHVzaXZlTWluaW11bSA9IGRlZi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChkZWYuaW5jbHVzaXZlID8gcGF5bG9hZC52YWx1ZSA+PSBkZWYudmFsdWUgOiBwYXlsb2FkLnZhbHVlID4gZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgbWluaW11bTogdHlwZW9mIGRlZi52YWx1ZSA9PT0gXCJvYmplY3RcIiA/IGRlZi52YWx1ZS5nZXRUaW1lKCkgOiBkZWYudmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZGVmLmluY2x1c2l2ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja011bHRpcGxlT2YgPSBcbi8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNdWx0aXBsZU9mXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgKF9hID0gaW5zdC5fem9kLmJhZykubXVsdGlwbGVPZiA/PyAoX2EubXVsdGlwbGVPZiA9IGRlZi52YWx1ZSk7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlICE9PSB0eXBlb2YgZGVmLnZhbHVlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IG1peCBudW1iZXIgYW5kIGJpZ2ludCBpbiBtdWx0aXBsZV9vZiBjaGVjay5cIik7XG4gICAgICAgIGNvbnN0IGlzTXVsdGlwbGUgPSB0eXBlb2YgcGF5bG9hZC52YWx1ZSA9PT0gXCJiaWdpbnRcIlxuICAgICAgICAgICAgPyBwYXlsb2FkLnZhbHVlICUgZGVmLnZhbHVlID09PSBCaWdJbnQoMClcbiAgICAgICAgICAgIDogdXRpbC5mbG9hdFNhZmVSZW1haW5kZXIocGF5bG9hZC52YWx1ZSwgZGVmLnZhbHVlKSA9PT0gMDtcbiAgICAgICAgaWYgKGlzTXVsdGlwbGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiB0eXBlb2YgcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGNvZGU6IFwibm90X211bHRpcGxlX29mXCIsXG4gICAgICAgICAgICBkaXZpc29yOiBkZWYudmFsdWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja051bWJlckZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tOdW1iZXJGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7IC8vIG5vIGZvcm1hdCBjaGVja3NcbiAgICBkZWYuZm9ybWF0ID0gZGVmLmZvcm1hdCB8fCBcImZsb2F0NjRcIjtcbiAgICBjb25zdCBpc0ludCA9IGRlZi5mb3JtYXQ/LmluY2x1ZGVzKFwiaW50XCIpO1xuICAgIGNvbnN0IG9yaWdpbiA9IGlzSW50ID8gXCJpbnRcIiA6IFwibnVtYmVyXCI7XG4gICAgY29uc3QgW21pbmltdW0sIG1heGltdW1dID0gdXRpbC5OVU1CRVJfRk9STUFUX1JBTkdFU1tkZWYuZm9ybWF0XTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcuZm9ybWF0ID0gZGVmLmZvcm1hdDtcbiAgICAgICAgYmFnLm1pbmltdW0gPSBtaW5pbXVtO1xuICAgICAgICBiYWcubWF4aW11bSA9IG1heGltdW07XG4gICAgICAgIGlmIChpc0ludClcbiAgICAgICAgICAgIGJhZy5wYXR0ZXJuID0gcmVnZXhlcy5pbnRlZ2VyO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKGlzSW50KSB7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgLy8gaW52YWxpZF9mb3JtYXQgaXNzdWVcbiAgICAgICAgICAgICAgICAvLyBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAvLyAgIGV4cGVjdGVkOiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgIC8vICAgZm9ybWF0OiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgIC8vICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIC8vICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgLy8gICBpbnN0LFxuICAgICAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgICAgICAgIC8vIGludmFsaWRfdHlwZSBpc3N1ZVxuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogb3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IGRlZi5mb3JtYXQsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIG5vdF9tdWx0aXBsZV9vZiBpc3N1ZVxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vICAgY29kZTogXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICAgICAgICAgICAgICAvLyAgIG9yaWdpbjogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICAvLyAgIGlucHV0LFxuICAgICAgICAgICAgICAgIC8vICAgaW5zdCxcbiAgICAgICAgICAgICAgICAvLyAgIGRpdmlzb3I6IDEsXG4gICAgICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdG9vX2JpZ1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW50ZWdlcnMgbXVzdCBiZSB3aXRoaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b29fc21hbGxcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW50ZWdlcnMgbXVzdCBiZSB3aXRoaW4gdGhlIHNhZmUgaW50ZWdlciByYW5nZS5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgPCBtaW5pbXVtKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ID4gbWF4aW11bSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgICAgIG1heGltdW0sXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tCaWdJbnRGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrQmlnSW50Rm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpOyAvLyBubyBmb3JtYXQgY2hlY2tzXG4gICAgY29uc3QgW21pbmltdW0sIG1heGltdW1dID0gdXRpbC5CSUdJTlRfRk9STUFUX1JBTkdFU1tkZWYuZm9ybWF0XTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcuZm9ybWF0ID0gZGVmLmZvcm1hdDtcbiAgICAgICAgYmFnLm1pbmltdW0gPSBtaW5pbXVtO1xuICAgICAgICBiYWcubWF4aW11bSA9IG1heGltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoaW5wdXQgPCBtaW5pbXVtKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBtaW5pbXVtLFxuICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlucHV0ID4gbWF4aW11bSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgICAgIG1heGltdW0sXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNYXhTaXplID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01heFNpemVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5zaXplICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyciA9IChpbnN0Ll96b2QuYmFnLm1heGltdW0gPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgaWYgKGRlZi5tYXhpbXVtIDwgY3VycilcbiAgICAgICAgICAgIGluc3QuX3pvZC5iYWcubWF4aW11bSA9IGRlZi5tYXhpbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGlucHV0LnNpemU7XG4gICAgICAgIGlmIChzaXplIDw9IGRlZi5tYXhpbXVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogdXRpbC5nZXRTaXphYmxlT3JpZ2luKGlucHV0KSxcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heGltdW0sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja01pblNpemUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWluU2l6ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLnNpemUgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyID0gKGluc3QuX3pvZC5iYWcubWluaW11bSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBpZiAoZGVmLm1pbmltdW0gPiBjdXJyKVxuICAgICAgICAgICAgaW5zdC5fem9kLmJhZy5taW5pbXVtID0gZGVmLm1pbmltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBzaXplID0gaW5wdXQuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPj0gZGVmLm1pbmltdW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiB1dGlsLmdldFNpemFibGVPcmlnaW4oaW5wdXQpLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5pbXVtLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tTaXplRXF1YWxzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1NpemVFcXVhbHNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5zaXplICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLm1pbmltdW0gPSBkZWYuc2l6ZTtcbiAgICAgICAgYmFnLm1heGltdW0gPSBkZWYuc2l6ZTtcbiAgICAgICAgYmFnLnNpemUgPSBkZWYuc2l6ZTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNpemUgPSBpbnB1dC5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA9PT0gZGVmLnNpemUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHRvb0JpZyA9IHNpemUgPiBkZWYuc2l6ZTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IHV0aWwuZ2V0U2l6YWJsZU9yaWdpbihpbnB1dCksXG4gICAgICAgICAgICAuLi4odG9vQmlnID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogZGVmLnNpemUgfSA6IHsgY29kZTogXCJ0b29fc21hbGxcIiwgbWluaW11bTogZGVmLnNpemUgfSksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWF4TGVuZ3RoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja01heExlbmd0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoaW5zdC5fem9kLmJhZy5tYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGlmIChkZWYubWF4aW11bSA8IGN1cnIpXG4gICAgICAgICAgICBpbnN0Ll96b2QuYmFnLm1heGltdW0gPSBkZWYubWF4aW11bTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8PSBkZWYubWF4aW11bSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdXRpbC5nZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhpbXVtLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNaW5MZW5ndGggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWluTGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyciA9IChpbnN0Ll96b2QuYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKTtcbiAgICAgICAgaWYgKGRlZi5taW5pbXVtID4gY3VycilcbiAgICAgICAgICAgIGluc3QuX3pvZC5iYWcubWluaW11bSA9IGRlZi5taW5pbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID49IGRlZi5taW5pbXVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcmlnaW4gPSB1dGlsLmdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICBtaW5pbXVtOiBkZWYubWluaW11bSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTGVuZ3RoRXF1YWxzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0xlbmd0aEVxdWFsc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5taW5pbXVtID0gZGVmLmxlbmd0aDtcbiAgICAgICAgYmFnLm1heGltdW0gPSBkZWYubGVuZ3RoO1xuICAgICAgICBiYWcubGVuZ3RoID0gZGVmLmxlbmd0aDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gZGVmLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gdXRpbC5nZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcbiAgICAgICAgY29uc3QgdG9vQmlnID0gbGVuZ3RoID4gZGVmLmxlbmd0aDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICAuLi4odG9vQmlnID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogZGVmLmxlbmd0aCB9IDogeyBjb2RlOiBcInRvb19zbWFsbFwiLCBtaW5pbXVtOiBkZWYubGVuZ3RoIH0pLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja1N0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tTdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcuZm9ybWF0ID0gZGVmLmZvcm1hdDtcbiAgICAgICAgaWYgKGRlZi5wYXR0ZXJuKSB7XG4gICAgICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgICAgICBiYWcucGF0dGVybnMuYWRkKGRlZi5wYXR0ZXJuKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChkZWYucGF0dGVybilcbiAgICAgICAgKF9hID0gaW5zdC5fem9kKS5jaGVjayA/PyAoX2EuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgZGVmLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgIGlmIChkZWYucGF0dGVybi50ZXN0KHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIC4uLihkZWYucGF0dGVybiA/IHsgcGF0dGVybjogZGVmLnBhdHRlcm4udG9TdHJpbmcoKSB9IDoge30pLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgZWxzZVxuICAgICAgICAoX2IgPSBpbnN0Ll96b2QpLmNoZWNrID8/IChfYi5jaGVjayA9ICgpID0+IHsgfSk7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tSZWdleCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tSZWdleFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBkZWYucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoZGVmLnBhdHRlcm4udGVzdChwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwicmVnZXhcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgcGF0dGVybjogZGVmLnBhdHRlcm4udG9TdHJpbmcoKSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0xvd2VyQ2FzZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tMb3dlckNhc2VcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMubG93ZXJjYXNlKTtcbiAgICAkWm9kQ2hlY2tTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrVXBwZXJDYXNlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1VwcGVyQ2FzZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy51cHBlcmNhc2UpO1xuICAgICRab2RDaGVja1N0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tJbmNsdWRlcyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tJbmNsdWRlc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBlc2NhcGVkUmVnZXggPSB1dGlsLmVzY2FwZVJlZ2V4KGRlZi5pbmNsdWRlcyk7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAodHlwZW9mIGRlZi5wb3NpdGlvbiA9PT0gXCJudW1iZXJcIiA/IGBeLnske2RlZi5wb3NpdGlvbn19JHtlc2NhcGVkUmVnZXh9YCA6IGVzY2FwZWRSZWdleCk7XG4gICAgZGVmLnBhdHRlcm4gPSBwYXR0ZXJuO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5wYXR0ZXJucyA/PyAoYmFnLnBhdHRlcm5zID0gbmV3IFNldCgpKTtcbiAgICAgICAgYmFnLnBhdHRlcm5zLmFkZChwYXR0ZXJuKTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZS5pbmNsdWRlcyhkZWYuaW5jbHVkZXMsIGRlZi5wb3NpdGlvbikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImluY2x1ZGVzXCIsXG4gICAgICAgICAgICBpbmNsdWRlczogZGVmLmluY2x1ZGVzLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tTdGFydHNXaXRoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1N0YXJ0c1dpdGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoYF4ke3V0aWwuZXNjYXBlUmVnZXgoZGVmLnByZWZpeCl9LipgKTtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSBwYXR0ZXJuKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgIGJhZy5wYXR0ZXJucy5hZGQocGF0dGVybik7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUuc3RhcnRzV2l0aChkZWYucHJlZml4KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwic3RhcnRzX3dpdGhcIixcbiAgICAgICAgICAgIHByZWZpeDogZGVmLnByZWZpeCxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrRW5kc1dpdGggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrRW5kc1dpdGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgcGF0dGVybiA9IG5ldyBSZWdFeHAoYC4qJHt1dGlsLmVzY2FwZVJlZ2V4KGRlZi5zdWZmaXgpfSRgKTtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSBwYXR0ZXJuKTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcucGF0dGVybnMgPz8gKGJhZy5wYXR0ZXJucyA9IG5ldyBTZXQoKSk7XG4gICAgICAgIGJhZy5wYXR0ZXJucy5hZGQocGF0dGVybik7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUuZW5kc1dpdGgoZGVmLnN1ZmZpeCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImVuZHNfd2l0aFwiLFxuICAgICAgICAgICAgc3VmZml4OiBkZWYuc3VmZml4LFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLyAgICAkWm9kQ2hlY2tQcm9wZXJ0eSAgICAvLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGhhbmRsZUNoZWNrUHJvcGVydHlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBwcm9wZXJ0eSkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKHByb3BlcnR5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0ICRab2RDaGVja1Byb3BlcnR5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1Byb3BlcnR5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5zY2hlbWEuX3pvZC5ydW4oe1xuICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQudmFsdWVbZGVmLnByb3BlcnR5XSxcbiAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVDaGVja1Byb3BlcnR5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgZGVmLnByb3BlcnR5KSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlQ2hlY2tQcm9wZXJ0eVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGRlZi5wcm9wZXJ0eSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWltZVR5cGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWltZVR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgbWltZVNldCA9IG5ldyBTZXQoZGVmLm1pbWUpO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGluc3QuX3pvZC5iYWcubWltZSA9IGRlZi5taW1lO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChtaW1lU2V0LmhhcyhwYXlsb2FkLnZhbHVlLnR5cGUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWVzOiBkZWYubWltZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLnR5cGUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tPdmVyd3JpdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrT3ZlcndyaXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYudHgocGF5bG9hZC52YWx1ZSk7XG4gICAgfTtcbn0pO1xuIiwgImV4cG9ydCBjbGFzcyBEb2Mge1xuICAgIGNvbnN0cnVjdG9yKGFyZ3MgPSBbXSkge1xuICAgICAgICB0aGlzLmNvbnRlbnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRlbnQgPSAwO1xuICAgICAgICBpZiAodGhpcylcbiAgICAgICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgfVxuICAgIGluZGVudGVkKGZuKSB7XG4gICAgICAgIHRoaXMuaW5kZW50ICs9IDE7XG4gICAgICAgIGZuKHRoaXMpO1xuICAgICAgICB0aGlzLmluZGVudCAtPSAxO1xuICAgIH1cbiAgICB3cml0ZShhcmcpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgYXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcInN5bmNcIiB9KTtcbiAgICAgICAgICAgIGFyZyh0aGlzLCB7IGV4ZWN1dGlvbjogXCJhc3luY1wiIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhcmc7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHgpID0+IHgpO1xuICAgICAgICBjb25zdCBtaW5JbmRlbnQgPSBNYXRoLm1pbiguLi5saW5lcy5tYXAoKHgpID0+IHgubGVuZ3RoIC0geC50cmltU3RhcnQoKS5sZW5ndGgpKTtcbiAgICAgICAgY29uc3QgZGVkZW50ZWQgPSBsaW5lcy5tYXAoKHgpID0+IHguc2xpY2UobWluSW5kZW50KSkubWFwKCh4KSA9PiBcIiBcIi5yZXBlYXQodGhpcy5pbmRlbnQgKiAyKSArIHgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgZGVkZW50ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGVudC5wdXNoKGxpbmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBpbGUoKSB7XG4gICAgICAgIGNvbnN0IEYgPSBGdW5jdGlvbjtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXM/LmFyZ3M7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzPy5jb250ZW50ID8/IFtgYF07XG4gICAgICAgIGNvbnN0IGxpbmVzID0gWy4uLmNvbnRlbnQubWFwKCh4KSA9PiBgICAke3h9YCldO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhsaW5lcy5qb2luKFwiXFxuXCIpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGKC4uLmFyZ3MsIGxpbmVzLmpvaW4oXCJcXG5cIikpO1xuICAgIH1cbn1cbiIsICJleHBvcnQgY29uc3QgdmVyc2lvbiA9IHtcbiAgICBtYWpvcjogNCxcbiAgICBtaW5vcjogMyxcbiAgICBwYXRjaDogNixcbn07XG4iLCAiaW1wb3J0ICogYXMgY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQgeyBEb2MgfSBmcm9tIFwiLi9kb2MuanNcIjtcbmltcG9ydCB7IHBhcnNlLCBwYXJzZUFzeW5jLCBzYWZlUGFyc2UsIHNhZmVQYXJzZUFzeW5jIH0gZnJvbSBcIi4vcGFyc2UuanNcIjtcbmltcG9ydCAqIGFzIHJlZ2V4ZXMgZnJvbSBcIi4vcmVnZXhlcy5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vdmVyc2lvbnMuanNcIjtcbmV4cG9ydCBjb25zdCAkWm9kVHlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGluc3QgPz8gKGluc3QgPSB7fSk7XG4gICAgaW5zdC5fem9kLmRlZiA9IGRlZjsgLy8gc2V0IF9kZWYgcHJvcGVydHlcbiAgICBpbnN0Ll96b2QuYmFnID0gaW5zdC5fem9kLmJhZyB8fCB7fTsgLy8gaW5pdGlhbGl6ZSBfYmFnIG9iamVjdFxuICAgIGluc3QuX3pvZC52ZXJzaW9uID0gdmVyc2lvbjtcbiAgICBjb25zdCBjaGVja3MgPSBbLi4uKGluc3QuX3pvZC5kZWYuY2hlY2tzID8/IFtdKV07XG4gICAgLy8gaWYgaW5zdCBpcyBpdHNlbGYgYSBjaGVja3MuJFpvZENoZWNrLCBydW4gaXQgYXMgYSBjaGVja1xuICAgIGlmIChpbnN0Ll96b2QudHJhaXRzLmhhcyhcIiRab2RDaGVja1wiKSkge1xuICAgICAgICBjaGVja3MudW5zaGlmdChpbnN0KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjaCBvZiBjaGVja3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBmbiBvZiBjaC5fem9kLm9uYXR0YWNoKSB7XG4gICAgICAgICAgICBmbihpbnN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY2hlY2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBkZWZlcnJlZCBpbml0aWFsaXplclxuICAgICAgICAvLyBpbnN0Ll96b2QucGFyc2UgaXMgbm90IHlldCBkZWZpbmVkXG4gICAgICAgIChfYSA9IGluc3QuX3pvZCkuZGVmZXJyZWQgPz8gKF9hLmRlZmVycmVkID0gW10pO1xuICAgICAgICBpbnN0Ll96b2QuZGVmZXJyZWQ/LnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgaW5zdC5fem9kLnJ1biA9IGluc3QuX3pvZC5wYXJzZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBydW5DaGVja3MgPSAocGF5bG9hZCwgY2hlY2tzLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGxldCBpc0Fib3J0ZWQgPSB1dGlsLmFib3J0ZWQocGF5bG9hZCk7XG4gICAgICAgICAgICBsZXQgYXN5bmNSZXN1bHQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIGNoZWNrcykge1xuICAgICAgICAgICAgICAgIGlmIChjaC5fem9kLmRlZi53aGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZFJ1biA9IGNoLl96b2QuZGVmLndoZW4ocGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2hvdWxkUnVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckxlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBfID0gY2guX3pvZC5jaGVjayhwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICBpZiAoXyBpbnN0YW5jZW9mIFByb21pc2UgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzeW5jUmVzdWx0IHx8IF8gaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzeW5jUmVzdWx0ID0gKGFzeW5jUmVzdWx0ID8/IFByb21pc2UucmVzb2x2ZSgpKS50aGVuKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IF87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0TGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMZW4gPT09IGN1cnJMZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fib3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNBYm9ydGVkID0gdXRpbC5hYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0TGVuID09PSBjdXJyTGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNBYm9ydGVkKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNBYm9ydGVkID0gdXRpbC5hYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhc3luY1Jlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhc3luY1Jlc3VsdC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2FuYXJ5UmVzdWx0ID0gKGNhbmFyeSwgcGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgICAgICAvLyBhYm9ydCBpZiB0aGUgY2FuYXJ5IGlzIGFib3J0ZWRcbiAgICAgICAgICAgIGlmICh1dGlsLmFib3J0ZWQoY2FuYXJ5KSkge1xuICAgICAgICAgICAgICAgIGNhbmFyeS5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuYXJ5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcnVuIGNoZWNrcyBmaXJzdCwgdGhlblxuICAgICAgICAgICAgY29uc3QgY2hlY2tSZXN1bHQgPSBydW5DaGVja3MocGF5bG9hZCwgY2hlY2tzLCBjdHgpO1xuICAgICAgICAgICAgaWYgKGNoZWNrUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdHguYXN5bmMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja1Jlc3VsdC50aGVuKChjaGVja1Jlc3VsdCkgPT4gaW5zdC5fem9kLnBhcnNlKGNoZWNrUmVzdWx0LCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0Ll96b2QucGFyc2UoY2hlY2tSZXN1bHQsIGN0eCk7XG4gICAgICAgIH07XG4gICAgICAgIGluc3QuX3pvZC5ydW4gPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgICAgICBpZiAoY3R4LnNraXBDaGVja3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5zdC5fem9kLnBhcnNlKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gcnVuIGNhbmFyeVxuICAgICAgICAgICAgICAgIC8vIGluaXRpYWwgcGFzcyAobm8gY2hlY2tzKVxuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmFyeSA9IGluc3QuX3pvZC5wYXJzZSh7IHZhbHVlOiBwYXlsb2FkLnZhbHVlLCBpc3N1ZXM6IFtdIH0sIHsgLi4uY3R4LCBza2lwQ2hlY2tzOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIGlmIChjYW5hcnkgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYW5hcnkudGhlbigoY2FuYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2FuYXJ5UmVzdWx0KGNhbmFyeSwgcGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYW5hcnlSZXN1bHQoY2FuYXJ5LCBwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZm9yd2FyZFxuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5zdC5fem9kLnBhcnNlKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGlmIChjdHguYXN5bmMgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiBydW5DaGVja3MocmVzdWx0LCBjaGVja3MsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJ1bkNoZWNrcyhyZXN1bHQsIGNoZWNrcywgY3R4KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTGF6eSBpbml0aWFsaXplIH5zdGFuZGFyZCB0byBhdm9pZCBjcmVhdGluZyBvYmplY3RzIGZvciBldmVyeSBzY2hlbWFcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdCwgXCJ+c3RhbmRhcmRcIiwgKCkgPT4gKHtcbiAgICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByID0gc2FmZVBhcnNlKGluc3QsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5zdWNjZXNzID8geyB2YWx1ZTogci5kYXRhIH0gOiB7IGlzc3Vlczogci5lcnJvcj8uaXNzdWVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzYWZlUGFyc2VBc3luYyhpbnN0LCB2YWx1ZSkudGhlbigocikgPT4gKHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgdmVyc2lvbjogMSxcbiAgICB9KSk7XG59KTtcbmV4cG9ydCB7IGNsb25lIH0gZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0ICRab2RTdHJpbmcgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN0cmluZ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gWy4uLihpbnN0Py5fem9kLmJhZz8ucGF0dGVybnMgPz8gW10pXS5wb3AoKSA/PyByZWdleGVzLnN0cmluZyhpbnN0Ll96b2QuYmFnKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgXykgPT4ge1xuICAgICAgICBpZiAoZGVmLmNvZXJjZSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IFN0cmluZyhwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RTdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN0cmluZ0Zvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gY2hlY2sgaW5pdGlhbGl6YXRpb24gbXVzdCBjb21lIGZpcnN0XG4gICAgY2hlY2tzLiRab2RDaGVja1N0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgJFpvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kR1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kR1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5ndWlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBpZiAoZGVmLnZlcnNpb24pIHtcbiAgICAgICAgY29uc3QgdmVyc2lvbk1hcCA9IHtcbiAgICAgICAgICAgIHYxOiAxLFxuICAgICAgICAgICAgdjI6IDIsXG4gICAgICAgICAgICB2MzogMyxcbiAgICAgICAgICAgIHY0OiA0LFxuICAgICAgICAgICAgdjU6IDUsXG4gICAgICAgICAgICB2NjogNixcbiAgICAgICAgICAgIHY3OiA3LFxuICAgICAgICAgICAgdjg6IDgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHYgPSB2ZXJzaW9uTWFwW2RlZi52ZXJzaW9uXTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBVVUlEIHZlcnNpb246IFwiJHtkZWYudmVyc2lvbn1cImApO1xuICAgICAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnV1aWQodikpO1xuICAgIH1cbiAgICBlbHNlXG4gICAgICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMudXVpZCgpKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RFbWFpbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRW1haWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZW1haWwpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVSTCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJpbSB3aGl0ZXNwYWNlIGZyb20gaW5wdXRcbiAgICAgICAgICAgIGNvbnN0IHRyaW1tZWQgPSBwYXlsb2FkLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwodHJpbW1lZCk7XG4gICAgICAgICAgICBpZiAoZGVmLmhvc3RuYW1lKSB7XG4gICAgICAgICAgICAgICAgZGVmLmhvc3RuYW1lLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCFkZWYuaG9zdG5hbWUudGVzdCh1cmwuaG9zdG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogXCJJbnZhbGlkIGhvc3RuYW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBkZWYuaG9zdG5hbWUuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkZWYucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBkZWYucHJvdG9jb2wubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZi5wcm90b2NvbC50ZXN0KHVybC5wcm90b2NvbC5lbmRzV2l0aChcIjpcIikgPyB1cmwucHJvdG9jb2wuc2xpY2UoMCwgLTEpIDogdXJsLnByb3RvY29sKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1hdDogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGU6IFwiSW52YWxpZCBwcm90b2NvbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZGVmLnByb3RvY29sLnNvdXJjZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdGhlIG91dHB1dCB2YWx1ZSBiYXNlZCBvbiBub3JtYWxpemUgZmxhZ1xuICAgICAgICAgICAgaWYgKGRlZi5ub3JtYWxpemUpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2Ugbm9ybWFsaXplZCBVUkxcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdXJsLmhyZWY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBQcmVzZXJ2ZSB0aGUgb3JpZ2luYWwgaW5wdXQgKHRyaW1tZWQpXG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHRyaW1tZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RFbW9qaSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRW1vamlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZW1vamkoKSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTmFub0lEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROYW5vSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMubmFub2lkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmN1aWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENVSUQyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDVUlEMlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5jdWlkMik7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVUxJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVUxJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy51bGlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RYSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFhJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy54aWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEtTVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RLU1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5rc3VpZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVNPRGF0ZVRpbWUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElTT0RhdGVUaW1lXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmRhdGV0aW1lKGRlZikpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElTT0RhdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElTT0RhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZGF0ZSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVNPVGltZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVNPVGltZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy50aW1lKGRlZikpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElTT0R1cmF0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJU09EdXJhdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5kdXJhdGlvbik7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVB2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVB2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5pcHY0KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuYmFnLmZvcm1hdCA9IGBpcHY0YDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJUHY2ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJUHY2XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmlwdjYpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuZm9ybWF0ID0gYGlwdjZgO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBuZXcgVVJMKGBodHRwOi8vWyR7cGF5bG9hZC52YWx1ZX1dYCk7XG4gICAgICAgICAgICAvLyByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJpcHY2XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RNQUMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE1BQ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5tYWMoZGVmLmRlbGltaXRlcikpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuZm9ybWF0ID0gYG1hY2A7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ0lEUnY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDSURSdjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuY2lkcnY0KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDSURSdjYgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENJRFJ2NlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5jaWRydjYpOyAvLyBub3QgdXNlZCBmb3IgdmFsaWRhdGlvblxuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gcGF5bG9hZC52YWx1ZS5zcGxpdChcIi9cIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoICE9PSAyKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgW2FkZHJlc3MsIHByZWZpeF0gPSBwYXJ0cztcbiAgICAgICAgICAgIGlmICghcHJlZml4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgY29uc3QgcHJlZml4TnVtID0gTnVtYmVyKHByZWZpeCk7XG4gICAgICAgICAgICBpZiAoYCR7cHJlZml4TnVtfWAgIT09IHByZWZpeClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIGlmIChwcmVmaXhOdW0gPCAwIHx8IHByZWZpeE51bSA+IDEyOClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG5ldyBVUkwoYGh0dHA6Ly9bJHthZGRyZXNzfV1gKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImNpZHJ2NlwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFpvZEJhc2U2NCAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRCYXNlNjQoZGF0YSkge1xuICAgIGlmIChkYXRhID09PSBcIlwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZGF0YS5sZW5ndGggJSA0ICE9PSAwKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBhdG9iKGRhdGEpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0ICRab2RCYXNlNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEJhc2U2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5iYXNlNjQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuY29udGVudEVuY29kaW5nID0gXCJiYXNlNjRcIjtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoaXNWYWxpZEJhc2U2NChwYXlsb2FkLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiYmFzZTY0XCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgWm9kQmFzZTY0ICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEJhc2U2NFVSTChkYXRhKSB7XG4gICAgaWYgKCFyZWdleGVzLmJhc2U2NHVybC50ZXN0KGRhdGEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgYmFzZTY0ID0gZGF0YS5yZXBsYWNlKC9bLV9dL2csIChjKSA9PiAoYyA9PT0gXCItXCIgPyBcIitcIiA6IFwiL1wiKSk7XG4gICAgY29uc3QgcGFkZGVkID0gYmFzZTY0LnBhZEVuZChNYXRoLmNlaWwoYmFzZTY0Lmxlbmd0aCAvIDQpICogNCwgXCI9XCIpO1xuICAgIHJldHVybiBpc1ZhbGlkQmFzZTY0KHBhZGRlZCk7XG59XG5leHBvcnQgY29uc3QgJFpvZEJhc2U2NFVSTCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQmFzZTY0VVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmJhc2U2NHVybCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmJhZy5jb250ZW50RW5jb2RpbmcgPSBcImJhc2U2NHVybFwiO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChpc1ZhbGlkQmFzZTY0VVJMKHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEUxNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEUxNjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZTE2NCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLyAgIFpvZEpXVCAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRKV1QodG9rZW4sIGFsZ29yaXRobSA9IG51bGwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCB0b2tlbnNQYXJ0cyA9IHRva2VuLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKHRva2Vuc1BhcnRzLmxlbmd0aCAhPT0gMylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgW2hlYWRlcl0gPSB0b2tlbnNQYXJ0cztcbiAgICAgICAgaWYgKCFoZWFkZXIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3QgcGFyc2VkSGVhZGVyID0gSlNPTi5wYXJzZShhdG9iKGhlYWRlcikpO1xuICAgICAgICBpZiAoXCJ0eXBcIiBpbiBwYXJzZWRIZWFkZXIgJiYgcGFyc2VkSGVhZGVyPy50eXAgIT09IFwiSldUXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghcGFyc2VkSGVhZGVyLmFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKGFsZ29yaXRobSAmJiAoIShcImFsZ1wiIGluIHBhcnNlZEhlYWRlcikgfHwgcGFyc2VkSGVhZGVyLmFsZyAhPT0gYWxnb3JpdGhtKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCAkWm9kSldUID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RKV1RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChpc1ZhbGlkSldUKHBheWxvYWQudmFsdWUsIGRlZi5hbGcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJqd3RcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ3VzdG9tU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmZuKHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogZGVmLmZvcm1hdCxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE51bWJlciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVtYmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBpbnN0Ll96b2QuYmFnLnBhdHRlcm4gPz8gcmVnZXhlcy5udW1iZXI7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBOdW1iZXIocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIiAmJiAhTnVtYmVyLmlzTmFOKGlucHV0KSAmJiBOdW1iZXIuaXNGaW5pdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWNlaXZlZCA9IHR5cGVvZiBpbnB1dCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgPyBOdW1iZXIuaXNOYU4oaW5wdXQpXG4gICAgICAgICAgICAgICAgPyBcIk5hTlwiXG4gICAgICAgICAgICAgICAgOiAhTnVtYmVyLmlzRmluaXRlKGlucHV0KVxuICAgICAgICAgICAgICAgICAgICA/IFwiSW5maW5pdHlcIlxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgLi4uKHJlY2VpdmVkID8geyByZWNlaXZlZCB9IDoge30pLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROdW1iZXJGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE51bWJlckZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY2hlY2tzLiRab2RDaGVja051bWJlckZvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgJFpvZE51bWJlci5pbml0KGluc3QsIGRlZik7IC8vIG5vIGZvcm1hdCBjaGVja3Ncbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RCb29sZWFuID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCb29sZWFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSByZWdleGVzLmJvb2xlYW47XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBCb29sZWFuKHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiYm9vbGVhblwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYm9vbGVhblwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQmlnSW50ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCaWdJbnRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IHJlZ2V4ZXMuYmlnaW50O1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gQmlnSW50KHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJiaWdpbnRcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEJpZ0ludEZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQmlnSW50Rm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjaGVja3MuJFpvZENoZWNrQmlnSW50Rm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICAkWm9kQmlnSW50LmluaXQoaW5zdCwgZGVmKTsgLy8gbm8gZm9ybWF0IGNoZWNrc1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFN5bWJvbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU3ltYm9sXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN5bWJvbFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3ltYm9sXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVbmRlZmluZWQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVuZGVmaW5lZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gcmVnZXhlcy51bmRlZmluZWQ7XG4gICAgaW5zdC5fem9kLnZhbHVlcyA9IG5ldyBTZXQoW3VuZGVmaW5lZF0pO1xuICAgIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgICBpbnN0Ll96b2Qub3B0b3V0ID0gXCJvcHRpb25hbFwiO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcInVuZGVmaW5lZFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTnVsbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVsbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gcmVnZXhlcy5udWxsO1xuICAgIGluc3QuX3pvZC52YWx1ZXMgPSBuZXcgU2V0KFtudWxsXSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJudWxsXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RBbnkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEFueVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkKSA9PiBwYXlsb2FkO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVua25vd24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVua25vd25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCkgPT4gcGF5bG9hZDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROZXZlciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTmV2ZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5ldmVyXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RWb2lkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RWb2lkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwidm9pZFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRGF0ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRGF0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBuZXcgRGF0ZShwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfZXJyKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGlzRGF0ZSA9IGlucHV0IGluc3RhbmNlb2YgRGF0ZTtcbiAgICAgICAgY29uc3QgaXNWYWxpZERhdGUgPSBpc0RhdGUgJiYgIU51bWJlci5pc05hTihpbnB1dC5nZXRUaW1lKCkpO1xuICAgICAgICBpZiAoaXNWYWxpZERhdGUpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJkYXRlXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAuLi4oaXNEYXRlID8geyByZWNlaXZlZDogXCJJbnZhbGlkIERhdGVcIiB9IDoge30pLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgZmluYWwsIGluZGV4KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kQXJyYXkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEFycmF5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gQXJyYXkoaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGlucHV0W2ldO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmVsZW1lbnQuX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpdGVtLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkOyAvL2hhbmRsZUFycmF5UmVzdWx0c0FzeW5jKHBhcnNlUmVzdWx0cywgZmluYWwpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVByb3BlcnR5UmVzdWx0KHJlc3VsdCwgZmluYWwsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gRm9yIG9wdGlvbmFsLW91dCBzY2hlbWFzLCBpZ25vcmUgZXJyb3JzIG9uIGFic2VudCBrZXlzXG4gICAgICAgIGlmIChpc09wdGlvbmFsT3V0ICYmICEoa2V5IGluIGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemVEZWYoZGVmKSB7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRlZi5zaGFwZSk7XG4gICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgaWYgKCFkZWYuc2hhcGU/LltrXT8uX3pvZD8udHJhaXRzPy5oYXMoXCIkWm9kVHlwZVwiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGVsZW1lbnQgYXQga2V5IFwiJHtrfVwiOiBleHBlY3RlZCBhIFpvZCBzY2hlbWFgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBva2V5cyA9IHV0aWwub3B0aW9uYWxLZXlzKGRlZi5zaGFwZSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmLFxuICAgICAgICBrZXlzLFxuICAgICAgICBrZXlTZXQ6IG5ldyBTZXQoa2V5cyksXG4gICAgICAgIG51bUtleXM6IGtleXMubGVuZ3RoLFxuICAgICAgICBvcHRpb25hbEtleXM6IG5ldyBTZXQob2tleXMpLFxuICAgIH07XG59XG5mdW5jdGlvbiBoYW5kbGVDYXRjaGFsbChwcm9tcywgaW5wdXQsIHBheWxvYWQsIGN0eCwgZGVmLCBpbnN0KSB7XG4gICAgY29uc3QgdW5yZWNvZ25pemVkID0gW107XG4gICAgLy8gaXRlcmF0ZSBvdmVyIGlucHV0IGtleXNcbiAgICBjb25zdCBrZXlTZXQgPSBkZWYua2V5U2V0O1xuICAgIGNvbnN0IF9jYXRjaGFsbCA9IGRlZi5jYXRjaGFsbC5fem9kO1xuICAgIGNvbnN0IHQgPSBfY2F0Y2hhbGwuZGVmLnR5cGU7XG4gICAgY29uc3QgaXNPcHRpb25hbE91dCA9IF9jYXRjaGFsbC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICBpZiAoa2V5U2V0LmhhcyhrZXkpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGlmICh0ID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgICAgIHVucmVjb2duaXplZC5wdXNoKGtleSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByID0gX2NhdGNoYWxsLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcHJvbXMucHVzaChyLnRoZW4oKHIpID0+IGhhbmRsZVByb3BlcnR5UmVzdWx0KHIsIHBheWxvYWQsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodW5yZWNvZ25pemVkLmxlbmd0aCkge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICAgICAgICAgIGtleXM6IHVucmVjb2duaXplZCxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghcHJvbXMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kT2JqZWN0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RPYmplY3RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIHJlcXVpcmVzIGNhc3QgYmVjYXVzZSB0ZWNobmljYWxseSAkWm9kT2JqZWN0IGRvZXNuJ3QgZXh0ZW5kXG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIC8vIGNvbnN0IHNoID0gZGVmLnNoYXBlO1xuICAgIGNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGRlZiwgXCJzaGFwZVwiKTtcbiAgICBpZiAoIWRlc2M/LmdldCkge1xuICAgICAgICBjb25zdCBzaCA9IGRlZi5zaGFwZTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlZiwgXCJzaGFwZVwiLCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdTaCA9IHsgLi4uc2ggfTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVmLCBcInNoYXBlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG5ld1NoLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXdTaDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBfbm9ybWFsaXplZCA9IHV0aWwuY2FjaGVkKCgpID0+IG5vcm1hbGl6ZURlZihkZWYpKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZTtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBzaGFwZVtrZXldLl96b2Q7XG4gICAgICAgICAgICBpZiAoZmllbGQudmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcHJvcFZhbHVlc1trZXldID8/IChwcm9wVmFsdWVzW2tleV0gPSBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBmaWVsZC52YWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZXNba2V5XS5hZGQodik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZXM7XG4gICAgfSk7XG4gICAgY29uc3QgaXNPYmplY3QgPSB1dGlsLmlzT2JqZWN0O1xuICAgIGNvbnN0IGNhdGNoYWxsID0gZGVmLmNhdGNoYWxsO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHZhbHVlID8/ICh2YWx1ZSA9IF9ub3JtYWxpemVkLnZhbHVlKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0ge307XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdmFsdWUuc2hhcGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHZhbHVlLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsID0gc2hhcGVba2V5XTtcbiAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWxPdXQgPSBlbC5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgICAgICAgICAgY29uc3QgciA9IGVsLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2goci50aGVuKChyKSA9PiBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlUHJvcGVydHlSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaXNPcHRpb25hbE91dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYXRjaGFsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb21zLmxlbmd0aCA/IFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpIDogcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlQ2F0Y2hhbGwocHJvbXMsIGlucHV0LCBwYXlsb2FkLCBjdHgsIF9ub3JtYWxpemVkLnZhbHVlLCBpbnN0KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE9iamVjdEpJVCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kT2JqZWN0SklUXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyByZXF1aXJlcyBjYXN0IGJlY2F1c2UgdGVjaG5pY2FsbHkgJFpvZE9iamVjdCBkb2Vzbid0IGV4dGVuZFxuICAgICRab2RPYmplY3QuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IHN1cGVyUGFyc2UgPSBpbnN0Ll96b2QucGFyc2U7XG4gICAgY29uc3QgX25vcm1hbGl6ZWQgPSB1dGlsLmNhY2hlZCgoKSA9PiBub3JtYWxpemVEZWYoZGVmKSk7XG4gICAgY29uc3QgZ2VuZXJhdGVGYXN0cGFzcyA9IChzaGFwZSkgPT4ge1xuICAgICAgICBjb25zdCBkb2MgPSBuZXcgRG9jKFtcInNoYXBlXCIsIFwicGF5bG9hZFwiLCBcImN0eFwiXSk7XG4gICAgICAgIGNvbnN0IG5vcm1hbGl6ZWQgPSBfbm9ybWFsaXplZC52YWx1ZTtcbiAgICAgICAgY29uc3QgcGFyc2VTdHIgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrID0gdXRpbC5lc2Moa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBgc2hhcGVbJHtrfV0uX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRbJHtrfV0sIGlzc3VlczogW10gfSwgY3R4KWA7XG4gICAgICAgIH07XG4gICAgICAgIGRvYy53cml0ZShgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO2ApO1xuICAgICAgICBjb25zdCBpZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBsZXQgY291bnRlciA9IDA7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIG5vcm1hbGl6ZWQua2V5cykge1xuICAgICAgICAgICAgaWRzW2tleV0gPSBga2V5XyR7Y291bnRlcisrfWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQTogcHJlc2VydmUga2V5IG9yZGVyIHtcbiAgICAgICAgZG9jLndyaXRlKGBjb25zdCBuZXdSZXN1bHQgPSB7fTtgKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGlkc1trZXldO1xuICAgICAgICAgICAgY29uc3QgayA9IHV0aWwuZXNjKGtleSk7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBzaGFwZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgaXNPcHRpb25hbE91dCA9IHNjaGVtYT8uX3pvZD8ub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gICAgICAgICAgICBkb2Mud3JpdGUoYGNvbnN0ICR7aWR9ID0gJHtwYXJzZVN0cihrZXkpfTtgKTtcbiAgICAgICAgICAgIGlmIChpc09wdGlvbmFsT3V0KSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG9wdGlvbmFsLW91dCBzY2hlbWFzLCBpZ25vcmUgZXJyb3JzIG9uIGFic2VudCBrZXlzXG4gICAgICAgICAgICAgICAgZG9jLndyaXRlKGBcbiAgICAgICAgaWYgKCR7aWR9Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoJHtpZH0uaXNzdWVzLm1hcChpc3MgPT4gKHtcbiAgICAgICAgICAgICAgLi4uaXNzLFxuICAgICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2t9LCAuLi5pc3MucGF0aF0gOiBbJHtrfV1cbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoJHtpZH0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkb2Mud3JpdGUoYFxuICAgICAgICBpZiAoJHtpZH0uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gcGF5bG9hZC5pc3N1ZXMuY29uY2F0KCR7aWR9Lmlzc3Vlcy5tYXAoaXNzID0+ICh7XG4gICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICBwYXRoOiBpc3MucGF0aCA/IFske2t9LCAuLi5pc3MucGF0aF0gOiBbJHtrfV1cbiAgICAgICAgICB9KSkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoJHtpZH0udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICBuZXdSZXN1bHRbJHtrfV0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9jLndyaXRlKGBwYXlsb2FkLnZhbHVlID0gbmV3UmVzdWx0O2ApO1xuICAgICAgICBkb2Mud3JpdGUoYHJldHVybiBwYXlsb2FkO2ApO1xuICAgICAgICBjb25zdCBmbiA9IGRvYy5jb21waWxlKCk7XG4gICAgICAgIHJldHVybiAocGF5bG9hZCwgY3R4KSA9PiBmbihzaGFwZSwgcGF5bG9hZCwgY3R4KTtcbiAgICB9O1xuICAgIGxldCBmYXN0cGFzcztcbiAgICBjb25zdCBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgY29uc3Qgaml0ID0gIWNvcmUuZ2xvYmFsQ29uZmlnLmppdGxlc3M7XG4gICAgY29uc3QgYWxsb3dzRXZhbCA9IHV0aWwuYWxsb3dzRXZhbDtcbiAgICBjb25zdCBmYXN0RW5hYmxlZCA9IGppdCAmJiBhbGxvd3NFdmFsLnZhbHVlOyAvLyAmJiAhZGVmLmNhdGNoYWxsO1xuICAgIGNvbnN0IGNhdGNoYWxsID0gZGVmLmNhdGNoYWxsO1xuICAgIGxldCB2YWx1ZTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHZhbHVlID8/ICh2YWx1ZSA9IF9ub3JtYWxpemVkLnZhbHVlKTtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaml0ICYmIGZhc3RFbmFibGVkICYmIGN0eD8uYXN5bmMgPT09IGZhbHNlICYmIGN0eC5qaXRsZXNzICE9PSB0cnVlKSB7XG4gICAgICAgICAgICAvLyBhbHdheXMgc3luY2hyb25vdXNcbiAgICAgICAgICAgIGlmICghZmFzdHBhc3MpXG4gICAgICAgICAgICAgICAgZmFzdHBhc3MgPSBnZW5lcmF0ZUZhc3RwYXNzKGRlZi5zaGFwZSk7XG4gICAgICAgICAgICBwYXlsb2FkID0gZmFzdHBhc3MocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmICghY2F0Y2hhbGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ2F0Y2hhbGwoW10sIGlucHV0LCBwYXlsb2FkLCBjdHgsIHZhbHVlLCBpbnN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VwZXJQYXJzZShwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBmaW5hbCwgaW5zdCwgY3R4KSB7XG4gICAgZm9yIChjb25zdCByZXN1bHQgb2YgcmVzdWx0cykge1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGZpbmFsLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgcmV0dXJuIGZpbmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG5vbmFib3J0ZWQgPSByZXN1bHRzLmZpbHRlcigocikgPT4gIXV0aWwuYWJvcnRlZChyKSk7XG4gICAgaWYgKG5vbmFib3J0ZWQubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZpbmFsLnZhbHVlID0gbm9uYWJvcnRlZFswXS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIG5vbmFib3J0ZWRbMF07XG4gICAgfVxuICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgICAgIGlucHV0OiBmaW5hbC52YWx1ZSxcbiAgICAgICAgaW5zdCxcbiAgICAgICAgZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSksXG4gICAgfSk7XG4gICAgcmV0dXJuIGZpbmFsO1xufVxuZXhwb3J0IGNvbnN0ICRab2RVbmlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVW5pb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHVuZGVmaW5lZCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLm9wdGlvbnMuc29tZSgobykgPT4gby5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiKSA/IFwib3B0aW9uYWxcIiA6IHVuZGVmaW5lZCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICBpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC52YWx1ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNldChkZWYub3B0aW9ucy5mbGF0TWFwKChvcHRpb24pID0+IEFycmF5LmZyb20ob3B0aW9uLl96b2QudmFsdWVzKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5vcHRpb25zLmV2ZXJ5KChvKSA9PiBvLl96b2QucGF0dGVybikpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5zID0gZGVmLm9wdGlvbnMubWFwKChvKSA9PiBvLl96b2QucGF0dGVybik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXigke3BhdHRlcm5zLm1hcCgocCkgPT4gdXRpbC5jbGVhblJlZ2V4KHAuc291cmNlKSkuam9pbihcInxcIil9KSRgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGNvbnN0IHNpbmdsZSA9IGRlZi5vcHRpb25zLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBmaXJzdCA9IGRlZi5vcHRpb25zWzBdLl96b2QucnVuO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKHNpbmdsZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpcnN0KHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFzeW5jID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbi5fem9kLnJ1bih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgICAgIGFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFzeW5jKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVFeGNsdXNpdmVVbmlvblJlc3VsdHMocmVzdWx0cywgZmluYWwsIGluc3QsIGN0eCkge1xuICAgIGNvbnN0IHN1Y2Nlc3NlcyA9IHJlc3VsdHMuZmlsdGVyKChyKSA9PiByLmlzc3Vlcy5sZW5ndGggPT09IDApO1xuICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGZpbmFsLnZhbHVlID0gc3VjY2Vzc2VzWzBdLnZhbHVlO1xuICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgfVxuICAgIGlmIChzdWNjZXNzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIE5vIG1hdGNoZXMgLSBzYW1lIGFzIHJlZ3VsYXIgdW5pb25cbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogZmluYWwudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgbWF0Y2hlcyAtIGV4Y2x1c2l2ZSB1bmlvbiBmYWlsdXJlXG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgICAgICAgICAgaW5wdXQ6IGZpbmFsLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGVycm9yczogW10sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsO1xufVxuZXhwb3J0IGNvbnN0ICRab2RYb3IgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFhvclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBkZWYuaW5jbHVzaXZlID0gZmFsc2U7XG4gICAgY29uc3Qgc2luZ2xlID0gZGVmLm9wdGlvbnMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IGZpcnN0ID0gZGVmLm9wdGlvbnNbMF0uX3pvZC5ydW47XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl96b2QucnVuKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhc3luYylcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeGNsdXNpdmVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHJlc3VsdHMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVFeGNsdXNpdmVVbmlvblJlc3VsdHMocmVzdWx0cywgcGF5bG9hZCwgaW5zdCwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2REaXNjcmltaW5hdGVkVW5pb24gPSBcbi8qQF9fUFVSRV9fKi9cbmNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZERpc2NyaW1pbmF0ZWRVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLmluY2x1c2l2ZSA9IGZhbHNlO1xuICAgICRab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgX3N1cGVyID0gaW5zdC5fem9kLnBhcnNlO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHByb3BWYWx1ZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZGVmLm9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHB2ID0gb3B0aW9uLl96b2QucHJvcFZhbHVlcztcbiAgICAgICAgICAgIGlmICghcHYgfHwgT2JqZWN0LmtleXMocHYpLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZGlzY3JpbWluYXRlZCB1bmlvbiBvcHRpb24gYXQgaW5kZXggXCIke2RlZi5vcHRpb25zLmluZGV4T2Yob3B0aW9uKX1cImApO1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMocHYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wVmFsdWVzW2tdKVxuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWVzW2tdID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHYpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlc1trXS5hZGQodmFsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3BWYWx1ZXM7XG4gICAgfSk7XG4gICAgY29uc3QgZGlzYyA9IHV0aWwuY2FjaGVkKCgpID0+IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IGRlZi5vcHRpb25zO1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgbyBvZiBvcHRzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvLl96b2QucHJvcFZhbHVlcz8uW2RlZi5kaXNjcmltaW5hdG9yXTtcbiAgICAgICAgICAgIGlmICghdmFsdWVzIHx8IHZhbHVlcy5zaXplID09PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaXNjcmltaW5hdGVkIHVuaW9uIG9wdGlvbiBhdCBpbmRleCBcIiR7ZGVmLm9wdGlvbnMuaW5kZXhPZihvKX1cImApO1xuICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChtYXAuaGFzKHYpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIGRpc2NyaW1pbmF0b3IgdmFsdWUgXCIke1N0cmluZyh2KX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXAuc2V0KHYsIG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghdXRpbC5pc09iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0ID0gZGlzYy52YWx1ZS5nZXQoaW5wdXQ/LltkZWYuZGlzY3JpbWluYXRvcl0pO1xuICAgICAgICBpZiAob3B0KSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0Ll96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi51bmlvbkZhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gbWF0Y2hpbmcgZGlzY3JpbWluYXRvclxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF91bmlvblwiLFxuICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgIG5vdGU6IFwiTm8gbWF0Y2hpbmcgZGlzY3JpbWluYXRvclwiLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcjogZGVmLmRpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIHBhdGg6IFtkZWYuZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJbnRlcnNlY3Rpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEludGVyc2VjdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBsZWZ0ID0gZGVmLmxlZnQuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXQsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBkZWYucmlnaHQuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXQsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgY29uc3QgYXN5bmMgPSBsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCByaWdodCBpbnN0YW5jZW9mIFByb21pc2U7XG4gICAgICAgIGlmIChhc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtsZWZ0LCByaWdodF0pLnRoZW4oKFtsZWZ0LCByaWdodF0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0LCByaWdodCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0LCByaWdodCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gbWVyZ2VWYWx1ZXMoYSwgYikge1xuICAgIC8vIGNvbnN0IGFUeXBlID0gcGFyc2UudChhKTtcbiAgICAvLyBjb25zdCBiVHlwZSA9IHBhcnNlLnQoYik7XG4gICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgaWYgKGEgaW5zdGFuY2VvZiBEYXRlICYmIGIgaW5zdGFuY2VvZiBEYXRlICYmICthID09PSArYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBpZiAodXRpbC5pc1BsYWluT2JqZWN0KGEpICYmIHV0aWwuaXNQbGFpbk9iamVjdChiKSkge1xuICAgICAgICBjb25zdCBiS2V5cyA9IE9iamVjdC5rZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gT2JqZWN0LmtleXMoYSkuZmlsdGVyKChrZXkpID0+IGJLZXlzLmluZGV4T2Yoa2V5KSAhPT0gLTEpO1xuICAgICAgICBjb25zdCBuZXdPYmogPSB7IC4uLmEsIC4uLmIgfTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG4gICAgICAgICAgICBpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBtZXJnZUVycm9yUGF0aDogW2tleSwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld09iaiB9O1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSAmJiBBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgbWVyZ2VFcnJvclBhdGg6IFtdIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlRXJyb3JQYXRoOiBbaW5kZXgsIC4uLnNoYXJlZFZhbHVlLm1lcmdlRXJyb3JQYXRoXSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3QXJyYXkgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXJnZUVycm9yUGF0aDogW10gfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocmVzdWx0LCBsZWZ0LCByaWdodCkge1xuICAgIC8vIFRyYWNrIHdoaWNoIHNpZGUocykgcmVwb3J0IGVhY2gga2V5IGFzIHVucmVjb2duaXplZFxuICAgIGNvbnN0IHVucmVjS2V5cyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgdW5yZWNJc3N1ZTtcbiAgICBmb3IgKGNvbnN0IGlzcyBvZiBsZWZ0Lmlzc3Vlcykge1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIikge1xuICAgICAgICAgICAgdW5yZWNJc3N1ZSA/PyAodW5yZWNJc3N1ZSA9IGlzcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGsgb2YgaXNzLmtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXVucmVjS2V5cy5oYXMoaykpXG4gICAgICAgICAgICAgICAgICAgIHVucmVjS2V5cy5zZXQoaywge30pO1xuICAgICAgICAgICAgICAgIHVucmVjS2V5cy5nZXQoaykubCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQuaXNzdWVzLnB1c2goaXNzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGlzcyBvZiByaWdodC5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKGlzcy5jb2RlID09PSBcInVucmVjb2duaXplZF9rZXlzXCIpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBpc3Mua2V5cykge1xuICAgICAgICAgICAgICAgIGlmICghdW5yZWNLZXlzLmhhcyhrKSlcbiAgICAgICAgICAgICAgICAgICAgdW5yZWNLZXlzLnNldChrLCB7fSk7XG4gICAgICAgICAgICAgICAgdW5yZWNLZXlzLmdldChrKS5yID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc3N1ZXMucHVzaChpc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFJlcG9ydCBvbmx5IGtleXMgdW5yZWNvZ25pemVkIGJ5IEJPVEggc2lkZXNcbiAgICBjb25zdCBib3RoS2V5cyA9IFsuLi51bnJlY0tleXNdLmZpbHRlcigoWywgZl0pID0+IGYubCAmJiBmLnIpLm1hcCgoW2tdKSA9PiBrKTtcbiAgICBpZiAoYm90aEtleXMubGVuZ3RoICYmIHVucmVjSXNzdWUpIHtcbiAgICAgICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKHsgLi4udW5yZWNJc3N1ZSwga2V5czogYm90aEtleXMgfSk7XG4gICAgfVxuICAgIGlmICh1dGlsLmFib3J0ZWQocmVzdWx0KSlcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICBjb25zdCBtZXJnZWQgPSBtZXJnZVZhbHVlcyhsZWZ0LnZhbHVlLCByaWdodC52YWx1ZSk7XG4gICAgaWYgKCFtZXJnZWQudmFsaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbm1lcmdhYmxlIGludGVyc2VjdGlvbi4gRXJyb3IgcGF0aDogYCArIGAke0pTT04uc3RyaW5naWZ5KG1lcmdlZC5tZXJnZUVycm9yUGF0aCl9YCk7XG4gICAgfVxuICAgIHJlc3VsdC52YWx1ZSA9IG1lcmdlZC5kYXRhO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFR1cGxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RUdXBsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IGl0ZW1zID0gZGVmLml0ZW1zO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IFtdO1xuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBjb25zdCByZXZlcnNlZEluZGV4ID0gWy4uLml0ZW1zXS5yZXZlcnNlKCkuZmluZEluZGV4KChpdGVtKSA9PiBpdGVtLl96b2Qub3B0aW4gIT09IFwib3B0aW9uYWxcIik7XG4gICAgICAgIGNvbnN0IG9wdFN0YXJ0ID0gcmV2ZXJzZWRJbmRleCA9PT0gLTEgPyAwIDogaXRlbXMubGVuZ3RoIC0gcmV2ZXJzZWRJbmRleDtcbiAgICAgICAgaWYgKCFkZWYucmVzdCkge1xuICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gaW5wdXQubGVuZ3RoID4gaXRlbXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5sZW5ndGggPCBvcHRTdGFydCAtIDE7XG4gICAgICAgICAgICBpZiAodG9vQmlnIHx8IHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIC4uLih0b29CaWdcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyBjb2RlOiBcInRvb19iaWdcIiwgbWF4aW11bTogaXRlbXMubGVuZ3RoLCBpbmNsdXNpdmU6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IGNvZGU6IFwidG9vX3NtYWxsXCIsIG1pbmltdW06IGl0ZW1zLmxlbmd0aCB9KSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gLTE7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgaWYgKGkgPj0gaW5wdXQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGlmIChpID49IG9wdFN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGl0ZW0uX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBpbnB1dFtpXSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVUdXBsZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucmVzdCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdCA9IGlucHV0LnNsaWNlKGl0ZW1zLmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHJlc3QpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLnJlc3QuX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZWwsXG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSkpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgZmluYWwsIGluZGV4KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kUmVjb3JkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RSZWNvcmRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCF1dGlsLmlzUGxhaW5PYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGRlZi5rZXlUeXBlLl96b2QudmFsdWVzO1xuICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0ge307XG4gICAgICAgICAgICBjb25zdCByZWNvcmRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGtleSA9PT0gXCJudW1iZXJcIiB8fCB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY29yZEtleXMuYWRkKHR5cGVvZiBrZXkgPT09IFwibnVtYmVyXCIgPyBrZXkudG9TdHJpbmcoKSA6IGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdW5yZWNvZ25pemVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5wdXQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlY29yZEtleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5yZWNvZ25pemVkID0gdW5yZWNvZ25pemVkID8/IFtdO1xuICAgICAgICAgICAgICAgICAgICB1bnJlY29nbml6ZWQucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bnJlY29nbml6ZWQgJiYgdW5yZWNvZ25pemVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAga2V5czogdW5yZWNvZ25pemVkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgUmVmbGVjdC5vd25LZXlzKGlucHV0KSkge1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiX19wcm90b19fXCIpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGxldCBrZXlSZXN1bHQgPSBkZWYua2V5VHlwZS5fem9kLnJ1bih7IHZhbHVlOiBrZXksIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoa2V5UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyBzY2hlbWFzIG5vdCBzdXBwb3J0ZWQgaW4gb2JqZWN0IGtleXMgY3VycmVudGx5XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOdW1lcmljIHN0cmluZyBmYWxsYmFjazogaWYga2V5IGlzIGEgbnVtZXJpYyBzdHJpbmcgYW5kIGZhaWxlZCwgcmV0cnkgd2l0aCBOdW1iZXIoa2V5KVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaGFuZGxlcyB6Lm51bWJlcigpLCB6LmxpdGVyYWwoWzEsIDIsIDNdKSwgYW5kIHVuaW9ucyBjb250YWluaW5nIG51bWVyaWMgbGl0ZXJhbHNcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja051bWVyaWNLZXkgPSB0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiICYmIHJlZ2V4ZXMubnVtYmVyLnRlc3Qoa2V5KSAmJiBrZXlSZXN1bHQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tOdW1lcmljS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJldHJ5UmVzdWx0ID0gZGVmLmtleVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogTnVtYmVyKGtleSksIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJldHJ5UmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQXN5bmMgc2NoZW1hcyBub3Qgc3VwcG9ydGVkIGluIG9iamVjdCBrZXlzIGN1cnJlbnRseVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlSZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5UmVzdWx0ID0gcmV0cnlSZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGtleVJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZWYubW9kZSA9PT0gXCJsb29zZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQYXNzIHRocm91Z2ggdW5jaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleV0gPSBpbnB1dFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVmYXVsdCBcInN0cmljdFwiIGJlaGF2aW9yOiBlcnJvciBvbiBpbnZhbGlkIGtleVxuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2tleVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbjogXCJyZWNvcmRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGtleVJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYudmFsdWVUeXBlLl96b2QucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleVJlc3VsdC52YWx1ZV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlW2tleVJlc3VsdC52YWx1ZV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9tcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE1hcCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTWFwXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgTWFwKSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gbmV3IE1hcCgpO1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBpbnB1dCkge1xuICAgICAgICAgICAgY29uc3Qga2V5UmVzdWx0ID0gZGVmLmtleVR5cGUuX3pvZC5ydW4oeyB2YWx1ZToga2V5LCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogdmFsdWUsIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChrZXlSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHZhbHVlUmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2goUHJvbWlzZS5hbGwoW2tleVJlc3VsdCwgdmFsdWVSZXN1bHRdKS50aGVuKChba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlTWFwUmVzdWx0KGtleVJlc3VsdCwgdmFsdWVSZXN1bHQsIHBheWxvYWQsIGtleSwgaW5wdXQsIGluc3QsIGN0eCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlTWFwUmVzdWx0KGtleVJlc3VsdCwgdmFsdWVSZXN1bHQsIHBheWxvYWQsIGtleSwgaW5wdXQsIGluc3QsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlTWFwUmVzdWx0KGtleVJlc3VsdCwgdmFsdWVSZXN1bHQsIGZpbmFsLCBrZXksIGlucHV0LCBpbnN0LCBjdHgpIHtcbiAgICBpZiAoa2V5UmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHV0aWwucHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGtleSkpIHtcbiAgICAgICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwga2V5UmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9rZXlcIixcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGtleVJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHVlUmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHV0aWwucHJvcGVydHlLZXlUeXBlcy5oYXModHlwZW9mIGtleSkpIHtcbiAgICAgICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgdmFsdWVSZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcIm1hcFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9lbGVtZW50XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IHZhbHVlUmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmaW5hbC52YWx1ZS5zZXQoa2V5UmVzdWx0LnZhbHVlLCB2YWx1ZVJlc3VsdC52YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgJFpvZFNldCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU2V0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgU2V0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJzZXRcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgaW5wdXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaXRlbSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZVNldFJlc3VsdChyZXN1bHQsIHBheWxvYWQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgaGFuZGxlU2V0UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlU2V0UmVzdWx0KHJlc3VsdCwgZmluYWwpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4ucmVzdWx0Lmlzc3Vlcyk7XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlLmFkZChyZXN1bHQudmFsdWUpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RFbnVtID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgdmFsdWVzID0gdXRpbC5nZXRFbnVtVmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgICBjb25zdCB2YWx1ZXNTZXQgPSBuZXcgU2V0KHZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnZhbHVlcyA9IHZhbHVlc1NldDtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IG5ldyBSZWdFeHAoYF4oJHt2YWx1ZXNcbiAgICAgICAgLmZpbHRlcigoaykgPT4gdXRpbC5wcm9wZXJ0eUtleVR5cGVzLmhhcyh0eXBlb2YgaykpXG4gICAgICAgIC5tYXAoKG8pID0+ICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIiA/IHV0aWwuZXNjYXBlUmVnZXgobykgOiBvLnRvU3RyaW5nKCkpKVxuICAgICAgICAuam9pbihcInxcIil9KSRgKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZXNTZXQuaGFzKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICAgICAgICAgIHZhbHVlcyxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTGl0ZXJhbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGlmIChkZWYudmFsdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY3JlYXRlIGxpdGVyYWwgc2NoZW1hIHdpdGggbm8gdmFsaWQgdmFsdWVzXCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBuZXcgU2V0KGRlZi52YWx1ZXMpO1xuICAgIGluc3QuX3pvZC52YWx1ZXMgPSB2YWx1ZXM7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeKCR7ZGVmLnZhbHVlc1xuICAgICAgICAubWFwKChvKSA9PiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIgPyB1dGlsLmVzY2FwZVJlZ2V4KG8pIDogbyA/IHV0aWwuZXNjYXBlUmVnZXgoby50b1N0cmluZygpKSA6IFN0cmluZyhvKSkpXG4gICAgICAgIC5qb2luKFwifFwiKX0pJGApO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlcy5oYXMoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWVzOiBkZWYudmFsdWVzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RGaWxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RGaWxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIEZpbGUpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJmaWxlXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RUcmFuc2Zvcm0gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFRyYW5zZm9ybVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEVuY29kZUVycm9yKGluc3QuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgX291dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgICAgIGlmIChjdHguYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IG91dHB1dCA9IF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlID8gX291dCA6IFByb21pc2UucmVzb2x2ZShfb3V0KTtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gX291dDtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnB1dCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCAmJiBpbnB1dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiB7IGlzc3VlczogW10sIHZhbHVlOiB1bmRlZmluZWQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kT3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICAgIGluc3QuX3pvZC5vcHRvdXQgPSBcIm9wdGlvbmFsXCI7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyA/IG5ldyBTZXQoWy4uLmRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMsIHVuZGVmaW5lZF0pIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBkZWYuaW5uZXJUeXBlLl96b2QucGF0dGVybjtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4gPyBuZXcgUmVnRXhwKGBeKCR7dXRpbC5jbGVhblJlZ2V4KHBhdHRlcm4uc291cmNlKX0pPyRgKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyKSA9PiBoYW5kbGVPcHRpb25hbFJlc3VsdChyLCBwYXlsb2FkLnZhbHVlKSk7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRXhhY3RPcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRXhhY3RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gQ2FsbCBwYXJlbnQgaW5pdCAtIGluaGVyaXRzIG9wdGluL29wdG91dCA9IFwib3B0aW9uYWxcIlxuICAgICRab2RPcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gT3ZlcnJpZGUgdmFsdWVzL3BhdHRlcm4gdG8gTk9UIGFkZCB1bmRlZmluZWRcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm4pO1xuICAgIC8vIE92ZXJyaWRlIHBhcnNlIHRvIGp1c3QgZGVsZWdhdGUgKG5vIHVuZGVmaW5lZCBoYW5kbGluZylcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROdWxsYWJsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVsbGFibGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuICAgICAgICByZXR1cm4gcGF0dGVybiA/IG5ldyBSZWdFeHAoYF4oJHt1dGlsLmNsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfXxudWxsKSRgKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzID8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgbnVsbF0pIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb24gKGRlY29kZSk6IGFsbG93IG51bGwgdG8gcGFzcyB0aHJvdWdoXG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2REZWZhdWx0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gaW5zdC5fem9kLnFpbiA9IFwidHJ1ZVwiO1xuICAgIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb24gKGRlY29kZSk6IGFwcGx5IGRlZmF1bHRzIGZvciB1bmRlZmluZWQgaW5wdXRcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICRab2REZWZhdWx0IHJldHVybnMgdGhlIGRlZmF1bHQgdmFsdWUgaW1tZWRpYXRlbHkgaW4gZm9yd2FyZCBkaXJlY3Rpb24uXG4gICAgICAgICAgICAgKiBJdCBkb2Vzbid0IHBhc3MgdGhlIGRlZmF1bHQgdmFsdWUgaW50byB0aGUgdmFsaWRhdG9yIChcInByZWZhdWx0XCIpLiBUaGVyZSdzIG5vIHJlYXNvbiB0byBwYXNzIHRoZSBkZWZhdWx0IHZhbHVlIHRocm91Z2ggdmFsaWRhdGlvbi4gVGhlIHZhbGlkaXR5IG9mIHRoZSBkZWZhdWx0IGlzIGVuZm9yY2VkIGJ5IFR5cGVTY3JpcHQgc3RhdGljYWxseS4gT3RoZXJ3aXNlLCBpdCdzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlciB0byBlbnN1cmUgdGhlIGRlZmF1bHQgaXMgdmFsaWQuIEluIHRoZSBjYXNlIG9mIHBpcGVzIHdpdGggZGl2ZXJnZW50IGluL291dCB0eXBlcywgeW91IGNhbiBzcGVjaWZ5IHRoZSBkZWZhdWx0IG9uIHRoZSBgaW5gIHNjaGVtYSBvZiB5b3VyIFpvZFBpcGUgdG8gc2V0IGEgXCJwcmVmYXVsdFwiIGZvciB0aGUgcGlwZS4gICAqL1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb246IGNvbnRpbnVlIHdpdGggZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQsIGRlZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVEZWZhdWx0UmVzdWx0KHJlc3VsdCwgZGVmKTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVEZWZhdWx0UmVzdWx0KHBheWxvYWQsIGRlZikge1xuICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBwYXlsb2FkO1xufVxuZXhwb3J0IGNvbnN0ICRab2RQcmVmYXVsdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kUHJlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcndhcmQgZGlyZWN0aW9uIChkZWNvZGUpOiBhcHBseSBwcmVmYXVsdCBmb3IgdW5kZWZpbmVkIGlucHV0XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROb25PcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTm9uT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHYgPSBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzO1xuICAgICAgICByZXR1cm4gdiA/IG5ldyBTZXQoWy4uLnZdLmZpbHRlcigoeCkgPT4geCAhPT0gdW5kZWZpbmVkKSkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZU5vbk9wdGlvbmFsUmVzdWx0KHJlc3VsdCwgaW5zdCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocGF5bG9hZCwgaW5zdCkge1xuICAgIGlmICghcGF5bG9hZC5pc3N1ZXMubGVuZ3RoICYmIHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBleHBlY3RlZDogXCJub25vcHRpb25hbFwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFN1Y2Nlc3MgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFN1Y2Nlc3NcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RFbmNvZGVFcnJvcihcIlpvZFN1Y2Nlc3NcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2F0Y2ggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3J3YXJkIGRpcmVjdGlvbiAoZGVjb2RlKTogYXBwbHkgY2F0Y2ggbG9naWNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgIC4uLnBheWxvYWQsXG4gICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTmFOID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROYU5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgIT09IFwibnVtYmVyXCIgfHwgIU51bWJlci5pc05hTihwYXlsb2FkLnZhbHVlKSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJuYW5cIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFBpcGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC52YWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmluLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vdXQuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC5wcm9wVmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gZGVmLm91dC5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJpZ2h0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodC50aGVuKChyaWdodCkgPT4gaGFuZGxlUGlwZVJlc3VsdChyaWdodCwgZGVmLmluLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVQaXBlUmVzdWx0KHJpZ2h0LCBkZWYuaW4sIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVmdCA9IGRlZi5pbi5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0LnRoZW4oKGxlZnQpID0+IGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLm91dCwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLm91dCwgY3R4KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIG5leHQsIGN0eCkge1xuICAgIGlmIChsZWZ0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgLy8gcHJldmVudCBmdXJ0aGVyIGNoZWNrc1xuICAgICAgICBsZWZ0LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbGVmdDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQuX3pvZC5ydW4oeyB2YWx1ZTogbGVmdC52YWx1ZSwgaXNzdWVzOiBsZWZ0Lmlzc3VlcyB9LCBjdHgpO1xufVxuZXhwb3J0IGNvbnN0ICRab2RDb2RlYyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ29kZWNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC52YWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmluLl96b2Qub3B0aW4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vdXQuX3pvZC5vcHRvdXQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC5wcm9wVmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGN0eC5kaXJlY3Rpb24gfHwgXCJmb3J3YXJkXCI7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gZGVmLmluLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAobGVmdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdC50aGVuKChsZWZ0KSA9PiBoYW5kbGVDb2RlY0FSZXN1bHQobGVmdCwgZGVmLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDb2RlY0FSZXN1bHQobGVmdCwgZGVmLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBkZWYub3V0Ll96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0LnRoZW4oKHJpZ2h0KSA9PiBoYW5kbGVDb2RlY0FSZXN1bHQocmlnaHQsIGRlZiwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlQ29kZWNBUmVzdWx0KHJpZ2h0LCBkZWYsIGN0eCk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVDb2RlY0FSZXN1bHQocmVzdWx0LCBkZWYsIGN0eCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAvLyBwcmV2ZW50IGZ1cnRoZXIgY2hlY2tzXG4gICAgICAgIHJlc3VsdC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgZGlyZWN0aW9uID0gY3R4LmRpcmVjdGlvbiB8fCBcImZvcndhcmRcIjtcbiAgICBpZiAoZGlyZWN0aW9uID09PSBcImZvcndhcmRcIikge1xuICAgICAgICBjb25zdCB0cmFuc2Zvcm1lZCA9IGRlZi50cmFuc2Zvcm0ocmVzdWx0LnZhbHVlLCByZXN1bHQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQudGhlbigodmFsdWUpID0+IGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB2YWx1ZSwgZGVmLm91dCwgY3R4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB0cmFuc2Zvcm1lZCwgZGVmLm91dCwgY3R4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gZGVmLnJldmVyc2VUcmFuc2Zvcm0ocmVzdWx0LnZhbHVlLCByZXN1bHQpO1xuICAgICAgICBpZiAodHJhbnNmb3JtZWQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtZWQudGhlbigodmFsdWUpID0+IGhhbmRsZUNvZGVjVHhSZXN1bHQocmVzdWx0LCB2YWx1ZSwgZGVmLmluLCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlQ29kZWNUeFJlc3VsdChyZXN1bHQsIHRyYW5zZm9ybWVkLCBkZWYuaW4sIGN0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gaGFuZGxlQ29kZWNUeFJlc3VsdChsZWZ0LCB2YWx1ZSwgbmV4dFNjaGVtYSwgY3R4KSB7XG4gICAgLy8gQ2hlY2sgaWYgdHJhbnNmb3JtIGFkZGVkIGFueSBpc3N1ZXNcbiAgICBpZiAobGVmdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGxlZnQuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dFNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IGxlZnQuaXNzdWVzIH0sIGN0eCk7XG59XG5leHBvcnQgY29uc3QgJFpvZFJlYWRvbmx5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RSZWFkb25seVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QucHJvcFZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlPy5fem9kPy5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZT8uX3pvZD8ub3B0b3V0KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKGhhbmRsZVJlYWRvbmx5UmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlUmVhZG9ubHlSZXN1bHQocmVzdWx0KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWFkb25seVJlc3VsdChwYXlsb2FkKSB7XG4gICAgcGF5bG9hZC52YWx1ZSA9IE9iamVjdC5mcmVlemUocGF5bG9hZC52YWx1ZSk7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFRlbXBsYXRlTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVGVtcGxhdGVMaXRlcmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgcmVnZXhQYXJ0cyA9IFtdO1xuICAgIGZvciAoY29uc3QgcGFydCBvZiBkZWYucGFydHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJ0ID09PSBcIm9iamVjdFwiICYmIHBhcnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIGlzIFpvZCBzY2hlbWFcbiAgICAgICAgICAgIGlmICghcGFydC5fem9kLnBhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAvLyBpZiAoIXNvdXJjZSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVtcGxhdGUgbGl0ZXJhbCBwYXJ0LCBubyBwYXR0ZXJuIGZvdW5kOiAke1suLi5wYXJ0Ll96b2QudHJhaXRzXS5zaGlmdCgpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gcGFydC5fem9kLnBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHAgPyBwYXJ0Ll96b2QucGF0dGVybi5zb3VyY2UgOiBwYXJ0Ll96b2QucGF0dGVybjtcbiAgICAgICAgICAgIGlmICghc291cmNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZW1wbGF0ZSBsaXRlcmFsIHBhcnQ6ICR7cGFydC5fem9kLnRyYWl0c31gKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc291cmNlLnN0YXJ0c1dpdGgoXCJeXCIpID8gMSA6IDA7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBzb3VyY2UuZW5kc1dpdGgoXCIkXCIpID8gc291cmNlLmxlbmd0aCAtIDEgOiBzb3VyY2UubGVuZ3RoO1xuICAgICAgICAgICAgcmVnZXhQYXJ0cy5wdXNoKHNvdXJjZS5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocGFydCA9PT0gbnVsbCB8fCB1dGlsLnByaW1pdGl2ZVR5cGVzLmhhcyh0eXBlb2YgcGFydCkpIHtcbiAgICAgICAgICAgIHJlZ2V4UGFydHMucHVzaCh1dGlsLmVzY2FwZVJlZ2V4KGAke3BhcnR9YCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlIGxpdGVyYWwgcGFydDogJHtwYXJ0fWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gbmV3IFJlZ0V4cChgXiR7cmVnZXhQYXJ0cy5qb2luKFwiXCIpfSRgKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaW5zdC5fem9kLnBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgaWYgKCFpbnN0Ll96b2QucGF0dGVybi50ZXN0KHBheWxvYWQudmFsdWUpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRlZi5mb3JtYXQgPz8gXCJ0ZW1wbGF0ZV9saXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgcGF0dGVybjogaW5zdC5fem9kLnBhdHRlcm4uc291cmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEZ1bmN0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RGdW5jdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX2RlZiA9IGRlZjtcbiAgICBpbnN0Ll96b2QuZGVmID0gZGVmO1xuICAgIGluc3QuaW1wbGVtZW50ID0gKGZ1bmMpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImltcGxlbWVudCgpIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBpbnN0Ll9kZWYuaW5wdXQgPyBwYXJzZShpbnN0Ll9kZWYuaW5wdXQsIGFyZ3MpIDogYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IFJlZmxlY3QuYXBwbHkoZnVuYywgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICBpZiAoaW5zdC5fZGVmLm91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZShpbnN0Ll9kZWYub3V0cHV0LCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGluc3QuaW1wbGVtZW50QXN5bmMgPSAoZnVuYykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50QXN5bmMoKSBtdXN0IGJlIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFzeW5jIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gaW5zdC5fZGVmLmlucHV0ID8gYXdhaXQgcGFyc2VBc3luYyhpbnN0Ll9kZWYuaW5wdXQsIGFyZ3MpIDogYXJncztcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFJlZmxlY3QuYXBwbHkoZnVuYywgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICBpZiAoaW5zdC5fZGVmLm91dHB1dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBwYXJzZUFzeW5jKGluc3QuX2RlZi5vdXRwdXQsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkLnZhbHVlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBvdXRwdXQgaXMgYSBwcm9taXNlIHR5cGUgdG8gZGV0ZXJtaW5lIGlmIHdlIHNob3VsZCB1c2UgYXN5bmMgaW1wbGVtZW50YXRpb25cbiAgICAgICAgY29uc3QgaGFzUHJvbWlzZU91dHB1dCA9IGluc3QuX2RlZi5vdXRwdXQgJiYgaW5zdC5fZGVmLm91dHB1dC5fem9kLmRlZi50eXBlID09PSBcInByb21pc2VcIjtcbiAgICAgICAgaWYgKGhhc1Byb21pc2VPdXRwdXQpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBpbnN0LmltcGxlbWVudEFzeW5jKHBheWxvYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGluc3QuaW1wbGVtZW50KHBheWxvYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG4gICAgaW5zdC5pbnB1dCA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGNvbnN0IEYgPSBpbnN0LmNvbnN0cnVjdG9yO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmdzWzBdKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBGKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IG5ldyAkWm9kVHVwbGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICByZXN0OiBhcmdzWzFdLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIG91dHB1dDogaW5zdC5fZGVmLm91dHB1dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRih7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogYXJnc1swXSxcbiAgICAgICAgICAgIG91dHB1dDogaW5zdC5fZGVmLm91dHB1dCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBpbnN0Lm91dHB1dCA9IChvdXRwdXQpID0+IHtcbiAgICAgICAgY29uc3QgRiA9IGluc3QuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgRih7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogaW5zdC5fZGVmLmlucHV0LFxuICAgICAgICAgICAgb3V0cHV0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBpbnN0O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFByb21pc2UgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFByb21pc2VcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocGF5bG9hZC52YWx1ZSkudGhlbigoaW5uZXIpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaW5uZXIsIGlzc3VlczogW10gfSwgY3R4KSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RMYXp5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RMYXp5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gbGV0IF9pbm5lclR5cGUhOiBhbnk7XG4gICAgLy8gdXRpbC5kZWZpbmVMYXp5KGRlZiwgXCJnZXR0ZXJcIiwgKCkgPT4ge1xuICAgIC8vICAgaWYgKCFfaW5uZXJUeXBlKSB7XG4gICAgLy8gICAgIF9pbm5lclR5cGUgPSBkZWYuZ2V0dGVyKCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gKCkgPT4gX2lubmVyVHlwZTtcbiAgICAvLyB9KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcImlubmVyVHlwZVwiLCAoKSA9PiBkZWYuZ2V0dGVyKCkpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiBpbnN0Ll96b2QuaW5uZXJUeXBlPy5fem9kPy5wYXR0ZXJuKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gaW5zdC5fem9kLmlubmVyVHlwZT8uX3pvZD8ucHJvcFZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBpbnN0Ll96b2QuaW5uZXJUeXBlPy5fem9kPy5vcHRpbiA/PyB1bmRlZmluZWQpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGluc3QuX3pvZC5pbm5lclR5cGU/Ll96b2Q/Lm9wdG91dCA/PyB1bmRlZmluZWQpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBpbnN0Ll96b2QuaW5uZXJUeXBlO1xuICAgICAgICByZXR1cm4gaW5uZXIuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEN1c3RvbSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ3VzdG9tXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjaGVja3MuJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF8pID0+IHtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHIgPSBkZWYuZm4oaW5wdXQpO1xuICAgICAgICBpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByLnRoZW4oKHIpID0+IGhhbmRsZVJlZmluZVJlc3VsdChyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkpO1xuICAgICAgICB9XG4gICAgICAgIGhhbmRsZVJlZmluZVJlc3VsdChyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVSZWZpbmVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkge1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IF9pc3MgPSB7XG4gICAgICAgICAgICBjb2RlOiBcImN1c3RvbVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LCAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICAgICAgICBwYXRoOiBbLi4uKGluc3QuX3pvZC5kZWYucGF0aCA/PyBbXSldLCAvLyBpbmNvcnBvcmF0ZXMgcGFyYW1zLmVycm9yIGludG8gaXNzdWUgcmVwb3J0aW5nXG4gICAgICAgICAgICBjb250aW51ZTogIWluc3QuX3pvZC5kZWYuYWJvcnQsXG4gICAgICAgICAgICAvLyBwYXJhbXM6IGluc3QuX3pvZC5kZWYucGFyYW1zLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5zdC5fem9kLmRlZi5wYXJhbXMpXG4gICAgICAgICAgICBfaXNzLnBhcmFtcyA9IGluc3QuX3pvZC5kZWYucGFyYW1zO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWwuaXNzdWUoX2lzcykpO1xuICAgIH1cbn1cbiIsICJpbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuLi9jb3JlL3V0aWwuanNcIjtcbmNvbnN0IGVycm9yID0gKCkgPT4ge1xuICAgIGNvbnN0IFNpemFibGUgPSB7XG4gICAgICAgIHN0cmluZzogeyB1bml0OiBcImNoYXJhY3RlcnNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgZmlsZTogeyB1bml0OiBcImJ5dGVzXCIsIHZlcmI6IFwidG8gaGF2ZVwiIH0sXG4gICAgICAgIGFycmF5OiB7IHVuaXQ6IFwiaXRlbXNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgc2V0OiB7IHVuaXQ6IFwiaXRlbXNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgbWFwOiB7IHVuaXQ6IFwiZW50cmllc1wiLCB2ZXJiOiBcInRvIGhhdmVcIiB9LFxuICAgIH07XG4gICAgZnVuY3Rpb24gZ2V0U2l6aW5nKG9yaWdpbikge1xuICAgICAgICByZXR1cm4gU2l6YWJsZVtvcmlnaW5dID8/IG51bGw7XG4gICAgfVxuICAgIGNvbnN0IEZvcm1hdERpY3Rpb25hcnkgPSB7XG4gICAgICAgIHJlZ2V4OiBcImlucHV0XCIsXG4gICAgICAgIGVtYWlsOiBcImVtYWlsIGFkZHJlc3NcIixcbiAgICAgICAgdXJsOiBcIlVSTFwiLFxuICAgICAgICBlbW9qaTogXCJlbW9qaVwiLFxuICAgICAgICB1dWlkOiBcIlVVSURcIixcbiAgICAgICAgdXVpZHY0OiBcIlVVSUR2NFwiLFxuICAgICAgICB1dWlkdjY6IFwiVVVJRHY2XCIsXG4gICAgICAgIG5hbm9pZDogXCJuYW5vaWRcIixcbiAgICAgICAgZ3VpZDogXCJHVUlEXCIsXG4gICAgICAgIGN1aWQ6IFwiY3VpZFwiLFxuICAgICAgICBjdWlkMjogXCJjdWlkMlwiLFxuICAgICAgICB1bGlkOiBcIlVMSURcIixcbiAgICAgICAgeGlkOiBcIlhJRFwiLFxuICAgICAgICBrc3VpZDogXCJLU1VJRFwiLFxuICAgICAgICBkYXRldGltZTogXCJJU08gZGF0ZXRpbWVcIixcbiAgICAgICAgZGF0ZTogXCJJU08gZGF0ZVwiLFxuICAgICAgICB0aW1lOiBcIklTTyB0aW1lXCIsXG4gICAgICAgIGR1cmF0aW9uOiBcIklTTyBkdXJhdGlvblwiLFxuICAgICAgICBpcHY0OiBcIklQdjQgYWRkcmVzc1wiLFxuICAgICAgICBpcHY2OiBcIklQdjYgYWRkcmVzc1wiLFxuICAgICAgICBtYWM6IFwiTUFDIGFkZHJlc3NcIixcbiAgICAgICAgY2lkcnY0OiBcIklQdjQgcmFuZ2VcIixcbiAgICAgICAgY2lkcnY2OiBcIklQdjYgcmFuZ2VcIixcbiAgICAgICAgYmFzZTY0OiBcImJhc2U2NC1lbmNvZGVkIHN0cmluZ1wiLFxuICAgICAgICBiYXNlNjR1cmw6IFwiYmFzZTY0dXJsLWVuY29kZWQgc3RyaW5nXCIsXG4gICAgICAgIGpzb25fc3RyaW5nOiBcIkpTT04gc3RyaW5nXCIsXG4gICAgICAgIGUxNjQ6IFwiRS4xNjQgbnVtYmVyXCIsXG4gICAgICAgIGp3dDogXCJKV1RcIixcbiAgICAgICAgdGVtcGxhdGVfbGl0ZXJhbDogXCJpbnB1dFwiLFxuICAgIH07XG4gICAgLy8gdHlwZSBuYW1lczogbWlzc2luZyBrZXlzID0gZG8gbm90IHRyYW5zbGF0ZSAodXNlIHJhdyB2YWx1ZSB2aWEgPz8gZmFsbGJhY2spXG4gICAgY29uc3QgVHlwZURpY3Rpb25hcnkgPSB7XG4gICAgICAgIC8vIENvbXBhdGliaWxpdHk6IFwibmFuXCIgLT4gXCJOYU5cIiBmb3IgZGlzcGxheVxuICAgICAgICBuYW46IFwiTmFOXCIsXG4gICAgICAgIC8vIEFsbCBvdGhlciB0eXBlIG5hbWVzIG9taXR0ZWQgLSB0aGV5IGZhbGwgYmFjayB0byByYXcgdmFsdWVzIHZpYSA/PyBvcGVyYXRvclxuICAgIH07XG4gICAgcmV0dXJuIChpc3N1ZSkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3R5cGVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gVHlwZURpY3Rpb25hcnlbaXNzdWUuZXhwZWN0ZWRdID8/IGlzc3VlLmV4cGVjdGVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpdmVkVHlwZSA9IHV0aWwucGFyc2VkVHlwZShpc3N1ZS5pbnB1dCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWQgPSBUeXBlRGljdGlvbmFyeVtyZWNlaXZlZFR5cGVdID8/IHJlY2VpdmVkVHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgaW5wdXQ6IGV4cGVjdGVkICR7ZXhwZWN0ZWR9LCByZWNlaXZlZCAke3JlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF92YWx1ZVwiOlxuICAgICAgICAgICAgICAgIGlmIChpc3N1ZS52YWx1ZXMubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgaW5wdXQ6IGV4cGVjdGVkICR7dXRpbC5zdHJpbmdpZnlQcmltaXRpdmUoaXNzdWUudmFsdWVzWzBdKX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBvcHRpb246IGV4cGVjdGVkIG9uZSBvZiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS52YWx1ZXMsIFwifFwiKX1gO1xuICAgICAgICAgICAgY2FzZSBcInRvb19iaWdcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkaiA9IGlzc3VlLmluY2x1c2l2ZSA/IFwiPD1cIiA6IFwiPFwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpemluZyA9IGdldFNpemluZyhpc3N1ZS5vcmlnaW4pO1xuICAgICAgICAgICAgICAgIGlmIChzaXppbmcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgVG9vIGJpZzogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW4gPz8gXCJ2YWx1ZVwifSB0byBoYXZlICR7YWRqfSR7aXNzdWUubWF4aW11bS50b1N0cmluZygpfSAke3NpemluZy51bml0ID8/IFwiZWxlbWVudHNcIn1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBgVG9vIGJpZzogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW4gPz8gXCJ2YWx1ZVwifSB0byBiZSAke2Fkan0ke2lzc3VlLm1heGltdW0udG9TdHJpbmcoKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcInRvb19zbWFsbFwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqID0gaXNzdWUuaW5jbHVzaXZlID8gXCI+PVwiIDogXCI+XCI7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6aW5nID0gZ2V0U2l6aW5nKGlzc3VlLm9yaWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKHNpemluZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYFRvbyBzbWFsbDogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW59IHRvIGhhdmUgJHthZGp9JHtpc3N1ZS5taW5pbXVtLnRvU3RyaW5nKCl9ICR7c2l6aW5nLnVuaXR9YDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBUb28gc21hbGw6IGV4cGVjdGVkICR7aXNzdWUub3JpZ2lufSB0byBiZSAke2Fkan0ke2lzc3VlLm1pbmltdW0udG9TdHJpbmcoKX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfaXNzdWUgPSBpc3N1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZvcm1hdCA9PT0gXCJzdGFydHNfd2l0aFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBzdHJpbmc6IG11c3Qgc3RhcnQgd2l0aCBcIiR7X2lzc3VlLnByZWZpeH1cImA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZm9ybWF0ID09PSBcImVuZHNfd2l0aFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgc3RyaW5nOiBtdXN0IGVuZCB3aXRoIFwiJHtfaXNzdWUuc3VmZml4fVwiYDtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZvcm1hdCA9PT0gXCJpbmNsdWRlc1wiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgc3RyaW5nOiBtdXN0IGluY2x1ZGUgXCIke19pc3N1ZS5pbmNsdWRlc31cImA7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mb3JtYXQgPT09IFwicmVnZXhcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHN0cmluZzogbXVzdCBtYXRjaCBwYXR0ZXJuICR7X2lzc3VlLnBhdHRlcm59YDtcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgJHtGb3JtYXREaWN0aW9uYXJ5W19pc3N1ZS5mb3JtYXRdID8/IGlzc3VlLmZvcm1hdH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcIm5vdF9tdWx0aXBsZV9vZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBudW1iZXI6IG11c3QgYmUgYSBtdWx0aXBsZSBvZiAke2lzc3VlLmRpdmlzb3J9YDtcbiAgICAgICAgICAgIGNhc2UgXCJ1bnJlY29nbml6ZWRfa2V5c1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBgVW5yZWNvZ25pemVkIGtleSR7aXNzdWUua2V5cy5sZW5ndGggPiAxID8gXCJzXCIgOiBcIlwifTogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfa2V5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGtleSBpbiAke2lzc3VlLm9yaWdpbn1gO1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfdW5pb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9lbGVtZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHZhbHVlIGluICR7aXNzdWUub3JpZ2lufWA7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBpbnB1dGA7XG4gICAgICAgIH1cbiAgICB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBsb2NhbGVFcnJvcjogZXJyb3IoKSxcbiAgICB9O1xufVxuIiwgInZhciBfYTtcbmV4cG9ydCBjb25zdCAkb3V0cHV0ID0gU3ltYm9sKFwiWm9kT3V0cHV0XCIpO1xuZXhwb3J0IGNvbnN0ICRpbnB1dCA9IFN5bWJvbChcIlpvZElucHV0XCIpO1xuZXhwb3J0IGNsYXNzICRab2RSZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX21hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgICAgIHRoaXMuX2lkbWFwID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBhZGQoc2NoZW1hLCAuLi5fbWV0YSkge1xuICAgICAgICBjb25zdCBtZXRhID0gX21ldGFbMF07XG4gICAgICAgIHRoaXMuX21hcC5zZXQoc2NoZW1hLCBtZXRhKTtcbiAgICAgICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIG1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkbWFwLnNldChtZXRhLmlkLCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5faWRtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZW1vdmUoc2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gICAgICAgIGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB7XG4gICAgICAgICAgICB0aGlzLl9pZG1hcC5kZWxldGUobWV0YS5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWFwLmRlbGV0ZShzY2hlbWEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0KHNjaGVtYSkge1xuICAgICAgICAvLyByZXR1cm4gdGhpcy5fbWFwLmdldChzY2hlbWEpIGFzIGFueTtcbiAgICAgICAgLy8gaW5oZXJpdCBtZXRhZGF0YVxuICAgICAgICBjb25zdCBwID0gc2NoZW1hLl96b2QucGFyZW50O1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgY29uc3QgcG0gPSB7IC4uLih0aGlzLmdldChwKSA/PyB7fSkgfTtcbiAgICAgICAgICAgIGRlbGV0ZSBwbS5pZDsgLy8gZG8gbm90IGluaGVyaXQgaWRcbiAgICAgICAgICAgIGNvbnN0IGYgPSB7IC4uLnBtLCAuLi50aGlzLl9tYXAuZ2V0KHNjaGVtYSkgfTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhmKS5sZW5ndGggPyBmIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG4gICAgfVxuICAgIGhhcyhzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5oYXMoc2NoZW1hKTtcbiAgICB9XG59XG4vLyByZWdpc3RyaWVzXG5leHBvcnQgZnVuY3Rpb24gcmVnaXN0cnkoKSB7XG4gICAgcmV0dXJuIG5ldyAkWm9kUmVnaXN0cnkoKTtcbn1cbihfYSA9IGdsb2JhbFRoaXMpLl9fem9kX2dsb2JhbFJlZ2lzdHJ5ID8/IChfYS5fX3pvZF9nbG9iYWxSZWdpc3RyeSA9IHJlZ2lzdHJ5KCkpO1xuZXhwb3J0IGNvbnN0IGdsb2JhbFJlZ2lzdHJ5ID0gZ2xvYmFsVGhpcy5fX3pvZF9nbG9iYWxSZWdpc3RyeTtcbiIsICJpbXBvcnQgKiBhcyBjaGVja3MgZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgKiBhcyByZWdpc3RyaWVzIGZyb20gXCIuL3JlZ2lzdHJpZXMuanNcIjtcbmltcG9ydCAqIGFzIHNjaGVtYXMgZnJvbSBcIi4vc2NoZW1hcy5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdHJpbmcoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlZFN0cmluZyhDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2VtYWlsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImVtYWlsXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZ3VpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJndWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXVpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1dWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXVpZHY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInV1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IFwidjRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3V1aWR2NihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1dWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uOiBcInY2XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91dWlkdjcoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidXVpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgdmVyc2lvbjogXCJ2N1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXJsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInVybFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Vtb2ppKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImVtb2ppXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbmFub2lkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcIm5hbm9pZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2N1aWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiY3VpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2N1aWQyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImN1aWQyXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdWxpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1bGlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfeGlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInhpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2tzdWlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImtzdWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXB2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJpcHY0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXB2NihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJpcHY2XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWFjKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcIm1hY1wiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NpZHJ2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJjaWRydjRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jaWRydjYoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiY2lkcnY2XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImJhc2U2NFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Jhc2U2NHVybChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJiYXNlNjR1cmxcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lMTY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImUxNjRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9qd3QoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiand0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFRpbWVQcmVjaXNpb24gPSB7XG4gICAgQW55OiBudWxsLFxuICAgIE1pbnV0ZTogLTEsXG4gICAgU2Vjb25kOiAwLFxuICAgIE1pbGxpc2Vjb25kOiAzLFxuICAgIE1pY3Jvc2Vjb25kOiA2LFxufTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lzb0RhdGVUaW1lKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImRhdGV0aW1lXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgb2Zmc2V0OiBmYWxzZSxcbiAgICAgICAgbG9jYWw6IGZhbHNlLFxuICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pc29EYXRlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImRhdGVcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXNvVGltZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ0aW1lXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgcHJlY2lzaW9uOiBudWxsLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXNvRHVyYXRpb24oQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZHVyYXRpb25cIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbnVtYmVyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWROdW1iZXIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcInNhZmVpbnRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Zsb2F0MzIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImZsb2F0MzJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Zsb2F0NjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImZsb2F0NjRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2ludDMyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJpbnQzMlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdWludDMyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgY2hlY2s6IFwibnVtYmVyX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIGZvcm1hdDogXCJ1aW50MzJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Jvb2xlYW4oQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWRCb29sZWFuKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2JpZ2ludChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VkQmlnaW50KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaW50NjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBjaGVjazogXCJiaWdpbnRfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImludDY0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91aW50NjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBjaGVjazogXCJiaWdpbnRfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcInVpbnQ2NFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3ltYm9sKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzeW1ib2xcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VuZGVmaW5lZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9udWxsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJudWxsXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9hbnkoQ2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJhbnlcIixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3Vua25vd24oQ2xhc3MpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmtub3duXCIsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9uZXZlcihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibmV2ZXJcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3ZvaWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInZvaWRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2RhdGUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWREYXRlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25hbihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibmFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sdCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTGVzc1RoYW4oe1xuICAgICAgICBjaGVjazogXCJsZXNzX3RoYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sdGUodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0xlc3NUaGFuKHtcbiAgICAgICAgY2hlY2s6IFwibGVzc190aGFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgeyBcbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHoubHRlKClgIGluc3RlYWQuICovXG5fbHRlIGFzIF9tYXgsIH07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ndCh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrR3JlYXRlclRoYW4oe1xuICAgICAgICBjaGVjazogXCJncmVhdGVyX3RoYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ndGUodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0dyZWF0ZXJUaGFuKHtcbiAgICAgICAgY2hlY2s6IFwiZ3JlYXRlcl90aGFuXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnQgeyBcbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHouZ3RlKClgIGluc3RlYWQuICovXG5fZ3RlIGFzIF9taW4sIH07XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9wb3NpdGl2ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gX2d0KDAsIHBhcmFtcyk7XG59XG4vLyBuZWdhdGl2ZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbmVnYXRpdmUocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9sdCgwLCBwYXJhbXMpO1xufVxuLy8gbm9ucG9zaXRpdmVcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25vbnBvc2l0aXZlKHBhcmFtcykge1xuICAgIHJldHVybiBfbHRlKDAsIHBhcmFtcyk7XG59XG4vLyBub25uZWdhdGl2ZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbm9ubmVnYXRpdmUocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9ndGUoMCwgcGFyYW1zKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX211bHRpcGxlT2YodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja011bHRpcGxlT2Yoe1xuICAgICAgICBjaGVjazogXCJtdWx0aXBsZV9vZlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB2YWx1ZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21heFNpemUobWF4aW11bSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTWF4U2l6ZSh7XG4gICAgICAgIGNoZWNrOiBcIm1heF9zaXplXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIG1heGltdW0sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9taW5TaXplKG1pbmltdW0sIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja01pblNpemUoe1xuICAgICAgICBjaGVjazogXCJtaW5fc2l6ZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBtaW5pbXVtLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc2l6ZShzaXplLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tTaXplRXF1YWxzKHtcbiAgICAgICAgY2hlY2s6IFwic2l6ZV9lcXVhbHNcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgc2l6ZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21heExlbmd0aChtYXhpbXVtLCBwYXJhbXMpIHtcbiAgICBjb25zdCBjaCA9IG5ldyBjaGVja3MuJFpvZENoZWNrTWF4TGVuZ3RoKHtcbiAgICAgICAgY2hlY2s6IFwibWF4X2xlbmd0aFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBtYXhpbXVtLFxuICAgIH0pO1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21pbkxlbmd0aChtaW5pbXVtLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNaW5MZW5ndGgoe1xuICAgICAgICBjaGVjazogXCJtaW5fbGVuZ3RoXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIG1pbmltdW0sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9sZW5ndGgobGVuZ3RoLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tMZW5ndGhFcXVhbHMoe1xuICAgICAgICBjaGVjazogXCJsZW5ndGhfZXF1YWxzXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIGxlbmd0aCxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3JlZ2V4KHBhdHRlcm4sIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1JlZ2V4KHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwicmVnZXhcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgcGF0dGVybixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xvd2VyY2FzZShwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tMb3dlckNhc2Uoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJsb3dlcmNhc2VcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VwcGVyY2FzZShwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tVcHBlckNhc2Uoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJ1cHBlcmNhc2VcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2luY2x1ZGVzKGluY2x1ZGVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tJbmNsdWRlcyh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcImluY2x1ZGVzXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIGluY2x1ZGVzLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3RhcnRzV2l0aChwcmVmaXgsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1N0YXJ0c1dpdGgoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJzdGFydHNfd2l0aFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBwcmVmaXgsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lbmRzV2l0aChzdWZmaXgsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0VuZHNXaXRoKHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwiZW5kc193aXRoXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHN1ZmZpeCxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3Byb3BlcnR5KHByb3BlcnR5LCBzY2hlbWEsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1Byb3BlcnR5KHtcbiAgICAgICAgY2hlY2s6IFwicHJvcGVydHlcIixcbiAgICAgICAgcHJvcGVydHksXG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21pbWUodHlwZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja01pbWVUeXBlKHtcbiAgICAgICAgY2hlY2s6IFwibWltZV90eXBlXCIsXG4gICAgICAgIG1pbWU6IHR5cGVzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfb3ZlcndyaXRlKHR4KSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrT3ZlcndyaXRlKHtcbiAgICAgICAgY2hlY2s6IFwib3ZlcndyaXRlXCIsXG4gICAgICAgIHR4LFxuICAgIH0pO1xufVxuLy8gbm9ybWFsaXplXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ub3JtYWxpemUoZm9ybSkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gaW5wdXQubm9ybWFsaXplKGZvcm0pKTtcbn1cbi8vIHRyaW1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RyaW0oKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiBpbnB1dC50cmltKCkpO1xufVxuLy8gdG9Mb3dlckNhc2Vcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RvTG93ZXJDYXNlKCkge1xuICAgIHJldHVybiBfb3ZlcndyaXRlKChpbnB1dCkgPT4gaW5wdXQudG9Mb3dlckNhc2UoKSk7XG59XG4vLyB0b1VwcGVyQ2FzZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdG9VcHBlckNhc2UoKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiBpbnB1dC50b1VwcGVyQ2FzZSgpKTtcbn1cbi8vIHNsdWdpZnlcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3NsdWdpZnkoKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiB1dGlsLnNsdWdpZnkoaW5wdXQpKTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2FycmF5KENsYXNzLCBlbGVtZW50LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICBlbGVtZW50LFxuICAgICAgICAvLyBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgLy8gICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgLy8gfSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VuaW9uKENsYXNzLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF94b3IoQ2xhc3MsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9kaXNjcmltaW5hdGVkVW5pb24oQ2xhc3MsIGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnRlcnNlY3Rpb24oQ2xhc3MsIGxlZnQsIHJpZ2h0KSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0LFxuICAgIH0pO1xufVxuLy8gZXhwb3J0IGZ1bmN0aW9uIF90dXBsZShcbi8vICAgQ2xhc3M6IHV0aWwuU2NoZW1hQ2xhc3M8c2NoZW1hcy4kWm9kVHVwbGU+LFxuLy8gICBpdGVtczogW10sXG4vLyAgIHBhcmFtcz86IHN0cmluZyB8ICRab2RUdXBsZVBhcmFtc1xuLy8gKTogc2NoZW1hcy4kWm9kVHVwbGU8W10sIG51bGw+O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdHVwbGUoQ2xhc3MsIGl0ZW1zLCBfcGFyYW1zT3JSZXN0LCBfcGFyYW1zKSB7XG4gICAgY29uc3QgaGFzUmVzdCA9IF9wYXJhbXNPclJlc3QgaW5zdGFuY2VvZiBzY2hlbWFzLiRab2RUeXBlO1xuICAgIGNvbnN0IHBhcmFtcyA9IGhhc1Jlc3QgPyBfcGFyYW1zIDogX3BhcmFtc09yUmVzdDtcbiAgICBjb25zdCByZXN0ID0gaGFzUmVzdCA/IF9wYXJhbXNPclJlc3QgOiBudWxsO1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInR1cGxlXCIsXG4gICAgICAgIGl0ZW1zLFxuICAgICAgICByZXN0LFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcmVjb3JkKENsYXNzLCBrZXlUeXBlLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9tYXAoQ2xhc3MsIGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3NldChDbGFzcywgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzZXRcIixcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZW51bShDbGFzcywgdmFsdWVzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gT2JqZWN0LmZyb21FbnRyaWVzKHZhbHVlcy5tYXAoKHYpID0+IFt2LCB2XSkpIDogdmFsdWVzO1xuICAgIC8vIGlmIChBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAvLyAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgLy8gICAgIGVudHJpZXNbdmFsdWVdID0gdmFsdWU7XG4gICAgLy8gICB9XG4gICAgLy8gfSBlbHNlIHtcbiAgICAvLyAgIE9iamVjdC5hc3NpZ24oZW50cmllcywgdmFsdWVzKTtcbiAgICAvLyB9XG4gICAgLy8gY29uc3QgZW50cmllczogdXRpbC5FbnVtTGlrZSA9IHt9O1xuICAgIC8vIGZvciAoY29uc3QgdmFsIG9mIHZhbHVlcykge1xuICAgIC8vICAgZW50cmllc1t2YWxdID0gdmFsO1xuICAgIC8vIH1cbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuLyoqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIG1lcmdlZCBpbnRvIGB6LmVudW0oKWAuIFVzZSBgei5lbnVtKClgIGluc3RlYWQuXG4gKlxuICogYGBgdHNcbiAqIGVudW0gQ29sb3JzIHsgcmVkLCBncmVlbiwgYmx1ZSB9XG4gKiB6LmVudW0oQ29sb3JzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gX25hdGl2ZUVudW0oQ2xhc3MsIGVudHJpZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xpdGVyYWwoQ2xhc3MsIHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJsaXRlcmFsXCIsXG4gICAgICAgIHZhbHVlczogQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV0sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9maWxlKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90cmFuc2Zvcm0oQ2xhc3MsIGZuKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHRyYW5zZm9ybTogZm4sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9vcHRpb25hbChDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbnVsbGFibGUoQ2xhc3MsIGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2RlZmF1bHQoQ2xhc3MsIGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiB1dGlsLnNoYWxsb3dDbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbm9ub3B0aW9uYWwoQ2xhc3MsIGlubmVyVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3VjY2VzcyhDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3VjY2Vzc1wiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jYXRjaChDbGFzcywgaW5uZXJUeXBlLCBjYXRjaFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiY2F0Y2hcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgICAgICBjYXRjaFZhbHVlOiAodHlwZW9mIGNhdGNoVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhdGNoVmFsdWUgOiAoKSA9PiBjYXRjaFZhbHVlKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3BpcGUoQ2xhc3MsIGluXywgb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicGlwZVwiLFxuICAgICAgICBpbjogaW5fLFxuICAgICAgICBvdXQsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWFkb25seShDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdGVtcGxhdGVMaXRlcmFsKENsYXNzLCBwYXJ0cywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidGVtcGxhdGVfbGl0ZXJhbFwiLFxuICAgICAgICBwYXJ0cyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xhenkoQ2xhc3MsIGdldHRlcikge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImxhenlcIixcbiAgICAgICAgZ2V0dGVyLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcHJvbWlzZShDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicHJvbWlzZVwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jdXN0b20oQ2xhc3MsIGZuLCBfcGFyYW1zKSB7XG4gICAgY29uc3Qgbm9ybSA9IHV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpO1xuICAgIG5vcm0uYWJvcnQgPz8gKG5vcm0uYWJvcnQgPSB0cnVlKTsgLy8gZGVmYXVsdCB0byBhYm9ydDpmYWxzZVxuICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgICAgICBmbjogZm4sXG4gICAgICAgIC4uLm5vcm0sXG4gICAgfSk7XG4gICAgcmV0dXJuIHNjaGVtYTtcbn1cbi8vIHNhbWUgYXMgX2N1c3RvbSBidXQgZGVmYXVsdHMgdG8gYWJvcnQ6ZmFsc2Vcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3JlZmluZShDbGFzcywgZm4sIF9wYXJhbXMpIHtcbiAgICBjb25zdCBzY2hlbWEgPSBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgZm46IGZuLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSxcbiAgICB9KTtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3VwZXJSZWZpbmUoZm4pIHtcbiAgICBjb25zdCBjaCA9IF9jaGVjaygocGF5bG9hZCkgPT4ge1xuICAgICAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKGlzc3VlLCBwYXlsb2FkLnZhbHVlLCBjaC5fem9kLmRlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIFpvZCAzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWU7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mYXRhbClcbiAgICAgICAgICAgICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmNvZGUgPz8gKF9pc3N1ZS5jb2RlID0gXCJjdXN0b21cIik7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuaW5zdCA/PyAoX2lzc3VlLmluc3QgPSBjaCk7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID8/IChfaXNzdWUuY29udGludWUgPSAhY2guX3pvZC5kZWYuYWJvcnQpOyAvLyBhYm9ydCBpcyBhbHdheXMgdW5kZWZpbmVkLCBzbyB0aGlzIGlzIGFsd2F5cyB0cnVlLi4uXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZm4ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY2hlY2soZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2soe1xuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbiAgICBjaC5fem9kLmNoZWNrID0gZm47XG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBkZXNjcmliZShkZXNjcmlwdGlvbikge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2soeyBjaGVjazogXCJkZXNjcmliZVwiIH0pO1xuICAgIGNoLl96b2Qub25hdHRhY2ggPSBbXG4gICAgICAgIChpbnN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZyA9IHJlZ2lzdHJpZXMuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpID8/IHt9O1xuICAgICAgICAgICAgcmVnaXN0cmllcy5nbG9iYWxSZWdpc3RyeS5hZGQoaW5zdCwgeyAuLi5leGlzdGluZywgZGVzY3JpcHRpb24gfSk7XG4gICAgICAgIH0sXG4gICAgXTtcbiAgICBjaC5fem9kLmNoZWNrID0gKCkgPT4geyB9OyAvLyBuby1vcCBjaGVja1xuICAgIHJldHVybiBjaDtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gbWV0YShtZXRhZGF0YSkge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2soeyBjaGVjazogXCJtZXRhXCIgfSk7XG4gICAgY2guX3pvZC5vbmF0dGFjaCA9IFtcbiAgICAgICAgKGluc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmVnaXN0cmllcy5nbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCkgPz8ge307XG4gICAgICAgICAgICByZWdpc3RyaWVzLmdsb2JhbFJlZ2lzdHJ5LmFkZChpbnN0LCB7IC4uLmV4aXN0aW5nLCAuLi5tZXRhZGF0YSB9KTtcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGNoLl96b2QuY2hlY2sgPSAoKSA9PiB7IH07IC8vIG5vLW9wIGNoZWNrXG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3RyaW5nYm9vbChDbGFzc2VzLCBfcGFyYW1zKSB7XG4gICAgY29uc3QgcGFyYW1zID0gdXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyk7XG4gICAgbGV0IHRydXRoeUFycmF5ID0gcGFyYW1zLnRydXRoeSA/PyBbXCJ0cnVlXCIsIFwiMVwiLCBcInllc1wiLCBcIm9uXCIsIFwieVwiLCBcImVuYWJsZWRcIl07XG4gICAgbGV0IGZhbHN5QXJyYXkgPSBwYXJhbXMuZmFsc3kgPz8gW1wiZmFsc2VcIiwgXCIwXCIsIFwibm9cIiwgXCJvZmZcIiwgXCJuXCIsIFwiZGlzYWJsZWRcIl07XG4gICAgaWYgKHBhcmFtcy5jYXNlICE9PSBcInNlbnNpdGl2ZVwiKSB7XG4gICAgICAgIHRydXRoeUFycmF5ID0gdHJ1dGh5QXJyYXkubWFwKCh2KSA9PiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyB2LnRvTG93ZXJDYXNlKCkgOiB2KSk7XG4gICAgICAgIGZhbHN5QXJyYXkgPSBmYWxzeUFycmF5Lm1hcCgodikgPT4gKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiID8gdi50b0xvd2VyQ2FzZSgpIDogdikpO1xuICAgIH1cbiAgICBjb25zdCB0cnV0aHlTZXQgPSBuZXcgU2V0KHRydXRoeUFycmF5KTtcbiAgICBjb25zdCBmYWxzeVNldCA9IG5ldyBTZXQoZmFsc3lBcnJheSk7XG4gICAgY29uc3QgX0NvZGVjID0gQ2xhc3Nlcy5Db2RlYyA/PyBzY2hlbWFzLiRab2RDb2RlYztcbiAgICBjb25zdCBfQm9vbGVhbiA9IENsYXNzZXMuQm9vbGVhbiA/PyBzY2hlbWFzLiRab2RCb29sZWFuO1xuICAgIGNvbnN0IF9TdHJpbmcgPSBDbGFzc2VzLlN0cmluZyA/PyBzY2hlbWFzLiRab2RTdHJpbmc7XG4gICAgY29uc3Qgc3RyaW5nU2NoZW1hID0gbmV3IF9TdHJpbmcoeyB0eXBlOiBcInN0cmluZ1wiLCBlcnJvcjogcGFyYW1zLmVycm9yIH0pO1xuICAgIGNvbnN0IGJvb2xlYW5TY2hlbWEgPSBuZXcgX0Jvb2xlYW4oeyB0eXBlOiBcImJvb2xlYW5cIiwgZXJyb3I6IHBhcmFtcy5lcnJvciB9KTtcbiAgICBjb25zdCBjb2RlYyA9IG5ldyBfQ29kZWMoe1xuICAgICAgICB0eXBlOiBcInBpcGVcIixcbiAgICAgICAgaW46IHN0cmluZ1NjaGVtYSxcbiAgICAgICAgb3V0OiBib29sZWFuU2NoZW1hLFxuICAgICAgICB0cmFuc2Zvcm06ICgoaW5wdXQsIHBheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGxldCBkYXRhID0gaW5wdXQ7XG4gICAgICAgICAgICBpZiAocGFyYW1zLmNhc2UgIT09IFwic2Vuc2l0aXZlXCIpXG4gICAgICAgICAgICAgICAgZGF0YSA9IGRhdGEudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh0cnV0aHlTZXQuaGFzKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmYWxzeVNldC5oYXMoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInN0cmluZ2Jvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBbLi4udHJ1dGh5U2V0LCAuLi5mYWxzeVNldF0sXG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbnN0OiBjb2RlYyxcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm06ICgoaW5wdXQsIF9wYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5wdXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1dGh5QXJyYXlbMF0gfHwgXCJ0cnVlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc3lBcnJheVswXSB8fCBcImZhbHNlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogcGFyYW1zLmVycm9yLFxuICAgIH0pO1xuICAgIHJldHVybiBjb2RlYztcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N0cmluZ0Zvcm1hdChDbGFzcywgZm9ybWF0LCBmbk9yUmVnZXgsIF9wYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpO1xuICAgIGNvbnN0IGRlZiA9IHtcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyksXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0LFxuICAgICAgICBmbjogdHlwZW9mIGZuT3JSZWdleCA9PT0gXCJmdW5jdGlvblwiID8gZm5PclJlZ2V4IDogKHZhbCkgPT4gZm5PclJlZ2V4LnRlc3QodmFsKSxcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgIH07XG4gICAgaWYgKGZuT3JSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBkZWYucGF0dGVybiA9IGZuT3JSZWdleDtcbiAgICB9XG4gICAgY29uc3QgaW5zdCA9IG5ldyBDbGFzcyhkZWYpO1xuICAgIHJldHVybiBpbnN0O1xufVxuIiwgImltcG9ydCB7IGdsb2JhbFJlZ2lzdHJ5IH0gZnJvbSBcIi4vcmVnaXN0cmllcy5qc1wiO1xuLy8gZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnRleHQ8VCBleHRlbmRzIHNjaGVtYXMuJFpvZFR5cGU+KGlucHV0czogSlNPTlNjaGVtYUdlbmVyYXRvclBhcmFtczxUPik6IFRvSlNPTlNjaGVtYUNvbnRleHQ8VD4ge1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHByb2Nlc3NvcjogaW5wdXRzLnByb2Nlc3Nvcixcbi8vICAgICBtZXRhZGF0YVJlZ2lzdHJ5OiBpbnB1dHMubWV0YWRhdGEgPz8gZ2xvYmFsUmVnaXN0cnksXG4vLyAgICAgdGFyZ2V0OiBpbnB1dHMudGFyZ2V0ID8/IFwiZHJhZnQtMjAyMC0xMlwiLFxuLy8gICAgIHVucmVwcmVzZW50YWJsZTogaW5wdXRzLnVucmVwcmVzZW50YWJsZSA/PyBcInRocm93XCIsXG4vLyAgIH07XG4vLyB9XG5leHBvcnQgZnVuY3Rpb24gaW5pdGlhbGl6ZUNvbnRleHQocGFyYW1zKSB7XG4gICAgLy8gTm9ybWFsaXplIHRhcmdldDogY29udmVydCBvbGQgbm9uLWh5cGhlbmF0ZWQgdmVyc2lvbnMgdG8gaHlwaGVuYXRlZCB2ZXJzaW9uc1xuICAgIGxldCB0YXJnZXQgPSBwYXJhbXM/LnRhcmdldCA/PyBcImRyYWZ0LTIwMjAtMTJcIjtcbiAgICBpZiAodGFyZ2V0ID09PSBcImRyYWZ0LTRcIilcbiAgICAgICAgdGFyZ2V0ID0gXCJkcmFmdC0wNFwiO1xuICAgIGlmICh0YXJnZXQgPT09IFwiZHJhZnQtN1wiKVxuICAgICAgICB0YXJnZXQgPSBcImRyYWZ0LTA3XCI7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvY2Vzc29yczogcGFyYW1zLnByb2Nlc3NvcnMgPz8ge30sXG4gICAgICAgIG1ldGFkYXRhUmVnaXN0cnk6IHBhcmFtcz8ubWV0YWRhdGEgPz8gZ2xvYmFsUmVnaXN0cnksXG4gICAgICAgIHRhcmdldCxcbiAgICAgICAgdW5yZXByZXNlbnRhYmxlOiBwYXJhbXM/LnVucmVwcmVzZW50YWJsZSA/PyBcInRocm93XCIsXG4gICAgICAgIG92ZXJyaWRlOiBwYXJhbXM/Lm92ZXJyaWRlID8/ICgoKSA9PiB7IH0pLFxuICAgICAgICBpbzogcGFyYW1zPy5pbyA/PyBcIm91dHB1dFwiLFxuICAgICAgICBjb3VudGVyOiAwLFxuICAgICAgICBzZWVuOiBuZXcgTWFwKCksXG4gICAgICAgIGN5Y2xlczogcGFyYW1zPy5jeWNsZXMgPz8gXCJyZWZcIixcbiAgICAgICAgcmV1c2VkOiBwYXJhbXM/LnJldXNlZCA/PyBcImlubGluZVwiLFxuICAgICAgICBleHRlcm5hbDogcGFyYW1zPy5leHRlcm5hbCA/PyB1bmRlZmluZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzKHNjaGVtYSwgY3R4LCBfcGFyYW1zID0geyBwYXRoOiBbXSwgc2NoZW1hUGF0aDogW10gfSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgLy8gY2hlY2sgZm9yIHNjaGVtYSBpbiBzZWVuc1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBpZiAoc2Vlbikge1xuICAgICAgICBzZWVuLmNvdW50Kys7XG4gICAgICAgIC8vIGNoZWNrIGlmIGN5Y2xlXG4gICAgICAgIGNvbnN0IGlzQ3ljbGUgPSBfcGFyYW1zLnNjaGVtYVBhdGguaW5jbHVkZXMoc2NoZW1hKTtcbiAgICAgICAgaWYgKGlzQ3ljbGUpIHtcbiAgICAgICAgICAgIHNlZW4uY3ljbGUgPSBfcGFyYW1zLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlZW4uc2NoZW1hO1xuICAgIH1cbiAgICAvLyBpbml0aWFsaXplXG4gICAgY29uc3QgcmVzdWx0ID0geyBzY2hlbWE6IHt9LCBjb3VudDogMSwgY3ljbGU6IHVuZGVmaW5lZCwgcGF0aDogX3BhcmFtcy5wYXRoIH07XG4gICAgY3R4LnNlZW4uc2V0KHNjaGVtYSwgcmVzdWx0KTtcbiAgICAvLyBjdXN0b20gbWV0aG9kIG92ZXJyaWRlcyBkZWZhdWx0IGJlaGF2aW9yXG4gICAgY29uc3Qgb3ZlcnJpZGVTY2hlbWEgPSBzY2hlbWEuX3pvZC50b0pTT05TY2hlbWE/LigpO1xuICAgIGlmIChvdmVycmlkZVNjaGVtYSkge1xuICAgICAgICByZXN1bHQuc2NoZW1hID0gb3ZlcnJpZGVTY2hlbWE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAuLi5fcGFyYW1zLFxuICAgICAgICAgICAgc2NoZW1hUGF0aDogWy4uLl9wYXJhbXMuc2NoZW1hUGF0aCwgc2NoZW1hXSxcbiAgICAgICAgICAgIHBhdGg6IF9wYXJhbXMucGF0aCxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHNjaGVtYS5fem9kLnByb2Nlc3NKU09OU2NoZW1hKSB7XG4gICAgICAgICAgICBzY2hlbWEuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYShjdHgsIHJlc3VsdC5zY2hlbWEsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBfanNvbiA9IHJlc3VsdC5zY2hlbWE7XG4gICAgICAgICAgICBjb25zdCBwcm9jZXNzb3IgPSBjdHgucHJvY2Vzc29yc1tkZWYudHlwZV07XG4gICAgICAgICAgICBpZiAoIXByb2Nlc3Nvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgW3RvSlNPTlNjaGVtYV06IE5vbi1yZXByZXNlbnRhYmxlIHR5cGUgZW5jb3VudGVyZWQ6ICR7ZGVmLnR5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9jZXNzb3Ioc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHNjaGVtYS5fem9kLnBhcmVudDtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgLy8gQWxzbyBzZXQgcmVmIGlmIHByb2Nlc3NvciBkaWRuJ3QgKGZvciBpbmhlcml0YW5jZSlcbiAgICAgICAgICAgIGlmICghcmVzdWx0LnJlZilcbiAgICAgICAgICAgICAgICByZXN1bHQucmVmID0gcGFyZW50O1xuICAgICAgICAgICAgcHJvY2VzcyhwYXJlbnQsIGN0eCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGN0eC5zZWVuLmdldChwYXJlbnQpLmlzUGFyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBtZXRhZGF0YVxuICAgIGNvbnN0IG1ldGEgPSBjdHgubWV0YWRhdGFSZWdpc3RyeS5nZXQoc2NoZW1hKTtcbiAgICBpZiAobWV0YSlcbiAgICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQuc2NoZW1hLCBtZXRhKTtcbiAgICBpZiAoY3R4LmlvID09PSBcImlucHV0XCIgJiYgaXNUcmFuc2Zvcm1pbmcoc2NoZW1hKSkge1xuICAgICAgICAvLyBleGFtcGxlcy9kZWZhdWx0cyBvbmx5IGFwcGx5IHRvIG91dHB1dCB0eXBlIG9mIHBpcGVcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zY2hlbWEuZXhhbXBsZXM7XG4gICAgICAgIGRlbGV0ZSByZXN1bHQuc2NoZW1hLmRlZmF1bHQ7XG4gICAgfVxuICAgIC8vIHNldCBwcmVmYXVsdCBhcyBkZWZhdWx0XG4gICAgaWYgKGN0eC5pbyA9PT0gXCJpbnB1dFwiICYmIHJlc3VsdC5zY2hlbWEuX3ByZWZhdWx0KVxuICAgICAgICAoX2EgPSByZXN1bHQuc2NoZW1hKS5kZWZhdWx0ID8/IChfYS5kZWZhdWx0ID0gcmVzdWx0LnNjaGVtYS5fcHJlZmF1bHQpO1xuICAgIGRlbGV0ZSByZXN1bHQuc2NoZW1hLl9wcmVmYXVsdDtcbiAgICAvLyBwdWxsaW5nIGZyZXNoIGZyb20gY3R4LnNlZW4gaW4gY2FzZSBpdCB3YXMgb3ZlcndyaXR0ZW5cbiAgICBjb25zdCBfcmVzdWx0ID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgcmV0dXJuIF9yZXN1bHQuc2NoZW1hO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dHJhY3REZWZzKGN0eCwgc2NoZW1hXG4vLyBwYXJhbXM6IEVtaXRQYXJhbXNcbikge1xuICAgIC8vIGl0ZXJhdGUgb3ZlciBzZWVuIG1hcDtcbiAgICBjb25zdCByb290ID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgaWYgKCFyb290KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnByb2Nlc3NlZCBzY2hlbWEuIFRoaXMgaXMgYSBidWcgaW4gWm9kLlwiKTtcbiAgICAvLyBUcmFjayBpZHMgdG8gZGV0ZWN0IGR1cGxpY2F0ZXMgYWNyb3NzIGRpZmZlcmVudCBzY2hlbWFzXG4gICAgY29uc3QgaWRUb1NjaGVtYSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGN0eC5zZWVuLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBpZCA9IGN0eC5tZXRhZGF0YVJlZ2lzdHJ5LmdldChlbnRyeVswXSk/LmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gaWRUb1NjaGVtYS5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nICYmIGV4aXN0aW5nICE9PSBlbnRyeVswXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlIHNjaGVtYSBpZCBcIiR7aWR9XCIgZGV0ZWN0ZWQgZHVyaW5nIEpTT04gU2NoZW1hIGNvbnZlcnNpb24uIFR3byBkaWZmZXJlbnQgc2NoZW1hcyBjYW5ub3Qgc2hhcmUgdGhlIHNhbWUgaWQgd2hlbiBjb252ZXJ0ZWQgdG9nZXRoZXIuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZFRvU2NoZW1hLnNldChpZCwgZW50cnlbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJldHVybnMgYSByZWYgdG8gdGhlIHNjaGVtYVxuICAgIC8vIGRlZklkIHdpbGwgYmUgZW1wdHkgaWYgdGhlIHJlZiBwb2ludHMgdG8gYW4gZXh0ZXJuYWwgc2NoZW1hIChvciAjKVxuICAgIGNvbnN0IG1ha2VVUkkgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gY29tcGFyaW5nIHRoZSBzZWVuIG9iamVjdHMgYmVjYXVzZSBzb21ldGltZXNcbiAgICAgICAgLy8gbXVsdGlwbGUgc2NoZW1hcyBtYXAgdG8gdGhlIHNhbWUgc2VlbiBvYmplY3QuXG4gICAgICAgIC8vIGUuZy4gbGF6eVxuICAgICAgICAvLyBleHRlcm5hbCBpcyBjb25maWd1cmVkXG4gICAgICAgIGNvbnN0IGRlZnNTZWdtZW50ID0gY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcIiRkZWZzXCIgOiBcImRlZmluaXRpb25zXCI7XG4gICAgICAgIGlmIChjdHguZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsSWQgPSBjdHguZXh0ZXJuYWwucmVnaXN0cnkuZ2V0KGVudHJ5WzBdKT8uaWQ7IC8vID8/IFwiX19zaGFyZWRcIjsvLyBgX19zY2hlbWEke2N0eC5jb3VudGVyKyt9YDtcbiAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNjaGVtYSBpcyBpbiB0aGUgZXh0ZXJuYWwgcmVnaXN0cnlcbiAgICAgICAgICAgIGNvbnN0IHVyaUdlbmVyYXRvciA9IGN0eC5leHRlcm5hbC51cmkgPz8gKChpZCkgPT4gaWQpO1xuICAgICAgICAgICAgaWYgKGV4dGVybmFsSWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyByZWY6IHVyaUdlbmVyYXRvcihleHRlcm5hbElkKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBhZGQgdG8gX19zaGFyZWRcbiAgICAgICAgICAgIGNvbnN0IGlkID0gZW50cnlbMV0uZGVmSWQgPz8gZW50cnlbMV0uc2NoZW1hLmlkID8/IGBzY2hlbWEke2N0eC5jb3VudGVyKyt9YDtcbiAgICAgICAgICAgIGVudHJ5WzFdLmRlZklkID0gaWQ7IC8vIHNldCBkZWZJZCBzbyBpdCB3aWxsIGJlIHJldXNlZCBpZiBuZWVkZWRcbiAgICAgICAgICAgIHJldHVybiB7IGRlZklkOiBpZCwgcmVmOiBgJHt1cmlHZW5lcmF0b3IoXCJfX3NoYXJlZFwiKX0jLyR7ZGVmc1NlZ21lbnR9LyR7aWR9YCB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnRyeVsxXSA9PT0gcm9vdCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcmVmOiBcIiNcIiB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIHNlbGYtY29udGFpbmVkIHNjaGVtYVxuICAgICAgICBjb25zdCB1cmlQcmVmaXggPSBgI2A7XG4gICAgICAgIGNvbnN0IGRlZlVyaVByZWZpeCA9IGAke3VyaVByZWZpeH0vJHtkZWZzU2VnbWVudH0vYDtcbiAgICAgICAgY29uc3QgZGVmSWQgPSBlbnRyeVsxXS5zY2hlbWEuaWQgPz8gYF9fc2NoZW1hJHtjdHguY291bnRlcisrfWA7XG4gICAgICAgIHJldHVybiB7IGRlZklkLCByZWY6IGRlZlVyaVByZWZpeCArIGRlZklkIH07XG4gICAgfTtcbiAgICAvLyBzdG9yZWQgY2FjaGVkIHZlcnNpb24gaW4gYGRlZmAgcHJvcGVydHlcbiAgICAvLyByZW1vdmUgYWxsIHByb3BlcnRpZXMsIHNldCAkcmVmXG4gICAgY29uc3QgZXh0cmFjdFRvRGVmID0gKGVudHJ5KSA9PiB7XG4gICAgICAgIC8vIGlmIHRoZSBzY2hlbWEgaXMgYWxyZWFkeSBhIHJlZmVyZW5jZSwgZG8gbm90IGV4dHJhY3QgaXRcbiAgICAgICAgaWYgKGVudHJ5WzFdLnNjaGVtYS4kcmVmKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VlbiA9IGVudHJ5WzFdO1xuICAgICAgICBjb25zdCB7IHJlZiwgZGVmSWQgfSA9IG1ha2VVUkkoZW50cnkpO1xuICAgICAgICBzZWVuLmRlZiA9IHsgLi4uc2Vlbi5zY2hlbWEgfTtcbiAgICAgICAgLy8gZGVmSWQgd29uJ3QgYmUgc2V0IGlmIHRoZSBzY2hlbWEgaXMgYSByZWZlcmVuY2UgdG8gYW4gZXh0ZXJuYWwgc2NoZW1hXG4gICAgICAgIC8vIG9yIGlmIHRoZSBzY2hlbWEgaXMgdGhlIHJvb3Qgc2NoZW1hXG4gICAgICAgIGlmIChkZWZJZClcbiAgICAgICAgICAgIHNlZW4uZGVmSWQgPSBkZWZJZDtcbiAgICAgICAgLy8gd2lwZSBhd2F5IGFsbCBwcm9wZXJ0aWVzIGV4Y2VwdCAkcmVmXG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHNlZW4uc2NoZW1hO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuJHJlZiA9IHJlZjtcbiAgICB9O1xuICAgIC8vIHRocm93IG9uIGN5Y2xlc1xuICAgIC8vIGJyZWFrIGN5Y2xlc1xuICAgIGlmIChjdHguY3ljbGVzID09PSBcInRocm93XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdHguc2Vlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlZW4gPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIGlmIChzZWVuLmN5Y2xlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ3ljbGUgZGV0ZWN0ZWQ6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgYCMvJHtzZWVuLmN5Y2xlPy5qb2luKFwiL1wiKX0vPHJvb3Q+YCArXG4gICAgICAgICAgICAgICAgICAgICdcXG5cXG5TZXQgdGhlIGBjeWNsZXNgIHBhcmFtZXRlciB0byBgXCJyZWZcImAgdG8gcmVzb2x2ZSBjeWNsaWNhbCBzY2hlbWFzIHdpdGggZGVmcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBleHRyYWN0IHNjaGVtYXMgaW50byAkZGVmc1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgY3R4LnNlZW4uZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBlbnRyeVsxXTtcbiAgICAgICAgLy8gY29udmVydCByb290IHNjaGVtYSB0byAjICRyZWZcbiAgICAgICAgaWYgKHNjaGVtYSA9PT0gZW50cnlbMF0pIHtcbiAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7IC8vIHRoaXMgaGFzIHNwZWNpYWwgaGFuZGxpbmcgZm9yIHRoZSByb290IHNjaGVtYVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0cmFjdCBzY2hlbWFzIHRoYXQgYXJlIGluIHRoZSBleHRlcm5hbCByZWdpc3RyeVxuICAgICAgICBpZiAoY3R4LmV4dGVybmFsKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSBjdHguZXh0ZXJuYWwucmVnaXN0cnkuZ2V0KGVudHJ5WzBdKT8uaWQ7XG4gICAgICAgICAgICBpZiAoc2NoZW1hICE9PSBlbnRyeVswXSAmJiBleHQpIHtcbiAgICAgICAgICAgICAgICBleHRyYWN0VG9EZWYoZW50cnkpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4dHJhY3Qgc2NoZW1hcyB3aXRoIGBpZGAgbWV0YVxuICAgICAgICBjb25zdCBpZCA9IGN0eC5tZXRhZGF0YVJlZ2lzdHJ5LmdldChlbnRyeVswXSk/LmlkO1xuICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBicmVhayBjeWNsZXNcbiAgICAgICAgaWYgKHNlZW4uY3ljbGUpIHtcbiAgICAgICAgICAgIC8vIGFueVxuICAgICAgICAgICAgZXh0cmFjdFRvRGVmKGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV4dHJhY3QgcmV1c2VkIHNjaGVtYXNcbiAgICAgICAgaWYgKHNlZW4uY291bnQgPiAxKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnJldXNlZCA9PT0gXCJyZWZcIikge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7XG4gICAgICAgICAgICAgICAgLy8gYmlvbWUtaWdub3JlIGxpbnQ6XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZmluYWxpemUoY3R4LCBzY2hlbWEpIHtcbiAgICBjb25zdCByb290ID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgaWYgKCFyb290KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbnByb2Nlc3NlZCBzY2hlbWEuIFRoaXMgaXMgYSBidWcgaW4gWm9kLlwiKTtcbiAgICAvLyBmbGF0dGVuIHJlZnMgLSBpbmhlcml0IHByb3BlcnRpZXMgZnJvbSBwYXJlbnQgc2NoZW1hc1xuICAgIGNvbnN0IGZsYXR0ZW5SZWYgPSAoem9kU2NoZW1hKSA9PiB7XG4gICAgICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoem9kU2NoZW1hKTtcbiAgICAgICAgLy8gYWxyZWFkeSBwcm9jZXNzZWRcbiAgICAgICAgaWYgKHNlZW4ucmVmID09PSBudWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBzY2hlbWEgPSBzZWVuLmRlZiA/PyBzZWVuLnNjaGVtYTtcbiAgICAgICAgY29uc3QgX2NhY2hlZCA9IHsgLi4uc2NoZW1hIH07XG4gICAgICAgIGNvbnN0IHJlZiA9IHNlZW4ucmVmO1xuICAgICAgICBzZWVuLnJlZiA9IG51bGw7IC8vIHByZXZlbnQgaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5SZWYocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZlNlZW4gPSBjdHguc2Vlbi5nZXQocmVmKTtcbiAgICAgICAgICAgIGNvbnN0IHJlZlNjaGVtYSA9IHJlZlNlZW4uc2NoZW1hO1xuICAgICAgICAgICAgLy8gbWVyZ2UgcmVmZXJlbmNlZCBzY2hlbWEgaW50byBjdXJyZW50XG4gICAgICAgICAgICBpZiAocmVmU2NoZW1hLiRyZWYgJiYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDdcIiB8fCBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSkge1xuICAgICAgICAgICAgICAgIC8vIG9sZGVyIGRyYWZ0cyBjYW4ndCBjb21iaW5lICRyZWYgd2l0aCBvdGhlciBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgc2NoZW1hLmFsbE9mID0gc2NoZW1hLmFsbE9mID8/IFtdO1xuICAgICAgICAgICAgICAgIHNjaGVtYS5hbGxPZi5wdXNoKHJlZlNjaGVtYSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNjaGVtYSwgcmVmU2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJlc3RvcmUgY2hpbGQncyBvd24gcHJvcGVydGllcyAoY2hpbGQgd2lucylcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCBfY2FjaGVkKTtcbiAgICAgICAgICAgIGNvbnN0IGlzUGFyZW50UmVmID0gem9kU2NoZW1hLl96b2QucGFyZW50ID09PSByZWY7XG4gICAgICAgICAgICAvLyBGb3IgcGFyZW50IGNoYWluLCBjaGlsZCBpcyBhIHJlZmluZW1lbnQgLSByZW1vdmUgcGFyZW50LW9ubHkgcHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50UmVmKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiIHx8IGtleSA9PT0gXCJhbGxPZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGtleSBpbiBfY2FjaGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2hlbiByZWYgd2FzIGV4dHJhY3RlZCB0byAkZGVmcywgcmVtb3ZlIHByb3BlcnRpZXMgdGhhdCBtYXRjaCB0aGUgZGVmaW5pdGlvblxuICAgICAgICAgICAgaWYgKHJlZlNjaGVtYS4kcmVmICYmIHJlZlNlZW4uZGVmKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiIHx8IGtleSA9PT0gXCJhbGxPZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcmVmU2Vlbi5kZWYgJiYgSlNPTi5zdHJpbmdpZnkoc2NoZW1hW2tleV0pID09PSBKU09OLnN0cmluZ2lmeShyZWZTZWVuLmRlZltrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHBhcmVudCB3YXMgZXh0cmFjdGVkIChoYXMgJHJlZiksIHByb3BhZ2F0ZSAkcmVmIHRvIHRoaXMgc2NoZW1hXG4gICAgICAgIC8vIFRoaXMgaGFuZGxlcyBjYXNlcyBsaWtlOiByZWFkb25seSgpLm1ldGEoe2lkfSkuZGVzY3JpYmUoKVxuICAgICAgICAvLyB3aGVyZSBwcm9jZXNzb3Igc2V0cyByZWYgdG8gaW5uZXJUeXBlIGJ1dCBwYXJlbnQgc2hvdWxkIGJlIHJlZmVyZW5jZWRcbiAgICAgICAgY29uc3QgcGFyZW50ID0gem9kU2NoZW1hLl96b2QucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50ICYmIHBhcmVudCAhPT0gcmVmKSB7XG4gICAgICAgICAgICAvLyBFbnN1cmUgcGFyZW50IGlzIHByb2Nlc3NlZCBmaXJzdCBzbyBpdHMgZGVmIGhhcyBpbmhlcml0ZWQgcHJvcGVydGllc1xuICAgICAgICAgICAgZmxhdHRlblJlZihwYXJlbnQpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50U2VlbiA9IGN0eC5zZWVuLmdldChwYXJlbnQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudFNlZW4/LnNjaGVtYS4kcmVmKSB7XG4gICAgICAgICAgICAgICAgc2NoZW1hLiRyZWYgPSBwYXJlbnRTZWVuLnNjaGVtYS4kcmVmO1xuICAgICAgICAgICAgICAgIC8vIERlLWR1cGxpY2F0ZSB3aXRoIHBhcmVudCdzIGRlZmluaXRpb25cbiAgICAgICAgICAgICAgICBpZiAocGFyZW50U2Vlbi5kZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcIiRyZWZcIiB8fCBrZXkgPT09IFwiYWxsT2ZcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgaW4gcGFyZW50U2Vlbi5kZWYgJiYgSlNPTi5zdHJpbmdpZnkoc2NoZW1hW2tleV0pID09PSBKU09OLnN0cmluZ2lmeShwYXJlbnRTZWVuLmRlZltrZXldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWFba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBleGVjdXRlIG92ZXJyaWRlc1xuICAgICAgICBjdHgub3ZlcnJpZGUoe1xuICAgICAgICAgICAgem9kU2NoZW1hOiB6b2RTY2hlbWEsXG4gICAgICAgICAgICBqc29uU2NoZW1hOiBzY2hlbWEsXG4gICAgICAgICAgICBwYXRoOiBzZWVuLnBhdGggPz8gW10sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBbLi4uY3R4LnNlZW4uZW50cmllcygpXS5yZXZlcnNlKCkpIHtcbiAgICAgICAgZmxhdHRlblJlZihlbnRyeVswXSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIikge1xuICAgICAgICByZXN1bHQuJHNjaGVtYSA9IFwiaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAyMC0xMi9zY2hlbWFcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wN1wiKSB7XG4gICAgICAgIHJlc3VsdC4kc2NoZW1hID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiKSB7XG4gICAgICAgIHJlc3VsdC4kc2NoZW1hID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA0L3NjaGVtYSNcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIC8vIE9wZW5BUEkgMy4wIHNjaGVtYSBvYmplY3RzIHNob3VsZCBub3QgaW5jbHVkZSBhICRzY2hlbWEgcHJvcGVydHlcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEFyYml0cmFyeSBzdHJpbmcgdmFsdWVzIGFyZSBhbGxvd2VkIGJ1dCB3b24ndCBoYXZlIGEgJHNjaGVtYSBwcm9wZXJ0eSBzZXRcbiAgICB9XG4gICAgaWYgKGN0eC5leHRlcm5hbD8udXJpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gY3R4LmV4dGVybmFsLnJlZ2lzdHJ5LmdldChzY2hlbWEpPy5pZDtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNjaGVtYSBpcyBtaXNzaW5nIGFuIGBpZGAgcHJvcGVydHlcIik7XG4gICAgICAgIHJlc3VsdC4kaWQgPSBjdHguZXh0ZXJuYWwudXJpKGlkKTtcbiAgICB9XG4gICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIHJvb3QuZGVmID8/IHJvb3Quc2NoZW1hKTtcbiAgICAvLyBidWlsZCBkZWZzIG9iamVjdFxuICAgIGNvbnN0IGRlZnMgPSBjdHguZXh0ZXJuYWw/LmRlZnMgPz8ge307XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdHguc2Vlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IGVudHJ5WzFdO1xuICAgICAgICBpZiAoc2Vlbi5kZWYgJiYgc2Vlbi5kZWZJZCkge1xuICAgICAgICAgICAgZGVmc1tzZWVuLmRlZklkXSA9IHNlZW4uZGVmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHNldCBkZWZpbml0aW9ucyBpbiByZXN1bHRcbiAgICBpZiAoY3R4LmV4dGVybmFsKSB7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LiRkZWZzID0gZGVmcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5kZWZpbml0aW9ucyA9IGRlZnM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gdGhpcyBcImZpbmFsaXplc1wiIHRoaXMgc2NoZW1hIGFuZCBlbnN1cmVzIGFsbCBjeWNsZXMgYXJlIHJlbW92ZWRcbiAgICAgICAgLy8gZWFjaCBjYWxsIHRvIGZpbmFsaXplKCkgaXMgZnVuY3Rpb25hbGx5IGluZGVwZW5kZW50XG4gICAgICAgIC8vIHRob3VnaCB0aGUgc2VlbiBtYXAgaXMgc2hhcmVkXG4gICAgICAgIGNvbnN0IGZpbmFsaXplZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocmVzdWx0KSk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmaW5hbGl6ZWQsIFwifnN0YW5kYXJkXCIsIHtcbiAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgLi4uc2NoZW1hW1wifnN0YW5kYXJkXCJdLFxuICAgICAgICAgICAgICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChzY2hlbWEsIFwiaW5wdXRcIiwgY3R4LnByb2Nlc3NvcnMpLFxuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChzY2hlbWEsIFwib3V0cHV0XCIsIGN0eC5wcm9jZXNzb3JzKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZpbmFsaXplZDtcbiAgICB9XG4gICAgY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY29udmVydGluZyBzY2hlbWEgdG8gSlNPTi5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNUcmFuc2Zvcm1pbmcoX3NjaGVtYSwgX2N0eCkge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPz8geyBzZWVuOiBuZXcgU2V0KCkgfTtcbiAgICBpZiAoY3R4LnNlZW4uaGFzKF9zY2hlbWEpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY3R4LnNlZW4uYWRkKF9zY2hlbWEpO1xuICAgIGNvbnN0IGRlZiA9IF9zY2hlbWEuX3pvZC5kZWY7XG4gICAgaWYgKGRlZi50eXBlID09PSBcInRyYW5zZm9ybVwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5lbGVtZW50LCBjdHgpO1xuICAgIGlmIChkZWYudHlwZSA9PT0gXCJzZXRcIilcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi52YWx1ZVR5cGUsIGN0eCk7XG4gICAgaWYgKGRlZi50eXBlID09PSBcImxhenlcIilcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5nZXR0ZXIoKSwgY3R4KTtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwicHJvbWlzZVwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcIm9wdGlvbmFsXCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwibm9ub3B0aW9uYWxcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJudWxsYWJsZVwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcInJlYWRvbmx5XCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwiZGVmYXVsdFwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcInByZWZhdWx0XCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5pbm5lclR5cGUsIGN0eCk7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJpbnRlcnNlY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmxlZnQsIGN0eCkgfHwgaXNUcmFuc2Zvcm1pbmcoZGVmLnJpZ2h0LCBjdHgpO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwicmVjb3JkXCIgfHwgZGVmLnR5cGUgPT09IFwibWFwXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5rZXlUeXBlLCBjdHgpIHx8IGlzVHJhbnNmb3JtaW5nKGRlZi52YWx1ZVR5cGUsIGN0eCk7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJwaXBlXCIpIHtcbiAgICAgICAgcmV0dXJuIGlzVHJhbnNmb3JtaW5nKGRlZi5pbiwgY3R4KSB8fCBpc1RyYW5zZm9ybWluZyhkZWYub3V0LCBjdHgpO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGVmLnNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1pbmcoZGVmLnNoYXBlW2tleV0sIGN0eCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVmLnR5cGUgPT09IFwidW5pb25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtaW5nKG9wdGlvbiwgY3R4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBkZWYuaXRlbXMpIHtcbiAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybWluZyhpdGVtLCBjdHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYucmVzdCAmJiBpc1RyYW5zZm9ybWluZyhkZWYucmVzdCwgY3R4KSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIHRvSlNPTlNjaGVtYSBtZXRob2QgZm9yIGEgc2NoZW1hIGluc3RhbmNlLlxuICogVGhpcyBlbmNhcHN1bGF0ZXMgdGhlIGxvZ2ljIG9mIGluaXRpYWxpemluZyBjb250ZXh0LCBwcm9jZXNzaW5nLCBleHRyYWN0aW5nIGRlZnMsIGFuZCBmaW5hbGl6aW5nLlxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVG9KU09OU2NoZW1hTWV0aG9kID0gKHNjaGVtYSwgcHJvY2Vzc29ycyA9IHt9KSA9PiAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gaW5pdGlhbGl6ZUNvbnRleHQoeyAuLi5wYXJhbXMsIHByb2Nlc3NvcnMgfSk7XG4gICAgcHJvY2VzcyhzY2hlbWEsIGN0eCk7XG4gICAgZXh0cmFjdERlZnMoY3R4LCBzY2hlbWEpO1xuICAgIHJldHVybiBmaW5hbGl6ZShjdHgsIHNjaGVtYSk7XG59O1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZCA9IChzY2hlbWEsIGlvLCBwcm9jZXNzb3JzID0ge30pID0+IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGxpYnJhcnlPcHRpb25zLCB0YXJnZXQgfSA9IHBhcmFtcyA/PyB7fTtcbiAgICBjb25zdCBjdHggPSBpbml0aWFsaXplQ29udGV4dCh7IC4uLihsaWJyYXJ5T3B0aW9ucyA/PyB7fSksIHRhcmdldCwgaW8sIHByb2Nlc3NvcnMgfSk7XG4gICAgcHJvY2VzcyhzY2hlbWEsIGN0eCk7XG4gICAgZXh0cmFjdERlZnMoY3R4LCBzY2hlbWEpO1xuICAgIHJldHVybiBmaW5hbGl6ZShjdHgsIHNjaGVtYSk7XG59O1xuIiwgImltcG9ydCB7IGV4dHJhY3REZWZzLCBmaW5hbGl6ZSwgaW5pdGlhbGl6ZUNvbnRleHQsIHByb2Nlc3MsIH0gZnJvbSBcIi4vdG8tanNvbi1zY2hlbWEuanNcIjtcbmltcG9ydCB7IGdldEVudW1WYWx1ZXMgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5jb25zdCBmb3JtYXRNYXAgPSB7XG4gICAgZ3VpZDogXCJ1dWlkXCIsXG4gICAgdXJsOiBcInVyaVwiLFxuICAgIGRhdGV0aW1lOiBcImRhdGUtdGltZVwiLFxuICAgIGpzb25fc3RyaW5nOiBcImpzb24tc3RyaW5nXCIsXG4gICAgcmVnZXg6IFwiXCIsIC8vIGRvIG5vdCBzZXRcbn07XG4vLyA9PT09PT09PT09PT09PT09PT09PSBTSU1QTEUgVFlQRSBQUk9DRVNTT1JTID09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgY29uc3Qgc3RyaW5nUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBqc29uLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgIGNvbnN0IHsgbWluaW11bSwgbWF4aW11bSwgZm9ybWF0LCBwYXR0ZXJucywgY29udGVudEVuY29kaW5nIH0gPSBzY2hlbWEuX3pvZFxuICAgICAgICAuYmFnO1xuICAgIGlmICh0eXBlb2YgbWluaW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5taW5MZW5ndGggPSBtaW5pbXVtO1xuICAgIGlmICh0eXBlb2YgbWF4aW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tYXhMZW5ndGggPSBtYXhpbXVtO1xuICAgIC8vIGN1c3RvbSBwYXR0ZXJuIG92ZXJyaWRlcyBmb3JtYXRcbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIGpzb24uZm9ybWF0ID0gZm9ybWF0TWFwW2Zvcm1hdF0gPz8gZm9ybWF0O1xuICAgICAgICBpZiAoanNvbi5mb3JtYXQgPT09IFwiXCIpXG4gICAgICAgICAgICBkZWxldGUganNvbi5mb3JtYXQ7IC8vIGVtcHR5IGZvcm1hdCBpcyBub3QgdmFsaWRcbiAgICAgICAgLy8gSlNPTiBTY2hlbWEgZm9ybWF0OiBcInRpbWVcIiByZXF1aXJlcyBhIGZ1bGwgdGltZSB3aXRoIG9mZnNldCBvciBaXG4gICAgICAgIC8vIHouaXNvLnRpbWUoKSBkb2VzIG5vdCBpbmNsdWRlIHRpbWV6b25lIGluZm9ybWF0aW9uLCBzbyBmb3JtYXQ6IFwidGltZVwiIHNob3VsZCBuZXZlciBiZSB1c2VkXG4gICAgICAgIGlmIChmb3JtYXQgPT09IFwidGltZVwiKSB7XG4gICAgICAgICAgICBkZWxldGUganNvbi5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbnRlbnRFbmNvZGluZylcbiAgICAgICAganNvbi5jb250ZW50RW5jb2RpbmcgPSBjb250ZW50RW5jb2Rpbmc7XG4gICAgaWYgKHBhdHRlcm5zICYmIHBhdHRlcm5zLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlZ2V4ZXMgPSBbLi4ucGF0dGVybnNdO1xuICAgICAgICBpZiAocmVnZXhlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBqc29uLnBhdHRlcm4gPSByZWdleGVzWzBdLnNvdXJjZTtcbiAgICAgICAgZWxzZSBpZiAocmVnZXhlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBqc29uLmFsbE9mID0gW1xuICAgICAgICAgICAgICAgIC4uLnJlZ2V4ZXMubWFwKChyZWdleCkgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDdcIiB8fCBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHsgdHlwZTogXCJzdHJpbmdcIiB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogcmVnZXguc291cmNlLFxuICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG51bWJlclByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtLCBmb3JtYXQsIG11bHRpcGxlT2YsIGV4Y2x1c2l2ZU1heGltdW0sIGV4Y2x1c2l2ZU1pbmltdW0gfSA9IHNjaGVtYS5fem9kLmJhZztcbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PT0gXCJzdHJpbmdcIiAmJiBmb3JtYXQuaW5jbHVkZXMoXCJpbnRcIikpXG4gICAgICAgIGpzb24udHlwZSA9IFwiaW50ZWdlclwiO1xuICAgIGVsc2VcbiAgICAgICAganNvbi50eXBlID0gXCJudW1iZXJcIjtcbiAgICBpZiAodHlwZW9mIGV4Y2x1c2l2ZU1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIiB8fCBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgICAgIGpzb24ubWluaW11bSA9IGV4Y2x1c2l2ZU1pbmltdW07XG4gICAgICAgICAgICBqc29uLmV4Y2x1c2l2ZU1pbmltdW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAganNvbi5leGNsdXNpdmVNaW5pbXVtID0gZXhjbHVzaXZlTWluaW11bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAganNvbi5taW5pbXVtID0gbWluaW11bTtcbiAgICAgICAgaWYgKHR5cGVvZiBleGNsdXNpdmVNaW5pbXVtID09PSBcIm51bWJlclwiICYmIGN0eC50YXJnZXQgIT09IFwiZHJhZnQtMDRcIikge1xuICAgICAgICAgICAgaWYgKGV4Y2x1c2l2ZU1pbmltdW0gPj0gbWluaW11bSlcbiAgICAgICAgICAgICAgICBkZWxldGUganNvbi5taW5pbXVtO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmV4Y2x1c2l2ZU1pbmltdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBleGNsdXNpdmVNYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgICAgICBqc29uLm1heGltdW0gPSBleGNsdXNpdmVNYXhpbXVtO1xuICAgICAgICAgICAganNvbi5leGNsdXNpdmVNYXhpbXVtID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGpzb24uZXhjbHVzaXZlTWF4aW11bSA9IGV4Y2x1c2l2ZU1heGltdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIGpzb24ubWF4aW11bSA9IG1heGltdW07XG4gICAgICAgIGlmICh0eXBlb2YgZXhjbHVzaXZlTWF4aW11bSA9PT0gXCJudW1iZXJcIiAmJiBjdHgudGFyZ2V0ICE9PSBcImRyYWZ0LTA0XCIpIHtcbiAgICAgICAgICAgIGlmIChleGNsdXNpdmVNYXhpbXVtIDw9IG1heGltdW0pXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpzb24ubWF4aW11bTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBkZWxldGUganNvbi5leGNsdXNpdmVNYXhpbXVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbXVsdGlwbGVPZiA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tdWx0aXBsZU9mID0gbXVsdGlwbGVPZjtcbn07XG5leHBvcnQgY29uc3QgYm9vbGVhblByb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAganNvbi50eXBlID0gXCJib29sZWFuXCI7XG59O1xuZXhwb3J0IGNvbnN0IGJpZ2ludFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCaWdJbnQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc3ltYm9sUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlN5bWJvbHMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbnVsbFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGpzb24ubnVsbGFibGUgPSB0cnVlO1xuICAgICAgICBqc29uLmVudW0gPSBbbnVsbF07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uLnR5cGUgPSBcIm51bGxcIjtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHVuZGVmaW5lZFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgdm9pZFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWb2lkIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG5ldmVyUHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBqc29uLm5vdCA9IHt9O1xufTtcbmV4cG9ydCBjb25zdCBhbnlQcm9jZXNzb3IgPSAoX3NjaGVtYSwgX2N0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICAvLyBlbXB0eSBzY2hlbWEgYWNjZXB0cyBhbnl0aGluZ1xufTtcbmV4cG9ydCBjb25zdCB1bmtub3duUHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgLy8gZW1wdHkgc2NoZW1hIGFjY2VwdHMgYW55dGhpbmdcbn07XG5leHBvcnQgY29uc3QgZGF0ZVByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRlIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IGVudW1Qcm9jZXNzb3IgPSAoc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IHZhbHVlcyA9IGdldEVudW1WYWx1ZXMoZGVmLmVudHJpZXMpO1xuICAgIC8vIE51bWJlciBlbnVtcyBjYW4gaGF2ZSBib3RoIHN0cmluZyBhbmQgbnVtYmVyIHZhbHVlc1xuICAgIGlmICh2YWx1ZXMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcIm51bWJlclwiKSlcbiAgICAgICAganNvbi50eXBlID0gXCJudW1iZXJcIjtcbiAgICBpZiAodmFsdWVzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikpXG4gICAgICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAganNvbi5lbnVtID0gdmFsdWVzO1xufTtcbmV4cG9ydCBjb25zdCBsaXRlcmFsUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IHZhbHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZhbCBvZiBkZWYudmFsdWVzKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkxpdGVyYWwgYHVuZGVmaW5lZGAgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZG8gbm90IGFkZCB0byB2YWxzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gXCJiaWdpbnRcIikge1xuICAgICAgICAgICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCBsaXRlcmFscyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWxzLnB1c2goTnVtYmVyKHZhbCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHZhbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmcgKGFuIHVuZGVmaW5lZCBsaXRlcmFsIHdhcyBzdHJpcHBlZClcbiAgICB9XG4gICAgZWxzZSBpZiAodmFscy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdmFsc1swXTtcbiAgICAgICAganNvbi50eXBlID0gdmFsID09PSBudWxsID8gXCJudWxsXCIgOiB0eXBlb2YgdmFsO1xuICAgICAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiIHx8IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICAgICAganNvbi5lbnVtID0gW3ZhbF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqc29uLmNvbnN0ID0gdmFsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodmFscy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpKVxuICAgICAgICAgICAganNvbi50eXBlID0gXCJudW1iZXJcIjtcbiAgICAgICAgaWYgKHZhbHMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSlcbiAgICAgICAgICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAgICAgIGlmICh2YWxzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJib29sZWFuXCIpKVxuICAgICAgICAgICAganNvbi50eXBlID0gXCJib29sZWFuXCI7XG4gICAgICAgIGlmICh2YWxzLmV2ZXJ5KCh2KSA9PiB2ID09PSBudWxsKSlcbiAgICAgICAgICAgIGpzb24udHlwZSA9IFwibnVsbFwiO1xuICAgICAgICBqc29uLmVudW0gPSB2YWxzO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbmFuUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5hTiBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0ZW1wbGF0ZUxpdGVyYWxQcm9jZXNzb3IgPSAoc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgX2pzb24gPSBqc29uO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBzY2hlbWEuX3pvZC5wYXR0ZXJuO1xuICAgIGlmICghcGF0dGVybilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiBub3QgZm91bmQgaW4gdGVtcGxhdGUgbGl0ZXJhbFwiKTtcbiAgICBfanNvbi50eXBlID0gXCJzdHJpbmdcIjtcbiAgICBfanNvbi5wYXR0ZXJuID0gcGF0dGVybi5zb3VyY2U7XG59O1xuZXhwb3J0IGNvbnN0IGZpbGVQcm9jZXNzb3IgPSAoc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgX2pzb24gPSBqc29uO1xuICAgIGNvbnN0IGZpbGUgPSB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJiaW5hcnlcIixcbiAgICAgICAgY29udGVudEVuY29kaW5nOiBcImJpbmFyeVwiLFxuICAgIH07XG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtLCBtaW1lIH0gPSBzY2hlbWEuX3pvZC5iYWc7XG4gICAgaWYgKG1pbmltdW0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgZmlsZS5taW5MZW5ndGggPSBtaW5pbXVtO1xuICAgIGlmIChtYXhpbXVtICE9PSB1bmRlZmluZWQpXG4gICAgICAgIGZpbGUubWF4TGVuZ3RoID0gbWF4aW11bTtcbiAgICBpZiAobWltZSkge1xuICAgICAgICBpZiAobWltZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGZpbGUuY29udGVudE1lZGlhVHlwZSA9IG1pbWVbMF07XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKF9qc29uLCBmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oX2pzb24sIGZpbGUpOyAvLyBzaGFyZWQgcHJvcHMgYXQgcm9vdFxuICAgICAgICAgICAgX2pzb24uYW55T2YgPSBtaW1lLm1hcCgobSkgPT4gKHsgY29udGVudE1lZGlhVHlwZTogbSB9KSk7IC8vIG9ubHkgY29udGVudE1lZGlhVHlwZSBkaWZmZXJzXG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIE9iamVjdC5hc3NpZ24oX2pzb24sIGZpbGUpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3Qgc3VjY2Vzc1Byb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBqc29uLCBfcGFyYW1zKSA9PiB7XG4gICAganNvbi50eXBlID0gXCJib29sZWFuXCI7XG59O1xuZXhwb3J0IGNvbnN0IGN1c3RvbVByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDdXN0b20gdHlwZXMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZnVuY3Rpb25Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRnVuY3Rpb24gdHlwZXMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdHJhbnNmb3JtUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zZm9ybXMgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbWFwUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1hcCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBzZXRQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0IGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuLy8gPT09PT09PT09PT09PT09PT09PT0gQ09NUE9TSVRFIFRZUEUgUFJPQ0VTU09SUyA9PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0IGNvbnN0IGFycmF5UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0gfSA9IHNjaGVtYS5fem9kLmJhZztcbiAgICBpZiAodHlwZW9mIG1pbmltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWluSXRlbXMgPSBtaW5pbXVtO1xuICAgIGlmICh0eXBlb2YgbWF4aW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tYXhJdGVtcyA9IG1heGltdW07XG4gICAganNvbi50eXBlID0gXCJhcnJheVwiO1xuICAgIGpzb24uaXRlbXMgPSBwcm9jZXNzKGRlZi5lbGVtZW50LCBjdHgsIHsgLi4ucGFyYW1zLCBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwiaXRlbXNcIl0gfSk7XG59O1xuZXhwb3J0IGNvbnN0IG9iamVjdFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAganNvbi50eXBlID0gXCJvYmplY3RcIjtcbiAgICBqc29uLnByb3BlcnRpZXMgPSB7fTtcbiAgICBjb25zdCBzaGFwZSA9IGRlZi5zaGFwZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzaGFwZSkge1xuICAgICAgICBqc29uLnByb3BlcnRpZXNba2V5XSA9IHByb2Nlc3Moc2hhcGVba2V5XSwgY3R4LCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwicHJvcGVydGllc1wiLCBrZXldLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gcmVxdWlyZWQga2V5c1xuICAgIGNvbnN0IGFsbEtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHNoYXBlKSk7XG4gICAgY29uc3QgcmVxdWlyZWRLZXlzID0gbmV3IFNldChbLi4uYWxsS2V5c10uZmlsdGVyKChrZXkpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IGRlZi5zaGFwZVtrZXldLl96b2Q7XG4gICAgICAgIGlmIChjdHguaW8gPT09IFwiaW5wdXRcIikge1xuICAgICAgICAgICAgcmV0dXJuIHYub3B0aW4gPT09IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2Lm9wdG91dCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSkpO1xuICAgIGlmIChyZXF1aXJlZEtleXMuc2l6ZSA+IDApIHtcbiAgICAgICAganNvbi5yZXF1aXJlZCA9IEFycmF5LmZyb20ocmVxdWlyZWRLZXlzKTtcbiAgICB9XG4gICAgLy8gY2F0Y2hhbGxcbiAgICBpZiAoZGVmLmNhdGNoYWxsPy5fem9kLmRlZi50eXBlID09PSBcIm5ldmVyXCIpIHtcbiAgICAgICAgLy8gc3RyaWN0XG4gICAgICAgIGpzb24uYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWRlZi5jYXRjaGFsbCkge1xuICAgICAgICAvLyByZWd1bGFyXG4gICAgICAgIGlmIChjdHguaW8gPT09IFwib3V0cHV0XCIpXG4gICAgICAgICAgICBqc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRlZi5jYXRjaGFsbCkge1xuICAgICAgICBqc29uLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gcHJvY2VzcyhkZWYuY2F0Y2hhbGwsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdLFxuICAgICAgICB9KTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHVuaW9uUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgLy8gRXhjbHVzaXZlIHVuaW9ucyAoaW5jbHVzaXZlID09PSBmYWxzZSkgdXNlIG9uZU9mIChleGFjdGx5IG9uZSBtYXRjaCkgaW5zdGVhZCBvZiBhbnlPZiAob25lIG9yIG1vcmUgbWF0Y2hlcylcbiAgICAvLyBUaGlzIGluY2x1ZGVzIGJvdGggei54b3IoKSBhbmQgZGlzY3JpbWluYXRlZCB1bmlvbnNcbiAgICBjb25zdCBpc0V4Y2x1c2l2ZSA9IGRlZi5pbmNsdXNpdmUgPT09IGZhbHNlO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBkZWYub3B0aW9ucy5tYXAoKHgsIGkpID0+IHByb2Nlc3MoeCwgY3R4LCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBpc0V4Y2x1c2l2ZSA/IFwib25lT2ZcIiA6IFwiYW55T2ZcIiwgaV0sXG4gICAgfSkpO1xuICAgIGlmIChpc0V4Y2x1c2l2ZSkge1xuICAgICAgICBqc29uLm9uZU9mID0gb3B0aW9ucztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb24uYW55T2YgPSBvcHRpb25zO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgaW50ZXJzZWN0aW9uUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgYSA9IHByb2Nlc3MoZGVmLmxlZnQsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJhbGxPZlwiLCAwXSxcbiAgICB9KTtcbiAgICBjb25zdCBiID0gcHJvY2VzcyhkZWYucmlnaHQsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJhbGxPZlwiLCAxXSxcbiAgICB9KTtcbiAgICBjb25zdCBpc1NpbXBsZUludGVyc2VjdGlvbiA9ICh2YWwpID0+IFwiYWxsT2ZcIiBpbiB2YWwgJiYgT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgYWxsT2YgPSBbXG4gICAgICAgIC4uLihpc1NpbXBsZUludGVyc2VjdGlvbihhKSA/IGEuYWxsT2YgOiBbYV0pLFxuICAgICAgICAuLi4oaXNTaW1wbGVJbnRlcnNlY3Rpb24oYikgPyBiLmFsbE9mIDogW2JdKSxcbiAgICBdO1xuICAgIGpzb24uYWxsT2YgPSBhbGxPZjtcbn07XG5leHBvcnQgY29uc3QgdHVwbGVQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGpzb24udHlwZSA9IFwiYXJyYXlcIjtcbiAgICBjb25zdCBwcmVmaXhQYXRoID0gY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIgPyBcInByZWZpeEl0ZW1zXCIgOiBcIml0ZW1zXCI7XG4gICAgY29uc3QgcmVzdFBhdGggPSBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiaXRlbXNcIiA6IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIiA/IFwiaXRlbXNcIiA6IFwiYWRkaXRpb25hbEl0ZW1zXCI7XG4gICAgY29uc3QgcHJlZml4SXRlbXMgPSBkZWYuaXRlbXMubWFwKCh4LCBpKSA9PiBwcm9jZXNzKHgsIGN0eCwge1xuICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgcHJlZml4UGF0aCwgaV0sXG4gICAgfSkpO1xuICAgIGNvbnN0IHJlc3QgPSBkZWYucmVzdFxuICAgICAgICA/IHByb2Nlc3MoZGVmLnJlc3QsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCByZXN0UGF0aCwgLi4uKGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIiA/IFtkZWYuaXRlbXMubGVuZ3RoXSA6IFtdKV0sXG4gICAgICAgIH0pXG4gICAgICAgIDogbnVsbDtcbiAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIpIHtcbiAgICAgICAganNvbi5wcmVmaXhJdGVtcyA9IHByZWZpeEl0ZW1zO1xuICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAganNvbi5pdGVtcyA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIGpzb24uaXRlbXMgPSB7XG4gICAgICAgICAgICBhbnlPZjogcHJlZml4SXRlbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICBqc29uLml0ZW1zLmFueU9mLnB1c2gocmVzdCk7XG4gICAgICAgIH1cbiAgICAgICAganNvbi5taW5JdGVtcyA9IHByZWZpeEl0ZW1zLmxlbmd0aDtcbiAgICAgICAgaWYgKCFyZXN0KSB7XG4gICAgICAgICAgICBqc29uLm1heEl0ZW1zID0gcHJlZml4SXRlbXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBqc29uLml0ZW1zID0gcHJlZml4SXRlbXM7XG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICBqc29uLmFkZGl0aW9uYWxJdGVtcyA9IHJlc3Q7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gbGVuZ3RoXG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtIH0gPSBzY2hlbWEuX3pvZC5iYWc7XG4gICAgaWYgKHR5cGVvZiBtaW5pbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1pbkl0ZW1zID0gbWluaW11bTtcbiAgICBpZiAodHlwZW9mIG1heGltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWF4SXRlbXMgPSBtYXhpbXVtO1xufTtcbmV4cG9ydCBjb25zdCByZWNvcmRQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGpzb24udHlwZSA9IFwib2JqZWN0XCI7XG4gICAgLy8gRm9yIGxvb3NlUmVjb3JkIHdpdGggcmVnZXggcGF0dGVybnMsIHVzZSBwYXR0ZXJuUHJvcGVydGllc1xuICAgIC8vIFRoaXMgY29ycmVjdGx5IHJlcHJlc2VudHMgXCJvbmx5IHZhbGlkYXRlIGtleXMgbWF0Y2hpbmcgdGhlIHBhdHRlcm5cIiBzZW1hbnRpY3NcbiAgICAvLyBhbmQgY29tcG9zZXMgd2VsbCB3aXRoIGFsbE9mIChpbnRlcnNlY3Rpb25zKVxuICAgIGNvbnN0IGtleVR5cGUgPSBkZWYua2V5VHlwZTtcbiAgICBjb25zdCBrZXlCYWcgPSBrZXlUeXBlLl96b2QuYmFnO1xuICAgIGNvbnN0IHBhdHRlcm5zID0ga2V5QmFnPy5wYXR0ZXJucztcbiAgICBpZiAoZGVmLm1vZGUgPT09IFwibG9vc2VcIiAmJiBwYXR0ZXJucyAmJiBwYXR0ZXJucy5zaXplID4gMCkge1xuICAgICAgICAvLyBVc2UgcGF0dGVyblByb3BlcnRpZXMgZm9yIGxvb3NlUmVjb3JkIHdpdGggcmVnZXggcGF0dGVybnNcbiAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSBwcm9jZXNzKGRlZi52YWx1ZVR5cGUsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsIFwiKlwiXSxcbiAgICAgICAgfSk7XG4gICAgICAgIGpzb24ucGF0dGVyblByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICBqc29uLnBhdHRlcm5Qcm9wZXJ0aWVzW3BhdHRlcm4uc291cmNlXSA9IHZhbHVlU2NoZW1hO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yOiB1c2UgcHJvcGVydHlOYW1lcyArIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA3XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIpIHtcbiAgICAgICAgICAgIGpzb24ucHJvcGVydHlOYW1lcyA9IHByb2Nlc3MoZGVmLmtleVR5cGUsIGN0eCwge1xuICAgICAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwicHJvcGVydHlOYW1lc1wiXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGpzb24uYWRkaXRpb25hbFByb3BlcnRpZXMgPSBwcm9jZXNzKGRlZi52YWx1ZVR5cGUsIGN0eCwge1xuICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCJdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gQWRkIHJlcXVpcmVkIGZvciBrZXlzIHdpdGggZGlzY3JldGUgdmFsdWVzIChlbnVtLCBsaXRlcmFsLCBldGMuKVxuICAgIGNvbnN0IGtleVZhbHVlcyA9IGtleVR5cGUuX3pvZC52YWx1ZXM7XG4gICAgaWYgKGtleVZhbHVlcykge1xuICAgICAgICBjb25zdCB2YWxpZEtleVZhbHVlcyA9IFsuLi5rZXlWYWx1ZXNdLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpO1xuICAgICAgICBpZiAodmFsaWRLZXlWYWx1ZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAganNvbi5yZXF1aXJlZCA9IHZhbGlkS2V5VmFsdWVzO1xuICAgICAgICB9XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBudWxsYWJsZVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGlubmVyID0gcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIGlmIChjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgICAgICBqc29uLm51bGxhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb24uYW55T2YgPSBbaW5uZXIsIHsgdHlwZTogXCJudWxsXCIgfV07XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBub25vcHRpb25hbFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xufTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbiAgICBqc29uLmRlZmF1bHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZi5kZWZhdWx0VmFsdWUpKTtcbn07XG5leHBvcnQgY29uc3QgcHJlZmF1bHRQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgIGlmIChjdHguaW8gPT09IFwiaW5wdXRcIilcbiAgICAgICAganNvbi5fcHJlZmF1bHQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGRlZi5kZWZhdWx0VmFsdWUpKTtcbn07XG5leHBvcnQgY29uc3QgY2F0Y2hQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgIGxldCBjYXRjaFZhbHVlO1xuICAgIHRyeSB7XG4gICAgICAgIGNhdGNoVmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgY2F0Y2ggdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbiAgICBqc29uLmRlZmF1bHQgPSBjYXRjaFZhbHVlO1xufTtcbmV4cG9ydCBjb25zdCBwaXBlUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGlubmVyVHlwZSA9IGN0eC5pbyA9PT0gXCJpbnB1dFwiID8gKGRlZi5pbi5fem9kLmRlZi50eXBlID09PSBcInRyYW5zZm9ybVwiID8gZGVmLm91dCA6IGRlZi5pbikgOiBkZWYub3V0O1xuICAgIHByb2Nlc3MoaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gaW5uZXJUeXBlO1xufTtcbmV4cG9ydCBjb25zdCByZWFkb25seVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG4gICAganNvbi5yZWFkT25seSA9IHRydWU7XG59O1xuZXhwb3J0IGNvbnN0IHByb21pc2VQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbn07XG5leHBvcnQgY29uc3Qgb3B0aW9uYWxQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbn07XG5leHBvcnQgY29uc3QgbGF6eVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGlubmVyVHlwZSA9IHNjaGVtYS5fem9kLmlubmVyVHlwZTtcbiAgICBwcm9jZXNzKGlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGlubmVyVHlwZTtcbn07XG4vLyA9PT09PT09PT09PT09PT09PT09PSBBTEwgUFJPQ0VTU09SUyA9PT09PT09PT09PT09PT09PT09PVxuZXhwb3J0IGNvbnN0IGFsbFByb2Nlc3NvcnMgPSB7XG4gICAgc3RyaW5nOiBzdHJpbmdQcm9jZXNzb3IsXG4gICAgbnVtYmVyOiBudW1iZXJQcm9jZXNzb3IsXG4gICAgYm9vbGVhbjogYm9vbGVhblByb2Nlc3NvcixcbiAgICBiaWdpbnQ6IGJpZ2ludFByb2Nlc3NvcixcbiAgICBzeW1ib2w6IHN5bWJvbFByb2Nlc3NvcixcbiAgICBudWxsOiBudWxsUHJvY2Vzc29yLFxuICAgIHVuZGVmaW5lZDogdW5kZWZpbmVkUHJvY2Vzc29yLFxuICAgIHZvaWQ6IHZvaWRQcm9jZXNzb3IsXG4gICAgbmV2ZXI6IG5ldmVyUHJvY2Vzc29yLFxuICAgIGFueTogYW55UHJvY2Vzc29yLFxuICAgIHVua25vd246IHVua25vd25Qcm9jZXNzb3IsXG4gICAgZGF0ZTogZGF0ZVByb2Nlc3NvcixcbiAgICBlbnVtOiBlbnVtUHJvY2Vzc29yLFxuICAgIGxpdGVyYWw6IGxpdGVyYWxQcm9jZXNzb3IsXG4gICAgbmFuOiBuYW5Qcm9jZXNzb3IsXG4gICAgdGVtcGxhdGVfbGl0ZXJhbDogdGVtcGxhdGVMaXRlcmFsUHJvY2Vzc29yLFxuICAgIGZpbGU6IGZpbGVQcm9jZXNzb3IsXG4gICAgc3VjY2Vzczogc3VjY2Vzc1Byb2Nlc3NvcixcbiAgICBjdXN0b206IGN1c3RvbVByb2Nlc3NvcixcbiAgICBmdW5jdGlvbjogZnVuY3Rpb25Qcm9jZXNzb3IsXG4gICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1Qcm9jZXNzb3IsXG4gICAgbWFwOiBtYXBQcm9jZXNzb3IsXG4gICAgc2V0OiBzZXRQcm9jZXNzb3IsXG4gICAgYXJyYXk6IGFycmF5UHJvY2Vzc29yLFxuICAgIG9iamVjdDogb2JqZWN0UHJvY2Vzc29yLFxuICAgIHVuaW9uOiB1bmlvblByb2Nlc3NvcixcbiAgICBpbnRlcnNlY3Rpb246IGludGVyc2VjdGlvblByb2Nlc3NvcixcbiAgICB0dXBsZTogdHVwbGVQcm9jZXNzb3IsXG4gICAgcmVjb3JkOiByZWNvcmRQcm9jZXNzb3IsXG4gICAgbnVsbGFibGU6IG51bGxhYmxlUHJvY2Vzc29yLFxuICAgIG5vbm9wdGlvbmFsOiBub25vcHRpb25hbFByb2Nlc3NvcixcbiAgICBkZWZhdWx0OiBkZWZhdWx0UHJvY2Vzc29yLFxuICAgIHByZWZhdWx0OiBwcmVmYXVsdFByb2Nlc3NvcixcbiAgICBjYXRjaDogY2F0Y2hQcm9jZXNzb3IsXG4gICAgcGlwZTogcGlwZVByb2Nlc3NvcixcbiAgICByZWFkb25seTogcmVhZG9ubHlQcm9jZXNzb3IsXG4gICAgcHJvbWlzZTogcHJvbWlzZVByb2Nlc3NvcixcbiAgICBvcHRpb25hbDogb3B0aW9uYWxQcm9jZXNzb3IsXG4gICAgbGF6eTogbGF6eVByb2Nlc3Nvcixcbn07XG5leHBvcnQgZnVuY3Rpb24gdG9KU09OU2NoZW1hKGlucHV0LCBwYXJhbXMpIHtcbiAgICBpZiAoXCJfaWRtYXBcIiBpbiBpbnB1dCkge1xuICAgICAgICAvLyBSZWdpc3RyeSBjYXNlXG4gICAgICAgIGNvbnN0IHJlZ2lzdHJ5ID0gaW5wdXQ7XG4gICAgICAgIGNvbnN0IGN0eCA9IGluaXRpYWxpemVDb250ZXh0KHsgLi4ucGFyYW1zLCBwcm9jZXNzb3JzOiBhbGxQcm9jZXNzb3JzIH0pO1xuICAgICAgICBjb25zdCBkZWZzID0ge307XG4gICAgICAgIC8vIEZpcnN0IHBhc3M6IHByb2Nlc3MgYWxsIHNjaGVtYXMgdG8gYnVpbGQgdGhlIHNlZW4gbWFwXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVnaXN0cnkuX2lkbWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgW18sIHNjaGVtYV0gPSBlbnRyeTtcbiAgICAgICAgICAgIHByb2Nlc3Moc2NoZW1hLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjaGVtYXMgPSB7fTtcbiAgICAgICAgY29uc3QgZXh0ZXJuYWwgPSB7XG4gICAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICAgIHVyaTogcGFyYW1zPy51cmksXG4gICAgICAgICAgICBkZWZzLFxuICAgICAgICB9O1xuICAgICAgICAvLyBVcGRhdGUgdGhlIGNvbnRleHQgd2l0aCBleHRlcm5hbCBjb25maWd1cmF0aW9uXG4gICAgICAgIGN0eC5leHRlcm5hbCA9IGV4dGVybmFsO1xuICAgICAgICAvLyBTZWNvbmQgcGFzczogZW1pdCBlYWNoIHNjaGVtYVxuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIHJlZ2lzdHJ5Ll9pZG1hcC5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGNvbnN0IFtrZXksIHNjaGVtYV0gPSBlbnRyeTtcbiAgICAgICAgICAgIGV4dHJhY3REZWZzKGN0eCwgc2NoZW1hKTtcbiAgICAgICAgICAgIHNjaGVtYXNba2V5XSA9IGZpbmFsaXplKGN0eCwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoT2JqZWN0LmtleXMoZGVmcykubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgZGVmc1NlZ21lbnQgPSBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiJGRlZnNcIiA6IFwiZGVmaW5pdGlvbnNcIjtcbiAgICAgICAgICAgIHNjaGVtYXMuX19zaGFyZWQgPSB7XG4gICAgICAgICAgICAgICAgW2RlZnNTZWdtZW50XTogZGVmcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc2NoZW1hcyB9O1xuICAgIH1cbiAgICAvLyBTaW5nbGUgc2NoZW1hIGNhc2VcbiAgICBjb25zdCBjdHggPSBpbml0aWFsaXplQ29udGV4dCh7IC4uLnBhcmFtcywgcHJvY2Vzc29yczogYWxsUHJvY2Vzc29ycyB9KTtcbiAgICBwcm9jZXNzKGlucHV0LCBjdHgpO1xuICAgIGV4dHJhY3REZWZzKGN0eCwgaW5wdXQpO1xuICAgIHJldHVybiBmaW5hbGl6ZShjdHgsIGlucHV0KTtcbn1cbiIsIG51bGwsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyB1dGlsIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCAqIGFzIHByb2Nlc3NvcnMgZnJvbSBcIi4uL2NvcmUvanNvbi1zY2hlbWEtcHJvY2Vzc29ycy5qc1wiO1xuaW1wb3J0IHsgY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kLCBjcmVhdGVUb0pTT05TY2hlbWFNZXRob2QgfSBmcm9tIFwiLi4vY29yZS90by1qc29uLXNjaGVtYS5qc1wiO1xuaW1wb3J0ICogYXMgY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgaXNvIGZyb20gXCIuL2lzby5qc1wiO1xuaW1wb3J0ICogYXMgcGFyc2UgZnJvbSBcIi4vcGFyc2UuanNcIjtcbmV4cG9ydCBjb25zdCBab2RUeXBlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIE9iamVjdC5hc3NpZ24oaW5zdFtcIn5zdGFuZGFyZFwiXSwge1xuICAgICAgICBqc29uU2NoZW1hOiB7XG4gICAgICAgICAgICBpbnB1dDogY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kKGluc3QsIFwiaW5wdXRcIiksXG4gICAgICAgICAgICBvdXRwdXQ6IGNyZWF0ZVN0YW5kYXJkSlNPTlNjaGVtYU1ldGhvZChpbnN0LCBcIm91dHB1dFwiKSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBpbnN0LnRvSlNPTlNjaGVtYSA9IGNyZWF0ZVRvSlNPTlNjaGVtYU1ldGhvZChpbnN0LCB7fSk7XG4gICAgaW5zdC5kZWYgPSBkZWY7XG4gICAgaW5zdC50eXBlID0gZGVmLnR5cGU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX2RlZlwiLCB7IHZhbHVlOiBkZWYgfSk7XG4gICAgLy8gYmFzZSBtZXRob2RzXG4gICAgaW5zdC5jaGVjayA9ICguLi5jaGVja3MpID0+IHtcbiAgICAgICAgcmV0dXJuIGluc3QuY2xvbmUodXRpbC5tZXJnZURlZnMoZGVmLCB7XG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi4oZGVmLmNoZWNrcyA/PyBbXSksXG4gICAgICAgICAgICAgICAgLi4uY2hlY2tzLm1hcCgoY2gpID0+IHR5cGVvZiBjaCA9PT0gXCJmdW5jdGlvblwiID8geyBfem9kOiB7IGNoZWNrOiBjaCwgZGVmOiB7IGNoZWNrOiBcImN1c3RvbVwiIH0sIG9uYXR0YWNoOiBbXSB9IH0gOiBjaCksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KSwge1xuICAgICAgICAgICAgcGFyZW50OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGluc3Qud2l0aCA9IGluc3QuY2hlY2s7XG4gICAgaW5zdC5jbG9uZSA9IChkZWYsIHBhcmFtcykgPT4gY29yZS5jbG9uZShpbnN0LCBkZWYsIHBhcmFtcyk7XG4gICAgaW5zdC5icmFuZCA9ICgpID0+IGluc3Q7XG4gICAgaW5zdC5yZWdpc3RlciA9ICgocmVnLCBtZXRhKSA9PiB7XG4gICAgICAgIHJlZy5hZGQoaW5zdCwgbWV0YSk7XG4gICAgICAgIHJldHVybiBpbnN0O1xuICAgIH0pO1xuICAgIC8vIHBhcnNpbmdcbiAgICBpbnN0LnBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UucGFyc2UoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZSB9KTtcbiAgICBpbnN0LnNhZmVQYXJzZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVQYXJzZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3QucGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZUFzeW5jIH0pO1xuICAgIGluc3Quc2FmZVBhcnNlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlUGFyc2VBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc3BhID0gaW5zdC5zYWZlUGFyc2VBc3luYztcbiAgICAvLyBlbmNvZGluZy9kZWNvZGluZ1xuICAgIGluc3QuZW5jb2RlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZW5jb2RlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5kZWNvZGUgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5kZWNvZGUoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LmVuY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZW5jb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LmRlY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UuZGVjb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnNhZmVFbmNvZGUgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlRW5jb2RlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zYWZlRGVjb2RlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZURlY29kZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc2FmZUVuY29kZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZUVuY29kZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zYWZlRGVjb2RlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlRGVjb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICAvLyByZWZpbmVtZW50c1xuICAgIGluc3QucmVmaW5lID0gKGNoZWNrLCBwYXJhbXMpID0+IGluc3QuY2hlY2socmVmaW5lKGNoZWNrLCBwYXJhbXMpKTtcbiAgICBpbnN0LnN1cGVyUmVmaW5lID0gKHJlZmluZW1lbnQpID0+IGluc3QuY2hlY2soc3VwZXJSZWZpbmUocmVmaW5lbWVudCkpO1xuICAgIGluc3Qub3ZlcndyaXRlID0gKGZuKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5vdmVyd3JpdGUoZm4pKTtcbiAgICAvLyB3cmFwcGVyc1xuICAgIGluc3Qub3B0aW9uYWwgPSAoKSA9PiBvcHRpb25hbChpbnN0KTtcbiAgICBpbnN0LmV4YWN0T3B0aW9uYWwgPSAoKSA9PiBleGFjdE9wdGlvbmFsKGluc3QpO1xuICAgIGluc3QubnVsbGFibGUgPSAoKSA9PiBudWxsYWJsZShpbnN0KTtcbiAgICBpbnN0Lm51bGxpc2ggPSAoKSA9PiBvcHRpb25hbChudWxsYWJsZShpbnN0KSk7XG4gICAgaW5zdC5ub25vcHRpb25hbCA9IChwYXJhbXMpID0+IG5vbm9wdGlvbmFsKGluc3QsIHBhcmFtcyk7XG4gICAgaW5zdC5hcnJheSA9ICgpID0+IGFycmF5KGluc3QpO1xuICAgIGluc3Qub3IgPSAoYXJnKSA9PiB1bmlvbihbaW5zdCwgYXJnXSk7XG4gICAgaW5zdC5hbmQgPSAoYXJnKSA9PiBpbnRlcnNlY3Rpb24oaW5zdCwgYXJnKTtcbiAgICBpbnN0LnRyYW5zZm9ybSA9ICh0eCkgPT4gcGlwZShpbnN0LCB0cmFuc2Zvcm0odHgpKTtcbiAgICBpbnN0LmRlZmF1bHQgPSAoZGVmKSA9PiBfZGVmYXVsdChpbnN0LCBkZWYpO1xuICAgIGluc3QucHJlZmF1bHQgPSAoZGVmKSA9PiBwcmVmYXVsdChpbnN0LCBkZWYpO1xuICAgIC8vIGluc3QuY29hbGVzY2UgPSAoZGVmLCBwYXJhbXMpID0+IGNvYWxlc2NlKGluc3QsIGRlZiwgcGFyYW1zKTtcbiAgICBpbnN0LmNhdGNoID0gKHBhcmFtcykgPT4gX2NhdGNoKGluc3QsIHBhcmFtcyk7XG4gICAgaW5zdC5waXBlID0gKHRhcmdldCkgPT4gcGlwZShpbnN0LCB0YXJnZXQpO1xuICAgIGluc3QucmVhZG9ubHkgPSAoKSA9PiByZWFkb25seShpbnN0KTtcbiAgICAvLyBtZXRhXG4gICAgaW5zdC5kZXNjcmliZSA9IChkZXNjcmlwdGlvbikgPT4ge1xuICAgICAgICBjb25zdCBjbCA9IGluc3QuY2xvbmUoKTtcbiAgICAgICAgY29yZS5nbG9iYWxSZWdpc3RyeS5hZGQoY2wsIHsgZGVzY3JpcHRpb24gfSk7XG4gICAgICAgIHJldHVybiBjbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcImRlc2NyaXB0aW9uXCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpPy5kZXNjcmlwdGlvbjtcbiAgICAgICAgfSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIGluc3QubWV0YSA9ICguLi5hcmdzKSA9PiB7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvcmUuZ2xvYmFsUmVnaXN0cnkuZ2V0KGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgICAgICBjb3JlLmdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgYXJnc1swXSk7XG4gICAgICAgIHJldHVybiBjbDtcbiAgICB9O1xuICAgIC8vIGhlbHBlcnNcbiAgICBpbnN0LmlzT3B0aW9uYWwgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgaW5zdC5pc051bGxhYmxlID0gKCkgPT4gaW5zdC5zYWZlUGFyc2UobnVsbCkuc3VjY2VzcztcbiAgICBpbnN0LmFwcGx5ID0gKGZuKSA9PiBmbihpbnN0KTtcbiAgICByZXR1cm4gaW5zdDtcbn0pO1xuLyoqIEBpbnRlcm5hbCAqL1xuZXhwb3J0IGNvbnN0IF9ab2RTdHJpbmcgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiX1pvZFN0cmluZ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuc3RyaW5nUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgIGluc3QuZm9ybWF0ID0gYmFnLmZvcm1hdCA/PyBudWxsO1xuICAgIGluc3QubWluTGVuZ3RoID0gYmFnLm1pbmltdW0gPz8gbnVsbDtcbiAgICBpbnN0Lm1heExlbmd0aCA9IGJhZy5tYXhpbXVtID8/IG51bGw7XG4gICAgLy8gdmFsaWRhdGlvbnNcbiAgICBpbnN0LnJlZ2V4ID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLnJlZ2V4KC4uLmFyZ3MpKTtcbiAgICBpbnN0LmluY2x1ZGVzID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLmluY2x1ZGVzKC4uLmFyZ3MpKTtcbiAgICBpbnN0LnN0YXJ0c1dpdGggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3Muc3RhcnRzV2l0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5lbmRzV2l0aCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5lbmRzV2l0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5taW4gPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MubWluTGVuZ3RoKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lm1heCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tYXhMZW5ndGgoLi4uYXJncykpO1xuICAgIGluc3QubGVuZ3RoID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLmxlbmd0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5taW5MZW5ndGgoMSwgLi4uYXJncykpO1xuICAgIGluc3QubG93ZXJjYXNlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubG93ZXJjYXNlKHBhcmFtcykpO1xuICAgIGluc3QudXBwZXJjYXNlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MudXBwZXJjYXNlKHBhcmFtcykpO1xuICAgIC8vIHRyYW5zZm9ybXNcbiAgICBpbnN0LnRyaW0gPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy50cmltKCkpO1xuICAgIGluc3Qubm9ybWFsaXplID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLm5vcm1hbGl6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC50b0xvd2VyQ2FzZSA9ICgpID0+IGluc3QuY2hlY2soY2hlY2tzLnRvTG93ZXJDYXNlKCkpO1xuICAgIGluc3QudG9VcHBlckNhc2UgPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy50b1VwcGVyQ2FzZSgpKTtcbiAgICBpbnN0LnNsdWdpZnkgPSAoKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5zbHVnaWZ5KCkpO1xufSk7XG5leHBvcnQgY29uc3QgWm9kU3RyaW5nID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFN0cmluZ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbiAgICBfWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0LmVtYWlsID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9lbWFpbChab2RFbWFpbCwgcGFyYW1zKSk7XG4gICAgaW5zdC51cmwgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3VybChab2RVUkwsIHBhcmFtcykpO1xuICAgIGluc3Quand0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9qd3QoWm9kSldULCBwYXJhbXMpKTtcbiAgICBpbnN0LmVtb2ppID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9lbW9qaShab2RFbW9qaSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9ndWlkKFpvZEdVSUQsIHBhcmFtcykpO1xuICAgIGluc3QudXVpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXVpZChab2RVVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LnV1aWR2NCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXVpZHY0KFpvZFVVSUQsIHBhcmFtcykpO1xuICAgIGluc3QudXVpZHY2ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91dWlkdjYoWm9kVVVJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC51dWlkdjcgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3V1aWR2Nyhab2RVVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5hbm9pZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbmFub2lkKFpvZE5hbm9JRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9ndWlkKFpvZEdVSUQsIHBhcmFtcykpO1xuICAgIGluc3QuY3VpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fY3VpZChab2RDVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LmN1aWQyID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9jdWlkMihab2RDVUlEMiwgcGFyYW1zKSk7XG4gICAgaW5zdC51bGlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91bGlkKFpvZFVMSUQsIHBhcmFtcykpO1xuICAgIGluc3QuYmFzZTY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9iYXNlNjQoWm9kQmFzZTY0LCBwYXJhbXMpKTtcbiAgICBpbnN0LmJhc2U2NHVybCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fYmFzZTY0dXJsKFpvZEJhc2U2NFVSTCwgcGFyYW1zKSk7XG4gICAgaW5zdC54aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3hpZChab2RYSUQsIHBhcmFtcykpO1xuICAgIGluc3Qua3N1aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2tzdWlkKFpvZEtTVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LmlwdjQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2lwdjQoWm9kSVB2NCwgcGFyYW1zKSk7XG4gICAgaW5zdC5pcHY2ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9pcHY2KFpvZElQdjYsIHBhcmFtcykpO1xuICAgIGluc3QuY2lkcnY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9jaWRydjQoWm9kQ0lEUnY0LCBwYXJhbXMpKTtcbiAgICBpbnN0LmNpZHJ2NiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fY2lkcnY2KFpvZENJRFJ2NiwgcGFyYW1zKSk7XG4gICAgaW5zdC5lMTY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9lMTY0KFpvZEUxNjQsIHBhcmFtcykpO1xuICAgIC8vIGlzb1xuICAgIGluc3QuZGF0ZXRpbWUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGlzby5kYXRldGltZShwYXJhbXMpKTtcbiAgICBpbnN0LmRhdGUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGlzby5kYXRlKHBhcmFtcykpO1xuICAgIGluc3QudGltZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaXNvLnRpbWUocGFyYW1zKSk7XG4gICAgaW5zdC5kdXJhdGlvbiA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaXNvLmR1cmF0aW9uKHBhcmFtcykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmcoWm9kU3RyaW5nLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFN0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgX1pvZFN0cmluZy5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCBab2RFbWFpbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RFbWFpbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RFbWFpbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGVtYWlsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9lbWFpbChab2RFbWFpbCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RHVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEdVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kR1VJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGd1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2d1aWQoWm9kR1VJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RVVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kVVVJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3V1aWQoWm9kVVVJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1dWlkdjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3V1aWR2NChab2RVVUlELCBwYXJhbXMpO1xufVxuLy8gWm9kVVVJRHY2XG5leHBvcnQgZnVuY3Rpb24gdXVpZHY2KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91dWlkdjYoWm9kVVVJRCwgcGFyYW1zKTtcbn1cbi8vIFpvZFVVSUR2N1xuZXhwb3J0IGZ1bmN0aW9uIHV1aWR2NyhwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXVpZHY3KFpvZFVVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVVJMID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVSTFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RVUkwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1cmwocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VybChab2RVUkwsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaHR0cFVybChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXJsKFpvZFVSTCwge1xuICAgICAgICBwcm90b2NvbDogL15odHRwcz8kLyxcbiAgICAgICAgaG9zdG5hbWU6IGNvcmUucmVnZXhlcy5kb21haW4sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRW1vamkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRW1vamlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kRW1vamkuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBlbW9qaShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZW1vamkoWm9kRW1vamksIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTmFub0lEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE5hbm9JRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2ROYW5vSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBuYW5vaWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX25hbm9pZChab2ROYW5vSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZENVSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjdWlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jdWlkKFpvZENVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ1VJRDIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ1VJRDJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQ1VJRDIuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjdWlkMihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY3VpZDIoWm9kQ1VJRDIsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVUxJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVTElEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZFVMSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1bGlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91bGlkKFpvZFVMSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kWElEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFhJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RYSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB4aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3hpZChab2RYSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kS1NVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kS1NVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kS1NVSUQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBrc3VpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fa3N1aWQoWm9kS1NVSUQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVB2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJUHY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZElQdjQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpcHY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pcHY0KFpvZElQdjQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTUFDID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE1BQ1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RNQUMuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBtYWMocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX21hYyhab2RNQUMsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kSVB2NiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJUHY2XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZElQdjYuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpcHY2KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pcHY2KFpvZElQdjYsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ0lEUnY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENJRFJ2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQ0lEUnY0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gY2lkcnY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jaWRydjQoWm9kQ0lEUnY0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZENJRFJ2NiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDSURSdjZcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZENJRFJ2Ni5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGNpZHJ2NihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fY2lkcnY2KFpvZENJRFJ2NiwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCYXNlNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQmFzZTY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEJhc2U2NC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYmFzZTY0KFpvZEJhc2U2NCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCYXNlNjRVUkwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQmFzZTY0VVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEJhc2U2NFVSTC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGJhc2U2NHVybChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYmFzZTY0dXJsKFpvZEJhc2U2NFVSTCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RFMTY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEUxNjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kRTE2NC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGUxNjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2UxNjQoWm9kRTE2NCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RKV1QgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSldUXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEpXVC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGp3dChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fand0KFpvZEpXVCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RDdXN0b21TdHJpbmdGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ3VzdG9tU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEN1c3RvbVN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ0Zvcm1hdChmb3JtYXQsIGZuT3JSZWdleCwgX3BhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIGZvcm1hdCwgZm5PclJlZ2V4LCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBob3N0bmFtZShfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIFwiaG9zdG5hbWVcIiwgY29yZS5yZWdleGVzLmhvc3RuYW1lLCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXgoX3BhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9zdHJpbmdGb3JtYXQoWm9kQ3VzdG9tU3RyaW5nRm9ybWF0LCBcImhleFwiLCBjb3JlLnJlZ2V4ZXMuaGV4LCBfcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNoKGFsZywgcGFyYW1zKSB7XG4gICAgY29uc3QgZW5jID0gcGFyYW1zPy5lbmMgPz8gXCJoZXhcIjtcbiAgICBjb25zdCBmb3JtYXQgPSBgJHthbGd9XyR7ZW5jfWA7XG4gICAgY29uc3QgcmVnZXggPSBjb3JlLnJlZ2V4ZXNbZm9ybWF0XTtcbiAgICBpZiAoIXJlZ2V4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBoYXNoIGZvcm1hdDogJHtmb3JtYXR9YCk7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIGZvcm1hdCwgcmVnZXgsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kTnVtYmVyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE51bWJlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTnVtYmVyLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubnVtYmVyUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lmd0ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0KHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmd0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWluID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5sdCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdCh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5sdGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QuaW50ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpbnQocGFyYW1zKSk7XG4gICAgaW5zdC5zYWZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpbnQocGFyYW1zKSk7XG4gICAgaW5zdC5wb3NpdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0KDAsIHBhcmFtcykpO1xuICAgIGluc3Qubm9ubmVnYXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUoMCwgcGFyYW1zKSk7XG4gICAgaW5zdC5uZWdhdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0KDAsIHBhcmFtcykpO1xuICAgIGluc3Qubm9ucG9zaXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUoMCwgcGFyYW1zKSk7XG4gICAgaW5zdC5tdWx0aXBsZU9mID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm11bHRpcGxlT2YodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3Quc3RlcCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tdWx0aXBsZU9mKHZhbHVlLCBwYXJhbXMpKTtcbiAgICAvLyBpbnN0LmZpbml0ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5maW5pdGUocGFyYW1zKSk7XG4gICAgaW5zdC5maW5pdGUgPSAoKSA9PiBpbnN0O1xuICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgaW5zdC5taW5WYWx1ZSA9XG4gICAgICAgIE1hdGgubWF4KGJhZy5taW5pbXVtID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSwgYmFnLmV4Y2x1c2l2ZU1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZKSA/PyBudWxsO1xuICAgIGluc3QubWF4VmFsdWUgPVxuICAgICAgICBNYXRoLm1pbihiYWcubWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksIGJhZy5leGNsdXNpdmVNYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSkgPz8gbnVsbDtcbiAgICBpbnN0LmlzSW50ID0gKGJhZy5mb3JtYXQgPz8gXCJcIikuaW5jbHVkZXMoXCJpbnRcIikgfHwgTnVtYmVyLmlzU2FmZUludGVnZXIoYmFnLm11bHRpcGxlT2YgPz8gMC41KTtcbiAgICBpbnN0LmlzRmluaXRlID0gdHJ1ZTtcbiAgICBpbnN0LmZvcm1hdCA9IGJhZy5mb3JtYXQgPz8gbnVsbDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlcihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbnVtYmVyKFpvZE51bWJlciwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2ROdW1iZXJGb3JtYXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTnVtYmVyRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROdW1iZXJGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZE51bWJlci5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpbnQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ludChab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQzMihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZmxvYXQzMihab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmxvYXQ2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZmxvYXQ2NChab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gaW50MzIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ludDMyKFpvZE51bWJlckZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50MzIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VpbnQzMihab2ROdW1iZXJGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQm9vbGVhbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCb29sZWFuXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RCb29sZWFuLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYm9vbGVhblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBib29sZWFuKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9ib29sZWFuKFpvZEJvb2xlYW4sIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQmlnSW50ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEJpZ0ludFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQmlnSW50LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYmlnaW50UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lmd0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWluID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndCh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ndGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1pbiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubHQgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHQodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubHRlID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0LnBvc2l0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3QoQmlnSW50KDApLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5lZ2F0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHQoQmlnSW50KDApLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbnBvc2l0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKEJpZ0ludCgwKSwgcGFyYW1zKSk7XG4gICAgaW5zdC5ub25uZWdhdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZShCaWdJbnQoMCksIHBhcmFtcykpO1xuICAgIGluc3QubXVsdGlwbGVPZiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tdWx0aXBsZU9mKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgIGluc3QubWluVmFsdWUgPSBiYWcubWluaW11bSA/PyBudWxsO1xuICAgIGluc3QubWF4VmFsdWUgPSBiYWcubWF4aW11bSA/PyBudWxsO1xuICAgIGluc3QuZm9ybWF0ID0gYmFnLmZvcm1hdCA/PyBudWxsO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYmlnaW50KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9iaWdpbnQoWm9kQmlnSW50LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEJpZ0ludEZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCaWdJbnRGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEJpZ0ludEZvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kQmlnSW50LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuLy8gaW50NjRcbmV4cG9ydCBmdW5jdGlvbiBpbnQ2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faW50NjQoWm9kQmlnSW50Rm9ybWF0LCBwYXJhbXMpO1xufVxuLy8gdWludDY0XG5leHBvcnQgZnVuY3Rpb24gdWludDY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91aW50NjQoWm9kQmlnSW50Rm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFN5bWJvbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTeW1ib2xcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN5bWJvbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnN5bWJvbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBzeW1ib2wocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N5bWJvbChab2RTeW1ib2wsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kVW5kZWZpbmVkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVuZGVmaW5lZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVW5kZWZpbmVkLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudW5kZWZpbmVkUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZnVuY3Rpb24gX3VuZGVmaW5lZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdW5kZWZpbmVkKFpvZFVuZGVmaW5lZCwgcGFyYW1zKTtcbn1cbmV4cG9ydCB7IF91bmRlZmluZWQgYXMgdW5kZWZpbmVkIH07XG5leHBvcnQgY29uc3QgWm9kTnVsbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROdWxsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROdWxsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubnVsbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmZ1bmN0aW9uIF9udWxsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9udWxsKFpvZE51bGwsIHBhcmFtcyk7XG59XG5leHBvcnQgeyBfbnVsbCBhcyBudWxsIH07XG5leHBvcnQgY29uc3QgWm9kQW55ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEFueVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQW55LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYW55UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGFueSgpIHtcbiAgICByZXR1cm4gY29yZS5fYW55KFpvZEFueSk7XG59XG5leHBvcnQgY29uc3QgWm9kVW5rbm93biA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RVbmtub3duLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudW5rbm93blByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1bmtub3duKCkge1xuICAgIHJldHVybiBjb3JlLl91bmtub3duKFpvZFVua25vd24pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE5ldmVyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE5ldmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROZXZlci5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm5ldmVyUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG5ldmVyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9uZXZlcihab2ROZXZlciwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RWb2lkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFZvaWRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFZvaWQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy52b2lkUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZnVuY3Rpb24gX3ZvaWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3ZvaWQoWm9kVm9pZCwgcGFyYW1zKTtcbn1cbmV4cG9ydCB7IF92b2lkIGFzIHZvaWQgfTtcbmV4cG9ydCBjb25zdCBab2REYXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZERhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZERhdGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5kYXRlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm1pbiA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgY29uc3QgYyA9IGluc3QuX3pvZC5iYWc7XG4gICAgaW5zdC5taW5EYXRlID0gYy5taW5pbXVtID8gbmV3IERhdGUoYy5taW5pbXVtKSA6IG51bGw7XG4gICAgaW5zdC5tYXhEYXRlID0gYy5tYXhpbXVtID8gbmV3IERhdGUoYy5tYXhpbXVtKSA6IG51bGw7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkYXRlKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9kYXRlKFpvZERhdGUsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQXJyYXkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEFycmF5LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuYXJyYXlQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuZWxlbWVudCA9IGRlZi5lbGVtZW50O1xuICAgIGluc3QubWluID0gKG1pbkxlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5taW5MZW5ndGgobWluTGVuZ3RoLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbmVtcHR5ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubWluTGVuZ3RoKDEsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKG1heExlbmd0aCwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5tYXhMZW5ndGgobWF4TGVuZ3RoLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmxlbmd0aCA9IChsZW4sIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubGVuZ3RoKGxlbiwgcGFyYW1zKSk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0LmVsZW1lbnQ7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBhcnJheShlbGVtZW50LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fYXJyYXkoWm9kQXJyYXksIGVsZW1lbnQsIHBhcmFtcyk7XG59XG4vLyAua2V5b2ZcbmV4cG9ydCBmdW5jdGlvbiBrZXlvZihzY2hlbWEpIHtcbiAgICBjb25zdCBzaGFwZSA9IHNjaGVtYS5fem9kLmRlZi5zaGFwZTtcbiAgICByZXR1cm4gX2VudW0oT2JqZWN0LmtleXMoc2hhcGUpKTtcbn1cbmV4cG9ydCBjb25zdCBab2RPYmplY3QgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kT2JqZWN0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RPYmplY3RKSVQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5vYmplY3RQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0LCBcInNoYXBlXCIsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlZi5zaGFwZTtcbiAgICB9KTtcbiAgICBpbnN0LmtleW9mID0gKCkgPT4gX2VudW0oT2JqZWN0LmtleXMoaW5zdC5fem9kLmRlZi5zaGFwZSkpO1xuICAgIGluc3QuY2F0Y2hhbGwgPSAoY2F0Y2hhbGwpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogY2F0Y2hhbGwgfSk7XG4gICAgaW5zdC5wYXNzdGhyb3VnaCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5rbm93bigpIH0pO1xuICAgIGluc3QubG9vc2UgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVua25vd24oKSB9KTtcbiAgICBpbnN0LnN0cmljdCA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogbmV2ZXIoKSB9KTtcbiAgICBpbnN0LnN0cmlwID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB1bmRlZmluZWQgfSk7XG4gICAgaW5zdC5leHRlbmQgPSAoaW5jb21pbmcpID0+IHtcbiAgICAgICAgcmV0dXJuIHV0aWwuZXh0ZW5kKGluc3QsIGluY29taW5nKTtcbiAgICB9O1xuICAgIGluc3Quc2FmZUV4dGVuZCA9IChpbmNvbWluZykgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5zYWZlRXh0ZW5kKGluc3QsIGluY29taW5nKTtcbiAgICB9O1xuICAgIGluc3QubWVyZ2UgPSAob3RoZXIpID0+IHV0aWwubWVyZ2UoaW5zdCwgb3RoZXIpO1xuICAgIGluc3QucGljayA9IChtYXNrKSA9PiB1dGlsLnBpY2soaW5zdCwgbWFzayk7XG4gICAgaW5zdC5vbWl0ID0gKG1hc2spID0+IHV0aWwub21pdChpbnN0LCBtYXNrKTtcbiAgICBpbnN0LnBhcnRpYWwgPSAoLi4uYXJncykgPT4gdXRpbC5wYXJ0aWFsKFpvZE9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcbiAgICBpbnN0LnJlcXVpcmVkID0gKC4uLmFyZ3MpID0+IHV0aWwucmVxdWlyZWQoWm9kTm9uT3B0aW9uYWwsIGluc3QsIGFyZ3NbMF0pO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0KHNoYXBlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBkZWYgPSB7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHNoYXBlOiBzaGFwZSA/PyB7fSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9O1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KGRlZik7XG59XG4vLyBzdHJpY3RPYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBzdHJpY3RPYmplY3Qoc2hhcGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgc2hhcGUsXG4gICAgICAgIGNhdGNoYWxsOiBuZXZlcigpLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gbG9vc2VPYmplY3RcbmV4cG9ydCBmdW5jdGlvbiBsb29zZU9iamVjdChzaGFwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgY2F0Y2hhbGw6IHVua25vd24oKSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RVbmlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy51bmlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5vcHRpb25zID0gZGVmLm9wdGlvbnM7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB1bmlvbihvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zOiBvcHRpb25zLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFhvciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RYb3JcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RYb3IuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy51bmlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5vcHRpb25zID0gZGVmLm9wdGlvbnM7XG59KTtcbi8qKiBDcmVhdGVzIGFuIGV4Y2x1c2l2ZSB1bmlvbiAoWE9SKSB3aGVyZSBleGFjdGx5IG9uZSBvcHRpb24gbXVzdCBtYXRjaC5cbiAqIFVubGlrZSByZWd1bGFyIHVuaW9ucyB0aGF0IHN1Y2NlZWQgd2hlbiBhbnkgb3B0aW9uIG1hdGNoZXMsIHhvciBmYWlscyBpZlxuICogemVybyBvciBtb3JlIHRoYW4gb25lIG9wdGlvbiBtYXRjaGVzIHRoZSBpbnB1dC4gKi9cbmV4cG9ydCBmdW5jdGlvbiB4b3Iob3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RYb3Ioe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRGlzY3JpbWluYXRlZFVuaW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZERpc2NyaW1pbmF0ZWRVbmlvbi5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBkaXNjcmltaW5hdGVkVW5pb24oZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgLy8gY29uc3QgW29wdGlvbnMsIHBhcmFtc10gPSBhcmdzO1xuICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgdHlwZTogXCJ1bmlvblwiLFxuICAgICAgICBvcHRpb25zLFxuICAgICAgICBkaXNjcmltaW5hdG9yLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEludGVyc2VjdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEludGVyc2VjdGlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmludGVyc2VjdGlvblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBpbnRlcnNlY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IFpvZEludGVyc2VjdGlvbih7XG4gICAgICAgIHR5cGU6IFwiaW50ZXJzZWN0aW9uXCIsXG4gICAgICAgIGxlZnQ6IGxlZnQsXG4gICAgICAgIHJpZ2h0OiByaWdodCxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RUdXBsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RUdXBsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVHVwbGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy50dXBsZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5yZXN0ID0gKHJlc3QpID0+IGluc3QuY2xvbmUoe1xuICAgICAgICAuLi5pbnN0Ll96b2QuZGVmLFxuICAgICAgICByZXN0OiByZXN0LFxuICAgIH0pO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdHVwbGUoaXRlbXMsIF9wYXJhbXNPclJlc3QsIF9wYXJhbXMpIHtcbiAgICBjb25zdCBoYXNSZXN0ID0gX3BhcmFtc09yUmVzdCBpbnN0YW5jZW9mIGNvcmUuJFpvZFR5cGU7XG4gICAgY29uc3QgcGFyYW1zID0gaGFzUmVzdCA/IF9wYXJhbXMgOiBfcGFyYW1zT3JSZXN0O1xuICAgIGNvbnN0IHJlc3QgPSBoYXNSZXN0ID8gX3BhcmFtc09yUmVzdCA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgaXRlbXM6IGl0ZW1zLFxuICAgICAgICByZXN0LFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFJlY29yZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RSZWNvcmRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFJlY29yZC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnJlY29yZFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5rZXlUeXBlID0gZGVmLmtleVR5cGU7XG4gICAgaW5zdC52YWx1ZVR5cGUgPSBkZWYudmFsdWVUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcmVjb3JkKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIHR5cGUgYWxrc2pmID0gY29yZS5vdXRwdXQ8Y29yZS4kWm9kUmVjb3JkS2V5PjtcbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsUmVjb3JkKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgY29uc3QgayA9IGNvcmUuY2xvbmUoa2V5VHlwZSk7XG4gICAgay5fem9kLnZhbHVlcyA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgIGtleVR5cGU6IGssXG4gICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGxvb3NlUmVjb3JkKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWNvcmQoe1xuICAgICAgICB0eXBlOiBcInJlY29yZFwiLFxuICAgICAgICBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgbW9kZTogXCJsb29zZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE1hcCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RNYXBcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE1hcC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm1hcFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5rZXlUeXBlID0gZGVmLmtleVR5cGU7XG4gICAgaW5zdC52YWx1ZVR5cGUgPSBkZWYudmFsdWVUeXBlO1xuICAgIGluc3QubWluID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSgxLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21heFNpemUoLi4uYXJncykpO1xuICAgIGluc3Quc2l6ZSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3NpemUoLi4uYXJncykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbWFwKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB0eXBlOiBcIm1hcFwiLFxuICAgICAgICBrZXlUeXBlOiBrZXlUeXBlLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RTZXQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kU2V0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTZXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5zZXRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QubWluID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC5ub25lbXB0eSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZSgxLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21heFNpemUoLi4uYXJncykpO1xuICAgIGluc3Quc2l6ZSA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3NpemUoLi4uYXJncykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc2V0KHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICB2YWx1ZVR5cGU6IHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RFbnVtID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEVudW1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEVudW0uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5lbnVtUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LmVudW0gPSBkZWYuZW50cmllcztcbiAgICBpbnN0Lm9wdGlvbnMgPSBPYmplY3QudmFsdWVzKGRlZi5lbnRyaWVzKTtcbiAgICBjb25zdCBrZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyhkZWYuZW50cmllcykpO1xuICAgIGluc3QuZXh0cmFjdCA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBuZXdFbnRyaWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmV3RW50cmllc1t2YWx1ZV0gPSBkZWYuZW50cmllc1t2YWx1ZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHt2YWx1ZX0gbm90IGZvdW5kIGluIGVudW1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICAgICAgLi4uZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgICAgICBlbnRyaWVzOiBuZXdFbnRyaWVzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGluc3QuZXhjbHVkZSA9ICh2YWx1ZXMsIHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCBuZXdFbnRyaWVzID0geyAuLi5kZWYuZW50cmllcyB9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtleXMuaGFzKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBuZXdFbnRyaWVzW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3ZhbHVlfSBub3QgZm91bmQgaW4gZW51bWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgICAgIGVudHJpZXM6IG5ld0VudHJpZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIF9lbnVtKHZhbHVlcywgcGFyYW1zKSB7XG4gICAgY29uc3QgZW50cmllcyA9IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IE9iamVjdC5mcm9tRW50cmllcyh2YWx1ZXMubWFwKCh2KSA9PiBbdiwgdl0pKSA6IHZhbHVlcztcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IF9lbnVtIGFzIGVudW0gfTtcbi8qKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBtZXJnZWQgaW50byBgei5lbnVtKClgLiBVc2UgYHouZW51bSgpYCBpbnN0ZWFkLlxuICpcbiAqIGBgYHRzXG4gKiBlbnVtIENvbG9ycyB7IHJlZCwgZ3JlZW4sIGJsdWUgfVxuICogei5lbnVtKENvbG9ycyk7XG4gKiBgYGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5hdGl2ZUVudW0oZW50cmllcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgdHlwZTogXCJlbnVtXCIsXG4gICAgICAgIGVudHJpZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTGl0ZXJhbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RMaXRlcmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RMaXRlcmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubGl0ZXJhbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC52YWx1ZXMgPSBuZXcgU2V0KGRlZi52YWx1ZXMpO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcInZhbHVlXCIsIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgaWYgKGRlZi52YWx1ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgc2NoZW1hIGNvbnRhaW5zIG11bHRpcGxlIHZhbGlkIGxpdGVyYWwgdmFsdWVzLiBVc2UgYC52YWx1ZXNgIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlZi52YWx1ZXNbMF07XG4gICAgICAgIH0sXG4gICAgfSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBsaXRlcmFsKHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xuICAgICAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICAgICAgdmFsdWVzOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RGaWxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEZpbGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEZpbGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5maWxlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm1pbiA9IChzaXplLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWluU2l6ZShzaXplLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9IChzaXplLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fbWF4U2l6ZShzaXplLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1pbWUgPSAodHlwZXMsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW1lKEFycmF5LmlzQXJyYXkodHlwZXMpID8gdHlwZXMgOiBbdHlwZXNdLCBwYXJhbXMpKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2ZpbGUoWm9kRmlsZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RUcmFuc2Zvcm0gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVHJhbnNmb3JtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RUcmFuc2Zvcm0uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy50cmFuc2Zvcm1Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmIChfY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kRW5jb2RlRXJyb3IoaW5zdC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmFkZElzc3VlID0gKGlzc3VlKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlzc3VlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKGlzc3VlLCBwYXlsb2FkLnZhbHVlLCBkZWYpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGZvciBab2QgMyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgICAgIGNvbnN0IF9pc3N1ZSA9IGlzc3VlO1xuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZmF0YWwpXG4gICAgICAgICAgICAgICAgICAgIF9pc3N1ZS5jb250aW51ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5jb2RlID8/IChfaXNzdWUuY29kZSA9IFwiY3VzdG9tXCIpO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5pbnB1dCA/PyAoX2lzc3VlLmlucHV0ID0gcGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmluc3QgPz8gKF9pc3N1ZS5pbnN0ID0gaW5zdCk7XG4gICAgICAgICAgICAgICAgLy8gX2lzc3VlLmNvbnRpbnVlID8/PSB0cnVlO1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbC5pc3N1ZShfaXNzdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKG91dHB1dCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0KSA9PiB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBvdXRwdXQ7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB0cmFuc2Zvcm0oZm4pIHtcbiAgICByZXR1cm4gbmV3IFpvZFRyYW5zZm9ybSh7XG4gICAgICAgIHR5cGU6IFwidHJhbnNmb3JtXCIsXG4gICAgICAgIHRyYW5zZm9ybTogZm4sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kT3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMub3B0aW9uYWxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBvcHRpb25hbChpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RFeGFjdE9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEV4YWN0T3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEV4YWN0T3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5vcHRpb25hbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGV4YWN0T3B0aW9uYWwoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RFeGFjdE9wdGlvbmFsKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2ROdWxsYWJsZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTnVsbGFibGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5udWxsYWJsZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG51bGxhYmxlKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICB0eXBlOiBcIm51bGxhYmxlXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gbnVsbGlzaFxuZXhwb3J0IGZ1bmN0aW9uIG51bGxpc2goaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG9wdGlvbmFsKG51bGxhYmxlKGlubmVyVHlwZSkpO1xufVxuZXhwb3J0IGNvbnN0IFpvZERlZmF1bHQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRGVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRGVmYXVsdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmRlZmF1bHRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG4gICAgaW5zdC5yZW1vdmVEZWZhdWx0ID0gaW5zdC51bndyYXA7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBfZGVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgIHR5cGU6IFwiZGVmYXVsdFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IHV0aWwuc2hhbGxvd0Nsb25lKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kUHJlZmF1bHQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kUHJlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFByZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucHJlZmF1bHRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBwcmVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgWm9kUHJlZmF1bHQoe1xuICAgICAgICB0eXBlOiBcInByZWZhdWx0XCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogdXRpbC5zaGFsbG93Q2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2ROb25PcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROb25PcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTm9uT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5ub25vcHRpb25hbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG5vbm9wdGlvbmFsKGlubmVyVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2ROb25PcHRpb25hbCh7XG4gICAgICAgIHR5cGU6IFwibm9ub3B0aW9uYWxcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kU3VjY2VzcyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTdWNjZXNzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTdWNjZXNzLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuc3VjY2Vzc1Byb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHN1Y2Nlc3MoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RTdWNjZXNzKHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZENhdGNoID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENhdGNoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RDYXRjaC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmNhdGNoUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuICAgIGluc3QucmVtb3ZlQ2F0Y2ggPSBpbnN0LnVud3JhcDtcbn0pO1xuZnVuY3Rpb24gX2NhdGNoKGlubmVyVHlwZSwgY2F0Y2hWYWx1ZSkge1xuICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICB0eXBlOiBcImNhdGNoXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgICAgICBjYXRjaFZhbHVlOiAodHlwZW9mIGNhdGNoVmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGNhdGNoVmFsdWUgOiAoKSA9PiBjYXRjaFZhbHVlKSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IF9jYXRjaCBhcyBjYXRjaCB9O1xuZXhwb3J0IGNvbnN0IFpvZE5hTiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROYU5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE5hTi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm5hblByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBuYW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX25hbihab2ROYU4sIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kUGlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RQaXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RQaXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucGlwZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5pbiA9IGRlZi5pbjtcbiAgICBpbnN0Lm91dCA9IGRlZi5vdXQ7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBwaXBlKGluXywgb3V0KSB7XG4gICAgcmV0dXJuIG5ldyBab2RQaXBlKHtcbiAgICAgICAgdHlwZTogXCJwaXBlXCIsXG4gICAgICAgIGluOiBpbl8sXG4gICAgICAgIG91dDogb3V0LFxuICAgICAgICAvLyAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZENvZGVjID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENvZGVjXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBab2RQaXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RDb2RlYy5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjb2RlYyhpbl8sIG91dCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RDb2RlYyh7XG4gICAgICAgIHR5cGU6IFwicGlwZVwiLFxuICAgICAgICBpbjogaW5fLFxuICAgICAgICBvdXQ6IG91dCxcbiAgICAgICAgdHJhbnNmb3JtOiBwYXJhbXMuZGVjb2RlLFxuICAgICAgICByZXZlcnNlVHJhbnNmb3JtOiBwYXJhbXMuZW5jb2RlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFJlYWRvbmx5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RSZWFkb25seS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnJlYWRvbmx5UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcmVhZG9ubHkoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIHR5cGU6IFwicmVhZG9ubHlcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kVGVtcGxhdGVMaXRlcmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFRlbXBsYXRlTGl0ZXJhbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVGVtcGxhdGVMaXRlcmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMudGVtcGxhdGVMaXRlcmFsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlTGl0ZXJhbChwYXJ0cywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RUZW1wbGF0ZUxpdGVyYWwoe1xuICAgICAgICB0eXBlOiBcInRlbXBsYXRlX2xpdGVyYWxcIixcbiAgICAgICAgcGFydHMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTGF6eSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RMYXp5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RMYXp5LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubGF6eVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmdldHRlcigpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbGF6eShnZXR0ZXIpIHtcbiAgICByZXR1cm4gbmV3IFpvZExhenkoe1xuICAgICAgICB0eXBlOiBcImxhenlcIixcbiAgICAgICAgZ2V0dGVyOiBnZXR0ZXIsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kUHJvbWlzZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RQcm9taXNlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RQcm9taXNlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucHJvbWlzZVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHByb21pc2UoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RQcm9taXNlKHtcbiAgICAgICAgdHlwZTogXCJwcm9taXNlXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEZ1bmN0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEZ1bmN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RGdW5jdGlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmZ1bmN0aW9uUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIF9mdW5jdGlvbihwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICBpbnB1dDogQXJyYXkuaXNBcnJheShwYXJhbXM/LmlucHV0KSA/IHR1cGxlKHBhcmFtcz8uaW5wdXQpIDogKHBhcmFtcz8uaW5wdXQgPz8gYXJyYXkodW5rbm93bigpKSksXG4gICAgICAgIG91dHB1dDogcGFyYW1zPy5vdXRwdXQgPz8gdW5rbm93bigpLFxuICAgIH0pO1xufVxuZXhwb3J0IHsgX2Z1bmN0aW9uIGFzIGZ1bmN0aW9uIH07XG5leHBvcnQgY29uc3QgWm9kQ3VzdG9tID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEN1c3RvbVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQ3VzdG9tLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuY3VzdG9tUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuLy8gY3VzdG9tIGNoZWNrc1xuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrKGZuKSB7XG4gICAgY29uc3QgY2ggPSBuZXcgY29yZS4kWm9kQ2hlY2soe1xuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgLy8gLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbiAgICBjaC5fem9kLmNoZWNrID0gZm47XG4gICAgcmV0dXJuIGNoO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGN1c3RvbShmbiwgX3BhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jdXN0b20oWm9kQ3VzdG9tLCBmbiA/PyAoKCkgPT4gdHJ1ZSksIF9wYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlZmluZShmbiwgX3BhcmFtcyA9IHt9KSB7XG4gICAgcmV0dXJuIGNvcmUuX3JlZmluZShab2RDdXN0b20sIGZuLCBfcGFyYW1zKTtcbn1cbi8vIHN1cGVyUmVmaW5lXG5leHBvcnQgZnVuY3Rpb24gc3VwZXJSZWZpbmUoZm4pIHtcbiAgICByZXR1cm4gY29yZS5fc3VwZXJSZWZpbmUoZm4pO1xufVxuLy8gUmUtZXhwb3J0IGRlc2NyaWJlIGFuZCBtZXRhIGZyb20gY29yZVxuZXhwb3J0IGNvbnN0IGRlc2NyaWJlID0gY29yZS5kZXNjcmliZTtcbmV4cG9ydCBjb25zdCBtZXRhID0gY29yZS5tZXRhO1xuZnVuY3Rpb24gX2luc3RhbmNlb2YoY2xzLCBwYXJhbXMgPSB7fSkge1xuICAgIGNvbnN0IGluc3QgPSBuZXcgWm9kQ3VzdG9tKHtcbiAgICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgICAgIGZuOiAoZGF0YSkgPT4gZGF0YSBpbnN0YW5jZW9mIGNscyxcbiAgICAgICAgYWJvcnQ6IHRydWUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmJhZy5DbGFzcyA9IGNscztcbiAgICAvLyBPdmVycmlkZSBjaGVjayB0byBlbWl0IGludmFsaWRfdHlwZSBpbnN0ZWFkIG9mIGN1c3RvbVxuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmICghKHBheWxvYWQudmFsdWUgaW5zdGFuY2VvZiBjbHMpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBjbHMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi4oaW5zdC5fem9kLmRlZi5wYXRoID8/IFtdKV0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGluc3Q7XG59XG5leHBvcnQgeyBfaW5zdGFuY2VvZiBhcyBpbnN0YW5jZW9mIH07XG4vLyBzdHJpbmdib29sXG5leHBvcnQgY29uc3Qgc3RyaW5nYm9vbCA9ICguLi5hcmdzKSA9PiBjb3JlLl9zdHJpbmdib29sKHtcbiAgICBDb2RlYzogWm9kQ29kZWMsXG4gICAgQm9vbGVhbjogWm9kQm9vbGVhbixcbiAgICBTdHJpbmc6IFpvZFN0cmluZyxcbn0sIC4uLmFyZ3MpO1xuZXhwb3J0IGZ1bmN0aW9uIGpzb24ocGFyYW1zKSB7XG4gICAgY29uc3QganNvblNjaGVtYSA9IGxhenkoKCkgPT4ge1xuICAgICAgICByZXR1cm4gdW5pb24oW3N0cmluZyhwYXJhbXMpLCBudW1iZXIoKSwgYm9vbGVhbigpLCBfbnVsbCgpLCBhcnJheShqc29uU2NoZW1hKSwgcmVjb3JkKHN0cmluZygpLCBqc29uU2NoZW1hKV0pO1xuICAgIH0pO1xuICAgIHJldHVybiBqc29uU2NoZW1hO1xufVxuLy8gcHJlcHJvY2Vzc1xuLy8gLyoqIEBkZXByZWNhdGVkIFVzZSBgei5waXBlKClgIGFuZCBgei50cmFuc2Zvcm0oKWAgaW5zdGVhZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmVwcm9jZXNzKGZuLCBzY2hlbWEpIHtcbiAgICByZXR1cm4gcGlwZSh0cmFuc2Zvcm0oZm4pLCBzY2hlbWEpO1xufVxuIiwgImV4cG9ydCB7IF9sdCBhcyBsdCwgX2x0ZSBhcyBsdGUsIF9ndCBhcyBndCwgX2d0ZSBhcyBndGUsIF9wb3NpdGl2ZSBhcyBwb3NpdGl2ZSwgX25lZ2F0aXZlIGFzIG5lZ2F0aXZlLCBfbm9ucG9zaXRpdmUgYXMgbm9ucG9zaXRpdmUsIF9ub25uZWdhdGl2ZSBhcyBub25uZWdhdGl2ZSwgX211bHRpcGxlT2YgYXMgbXVsdGlwbGVPZiwgX21heFNpemUgYXMgbWF4U2l6ZSwgX21pblNpemUgYXMgbWluU2l6ZSwgX3NpemUgYXMgc2l6ZSwgX21heExlbmd0aCBhcyBtYXhMZW5ndGgsIF9taW5MZW5ndGggYXMgbWluTGVuZ3RoLCBfbGVuZ3RoIGFzIGxlbmd0aCwgX3JlZ2V4IGFzIHJlZ2V4LCBfbG93ZXJjYXNlIGFzIGxvd2VyY2FzZSwgX3VwcGVyY2FzZSBhcyB1cHBlcmNhc2UsIF9pbmNsdWRlcyBhcyBpbmNsdWRlcywgX3N0YXJ0c1dpdGggYXMgc3RhcnRzV2l0aCwgX2VuZHNXaXRoIGFzIGVuZHNXaXRoLCBfcHJvcGVydHkgYXMgcHJvcGVydHksIF9taW1lIGFzIG1pbWUsIF9vdmVyd3JpdGUgYXMgb3ZlcndyaXRlLCBfbm9ybWFsaXplIGFzIG5vcm1hbGl6ZSwgX3RyaW0gYXMgdHJpbSwgX3RvTG93ZXJDYXNlIGFzIHRvTG93ZXJDYXNlLCBfdG9VcHBlckNhc2UgYXMgdG9VcHBlckNhc2UsIF9zbHVnaWZ5IGFzIHNsdWdpZnksIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgKiBhcyBzY2hlbWFzIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmV4cG9ydCBjb25zdCBab2RJU09EYXRlVGltZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJU09EYXRlVGltZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSVNPRGF0ZVRpbWUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGV0aW1lKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pc29EYXRlVGltZShab2RJU09EYXRlVGltZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJU09EYXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElTT0RhdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZElTT0RhdGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lzb0RhdGUoWm9kSVNPRGF0ZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJU09UaW1lID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElTT1RpbWVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZElTT1RpbWUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHRpbWUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lzb1RpbWUoWm9kSVNPVGltZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJU09EdXJhdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RJU09EdXJhdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSVNPRHVyYXRpb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIHNjaGVtYXMuWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGR1cmF0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pc29EdXJhdGlvbihab2RJU09EdXJhdGlvbiwgcGFyYW1zKTtcbn1cbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyAkWm9kRXJyb3IgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi4vY29yZS91dGlsLmpzXCI7XG5jb25zdCBpbml0aWFsaXplciA9IChpbnN0LCBpc3N1ZXMpID0+IHtcbiAgICAkWm9kRXJyb3IuaW5pdChpbnN0LCBpc3N1ZXMpO1xuICAgIGluc3QubmFtZSA9IFwiWm9kRXJyb3JcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0LCB7XG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgICAgdmFsdWU6IChtYXBwZXIpID0+IGNvcmUuZm9ybWF0RXJyb3IoaW5zdCwgbWFwcGVyKSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBmbGF0dGVuOiB7XG4gICAgICAgICAgICB2YWx1ZTogKG1hcHBlcikgPT4gY29yZS5mbGF0dGVuRXJyb3IoaW5zdCwgbWFwcGVyKSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBhZGRJc3N1ZToge1xuICAgICAgICAgICAgdmFsdWU6IChpc3N1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGluc3QuaXNzdWVzLnB1c2goaXNzdWUpO1xuICAgICAgICAgICAgICAgIGluc3QubWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KGluc3QuaXNzdWVzLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGFkZElzc3Vlczoge1xuICAgICAgICAgICAgdmFsdWU6IChpc3N1ZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpbnN0Lmlzc3Vlcy5wdXNoKC4uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgaW5zdC5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoaW5zdC5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNFbXB0eToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgLy8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiaXNFbXB0eVwiLCB7XG4gICAgLy8gICBnZXQoKSB7XG4gICAgLy8gICAgIHJldHVybiBpbnN0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG4gICAgLy8gICB9LFxuICAgIC8vIH0pO1xufTtcbmV4cG9ydCBjb25zdCBab2RFcnJvciA9IGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIpO1xuZXhwb3J0IGNvbnN0IFpvZFJlYWxFcnJvciA9IGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIsIHtcbiAgICBQYXJlbnQ6IEVycm9yLFxufSk7XG4vLyAvKiogQGRlcHJlY2F0ZWQgVXNlIGB6LmNvcmUuJFpvZEVycm9yTWFwQ3R4YCBpbnN0ZWFkLiAqL1xuLy8gZXhwb3J0IHR5cGUgRXJyb3JNYXBDdHggPSBjb3JlLiRab2RFcnJvck1hcEN0eDtcbiIsICJpbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBab2RSZWFsRXJyb3IgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCBjb25zdCBwYXJzZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9wYXJzZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fcGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVQYXJzZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlUGFyc2UoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlUGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlUGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuLy8gQ29kZWMgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgZW5jb2RlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX2VuY29kZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9kZWNvZGUoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9lbmNvZGVBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IGRlY29kZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX2RlY29kZUFzeW5jKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZUVuY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRW5jb2RlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZURlY29kZSA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRGVjb2RlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZUVuY29kZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVFbmNvZGVBc3luYyhab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVEZWNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9zYWZlRGVjb2RlQXN5bmMoWm9kUmVhbEVycm9yKTtcbiIsICIvLyBab2QgMyBjb21wYXQgbGF5ZXJcbmltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbi8qKiBAZGVwcmVjYXRlZCBVc2UgdGhlIHJhdyBzdHJpbmcgbGl0ZXJhbCBjb2RlcyBpbnN0ZWFkLCBlLmcuIFwiaW52YWxpZF90eXBlXCIuICovXG5leHBvcnQgY29uc3QgWm9kSXNzdWVDb2RlID0ge1xuICAgIGludmFsaWRfdHlwZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICB0b29fYmlnOiBcInRvb19iaWdcIixcbiAgICB0b29fc21hbGw6IFwidG9vX3NtYWxsXCIsXG4gICAgaW52YWxpZF9mb3JtYXQ6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICBub3RfbXVsdGlwbGVfb2Y6IFwibm90X211bHRpcGxlX29mXCIsXG4gICAgdW5yZWNvZ25pemVkX2tleXM6IFwidW5yZWNvZ25pemVkX2tleXNcIixcbiAgICBpbnZhbGlkX3VuaW9uOiBcImludmFsaWRfdW5pb25cIixcbiAgICBpbnZhbGlkX2tleTogXCJpbnZhbGlkX2tleVwiLFxuICAgIGludmFsaWRfZWxlbWVudDogXCJpbnZhbGlkX2VsZW1lbnRcIixcbiAgICBpbnZhbGlkX3ZhbHVlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICBjdXN0b206IFwiY3VzdG9tXCIsXG59O1xuZXhwb3J0IHsgJGJyYW5kLCBjb25maWcgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSBgei5jb25maWcocGFyYW1zKWAgaW5zdGVhZC4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBjb3JlLmNvbmZpZyh7XG4gICAgICAgIGN1c3RvbUVycm9yOiBtYXAsXG4gICAgfSk7XG59XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGB6LmNvbmZpZygpYCBpbnN0ZWFkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBjb3JlLmNvbmZpZygpLmN1c3RvbUVycm9yO1xufVxuLyoqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UuIFN0dWIgZGVmaW5pdGlvbiwgb25seSBpbmNsdWRlZCBmb3Igem9kLXRvLWpzb24tc2NoZW1hIGNvbXBhdGliaWxpdHkuICovXG5leHBvcnQgdmFyIFpvZEZpcnN0UGFydHlUeXBlS2luZDtcbihmdW5jdGlvbiAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kKSB7XG59KShab2RGaXJzdFBhcnR5VHlwZUtpbmQgfHwgKFpvZEZpcnN0UGFydHlUeXBlS2luZCA9IHt9KSk7XG4iLCAiaW1wb3J0IHsgZ2xvYmFsUmVnaXN0cnkgfSBmcm9tIFwiLi4vY29yZS9yZWdpc3RyaWVzLmpzXCI7XG5pbXBvcnQgKiBhcyBfY2hlY2tzIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuaW1wb3J0ICogYXMgX2lzbyBmcm9tIFwiLi9pc28uanNcIjtcbmltcG9ydCAqIGFzIF9zY2hlbWFzIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbi8vIExvY2FsIHogb2JqZWN0IHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgd2l0aCAuLi9pbmRleC5qc1xuY29uc3QgeiA9IHtcbiAgICAuLi5fc2NoZW1hcyxcbiAgICAuLi5fY2hlY2tzLFxuICAgIGlzbzogX2lzbyxcbn07XG4vLyBLZXlzIHRoYXQgYXJlIHJlY29nbml6ZWQgYW5kIGhhbmRsZWQgYnkgdGhlIGNvbnZlcnNpb24gbG9naWNcbmNvbnN0IFJFQ09HTklaRURfS0VZUyA9IG5ldyBTZXQoW1xuICAgIC8vIFNjaGVtYSBpZGVudGlmaWNhdGlvblxuICAgIFwiJHNjaGVtYVwiLFxuICAgIFwiJHJlZlwiLFxuICAgIFwiJGRlZnNcIixcbiAgICBcImRlZmluaXRpb25zXCIsXG4gICAgLy8gQ29yZSBzY2hlbWEga2V5d29yZHNcbiAgICBcIiRpZFwiLFxuICAgIFwiaWRcIixcbiAgICBcIiRjb21tZW50XCIsXG4gICAgXCIkYW5jaG9yXCIsXG4gICAgXCIkdm9jYWJ1bGFyeVwiLFxuICAgIFwiJGR5bmFtaWNSZWZcIixcbiAgICBcIiRkeW5hbWljQW5jaG9yXCIsXG4gICAgLy8gVHlwZVxuICAgIFwidHlwZVwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiY29uc3RcIixcbiAgICAvLyBDb21wb3NpdGlvblxuICAgIFwiYW55T2ZcIixcbiAgICBcIm9uZU9mXCIsXG4gICAgXCJhbGxPZlwiLFxuICAgIFwibm90XCIsXG4gICAgLy8gT2JqZWN0XG4gICAgXCJwcm9wZXJ0aWVzXCIsXG4gICAgXCJyZXF1aXJlZFwiLFxuICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAgICBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJwcm9wZXJ0eU5hbWVzXCIsXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCIsXG4gICAgXCJtYXhQcm9wZXJ0aWVzXCIsXG4gICAgLy8gQXJyYXlcbiAgICBcIml0ZW1zXCIsXG4gICAgXCJwcmVmaXhJdGVtc1wiLFxuICAgIFwiYWRkaXRpb25hbEl0ZW1zXCIsXG4gICAgXCJtaW5JdGVtc1wiLFxuICAgIFwibWF4SXRlbXNcIixcbiAgICBcInVuaXF1ZUl0ZW1zXCIsXG4gICAgXCJjb250YWluc1wiLFxuICAgIFwibWluQ29udGFpbnNcIixcbiAgICBcIm1heENvbnRhaW5zXCIsXG4gICAgLy8gU3RyaW5nXG4gICAgXCJtaW5MZW5ndGhcIixcbiAgICBcIm1heExlbmd0aFwiLFxuICAgIFwicGF0dGVyblwiLFxuICAgIFwiZm9ybWF0XCIsXG4gICAgLy8gTnVtYmVyXG4gICAgXCJtaW5pbXVtXCIsXG4gICAgXCJtYXhpbXVtXCIsXG4gICAgXCJleGNsdXNpdmVNaW5pbXVtXCIsXG4gICAgXCJleGNsdXNpdmVNYXhpbXVtXCIsXG4gICAgXCJtdWx0aXBsZU9mXCIsXG4gICAgLy8gQWxyZWFkeSBoYW5kbGVkIG1ldGFkYXRhXG4gICAgXCJkZXNjcmlwdGlvblwiLFxuICAgIFwiZGVmYXVsdFwiLFxuICAgIC8vIENvbnRlbnRcbiAgICBcImNvbnRlbnRFbmNvZGluZ1wiLFxuICAgIFwiY29udGVudE1lZGlhVHlwZVwiLFxuICAgIFwiY29udGVudFNjaGVtYVwiLFxuICAgIC8vIFVuc3VwcG9ydGVkIChlcnJvci10aHJvd2luZylcbiAgICBcInVuZXZhbHVhdGVkSXRlbXNcIixcbiAgICBcInVuZXZhbHVhdGVkUHJvcGVydGllc1wiLFxuICAgIFwiaWZcIixcbiAgICBcInRoZW5cIixcbiAgICBcImVsc2VcIixcbiAgICBcImRlcGVuZGVudFNjaGVtYXNcIixcbiAgICBcImRlcGVuZGVudFJlcXVpcmVkXCIsXG4gICAgLy8gT3BlbkFQSVxuICAgIFwibnVsbGFibGVcIixcbiAgICBcInJlYWRPbmx5XCIsXG5dKTtcbmZ1bmN0aW9uIGRldGVjdFZlcnNpb24oc2NoZW1hLCBkZWZhdWx0VGFyZ2V0KSB7XG4gICAgY29uc3QgJHNjaGVtYSA9IHNjaGVtYS4kc2NoZW1hO1xuICAgIGlmICgkc2NoZW1hID09PSBcImh0dHBzOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LzIwMjAtMTIvc2NoZW1hXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZHJhZnQtMjAyMC0xMlwiO1xuICAgIH1cbiAgICBpZiAoJHNjaGVtYSA9PT0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYSNcIikge1xuICAgICAgICByZXR1cm4gXCJkcmFmdC03XCI7XG4gICAgfVxuICAgIGlmICgkc2NoZW1hID09PSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiKSB7XG4gICAgICAgIHJldHVybiBcImRyYWZ0LTRcIjtcbiAgICB9XG4gICAgLy8gVXNlIGRlZmF1bHRUYXJnZXQgaWYgcHJvdmlkZWQsIG90aGVyd2lzZSBkZWZhdWx0IHRvIGRyYWZ0LTIwMjAtMTJcbiAgICByZXR1cm4gZGVmYXVsdFRhcmdldCA/PyBcImRyYWZ0LTIwMjAtMTJcIjtcbn1cbmZ1bmN0aW9uIHJlc29sdmVSZWYocmVmLCBjdHgpIHtcbiAgICBpZiAoIXJlZi5zdGFydHNXaXRoKFwiI1wiKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHRlcm5hbCAkcmVmIGlzIG5vdCBzdXBwb3J0ZWQsIG9ubHkgbG9jYWwgcmVmcyAoIy8uLi4pIGFyZSBhbGxvd2VkXCIpO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gcmVmLnNsaWNlKDEpLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG4gICAgLy8gSGFuZGxlIHJvb3QgcmVmZXJlbmNlIFwiI1wiXG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBjdHgucm9vdFNjaGVtYTtcbiAgICB9XG4gICAgY29uc3QgZGVmc0tleSA9IGN0eC52ZXJzaW9uID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiJGRlZnNcIiA6IFwiZGVmaW5pdGlvbnNcIjtcbiAgICBpZiAocGF0aFswXSA9PT0gZGVmc0tleSkge1xuICAgICAgICBjb25zdCBrZXkgPSBwYXRoWzFdO1xuICAgICAgICBpZiAoIWtleSB8fCAhY3R4LmRlZnNba2V5XSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWZlcmVuY2Ugbm90IGZvdW5kOiAke3JlZn1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY3R4LmRlZnNba2V5XTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSZWZlcmVuY2Ugbm90IGZvdW5kOiAke3JlZn1gKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCYXNlU2NoZW1hKHNjaGVtYSwgY3R4KSB7XG4gICAgLy8gSGFuZGxlIHVuc3VwcG9ydGVkIGZlYXR1cmVzXG4gICAgaWYgKHNjaGVtYS5ub3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IHsgbm90OiB7fSB9IHJlcHJlc2VudHMgbmV2ZXJcbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubm90ID09PSBcIm9iamVjdFwiICYmIE9iamVjdC5rZXlzKHNjaGVtYS5ub3QpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHoubmV2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaXMgbm90IHN1cHBvcnRlZCBpbiBab2QgKGV4Y2VwdCB7IG5vdDoge30gfSBmb3IgbmV2ZXIpXCIpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLnVuZXZhbHVhdGVkSXRlbXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV2YWx1YXRlZEl0ZW1zIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEudW5ldmFsdWF0ZWRQcm9wZXJ0aWVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzIGlzIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEuaWYgIT09IHVuZGVmaW5lZCB8fCBzY2hlbWEudGhlbiAhPT0gdW5kZWZpbmVkIHx8IHNjaGVtYS5lbHNlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29uZGl0aW9uYWwgc2NoZW1hcyAoaWYvdGhlbi9lbHNlKSBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5kZXBlbmRlbnRTY2hlbWFzICE9PSB1bmRlZmluZWQgfHwgc2NoZW1hLmRlcGVuZGVudFJlcXVpcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZGVwZW5kZW50U2NoZW1hcyBhbmQgZGVwZW5kZW50UmVxdWlyZWQgYXJlIG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgfVxuICAgIC8vIEhhbmRsZSAkcmVmXG4gICAgaWYgKHNjaGVtYS4kcmVmKSB7XG4gICAgICAgIGNvbnN0IHJlZlBhdGggPSBzY2hlbWEuJHJlZjtcbiAgICAgICAgaWYgKGN0eC5yZWZzLmhhcyhyZWZQYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGN0eC5yZWZzLmdldChyZWZQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LnByb2Nlc3NpbmcuaGFzKHJlZlBhdGgpKSB7XG4gICAgICAgICAgICAvLyBDaXJjdWxhciByZWZlcmVuY2UgLSB1c2UgbGF6eVxuICAgICAgICAgICAgcmV0dXJuIHoubGF6eSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdHgucmVmcy5oYXMocmVmUGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaXJjdWxhciByZWZlcmVuY2Ugbm90IHJlc29sdmVkOiAke3JlZlBhdGh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucmVmcy5nZXQocmVmUGF0aCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjdHgucHJvY2Vzc2luZy5hZGQocmVmUGF0aCk7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVJlZihyZWZQYXRoLCBjdHgpO1xuICAgICAgICBjb25zdCB6b2RTY2hlbWEgPSBjb252ZXJ0U2NoZW1hKHJlc29sdmVkLCBjdHgpO1xuICAgICAgICBjdHgucmVmcy5zZXQocmVmUGF0aCwgem9kU2NoZW1hKTtcbiAgICAgICAgY3R4LnByb2Nlc3NpbmcuZGVsZXRlKHJlZlBhdGgpO1xuICAgICAgICByZXR1cm4gem9kU2NoZW1hO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgZW51bVxuICAgIGlmIChzY2hlbWEuZW51bSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGVudW1WYWx1ZXMgPSBzY2hlbWEuZW51bTtcbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBPcGVuQVBJIDMuMCBudWxsIHJlcHJlc2VudGF0aW9uIHsgdHlwZTogXCJzdHJpbmdcIiwgbnVsbGFibGU6IHRydWUsIGVudW06IFtudWxsXSB9XG4gICAgICAgIGlmIChjdHgudmVyc2lvbiA9PT0gXCJvcGVuYXBpLTMuMFwiICYmXG4gICAgICAgICAgICBzY2hlbWEubnVsbGFibGUgPT09IHRydWUgJiZcbiAgICAgICAgICAgIGVudW1WYWx1ZXMubGVuZ3RoID09PSAxICYmXG4gICAgICAgICAgICBlbnVtVmFsdWVzWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gei5udWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudW1WYWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5uZXZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbnVtVmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHoubGl0ZXJhbChlbnVtVmFsdWVzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBpZiBhbGwgdmFsdWVzIGFyZSBzdHJpbmdzXG4gICAgICAgIGlmIChlbnVtVmFsdWVzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICAgIHJldHVybiB6LmVudW0oZW51bVZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWl4ZWQgdHlwZXMgLSB1c2UgdW5pb24gb2YgbGl0ZXJhbHNcbiAgICAgICAgY29uc3QgbGl0ZXJhbFNjaGVtYXMgPSBlbnVtVmFsdWVzLm1hcCgodikgPT4gei5saXRlcmFsKHYpKTtcbiAgICAgICAgaWYgKGxpdGVyYWxTY2hlbWFzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXRlcmFsU2NoZW1hc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei51bmlvbihbbGl0ZXJhbFNjaGVtYXNbMF0sIGxpdGVyYWxTY2hlbWFzWzFdLCAuLi5saXRlcmFsU2NoZW1hcy5zbGljZSgyKV0pO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgY29uc3RcbiAgICBpZiAoc2NoZW1hLmNvbnN0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHoubGl0ZXJhbChzY2hlbWEuY29uc3QpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgdHlwZVxuICAgIGNvbnN0IHR5cGUgPSBzY2hlbWEudHlwZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAvLyBFeHBhbmQgdHlwZSBhcnJheSBpbnRvIGFueU9mIHVuaW9uXG4gICAgICAgIGNvbnN0IHR5cGVTY2hlbWFzID0gdHlwZS5tYXAoKHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGVTY2hlbWEgPSB7IC4uLnNjaGVtYSwgdHlwZTogdCB9O1xuICAgICAgICAgICAgcmV0dXJuIGNvbnZlcnRCYXNlU2NoZW1hKHR5cGVTY2hlbWEsIGN0eCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZVNjaGVtYXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5uZXZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlU2NoZW1hcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlU2NoZW1hc1swXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gei51bmlvbih0eXBlU2NoZW1hcyk7XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgICAvLyBObyB0eXBlIHNwZWNpZmllZCAtIGVtcHR5IHNjaGVtYSAoYW55KVxuICAgICAgICByZXR1cm4gei5hbnkoKTtcbiAgICB9XG4gICAgbGV0IHpvZFNjaGVtYTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XG4gICAgICAgICAgICBsZXQgc3RyaW5nU2NoZW1hID0gei5zdHJpbmcoKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGZvcm1hdCB1c2luZyAuY2hlY2soKSB3aXRoIFpvZCBmb3JtYXQgZnVuY3Rpb25zXG4gICAgICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZvcm1hdCA9IHNjaGVtYS5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgLy8gTWFwIGNvbW1vbiBmb3JtYXRzIHRvIFpvZCBjaGVjayBmdW5jdGlvbnNcbiAgICAgICAgICAgICAgICBpZiAoZm9ybWF0ID09PSBcImVtYWlsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouZW1haWwoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ1cmlcIiB8fCBmb3JtYXQgPT09IFwidXJpLXJlZmVyZW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LnVybCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInV1aWRcIiB8fCBmb3JtYXQgPT09IFwiZ3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LnV1aWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJkYXRlLXRpbWVcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pc28uZGF0ZXRpbWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXNvLmRhdGUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXNvLnRpbWUoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJkdXJhdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lmlzby5kdXJhdGlvbigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImlwdjRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pcHY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiaXB2NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmlwdjYoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJtYWNcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5tYWMoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouY2lkcnY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiY2lkci12NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmNpZHJ2NigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImJhc2U2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmJhc2U2NCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmJhc2U2NHVybCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImUxNjRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5lMTY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiand0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouand0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5lbW9qaSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIm5hbm9pZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lm5hbm9pZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5jdWlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiY3VpZDJcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5jdWlkMigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInVsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei51bGlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwieGlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoueGlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwia3N1aWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5rc3VpZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm90ZToganNvbi1zdHJpbmcgZm9ybWF0IGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IFpvZFxuICAgICAgICAgICAgICAgIC8vIEN1c3RvbSBmb3JtYXRzIGFyZSBpZ25vcmVkIC0ga2VlcCBhcyBwbGFpbiBzdHJpbmdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFwcGx5IGNvbnN0cmFpbnRzXG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5MZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEubWluKHNjaGVtYS5taW5MZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4TGVuZ3RoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLm1heChzY2hlbWEubWF4TGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2hlbWEucGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIEpTT04gU2NoZW1hIHBhdHRlcm5zIGFyZSBub3QgaW1wbGljaXRseSBhbmNob3JlZCAobWF0Y2ggYW55d2hlcmUgaW4gc3RyaW5nKVxuICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5yZWdleChuZXcgUmVnRXhwKHNjaGVtYS5wYXR0ZXJuKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSBzdHJpbmdTY2hlbWE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6IHtcbiAgICAgICAgICAgIGxldCBudW1iZXJTY2hlbWEgPSB0eXBlID09PSBcImludGVnZXJcIiA/IHoubnVtYmVyKCkuaW50KCkgOiB6Lm51bWJlcigpO1xuICAgICAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubWluKHNjaGVtYS5taW5pbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubWF4KHNjaGVtYS5tYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEuZ3Qoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1pbmltdW0gPT09IHRydWUgJiYgdHlwZW9mIHNjaGVtYS5taW5pbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLmd0KHNjaGVtYS5taW5pbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubHQoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2NoZW1hLmV4Y2x1c2l2ZU1heGltdW0gPT09IHRydWUgJiYgdHlwZW9mIHNjaGVtYS5tYXhpbXVtID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbnVtYmVyU2NoZW1hID0gbnVtYmVyU2NoZW1hLmx0KHNjaGVtYS5tYXhpbXVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm11bHRpcGxlT2YgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubXVsdGlwbGVPZihzY2hlbWEubXVsdGlwbGVPZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSBudW1iZXJTY2hlbWE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOiB7XG4gICAgICAgICAgICB6b2RTY2hlbWEgPSB6LmJvb2xlYW4oKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJudWxsXCI6IHtcbiAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoubnVsbCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IHNjaGVtYS5wcm9wZXJ0aWVzIHx8IHt9O1xuICAgICAgICAgICAgY29uc3QgcmVxdWlyZWRTZXQgPSBuZXcgU2V0KHNjaGVtYS5yZXF1aXJlZCB8fCBbXSk7XG4gICAgICAgICAgICAvLyBDb252ZXJ0IHByb3BlcnRpZXMgLSBtYXJrIG9wdGlvbmFsIG9uZXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2tleSwgcHJvcFNjaGVtYV0gb2YgT2JqZWN0LmVudHJpZXMocHJvcGVydGllcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wWm9kU2NoZW1hID0gY29udmVydFNjaGVtYShwcm9wU2NoZW1hLCBjdHgpO1xuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBpbiByZXF1aXJlZCBhcnJheSwgbWFrZSBpdCBvcHRpb25hbFxuICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSByZXF1aXJlZFNldC5oYXMoa2V5KSA/IHByb3Bab2RTY2hlbWEgOiBwcm9wWm9kU2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcHJvcGVydHlOYW1lc1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5wcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5U2NoZW1hID0gY29udmVydFNjaGVtYShzY2hlbWEucHJvcGVydHlOYW1lcywgY3R4KTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVNjaGVtYSA9IHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyAmJiB0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFNjaGVtYShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIGN0eClcbiAgICAgICAgICAgICAgICAgICAgOiB6LmFueSgpO1xuICAgICAgICAgICAgICAgIC8vIENhc2UgQTogTm8gcHJvcGVydGllcyAocHVyZSByZWNvcmQpXG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNoYXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei5yZWNvcmQoa2V5U2NoZW1hLCB2YWx1ZVNjaGVtYSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDYXNlIEI6IFdpdGggcHJvcGVydGllcyAoaW50ZXJzZWN0aW9uIG9mIG9iamVjdCBhbmQgbG9vc2VSZWNvcmQpXG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2NoZW1hID0gei5vYmplY3Qoc2hhcGUpLnBhc3N0aHJvdWdoKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjb3JkU2NoZW1hID0gei5sb29zZVJlY29yZChrZXlTY2hlbWEsIHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LmludGVyc2VjdGlvbihvYmplY3RTY2hlbWEsIHJlY29yZFNjaGVtYSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgcGF0dGVyblByb3BlcnRpZXNcbiAgICAgICAgICAgIGlmIChzY2hlbWEucGF0dGVyblByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXR0ZXJuUHJvcGVydGllczoga2V5cyBtYXRjaGluZyBwYXR0ZXJuIG11c3Qgc2F0aXNmeSBjb3JyZXNwb25kaW5nIHNjaGVtYVxuICAgICAgICAgICAgICAgIC8vIFVzZSBsb29zZSByZWNvcmRzIHNvIG5vbi1tYXRjaGluZyBrZXlzIHBhc3MgdGhyb3VnaFxuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5Qcm9wcyA9IHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcztcbiAgICAgICAgICAgICAgICBjb25zdCBwYXR0ZXJuS2V5cyA9IE9iamVjdC5rZXlzKHBhdHRlcm5Qcm9wcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9vc2VSZWNvcmRzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5LZXlzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5WYWx1ZSA9IGNvbnZlcnRTY2hlbWEocGF0dGVyblByb3BzW3BhdHRlcm5dLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlTY2hlbWEgPSB6LnN0cmluZygpLnJlZ2V4KG5ldyBSZWdFeHAocGF0dGVybikpO1xuICAgICAgICAgICAgICAgICAgICBsb29zZVJlY29yZHMucHVzaCh6Lmxvb3NlUmVjb3JkKGtleVNjaGVtYSwgcGF0dGVyblZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEJ1aWxkIGludGVyc2VjdGlvbjogb2JqZWN0IHNjaGVtYSArIGFsbCBwYXR0ZXJuIHByb3BlcnR5IHJlY29yZHNcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFzVG9JbnRlcnNlY3QgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2hhcGUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXNlIHBhc3N0aHJvdWdoIHNvIHBhdHRlcm5Qcm9wZXJ0aWVzIGNhbiB2YWxpZGF0ZSBhZGRpdGlvbmFsIGtleXNcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hc1RvSW50ZXJzZWN0LnB1c2goei5vYmplY3Qoc2hhcGUpLnBhc3N0aHJvdWdoKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzY2hlbWFzVG9JbnRlcnNlY3QucHVzaCguLi5sb29zZVJlY29yZHMpO1xuICAgICAgICAgICAgICAgIGlmIChzY2hlbWFzVG9JbnRlcnNlY3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoub2JqZWN0KHt9KS5wYXNzdGhyb3VnaCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzY2hlbWFzVG9JbnRlcnNlY3QubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHNjaGVtYXNUb0ludGVyc2VjdFswXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoYWluIGludGVyc2VjdGlvbnM6IChBICYgQikgJiBDICYgRCAuLi5cbiAgICAgICAgICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHouaW50ZXJzZWN0aW9uKHNjaGVtYXNUb0ludGVyc2VjdFswXSwgc2NoZW1hc1RvSW50ZXJzZWN0WzFdKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBzY2hlbWFzVG9JbnRlcnNlY3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHouaW50ZXJzZWN0aW9uKHJlc3VsdCwgc2NoZW1hc1RvSW50ZXJzZWN0W2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZGxlIGFkZGl0aW9uYWxQcm9wZXJ0aWVzXG4gICAgICAgICAgICAvLyBJbiBKU09OIFNjaGVtYSwgYWRkaXRpb25hbFByb3BlcnRpZXMgZGVmYXVsdHMgdG8gdHJ1ZSAoYWxsb3cgYW55IGV4dHJhIHByb3BlcnRpZXMpXG4gICAgICAgICAgICAvLyBJbiBab2QsIG9iamVjdHMgc3RyaXAgdW5rbm93biBrZXlzIGJ5IGRlZmF1bHQsIHNvIHdlIG5lZWQgdG8gaGFuZGxlIHRoaXMgZXhwbGljaXRseVxuICAgICAgICAgICAgY29uc3Qgb2JqZWN0U2NoZW1hID0gei5vYmplY3Qoc2hhcGUpO1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAvLyBTdHJpY3QgbW9kZSAtIG5vIGV4dHJhIHByb3BlcnRpZXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IG9iamVjdFNjaGVtYS5zdHJpY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYSBwcm9wZXJ0aWVzIG11c3QgbWF0Y2ggdGhlIHNwZWNpZmllZCBzY2hlbWFcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBvYmplY3RTY2hlbWEuY2F0Y2hhbGwoY29udmVydFNjaGVtYShzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkaXRpb25hbFByb3BlcnRpZXMgaXMgdHJ1ZSBvciB1bmRlZmluZWQgLSBhbGxvdyBhbnkgZXh0cmEgcHJvcGVydGllcyAocGFzc3Rocm91Z2gpXG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gb2JqZWN0U2NoZW1hLnBhc3N0aHJvdWdoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiYXJyYXlcIjoge1xuICAgICAgICAgICAgLy8gVE9ETzogdW5pcXVlSXRlbXMgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gVE9ETzogY29udGFpbnMvbWluQ29udGFpbnMvbWF4Q29udGFpbnMgYXJlIG5vdCBzdXBwb3J0ZWRcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB0dXBsZSAocHJlZml4SXRlbXMgb3IgaXRlbXMgYXMgYXJyYXkpXG4gICAgICAgICAgICBjb25zdCBwcmVmaXhJdGVtcyA9IHNjaGVtYS5wcmVmaXhJdGVtcztcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1zID0gc2NoZW1hLml0ZW1zO1xuICAgICAgICAgICAgaWYgKHByZWZpeEl0ZW1zICYmIEFycmF5LmlzQXJyYXkocHJlZml4SXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGUgd2l0aCBwcmVmaXhJdGVtcyAoZHJhZnQtMjAyMC0xMilcbiAgICAgICAgICAgICAgICBjb25zdCB0dXBsZUl0ZW1zID0gcHJlZml4SXRlbXMubWFwKChpdGVtKSA9PiBjb252ZXJ0U2NoZW1hKGl0ZW0sIGN0eCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBpdGVtcyAmJiB0eXBlb2YgaXRlbXMgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkoaXRlbXMpXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFNjaGVtYShpdGVtcywgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpLnJlc3QocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBtaW5JdGVtcy9tYXhJdGVtcyBjb25zdHJhaW50cyB0byB0dXBsZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5JdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuY2hlY2soei5taW5MZW5ndGgoc2NoZW1hLm1pbkl0ZW1zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heEl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5jaGVjayh6Lm1heExlbmd0aChzY2hlbWEubWF4SXRlbXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGl0ZW1zKSkge1xuICAgICAgICAgICAgICAgIC8vIFR1cGxlIHdpdGggaXRlbXMgYXJyYXkgKGRyYWZ0LTcpXG4gICAgICAgICAgICAgICAgY29uc3QgdHVwbGVJdGVtcyA9IGl0ZW1zLm1hcCgoaXRlbSkgPT4gY29udmVydFNjaGVtYShpdGVtLCBjdHgpKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN0ID0gc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyAmJiB0eXBlb2Ygc2NoZW1hLmFkZGl0aW9uYWxJdGVtcyA9PT0gXCJvYmplY3RcIlxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRTY2hlbWEoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcywgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZDsgLy8gYWRkaXRpb25hbEl0ZW1zOiBmYWxzZSBtZWFucyBubyByZXN0LCBoYW5kbGVkIGJ5IGRlZmF1bHQgdHVwbGUgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBpZiAocmVzdCkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpLnJlc3QocmVzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnR1cGxlKHR1cGxlSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBcHBseSBtaW5JdGVtcy9tYXhJdGVtcyBjb25zdHJhaW50cyB0byB0dXBsZXNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5JdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuY2hlY2soei5taW5MZW5ndGgoc2NoZW1hLm1pbkl0ZW1zKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heEl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5jaGVjayh6Lm1heExlbmd0aChzY2hlbWEubWF4SXRlbXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVndWxhciBhcnJheVxuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBjb252ZXJ0U2NoZW1hKGl0ZW1zLCBjdHgpO1xuICAgICAgICAgICAgICAgIGxldCBhcnJheVNjaGVtYSA9IHouYXJyYXkoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5taW5JdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVNjaGVtYSA9IGFycmF5U2NoZW1hLm1pbihzY2hlbWEubWluSXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhJdGVtcyA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBhcnJheVNjaGVtYSA9IGFycmF5U2NoZW1hLm1heChzY2hlbWEubWF4SXRlbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBhcnJheVNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vIGl0ZW1zIHNwZWNpZmllZCAtIGFycmF5IG9mIGFueVxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHouYXJyYXkoei5hbnkoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCB0eXBlOiAke3R5cGV9YCk7XG4gICAgfVxuICAgIC8vIEFwcGx5IG1ldGFkYXRhXG4gICAgaWYgKHNjaGVtYS5kZXNjcmlwdGlvbikge1xuICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuZGVzY3JpYmUoc2NoZW1hLmRlc2NyaXB0aW9uKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmRlZmF1bHQoc2NoZW1hLmRlZmF1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gem9kU2NoZW1hO1xufVxuZnVuY3Rpb24gY29udmVydFNjaGVtYShzY2hlbWEsIGN0eCkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gc2NoZW1hID8gei5hbnkoKSA6IHoubmV2ZXIoKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBiYXNlIHNjaGVtYSBmaXJzdCAoaWdub3JpbmcgY29tcG9zaXRpb24ga2V5d29yZHMpXG4gICAgbGV0IGJhc2VTY2hlbWEgPSBjb252ZXJ0QmFzZVNjaGVtYShzY2hlbWEsIGN0eCk7XG4gICAgY29uc3QgaGFzRXhwbGljaXRUeXBlID0gc2NoZW1hLnR5cGUgfHwgc2NoZW1hLmVudW0gIT09IHVuZGVmaW5lZCB8fCBzY2hlbWEuY29uc3QgIT09IHVuZGVmaW5lZDtcbiAgICAvLyBQcm9jZXNzIGNvbXBvc2l0aW9uIGtleXdvcmRzIExBU1QgKHRoZXkgY2FuIGFwcGVhciB0b2dldGhlcilcbiAgICAvLyBIYW5kbGUgYW55T2YgLSB3cmFwIGJhc2Ugc2NoZW1hIHdpdGggdW5pb25cbiAgICBpZiAoc2NoZW1hLmFueU9mICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFueU9mKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc2NoZW1hLmFueU9mLm1hcCgocykgPT4gY29udmVydFNjaGVtYShzLCBjdHgpKTtcbiAgICAgICAgY29uc3QgYW55T2ZVbmlvbiA9IHoudW5pb24ob3B0aW9ucyk7XG4gICAgICAgIGJhc2VTY2hlbWEgPSBoYXNFeHBsaWNpdFR5cGUgPyB6LmludGVyc2VjdGlvbihiYXNlU2NoZW1hLCBhbnlPZlVuaW9uKSA6IGFueU9mVW5pb247XG4gICAgfVxuICAgIC8vIEhhbmRsZSBvbmVPZiAtIGV4Y2x1c2l2ZSB1bmlvbiAoZXhhY3RseSBvbmUgbXVzdCBtYXRjaClcbiAgICBpZiAoc2NoZW1hLm9uZU9mICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc2NoZW1hLm9uZU9mLm1hcCgocykgPT4gY29udmVydFNjaGVtYShzLCBjdHgpKTtcbiAgICAgICAgY29uc3Qgb25lT2ZVbmlvbiA9IHoueG9yKG9wdGlvbnMpO1xuICAgICAgICBiYXNlU2NoZW1hID0gaGFzRXhwbGljaXRUeXBlID8gei5pbnRlcnNlY3Rpb24oYmFzZVNjaGVtYSwgb25lT2ZVbmlvbikgOiBvbmVPZlVuaW9uO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgYWxsT2YgLSB3cmFwIGJhc2Ugc2NoZW1hIHdpdGggaW50ZXJzZWN0aW9uXG4gICAgaWYgKHNjaGVtYS5hbGxPZiAmJiBBcnJheS5pc0FycmF5KHNjaGVtYS5hbGxPZikpIHtcbiAgICAgICAgaWYgKHNjaGVtYS5hbGxPZi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGJhc2VTY2hlbWEgPSBoYXNFeHBsaWNpdFR5cGUgPyBiYXNlU2NoZW1hIDogei5hbnkoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSBoYXNFeHBsaWNpdFR5cGUgPyBiYXNlU2NoZW1hIDogY29udmVydFNjaGVtYShzY2hlbWEuYWxsT2ZbMF0sIGN0eCk7XG4gICAgICAgICAgICBjb25zdCBzdGFydElkeCA9IGhhc0V4cGxpY2l0VHlwZSA/IDAgOiAxO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0SWR4OyBpIDwgc2NoZW1hLmFsbE9mLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gei5pbnRlcnNlY3Rpb24ocmVzdWx0LCBjb252ZXJ0U2NoZW1hKHNjaGVtYS5hbGxPZltpXSwgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBiYXNlU2NoZW1hID0gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEhhbmRsZSBudWxsYWJsZSAoT3BlbkFQSSAzLjApXG4gICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSAmJiBjdHgudmVyc2lvbiA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgIGJhc2VTY2hlbWEgPSB6Lm51bGxhYmxlKGJhc2VTY2hlbWEpO1xuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVhZE9ubHlcbiAgICBpZiAoc2NoZW1hLnJlYWRPbmx5ID09PSB0cnVlKSB7XG4gICAgICAgIGJhc2VTY2hlbWEgPSB6LnJlYWRvbmx5KGJhc2VTY2hlbWEpO1xuICAgIH1cbiAgICAvLyBDb2xsZWN0IG1ldGFkYXRhOiBjb3JlIHNjaGVtYSBrZXl3b3JkcyBhbmQgdW5yZWNvZ25pemVkIGtleXNcbiAgICBjb25zdCBleHRyYU1ldGEgPSB7fTtcbiAgICAvLyBDb3JlIHNjaGVtYSBrZXl3b3JkcyB0aGF0IHNob3VsZCBiZSBjYXB0dXJlZCBhcyBtZXRhZGF0YVxuICAgIGNvbnN0IGNvcmVNZXRhZGF0YUtleXMgPSBbXCIkaWRcIiwgXCJpZFwiLCBcIiRjb21tZW50XCIsIFwiJGFuY2hvclwiLCBcIiR2b2NhYnVsYXJ5XCIsIFwiJGR5bmFtaWNSZWZcIiwgXCIkZHluYW1pY0FuY2hvclwiXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBjb3JlTWV0YWRhdGFLZXlzKSB7XG4gICAgICAgIGlmIChrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBleHRyYU1ldGFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbnRlbnQga2V5d29yZHMgLSBzdG9yZSBhcyBtZXRhZGF0YVxuICAgIGNvbnN0IGNvbnRlbnRNZXRhZGF0YUtleXMgPSBbXCJjb250ZW50RW5jb2RpbmdcIiwgXCJjb250ZW50TWVkaWFUeXBlXCIsIFwiY29udGVudFNjaGVtYVwiXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBjb250ZW50TWV0YWRhdGFLZXlzKSB7XG4gICAgICAgIGlmIChrZXkgaW4gc2NoZW1hKSB7XG4gICAgICAgICAgICBleHRyYU1ldGFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVucmVjb2duaXplZCBrZXlzIChjdXN0b20gbWV0YWRhdGEpXG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoc2NoZW1hKSkge1xuICAgICAgICBpZiAoIVJFQ09HTklaRURfS0VZUy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZXh0cmFNZXRhW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoT2JqZWN0LmtleXMoZXh0cmFNZXRhKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIGN0eC5yZWdpc3RyeS5hZGQoYmFzZVNjaGVtYSwgZXh0cmFNZXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2VTY2hlbWE7XG59XG4vKipcbiAqIENvbnZlcnRzIGEgSlNPTiBTY2hlbWEgdG8gYSBab2Qgc2NoZW1hLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBiZSBjb25zaWRlcmVkIHNlbWktZXhwZXJpbWVudGFsLiBJdCdzIGJlaGF2aW9yIGlzIGxpYWJsZSB0byBjaGFuZ2UuICovXG5leHBvcnQgZnVuY3Rpb24gZnJvbUpTT05TY2hlbWEoc2NoZW1hLCBwYXJhbXMpIHtcbiAgICAvLyBIYW5kbGUgYm9vbGVhbiBzY2hlbWFzXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEgPyB6LmFueSgpIDogei5uZXZlcigpO1xuICAgIH1cbiAgICBjb25zdCB2ZXJzaW9uID0gZGV0ZWN0VmVyc2lvbihzY2hlbWEsIHBhcmFtcz8uZGVmYXVsdFRhcmdldCk7XG4gICAgY29uc3QgZGVmcyA9IChzY2hlbWEuJGRlZnMgfHwgc2NoZW1hLmRlZmluaXRpb25zIHx8IHt9KTtcbiAgICBjb25zdCBjdHggPSB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIGRlZnMsXG4gICAgICAgIHJlZnM6IG5ldyBNYXAoKSxcbiAgICAgICAgcHJvY2Vzc2luZzogbmV3IFNldCgpLFxuICAgICAgICByb290U2NoZW1hOiBzY2hlbWEsXG4gICAgICAgIHJlZ2lzdHJ5OiBwYXJhbXM/LnJlZ2lzdHJ5ID8/IGdsb2JhbFJlZ2lzdHJ5LFxuICAgIH07XG4gICAgcmV0dXJuIGNvbnZlcnRTY2hlbWEoc2NoZW1hLCBjdHgpO1xufVxuIiwgImV4cG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3NjaGVtYXMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL2NoZWNrcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vZXJyb3JzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY29tcGF0LmpzXCI7XG4vLyB6b2Qtc3BlY2lmaWVkXG5pbXBvcnQgeyBjb25maWcgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0IGVuIGZyb20gXCIuLi9sb2NhbGVzL2VuLmpzXCI7XG5jb25maWcoZW4oKSk7XG5leHBvcnQgeyBnbG9iYWxSZWdpc3RyeSwgcmVnaXN0cnksIGNvbmZpZywgJG91dHB1dCwgJGlucHV0LCAkYnJhbmQsIGNsb25lLCByZWdleGVzLCB0cmVlaWZ5RXJyb3IsIHByZXR0aWZ5RXJyb3IsIGZvcm1hdEVycm9yLCBmbGF0dGVuRXJyb3IsIFRpbWVQcmVjaXNpb24sIHV0aWwsIE5FVkVSLCB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5leHBvcnQgeyB0b0pTT05TY2hlbWEgfSBmcm9tIFwiLi4vY29yZS9qc29uLXNjaGVtYS1wcm9jZXNzb3JzLmpzXCI7XG5leHBvcnQgeyBmcm9tSlNPTlNjaGVtYSB9IGZyb20gXCIuL2Zyb20tanNvbi1zY2hlbWEuanNcIjtcbmV4cG9ydCAqIGFzIGxvY2FsZXMgZnJvbSBcIi4uL2xvY2FsZXMvaW5kZXguanNcIjtcbi8vIGlzb1xuLy8gbXVzdCBiZSBleHBvcnRlZCBmcm9tIHRvcC1sZXZlbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2lzc3Vlcy80NDkxXG5leHBvcnQgeyBab2RJU09EYXRlVGltZSwgWm9kSVNPRGF0ZSwgWm9kSVNPVGltZSwgWm9kSVNPRHVyYXRpb24gfSBmcm9tIFwiLi9pc28uanNcIjtcbmV4cG9ydCAqIGFzIGlzbyBmcm9tIFwiLi9pc28uanNcIjtcbmV4cG9ydCAqIGFzIGNvZXJjZSBmcm9tIFwiLi9jb2VyY2UuanNcIjtcbiIsIG51bGwsIG51bGwsICJleHBvcnQgY29uc3QgaWdub3JlT3ZlcnJpZGUgPSBTeW1ib2woXCJMZXQgem9kVG9Kc29uU2NoZW1hIGRlY2lkZSBvbiB3aGljaCBwYXJzZXIgdG8gdXNlXCIpO1xuZXhwb3J0IGNvbnN0IGpzb25EZXNjcmlwdGlvbiA9IChqc29uU2NoZW1hLCBkZWYpID0+IHtcbiAgICBpZiAoZGVmLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC4uLmpzb25TY2hlbWEsXG4gICAgICAgICAgICAgICAgLi4uSlNPTi5wYXJzZShkZWYuZGVzY3JpcHRpb24pLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7IH1cbiAgICB9XG4gICAgcmV0dXJuIGpzb25TY2hlbWE7XG59O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5hbWU6IHVuZGVmaW5lZCxcbiAgICAkcmVmU3RyYXRlZ3k6IFwicm9vdFwiLFxuICAgIGJhc2VQYXRoOiBbXCIjXCJdLFxuICAgIGVmZmVjdFN0cmF0ZWd5OiBcImlucHV0XCIsXG4gICAgcGlwZVN0cmF0ZWd5OiBcImFsbFwiLFxuICAgIGRhdGVTdHJhdGVneTogXCJmb3JtYXQ6ZGF0ZS10aW1lXCIsXG4gICAgbWFwU3RyYXRlZ3k6IFwiZW50cmllc1wiLFxuICAgIHJlbW92ZUFkZGl0aW9uYWxTdHJhdGVneTogXCJwYXNzdGhyb3VnaFwiLFxuICAgIGFsbG93ZWRBZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgICByZWplY3RlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZSxcbiAgICBkZWZpbml0aW9uUGF0aDogXCJkZWZpbml0aW9uc1wiLFxuICAgIHRhcmdldDogXCJqc29uU2NoZW1hN1wiLFxuICAgIHN0cmljdFVuaW9uczogZmFsc2UsXG4gICAgZGVmaW5pdGlvbnM6IHt9LFxuICAgIGVycm9yTWVzc2FnZXM6IGZhbHNlLFxuICAgIG1hcmtkb3duRGVzY3JpcHRpb246IGZhbHNlLFxuICAgIHBhdHRlcm5TdHJhdGVneTogXCJlc2NhcGVcIixcbiAgICBhcHBseVJlZ2V4RmxhZ3M6IGZhbHNlLFxuICAgIGVtYWlsU3RyYXRlZ3k6IFwiZm9ybWF0OmVtYWlsXCIsXG4gICAgYmFzZTY0U3RyYXRlZ3k6IFwiY29udGVudEVuY29kaW5nOmJhc2U2NFwiLFxuICAgIG5hbWVTdHJhdGVneTogXCJyZWZcIixcbiAgICBvcGVuQWlBbnlUeXBlTmFtZTogXCJPcGVuQWlBbnlUeXBlXCJcbn07XG5leHBvcnQgY29uc3QgZ2V0RGVmYXVsdE9wdGlvbnMgPSAob3B0aW9ucykgPT4gKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiXG4gICAgPyB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICBuYW1lOiBvcHRpb25zLFxuICAgIH1cbiAgICA6IHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4iLCAiaW1wb3J0IHsgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyB9IGZyb20gXCIuLi9lcnJvck1lc3NhZ2VzLmpzXCI7XG5sZXQgZW1vamlSZWdleCA9IHVuZGVmaW5lZDtcbi8qKlxuICogR2VuZXJhdGVkIGZyb20gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbnMgZm91bmQgaGVyZSBhcyBvZiAyMDI0LTA1LTIyOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2Jsb2IvbWFzdGVyL3NyYy90eXBlcy50cy5cbiAqXG4gKiBFeHByZXNzaW9ucyB3aXRoIC9pIGZsYWcgaGF2ZSBiZWVuIGNoYW5nZWQgYWNjb3JkaW5nbHkuXG4gKi9cbmV4cG9ydCBjb25zdCB6b2RQYXR0ZXJucyA9IHtcbiAgICAvKipcbiAgICAgKiBgY2Agd2FzIGNoYW5nZWQgdG8gYFtjQ11gIHRvIHJlcGxpY2F0ZSAvaSBmbGFnXG4gICAgICovXG4gICAgY3VpZDogL15bY0NdW15cXHMtXXs4LH0kLyxcbiAgICBjdWlkMjogL15bMC05YS16XSskLyxcbiAgICB1bGlkOiAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kLyxcbiAgICAvKipcbiAgICAgKiBgYS16YCB3YXMgYWRkZWQgdG8gcmVwbGljYXRlIC9pIGZsYWdcbiAgICAgKi9cbiAgICBlbWFpbDogL14oPyFcXC4pKD8hLipcXC5cXC4pKFthLXpBLVowLTlfJytcXC1cXC5dKilbYS16QS1aMC05XystXUAoW2EtekEtWjAtOV1bYS16QS1aMC05XFwtXSpcXC4pK1thLXpBLVpdezIsfSQvLFxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdGVkIGEgdmFsaWQgVW5pY29kZSBSZWdFeHBcbiAgICAgKlxuICAgICAqIExhemlseSBpbnN0YW50aWF0ZSBzaW5jZSB0aGlzIHR5cGUgb2YgcmVnZXggaXNuJ3Qgc3VwcG9ydGVkXG4gICAgICogaW4gYWxsIGVudnMgKGUuZy4gUmVhY3QgTmF0aXZlKS5cbiAgICAgKlxuICAgICAqIFNlZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvaXNzdWVzLzI0MzNcbiAgICAgKiBGaXggaW4gWm9kOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9jb21taXQvOTM0MGZkNTFlNDg1NzZhNzVhZGM5MTliZmY2NWRiYzRhNWQ0Yzk5YlxuICAgICAqL1xuICAgIGVtb2ppOiAoKSA9PiB7XG4gICAgICAgIGlmIChlbW9qaVJlZ2V4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVtb2ppUmVnZXggPSBSZWdFeHAoXCJeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJFwiLCBcInVcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVtb2ppUmVnZXg7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBVbnVzZWRcbiAgICAgKi9cbiAgICB1dWlkOiAvXlswLTlhLWZBLUZdezh9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezR9XFxiLVswLTlhLWZBLUZdezEyfSQvLFxuICAgIC8qKlxuICAgICAqIFVudXNlZFxuICAgICAqL1xuICAgIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC8sXG4gICAgaXB2NENpZHI6IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwvKDNbMC0yXXxbMTJdP1swLTldKSQvLFxuICAgIC8qKlxuICAgICAqIFVudXNlZFxuICAgICAqL1xuICAgIGlwdjY6IC9eKChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKSQvLFxuICAgIGlwdjZDaWRyOiAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvLFxuICAgIGJhc2U2NDogL14oWzAtOWEtekEtWisvXXs0fSkqKChbMC05YS16QS1aKy9dezJ9PT0pfChbMC05YS16QS1aKy9dezN9PSkpPyQvLFxuICAgIGJhc2U2NHVybDogL14oWzAtOWEtekEtWi1fXXs0fSkqKChbMC05YS16QS1aLV9dezJ9KD09KT8pfChbMC05YS16QS1aLV9dezN9KD0pPykpPyQvLFxuICAgIG5hbm9pZDogL15bYS16QS1aMC05Xy1dezIxfSQvLFxuICAgIGp3dDogL15bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXSokLyxcbn07XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VTdHJpbmdEZWYoZGVmLCByZWZzKSB7XG4gICAgY29uc3QgcmVzID0ge1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIH07XG4gICAgaWYgKGRlZi5jaGVja3MpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGVjayBvZiBkZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGNoZWNrLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibWluXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbkxlbmd0aFwiLCB0eXBlb2YgcmVzLm1pbkxlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1heChyZXMubWluTGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibWF4XCI6XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heExlbmd0aFwiLCB0eXBlb2YgcmVzLm1heExlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1pbihyZXMubWF4TGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW1haWxcIjpcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChyZWZzLmVtYWlsU3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6ZW1haWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1hdDppZG4tZW1haWxcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlkbi1lbWFpbFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5lbWFpbCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInVybFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInVyaVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInV1aWRcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJ1dWlkXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVnZXhcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIGNoZWNrLnJlZ2V4LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImN1aWRcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY3VpZDJcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmN1aWQyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0YXJ0c1dpdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIFJlZ0V4cChgXiR7ZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpfWApLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZHNXaXRoXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCBSZWdFeHAoYCR7ZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUoY2hlY2sudmFsdWUsIHJlZnMpfSRgKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRldGltZVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImRhdGUtdGltZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhdGVcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJkYXRlXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidGltZVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInRpbWVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJkdXJhdGlvblwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImR1cmF0aW9uXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwibGVuZ3RoXCI6XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1pbkxlbmd0aFwiLCB0eXBlb2YgcmVzLm1pbkxlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1heChyZXMubWluTGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJtYXhMZW5ndGhcIiwgdHlwZW9mIHJlcy5tYXhMZW5ndGggPT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocmVzLm1heExlbmd0aCwgY2hlY2sudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGNoZWNrLnZhbHVlLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImluY2x1ZGVzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIFJlZ0V4cChlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcykpLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJpcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaXB2NFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImlwdjZcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjR1cmxcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmJhc2U2NHVybCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJqd3RcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmp3dCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjaWRyXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmlwdjRDaWRyLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuaXB2NkNpZHIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZW1vamlcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmVtb2ppKCksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidWxpZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy51bGlkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJiYXNlNjRcIjoge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlZnMuYmFzZTY0U3RyYXRlZ3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmb3JtYXQ6YmluYXJ5XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImJpbmFyeVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjb250ZW50RW5jb2Rpbmc6YmFzZTY0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHJlcywgXCJjb250ZW50RW5jb2RpbmdcIiwgXCJiYXNlNjRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwicGF0dGVybjp6b2RcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5iYXNlNjQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibmFub2lkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLm5hbm9pZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b0xvd2VyQ2FzZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b1VwcGVyQ2FzZVwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0cmltXCI6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICgoXykgPT4geyB9KShjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGVzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGxpdGVyYWwsIHJlZnMpIHtcbiAgICByZXR1cm4gcmVmcy5wYXR0ZXJuU3RyYXRlZ3kgPT09IFwiZXNjYXBlXCJcbiAgICAgICAgPyBlc2NhcGVOb25BbHBoYU51bWVyaWMobGl0ZXJhbClcbiAgICAgICAgOiBsaXRlcmFsO1xufVxuY29uc3QgQUxQSEFfTlVNRVJJQyA9IG5ldyBTZXQoXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnh5ejAxMjM0NTY3ODlcIik7XG5mdW5jdGlvbiBlc2NhcGVOb25BbHBoYU51bWVyaWMoc291cmNlKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFBTFBIQV9OVU1FUklDLmhhcyhzb3VyY2VbaV0pKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gXCJcXFxcXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHNvdXJjZVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8vIEFkZHMgYSBcImZvcm1hdFwiIGtleXdvcmQgdG8gdGhlIHNjaGVtYS4gSWYgYSBmb3JtYXQgZXhpc3RzLCBib3RoIGZvcm1hdHMgd2lsbCBiZSBqb2luZWQgaW4gYW4gYWxsT2Ytbm9kZSwgYWxvbmcgd2l0aCBzdWJzZXF1ZW50IG9uZXMuXG5mdW5jdGlvbiBhZGRGb3JtYXQoc2NoZW1hLCB2YWx1ZSwgbWVzc2FnZSwgcmVmcykge1xuICAgIGlmIChzY2hlbWEuZm9ybWF0IHx8IHNjaGVtYS5hbnlPZj8uc29tZSgoeCkgPT4geC5mb3JtYXQpKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmFueU9mKSB7XG4gICAgICAgICAgICBzY2hlbWEuYW55T2YgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLmZvcm1hdCkge1xuICAgICAgICAgICAgc2NoZW1hLmFueU9mLnB1c2goe1xuICAgICAgICAgICAgICAgIGZvcm1hdDogc2NoZW1hLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAuLi4oc2NoZW1hLmVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHsgZm9ybWF0OiBzY2hlbWEuZXJyb3JNZXNzYWdlLmZvcm1hdCB9LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkZWxldGUgc2NoZW1hLmZvcm1hdDtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2UuZm9ybWF0O1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZXJyb3JNZXNzYWdlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS5hbnlPZi5wdXNoKHtcbiAgICAgICAgICAgIGZvcm1hdDogdmFsdWUsXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7IGVycm9yTWVzc2FnZTogeyBmb3JtYXQ6IG1lc3NhZ2UgfSB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzKHNjaGVtYSwgXCJmb3JtYXRcIiwgdmFsdWUsIG1lc3NhZ2UsIHJlZnMpO1xuICAgIH1cbn1cbi8vIEFkZHMgYSBcInBhdHRlcm5cIiBrZXl3b3JkIHRvIHRoZSBzY2hlbWEuIElmIGEgcGF0dGVybiBleGlzdHMsIGJvdGggcGF0dGVybnMgd2lsbCBiZSBqb2luZWQgaW4gYW4gYWxsT2Ytbm9kZSwgYWxvbmcgd2l0aCBzdWJzZXF1ZW50IG9uZXMuXG5mdW5jdGlvbiBhZGRQYXR0ZXJuKHNjaGVtYSwgcmVnZXgsIG1lc3NhZ2UsIHJlZnMpIHtcbiAgICBpZiAoc2NoZW1hLnBhdHRlcm4gfHwgc2NoZW1hLmFsbE9mPy5zb21lKCh4KSA9PiB4LnBhdHRlcm4pKSB7XG4gICAgICAgIGlmICghc2NoZW1hLmFsbE9mKSB7XG4gICAgICAgICAgICBzY2hlbWEuYWxsT2YgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NoZW1hLnBhdHRlcm4pIHtcbiAgICAgICAgICAgIHNjaGVtYS5hbGxPZi5wdXNoKHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBzY2hlbWEucGF0dGVybixcbiAgICAgICAgICAgICAgICAuLi4oc2NoZW1hLmVycm9yTWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYge1xuICAgICAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2U6IHsgcGF0dGVybjogc2NoZW1hLmVycm9yTWVzc2FnZS5wYXR0ZXJuIH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEucGF0dGVybjtcbiAgICAgICAgICAgIGlmIChzY2hlbWEuZXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2UucGF0dGVybjtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2NoZW1hLmVycm9yTWVzc2FnZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZXJyb3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlbWEuYWxsT2YucHVzaCh7XG4gICAgICAgICAgICBwYXR0ZXJuOiBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpLFxuICAgICAgICAgICAgLi4uKG1lc3NhZ2UgJiZcbiAgICAgICAgICAgICAgICByZWZzLmVycm9yTWVzc2FnZXMgJiYgeyBlcnJvck1lc3NhZ2U6IHsgcGF0dGVybjogbWVzc2FnZSB9IH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMoc2NoZW1hLCBcInBhdHRlcm5cIiwgc3RyaW5naWZ5UmVnRXhwV2l0aEZsYWdzKHJlZ2V4LCByZWZzKSwgbWVzc2FnZSwgcmVmcyk7XG4gICAgfVxufVxuLy8gTXV0YXRlIHouc3RyaW5nLnJlZ2V4KCkgaW4gYSBiZXN0IGF0dGVtcHQgdG8gYWNjb21tb2RhdGUgZm9yIHJlZ2V4IGZsYWdzIHdoZW4gYXBwbHlSZWdleEZsYWdzIGlzIHRydWVcbmZ1bmN0aW9uIHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcykge1xuICAgIGlmICghcmVmcy5hcHBseVJlZ2V4RmxhZ3MgfHwgIXJlZ2V4LmZsYWdzKSB7XG4gICAgICAgIHJldHVybiByZWdleC5zb3VyY2U7XG4gICAgfVxuICAgIC8vIEN1cnJlbnRseSBoYW5kbGVkIGZsYWdzXG4gICAgY29uc3QgZmxhZ3MgPSB7XG4gICAgICAgIGk6IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwiaVwiKSxcbiAgICAgICAgbTogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJtXCIpLFxuICAgICAgICBzOiByZWdleC5mbGFncy5pbmNsdWRlcyhcInNcIiksIC8vIGAuYCBtYXRjaGVzIG5ld2xpbmVzXG4gICAgfTtcbiAgICAvLyBUaGUgZ2VuZXJhbCBwcmluY2lwbGUgaGVyZSBpcyB0byBzdGVwIHRocm91Z2ggZWFjaCBjaGFyYWN0ZXIsIG9uZSBhdCBhIHRpbWUsIGFwcGx5aW5nIG11dGF0aW9ucyBhcyBmbGFncyByZXF1aXJlLiBXZSBrZWVwIHRyYWNrIHdoZW4gdGhlIGN1cnJlbnQgY2hhcmFjdGVyIGlzIGVzY2FwZWQsIGFuZCB3aGVuIGl0J3MgaW5zaWRlIGEgZ3JvdXAgL2xpa2UgW3RoaXNdLyBvciAoYWxzbykgYSByYW5nZSBsaWtlIC9bYS16XS8uIFRoZSBmb2xsb3dpbmcgaXMgZmFpcmx5IGJyaXR0bGUgaW1wZXJhdGl2ZSBjb2RlOyBlZGl0IGF0IHlvdXIgcGVyaWwhXG4gICAgY29uc3Qgc291cmNlID0gZmxhZ3MuaSA/IHJlZ2V4LnNvdXJjZS50b0xvd2VyQ2FzZSgpIDogcmVnZXguc291cmNlO1xuICAgIGxldCBwYXR0ZXJuID0gXCJcIjtcbiAgICBsZXQgaXNFc2NhcGVkID0gZmFsc2U7XG4gICAgbGV0IGluQ2hhckdyb3VwID0gZmFsc2U7XG4gICAgbGV0IGluQ2hhclJhbmdlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzRXNjYXBlZCkge1xuICAgICAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgICAgICBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncy5pKSB7XG4gICAgICAgICAgICBpZiAoaW5DaGFyR3JvdXApIHtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlW2ldLm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbkNoYXJSYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAke3NvdXJjZVtpIC0gMl19LSR7c291cmNlW2ldfWAudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluQ2hhclJhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlW2kgKyAxXSA9PT0gXCItXCIgJiYgc291cmNlW2kgKyAyXT8ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gc291cmNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5DaGFyUmFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBgJHtzb3VyY2VbaV19JHtzb3VyY2VbaV0udG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVtpXS5tYXRjaCgvW2Etel0vKSkge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYFske3NvdXJjZVtpXX0ke3NvdXJjZVtpXS50b1VwcGVyQ2FzZSgpfV1gO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncy5tKSB7XG4gICAgICAgICAgICBpZiAoc291cmNlW2ldID09PSBcIl5cIikge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYChefCg/PD1bXFxyXFxuXSkpYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNvdXJjZVtpXSA9PT0gXCIkXCIpIHtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAoJHwoPz1bXFxyXFxuXSkpYDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmxhZ3MucyAmJiBzb3VyY2VbaV0gPT09IFwiLlwiKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IGluQ2hhckdyb3VwID8gYCR7c291cmNlW2ldfVxcclxcbmAgOiBgWyR7c291cmNlW2ldfVxcclxcbl1gO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgIGlmIChzb3VyY2VbaV0gPT09IFwiXFxcXFwiKSB7XG4gICAgICAgICAgICBpc0VzY2FwZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGluQ2hhckdyb3VwICYmIHNvdXJjZVtpXSA9PT0gXCJdXCIpIHtcbiAgICAgICAgICAgIGluQ2hhckdyb3VwID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluQ2hhckdyb3VwICYmIHNvdXJjZVtpXSA9PT0gXCJbXCIpIHtcbiAgICAgICAgICAgIGluQ2hhckdyb3VwID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBuZXcgUmVnRXhwKHBhdHRlcm4pO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGNvbnZlcnQgcmVnZXggcGF0dGVybiBhdCAke3JlZnMuY3VycmVudFBhdGguam9pbihcIi9cIil9IHRvIGEgZmxhZy1pbmRlcGVuZGVudCBmb3JtISBGYWxsaW5nIGJhY2sgdG8gdGhlIGZsYWctaWdub3JhbnQgc291cmNlYCk7XG4gICAgICAgIHJldHVybiByZWdleC5zb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBwYXR0ZXJuO1xufVxuIiwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgIi8qKlxuICogU1BBUlFMIENsaWVudCBmb3IgTElOREFTL0ZlZGxleCBFbmRwb2ludFxuICogUHJvdmlkZXMgSFRUUCBhY2Nlc3MgdG8gdGhlIFN3aXNzIEZlZGVyYWwgTGlua2VkIERhdGEgU2VydmljZVxuICpcbiAqIEVuZHBvaW50OiBodHRwczovL2xkLmFkbWluLmNoL3F1ZXJ5XG4gKiBEb2N1bWVudGF0aW9uOiBodHRwczovL2xpbmRhcy5hZG1pbi5jaC9cbiAqL1xuXG5pbXBvcnQgeyBTUEFSUUxSZXN1bHQsIFNQQVJRTEJpbmRpbmcsIEZlZGxleEVycm9yIH0gZnJvbSAnLi90eXBlcy9sZWdpc2xhdGlvbi5qcyc7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBmb3IgdGhlIFNQQVJRTCBjbGllbnRcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTUEFSUUxDbGllbnRDb25maWcge1xuICBlbmRwb2ludDogc3RyaW5nO1xuICB0aW1lb3V0OiBudW1iZXI7XG4gIG1heFJldHJpZXM6IG51bWJlcjtcbiAgcmV0cnlEZWxheTogbnVtYmVyO1xuICB1c2VyQWdlbnQ6IHN0cmluZztcbn1cblxuLyoqXG4gKiBEZWZhdWx0IGNvbmZpZ3VyYXRpb25cbiAqL1xuZXhwb3J0IGNvbnN0IERFRkFVTFRfQ09ORklHOiBTUEFSUUxDbGllbnRDb25maWcgPSB7XG4gIGVuZHBvaW50OiAnaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9zcGFycWxlbmRwb2ludCcsICAvLyBDb3JyZWN0IEZlZGxleCBTUEFSUUwgZW5kcG9pbnRcbiAgdGltZW91dDogMzAwMDAsICAgICAgICAvLyAzMCBzZWNvbmRzXG4gIG1heFJldHJpZXM6IDMsXG4gIHJldHJ5RGVsYXk6IDEwMDAsICAgICAgLy8gMSBzZWNvbmRcbiAgdXNlckFnZW50OiAnQmV0dGVyQ2FsbENsYXVkZS8yLjAuMSAoU3dpc3MgTGVnYWwgSW50ZWxsaWdlbmNlKScsXG59O1xuXG4vKipcbiAqIFNQQVJRTCBxdWVyeSBleGVjdXRpb24gb3B0aW9uc1xuICovXG5leHBvcnQgaW50ZXJmYWNlIFF1ZXJ5T3B0aW9ucyB7XG4gIGZvcm1hdD86ICdqc29uJyB8ICd4bWwnO1xuICB0aW1lb3V0PzogbnVtYmVyO1xuICBhY2NlcHRMYW5ndWFnZT86IHN0cmluZztcbn1cblxuLyoqXG4gKiBTUEFSUUwgQ2xpZW50IGZvciBxdWVyeWluZyBMSU5EQVMvRmVkbGV4XG4gKi9cbmV4cG9ydCBjbGFzcyBTUEFSUUxDbGllbnQge1xuICBwcml2YXRlIGNvbmZpZzogU1BBUlFMQ2xpZW50Q29uZmlnO1xuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZzogUGFydGlhbDxTUEFSUUxDbGllbnRDb25maWc+ID0ge30pIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4uREVGQVVMVF9DT05GSUcsIC4uLmNvbmZpZyB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGUgYSBTUEFSUUwgU0VMRUNUIHF1ZXJ5XG4gICAqL1xuICBhc3luYyBxdWVyeShzcGFycWw6IHN0cmluZywgb3B0aW9uczogUXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPFNQQVJRTFJlc3VsdD4ge1xuICAgIGNvbnN0IHsgZm9ybWF0ID0gJ2pzb24nLCB0aW1lb3V0ID0gdGhpcy5jb25maWcudGltZW91dCwgYWNjZXB0TGFuZ3VhZ2UgfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge1xuICAgICAgJ0FjY2VwdCc6IGZvcm1hdCA9PT0gJ2pzb24nID8gJ2FwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK2pzb24nIDogJ2FwcGxpY2F0aW9uL3NwYXJxbC1yZXN1bHRzK3htbCcsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAnVXNlci1BZ2VudCc6IHRoaXMuY29uZmlnLnVzZXJBZ2VudCxcbiAgICB9O1xuXG4gICAgaWYgKGFjY2VwdExhbmd1YWdlKSB7XG4gICAgICBoZWFkZXJzWydBY2NlcHQtTGFuZ3VhZ2UnXSA9IGFjY2VwdExhbmd1YWdlO1xuICAgIH1cblxuICAgIGNvbnN0IGJvZHkgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgIHF1ZXJ5OiBzcGFycWwsXG4gICAgfSk7XG5cbiAgICBsZXQgbGFzdEVycm9yOiBFcnJvciB8IG51bGwgPSBudWxsO1xuXG4gICAgZm9yIChsZXQgYXR0ZW1wdCA9IDA7IGF0dGVtcHQgPCB0aGlzLmNvbmZpZy5tYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aW1lb3V0KTtcblxuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuY29uZmlnLmVuZHBvaW50LCB7XG4gICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgaGVhZGVycyxcbiAgICAgICAgICBib2R5OiBib2R5LnRvU3RyaW5nKCksXG4gICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG5cbiAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFNQQVJRTCBxdWVyeSBmYWlsZWQ6ICR7cmVzcG9uc2Uuc3RhdHVzfSAke3Jlc3BvbnNlLnN0YXR1c1RleHR9IC0gJHtlcnJvclRleHR9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZXNwb25zZS5qc29uKCkgYXMgU1BBUlFMUmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBsYXN0RXJyb3IgPSBlcnJvciBhcyBFcnJvcjtcblxuICAgICAgICAvLyBEb24ndCByZXRyeSBvbiBjbGllbnQgZXJyb3JzICg0eHgpXG4gICAgICAgIGlmIChsYXN0RXJyb3IubWVzc2FnZS5pbmNsdWRlcygnNCcpKSB7XG4gICAgICAgICAgdGhyb3cgdGhpcy5jcmVhdGVGZWRsZXhFcnJvcihsYXN0RXJyb3IsIHNwYXJxbCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBXYWl0IGJlZm9yZSByZXRyeWluZ1xuICAgICAgICBpZiAoYXR0ZW1wdCA8IHRoaXMuY29uZmlnLm1heFJldHJpZXMgLSAxKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy5kZWxheSh0aGlzLmNvbmZpZy5yZXRyeURlbGF5ICogKGF0dGVtcHQgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyB0aGlzLmNyZWF0ZUZlZGxleEVycm9yKGxhc3RFcnJvciEsIHNwYXJxbCk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZSBhIFNQQVJRTCBBU0sgcXVlcnlcbiAgICovXG4gIGFzeW5jIGFzayhzcGFycWw6IHN0cmluZywgb3B0aW9uczogUXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLnF1ZXJ5KHNwYXJxbCwgb3B0aW9ucyk7XG4gICAgLy8gQVNLIHF1ZXJpZXMgcmV0dXJuIGEgYm9vbGVhbiBpbiB0aGUgcmVzdWx0XG4gICAgcmV0dXJuIChyZXN1bHQgYXMgdW5rbm93biBhcyB7IGJvb2xlYW46IGJvb2xlYW4gfSkuYm9vbGVhbiA/PyBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGEgU1BBUlFMIERFU0NSSUJFIHF1ZXJ5XG4gICAqL1xuICBhc3luYyBkZXNjcmliZShzcGFycWw6IHN0cmluZywgb3B0aW9uczogUXVlcnlPcHRpb25zID0ge30pOiBQcm9taXNlPFNQQVJRTFJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnF1ZXJ5KHNwYXJxbCwgeyAuLi5vcHRpb25zLCBmb3JtYXQ6ICdqc29uJyB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBhIHNpbmdsZSB2YWx1ZSBmcm9tIGJpbmRpbmdzXG4gICAqL1xuICBleHRyYWN0VmFsdWUoYmluZGluZzogU1BBUlFMQmluZGluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIGJpbmRpbmc/LnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciB0byBleHRyYWN0IGEgbG9jYWxpemVkIHZhbHVlIGJhc2VkIG9uIGxhbmd1YWdlIHByZWZlcmVuY2VcbiAgICovXG4gIGV4dHJhY3RMb2NhbGl6ZWRWYWx1ZShcbiAgICBiaW5kaW5nczogQXJyYXk8UmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4+LFxuICAgIHZhcmlhYmxlTmFtZTogc3RyaW5nLFxuICAgIHByZWZlcnJlZExhbmc6IHN0cmluZyA9ICdkZSdcbiAgKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgICAvLyBGaXJzdCB0cnkgdG8gZmluZCBleGFjdCBsYW5ndWFnZSBtYXRjaFxuICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBiaW5kaW5ncykge1xuICAgICAgY29uc3QgdmFsdWUgPSBiaW5kaW5nW3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJ3htbDpsYW5nJ10gPT09IHByZWZlcnJlZExhbmcpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byBhbnkgYXZhaWxhYmxlIHZhbHVlXG4gICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIGJpbmRpbmdzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGJpbmRpbmdbdmFyaWFibGVOYW1lXTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUudmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZXh0cmFjdCBtdWx0aWxpbmd1YWwgdmFsdWVzXG4gICAqL1xuICBleHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUoXG4gICAgYmluZGluZ3M6IEFycmF5PFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+PixcbiAgICB2YXJpYWJsZU5hbWU6IHN0cmluZ1xuICApOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBiaW5kaW5ncykge1xuICAgICAgY29uc3QgdmFsdWUgPSBiaW5kaW5nW3ZhcmlhYmxlTmFtZV07XG4gICAgICBpZiAodmFsdWUgJiYgdmFsdWVbJ3htbDpsYW5nJ10pIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlWyd4bWw6bGFuZyddXSA9IHZhbHVlLnZhbHVlO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSAmJiAhT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGgpIHtcbiAgICAgICAgLy8gVXNlIHZhbHVlIHdpdGhvdXQgbGFuZ3VhZ2UgdGFnIGlmIG5vIGxvY2FsaXplZCB2YWx1ZXMgZm91bmRcbiAgICAgICAgcmVzdWx0WydkZSddID0gdmFsdWUudmFsdWU7IC8vIERlZmF1bHQgdG8gR2VybWFuXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgdG8gZ3JvdXAgYmluZGluZ3MgYnkgYSBrZXkgdmFyaWFibGVcbiAgICovXG4gIGdyb3VwQmluZGluZ3MoXG4gICAgYmluZGluZ3M6IEFycmF5PFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+PixcbiAgICBrZXlWYXJpYWJsZTogc3RyaW5nXG4gICk6IE1hcDxzdHJpbmcsIEFycmF5PFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+Pj4ge1xuICAgIGNvbnN0IGdyb3VwcyA9IG5ldyBNYXA8c3RyaW5nLCBBcnJheTxSZWNvcmQ8c3RyaW5nLCBTUEFSUUxCaW5kaW5nPj4+KCk7XG5cbiAgICBmb3IgKGNvbnN0IGJpbmRpbmcgb2YgYmluZGluZ3MpIHtcbiAgICAgIGNvbnN0IGtleSA9IHRoaXMuZXh0cmFjdFZhbHVlKGJpbmRpbmdba2V5VmFyaWFibGVdKTtcbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgY29uc3QgZ3JvdXAgPSBncm91cHMuZ2V0KGtleSkgfHwgW107XG4gICAgICAgIGdyb3VwLnB1c2goYmluZGluZyk7XG4gICAgICAgIGdyb3Vwcy5zZXQoa2V5LCBncm91cCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyb3VwcztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIFNQQVJRTCBxdWVyeSBzeW50YXggKGJhc2ljIGNoZWNrKVxuICAgKi9cbiAgdmFsaWRhdGVRdWVyeShzcGFycWw6IHN0cmluZyk6IHsgdmFsaWQ6IGJvb2xlYW47IGVycm9yPzogc3RyaW5nIH0ge1xuICAgIC8vIEJhc2ljIHN5bnRheCBjaGVja3NcbiAgICBjb25zdCB0cmltbWVkID0gc3BhcnFsLnRyaW0oKS50b1VwcGVyQ2FzZSgpO1xuXG4gICAgaWYgKCF0cmltbWVkLnN0YXJ0c1dpdGgoJ1NFTEVDVCcpICYmXG4gICAgICAgICF0cmltbWVkLnN0YXJ0c1dpdGgoJ0FTSycpICYmXG4gICAgICAgICF0cmltbWVkLnN0YXJ0c1dpdGgoJ0RFU0NSSUJFJykgJiZcbiAgICAgICAgIXRyaW1tZWQuc3RhcnRzV2l0aCgnQ09OU1RSVUNUJykgJiZcbiAgICAgICAgIXRyaW1tZWQuc3RhcnRzV2l0aCgnUFJFRklYJykpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdRdWVyeSBtdXN0IHN0YXJ0IHdpdGggU0VMRUNULCBBU0ssIERFU0NSSUJFLCBDT05TVFJVQ1QsIG9yIFBSRUZJWCcgfTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgYmFsYW5jZWQgYnJhY2VzXG4gICAgY29uc3Qgb3BlbkJyYWNlcyA9IChzcGFycWwubWF0Y2goL3svZykgfHwgW10pLmxlbmd0aDtcbiAgICBjb25zdCBjbG9zZUJyYWNlcyA9IChzcGFycWwubWF0Y2goL30vZykgfHwgW10pLmxlbmd0aDtcbiAgICBpZiAob3BlbkJyYWNlcyAhPT0gY2xvc2VCcmFjZXMpIHtcbiAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSwgZXJyb3I6ICdVbmJhbGFuY2VkIGJyYWNlcyBpbiBxdWVyeScgfTtcbiAgICB9XG5cbiAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIEZlZGxleEVycm9yIGZyb20gYW4gRXJyb3JcbiAgICovXG4gIHByaXZhdGUgY3JlYXRlRmVkbGV4RXJyb3IoZXJyb3I6IEVycm9yLCBxdWVyeT86IHN0cmluZyk6IEZlZGxleEVycm9yIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29kZTogJ1NQQVJRTF9FUlJPUicsXG4gICAgICBtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuICAgICAgcXVlcnksXG4gICAgICBlbmRwb2ludDogdGhpcy5jb25maWcuZW5kcG9pbnQsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxheSBoZWxwZXIgZm9yIHJldHJ5IGxvZ2ljXG4gICAqL1xuICBwcml2YXRlIGRlbGF5KG1zOiBudW1iZXIpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBjb25maWd1cmVkIGVuZHBvaW50IFVSTFxuICAgKi9cbiAgZ2V0RW5kcG9pbnQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5jb25maWcuZW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGNsaWVudCBjb25maWd1cmF0aW9uXG4gICAqL1xuICB1cGRhdGVDb25maWcoY29uZmlnOiBQYXJ0aWFsPFNQQVJRTENsaWVudENvbmZpZz4pOiB2b2lkIHtcbiAgICB0aGlzLmNvbmZpZyA9IHsgLi4udGhpcy5jb25maWcsIC4uLmNvbmZpZyB9O1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcHJlLWNvbmZpZ3VyZWQgU1BBUlFMIGNsaWVudCBmb3IgRmVkbGV4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVGZWRsZXhDbGllbnQoY29uZmlnPzogUGFydGlhbDxTUEFSUUxDbGllbnRDb25maWc+KTogU1BBUlFMQ2xpZW50IHtcbiAgcmV0dXJuIG5ldyBTUEFSUUxDbGllbnQoe1xuICAgIC4uLkRFRkFVTFRfQ09ORklHLFxuICAgIC4uLmNvbmZpZyxcbiAgfSk7XG59XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBmb3IgU1BBUlFMIHN0cmluZyBsaXRlcmFsc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlRm9yU1BBUlFMKHZhbHVlOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdmFsdWVcbiAgICAucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnXFxcXFwiJylcbiAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpXG4gICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKVxuICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0Jyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBGSUxURVIgY2xhdXNlIGZvciB0ZXh0IHNlYXJjaFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRUZXh0RmlsdGVyKHZhcmlhYmxlOiBzdHJpbmcsIHNlYXJjaFRleHQ6IHN0cmluZywgbGFuZ3VhZ2U/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBlc2NhcGVkID0gZXNjYXBlRm9yU1BBUlFMKHNlYXJjaFRleHQpO1xuXG4gIGlmIChsYW5ndWFnZSkge1xuICAgIHJldHVybiBgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/JHt2YXJpYWJsZX0pKSwgTENBU0UoXCIke2VzY2FwZWR9XCIpKSAmJiBMQU5HKD8ke3ZhcmlhYmxlfSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYDtcbiAgfVxuXG4gIHJldHVybiBgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/JHt2YXJpYWJsZX0pKSwgTENBU0UoXCIke2VzY2FwZWR9XCIpKSlgO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgRklMVEVSIGNsYXVzZSBmb3IgU1IgbnVtYmVyIHBhdHRlcm4gbWF0Y2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU1JOdW1iZXJGaWx0ZXIodmFyaWFibGU6IHN0cmluZywgc3JOdW1iZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFNSIG51bWJlcnMgY2FuIGJlIHBhcnRpYWwgKGUuZy4sIFwiMlwiIG1hdGNoZXMgXCIyMTBcIiwgXCIyMjBcIiwgZXRjLilcbiAgY29uc3QgZXNjYXBlZCA9IGVzY2FwZUZvclNQQVJRTChzck51bWJlcik7XG4gIHJldHVybiBgRklMVEVSKFNUUlNUQVJUUyhTVFIoPyR7dmFyaWFibGV9KSwgXCIke2VzY2FwZWR9XCIpKWA7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUHJlZml4ZXMgZm9yIEZlZGxleCBRdWVyaWVzXG4gKiBDb21tb24gbmFtZXNwYWNlIHByZWZpeGVzIHVzZWQgaW4gdGhlIEZlZGxleCBTUEFSUUwgZW5kcG9pbnRcbiAqXG4gKiBOT1RFOiBGZWRsZXggdXNlcyB0aGUgSk9MVVggb250b2xvZ3kgKEZSQlItbGlrZSBtb2RlbCksIG5vdCBFTElcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiBlbnRpdHlcbiAqIC0gam9sdXg6RXhwcmVzc2lvbiA9IExhbmd1YWdlLXNwZWNpZmljIHZlcnNpb24gKHRpdGxlcyBoZXJlLCBOTyBsYW5ndWFnZSB0YWdzKVxuICogLSBqb2x1eDpNYW5pZmVzdGF0aW9uID0gUGh5c2ljYWwgZm9ybWF0IChQREYsIFhNTCwgZXRjLilcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqL1xuXG4vKipcbiAqIFN0YW5kYXJkIFJERiBwcmVmaXhlc1xuICovXG5leHBvcnQgY29uc3QgUkRGX1BSRUZJWEVTID0gYFxuUFJFRklYIHJkZjogPGh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyM+XG5QUkVGSVggcmRmczogPGh0dHA6Ly93d3cudzMub3JnLzIwMDAvMDEvcmRmLXNjaGVtYSM+XG5QUkVGSVggeHNkOiA8aHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjPlxuUFJFRklYIG93bDogPGh0dHA6Ly93d3cudzMub3JnLzIwMDIvMDcvb3dsIz5cblBSRUZJWCBza29zOiA8aHR0cDovL3d3dy53My5vcmcvMjAwNC8wMi9za29zL2NvcmUjPlxuUFJFRklYIGRjdGVybXM6IDxodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvPlxuUFJFRklYIGRjYXQ6IDxodHRwOi8vd3d3LnczLm9yZy9ucy9kY2F0Iz5cbmA7XG5cbi8qKlxuICogRmVkbGV4LXNwZWNpZmljIHByZWZpeGVzXG4gKiAtIGpvbHV4OiBQcmltYXJ5IG9udG9sb2d5IHVzZWQgYnkgRmVkbGV4IChGUkJSIG1vZGVsKVxuICogLSBlbGk6IEV1cm9wZWFuIExlZ2lzbGF0aW9uIElkZW50aWZpZXIgKGxpbWl0ZWQgdXNlIGluIEZlZGxleClcbiAqL1xuZXhwb3J0IGNvbnN0IEZFRExFWF9QUkVGSVhFUyA9IGBcblBSRUZJWCBlbGk6IDxodHRwOi8vZGF0YS5ldXJvcGEuZXUvZWxpL29udG9sb2d5Iz5cblBSRUZJWCBqb2x1eDogPGh0dHA6Ly9kYXRhLmxlZ2lsdXgucHVibGljLmx1L3Jlc291cmNlL29udG9sb2d5L2pvbHV4Iz5cblBSRUZJWCBmZWRsZXg6IDxodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL3ZvY2FidWxhcnkvPlxuUFJFRklYIGZlZGxleC1lbGk6IDxodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS8+XG5QUkVGSVggZmVkbGV4LWNjOiA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9lbGkvY2MvPlxuUFJFRklYIHNjaGVtYTogPGh0dHA6Ly9zY2hlbWEub3JnLz5cbmA7XG5cbi8qKlxuICogTElOREFTLXNwZWNpZmljIHByZWZpeGVzIChsZWdhY3ksIGtlcHQgZm9yIGNvbXBhdGliaWxpdHkpXG4gKi9cbmV4cG9ydCBjb25zdCBMSU5EQVNfUFJFRklYRVMgPSBgXG5QUkVGSVggbGQ6IDxodHRwczovL2xkLmFkbWluLmNoLz5cblBSRUZJWCBjdWJlOiA8aHR0cHM6Ly9jdWJlLmxpbmsvPlxuUFJFRklYIHF1ZHQ6IDxodHRwOi8vcXVkdC5vcmcvc2NoZW1hL3F1ZHQvPlxuYDtcblxuLyoqXG4gKiBBbGwgcHJlZml4ZXMgY29tYmluZWQgZm9yIHVzZSBpbiBxdWVyaWVzXG4gKi9cbmV4cG9ydCBjb25zdCBBTExfUFJFRklYRVMgPSBgJHtSREZfUFJFRklYRVN9JHtGRURMRVhfUFJFRklYRVN9JHtMSU5EQVNfUFJFRklYRVN9YDtcblxuLyoqXG4gKiBDcmVhdGUgYSBxdWVyeSB3aXRoIHN0YW5kYXJkIHByZWZpeGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3aXRoUHJlZml4ZXMocXVlcnk6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBgJHtBTExfUFJFRklYRVN9XFxuJHtxdWVyeX1gO1xufVxuXG4vKipcbiAqIEZlZGxleCBFTEkgYmFzZSBVUklzXG4gKi9cbmV4cG9ydCBjb25zdCBGRURMRVhfQkFTRSA9IHtcbiAgQ0M6ICdodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS9jYy8nLCAgICAgICAgICAvLyBDbGFzc2lmaWVkIGNvbXBpbGF0aW9uXG4gIE9DOiAnaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9lbGkvb2MvJywgICAgICAgICAgLy8gT2ZmaWNpYWwgY29sbGVjdGlvblxuICBGR0E6ICdodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS9mZ2EvJywgICAgICAgIC8vIEZlZGVyYWwgR2F6ZXR0ZVxuICBUUkVBVFk6ICdodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL2VsaS90cmVhdHkvJywgIC8vIEludGVybmF0aW9uYWwgdHJlYXRpZXNcbn0gYXMgY29uc3Q7XG5cbi8qKlxuICogQnVpbGQgYSBGZWRsZXggVVJJIGZyb20gU1IgbnVtYmVyXG4gKiBTUiBudW1iZXJzIGxpa2UgXCIyMTBcIiBiZWNvbWUgVVJJcyBsaWtlIFwiaHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC9lbGkvY2MvMjQvMjMzXzI0NV8yMzNcIlxuICogTm90ZTogVGhlIGFjdHVhbCBtYXBwaW5nIHJlcXVpcmVzIGxvb2tpbmcgdXAgdGhlIG9mZmljaWFsIFVSSVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGZWRsZXhTZWFyY2hVUkkoc3JOdW1iZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIC8vIFNSIG51bWJlciBpcyB1c2VkIGZvciBzZWFyY2hpbmcsIG5vdCBkaXJlY3QgVVJJIGNvbnN0cnVjdGlvblxuICAvLyBUaGUgYWN0dWFsIG1hcHBpbmcgZnJvbSBTUiB0byBFTEkgVVJJIGlzIGRvbmUgdmlhIFNQQVJRTCBxdWVyeVxuICByZXR1cm4gc3JOdW1iZXI7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUXVlcmllcyBmb3IgU3RhdHV0ZSBMb29rdXBcbiAqIFF1ZXJpZXMgdG8gcmV0cmlldmUgbGVnYWwgYWN0cyBieSBTUiBudW1iZXIgdXNpbmcgSk9MVVggb250b2xvZ3lcbiAqXG4gKiBGZWRsZXggRGF0YSBNb2RlbCAoRlJCUi1iYXNlZCk6XG4gKiAtIGpvbHV4OkFjdCA9IFByaW1hcnkgbGVnaXNsYXRpb24gd29ya1xuICogLSBqb2x1eDpFeHByZXNzaW9uID0gTGFuZ3VhZ2Utc3BlY2lmaWMgcmVhbGl6YXRpb24gKHZpYSBqb2x1eDppc1JlYWxpemVkQnkpXG4gKiAtIGpvbHV4Ok1hbmlmZXN0YXRpb24gPSBQaHlzaWNhbCBmb3JtYXQgKHZpYSBqb2x1eDppc0VtYm9kaWVkQnkpXG4gKiAtIFNSIG51bWJlcnMgdmlhIHRheG9ub215OiBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5IFx1MjE5MiBza29zOm5vdGF0aW9uXG4gKi9cblxuaW1wb3J0IHsgd2l0aFByZWZpeGVzIH0gZnJvbSAnLi9wcmVmaXhlcy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVGb3JTUEFSUUwgfSBmcm9tICcuLi9zcGFycWwtY2xpZW50LmpzJztcbmltcG9ydCB7IExhbmd1YWdlIH0gZnJvbSAnLi4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gbG9vayB1cCBhIGxlZ2FsIGFjdCBieSBTUiBudW1iZXJcbiAqIFNSIG51bWJlcnMgYXJlIGFjY2Vzc2VkIHZpYSB0YXhvbm9teSBjbGFzc2lmaWNhdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rdXBTdGF0dXRlUXVlcnkoc3JOdW1iZXI6IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2luRm9yY2UgP2RhdGVJbkZvcmNlID9kYXRlRG9jdW1lbnQgP2FjdFR5cGVcbldIRVJFIHtcbiAgIyBGaW5kIGFjdCB2aWEgdGF4b25vbXkgY2xhc3NpZmljYXRpb25cbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gICMgR2V0IFNSIG51bWJlciBmcm9tIHRheG9ub215XG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgR2V0IHRpdGxlIGZyb20gdGF4b25vbXkgcHJlZkxhYmVsIChoYXMgbGFuZ3VhZ2UgdGFncylcbiAgP3RheG9ub215IHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG4gICR7bGFuZ0ZpbHRlcn1cblxuICAjIE9wdGlvbmFsIG1ldGFkYXRhXG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6ZGF0ZURvY3VtZW50ID9kYXRlRG9jdW1lbnQgfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6ZGF0ZUVudHJ5SW5Gb3JjZSA/ZGF0ZUluRm9yY2UgfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dHlwZURvY3VtZW50ID9hY3RUeXBlIH1cblxuICAjIENoZWNrIGlmIGN1cnJlbnRseSBpbiBmb3JjZVxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppbkZvcmNlID9pbkZvcmNlU3RhdHVzIC5cbiAgICBCSU5EKD9pbkZvcmNlU3RhdHVzID0gPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9lbmZvcmNlbWVudC1zdGF0dXMvMT4gQVMgP2luRm9yY2UpXG4gIH1cbn1cbk9SREVSIEJZID9zck51bWJlclxuTElNSVQgMTBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBsb29rIHVwIGEgbGVnYWwgYWN0IHdpdGggYXJ0aWNsZXNcbiAqIE5vdGU6IEFydGljbGUgc3RydWN0dXJlIGluIEpPTFVYIHVzZXMgam9sdXg6aGFzUGFydFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rdXBTdGF0dXRlV2l0aEFydGljbGVzUXVlcnkoc3JOdW1iZXI6IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2FydGljbGUgP2FydGljbGVOdW1iZXIgP2FydGljbGVUaXRsZSA/YXJ0aWNsZVRleHQgP2RhdGVJbkZvcmNlXG5XSEVSRSB7XG4gICMgRmluZCBtYWluIGFjdCB2aWEgdGF4b25vbXlcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgR2V0IHRpdGxlIGZyb20gdGF4b25vbXlcbiAgP3RheG9ub215IHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG4gICR7bGFuZ0ZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmRhdGVFbnRyeUluRm9yY2UgP2RhdGVJbkZvcmNlIH1cblxuICAjIEFydGljbGVzIChzdWJkaXZpc2lvbnMpIC0gSk9MVVggdXNlcyBoYXNQYXJ0XG4gIE9QVElPTkFMIHtcbiAgICA/YWN0IGpvbHV4Omhhc1BhcnQgP2FydGljbGUgLlxuICAgID9hcnRpY2xlIGpvbHV4Om51bWJlciA/YXJ0aWNsZU51bWJlciAuXG4gICAgT1BUSU9OQUwge1xuICAgICAgP2FydGljbGUgam9sdXg6aXNSZWFsaXplZEJ5ID9hcnRpY2xlRXhwciAuXG4gICAgICA/YXJ0aWNsZUV4cHIgam9sdXg6dGl0bGUgP2FydGljbGVUaXRsZSAuXG4gICAgfVxuICAgIE9QVElPTkFMIHsgP2FydGljbGUgam9sdXg6dGV4dCA/YXJ0aWNsZVRleHQgfVxuICB9XG59XG5PUkRFUiBCWSA/YXJ0aWNsZU51bWJlclxuTElNSVQgNTAwXG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3QgYnkgYWJicmV2aWF0aW9uIChlLmcuLCBcIk9SXCIsIFwiWkdCXCIsIFwiU3RHQlwiKVxuICogQWJicmV2aWF0aW9ucyBtYXkgYmUgaW4gdGF4b25vbXkgb3IgYWN0IHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTG9va3VwQnlBYmJyZXZpYXRpb25RdWVyeShhYmJyZXZpYXRpb246IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2luRm9yY2VcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gID90YXhvbm9teSBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBTZWFyY2ggZm9yIGFiYnJldmlhdGlvbiBpbiB2YXJpb3VzIHBsYWNlc1xuICB7XG4gICAgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gLlxuICAgIEZJTFRFUihVQ0FTRShTVFIoP2FiYnJldmlhdGlvbikpID0gXCIke2VzY2FwZUZvclNQQVJRTChhYmJyZXZpYXRpb24udG9VcHBlckNhc2UoKSl9XCIpXG4gIH0gVU5JT04ge1xuICAgID90YXhvbm9teSBza29zOmFsdExhYmVsID9hYmJyZXZpYXRpb24gLlxuICAgIEZJTFRFUihVQ0FTRShTVFIoP2FiYnJldmlhdGlvbikpID0gXCIke2VzY2FwZUZvclNQQVJRTChhYmJyZXZpYXRpb24udG9VcHBlckNhc2UoKSl9XCIpXG4gIH1cblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppbkZvcmNlID9pbkZvcmNlU3RhdHVzIC5cbiAgICBCSU5EKD9pbkZvcmNlU3RhdHVzID0gPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9lbmZvcmNlbWVudC1zdGF0dXMvMT4gQVMgP2luRm9yY2UpXG4gIH1cbn1cbk9SREVSIEJZID9zck51bWJlclxuTElNSVQgMTBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBjaGVjayBpZiBhbiBTUiBudW1iZXIgZXhpc3RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEV4aXN0c1F1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcbkFTSyB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGFsbCBTUiBudW1iZXJzIGZvciBuYXZpZ2F0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExpc3RTUk51bWJlcnNRdWVyeShwcmVmaXg/OiBzdHJpbmcsIGxpbWl0OiBudW1iZXIgPSAxMDApOiBzdHJpbmcge1xuICBjb25zdCBwcmVmaXhGaWx0ZXIgPSBwcmVmaXhcbiAgICA/IGBGSUxURVIoU1RSU1RBUlRTKFNUUig/c3JOdW1iZXIpLCBcIiR7ZXNjYXBlRm9yU1BBUlFMKHByZWZpeCl9XCIpKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9zck51bWJlciA/dGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gIEZJTFRFUihMQU5HKD90aXRsZSkgPSBcImRlXCIpXG4gICR7cHJlZml4RmlsdGVyfVxufVxuT1JERVIgQlkgP3NyTnVtYmVyXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCB0aGUgY3VycmVudCBjb25zb2xpZGF0ZWQgdmVyc2lvbiBvZiBhbiBhY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQ29uc29saWRhdGVkVmVyc2lvblF1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcsIGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP2NvbnNvbGlkYXRlZFZlcnNpb24gP3NyTnVtYmVyID90aXRsZSA/ZGF0ZUNvbnNvbGlkYXRpb25cbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBHZXQgdGhlIG1vc3QgcmVjZW50IGNvbnNvbGlkYXRlZCB2ZXJzaW9uXG4gIE9QVElPTkFMIHtcbiAgICA/YWN0IGpvbHV4OmlzUmVhbGl6ZWRCeSA/Y29uc29saWRhdGVkVmVyc2lvbiAuXG4gICAgP2NvbnNvbGlkYXRlZFZlcnNpb24gam9sdXg6ZGF0ZURvY3VtZW50ID9kYXRlQ29uc29saWRhdGlvbiAuXG4gIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGVDb25zb2xpZGF0aW9uKVxuTElNSVQgMVxuICBgKTtcbn1cbiIsICIvKipcbiAqIFNQQVJRTCBRdWVyaWVzIGZvciBBcnRpY2xlIFJldHJpZXZhbFxuICogUXVlcmllcyB0byByZXRyaWV2ZSBzcGVjaWZpYyBhcnRpY2xlcyB3aXRoaW4gbGVnYWwgYWN0cyB1c2luZyBKT0xVWCBvbnRvbG9neVxuICpcbiAqIEZlZGxleCBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6Q29uc29saWRhdGlvbkFic3RyYWN0ID0gQ29uc29saWRhdGVkIGxlZ2lzbGF0aW9uIHdvcmtcbiAqIC0gam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uID0gQXJ0aWNsZS9zdWJkaXZpc2lvbiBzdHJ1Y3R1cmVcbiAqIC0gam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSXNQYXJ0T2YgPSBpbnZlcnNlIHBhcmVudCByZWxhdGlvbnNoaXAgKGNoaWxkIFx1MjE5MiBwYXJlbnQpXG4gKiAtIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkhhc1N1YmRpdmlzaW9uSWRlbnRpZmljYXRpb25EZXRhaWwgXHUyMTkyIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkRldGFpbElkID0gQXJ0aWNsZSBudW1iZXJcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqIC0gVGl0bGVzOiB0YXhvbm9teSBza29zOnByZWZMYWJlbCAod2l0aCBsYW5ndWFnZSB0YWdzKVxuICpcbiAqIE5vdGU6IE9ubHkgbW9kaWZpZWQgYXJ0aWNsZXMgYXJlIHN0b3JlZCBpbiBGZWRsZXggKG5vdCBvcmlnaW5hbCBhcnRpY2xlcykuXG4gKiBBcnRpY2xlIFVSSXMgZm9sbG93IHBhdHRlcm46IC9lbGkvY2MvW2lkXS9hcnRfW251bWJlcl0vW2RhdGVdXG4gKi9cblxuaW1wb3J0IHsgd2l0aFByZWZpeGVzIH0gZnJvbSAnLi9wcmVmaXhlcy5qcyc7XG5pbXBvcnQgeyBlc2NhcGVGb3JTUEFSUUwgfSBmcm9tICcuLi9zcGFycWwtY2xpZW50LmpzJztcbmltcG9ydCB7IExhbmd1YWdlIH0gZnJvbSAnLi4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGEgc3BlY2lmaWMgYXJ0aWNsZVxuICpcbiAqIEZlZGxleCBzdG9yZXMgYXJ0aWNsZXMgYXMgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIHdpdGggaW52ZXJzZSBwYXJlbnQgcmVsYXRpb25zaGlwLlxuICogQXJ0aWNsZSBudW1iZXJzIGFyZSBhY2Nlc3NlZCB2aWEgbGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR2V0QXJ0aWNsZVF1ZXJ5KFxuICBzck51bWJlcjogc3RyaW5nLFxuICBhcnRpY2xlTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2Vcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD9hY3RUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgLy8gTm9ybWFsaXplIGFydGljbGUgbnVtYmVyIChlLmcuLCBcIjk3XCIgb3IgXCJBcnQuIDk3XCIgLT4gXCI5N1wiKVxuICBjb25zdCBub3JtYWxpemVkQXJ0aWNsZSA9IGFydGljbGVOdW1iZXIucmVwbGFjZSgvXkFydFxcLj9cXHMqL2ksICcnKS50cmltKCk7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP2FjdFRpdGxlID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID9hcnRpY2xlVGl0bGUgP3RleHQgP3BhcmFncmFwaE51bSA/cGFyYWdyYXBoVGV4dFxuV0hFUkUge1xuICAjIEZpbmQgdGhlIGFjdCB2aWEgdGF4b25vbXkgKENvbnNvbGlkYXRpb25BYnN0cmFjdCBmb3IgY29uc29saWRhdGVkIGxhd3MpXG4gID9hY3QgYSBqb2x1eDpDb25zb2xpZGF0aW9uQWJzdHJhY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgO1xuICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP2FjdFRpdGxlIC5cblxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcbiAgJHtsYW5nRmlsdGVyfVxuXG4gICMgRmluZCBhcnRpY2xlcyB0aGF0IGJlbG9uZyB0byB0aGlzIGFjdCAoaW52ZXJzZSByZWxhdGlvbnNoaXA6IGFydGljbGUgXHUyMTkyIHBhcmVudClcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgIyBHZXQgYXJ0aWNsZSBudW1iZXIgZnJvbSBzdWJkaXZpc2lvbiBkZXRhaWxcbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgIyBNYXRjaCBhcnRpY2xlIG51bWJlclxuICBGSUxURVIoXG4gICAgU1RSKD9hcnRpY2xlTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwobm9ybWFsaXplZEFydGljbGUpfVwiIHx8XG4gICAgUkVHRVgoU1RSKD9hcnRpY2xlTnVtYmVyKSwgXCJeJHtlc2NhcGVGb3JTUEFSUUwobm9ybWFsaXplZEFydGljbGUpfVthLXpdPyRcIiwgXCJpXCIpXG4gIClcblxuICAjIEFydGljbGUgdGl0bGUgKG1hcmdpbmFsIG5vdGUpIGZyb20gZXhwcmVzc2lvblxuICBPUFRJT05BTCB7XG4gICAgP2FydGljbGUgam9sdXg6aXNSZWFsaXplZEJ5ID9hcnRpY2xlRXhwciAuXG4gICAgP2FydGljbGVFeHByIGpvbHV4OnRpdGxlID9hcnRpY2xlVGl0bGUgLlxuICAgICR7bGFuZ3VhZ2UgPyBgRklMVEVSKExBTkcoP2FydGljbGVUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYCA6ICcnfVxuICB9XG5cbiAgIyBHZXQgdGV4dCBjb250ZW50IGZyb20gbWFuaWZlc3RhdGlvblxuICBPUFRJT05BTCB7XG4gICAgP2FydGljbGUgam9sdXg6aXNSZWFsaXplZEJ5ID9leHByIC5cbiAgICA/ZXhwciBqb2x1eDppc0VtYm9kaWVkQnkgP21hbmlmIC5cbiAgICA/bWFuaWYgam9sdXg6dGV4dCA/dGV4dCAuXG4gIH1cblxuICAjIFBhcmFncmFwaHMgKHN1Yi1zdWJkaXZpc2lvbnMpXG4gIE9QVElPTkFMIHtcbiAgICA/cGFyYWdyYXBoIGEgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIDtcbiAgICAgICAgICAgICAgIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbklzUGFydE9mID9hcnRpY2xlIC5cbiAgICA/cGFyYWdyYXBoIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkhhc1N1YmRpdmlzaW9uSWRlbnRpZmljYXRpb25EZXRhaWwgP3BEZXRhaWwgLlxuICAgID9wRGV0YWlsIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkRldGFpbElkID9wYXJhZ3JhcGhOdW0gLlxuXG4gICAgT1BUSU9OQUwge1xuICAgICAgP3BhcmFncmFwaCBqb2x1eDppc1JlYWxpemVkQnkgP3BFeHByIC5cbiAgICAgID9wRXhwciBqb2x1eDppc0VtYm9kaWVkQnkgP3BNYW5pZiAuXG4gICAgICA/cE1hbmlmIGpvbHV4OnRleHQgP3BhcmFncmFwaFRleHQgLlxuICAgIH1cbiAgfVxufVxuT1JERVIgQlkgP3BhcmFncmFwaE51bVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBhbiBhcnRpY2xlIHdpdGggc3BlY2lmaWMgcGFyYWdyYXBoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdldEFydGljbGVQYXJhZ3JhcGhRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgYXJ0aWNsZU51bWJlcjogc3RyaW5nLFxuICBwYXJhZ3JhcGhOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZVxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICBjb25zdCBub3JtYWxpemVkQXJ0aWNsZSA9IGFydGljbGVOdW1iZXIucmVwbGFjZSgvXkFydFxcLj9cXHMqL2ksICcnKS50cmltKCk7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FjdCA/c3JOdW1iZXIgP3RpdGxlID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID9wYXJhZ3JhcGggP3BhcmFncmFwaE51bSA/dGV4dFxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6Q29uc29saWRhdGlvbkFic3RyYWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG4gICR7bGFuZ0ZpbHRlcn1cblxuICAjIEZpbmQgYXJ0aWNsZSB2aWEgaW52ZXJzZSByZWxhdGlvbnNoaXBcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgRklMVEVSKFxuICAgIFNUUig/YXJ0aWNsZU51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1cIiB8fFxuICAgIFJFR0VYKFNUUig/YXJ0aWNsZU51bWJlciksIFwiXiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1bYS16XT8kXCIsIFwiaVwiKVxuICApXG5cbiAgIyBGaW5kIHBhcmFncmFwaCB3aXRoaW4gYXJ0aWNsZVxuICA/cGFyYWdyYXBoIGEgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIDtcbiAgICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YXJ0aWNsZSAuXG5cbiAgP3BhcmFncmFwaCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25IYXNTdWJkaXZpc2lvbklkZW50aWZpY2F0aW9uRGV0YWlsID9wRGV0YWlsIC5cbiAgP3BEZXRhaWwgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uRGV0YWlsSWQgP3BhcmFncmFwaE51bSAuXG5cbiAgRklMVEVSKFNUUig/cGFyYWdyYXBoTnVtKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwocGFyYWdyYXBoTnVtYmVyKX1cIilcblxuICAjIEdldCBwYXJhZ3JhcGggdGV4dFxuICBPUFRJT05BTCB7XG4gICAgP3BhcmFncmFwaCBqb2x1eDppc1JlYWxpemVkQnkgP3BFeHByIC5cbiAgICA/cEV4cHIgam9sdXg6aXNFbWJvZGllZEJ5ID9wTWFuaWYgLlxuICAgID9wTWFuaWYgam9sdXg6dGV4dCA/dGV4dCAuXG4gIH1cbn1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBsaXN0IGFsbCBhcnRpY2xlcyBpbiBhbiBhY3RcbiAqXG4gKiBOb3RlOiBGZWRsZXggb25seSBzdG9yZXMgbW9kaWZpZWQgYXJ0aWNsZXMsIG5vdCBhbGwgYXJ0aWNsZXMuXG4gKiBUaGlzIHJldHVybnMgYXJ0aWNsZXMgdGhhdCBoYXZlIGJlZW4gYW1lbmRlZC9tb2RpZmllZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGlzdEFydGljbGVzUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDAwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YWN0VGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID90aXRsZSA/YWN0VGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkNvbnNvbGlkYXRpb25BYnN0cmFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/YWN0VGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBGaW5kIGFsbCBhcnRpY2xlIHN1YmRpdmlzaW9ucyBiZWxvbmdpbmcgdG8gdGhpcyBhY3RcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgIyBHZXQgYXJ0aWNsZSBudW1iZXJcbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgIyBHZXQgYXJ0aWNsZSB0aXRsZSBpZiBhdmFpbGFibGVcbiAgT1BUSU9OQUwge1xuICAgID9hcnRpY2xlIGpvbHV4OmlzUmVhbGl6ZWRCeSA/YXJ0aWNsZUV4cHIgLlxuICAgID9hcnRpY2xlRXhwciBqb2x1eDp0aXRsZSA/dGl0bGUgLlxuICAgICR7bGFuZ3VhZ2UgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgIDogJyd9XG4gIH1cbn1cbk9SREVSIEJZIHhzZDppbnRlZ2VyKD9hcnRpY2xlTnVtYmVyKVxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBzZWFyY2ggZm9yIGFydGljbGVzIGNvbnRhaW5pbmcgc3BlY2lmaWMgdGV4dFxuICpcbiAqIFNlYXJjaGVzIGluIGFydGljbGUgdGl0bGVzIChtYXJnaW5hbCBub3RlcykgZnJvbSBleHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2VhcmNoQXJ0aWNsZXNRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgc2VhcmNoVGV4dDogc3RyaW5nLFxuICBsYW5ndWFnZT86IExhbmd1YWdlXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YWN0VGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hcnRpY2xlID9hcnRpY2xlTnVtYmVyID90aXRsZSA/YWN0VGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkNvbnNvbGlkYXRpb25BYnN0cmFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/YWN0VGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgIyBGaW5kIGFydGljbGVzXG4gID9hcnRpY2xlIGEgam9sdXg6TGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uIDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSXNQYXJ0T2YgP2FjdCA7XG4gICAgICAgICAgIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvblR5cGUgPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9zdWJkaXZpc2lvbi10eXBlL2FydD4gLlxuXG4gICMgR2V0IGFydGljbGUgbnVtYmVyXG4gID9hcnRpY2xlIGpvbHV4OmxlZ2FsUmVzb3VyY2VTdWJkaXZpc2lvbkhhc1N1YmRpdmlzaW9uSWRlbnRpZmljYXRpb25EZXRhaWwgP2RldGFpbCAuXG4gID9kZXRhaWwgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uRGV0YWlsSWQgP2FydGljbGVOdW1iZXIgLlxuXG4gICMgR2V0IGFydGljbGUgdGl0bGUgZm9yIHNlYXJjaFxuICA/YXJ0aWNsZSBqb2x1eDppc1JlYWxpemVkQnkgP2FydGljbGVFeHByIC5cbiAgP2FydGljbGVFeHByIGpvbHV4OnRpdGxlID90aXRsZSAuXG4gICR7bGFuZ3VhZ2UgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgIDogJyd9XG5cbiAgIyBTZWFyY2ggaW4gYXJ0aWNsZSB0aXRsZVxuICBGSUxURVIoQ09OVEFJTlMoTENBU0UoU1RSKD90aXRsZSkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKHNlYXJjaFRleHQpfVwiKSkpXG59XG5PUkRFUiBCWSB4c2Q6aW50ZWdlcig/YXJ0aWNsZU51bWJlcilcbkxJTUlUIDUwXG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGFydGljbGUgaGlzdG9yeSAodmVyc2lvbnMgb3ZlciB0aW1lKVxuICpcbiAqIEFydGljbGVzIGluIEZlZGxleCBoYXZlIHRlbXBvcmFsIHZlcnNpb25zIHZpYSBleHByZXNzaW9ucyB3aXRoIGRhdGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBcnRpY2xlSGlzdG9yeVF1ZXJ5KFxuICBzck51bWJlcjogc3RyaW5nLFxuICBhcnRpY2xlTnVtYmVyOiBzdHJpbmdcbik6IHN0cmluZyB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRBcnRpY2xlID0gYXJ0aWNsZU51bWJlci5yZXBsYWNlKC9eQXJ0XFwuP1xccyovaSwgJycpLnRyaW0oKTtcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YXJ0aWNsZSA/YXJ0aWNsZU51bWJlciA/dmVyc2lvbiA/ZGF0ZSA/bGFuZ3VhZ2VcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkNvbnNvbGlkYXRpb25BYnN0cmFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgIyBGaW5kIGFydGljbGVcbiAgP2FydGljbGUgYSBqb2x1eDpMZWdhbFJlc291cmNlU3ViZGl2aXNpb24gO1xuICAgICAgICAgICBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25Jc1BhcnRPZiA/YWN0IDtcbiAgICAgICAgICAgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uVHlwZSA8aHR0cHM6Ly9mZWRsZXguZGF0YS5hZG1pbi5jaC92b2NhYnVsYXJ5L3N1YmRpdmlzaW9uLXR5cGUvYXJ0PiAuXG5cbiAgP2FydGljbGUgam9sdXg6bGVnYWxSZXNvdXJjZVN1YmRpdmlzaW9uSGFzU3ViZGl2aXNpb25JZGVudGlmaWNhdGlvbkRldGFpbCA/ZGV0YWlsIC5cbiAgP2RldGFpbCBqb2x1eDpsZWdhbFJlc291cmNlU3ViZGl2aXNpb25EZXRhaWxJZCA/YXJ0aWNsZU51bWJlciAuXG5cbiAgRklMVEVSKFxuICAgIFNUUig/YXJ0aWNsZU51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1cIiB8fFxuICAgIFJFR0VYKFNUUig/YXJ0aWNsZU51bWJlciksIFwiXiR7ZXNjYXBlRm9yU1BBUlFMKG5vcm1hbGl6ZWRBcnRpY2xlKX1bYS16XT8kXCIsIFwiaVwiKVxuICApXG5cbiAgIyBHZXQgdmVyc2lvbiBoaXN0b3J5IHZpYSBleHByZXNzaW9uc1xuICA/YXJ0aWNsZSBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuXG4gICMgR2V0IGRhdGUgYW5kIGxhbmd1YWdlIGZyb20gZXhwcmVzc2lvblxuICBPUFRJT05BTCB7ID92ZXJzaW9uIGpvbHV4OmRhdGVEb2N1bWVudCA/ZGF0ZSB9XG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6bGFuZ3VhZ2UgP2xhbmd1YWdlIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGUpID9sYW5ndWFnZVxuTElNSVQgNTBcbiAgYCk7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUXVlcmllcyBmb3IgTGVnaXNsYXRpb24gU2VhcmNoXG4gKiBGdWxsLXRleHQgYW5kIGZpbHRlcmVkIHNlYXJjaCBhY3Jvc3MgdGhlIGxlZ2lzbGF0aW9uIGNvcnB1cyB1c2luZyBKT0xVWCBvbnRvbG9neVxuICpcbiAqIEZlZGxleCBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiB3b3JrXG4gKiAtIFRpdGxlczogdGF4b25vbXkgc2tvczpwcmVmTGFiZWwgKHdpdGggbGFuZ3VhZ2UgdGFncykgT1IgRXhwcmVzc2lvbiBqb2x1eDp0aXRsZSAobm8gdGFncylcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqL1xuXG5pbXBvcnQgeyB3aXRoUHJlZml4ZXMgfSBmcm9tICcuL3ByZWZpeGVzLmpzJztcbmltcG9ydCB7IGVzY2FwZUZvclNQQVJRTCB9IGZyb20gJy4uL3NwYXJxbC1jbGllbnQuanMnO1xuaW1wb3J0IHsgTGFuZ3VhZ2UsIFNlYXJjaEZpbHRlcnMgfSBmcm9tICcuLi90eXBlcy9sZWdpc2xhdGlvbi5qcyc7XG5cbi8qKlxuICogQnVpbGQgYSBmdWxsLXRleHQgc2VhcmNoIHF1ZXJ5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlYXJjaFF1ZXJ5KFxuICBzZWFyY2hUZXh0OiBzdHJpbmcsXG4gIGZpbHRlcnM6IFNlYXJjaEZpbHRlcnMgPSB7fVxuKTogc3RyaW5nIHtcbiAgY29uc3Qge1xuICAgIGxhbmd1YWdlLFxuICAgIGFjdFR5cGUsXG4gICAgLy8gc3RhdHVzIGZpbHRlciBub3QgeWV0IGltcGxlbWVudGVkIC0gRmVkbGV4IHVzZXMgam9sdXg6aW5Gb3JjZSB2b2NhYnVsYXJ5XG4gICAgc3JOdW1iZXJQcmVmaXgsXG4gICAgbGltaXQgPSA1MCxcbiAgICBvZmZzZXQgPSAwLFxuICB9ID0gZmlsdGVycztcblxuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIGNvbnN0IHNyUHJlZml4RmlsdGVyID0gc3JOdW1iZXJQcmVmaXhcbiAgICA/IGBGSUxURVIoU1RSU1RBUlRTKFNUUig/c3JOdW1iZXIpLCBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyUHJlZml4KX1cIikpYFxuICAgIDogJyc7XG5cbiAgY29uc3QgYWN0VHlwZUZpbHRlciA9IGFjdFR5cGUgJiYgYWN0VHlwZS5sZW5ndGggPiAwXG4gICAgPyBgRklMVEVSKD9hY3RUeXBlIElOICgke2FjdFR5cGUubWFwKHQgPT4gYFwiJHt0fVwiYCkuam9pbignLCAnKX0pKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9hY3RUeXBlID9kYXRlSW5Gb3JjZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgIyBHZXQgU1IgbnVtYmVyIGZyb20gdGF4b25vbXlcbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cblxuICAjIEdldCB0aXRsZSBmcm9tIHRheG9ub215IHByZWZMYWJlbCAoaGFzIGxhbmd1YWdlIHRhZ3MpXG4gID90YXhvbm9teSBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gICMgVGV4dCBzZWFyY2ggaW4gdGl0bGUgb3IgU1IgbnVtYmVyXG4gIEZJTFRFUihcbiAgICBDT05UQUlOUyhMQ0FTRShTVFIoP3RpdGxlKSksIExDQVNFKFwiJHtlc2NhcGVGb3JTUEFSUUwoc2VhcmNoVGV4dCl9XCIpKSB8fFxuICAgIENPTlRBSU5TKExDQVNFKFNUUig/c3JOdW1iZXIpKSwgTENBU0UoXCIke2VzY2FwZUZvclNQQVJRTChzZWFyY2hUZXh0KX1cIikpXG4gIClcblxuICAke2xhbmdGaWx0ZXJ9XG4gICR7c3JQcmVmaXhGaWx0ZXJ9XG4gICR7YWN0VHlwZUZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YWN0VHlwZSB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlRW50cnlJbkZvcmNlID9kYXRlSW5Gb3JjZSB9XG59XG5PUkRFUiBCWSA/c3JOdW1iZXJcbk9GRlNFVCAke29mZnNldH1cbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgc2VhcmNoIHF1ZXJ5IGZvciBjb3VudGluZyByZXN1bHRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlYXJjaENvdW50UXVlcnkoXG4gIHNlYXJjaFRleHQ6IHN0cmluZyxcbiAgZmlsdGVyczogU2VhcmNoRmlsdGVycyA9IHt9XG4pOiBzdHJpbmcge1xuICBjb25zdCB7IGxhbmd1YWdlLCBzck51bWJlclByZWZpeCwgYWN0VHlwZSB9ID0gZmlsdGVycztcblxuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIGNvbnN0IHNyUHJlZml4RmlsdGVyID0gc3JOdW1iZXJQcmVmaXhcbiAgICA/IGBGSUxURVIoU1RSU1RBUlRTKFNUUig/c3JOdW1iZXIpLCBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyUHJlZml4KX1cIikpYFxuICAgIDogJyc7XG5cbiAgY29uc3QgYWN0VHlwZUZpbHRlciA9IGFjdFR5cGUgJiYgYWN0VHlwZS5sZW5ndGggPiAwXG4gICAgPyBgRklMVEVSKD9hY3RUeXBlIElOICgke2FjdFR5cGUubWFwKHQgPT4gYFwiJHt0fVwiYCkuam9pbignLCAnKX0pKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIChDT1VOVChESVNUSU5DVCA/YWN0KSBBUyA/Y291bnQpXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgO1xuICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP3RpdGxlIC5cblxuICBGSUxURVIoXG4gICAgQ09OVEFJTlMoTENBU0UoU1RSKD90aXRsZSkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKHNlYXJjaFRleHQpfVwiKSkgfHxcbiAgICBDT05UQUlOUyhMQ0FTRShTVFIoP3NyTnVtYmVyKSksIExDQVNFKFwiJHtlc2NhcGVGb3JTUEFSUUwoc2VhcmNoVGV4dCl9XCIpKVxuICApXG5cbiAgJHtsYW5nRmlsdGVyfVxuICAke3NyUHJlZml4RmlsdGVyfVxuICAke2FjdFR5cGVGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YWN0VHlwZSB9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgc2VhcmNoIHF1ZXJ5IGJ5IGxlZ2FsIGRvbWFpbiAoU1IgbnVtYmVyIHByZWZpeClcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkU2VhcmNoQnlEb21haW5RdWVyeShcbiAgZG9tYWluOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDBcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgLy8gRG9tYWluIGNvZGVzIG1hcCB0byBTUiBudW1iZXIgcHJlZml4ZXM6XG4gIC8vIDEgPSBDb25zdGl0dXRpb25hbCBsYXcsIDIgPSBQcml2YXRlIGxhdywgMyA9IENyaW1pbmFsIGxhdywgZXRjLlxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YWN0ID9zck51bWJlciA/dGl0bGUgP2FiYnJldmlhdGlvblxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUlNUQVJUUyhTVFIoP3NyTnVtYmVyKSwgXCIke2VzY2FwZUZvclNQQVJRTChkb21haW4pfVwiKSlcbiAgJHtsYW5nRmlsdGVyfVxuXG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gfVxufVxuT1JERVIgQlkgP3NyTnVtYmVyXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHNlYXJjaCBxdWVyeSBieSBkYXRlIHJhbmdlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFNlYXJjaEJ5RGF0ZVF1ZXJ5KFxuICBkYXRlRnJvbT86IHN0cmluZyxcbiAgZGF0ZVRvPzogc3RyaW5nLFxuICBsYW5ndWFnZT86IExhbmd1YWdlLFxuICBsaW1pdDogbnVtYmVyID0gNTBcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgbGV0IGRhdGVGaWx0ZXIgPSAnJztcbiAgaWYgKGRhdGVGcm9tICYmIGRhdGVUbykge1xuICAgIGRhdGVGaWx0ZXIgPSBgRklMVEVSKD9kYXRlSW5Gb3JjZSA+PSBcIiR7ZGF0ZUZyb219XCJeXnhzZDpkYXRlICYmID9kYXRlSW5Gb3JjZSA8PSBcIiR7ZGF0ZVRvfVwiXl54c2Q6ZGF0ZSlgO1xuICB9IGVsc2UgaWYgKGRhdGVGcm9tKSB7XG4gICAgZGF0ZUZpbHRlciA9IGBGSUxURVIoP2RhdGVJbkZvcmNlID49IFwiJHtkYXRlRnJvbX1cIl5eeHNkOmRhdGUpYDtcbiAgfSBlbHNlIGlmIChkYXRlVG8pIHtcbiAgICBkYXRlRmlsdGVyID0gYEZJTFRFUig/ZGF0ZUluRm9yY2UgPD0gXCIke2RhdGVUb31cIl5eeHNkOmRhdGUpYDtcbiAgfVxuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9kYXRlSW5Gb3JjZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSA7XG4gICAgICAgam9sdXg6ZGF0ZUVudHJ5SW5Gb3JjZSA/ZGF0ZUluRm9yY2UgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gICR7ZGF0ZUZpbHRlcn1cbiAgJHtsYW5nRmlsdGVyfVxuXG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0aXRsZVNob3J0ID9hYmJyZXZpYXRpb24gfVxufVxuT1JERVIgQlkgREVTQyg/ZGF0ZUluRm9yY2UpXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHNlYXJjaCBxdWVyeSBmb3IgcmVjZW50bHkgbW9kaWZpZWQgbGVnaXNsYXRpb25cbiAqXG4gKiBVc2VzIGRjdGVybXM6bW9kaWZpZWQgd2hpY2ggaXMgdGhlIGFjdHVhbCBtb2RpZmljYXRpb24gdGltZXN0YW1wIGluIEZlZGxleC5cbiAqIFNlYXJjaGVzIGJvdGggam9sdXg6QWN0IChvZmZpY2lhbCBjb2xsZWN0aW9uKSBhbmQgam9sdXg6Q29uc29saWRhdGlvbkFic3RyYWN0IChjb25zb2xpZGF0ZWQgbGF3cykuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZFJlY2VudGx5TW9kaWZpZWRRdWVyeShcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDIwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9kYXRlTW9kaWZpZWRcbldIRVJFIHtcbiAgIyBNYXRjaCBib3RoIEFjdCAob2ZmaWNpYWwgY29sbGVjdGlvbikgYW5kIENvbnNvbGlkYXRpb25BYnN0cmFjdCAoY29uc29saWRhdGVkKVxuICA/YWN0IGEgP2FjdFR5cGUgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IDtcbiAgICAgICBkY3Rlcm1zOm1vZGlmaWVkID9kYXRlTW9kaWZpZWQgLlxuXG4gIEZJTFRFUig/YWN0VHlwZSBJTiAoam9sdXg6QWN0LCBqb2x1eDpDb25zb2xpZGF0aW9uQWJzdHJhY3QpKVxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gICR7bGFuZ0ZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGVNb2RpZmllZClcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEga2V5d29yZCBzZWFyY2ggcXVlcnkgKHVzaW5nIFNLT1MgY29uY2VwdHMgZnJvbSB0YXhvbm9teSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkS2V5d29yZFNlYXJjaFF1ZXJ5KFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YWN0ID9zck51bWJlciA/dGl0bGUgP2FiYnJldmlhdGlvbiA/a2V5d29yZFxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgIyBTZWFyY2ggaW4gdGF4b25vbXkgYnJvYWRlciBjb25jZXB0cyBhbmQga2V5d29yZHNcbiAge1xuICAgID90YXhvbm9teSBza29zOmJyb2FkZXIqID9icm9hZGVyVGF4IC5cbiAgICA/YnJvYWRlclRheCBza29zOnByZWZMYWJlbCA/a2V5d29yZCAuXG4gICAgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/a2V5d29yZCkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKGtleXdvcmQpfVwiKSkpXG4gIH0gVU5JT04ge1xuICAgICMgU2VhcmNoIGluIHN1YmplY3Qva2V5d29yZCBhbm5vdGF0aW9uc1xuICAgID9hY3QgZGN0ZXJtczpzdWJqZWN0ID9zdWJqZWN0IC5cbiAgICA/c3ViamVjdCBza29zOnByZWZMYWJlbCA/a2V5d29yZCAuXG4gICAgRklMVEVSKENPTlRBSU5TKExDQVNFKFNUUig/a2V5d29yZCkpLCBMQ0FTRShcIiR7ZXNjYXBlRm9yU1BBUlFMKGtleXdvcmQpfVwiKSkpXG4gIH1cblxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnRpdGxlU2hvcnQgP2FiYnJldmlhdGlvbiB9XG59XG5PUkRFUiBCWSA/c3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIExlZ2FsIGRvbWFpbiBtYXBwaW5nIChTUiBudW1iZXIgcHJlZml4ZXMpXG4gKi9cbmV4cG9ydCBjb25zdCBMRUdBTF9ET01BSU5TOiBSZWNvcmQ8c3RyaW5nLCB7IGRlOiBzdHJpbmc7IGZyOiBzdHJpbmc7IGl0OiBzdHJpbmcgfT4gPSB7XG4gICcxJzogeyBkZTogJ1N0YWF0IC0gVm9sayAtIEJlaFx1MDBGNnJkZW4nLCBmcjogJ1x1MDBDOXRhdCAtIFBldXBsZSAtIEF1dG9yaXRcdTAwRTlzJywgaXQ6ICdTdGF0byAtIFBvcG9sbyAtIEF1dG9yaXRcdTAwRTAnIH0sXG4gICcyJzogeyBkZTogJ1ByaXZhdHJlY2h0IC0gWml2aWxyZWNodHNwZmxlZ2UgLSBWb2xsc3RyZWNrdW5nJywgZnI6ICdEcm9pdCBwcml2XHUwMEU5IC0gUHJvY1x1MDBFOWR1cmUgY2l2aWxlIC0gRXhcdTAwRTljdXRpb24gZm9yY1x1MDBFOWUnLCBpdDogJ0Rpcml0dG8gcHJpdmF0byAtIFByb2NlZHVyYSBjaXZpbGUgLSBFc2VjdXppb25lJyB9LFxuICAnMyc6IHsgZGU6ICdTdHJhZnJlY2h0IC0gU3RyYWZyZWNodHNwZmxlZ2UgLSBTdHJhZnZvbGx6dWcnLCBmcjogJ0Ryb2l0IHBcdTAwRTluYWwgLSBQcm9jXHUwMEU5ZHVyZSBwXHUwMEU5bmFsZSAtIEV4XHUwMEU5Y3V0aW9uIGRlcyBwZWluZXMnLCBpdDogJ0Rpcml0dG8gcGVuYWxlIC0gUHJvY2VkdXJhIHBlbmFsZSAtIEVzZWN1emlvbmUgZGVsbGUgcGVuZScgfSxcbiAgJzQnOiB7IGRlOiAnU2NodWxlIC0gV2lzc2Vuc2NoYWZ0IC0gS3VsdHVyJywgZnI6ICdcdTAwQzljb2xlIC0gU2NpZW5jZSAtIEN1bHR1cmUnLCBpdDogJ1NjdW9sYSAtIFNjaWVuemEgLSBDdWx0dXJhJyB9LFxuICAnNSc6IHsgZGU6ICdMYW5kZXN2ZXJ0ZWlkaWd1bmcnLCBmcjogJ0RcdTAwRTlmZW5zZSBuYXRpb25hbGUnLCBpdDogJ0RpZmVzYSBuYXppb25hbGUnIH0sXG4gICc2JzogeyBkZTogJ0ZpbmFuemVuJywgZnI6ICdGaW5hbmNlcycsIGl0OiAnRmluYW56ZScgfSxcbiAgJzcnOiB7IGRlOiAnXHUwMEQ2ZmZlbnRsaWNoZSBXZXJrZSAtIEVuZXJnaWUgLSBWZXJrZWhyJywgZnI6ICdUcmF2YXV4IHB1YmxpY3MgLSBcdTAwQzluZXJnaWUgLSBUcmFuc3BvcnRzJywgaXQ6ICdMYXZvcmkgcHViYmxpY2kgLSBFbmVyZ2lhIC0gVHJhc3BvcnRpJyB9LFxuICAnOCc6IHsgZGU6ICdHZXN1bmRoZWl0IC0gQXJiZWl0IC0gU296aWFsZSBTaWNoZXJoZWl0JywgZnI6ICdTYW50XHUwMEU5IC0gVHJhdmFpbCAtIFNcdTAwRTljdXJpdFx1MDBFOSBzb2NpYWxlJywgaXQ6ICdTYW5pdFx1MDBFMCAtIExhdm9ybyAtIFNpY3VyZXp6YSBzb2NpYWxlJyB9LFxuICAnOSc6IHsgZGU6ICdXaXJ0c2NoYWZ0IC0gVGVjaG5pc2NoZSBadXNhbW1lbmFyYmVpdCcsIGZyOiAnXHUwMEM5Y29ub21pZSAtIENvb3BcdTAwRTlyYXRpb24gdGVjaG5pcXVlJywgaXQ6ICdFY29ub21pYSAtIENvb3BlcmF6aW9uZSB0ZWNuaWNhJyB9LFxufTtcbiIsICIvKipcbiAqIFNQQVJRTCBRdWVyaWVzIGZvciBSZWxhdGVkIExlZ2lzbGF0aW9uXG4gKiBRdWVyaWVzIHRvIGZpbmQgcmVsYXRpb25zaGlwcyBiZXR3ZWVuIGxlZ2FsIGFjdHMgdXNpbmcgSk9MVVggb250b2xvZ3lcbiAqXG4gKiBGZWRsZXggRGF0YSBNb2RlbCAoRlJCUi1iYXNlZCk6XG4gKiAtIGpvbHV4OkFjdCA9IFByaW1hcnkgbGVnaXNsYXRpb24gd29ya1xuICogLSBSZWxhdGlvbnNoaXBzOiBqb2x1eDpsZWdhbFJlc291cmNlTGVnYWxSZXNvdXJjZUFtZW5kZWRCeSwgZXRjLlxuICogLSBTUiBudW1iZXJzIHZpYSB0YXhvbm9teTogam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSBcdTIxOTIgc2tvczpub3RhdGlvblxuICpcbiAqIE5vdGU6IEpPTFVYIHVzZXMgZGlmZmVyZW50IHJlbGF0aW9uc2hpcCBwcmVkaWNhdGVzIHRoYW4gRUxJLlxuICogU29tZSByZWxhdGlvbnNoaXBzIGFyZSBtb2RlbGVkIHZpYSBjb25zb2xpZGF0aW9uIGxpbmtzIG9yIGltcGFjdCBlbnRyaWVzLlxuICovXG5cbmltcG9ydCB7IHdpdGhQcmVmaXhlcyB9IGZyb20gJy4vcHJlZml4ZXMuanMnO1xuaW1wb3J0IHsgZXNjYXBlRm9yU1BBUlFMIH0gZnJvbSAnLi4vc3BhcnFsLWNsaWVudC5qcyc7XG5pbXBvcnQgeyBMYW5ndWFnZSwgUmVsYXRpb25UeXBlIH0gZnJvbSAnLi4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3RzIHRoYXQgYW1lbmQgYSBzcGVjaWZpYyBhY3RcbiAqIEluIEpPTFVYLCBhbWVuZG1lbnRzIGFyZSB0cmFja2VkIHZpYSBjb25zb2xpZGF0aW9uL2ltcGFjdCBlbnRyaWVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEZpbmRBbWVuZGluZ0FjdHNRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDUwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YW1lbmRpbmdUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2FtZW5kaW5nQWN0ID9hbWVuZGluZ1NyTnVtYmVyID9hbWVuZGluZ1RpdGxlID9hbWVuZG1lbnREYXRlID9hbWVuZG1lbnRUeXBlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEZpbmQgYWN0cyB0aGF0IGFtZW5kIHRoaXMgYWN0IHZpYSBjb25zb2xpZGF0aW9uIGxpbmtzXG4gICMgSk9MVVggdXNlcyBsZWdhbFJlc291cmNlSW1wYWN0SGFzTGVnYWxSZXNvdXJjZSBvciBzaW1pbGFyIHByZWRpY2F0ZXNcbiAge1xuICAgID9pbXBhY3RFbnRyeSBqb2x1eDpsZWdhbFJlc291cmNlSW1wYWN0SGFzTGVnYWxSZXNvdXJjZSA/YWN0IC5cbiAgICA/aW1wYWN0RW50cnkgam9sdXg6aW1wYWN0RnJvbUxlZ2FsUmVzb3VyY2UgP2FtZW5kaW5nQWN0IC5cbiAgfSBVTklPTiB7XG4gICAgIyBBbHRlcm5hdGl2ZTogZGlyZWN0IGFtZW5kbWVudCByZWxhdGlvbnNoaXAgaWYgYXZhaWxhYmxlXG4gICAgP2FtZW5kaW5nQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQW1lbmRzID9hY3QgLlxuICB9XG5cbiAgP2FtZW5kaW5nQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP2FtZW5kaW5nVGF4IC5cblxuICA/YW1lbmRpbmdUYXggc2tvczpub3RhdGlvbiA/YW1lbmRpbmdTck51bWJlciA7XG4gICAgICAgICAgICAgICBza29zOnByZWZMYWJlbCA/YW1lbmRpbmdUaXRsZSAuXG5cbiAgJHtsYW5nRmlsdGVyfVxuXG4gIE9QVElPTkFMIHsgP2FtZW5kaW5nQWN0IGpvbHV4OmRhdGVEb2N1bWVudCA/YW1lbmRtZW50RGF0ZSB9XG4gIE9QVElPTkFMIHsgP2FtZW5kaW5nQWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YW1lbmRtZW50VHlwZSB9XG59XG5PUkRFUiBCWSBERVNDKD9hbWVuZG1lbnREYXRlKVxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBmaW5kIGFjdHMgYW1lbmRlZCBieSBhIHNwZWNpZmljIGFjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kQW1lbmRlZEFjdHNRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDUwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/YW1lbmRlZFRpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/YW1lbmRlZEFjdCA/YW1lbmRlZFNyTnVtYmVyID9hbWVuZGVkVGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgRmluZCBhY3RzIGFtZW5kZWQgYnkgdGhpcyBhY3RcbiAge1xuICAgID9pbXBhY3RFbnRyeSBqb2x1eDppbXBhY3RGcm9tTGVnYWxSZXNvdXJjZSA/YWN0IC5cbiAgICA/aW1wYWN0RW50cnkgam9sdXg6bGVnYWxSZXNvdXJjZUltcGFjdEhhc0xlZ2FsUmVzb3VyY2UgP2FtZW5kZWRBY3QgLlxuICB9IFVOSU9OIHtcbiAgICA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQW1lbmRzID9hbWVuZGVkQWN0IC5cbiAgfVxuXG4gID9hbWVuZGVkQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/YW1lbmRlZFRheCAuXG5cbiAgP2FtZW5kZWRUYXggc2tvczpub3RhdGlvbiA/YW1lbmRlZFNyTnVtYmVyIDtcbiAgICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP2FtZW5kZWRUaXRsZSAuXG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuT1JERVIgQlkgP2FtZW5kZWRTck51bWJlclxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBmaW5kIGFjdHMgdGhhdCByZWZlcmVuY2UgYSBzcGVjaWZpYyBhY3RcbiAqIEluIEpPTFVYLCByZWZlcmVuY2VzIGFyZSB0cmFja2VkIHZpYSBjaXRhdGlvbi9jcm9zcy1yZWZlcmVuY2UgZW50cmllc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kUmVmZXJlbmNpbmdBY3RzUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlZmVyZW5jaW5nVGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9yZWZlcmVuY2luZ0FjdCA/cmVmZXJlbmNpbmdTck51bWJlciA/cmVmZXJlbmNpbmdUaXRsZSA/cmVmZXJlbmNlVHlwZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgIyBGaW5kIGFjdHMgdGhhdCByZWZlcmVuY2UgdGhpcyBhY3QgdmlhIHZhcmlvdXMgcmVsYXRpb25zaGlwIHR5cGVzXG4gIHtcbiAgICA/cmVmZXJlbmNpbmdBY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VDaXRlcyA/YWN0IC5cbiAgICBCSU5EKFwiY2l0ZXNcIiBBUyA/cmVmZXJlbmNlVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgP3JlZmVyZW5jaW5nQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/YWN0IC5cbiAgICBCSU5EKFwiYmFzZWRfb25cIiBBUyA/cmVmZXJlbmNlVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgP3JlZmVyZW5jaW5nQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlSW1wbGVtZW50cyA/YWN0IC5cbiAgICBCSU5EKFwiaW1wbGVtZW50c1wiIEFTID9yZWZlcmVuY2VUeXBlKVxuICB9XG5cbiAgP3JlZmVyZW5jaW5nQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3JlZlRheCAuXG5cbiAgP3JlZlRheCBza29zOm5vdGF0aW9uID9yZWZlcmVuY2luZ1NyTnVtYmVyIDtcbiAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVmZXJlbmNpbmdUaXRsZSAuXG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuT1JERVIgQlkgP3JlZmVyZW5jaW5nU3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3RzIHJlZmVyZW5jZWQgYnkgYSBzcGVjaWZpYyBhY3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRmluZFJlZmVyZW5jZWRBY3RzUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlZmVyZW5jZWRUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3JlZmVyZW5jZWRBY3QgP3JlZmVyZW5jZWRTck51bWJlciA/cmVmZXJlbmNlZFRpdGxlID9yZWZlcmVuY2VUeXBlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEZpbmQgYWN0cyByZWZlcmVuY2VkIGJ5IHRoaXMgYWN0XG4gIHtcbiAgICA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQ2l0ZXMgP3JlZmVyZW5jZWRBY3QgLlxuICAgIEJJTkQoXCJjaXRlc1wiIEFTID9yZWZlcmVuY2VUeXBlKVxuICB9IFVOSU9OIHtcbiAgICA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/cmVmZXJlbmNlZEFjdCAuXG4gICAgQklORChcImJhc2VkX29uXCIgQVMgP3JlZmVyZW5jZVR5cGUpXG4gIH0gVU5JT04ge1xuICAgID9hY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VJbXBsZW1lbnRzID9yZWZlcmVuY2VkQWN0IC5cbiAgICBCSU5EKFwiaW1wbGVtZW50c1wiIEFTID9yZWZlcmVuY2VUeXBlKVxuICB9XG5cbiAgP3JlZmVyZW5jZWRBY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgICAgICAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID9yZWZUYXggLlxuXG4gID9yZWZUYXggc2tvczpub3RhdGlvbiA/cmVmZXJlbmNlZFNyTnVtYmVyIDtcbiAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVmZXJlbmNlZFRpdGxlIC5cblxuICAke2xhbmdGaWx0ZXJ9XG59XG5PUkRFUiBCWSA/cmVmZXJlbmNlZFNyTnVtYmVyXG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGZpbmQgcmVsYXRlZCBhY3RzIGluIHRoZSBzYW1lIGxlZ2FsIGRvbWFpblxuICogVXNlcyB0YXhvbm9teSBoaWVyYXJjaHkgZm9yIGRvbWFpbiBtYXRjaGluZ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kUmVsYXRlZEJ5RG9tYWluUXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAyMFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlbGF0ZWRUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3JlbGF0ZWRBY3QgP3JlbGF0ZWRTck51bWJlciA/cmVsYXRlZFRpdGxlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEdldCB0aGUgZG9tYWluIHByZWZpeCAoZmlyc3QgZGlnaXQocykgb2YgU1IgbnVtYmVyKVxuICBCSU5EKFJFUExBQ0UoU1RSKD9zck51bWJlciksIFwiXihbMC05XSspXFxcXFxcXFwuLipcIiwgXCIkMVwiKSBBUyA/ZG9tYWluUHJlZml4KVxuXG4gICMgRmluZCBhY3RzIGluIHRoZSBzYW1lIGRvbWFpbiB2aWEgdGF4b25vbXlcbiAgP3JlbGF0ZWRBY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgICAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID9yZWxhdGVkVGF4IC5cblxuICA/cmVsYXRlZFRheCBza29zOm5vdGF0aW9uID9yZWxhdGVkU3JOdW1iZXIgO1xuICAgICAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVsYXRlZFRpdGxlIC5cblxuICBGSUxURVIoP3JlbGF0ZWRBY3QgIT0gP2FjdClcbiAgRklMVEVSKFNUUlNUQVJUUyhTVFIoP3JlbGF0ZWRTck51bWJlciksID9kb21haW5QcmVmaXgpKVxuXG4gICR7bGFuZ0ZpbHRlcn1cbn1cbk9SREVSIEJZID9yZWxhdGVkU3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZmluZCBhY3RzIHdpdGggc2hhcmVkIGtleXdvcmRzL3N1YmplY3RzXG4gKiBVc2VzIHRheG9ub215IGJyb2FkZXIgY29uY2VwdHMgZm9yIHN1YmplY3QgbWF0Y2hpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkRmluZFJlbGF0ZWRCeVN1YmplY3RRdWVyeShcbiAgc3JOdW1iZXI6IHN0cmluZyxcbiAgbGFuZ3VhZ2U/OiBMYW5ndWFnZSxcbiAgbGltaXQ6IG51bWJlciA9IDIwXG4pOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/cmVsYXRlZFRpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/cmVsYXRlZEFjdCA/cmVsYXRlZFNyTnVtYmVyID9yZWxhdGVkVGl0bGUgP3NoYXJlZFN1YmplY3RcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgR2V0IHN1YmplY3QgdmlhIHRheG9ub215IG9yIGRjdGVybXM6c3ViamVjdFxuICB7XG4gICAgP3RheG9ub215IHNrb3M6YnJvYWRlciA/c3ViamVjdCAuXG4gIH0gVU5JT04ge1xuICAgID9hY3QgZGN0ZXJtczpzdWJqZWN0ID9zdWJqZWN0IC5cbiAgfVxuXG4gICMgRmluZCBhY3RzIHdpdGggdGhlIHNhbWUgc3ViamVjdFxuICB7XG4gICAgP3JlbGF0ZWRBY3Qgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/cmVsYXRlZFRheCAuXG4gICAgP3JlbGF0ZWRUYXggc2tvczpicm9hZGVyID9zdWJqZWN0IC5cbiAgfSBVTklPTiB7XG4gICAgP3JlbGF0ZWRBY3QgZGN0ZXJtczpzdWJqZWN0ID9zdWJqZWN0IC5cbiAgfVxuXG4gID9yZWxhdGVkQWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICAgICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/cmVsYXRlZFRheE1haW4gLlxuXG4gID9yZWxhdGVkVGF4TWFpbiBza29zOm5vdGF0aW9uID9yZWxhdGVkU3JOdW1iZXIgO1xuICAgICAgICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP3JlbGF0ZWRUaXRsZSAuXG5cbiAgRklMVEVSKD9yZWxhdGVkQWN0ICE9ID9hY3QpXG5cbiAgT1BUSU9OQUwgeyA/c3ViamVjdCBza29zOnByZWZMYWJlbCA/c2hhcmVkU3ViamVjdCB9XG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuT1JERVIgQlkgP3JlbGF0ZWRTck51bWJlclxuTElNSVQgJHtsaW1pdH1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBjb21wcmVoZW5zaXZlIHF1ZXJ5IHRvIGZpbmQgYWxsIHJlbGF0ZWQgYWN0c1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRGaW5kQWxsUmVsYXRlZFF1ZXJ5KFxuICBzck51bWJlcjogc3RyaW5nLFxuICByZWxhdGlvblR5cGU/OiBSZWxhdGlvblR5cGUsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSA1MFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3JlbGF0ZWRUaXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgLy8gSWYgc3BlY2lmaWMgcmVsYXRpb24gdHlwZSByZXF1ZXN0ZWQsIGJ1aWxkIHRhcmdldGVkIHF1ZXJ5XG4gIGlmIChyZWxhdGlvblR5cGUpIHtcbiAgICBzd2l0Y2ggKHJlbGF0aW9uVHlwZSkge1xuICAgICAgY2FzZSAnYW1lbmRzJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkRmluZEFtZW5kaW5nQWN0c1F1ZXJ5KHNyTnVtYmVyLCBsYW5ndWFnZSwgbGltaXQpO1xuICAgICAgY2FzZSAnYW1lbmRlZF9ieSc6XG4gICAgICAgIHJldHVybiBidWlsZEZpbmRBbWVuZGVkQWN0c1F1ZXJ5KHNyTnVtYmVyLCBsYW5ndWFnZSwgbGltaXQpO1xuICAgICAgY2FzZSAnY2l0ZXMnOlxuICAgICAgY2FzZSAnY2l0ZWRfYnknOlxuICAgICAgY2FzZSAnaW1wbGVtZW50cyc6XG4gICAgICBjYXNlICdpbXBsZW1lbnRlZF9ieSc6XG4gICAgICBjYXNlICdiYXNlZF9vbic6XG4gICAgICAgIHJldHVybiBidWlsZEZpbmRSZWZlcmVuY2luZ0FjdHNRdWVyeShzck51bWJlciwgbGFuZ3VhZ2UsIGxpbWl0KTtcbiAgICAgIGNhc2UgJ3NhbWVfZG9tYWluJzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkRmluZFJlbGF0ZWRCeURvbWFpblF1ZXJ5KHNyTnVtYmVyLCBsYW5ndWFnZSwgbGltaXQpO1xuICAgICAgY2FzZSAnc2FtZV9zdWJqZWN0JzpcbiAgICAgICAgcmV0dXJuIGJ1aWxkRmluZFJlbGF0ZWRCeVN1YmplY3RRdWVyeShzck51bWJlciwgbGFuZ3VhZ2UsIGxpbWl0KTtcbiAgICB9XG4gIH1cblxuICAvLyBEZWZhdWx0OiByZXR1cm4gYWxsIHJlbGF0aW9uc2hpcHMgdmlhIGltcGFjdC9jb25zb2xpZGF0aW9uIGxpbmtzXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9yZWxhdGVkQWN0ID9yZWxhdGVkU3JOdW1iZXIgP3JlbGF0ZWRUaXRsZSA/cmVsYXRpb25UeXBlID9yZWxhdGlvbkRhdGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gIHtcbiAgICAjIEFtZW5kaW5nIGFjdHMgKHZpYSBpbXBhY3QgZW50cmllcylcbiAgICA/aW1wYWN0RW50cnkgam9sdXg6aW1wYWN0RnJvbUxlZ2FsUmVzb3VyY2UgP3JlbGF0ZWRBY3QgLlxuICAgID9pbXBhY3RFbnRyeSBqb2x1eDpsZWdhbFJlc291cmNlSW1wYWN0SGFzTGVnYWxSZXNvdXJjZSA/YWN0IC5cbiAgICBCSU5EKFwiYW1lbmRzXCIgQVMgP3JlbGF0aW9uVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgIyBBbWVuZGVkIGFjdHNcbiAgICA/aW1wYWN0RW50cnkgam9sdXg6aW1wYWN0RnJvbUxlZ2FsUmVzb3VyY2UgP2FjdCAuXG4gICAgP2ltcGFjdEVudHJ5IGpvbHV4OmxlZ2FsUmVzb3VyY2VJbXBhY3RIYXNMZWdhbFJlc291cmNlID9yZWxhdGVkQWN0IC5cbiAgICBCSU5EKFwiYW1lbmRlZF9ieVwiIEFTID9yZWxhdGlvblR5cGUpXG4gIH0gVU5JT04ge1xuICAgICMgQ2l0aW5nIGFjdHNcbiAgICA/cmVsYXRlZEFjdCBqb2x1eDpsZWdhbFJlc291cmNlTGVnYWxSZXNvdXJjZUNpdGVzID9hY3QgLlxuICAgIEJJTkQoXCJjaXRlc1wiIEFTID9yZWxhdGlvblR5cGUpXG4gIH0gVU5JT04ge1xuICAgICMgQ2l0ZWQgYWN0c1xuICAgID9hY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VDaXRlcyA/cmVsYXRlZEFjdCAuXG4gICAgQklORChcImNpdGVkX2J5XCIgQVMgP3JlbGF0aW9uVHlwZSlcbiAgfSBVTklPTiB7XG4gICAgIyBCYXNlZCBvblxuICAgID9yZWxhdGVkQWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/YWN0IC5cbiAgICBCSU5EKFwiYmFzZWRfb25cIiBBUyA/cmVsYXRpb25UeXBlKVxuICB9XG5cbiAgP3JlbGF0ZWRBY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgICAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID9yZWxhdGVkVGF4IC5cblxuICA/cmVsYXRlZFRheCBza29zOm5vdGF0aW9uID9yZWxhdGVkU3JOdW1iZXIgO1xuICAgICAgICAgICAgICBza29zOnByZWZMYWJlbCA/cmVsYXRlZFRpdGxlIC5cblxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/cmVsYXRlZEFjdCBqb2x1eDpkYXRlRG9jdW1lbnQgP3JlbGF0aW9uRGF0ZSB9XG59XG5PUkRFUiBCWSA/cmVsYXRpb25UeXBlID9yZWxhdGVkU3JOdW1iZXJcbkxJTUlUICR7bGltaXR9XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IHRoZSBsZWdpc2xhdGl2ZSBoaXN0b3J5IChjb25zb2xpZGF0aW9uIGNoYWluKVxuICogSW4gSk9MVVgsIGNvbnNvbGlkYXRpb25zIGFyZSB0cmFja2VkIHZpYSBqb2x1eDppc1JlYWxpemVkQnkgZXhwcmVzc2lvbnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGVnaXNsYXRpdmVIaXN0b3J5UXVlcnkoXG4gIHNyTnVtYmVyOiBzdHJpbmcsXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2Vcbik6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90aXRsZSkgPSBcIiR7bGFuZ3VhZ2V9XCIpYFxuICAgIDogJyc7XG5cbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3ZlcnNpb24gP2RhdGUgP3RpdGxlID9jaGFuZ2VEZXNjcmlwdGlvblxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG4gICR7bGFuZ0ZpbHRlcn1cblxuICAjIEdldCBhbGwgdmVyc2lvbnMvZXhwcmVzc2lvbnMgaW4gdGhlIGNvbnNvbGlkYXRpb25cbiAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuICA/dmVyc2lvbiBqb2x1eDpkYXRlRG9jdW1lbnQgP2RhdGUgLlxuXG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6dGl0bGUgP2NoYW5nZURlc2NyaXB0aW9uIH1cbn1cbk9SREVSIEJZIERFU0MoP2RhdGUpXG5MSU1JVCAxMDBcbiAgYCk7XG59XG4iLCAiLyoqXG4gKiBTUEFSUUwgUXVlcmllcyBmb3IgTGVnaXNsYXRpb24gTWV0YWRhdGFcbiAqIFF1ZXJpZXMgdG8gcmV0cmlldmUgZGV0YWlsZWQgbWV0YWRhdGEgYWJvdXQgbGVnYWwgYWN0cyB1c2luZyBKT0xVWCBvbnRvbG9neVxuICpcbiAqIEZlZGxleCBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiB3b3JrXG4gKiAtIGpvbHV4OkV4cHJlc3Npb24gPSBMYW5ndWFnZS1zcGVjaWZpYyByZWFsaXphdGlvbiAodmlhIGpvbHV4OmlzUmVhbGl6ZWRCeSlcbiAqIC0gam9sdXg6TWFuaWZlc3RhdGlvbiA9IFBoeXNpY2FsIGZvcm1hdCAodmlhIGpvbHV4OmlzRW1ib2RpZWRCeSlcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqIC0gVGl0bGVzOiB0YXhvbm9teSBza29zOnByZWZMYWJlbCAod2l0aCBsYW5ndWFnZSB0YWdzKVxuICovXG5cbmltcG9ydCB7IHdpdGhQcmVmaXhlcyB9IGZyb20gJy4vcHJlZml4ZXMuanMnO1xuaW1wb3J0IHsgZXNjYXBlRm9yU1BBUlFMIH0gZnJvbSAnLi4vc3BhcnFsLWNsaWVudC5qcyc7XG5pbXBvcnQgeyBMYW5ndWFnZSB9IGZyb20gJy4uL3R5cGVzL2xlZ2lzbGF0aW9uLmpzJztcblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBjb21wcmVoZW5zaXZlIG1ldGFkYXRhIGZvciBhIGxlZ2FsIGFjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRNZXRhZGF0YVF1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcsIGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoTEFORyg/dGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3QgP3NyTnVtYmVyID90aXRsZSA/YWJicmV2aWF0aW9uID9hY3RUeXBlID9kYXRlRG9jdW1lbnQgP2RhdGVJbkZvcmNlXG4gICAgICAgP2RhdGVBYnJvZ2F0aW9uID9wdWJsaWNhdGlvblN0YXR1cyA/cmVzcG9uc2libGVBdXRob3JpdHkgP2xlZ2FsQmFzaXNcbiAgICAgICA/Y2xhc3NpZmljYXRpb25OdW1iZXIgP3ZlcnNpb24gP2V4cHJlc3Npb25MYW5ndWFnZSA/aW5Gb3JjZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIDtcbiAgICAgICAgICAgIHNrb3M6cHJlZkxhYmVsID90aXRsZSAuXG5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG4gICR7bGFuZ0ZpbHRlcn1cblxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6dGl0bGVTaG9ydCA/YWJicmV2aWF0aW9uIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnR5cGVEb2N1bWVudCA/YWN0VHlwZSB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlRG9jdW1lbnQgP2RhdGVEb2N1bWVudCB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlRW50cnlJbkZvcmNlID9kYXRlSW5Gb3JjZSB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDpkYXRlTm9Mb25nZXJJbkZvcmNlID9kYXRlQWJyb2dhdGlvbiB9XG5cbiAgIyBJbiBmb3JjZSBzdGF0dXNcbiAgT1BUSU9OQUwge1xuICAgID9hY3Qgam9sdXg6aW5Gb3JjZSA/aW5Gb3JjZVN0YXR1cyAuXG4gICAgQklORCg/aW5Gb3JjZVN0YXR1cyA9IDxodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL3ZvY2FidWxhcnkvZW5mb3JjZW1lbnQtc3RhdHVzLzE+IEFTID9pbkZvcmNlKVxuICB9XG5cbiAgIyBBdXRob3JpdHkgYW5kIGJhc2lzXG4gIE9QVElPTkFMIHsgP2FjdCBkY3Rlcm1zOmNyZWF0b3IgP3Jlc3BvbnNpYmxlQXV0aG9yaXR5IH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmxlZ2FsUmVzb3VyY2VMZWdhbFJlc291cmNlQmFzZWRPbiA/bGVnYWxCYXNpcyB9XG5cbiAgIyBDbGFzc2lmaWNhdGlvbiBudW1iZXIgKHNhbWUgYXMgU1IpXG4gIEJJTkQoP3NyTnVtYmVyIEFTID9jbGFzc2lmaWNhdGlvbk51bWJlcilcblxuICAjIFZlcnNpb24gaW5mbyB2aWEgRXhwcmVzc2lvblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuICAgID92ZXJzaW9uIGpvbHV4Omxhbmd1YWdlID9leHByZXNzaW9uTGFuZ3VhZ2UgLlxuICB9XG59XG5MSU1JVCA1MFxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBhbGwgYXZhaWxhYmxlIGxhbmd1YWdlcyBmb3IgYSBsZWdhbCBhY3RcbiAqIFVzZXMgdGF4b25vbXkgcHJlZkxhYmVsIGxhbmd1YWdlIHRhZ3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR2V0TGFuZ3VhZ2VzUXVlcnkoc3JOdW1iZXI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9sYW5ndWFnZSA/dGl0bGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciA7XG4gICAgICAgICAgICBza29zOnByZWZMYWJlbCA/dGl0bGUgLlxuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gIEJJTkQoTEFORyg/dGl0bGUpIEFTID9sYW5ndWFnZSlcbiAgRklMVEVSKEJPVU5EKD9sYW5ndWFnZSkgJiYgP2xhbmd1YWdlICE9IFwiXCIpXG59XG5PUkRFUiBCWSA/bGFuZ3VhZ2VcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgcHVibGljYXRpb24gaW5mb3JtYXRpb25cbiAqIEluIEpPTFVYLCBwdWJsaWNhdGlvbnMgYXJlIHRyYWNrZWQgdmlhIEV4cHJlc3Npb25zIGFuZCBNYW5pZmVzdGF0aW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRQdWJsaWNhdGlvbkluZm9RdWVyeShzck51bWJlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP3B1YmxpY2F0aW9uID9wdWJsaWNhdGlvblR5cGUgP3B1YmxpY2F0aW9uRGF0ZSA/cHVibGljYXRpb25SZWZlcmVuY2UgP2NvbGxlY3Rpb25cbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gICMgUHVibGljYXRpb24gaW5mbyB2aWEgRXhwcmVzc2lvblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3B1YmxpY2F0aW9uIC5cbiAgICBPUFRJT05BTCB7ID9wdWJsaWNhdGlvbiBqb2x1eDp0eXBlRG9jdW1lbnQgP3B1YmxpY2F0aW9uVHlwZSB9XG4gICAgT1BUSU9OQUwgeyA/cHVibGljYXRpb24gam9sdXg6ZGF0ZURvY3VtZW50ID9wdWJsaWNhdGlvbkRhdGUgfVxuICAgIE9QVElPTkFMIHsgP3B1YmxpY2F0aW9uIGpvbHV4OnB1YmxpY2F0aW9uUmVmZXJlbmNlID9wdWJsaWNhdGlvblJlZmVyZW5jZSB9XG4gIH1cblxuICAjIENvbGxlY3Rpb24gbWVtYmVyc2hpcCB2aWEgdGF4b25vbXkgaGllcmFyY2h5XG4gIE9QVElPTkFMIHtcbiAgICA/dGF4b25vbXkgc2tvczpicm9hZGVyID9jb2xsZWN0aW9uIC5cbiAgfVxufVxuT1JERVIgQlkgREVTQyg/cHVibGljYXRpb25EYXRlKVxuTElNSVQgMjBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgc3ViamVjdHMva2V5d29yZHMgZm9yIGEgbGVnYWwgYWN0XG4gKiBVc2VzIHRheG9ub215IGJyb2FkZXIgY29uY2VwdHMgYW5kIGRjdGVybXM6c3ViamVjdFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRTdWJqZWN0c1F1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcsIGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBzdHJpbmcge1xuICBjb25zdCBsYW5nRmlsdGVyID0gbGFuZ3VhZ2VcbiAgICA/IGBGSUxURVIoIUJPVU5EKD9sYWJlbCkgfHwgTEFORyg/bGFiZWwpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9zdWJqZWN0ID9sYWJlbCA/c2NoZW1lXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEdldCBzdWJqZWN0cyBmcm9tIHRheG9ub215IGhpZXJhcmNoeSBvciBkY3Rlcm1zOnN1YmplY3RcbiAge1xuICAgID90YXhvbm9teSBza29zOmJyb2FkZXIgP3N1YmplY3QgLlxuICB9IFVOSU9OIHtcbiAgICA/YWN0IGRjdGVybXM6c3ViamVjdCA/c3ViamVjdCAuXG4gIH1cblxuICBPUFRJT05BTCB7ID9zdWJqZWN0IHNrb3M6cHJlZkxhYmVsID9sYWJlbCB9XG4gIE9QVElPTkFMIHsgP3N1YmplY3Qgc2tvczppblNjaGVtZSA/c2NoZW1lIH1cblxuICAke2xhbmdGaWx0ZXJ9XG59XG5PUkRFUiBCWSA/bGFiZWxcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgcmVzcG9uc2libGUgYXV0aG9yaXR5L2NyZWF0b3JcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR2V0QXV0aG9yaXR5UXVlcnkoc3JOdW1iZXI6IHN0cmluZywgbGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUighQk9VTkQoP2F1dGhvcml0eU5hbWUpIHx8IExBTkcoP2F1dGhvcml0eU5hbWUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hdXRob3JpdHkgP2F1dGhvcml0eU5hbWUgP2F1dGhvcml0eVR5cGVcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6Y2xhc3NpZmllZEJ5VGF4b25vbXlFbnRyeSA/dGF4b25vbXkgLlxuXG4gID90YXhvbm9teSBza29zOm5vdGF0aW9uID9zck51bWJlciAuXG4gIEZJTFRFUihTVFIoP3NyTnVtYmVyKSA9IFwiJHtlc2NhcGVGb3JTUEFSUUwoc3JOdW1iZXIpfVwiKVxuXG4gIHtcbiAgICA/YWN0IGRjdGVybXM6Y3JlYXRvciA/YXV0aG9yaXR5IC5cbiAgfSBVTklPTiB7XG4gICAgP2FjdCBqb2x1eDpyZXNwb25zaWJsZURlcGFydG1lbnQgP2F1dGhvcml0eSAuXG4gIH1cblxuICBPUFRJT05BTCB7ID9hdXRob3JpdHkgcmRmczpsYWJlbCA/YXV0aG9yaXR5TmFtZSB9XG4gIE9QVElPTkFMIHsgP2F1dGhvcml0eSBza29zOnByZWZMYWJlbCA/YXV0aG9yaXR5TmFtZSB9XG4gIE9QVElPTkFMIHsgP2F1dGhvcml0eSBhID9hdXRob3JpdHlUeXBlIH1cblxuICAke2xhbmdGaWx0ZXJ9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IHZlcnNpb24gaGlzdG9yeVxuICogSW4gSk9MVVgsIHZlcnNpb25zIGFyZSB0cmFja2VkIHZpYSBFeHByZXNzaW9uc1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRWZXJzaW9uSGlzdG9yeVF1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/dmVyc2lvbiA/dmVyc2lvbkRhdGUgP3ZlcnNpb25UeXBlID90aXRsZVxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP3ZlcnNpb24gLlxuXG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6ZGF0ZURvY3VtZW50ID92ZXJzaW9uRGF0ZSB9XG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6dHlwZURvY3VtZW50ID92ZXJzaW9uVHlwZSB9XG4gIE9QVElPTkFMIHsgP3ZlcnNpb24gam9sdXg6dGl0bGUgP3RpdGxlIH1cbn1cbk9SREVSIEJZIERFU0MoP3ZlcnNpb25EYXRlKVxuTElNSVQgNTBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgbGVnYWwgZWZmZWN0L3N0YXR1cyBpbmZvcm1hdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRMZWdhbFN0YXR1c1F1ZXJ5KHNyTnVtYmVyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/c3RhdHVzID9pbkZvcmNlID9kYXRlSW5Gb3JjZSA/ZGF0ZUFicm9nYXRpb24gP2Ficm9nYXRlZEJ5XG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICBPUFRJT05BTCB7XG4gICAgP2FjdCBqb2x1eDppbkZvcmNlID9pbkZvcmNlU3RhdHVzIC5cbiAgICBCSU5EKD9pbkZvcmNlU3RhdHVzID0gPGh0dHBzOi8vZmVkbGV4LmRhdGEuYWRtaW4uY2gvdm9jYWJ1bGFyeS9lbmZvcmNlbWVudC1zdGF0dXMvMT4gQVMgP2luRm9yY2UpXG4gIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmRhdGVFbnRyeUluRm9yY2UgP2RhdGVJbkZvcmNlIH1cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OmRhdGVOb0xvbmdlckluRm9yY2UgP2RhdGVBYnJvZ2F0aW9uIH1cblxuICAjIENoZWNrIGlmIGFicm9nYXRlZCBieSBhbm90aGVyIGFjdFxuICBPUFRJT05BTCB7XG4gICAgP2Ficm9nYXRpbmdBY3Qgam9sdXg6bGVnYWxSZXNvdXJjZUxlZ2FsUmVzb3VyY2VSZXBlYWxzID9hY3QgLlxuICAgID9hYnJvZ2F0aW5nQWN0IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP2Ficm9nYXRpbmdUYXggLlxuICAgID9hYnJvZ2F0aW5nVGF4IHNrb3M6bm90YXRpb24gP2Ficm9nYXRlZEJ5IC5cbiAgfVxuXG4gIEJJTkQoXG4gICAgSUYoQk9VTkQoP2RhdGVBYnJvZ2F0aW9uKSwgXCJhYnJvZ2F0ZWRcIixcbiAgICAgIElGKEJPVU5EKD9kYXRlSW5Gb3JjZSksIFwiaW5fZm9yY2VcIiwgXCJwZW5kaW5nXCIpXG4gICAgKSBBUyA/c3RhdHVzXG4gIClcbn1cbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgZG9jdW1lbnQgc3RydWN0dXJlICh0YWJsZSBvZiBjb250ZW50cylcbiAqIFVzZXMgam9sdXg6aGFzUGFydCBmb3IgaGllcmFyY2hpY2FsIHN0cnVjdHVyZVxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRHZXRTdHJ1Y3R1cmVRdWVyeShzck51bWJlcjogc3RyaW5nLCBsYW5ndWFnZT86IExhbmd1YWdlKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKCFCT1VORCg/cGFydFRpdGxlKSB8fCBMQU5HKD9wYXJ0VGl0bGUpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9wYXJ0ID9wYXJ0TnVtYmVyID9wYXJ0VGl0bGUgP3BhcnRUeXBlID9wYXJlbnRQYXJ0XG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIEdldCBzdHJ1Y3R1cmFsIHBhcnRzIChjaGFwdGVycywgc2VjdGlvbnMsIGFydGljbGVzKVxuICA/YWN0IGpvbHV4Omhhc1BhcnQrID9wYXJ0IC5cblxuICA/cGFydCBqb2x1eDpudW1iZXIgP3BhcnROdW1iZXIgLlxuXG4gIE9QVElPTkFMIHtcbiAgICA/cGFydCBqb2x1eDppc1JlYWxpemVkQnkgP3BhcnRFeHByIC5cbiAgICA/cGFydEV4cHIgam9sdXg6dGl0bGUgP3BhcnRUaXRsZSAuXG4gIH1cbiAgT1BUSU9OQUwgeyA/cGFydCBhID9wYXJ0VHlwZSB9XG5cbiAgIyBHZXQgcGFyZW50IHJlbGF0aW9uc2hpcCBmb3IgaGllcmFyY2h5XG4gIE9QVElPTkFMIHtcbiAgICA/cGFyZW50UGFydCBqb2x1eDpoYXNQYXJ0ID9wYXJ0IC5cbiAgICBGSUxURVIoP3BhcmVudFBhcnQgIT0gP2FjdClcbiAgfVxuXG4gICR7bGFuZ0ZpbHRlcn1cbn1cbk9SREVSIEJZID9wYXJ0TnVtYmVyXG5MSU1JVCA1MDBcbiAgYCk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBxdWVyeSB0byBnZXQgZG9jdW1lbnQgZm9ybWF0L2VuY29kaW5nIGluZm9ybWF0aW9uXG4gKiBJbiBKT0xVWCwgZm9ybWF0cyBhcmUgdmlhIE1hbmlmZXN0YXRpb25zIChqb2x1eDppc0VtYm9kaWVkQnkpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdldEZvcm1hdEluZm9RdWVyeShzck51bWJlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgRElTVElOQ1QgP2Zvcm1hdCA/Zm9ybWF0VHlwZSA/ZW5jb2RpbmcgP2ZpbGVTaXplID9kb3dubG9hZFVybFxuV0hFUkUge1xuICA/YWN0IGEgam9sdXg6QWN0IDtcbiAgICAgICBqb2x1eDpjbGFzc2lmaWVkQnlUYXhvbm9teUVudHJ5ID90YXhvbm9teSAuXG5cbiAgP3RheG9ub215IHNrb3M6bm90YXRpb24gP3NyTnVtYmVyIC5cbiAgRklMVEVSKFNUUig/c3JOdW1iZXIpID0gXCIke2VzY2FwZUZvclNQQVJRTChzck51bWJlcil9XCIpXG5cbiAgIyBFeHByZXNzaW9uIC0+IE1hbmlmZXN0YXRpb24gY2hhaW5cbiAgP2FjdCBqb2x1eDppc1JlYWxpemVkQnkgP2V4cHJlc3Npb24gLlxuICA/ZXhwcmVzc2lvbiBqb2x1eDppc0VtYm9kaWVkQnkgP21hbmlmZXN0YXRpb24gLlxuXG4gIE9QVElPTkFMIHsgP21hbmlmZXN0YXRpb24gZGN0ZXJtczpmb3JtYXQgP2Zvcm1hdCB9XG4gIE9QVElPTkFMIHsgP2Zvcm1hdCBkY3Rlcm1zOnR5cGUgP2Zvcm1hdFR5cGUgfVxuICBPUFRJT05BTCB7ID9mb3JtYXQgZGN0ZXJtczplbmNvZGluZyA/ZW5jb2RpbmcgfVxuICBPUFRJT05BTCB7ID9tYW5pZmVzdGF0aW9uIHNjaGVtYTpjb250ZW50U2l6ZSA/ZmlsZVNpemUgfVxuICBPUFRJT05BTCB7ID9tYW5pZmVzdGF0aW9uIHNjaGVtYTpjb250ZW50VXJsID9kb3dubG9hZFVybCB9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IHN0YXRpc3RpY2FsIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEdldFN0YXRpc3RpY3NRdWVyeShzck51bWJlcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgcmV0dXJuIHdpdGhQcmVmaXhlcyhgXG5TRUxFQ1QgP2FydGljbGVDb3VudCA/cGFydENvdW50XG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgLlxuICBGSUxURVIoU1RSKD9zck51bWJlcikgPSBcIiR7ZXNjYXBlRm9yU1BBUlFMKHNyTnVtYmVyKX1cIilcblxuICAjIENvdW50IGFydGljbGVzIChkaXJlY3QgcGFydHMpXG4gIHtcbiAgICBTRUxFQ1QgKENPVU5UKERJU1RJTkNUID9hcnRpY2xlKSBBUyA/YXJ0aWNsZUNvdW50KVxuICAgIFdIRVJFIHtcbiAgICAgID9hY3Qgam9sdXg6aGFzUGFydCA/YXJ0aWNsZSAuXG4gICAgICA/YXJ0aWNsZSBqb2x1eDpudW1iZXIgP251bSAuXG4gICAgfVxuICB9XG5cbiAgIyBDb3VudCBhbGwgcGFydHMgKHJlY3Vyc2l2ZSlcbiAge1xuICAgIFNFTEVDVCAoQ09VTlQoRElTVElOQ1QgP3BhcnQpIEFTID9wYXJ0Q291bnQpXG4gICAgV0hFUkUge1xuICAgICAgP2FjdCBqb2x1eDpoYXNQYXJ0KyA/cGFydCAuXG4gICAgfVxuICB9XG59XG4gIGApO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgcXVlcnkgdG8gZ2V0IGFsbCBhdmFpbGFibGUgU1IgbnVtYmVycyB3aXRoIHRoZWlyIG1ldGFkYXRhXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWlsZExpc3RBbGxBY3RzUXVlcnkoXG4gIGxhbmd1YWdlPzogTGFuZ3VhZ2UsXG4gIGxpbWl0OiBudW1iZXIgPSAxMDAsXG4gIG9mZnNldDogbnVtYmVyID0gMFxuKTogc3RyaW5nIHtcbiAgY29uc3QgbGFuZ0ZpbHRlciA9IGxhbmd1YWdlXG4gICAgPyBgRklMVEVSKExBTkcoP3RpdGxlKSA9IFwiJHtsYW5ndWFnZX1cIilgXG4gICAgOiAnJztcblxuICByZXR1cm4gd2l0aFByZWZpeGVzKGBcblNFTEVDVCBESVNUSU5DVCA/c3JOdW1iZXIgP3RpdGxlID9hYmJyZXZpYXRpb24gP2FjdFR5cGUgP2RhdGVJbkZvcmNlXG5XSEVSRSB7XG4gID9hY3QgYSBqb2x1eDpBY3QgO1xuICAgICAgIGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgP3RheG9ub215IC5cblxuICA/dGF4b25vbXkgc2tvczpub3RhdGlvbiA/c3JOdW1iZXIgO1xuICAgICAgICAgICAgc2tvczpwcmVmTGFiZWwgP3RpdGxlIC5cblxuICAke2xhbmdGaWx0ZXJ9XG5cbiAgT1BUSU9OQUwgeyA/YWN0IGpvbHV4OnRpdGxlU2hvcnQgP2FiYnJldmlhdGlvbiB9XG4gIE9QVElPTkFMIHsgP2FjdCBqb2x1eDp0eXBlRG9jdW1lbnQgP2FjdFR5cGUgfVxuICBPUFRJT05BTCB7ID9hY3Qgam9sdXg6ZGF0ZUVudHJ5SW5Gb3JjZSA/ZGF0ZUluRm9yY2UgfVxufVxuT1JERVIgQlkgP3NyTnVtYmVyXG5PRkZTRVQgJHtvZmZzZXR9XG5MSU1JVCAke2xpbWl0fVxuICBgKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIHF1ZXJ5IHRvIGdldCBhY3QgdHlwZXMgYXZhaWxhYmxlIGluIHRoZSBzeXN0ZW1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkTGlzdEFjdFR5cGVzUXVlcnkobGFuZ3VhZ2U/OiBMYW5ndWFnZSk6IHN0cmluZyB7XG4gIGNvbnN0IGxhbmdGaWx0ZXIgPSBsYW5ndWFnZVxuICAgID8gYEZJTFRFUihMQU5HKD90eXBlTGFiZWwpID0gXCIke2xhbmd1YWdlfVwiKWBcbiAgICA6ICcnO1xuXG4gIHJldHVybiB3aXRoUHJlZml4ZXMoYFxuU0VMRUNUIERJU1RJTkNUID9hY3RUeXBlID90eXBlTGFiZWwgKENPVU5UKD9hY3QpIEFTID9jb3VudClcbldIRVJFIHtcbiAgP2FjdCBhIGpvbHV4OkFjdCA7XG4gICAgICAgam9sdXg6dHlwZURvY3VtZW50ID9hY3RUeXBlIC5cblxuICBPUFRJT05BTCB7ID9hY3RUeXBlIHJkZnM6bGFiZWwgP3R5cGVMYWJlbCB9XG4gIE9QVElPTkFMIHsgP2FjdFR5cGUgc2tvczpwcmVmTGFiZWwgP3R5cGVMYWJlbCB9XG5cbiAgJHtsYW5nRmlsdGVyfVxufVxuR1JPVVAgQlkgP2FjdFR5cGUgP3R5cGVMYWJlbFxuT1JERVIgQlkgREVTQyg/Y291bnQpXG4gIGApO1xufVxuIiwgIi8qKlxuICogU3RhdGljIG1hcHBpbmcgb2YgU3dpc3MgbGF3IGFiYnJldmlhdGlvbnMgdG8gU1IgbnVtYmVycy5cbiAqIFVzZWQgYXMgYSBmYXN0IGxvb2t1cCBiZWZvcmUgZmFsbGluZyBiYWNrIHRvIFNQQVJRTCBhYmJyZXZpYXRpb24gcXVlcmllcyxcbiAqIHdoaWNoIGZhaWwgYmVjYXVzZSBGZWRsZXggZG9lc24ndCBwb3B1bGF0ZSBqb2x1eDp0aXRsZVNob3J0IG9yIHNrb3M6YWx0TGFiZWwuXG4gKlxuICogSW5jbHVkZXMgREUsIEZSLCBhbmQgSVQgYWJicmV2aWF0aW9uIHZhcmlhbnRzIChjYXNlLWluc2Vuc2l0aXZlIGxvb2t1cCkuXG4gKiBEYXRhIHNvdXJjZWQgZnJvbSBtY3Atc2VydmVycy1zcmMvb25saW5la29tbWVudGFyL3NyYy9sZWdpc2xhdGl2ZS1hY3RzLnRzXG4gKiBhbmQgbWNwLXNlcnZlcnMtc3JjL2ZlZGxleC1zcGFycWwvc3JjL3R5cGVzL2xlZ2lzbGF0aW9uLnRzLlxuICovXG5cbmNvbnN0IEFCQlJFVklBVElPTl9UT19TUjogUmVhZG9ubHlNYXA8c3RyaW5nLCBzdHJpbmc+ID0gbmV3IE1hcChbXG4gIC8vID09PSBDT05TVElUVVRJT05BTCBMQVcgPT09XG4gIC8vIEJ1bmRlc3ZlcmZhc3N1bmcgLyBDb25zdGl0dXRpb24gZmVkZXJhbGUgLyBDb3N0aXR1emlvbmUgZmVkZXJhbGVcbiAgWydidicsICcxMDEnXSxcbiAgWydjc3QnLCAnMTAxJ10sXG4gIFsnY3N0LicsICcxMDEnXSxcbiAgWydjb3N0JywgJzEwMSddLFxuICBbJ2Nvc3QuJywgJzEwMSddLFxuXG4gIC8vID09PSBDSVZJTCBMQVcgPT09XG4gIC8vIFppdmlsZ2VzZXR6YnVjaCAvIENvZGUgY2l2aWwgLyBDb2RpY2UgY2l2aWxlXG4gIFsnemdiJywgJzIxMCddLFxuICBbJ2NjJywgJzIxMCddLFxuXG4gIC8vIE9ibGlnYXRpb25lbnJlY2h0IC8gQ29kZSBkZXMgb2JsaWdhdGlvbnMgLyBDb2RpY2UgZGVsbGUgb2JibGlnYXppb25pXG4gIFsnb3InLCAnMjIwJ10sXG4gIFsnY28nLCAnMjIwJ10sXG5cbiAgLy8gPT09IENSSU1JTkFMIExBVyA9PT1cbiAgLy8gU3RyYWZnZXNldHpidWNoIC8gQ29kZSBwZW5hbCAvIENvZGljZSBwZW5hbGVcbiAgWydzdGdiJywgJzMxMS4wJ10sXG4gIFsnY3AnLCAnMzExLjAnXSxcblxuICAvLyA9PT0gUFJPQ0VEVVJBTCBMQVcgPT09XG4gIC8vIFppdmlscHJvemVzc29yZG51bmcgLyBDb2RlIGRlIHByb2NlZHVyZSBjaXZpbGUgLyBDb2RpY2UgZGkgcHJvY2VkdXJhIGNpdmlsZVxuICBbJ3pwbycsICcyNzInXSxcbiAgWydjcGMnLCAnMjcyJ10sXG5cbiAgLy8gU3RyYWZwcm96ZXNzb3JkbnVuZyAvIENvZGUgZGUgcHJvY2VkdXJlIHBlbmFsZSAvIENvZGljZSBkaSBwcm9jZWR1cmEgcGVuYWxlXG4gIFsnc3RwbycsICczMTIuMCddLFxuICBbJ2NwcCcsICczMTIuMCddLFxuXG4gIC8vIFNjaHVsZGJldHJlaWJ1bmdzLSB1bmQgS29ua3Vyc2dlc2V0eiAvIExQIC8gTEVGXG4gIFsnc2Noa2cnLCAnMjgxLjEnXSxcbiAgWydscCcsICcyODEuMSddLFxuICBbJ2xlZicsICcyODEuMSddLFxuXG4gIC8vID09PSBBRE1JTklTVFJBVElWRSBMQVcgPT09XG4gIC8vIFZlcndhbHR1bmdzdmVyZmFocmVuc2dlc2V0eiAvIFBBXG4gIFsndnd2ZycsICcxNzIuMDIxJ10sXG4gIFsncGEnLCAnMTcyLjAyMSddLFxuXG4gIC8vIEJ1bmRlc2dlcmljaHRzZ2VzZXR6IC8gTFRGXG4gIFsnYmdnJywgJzE3My4xMTAnXSxcbiAgWydsdGYnLCAnMTczLjExMCddLFxuXG4gIC8vID09PSBDT01NRVJDSUFMIExBVyA9PT1cbiAgLy8gQnVuZGVzZ2VzZXR6IGdlZ2VuIGRlbiB1bmxhdXRlcmVuIFdldHRiZXdlcmIgLyBMQ0QgLyBMQ1NsXG4gIFsndXdnJywgJzI0MSddLFxuICBbJ2xjZCcsICcyNDEnXSxcbiAgWydsY3NsJywgJzI0MSddLFxuXG4gIC8vIEthcnRlbGxnZXNldHogLyBMQ2FydFxuICBbJ2tnJywgJzI1MSddLFxuICBbJ2xjYXJ0JywgJzI1MSddLFxuXG4gIC8vID09PSBEQVRBIFBST1RFQ1RJT04gPT09XG4gIC8vIERhdGVuc2NodXR6Z2VzZXR6IC8gTFBEXG4gIFsnZHNnJywgJzIzNS4xJ10sXG4gIFsnbHBkJywgJzIzNS4xJ10sXG5cbiAgLy8gPT09IElOVEVMTEVDVFVBTCBQUk9QRVJUWSA9PT1cbiAgLy8gVXJoZWJlcnJlY2h0c2dlc2V0eiAvIExEQVxuICBbJ3VyZycsICcyMzEuMSddLFxuICBbJ2xkYScsICcyMzEuMSddLFxuXG4gIC8vIE1hcmtlbnNjaHV0emdlc2V0eiAvIExQTVxuICBbJ21zY2hnJywgJzIzMi4xMSddLFxuICBbJ2xwbScsICcyMzIuMTEnXSxcblxuICAvLyA9PT0gRU1QTE9ZTUVOVCAvIExBQk9SID09PVxuICAvLyBBcmJlaXRzZ2VzZXR6IC8gTFRyIC8gTExcbiAgWydhcmcnLCAnODIyLjExJ10sXG4gIFsnbHRyJywgJzgyMi4xMSddLFxuICBbJ2xsJywgJzgyMi4xMSddLFxuXG4gIC8vID09PSBUUkFOU1BPUlQgPT09XG4gIC8vIFN0cmFzc2VudmVya2VocnNnZXNldHogLyBMQ1IgLyBMQ1N0clxuICBbJ3N2ZycsICc3NDEuMDEnXSxcbiAgWydsY3InLCAnNzQxLjAxJ10sXG4gIFsnbGNzdHInLCAnNzQxLjAxJ10sXG5cbiAgLy8gPT09IElOU1VSQU5DRSA9PT1cbiAgLy8gVmVyc2ljaGVydW5nc3ZlcnRyYWdzZ2VzZXR6IC8gTENBXG4gIFsndnZnJywgJzIyMS4yMjkuMSddLFxuICBbJ2xjYScsICcyMjEuMjI5LjEnXSxcblxuICAvLyA9PT0gUFJJVkFURSBJTlRFUk5BVElPTkFMIExBVyA9PT1cbiAgLy8gSVBSRyAvIExESVBcbiAgWydpcHJnJywgJzI5MSddLFxuICBbJ2xkaXAnLCAnMjkxJ10sXG5cbiAgLy8gPT09IEFERElUSU9OQUwgQ09NTU9OIEFDVFMgPT09XG4gIC8vIEdsZWljaHN0ZWxsdW5nc2dlc2V0eiAvIExFZyAvIExQYXJcbiAgWydnbGcnLCAnMTUxLjEnXSxcbiAgWydsZWcnLCAnMTUxLjEnXSxcbiAgWydscGFyJywgJzE1MS4xJ10sXG5cbiAgLy8gQnVuZGVzZ2VzZXR6IFx1MDBGQ2JlciBkaWUgTWVocndlcnRzdGV1ZXIgLyBMVFZBIC8gTElWQVxuICBbJ213c3RnJywgJzY0MS4yMCddLFxuICBbJ2x0dmEnLCAnNjQxLjIwJ10sXG4gIFsnbGl2YScsICc2NDEuMjAnXSxcblxuICAvLyBCdW5kZXNnZXNldHogXHUwMEZDYmVyIGRpZSBkaXJla3RlIEJ1bmRlc3N0ZXVlciAvIExJRkRcbiAgWydkYmcnLCAnNjQyLjExJ10sXG4gIFsnbGlmZCcsICc2NDIuMTEnXSxcblxuICAvLyBTdGV1ZXJoYXJtb25pc2llcnVuZ3NnZXNldHogLyBMSElEXG4gIFsnc3RoZycsICc2NDIuMTQnXSxcbiAgWydsaGlkJywgJzY0Mi4xNCddLFxuXG4gIC8vIE1pZXRlIChUZW5hbmN5KSAtIFBhcnQgb2YgT1IgYnV0IGNvbW1vbmx5IHJlZmVyZW5jZWRcbiAgLy8gT1IgMjUzZmYsIG5vIHNlcGFyYXRlIFNSXG5cbiAgLy8gQnVuZGVzZ2VzZXR6IFx1MDBGQ2JlciBTY2h1bGRiZXRyZWlidW5nIHVuZCBLb25rdXJzIChhbHJlYWR5IGNvdmVyZWQgYXMgU2NoS0cpXG5cbiAgLy8gRnVzaW9uc2dlc2V0eiAvIExGdXNcbiAgWydmdXNnJywgJzIyMS4zMDEnXSxcbiAgWydsZnVzJywgJzIyMS4zMDEnXSxcblxuICAvLyBHd0cgLyBMQkEgKEFudGktTW9uZXkgTGF1bmRlcmluZylcbiAgWydnd2cnLCAnOTU1LjAnXSxcbiAgWydsYmEnLCAnOTU1LjAnXSxcblxuICAvLyBGSU5NQUdcbiAgWydmaW5tYWcnLCAnOTU2LjEnXSxcbiAgWydsZmlubWEnLCAnOTU2LjEnXSxcblxuICAvLyBGSURMRUcgLyBMU0ZpblxuICBbJ2ZpZGxlZycsICc5NTAuMSddLFxuICBbJ2xzZmluJywgJzk1MC4xJ10sXG5cbiAgLy8gRklOSUcgLyBMRUZpblxuICBbJ2ZpbmlnJywgJzk1NC4xJ10sXG4gIFsnbGVmaW4nLCAnOTU0LjEnXSxcbl0pO1xuXG4vKipcbiAqIExvb2sgdXAgYW4gU1IgbnVtYmVyIGJ5IGFiYnJldmlhdGlvbiAoY2FzZS1pbnNlbnNpdGl2ZSkuXG4gKiBSZXR1cm5zIHRoZSBTUiBudW1iZXIgc3RyaW5nIGlmIGZvdW5kLCBvciB1bmRlZmluZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb29rdXBTUkJ5QWJicmV2aWF0aW9uKGFiYnJldmlhdGlvbjogc3RyaW5nKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgLy8gTm9ybWFsaXplOiBsb3dlcmNhc2UsIHJlbW92ZSB0cmFpbGluZyBkb3RzXG4gIGNvbnN0IG5vcm1hbGl6ZWQgPSBhYmJyZXZpYXRpb24udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4rJC8sICcnKTtcbiAgcmV0dXJuIEFCQlJFVklBVElPTl9UT19TUi5nZXQobm9ybWFsaXplZCk7XG59XG4iLCAiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuXG4vKipcbiAqIEZlZGxleCBTUEFSUUwgTUNQIFNlcnZlclxuICpcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byBTd2lzcyBGZWRlcmFsIExlZ2lzbGF0aW9uIHZpYSB0aGUgRmVkbGV4IFNQQVJRTCBlbmRwb2ludC5cbiAqIFVzZXMgdGhlIEpPTFVYIG9udG9sb2d5IChiYXNlZCBvbiBGUkJSIG1vZGVsKSBmb3Igc3RydWN0dXJlZCBsZWdhbCBkYXRhLlxuICpcbiAqIEVuZHBvaW50OiBodHRwczovL2ZlZGxleC5kYXRhLmFkbWluLmNoL3NwYXJxbGVuZHBvaW50XG4gKiBEYXRhOiB+MjI4LDUwMCBsZWdhbCBvYmplY3RzIGluY2x1ZGluZyBTUi9SUyBjbGFzc2lmaWVkIGxlZ2lzbGF0aW9uXG4gKiBMaWNlbnNlOiBDQyBCWS1OQy1TQSA0LjBcbiAqXG4gKiBEYXRhIE1vZGVsIChGUkJSLWJhc2VkKTpcbiAqIC0gam9sdXg6QWN0ID0gUHJpbWFyeSBsZWdpc2xhdGlvbiB3b3JrXG4gKiAtIGpvbHV4OkV4cHJlc3Npb24gPSBMYW5ndWFnZS1zcGVjaWZpYyByZWFsaXphdGlvbiAodmlhIGpvbHV4OmlzUmVhbGl6ZWRCeSlcbiAqIC0gam9sdXg6TWFuaWZlc3RhdGlvbiA9IFBoeXNpY2FsIGZvcm1hdCAodmlhIGpvbHV4OmlzRW1ib2RpZWRCeSlcbiAqIC0gU1IgbnVtYmVycyB2aWEgdGF4b25vbXk6IGpvbHV4OmNsYXNzaWZpZWRCeVRheG9ub215RW50cnkgXHUyMTkyIHNrb3M6bm90YXRpb25cbiAqIC0gVGl0bGVzOiB0YXhvbm9teSBza29zOnByZWZMYWJlbCAod2l0aCBsYW5ndWFnZSB0YWdzKVxuICpcbiAqIFRvb2xzOlxuICogLSBsb29rdXBfc3RhdHV0ZTogTG9vayB1cCBhIGxlZ2FsIGFjdCBieSBTUiBudW1iZXIgb3IgYWJicmV2aWF0aW9uXG4gKiAtIGdldF9hcnRpY2xlOiBSZXRyaWV2ZSBzcGVjaWZpYyBhcnRpY2xlcyB3aXRoaW4gYSBsZWdhbCBhY3RcbiAqIC0gc2VhcmNoX2xlZ2lzbGF0aW9uOiBGdWxsLXRleHQgYW5kIGZpbHRlcmVkIHNlYXJjaCBhY3Jvc3MgbGVnaXNsYXRpb25cbiAqIC0gZmluZF9yZWxhdGVkOiBGaW5kIHJlbGF0ZWQgbGVnaXNsYXRpb24gKGFtZW5kbWVudHMsIGNpdGF0aW9ucywgc2FtZSBkb21haW4pXG4gKiAtIGdldF9tZXRhZGF0YTogR2V0IGNvbXByZWhlbnNpdmUgbWV0YWRhdGEgYWJvdXQgYSBsZWdhbCBhY3RcbiAqL1xuXG5pbXBvcnQgeyBTZXJ2ZXIgfSBmcm9tIFwiQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zZXJ2ZXIvaW5kZXguanNcIjtcbmltcG9ydCB7IFN0ZGlvU2VydmVyVHJhbnNwb3J0IH0gZnJvbSBcIkBtb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL3N0ZGlvLmpzXCI7XG5pbXBvcnQge1xuICBDYWxsVG9vbFJlcXVlc3RTY2hlbWEsXG4gIExpc3RUb29sc1JlcXVlc3RTY2hlbWEsXG59IGZyb20gXCJAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3R5cGVzLmpzXCI7XG5cbmltcG9ydCB7IFNQQVJRTENsaWVudCwgY3JlYXRlRmVkbGV4Q2xpZW50IH0gZnJvbSAnLi9zcGFycWwtY2xpZW50LmpzJztcbmltcG9ydCB7XG4gIGJ1aWxkTG9va3VwU3RhdHV0ZVF1ZXJ5LFxuICBidWlsZExvb2t1cEJ5QWJicmV2aWF0aW9uUXVlcnksXG4gIGJ1aWxkR2V0QXJ0aWNsZVF1ZXJ5LFxuICBidWlsZEdldEFydGljbGVQYXJhZ3JhcGhRdWVyeSxcbiAgLy8gYnVpbGRMaXN0QXJ0aWNsZXNRdWVyeSwgLy8gUmVzZXJ2ZWQgZm9yIGZ1dHVyZSBhcnRpY2xlIGxpc3RpbmcgZW5kcG9pbnRcbiAgYnVpbGRTZWFyY2hRdWVyeSxcbiAgYnVpbGRTZWFyY2hDb3VudFF1ZXJ5LFxuICBidWlsZFNlYXJjaEJ5RG9tYWluUXVlcnksXG4gIGJ1aWxkU2VhcmNoQnlEYXRlUXVlcnksXG4gIGJ1aWxkRmluZEFsbFJlbGF0ZWRRdWVyeSxcbiAgYnVpbGRMZWdpc2xhdGl2ZUhpc3RvcnlRdWVyeSxcbiAgYnVpbGRHZXRNZXRhZGF0YVF1ZXJ5LFxuICBidWlsZEdldExhbmd1YWdlc1F1ZXJ5LFxuICBidWlsZEdldFN1YmplY3RzUXVlcnksXG4gIGJ1aWxkR2V0VmVyc2lvbkhpc3RvcnlRdWVyeSxcbiAgYnVpbGRHZXRMZWdhbFN0YXR1c1F1ZXJ5LFxuICBidWlsZEdldFN0cnVjdHVyZVF1ZXJ5LFxuICBMRUdBTF9ET01BSU5TLFxufSBmcm9tICcuL3F1ZXJpZXMvaW5kZXguanMnO1xuXG5pbXBvcnQgeyBsb29rdXBTUkJ5QWJicmV2aWF0aW9uIH0gZnJvbSAnLi9hYmJyZXZpYXRpb24tbWFwLmpzJztcblxuaW1wb3J0IHR5cGUge1xuICBMYW5ndWFnZSxcbiAgTGVnYWxBY3QsXG4gIEFydGljbGUsXG4gIFJlbGF0ZWRBY3QsXG4gIFNlYXJjaEZpbHRlcnMsXG4gIExvb2t1cFN0YXR1dGVJbnB1dCxcbiAgTG9va3VwU3RhdHV0ZVJlc3VsdCxcbiAgR2V0QXJ0aWNsZUlucHV0LFxuICBHZXRBcnRpY2xlUmVzdWx0LFxuICBTZWFyY2hMZWdpc2xhdGlvbklucHV0LFxuICBTZWFyY2hMZWdpc2xhdGlvblJlc3VsdCxcbiAgRmluZFJlbGF0ZWRJbnB1dCxcbiAgRmluZFJlbGF0ZWRSZXN1bHQsXG4gIEdldE1ldGFkYXRhSW5wdXQsXG4gIEdldE1ldGFkYXRhUmVzdWx0LFxuICBTUEFSUUxCaW5kaW5nLFxuICBSZWxhdGlvblR5cGUsXG59IGZyb20gJy4vdHlwZXMvbGVnaXNsYXRpb24uanMnO1xuXG4vKipcbiAqIEdsb2JhbCBTUEFSUUwgY2xpZW50IGluc3RhbmNlXG4gKi9cbmxldCBzcGFycWxDbGllbnQ6IFNQQVJRTENsaWVudDtcblxuLyoqXG4gKiBJbml0aWFsaXplIHRoZSBTUEFSUUwgY2xpZW50XG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVDbGllbnQoKTogdm9pZCB7XG4gIHNwYXJxbENsaWVudCA9IGNyZWF0ZUZlZGxleENsaWVudCh7XG4gICAgdGltZW91dDogNjAwMDAsIC8vIDYwIHNlY29uZHMgZm9yIGNvbXBsZXggcXVlcmllc1xuICAgIG1heFJldHJpZXM6IDMsXG4gICAgcmV0cnlEZWxheTogMjAwMCxcbiAgfSk7XG5cbiAgY29uc29sZS5lcnJvcihgRmVkbGV4IFNQQVJRTCBjbGllbnQgaW5pdGlhbGl6ZWQgLSBlbmRwb2ludDogJHtzcGFycWxDbGllbnQuZ2V0RW5kcG9pbnQoKX1gKTtcbn1cblxuLyoqXG4gKiBMb29rIHVwIGEgbGVnYWwgYWN0IGJ5IFNSIG51bWJlciBvciBhYmJyZXZpYXRpb25cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9va3VwU3RhdHV0ZShpbnB1dDogTG9va3VwU3RhdHV0ZUlucHV0KTogUHJvbWlzZTxMb29rdXBTdGF0dXRlUmVzdWx0PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgcXVlcnk6IHN0cmluZztcbiAgICBsZXQgc2VhcmNoVHlwZTogJ3NyTnVtYmVyJyB8ICdhYmJyZXZpYXRpb24nO1xuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIGlucHV0IGlzIFNSIG51bWJlciBvciBhYmJyZXZpYXRpb25cbiAgICBpZiAoL15cXGQvLnRlc3QoaW5wdXQuaWRlbnRpZmllcikpIHtcbiAgICAgIC8vIFN0YXJ0cyB3aXRoIGRpZ2l0IFx1MjE5MiBTUiBudW1iZXJcbiAgICAgIHF1ZXJ5ID0gYnVpbGRMb29rdXBTdGF0dXRlUXVlcnkoaW5wdXQuaWRlbnRpZmllciwgaW5wdXQubGFuZ3VhZ2UpO1xuICAgICAgc2VhcmNoVHlwZSA9ICdzck51bWJlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIExpa2VseSBhYmJyZXZpYXRpb24gKGUuZy4sIFwiT1JcIiwgXCJaR0JcIilcbiAgICAgIC8vIFRyeSBsb2NhbCBhYmJyZXZpYXRpb24gbWFwIGZpcnN0IChTUEFSUUwgYWJicmV2aWF0aW9uIHF1ZXJ5IGlzIHVucmVsaWFibGUpXG4gICAgICBjb25zdCBzck51bWJlciA9IGxvb2t1cFNSQnlBYmJyZXZpYXRpb24oaW5wdXQuaWRlbnRpZmllcik7XG4gICAgICBpZiAoc3JOdW1iZXIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgQWJicmV2aWF0aW9uIFwiJHtpbnB1dC5pZGVudGlmaWVyfVwiIHJlc29sdmVkIHRvIFNSICR7c3JOdW1iZXJ9IHZpYSBsb2NhbCBtYXBgKTtcbiAgICAgICAgcXVlcnkgPSBidWlsZExvb2t1cFN0YXR1dGVRdWVyeShzck51bWJlciwgaW5wdXQubGFuZ3VhZ2UpO1xuICAgICAgICBzZWFyY2hUeXBlID0gJ2FiYnJldmlhdGlvbic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGYWxsIGJhY2sgdG8gU1BBUlFMIGFiYnJldmlhdGlvbiBxdWVyeSBmb3IgdW5rbm93biBhYmJyZXZpYXRpb25zXG4gICAgICAgIHF1ZXJ5ID0gYnVpbGRMb29rdXBCeUFiYnJldmlhdGlvblF1ZXJ5KGlucHV0LmlkZW50aWZpZXIsIGlucHV0Lmxhbmd1YWdlKTtcbiAgICAgICAgc2VhcmNoVHlwZSA9ICdhYmJyZXZpYXRpb24nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHNwYXJxbENsaWVudC5xdWVyeShxdWVyeSk7XG4gICAgY29uc3QgYmluZGluZ3MgPSByZXN1bHQucmVzdWx0cy5iaW5kaW5ncztcblxuICAgIGlmIChiaW5kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgc2VhcmNoVGltZU1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBHcm91cCBieSBhY3QgVVJJIHRvIGhhbmRsZSBtdWx0aXBsZSBsYW5ndWFnZSB2ZXJzaW9uc1xuICAgIGNvbnN0IGFjdEdyb3VwcyA9IHNwYXJxbENsaWVudC5ncm91cEJpbmRpbmdzKGJpbmRpbmdzLCAnYWN0Jyk7XG4gICAgY29uc3QgYWN0czogTGVnYWxBY3RbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbYWN0VXJpLCBhY3RCaW5kaW5nc10gb2YgYWN0R3JvdXBzKSB7XG4gICAgICBjb25zdCBmaXJzdEJpbmRpbmcgPSBhY3RCaW5kaW5nc1swXTtcblxuICAgICAgY29uc3QgYWN0OiBMZWdhbEFjdCA9IHtcbiAgICAgICAgdXJpOiBhY3RVcmksXG4gICAgICAgIHNyTnVtYmVyOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5zck51bWJlcikgfHwgJycsXG4gICAgICAgIHRpdGxlOiBzcGFycWxDbGllbnQuZXh0cmFjdE11bHRpbGluZ3VhbFZhbHVlKGFjdEJpbmRpbmdzLCAndGl0bGUnKSxcbiAgICAgICAgYWJicmV2aWF0aW9uOiBzcGFycWxDbGllbnQuZXh0cmFjdE11bHRpbGluZ3VhbFZhbHVlKGFjdEJpbmRpbmdzLCAnYWJicmV2aWF0aW9uJyksXG4gICAgICAgIGFjdFR5cGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmFjdFR5cGUpLFxuICAgICAgICBkYXRlRG9jdW1lbnQ6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmRhdGVEb2N1bWVudCksXG4gICAgICAgIGRhdGVJbkZvcmNlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5kYXRlSW5Gb3JjZSksXG4gICAgICAgIHN0YXR1czogZmlyc3RCaW5kaW5nLmluRm9yY2UgPyAnaW5fZm9yY2UnIDogJ3Vua25vd24nLFxuICAgICAgfTtcblxuICAgICAgYWN0cy5wdXNoKGFjdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgYWN0cyxcbiAgICAgIHNlYXJjaFR5cGUsXG4gICAgICBzZWFyY2hUaW1lTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdMb29rdXAgc3RhdHV0ZSBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGEgc3BlY2lmaWMgYXJ0aWNsZSB3aXRoaW4gYSBsZWdhbCBhY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0QXJ0aWNsZShpbnB1dDogR2V0QXJ0aWNsZUlucHV0KTogUHJvbWlzZTxHZXRBcnRpY2xlUmVzdWx0PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgdHJ5IHtcbiAgICBsZXQgcXVlcnk6IHN0cmluZztcblxuICAgIGlmIChpbnB1dC5wYXJhZ3JhcGgpIHtcbiAgICAgIHF1ZXJ5ID0gYnVpbGRHZXRBcnRpY2xlUGFyYWdyYXBoUXVlcnkoXG4gICAgICAgIGlucHV0LnNyTnVtYmVyLFxuICAgICAgICBpbnB1dC5hcnRpY2xlTnVtYmVyLFxuICAgICAgICBpbnB1dC5wYXJhZ3JhcGgsXG4gICAgICAgIGlucHV0Lmxhbmd1YWdlXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBxdWVyeSA9IGJ1aWxkR2V0QXJ0aWNsZVF1ZXJ5KFxuICAgICAgICBpbnB1dC5zck51bWJlcixcbiAgICAgICAgaW5wdXQuYXJ0aWNsZU51bWJlcixcbiAgICAgICAgaW5wdXQubGFuZ3VhZ2VcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3BhcnFsQ2xpZW50LnF1ZXJ5KHF1ZXJ5KTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzO1xuXG4gICAgaWYgKGJpbmRpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZm91bmQ6IGZhbHNlLFxuICAgICAgICBzZWFyY2hUaW1lTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEV4dHJhY3QgYWN0IGluZm9ybWF0aW9uXG4gICAgY29uc3QgZmlyc3RCaW5kaW5nID0gYmluZGluZ3NbMF07XG4gICAgY29uc3QgYWN0SW5mbyA9IHtcbiAgICAgIHVyaTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuYWN0KSB8fCAnJyxcbiAgICAgIHNyTnVtYmVyOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGZpcnN0QmluZGluZy5zck51bWJlcikgfHwgJycsXG4gICAgICB0aXRsZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RNdWx0aWxpbmd1YWxWYWx1ZShiaW5kaW5ncywgJ2FjdFRpdGxlJyksXG4gICAgfTtcblxuICAgIC8vIEdyb3VwIGJ5IGFydGljbGUgdG8gaGFuZGxlIHBhcmFncmFwaHMgYW5kIGxldHRlcnNcbiAgICBjb25zdCBhcnRpY2xlR3JvdXBzID0gc3BhcnFsQ2xpZW50Lmdyb3VwQmluZGluZ3MoYmluZGluZ3MsICdhcnRpY2xlJyk7XG4gICAgY29uc3QgYXJ0aWNsZXM6IEFydGljbGVbXSA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBbYXJ0aWNsZVVyaSwgYXJ0aWNsZUJpbmRpbmdzXSBvZiBhcnRpY2xlR3JvdXBzKSB7XG4gICAgICBjb25zdCBhcnRpY2xlRmlyc3QgPSBhcnRpY2xlQmluZGluZ3NbMF07XG5cbiAgICAgIC8vIEV4dHJhY3QgcGFyYWdyYXBoc1xuICAgICAgY29uc3QgcGFyYWdyYXBoczogQXJyYXk8e1xuICAgICAgICBudW1iZXI6IHN0cmluZztcbiAgICAgICAgdGV4dD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gICAgICAgIGxldHRlcnM/OiBBcnJheTx7IGxpdGVyYWw6IHN0cmluZzsgdGV4dD86IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gfT47XG4gICAgICB9PiA9IFtdO1xuXG4gICAgICBjb25zdCBwYXJhZ3JhcGhHcm91cHMgPSBzcGFycWxDbGllbnQuZ3JvdXBCaW5kaW5ncyhhcnRpY2xlQmluZGluZ3MsICdwYXJhZ3JhcGhOdW0nKTtcbiAgICAgIGZvciAoY29uc3QgW3BhcmFncmFwaE51bSwgcGFyYWdyYXBoQmluZGluZ3NdIG9mIHBhcmFncmFwaEdyb3Vwcykge1xuICAgICAgICBpZiAoIXBhcmFncmFwaE51bSkgY29udGludWU7XG5cbiAgICAgICAgLy8gRXh0cmFjdCBsZXR0ZXJzIHdpdGhpbiBwYXJhZ3JhcGhcbiAgICAgICAgY29uc3QgbGV0dGVyczogQXJyYXk8eyBsaXRlcmFsOiBzdHJpbmc7IHRleHQ/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IH0+ID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYmluZGluZyBvZiBwYXJhZ3JhcGhCaW5kaW5ncykge1xuICAgICAgICAgIGNvbnN0IGxldHRlckxpdCA9IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5sZXR0ZXJMaXQpO1xuICAgICAgICAgIGlmIChsZXR0ZXJMaXQpIHtcbiAgICAgICAgICAgIGxldHRlcnMucHVzaCh7XG4gICAgICAgICAgICAgIGxpdGVyYWw6IGxldHRlckxpdCxcbiAgICAgICAgICAgICAgdGV4dDogYmluZGluZy5sZXR0ZXJUZXh0ID8geyBbYmluZGluZy5sZXR0ZXJUZXh0Wyd4bWw6bGFuZyddIHx8ICdkZSddOiBiaW5kaW5nLmxldHRlclRleHQudmFsdWUgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFncmFwaHMucHVzaCh7XG4gICAgICAgICAgbnVtYmVyOiBwYXJhZ3JhcGhOdW0sXG4gICAgICAgICAgdGV4dDogc3BhcnFsQ2xpZW50LmV4dHJhY3RNdWx0aWxpbmd1YWxWYWx1ZShwYXJhZ3JhcGhCaW5kaW5ncywgJ3BhcmFncmFwaFRleHQnKSxcbiAgICAgICAgICBsZXR0ZXJzOiBsZXR0ZXJzLmxlbmd0aCA+IDAgPyBsZXR0ZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgYXJ0aWNsZTogQXJ0aWNsZSA9IHtcbiAgICAgICAgdXJpOiBhcnRpY2xlVXJpLFxuICAgICAgICBudW1iZXI6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYXJ0aWNsZUZpcnN0LmFydGljbGVOdW1iZXIpIHx8ICcnLFxuICAgICAgICB0aXRsZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RNdWx0aWxpbmd1YWxWYWx1ZShhcnRpY2xlQmluZGluZ3MsICdhcnRpY2xlVGl0bGUnKSxcbiAgICAgICAgdGV4dDogc3BhcnFsQ2xpZW50LmV4dHJhY3RNdWx0aWxpbmd1YWxWYWx1ZShhcnRpY2xlQmluZGluZ3MsICdhcnRpY2xlVGV4dCcpLFxuICAgICAgICBwYXJhZ3JhcGhzOiBwYXJhZ3JhcGhzLmxlbmd0aCA+IDAgPyBwYXJhZ3JhcGhzIDogdW5kZWZpbmVkLFxuICAgICAgfTtcblxuICAgICAgYXJ0aWNsZXMucHVzaChhcnRpY2xlKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgZm91bmQ6IHRydWUsXG4gICAgICBhY3Q6IGFjdEluZm8sXG4gICAgICBhcnRpY2xlcyxcbiAgICAgIHNlYXJjaFRpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0dldCBhcnRpY2xlIGZhaWxlZDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2ggYWNyb3NzIGxlZ2lzbGF0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNlYXJjaExlZ2lzbGF0aW9uKGlucHV0OiBTZWFyY2hMZWdpc2xhdGlvbklucHV0KTogUHJvbWlzZTxTZWFyY2hMZWdpc2xhdGlvblJlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZmlsdGVyczogU2VhcmNoRmlsdGVycyA9IHtcbiAgICAgIGxhbmd1YWdlOiBpbnB1dC5sYW5ndWFnZSxcbiAgICAgIGFjdFR5cGU6IGlucHV0LmFjdFR5cGUsXG4gICAgICBzdGF0dXM6IGlucHV0LnN0YXR1cyxcbiAgICAgIHNyTnVtYmVyUHJlZml4OiBpbnB1dC5zck51bWJlclByZWZpeCxcbiAgICAgIGxpbWl0OiBpbnB1dC5saW1pdCB8fCA1MCxcbiAgICAgIG9mZnNldDogaW5wdXQub2Zmc2V0IHx8IDAsXG4gICAgfTtcblxuICAgIC8vIEJ1aWxkIGFwcHJvcHJpYXRlIHF1ZXJ5IGJhc2VkIG9uIHNlYXJjaCB0eXBlXG4gICAgbGV0IHF1ZXJ5OiBzdHJpbmc7XG4gICAgbGV0IGNvdW50UXVlcnk6IHN0cmluZyB8IHVuZGVmaW5lZDtcblxuICAgIGlmIChpbnB1dC5kb21haW4gJiYgIWlucHV0LnF1ZXJ5KSB7XG4gICAgICAvLyBEb21haW4tb25seSBzZWFyY2hcbiAgICAgIHF1ZXJ5ID0gYnVpbGRTZWFyY2hCeURvbWFpblF1ZXJ5KGlucHV0LmRvbWFpbiwgaW5wdXQubGFuZ3VhZ2UsIGZpbHRlcnMubGltaXQpO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQuZGF0ZUZyb20gfHwgaW5wdXQuZGF0ZVRvKSB7XG4gICAgICAvLyBEYXRlIHJhbmdlIHNlYXJjaFxuICAgICAgcXVlcnkgPSBidWlsZFNlYXJjaEJ5RGF0ZVF1ZXJ5KGlucHV0LmRhdGVGcm9tLCBpbnB1dC5kYXRlVG8sIGlucHV0Lmxhbmd1YWdlLCBmaWx0ZXJzLmxpbWl0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRnVsbC10ZXh0IHNlYXJjaFxuICAgICAgcXVlcnkgPSBidWlsZFNlYXJjaFF1ZXJ5KGlucHV0LnF1ZXJ5IHx8ICcnLCBmaWx0ZXJzKTtcbiAgICAgIGNvdW50UXVlcnkgPSBidWlsZFNlYXJjaENvdW50UXVlcnkoaW5wdXQucXVlcnkgfHwgJycsIGZpbHRlcnMpO1xuICAgIH1cblxuICAgIC8vIEV4ZWN1dGUgc2VhcmNoIHF1ZXJ5XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3BhcnFsQ2xpZW50LnF1ZXJ5KHF1ZXJ5KTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzO1xuXG4gICAgLy8gRXhlY3V0ZSBjb3VudCBxdWVyeSBpZiBhdmFpbGFibGVcbiAgICBsZXQgdG90YWxDb3VudCA9IGJpbmRpbmdzLmxlbmd0aDtcbiAgICBpZiAoY291bnRRdWVyeSkge1xuICAgICAgY29uc3QgY291bnRSZXN1bHQgPSBhd2FpdCBzcGFycWxDbGllbnQucXVlcnkoY291bnRRdWVyeSk7XG4gICAgICBpZiAoY291bnRSZXN1bHQucmVzdWx0cy5iaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGNvdW50VmFsdWUgPSBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGNvdW50UmVzdWx0LnJlc3VsdHMuYmluZGluZ3NbMF0uY291bnQpO1xuICAgICAgICB0b3RhbENvdW50ID0gY291bnRWYWx1ZSA/IHBhcnNlSW50KGNvdW50VmFsdWUsIDEwKSA6IGJpbmRpbmdzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQYXJzZSByZXN1bHRzXG4gICAgY29uc3QgYWN0czogTGVnYWxBY3RbXSA9IGJpbmRpbmdzLm1hcCgoYmluZGluZzogUmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4pID0+ICh7XG4gICAgICB1cmk6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5hY3QpIHx8ICcnLFxuICAgICAgc3JOdW1iZXI6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5zck51bWJlcikgfHwgJycsXG4gICAgICB0aXRsZTogYmluZGluZy50aXRsZSA/IHsgW2JpbmRpbmcudGl0bGVbJ3htbDpsYW5nJ10gfHwgJ2RlJ106IGJpbmRpbmcudGl0bGUudmFsdWUgfSA6IHt9LFxuICAgICAgYWJicmV2aWF0aW9uOiBiaW5kaW5nLmFiYnJldmlhdGlvbiA/IHsgW2JpbmRpbmcuYWJicmV2aWF0aW9uWyd4bWw6bGFuZyddIHx8ICdkZSddOiBiaW5kaW5nLmFiYnJldmlhdGlvbi52YWx1ZSB9IDogdW5kZWZpbmVkLFxuICAgICAgYWN0VHlwZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiaW5kaW5nLmFjdFR5cGUpLFxuICAgICAgZGF0ZUluRm9yY2U6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5kYXRlSW5Gb3JjZSksXG4gICAgfSkpO1xuXG4gICAgLy8gR3JvdXAgYnkgU1IgbnVtYmVyIHByZWZpeCBmb3IgZG9tYWluIGZhY2V0c1xuICAgIGNvbnN0IGRvbWFpbkZhY2V0czogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIGZvciAoY29uc3QgYWN0IG9mIGFjdHMpIHtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGFjdC5zck51bWJlci5zcGxpdCgnLicpWzBdO1xuICAgICAgaWYgKHByZWZpeCAmJiBMRUdBTF9ET01BSU5TW3ByZWZpeF0pIHtcbiAgICAgICAgZG9tYWluRmFjZXRzW3ByZWZpeF0gPSAoZG9tYWluRmFjZXRzW3ByZWZpeF0gfHwgMCkgKyAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBhY3RzLFxuICAgICAgdG90YWxDb3VudCxcbiAgICAgIGhhc01vcmU6IChmaWx0ZXJzLm9mZnNldCB8fCAwKSArIGFjdHMubGVuZ3RoIDwgdG90YWxDb3VudCxcbiAgICAgIGZhY2V0czoge1xuICAgICAgICBieURvbWFpbjogZG9tYWluRmFjZXRzLFxuICAgICAgfSxcbiAgICAgIHNlYXJjaFRpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ1NlYXJjaCBsZWdpc2xhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogRmluZCByZWxhdGVkIGxlZ2lzbGF0aW9uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbmRSZWxhdGVkKGlucHV0OiBGaW5kUmVsYXRlZElucHV0KTogUHJvbWlzZTxGaW5kUmVsYXRlZFJlc3VsdD4ge1xuICBjb25zdCBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gIHRyeSB7XG4gICAgLy8gR2V0IGFsbCByZWxhdGVkIGFjdHNcbiAgICBjb25zdCBxdWVyeSA9IGJ1aWxkRmluZEFsbFJlbGF0ZWRRdWVyeShcbiAgICAgIGlucHV0LnNyTnVtYmVyLFxuICAgICAgaW5wdXQucmVsYXRpb25UeXBlIGFzIFJlbGF0aW9uVHlwZSxcbiAgICAgIGlucHV0Lmxhbmd1YWdlLFxuICAgICAgaW5wdXQubGltaXQgfHwgNTBcbiAgICApO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc3BhcnFsQ2xpZW50LnF1ZXJ5KHF1ZXJ5KTtcbiAgICBjb25zdCBiaW5kaW5ncyA9IHJlc3VsdC5yZXN1bHRzLmJpbmRpbmdzO1xuXG4gICAgLy8gUGFyc2UgcmVsYXRlZCBhY3RzXG4gICAgY29uc3QgcmVsYXRlZEFjdHM6IFJlbGF0ZWRBY3RbXSA9IGJpbmRpbmdzLm1hcCgoYmluZGluZzogUmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4pID0+ICh7XG4gICAgICB1cmk6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5yZWxhdGVkQWN0KSB8fCAnJyxcbiAgICAgIHNyTnVtYmVyOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcucmVsYXRlZFNyTnVtYmVyKSB8fCAnJyxcbiAgICAgIHRpdGxlOiBiaW5kaW5nLnJlbGF0ZWRUaXRsZSA/IHsgW2JpbmRpbmcucmVsYXRlZFRpdGxlWyd4bWw6bGFuZyddIHx8ICdkZSddOiBiaW5kaW5nLnJlbGF0ZWRUaXRsZS52YWx1ZSB9IDoge30sXG4gICAgICByZWxhdGlvblR5cGU6IChzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGJpbmRpbmcucmVsYXRpb25UeXBlKSBhcyBSZWxhdGlvblR5cGUpIHx8ICdzYW1lX2RvbWFpbicsXG4gICAgICByZWxhdGlvbkRhdGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYmluZGluZy5yZWxhdGlvbkRhdGUpLFxuICAgIH0pKTtcblxuICAgIC8vIEdyb3VwIGJ5IHJlbGF0aW9uIHR5cGUgZm9yIHN1bW1hcnlcbiAgICBjb25zdCBieVJlbGF0aW9uVHlwZTogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9O1xuICAgIGZvciAoY29uc3QgYWN0IG9mIHJlbGF0ZWRBY3RzKSB7XG4gICAgICBjb25zdCByZWxUeXBlID0gYWN0LnJlbGF0aW9uVHlwZSB8fCAndW5rbm93bic7XG4gICAgICBieVJlbGF0aW9uVHlwZVtyZWxUeXBlXSA9IChieVJlbGF0aW9uVHlwZVtyZWxUeXBlXSB8fCAwKSArIDE7XG4gICAgfVxuXG4gICAgLy8gR2V0IGxlZ2lzbGF0aXZlIGhpc3RvcnkgaWYgcmVxdWVzdGVkXG4gICAgbGV0IGxlZ2lzbGF0aXZlSGlzdG9yeTogQXJyYXk8eyBkYXRlOiBzdHJpbmc7IGRlc2NyaXB0aW9uPzogc3RyaW5nIH0+IHwgdW5kZWZpbmVkO1xuICAgIGlmIChpbnB1dC5pbmNsdWRlSGlzdG9yeSkge1xuICAgICAgY29uc3QgaGlzdG9yeVF1ZXJ5ID0gYnVpbGRMZWdpc2xhdGl2ZUhpc3RvcnlRdWVyeShpbnB1dC5zck51bWJlciwgaW5wdXQubGFuZ3VhZ2UpO1xuICAgICAgY29uc3QgaGlzdG9yeVJlc3VsdCA9IGF3YWl0IHNwYXJxbENsaWVudC5xdWVyeShoaXN0b3J5UXVlcnkpO1xuXG4gICAgICBsZWdpc2xhdGl2ZUhpc3RvcnkgPSBoaXN0b3J5UmVzdWx0LnJlc3VsdHMuYmluZGluZ3MubWFwKChiaW5kaW5nOiBSZWNvcmQ8c3RyaW5nLCBTUEFSUUxCaW5kaW5nPikgPT4gKHtcbiAgICAgICAgZGF0ZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiaW5kaW5nLmRhdGUpIHx8ICcnLFxuICAgICAgICBkZXNjcmlwdGlvbjogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiaW5kaW5nLmNoYW5nZURlc2NyaXB0aW9uKSxcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3JOdW1iZXI6IGlucHV0LnNyTnVtYmVyLFxuICAgICAgcmVsYXRlZEFjdHMsXG4gICAgICBieVJlbGF0aW9uVHlwZSxcbiAgICAgIGxlZ2lzbGF0aXZlSGlzdG9yeSxcbiAgICAgIHNlYXJjaFRpbWVNczogRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSxcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0ZpbmQgcmVsYXRlZCBmYWlsZWQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogR2V0IGNvbXByZWhlbnNpdmUgbWV0YWRhdGEgYWJvdXQgYSBsZWdhbCBhY3RcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0TWV0YWRhdGEoaW5wdXQ6IEdldE1ldGFkYXRhSW5wdXQpOiBQcm9taXNlPEdldE1ldGFkYXRhUmVzdWx0PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBGZXRjaCBtZXRhZGF0YSBpbiBwYXJhbGxlbFxuICAgIGNvbnN0IFtcbiAgICAgIG1ldGFkYXRhUmVzdWx0LFxuICAgICAgbGFuZ3VhZ2VzUmVzdWx0LFxuICAgICAgc3ViamVjdHNSZXN1bHQsXG4gICAgICBoaXN0b3J5UmVzdWx0LFxuICAgICAgc3RhdHVzUmVzdWx0LFxuICAgICAgc3RydWN0dXJlUmVzdWx0LFxuICAgIF0gPSBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICBzcGFycWxDbGllbnQucXVlcnkoYnVpbGRHZXRNZXRhZGF0YVF1ZXJ5KGlucHV0LnNyTnVtYmVyLCBpbnB1dC5sYW5ndWFnZSkpLFxuICAgICAgc3BhcnFsQ2xpZW50LnF1ZXJ5KGJ1aWxkR2V0TGFuZ3VhZ2VzUXVlcnkoaW5wdXQuc3JOdW1iZXIpKSxcbiAgICAgIHNwYXJxbENsaWVudC5xdWVyeShidWlsZEdldFN1YmplY3RzUXVlcnkoaW5wdXQuc3JOdW1iZXIsIGlucHV0Lmxhbmd1YWdlKSksXG4gICAgICBzcGFycWxDbGllbnQucXVlcnkoYnVpbGRHZXRWZXJzaW9uSGlzdG9yeVF1ZXJ5KGlucHV0LnNyTnVtYmVyKSksXG4gICAgICBzcGFycWxDbGllbnQucXVlcnkoYnVpbGRHZXRMZWdhbFN0YXR1c1F1ZXJ5KGlucHV0LnNyTnVtYmVyKSksXG4gICAgICBpbnB1dC5pbmNsdWRlU3RydWN0dXJlXG4gICAgICAgID8gc3BhcnFsQ2xpZW50LnF1ZXJ5KGJ1aWxkR2V0U3RydWN0dXJlUXVlcnkoaW5wdXQuc3JOdW1iZXIsIGlucHV0Lmxhbmd1YWdlKSlcbiAgICAgICAgOiBQcm9taXNlLnJlc29sdmUoeyByZXN1bHRzOiB7IGJpbmRpbmdzOiBbXSB9IH0pLFxuICAgIF0pO1xuXG4gICAgY29uc3QgbWV0YWRhdGFCaW5kaW5ncyA9IG1ldGFkYXRhUmVzdWx0LnJlc3VsdHMuYmluZGluZ3M7XG5cbiAgICBpZiAobWV0YWRhdGFCaW5kaW5ncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvdW5kOiBmYWxzZSxcbiAgICAgICAgc2VhcmNoVGltZU1zOiBEYXRlLm5vdygpIC0gc3RhcnRUaW1lLFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBjb25zdCBmaXJzdEJpbmRpbmcgPSBtZXRhZGF0YUJpbmRpbmdzWzBdO1xuXG4gICAgLy8gUGFyc2UgYmFzaWMgbWV0YWRhdGFcbiAgICBjb25zdCBtZXRhZGF0YTogR2V0TWV0YWRhdGFSZXN1bHRbJ21ldGFkYXRhJ10gPSB7XG4gICAgICB1cmk6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmFjdCkgfHwgJycsXG4gICAgICBzck51bWJlcjogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuc3JOdW1iZXIpIHx8ICcnLFxuICAgICAgdGl0bGU6IHNwYXJxbENsaWVudC5leHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUobWV0YWRhdGFCaW5kaW5ncywgJ3RpdGxlJyksXG4gICAgICBhYmJyZXZpYXRpb246IHNwYXJxbENsaWVudC5leHRyYWN0TXVsdGlsaW5ndWFsVmFsdWUobWV0YWRhdGFCaW5kaW5ncywgJ2FiYnJldmlhdGlvbicpLFxuICAgICAgYWN0VHlwZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuYWN0VHlwZSksXG4gICAgICBkYXRlRG9jdW1lbnQ6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmRhdGVEb2N1bWVudCksXG4gICAgICBkYXRlSW5Gb3JjZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShmaXJzdEJpbmRpbmcuZGF0ZUluRm9yY2UpLFxuICAgICAgZGF0ZUFicm9nYXRpb246IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoZmlyc3RCaW5kaW5nLmRhdGVBYnJvZ2F0aW9uKSxcbiAgICAgIHN0YXR1czogJ3Vua25vd24nLFxuICAgIH07XG5cbiAgICAvLyBQYXJzZSBsYW5ndWFnZXNcbiAgICBtZXRhZGF0YS5hdmFpbGFibGVMYW5ndWFnZXMgPSBsYW5ndWFnZXNSZXN1bHQucmVzdWx0cy5iaW5kaW5nc1xuICAgICAgLm1hcCgoYjogUmVjb3JkPHN0cmluZywgU1BBUlFMQmluZGluZz4pID0+IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYi5sYW5ndWFnZSkpXG4gICAgICAuZmlsdGVyKChsYW5nKTogbGFuZyBpcyBzdHJpbmcgPT4gISFsYW5nKSBhcyBMYW5ndWFnZVtdO1xuXG4gICAgLy8gUGFyc2Ugc3ViamVjdHMva2V5d29yZHNcbiAgICBjb25zdCBzdWJqZWN0cyA9IHN1YmplY3RzUmVzdWx0LnJlc3VsdHMuYmluZGluZ3NcbiAgICAgIC5tYXAoKGI6IFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+KSA9PiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIubGFiZWwpKVxuICAgICAgLmZpbHRlcigocyk6IHMgaXMgc3RyaW5nID0+ICEhcyk7XG4gICAgaWYgKHN1YmplY3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIG1ldGFkYXRhLnN1YmplY3RzID0gc3ViamVjdHM7XG4gICAgfVxuXG4gICAgLy8gUGFyc2UgdmVyc2lvbiBoaXN0b3J5XG4gICAgY29uc3QgdmVyc2lvbnMgPSBoaXN0b3J5UmVzdWx0LnJlc3VsdHMuYmluZGluZ3MubWFwKChiOiBSZWNvcmQ8c3RyaW5nLCBTUEFSUUxCaW5kaW5nPikgPT4gKHtcbiAgICAgIGRhdGU6IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYi52ZXJzaW9uRGF0ZSkgfHwgJycsXG4gICAgICB0eXBlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIudmVyc2lvblR5cGUpLFxuICAgICAgZGVzY3JpcHRpb246IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoYi5jaGFuZ2VEZXNjcmlwdGlvbiksXG4gICAgfSkpO1xuICAgIGlmICh2ZXJzaW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXRhZGF0YS52ZXJzaW9uSGlzdG9yeSA9IHZlcnNpb25zO1xuICAgIH1cblxuICAgIC8vIFBhcnNlIGxlZ2FsIHN0YXR1c1xuICAgIGlmIChzdGF0dXNSZXN1bHQucmVzdWx0cy5iaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBzdGF0dXNCaW5kaW5nID0gc3RhdHVzUmVzdWx0LnJlc3VsdHMuYmluZGluZ3NbMF07XG4gICAgICBjb25zdCBzdGF0dXMgPSBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKHN0YXR1c0JpbmRpbmcuc3RhdHVzKTtcbiAgICAgIGlmIChzdGF0dXMgPT09ICdpbl9mb3JjZScgfHwgc3RhdHVzID09PSAnYWJyb2dhdGVkJyB8fCBzdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICBtZXRhZGF0YS5zdGF0dXMgPSBzdGF0dXM7XG4gICAgICB9XG4gICAgICBtZXRhZGF0YS5hYnJvZ2F0ZWRCeSA9IHNwYXJxbENsaWVudC5leHRyYWN0VmFsdWUoc3RhdHVzQmluZGluZy5hYnJvZ2F0ZWRCeSk7XG4gICAgfVxuXG4gICAgLy8gUGFyc2Ugc3RydWN0dXJlICh0YWJsZSBvZiBjb250ZW50cylcbiAgICBpZiAoaW5wdXQuaW5jbHVkZVN0cnVjdHVyZSAmJiBzdHJ1Y3R1cmVSZXN1bHQucmVzdWx0cy5iaW5kaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBtZXRhZGF0YS5zdHJ1Y3R1cmUgPSBzdHJ1Y3R1cmVSZXN1bHQucmVzdWx0cy5iaW5kaW5ncy5tYXAoKGI6IFJlY29yZDxzdHJpbmcsIFNQQVJRTEJpbmRpbmc+KSA9PiAoe1xuICAgICAgICBwYXJ0TnVtYmVyOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIucGFydE51bWJlcikgfHwgJycsXG4gICAgICAgIHBhcnRUaXRsZTogc3BhcnFsQ2xpZW50LmV4dHJhY3RWYWx1ZShiLnBhcnRUaXRsZSksXG4gICAgICAgIHBhcnRUeXBlOiBzcGFycWxDbGllbnQuZXh0cmFjdFZhbHVlKGIucGFydFR5cGUpLFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8vIEFkZCBsZWdhbCBkb21haW4gaW5mb1xuICAgIGNvbnN0IGRvbWFpblByZWZpeCA9IGlucHV0LnNyTnVtYmVyLnNwbGl0KCcuJylbMF07XG4gICAgaWYgKExFR0FMX0RPTUFJTlNbZG9tYWluUHJlZml4XSkge1xuICAgICAgbWV0YWRhdGEubGVnYWxEb21haW4gPSBMRUdBTF9ET01BSU5TW2RvbWFpblByZWZpeF07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGZvdW5kOiB0cnVlLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBzZWFyY2hUaW1lTXM6IERhdGUubm93KCkgLSBzdGFydFRpbWUsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdHZXQgbWV0YWRhdGEgZmFpbGVkOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG4vKipcbiAqIE1haW4gc2VydmVyIHNldHVwXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gIC8vIEluaXRpYWxpemUgU1BBUlFMIGNsaWVudFxuICBpbml0aWFsaXplQ2xpZW50KCk7XG5cbiAgY29uc3Qgc2VydmVyID0gbmV3IFNlcnZlcihcbiAgICB7XG4gICAgICBuYW1lOiBcImZlZGxleC1zcGFycWxcIixcbiAgICAgIHZlcnNpb246IFwiMi4wLjFcIixcbiAgICB9LFxuICAgIHtcbiAgICAgIGNhcGFiaWxpdGllczoge1xuICAgICAgICB0b29sczoge30sXG4gICAgICB9LFxuICAgIH1cbiAgKTtcblxuICAvLyBMaXN0IGF2YWlsYWJsZSB0b29sc1xuICBzZXJ2ZXIuc2V0UmVxdWVzdEhhbmRsZXIoTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSwgYXN5bmMgKCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogW1xuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJsb29rdXBfc3RhdHV0ZVwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgXCJMb29rIHVwIGEgU3dpc3MgZmVkZXJhbCBsZWdhbCBhY3QgYnkgU1IgbnVtYmVyIChlLmcuLCAnMjIwJyBmb3IgT1IpIG9yIGFiYnJldmlhdGlvbiAoZS5nLiwgJ09SJywgJ1pHQicpLiBSZXR1cm5zIGJhc2ljIGluZm9ybWF0aW9uIGluY2x1ZGluZyB0aXRsZSwgdHlwZSwgYW5kIHN0YXR1cyBpbiBtdWx0aXBsZSBsYW5ndWFnZXMgKERFL0ZSL0lUKS5cIixcbiAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgaWRlbnRpZmllcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICAgICAgICBcIlNSIG51bWJlciAoZS5nLiwgJzIyMCcsICcyMTAnKSBvciBhYmJyZXZpYXRpb24gKGUuZy4sICdPUicsICdaR0InLCAnU3RHQicpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBlbnVtOiBbXCJkZVwiLCBcImZyXCIsIFwiaXRcIiwgXCJybVwiXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJQcmVmZXJyZWQgbGFuZ3VhZ2UgZm9yIHJlc3VsdHMgKGRlPUdlcm1hbiwgZnI9RnJlbmNoLCBpdD1JdGFsaWFuLCBybT1Sb21hbnNoKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJpZGVudGlmaWVyXCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImdldF9hcnRpY2xlXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICBcIlJldHJpZXZlIGEgc3BlY2lmaWMgYXJ0aWNsZSB3aXRoaW4gYSBTd2lzcyBsZWdhbCBhY3QuIFJldHVybnMgYXJ0aWNsZSB0ZXh0LCBtYXJnaW5hbCBub3RlcywgcGFyYWdyYXBocyAoQWJzXHUwMEU0dHplKSwgYW5kIGxldHRlcnMgKEJ1Y2hzdGFiZW4pIGluIHN0cnVjdHVyZWQgZm9ybWF0LlwiLFxuICAgICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICBzck51bWJlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiU1IgbnVtYmVyIG9mIHRoZSBsZWdhbCBhY3QgKGUuZy4sICcyMjAnIGZvciBPUilcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgYXJ0aWNsZU51bWJlcjoge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiQXJ0aWNsZSBudW1iZXIgKGUuZy4sICc5NycsICc0MScsICdBcnQuIDk3JylcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcGFyYWdyYXBoOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTcGVjaWZpYyBwYXJhZ3JhcGgvQWJzYXR6IG51bWJlciAob3B0aW9uYWwpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBlbnVtOiBbXCJkZVwiLCBcImZyXCIsIFwiaXRcIiwgXCJybVwiXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJQcmVmZXJyZWQgbGFuZ3VhZ2UgZm9yIGFydGljbGUgdGV4dFwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBbXCJzck51bWJlclwiLCBcImFydGljbGVOdW1iZXJcIl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwic2VhcmNoX2xlZ2lzbGF0aW9uXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICBcIlNlYXJjaCBhY3Jvc3MgU3dpc3MgZmVkZXJhbCBsZWdpc2xhdGlvbiB3aXRoIGZ1bGwtdGV4dCBzZWFyY2ggYW5kIGZpbHRlcnMuIFN1cHBvcnRzIGZpbHRlcmluZyBieSBsZWdhbCBkb21haW4sIGRhdGUgcmFuZ2UsIGFjdCB0eXBlLCBhbmQgbGFuZ3VhZ2UuXCIsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHF1ZXJ5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJGdWxsLXRleHQgc2VhcmNoIHF1ZXJ5IChzZWFyY2hlcyB0aXRsZSBhbmQgU1IgbnVtYmVyKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBkb21haW46IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGVudW06IFtcIjFcIiwgXCIyXCIsIFwiM1wiLCBcIjRcIiwgXCI1XCIsIFwiNlwiLCBcIjdcIiwgXCI4XCIsIFwiOVwiXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAgICAgICAgIFwiTGVnYWwgZG9tYWluIGZpbHRlciBieSBTUiBwcmVmaXg6IDE9U3RhdGUvQ29uc3RpdHV0aW9uYWwsIDI9UHJpdmF0ZS9DaXZpbCwgMz1DcmltaW5hbCwgND1FZHVjYXRpb24vQ3VsdHVyZSwgNT1EZWZlbnNlLCA2PUZpbmFuY2UsIDc9UHVibGljIFdvcmtzL1RyYW5zcG9ydCwgOD1IZWFsdGgvTGFib3IvU29jaWFsIFNlY3VyaXR5LCA5PUVjb25vbXlcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgc3JOdW1iZXJQcmVmaXg6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbHRlciBieSBTUiBudW1iZXIgcHJlZml4IChlLmcuLCAnMjInIGZvciBjb250cmFjdCBsYXcpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGRhdGVGcm9tOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbHRlciBhY3RzIGluIGZvcmNlIGZyb20gdGhpcyBkYXRlIChJU08gODYwMTogWVlZWS1NTS1ERClcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgZGF0ZVRvOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbHRlciBhY3RzIGluIGZvcmNlIHVudGlsIHRoaXMgZGF0ZSAoSVNPIDg2MDE6IFlZWVktTU0tREQpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGFjdFR5cGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgaXRlbXM6IHsgdHlwZTogXCJzdHJpbmdcIiB9LFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbHRlciBieSBhY3QgdHlwZXMgKGUuZy4sICdCdW5kZXNnZXNldHonLCAnVmVyb3JkbnVuZycpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBlbnVtOiBbXCJkZVwiLCBcImZyXCIsIFwiaXRcIiwgXCJybVwiXSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJMYW5ndWFnZSBmaWx0ZXIgZm9yIHJlc3VsdHNcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgbGltaXQ6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IDEsXG4gICAgICAgICAgICAgICAgbWF4aW11bTogMTAwLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDUwLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIk1heGltdW0gbnVtYmVyIG9mIHJlc3VsdHNcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgb2Zmc2V0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6IDAsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiT2Zmc2V0IGZvciBwYWdpbmF0aW9uXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBuYW1lOiBcImZpbmRfcmVsYXRlZFwiLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgICAgXCJGaW5kIGxlZ2lzbGF0aW9uIHJlbGF0ZWQgdG8gYSBzcGVjaWZpYyBhY3QgdGhyb3VnaCBhbWVuZG1lbnRzLCBjaXRhdGlvbnMsIHJlZmVyZW5jZXMsIG9yIHNoYXJlZCBsZWdhbCBkb21haW4uIE9wdGlvbmFsbHkgaW5jbHVkZXMgbGVnaXNsYXRpdmUgaGlzdG9yeSAoY29uc29saWRhdGlvbiBjaGFpbikuXCIsXG4gICAgICAgICAgaW5wdXRTY2hlbWE6IHtcbiAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIHNyTnVtYmVyOiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJTUiBudW1iZXIgb2YgdGhlIGxlZ2FsIGFjdCAoZS5nLiwgJzIyMCcgZm9yIE9SKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICByZWxhdGlvblR5cGU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGVudW06IFtcbiAgICAgICAgICAgICAgICAgIFwiYW1lbmRzXCIsXG4gICAgICAgICAgICAgICAgICBcImFtZW5kZWRfYnlcIixcbiAgICAgICAgICAgICAgICAgIFwiY2l0ZXNcIixcbiAgICAgICAgICAgICAgICAgIFwiY2l0ZWRfYnlcIixcbiAgICAgICAgICAgICAgICAgIFwiaW1wbGVtZW50c1wiLFxuICAgICAgICAgICAgICAgICAgXCJpbXBsZW1lbnRlZF9ieVwiLFxuICAgICAgICAgICAgICAgICAgXCJiYXNlZF9vblwiLFxuICAgICAgICAgICAgICAgICAgXCJzYW1lX2RvbWFpblwiLFxuICAgICAgICAgICAgICAgICAgXCJzYW1lX3N1YmplY3RcIixcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIkZpbHRlciBieSBzcGVjaWZpYyByZWxhdGlvbiB0eXBlIChvcHRpb25hbCAtIHJldHVybnMgYWxsIGlmIG5vdCBzcGVjaWZpZWQpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluY2x1ZGVIaXN0b3J5OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICAgICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiSW5jbHVkZSBsZWdpc2xhdGl2ZSBoaXN0b3J5IChjb25zb2xpZGF0aW9uIGNoYWluKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZW51bTogW1wiZGVcIiwgXCJmclwiLCBcIml0XCIsIFwicm1cIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUHJlZmVycmVkIGxhbmd1YWdlIGZvciByZXN1bHRzXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGxpbWl0OiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiAxLFxuICAgICAgICAgICAgICAgIG1heGltdW06IDEwMCxcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiA1MCxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJNYXhpbXVtIG51bWJlciBvZiByZWxhdGVkIGFjdHNcIixcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZXF1aXJlZDogW1wic3JOdW1iZXJcIl0sXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiZ2V0X21ldGFkYXRhXCIsXG4gICAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgICBcIkdldCBjb21wcmVoZW5zaXZlIG1ldGFkYXRhIGFib3V0IGEgbGVnYWwgYWN0IGluY2x1ZGluZyBwdWJsaWNhdGlvbiBpbmZvLCBzdWJqZWN0cy9rZXl3b3JkcywgdmVyc2lvbiBoaXN0b3J5LCBsZWdhbCBzdGF0dXMsIGF2YWlsYWJsZSBsYW5ndWFnZXMsIGFuZCBvcHRpb25hbGx5IHRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgKHRhYmxlIG9mIGNvbnRlbnRzKS5cIixcbiAgICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgc3JOdW1iZXI6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBcIlNSIG51bWJlciBvZiB0aGUgbGVnYWwgYWN0IChlLmcuLCAnMjIwJyBmb3IgT1IpXCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIGluY2x1ZGVTdHJ1Y3R1cmU6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogXCJJbmNsdWRlIGRvY3VtZW50IHN0cnVjdHVyZSAodGFibGUgb2YgY29udGVudHMgd2l0aCBjaGFwdGVycywgc2VjdGlvbnMsIGFydGljbGVzKVwiLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgZW51bTogW1wiZGVcIiwgXCJmclwiLCBcIml0XCIsIFwicm1cIl0sXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IFwiUHJlZmVycmVkIGxhbmd1YWdlIGZvciBtZXRhZGF0YSB0ZXh0XCIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IFtcInNyTnVtYmVyXCJdLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gIH0pO1xuXG4gIC8vIEhhbmRsZSB0b29sIGNhbGxzXG4gIHNlcnZlci5zZXRSZXF1ZXN0SGFuZGxlcihDYWxsVG9vbFJlcXVlc3RTY2hlbWEsIGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IHJlcXVlc3QucGFyYW1zO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChuYW1lID09PSBcImxvb2t1cF9zdGF0dXRlXCIpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhcmdzIGFzIHVua25vd24gYXMgTG9va3VwU3RhdHV0ZUlucHV0O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsb29rdXBTdGF0dXRlKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gXCJnZXRfYXJ0aWNsZVwiKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXJncyBhcyB1bmtub3duIGFzIEdldEFydGljbGVJbnB1dDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZ2V0QXJ0aWNsZShpbnB1dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5hbWUgPT09IFwic2VhcmNoX2xlZ2lzbGF0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBhcmdzIGFzIHVua25vd24gYXMgU2VhcmNoTGVnaXNsYXRpb25JbnB1dDtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgc2VhcmNoTGVnaXNsYXRpb24oaW5wdXQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHJlc3VsdCwgbnVsbCwgMiksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChuYW1lID09PSBcImZpbmRfcmVsYXRlZFwiKSB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gYXJncyBhcyB1bmtub3duIGFzIEZpbmRSZWxhdGVkSW5wdXQ7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGZpbmRSZWxhdGVkKGlucHV0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiLFxuICAgICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShyZXN1bHQsIG51bGwsIDIpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobmFtZSA9PT0gXCJnZXRfbWV0YWRhdGFcIikge1xuICAgICAgICBjb25zdCBpbnB1dCA9IGFyZ3MgYXMgdW5rbm93biBhcyBHZXRNZXRhZGF0YUlucHV0O1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBnZXRNZXRhZGF0YShpbnB1dCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkocmVzdWx0LCBudWxsLCAyKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRvb2w6ICR7bmFtZX1gKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiBTdHJpbmcoZXJyb3IpO1xuICAgICAgY29uc29sZS5lcnJvcihgVG9vbCBleGVjdXRpb24gZmFpbGVkOiAke25hbWV9YCwgZXJyb3IpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IGVycm9yOiBlcnJvck1lc3NhZ2UgfSwgbnVsbCwgMiksXG4gICAgICAgICAgfSxcbiAgICAgICAgXSxcbiAgICAgICAgaXNFcnJvcjogdHJ1ZSxcbiAgICAgIH07XG4gICAgfVxuICB9KTtcblxuICAvLyBTdGFydCBzZXJ2ZXIgd2l0aCBzdGRpbyB0cmFuc3BvcnRcbiAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFN0ZGlvU2VydmVyVHJhbnNwb3J0KCk7XG4gIGF3YWl0IHNlcnZlci5jb25uZWN0KHRyYW5zcG9ydCk7XG5cbiAgY29uc29sZS5lcnJvcihcIkZlZGxleCBTUEFSUUwgTUNQIHNlcnZlciBydW5uaW5nIG9uIHN0ZGlvXCIpO1xufVxuXG5tYWluKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoXCJGYXRhbCBlcnJvciBpbiBtYWluKCk6XCIsIGVycm9yKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufSk7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsUUFBc0IsY0FBdEIsTUFBaUM7O0FBQWpDLElBQUFBLFNBQUEsY0FBQTtBQU9hLElBQUFBLFNBQUEsYUFBYTtBQUUxQixRQUFhLE9BQWIsY0FBMEIsWUFBVztNQUVuQyxZQUFZLEdBQVM7QUFFbkIsWUFEQSxNQUFLLEdBQ0QsQ0FBQ0EsU0FBQSxXQUFXLEtBQUssQ0FBQztBQUFHLGdCQUFNLElBQUksTUFBTSwwQ0FBMEM7QUFDbkYsYUFBSyxNQUFNO01BQ2I7TUFFQSxXQUFRO0FBQ04sZUFBTyxLQUFLO01BQ2Q7TUFFQSxXQUFRO0FBQ04sZUFBTztNQUNUO01BRUEsSUFBSSxRQUFLO0FBQ1AsZUFBTyxFQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsRUFBQztNQUN2Qjs7QUFsQkYsSUFBQUEsU0FBQSxPQUFBO0FBcUJBLFFBQWEsUUFBYixjQUEyQixZQUFXO01BS3BDLFlBQVksTUFBa0M7QUFDNUMsY0FBSyxHQUNMLEtBQUssU0FBUyxPQUFPLFFBQVMsV0FBVyxDQUFDLElBQUksSUFBSTtNQUNwRDtNQUVBLFdBQVE7QUFDTixlQUFPLEtBQUs7TUFDZDtNQUVBLFdBQVE7QUFDTixZQUFJLEtBQUssT0FBTyxTQUFTO0FBQUcsaUJBQU87QUFDbkMsWUFBTSxPQUFPLEtBQUssT0FBTyxDQUFDO0FBQzFCLGVBQU8sU0FBUyxNQUFNLFNBQVM7TUFDakM7TUFFQSxJQUFJLE1BQUc7O0FBQ0wsZ0JBQU9DLE1BQUMsS0FBSyxV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QSxFQUNBLE1BQU0sU0FBUztBQUNYLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxTQUFTLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDM0U7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxPQUFPLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDekU7QUFBQSxFQUNBLE1BQU0sU0FBUztBQUNYLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxTQUFTLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDM0U7QUFBQSxFQUNBLEtBQUssU0FBUztBQUNWLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxRQUFRLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDMUU7QUFBQSxFQUNBLE9BQU8sU0FBUztBQUNaLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxVQUFVLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDNUU7QUFBQSxFQUNBLEtBQUssU0FBUztBQUNWLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxRQUFRLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDMUU7QUFBQSxFQUNBLE1BQU0sU0FBUztBQUNYLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxTQUFTLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDM0U7QUFBQSxFQUNBLEtBQUssU0FBUztBQUNWLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxRQUFRLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDMUU7QUFBQSxFQUNBLE9BQU8sU0FBUztBQUNaLFdBQU8sS0FBSyxVQUFVLEVBQUUsTUFBTSxVQUFVLEdBQUcsVUFBVSxTQUFTLE9BQU8sRUFBRSxDQUFDO0FBQUEsRUFDNUU7QUFBQSxFQUNBLFVBQVUsU0FBUztBQUVmLFdBQU8sS0FBSyxVQUFV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LFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksYUFBYTtBQUNiLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxVQUFVO0FBQUEsRUFDakU7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDOUQ7QUFBQSxFQUNBLElBQUksUUFBUTtBQUNSLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxLQUFLO0FBQUEsRUFDNUQ7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxPQUFPO0FBQUEsRUFDOUQ7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksV0FBVztBQUNYLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxRQUFRO0FBQUEsRUFDL0Q7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUssQ0FBQyxPQUFPLEdBQUcsU0FBUyxNQUFNO0FBQUEsRUFDN0Q7QUFBQSxFQUNBLElBQUksVUFBVTtBQUNWLFdBQU8sQ0FBQyxDQUFDLEtBQUssS0FBSyxPQUFPLEtBQUss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QUFBQSxFQUFBO0FBQUEsbUJBQUFDO0FBQUEsRUFBQSxtQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxvQkFBQUM7QUFBQSxFQUFBLG1CQUFBQztBQUFBLEVBQUEsaUJBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUEsaUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEsbUJBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEsa0JBQUFDO0FBQUEsRUFBQSxlQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBLGtCQUFBQztBQUFBLEVBQUEsZUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQSxpQkFBQUM7QUFBQSxFQUFBLGNBQUFDO0FBQUEsRUFBQSxlQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBLGdCQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLGFBQUFDO0FBQUEsRUFBQSxhQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUEsYUFBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLFlBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQSxlQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxhQUFBQztBQUFBLEVBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQTtBQUFBLGlCQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBLGNBQUFDO0FB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QUVBLEtBQUssRUFBRSxNQUFNLENBQUNBLFdBQVU7QUFDdEIsVUFBUSxNQUFNLDBCQUEwQkEsTUFBSyxHQUM3QyxRQUFRLEtBQUssQ0FBQztBQUNoQixDQUFDOyIsCiAgIm5hbWVzIjogWyJleHBvcnRzIiwgIl9hIiwgIlVzZWRWYWx1ZVN0YXRlIiwgImV4cG9ydHMiLCAiX2EiLCAiZXhwb3J0cyIsICJlcnJvciIsICJfYSIsICJoYXNoIiwgImV4cG9ydHMiLCAibWVyZ2VWYWx1ZXMiLCAiVHlwZSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiX2EiLCAiRGF0YVR5cGUiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJfYSIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiX2EiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJleHBvcnRzIiwgIm1vZHVsZSIsICJoZXgiLCAiaXB2NiIsICJlc2MiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAicGFyc2UiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgIl9hIiwgIkFqdiIsICJtZXRhIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJfYSIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJlcnJvciIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiZXJyb3IiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImVycm9yIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJleHBvcnRzIiwgImV4cG9ydHMiLCAiRGlzY3JFcnJvciIsICJleHBvcnRzIiwgImVycm9yIiwgIl9hIiwgInJlcXVpcmVkIiwgImV4cG9ydHMiLCAiZXhwb3J0cyIsICJtb2R1bGUiLCAiQWp2IiwgImV4cG9ydHMiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAiZGF0ZSIsICJ0aW1lIiwgImVycm9yIiwgImV4cG9ydHMiLCAiX2EiLCAibW9kdWxlIiwgImV4cG9ydHMiLCAidXRpbCIsICJhc3NlcnRJcyIsICJhc3NlcnROZXZlciIsICJvYmplY3QiLCAiam9pblZhbHVlcyIsICJhcnJheSIsICJvYmplY3RVdGlsIiwgImlzc3VlIiwgImVycm9yIiwgImlzc3VlIiwgIm1hcCIsICJpc3N1ZSIsICJlcnJvclV0aWwiLCAiZXJyb3IiLCAiZXJyb3JNYXAiLCAiY2hlY2siLCAidHJhbnNmb3JtIiwgInZlcnNpb24iLCAiand0IiwgImJhc2U2NCIsICJfWm9kU3RyaW5nIiwgImN0eCIsICJyZXN1bHQiLCAiaXNzdWUiLCAiaXNzdWVzIiwgImVsZW1lbnRzIiwgInByb2Nlc3NlZCIsICJwcmVwcm9jZXNzIiwgInJlc3VsdCIsICJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCAiaW5pdGlhbGl6ZXIiLCAiX2EiLCAiZmxvYXRTYWZlUmVtYWluZGVyIiwgImdldFBhcnNlZFR5cGUiLCAiYXJyYXkiLCAib2JqZWN0IiwgIkNsYXNzIiwgIl9hIiwgImNvbmZpZyIsICJiYXNlNjQiLCAiYmFzZTY0dXJsIiwgImhleCIsICJlcnJvciIsICJpc3N1ZSIsICJ2ZXJzaW9uIiwgInRpbWUiLCAidGltZVJlZ2V4IiwgIl9hIiwgImluc3QiLCAiZmxvYXRTYWZlUmVtYWluZGVyIiwgInJlc3VsdCIsICJfYSIsICJjaGVja3MiLCAiaXNBYm9ydGVkIiwgImNoZWNrUmVzdWx0IiwgImNhbmFyeSIsICJyZXN1bHQiLCAidXJsIiwgImJhc2U2NCIsICJpc1ZhbGlkSldUIiwgInIiLCAiaXNPYmplY3QiLCAicmVzdWx0cyIsICJtYXAiLCAibGVmdCIsICJyaWdodCIsICJtZXJnZVZhbHVlcyIsICJrZXlSZXN1bHQiLCAidmFsdWVSZXN1bHQiLCAib3V0cHV0IiwgImlzc3VlIiwgImVuX2RlZmF1bHQiLCAibWV0YSIsICJDbGFzcyIsICJDbGFzcyIsICJfZW1vamkiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiX3VuZGVmaW5lZCIsICJfbnVsbCIsICJDbGFzcyIsICJDbGFzcyIsICJDbGFzcyIsICJDbGFzcyIsICJpc3N1ZSIsICJjb2RlYyIsICJwcm9jZXNzIiwgIl9hIiwgIm1ldGEiLCAiaWQiLCAic2NoZW1hIiwgImpzb24iLCAiZmlsZSIsICJwcm9jZXNzIiwgInNhZmVQYXJzZSIsICJkZWYiLCAic2NoZW1hc19leHBvcnRzIiwgIlpvZEFueSIsICJab2RBcnJheSIsICJab2RCaWdJbnQiLCAiWm9kQm9vbGVhbiIsICJab2RDYXRjaCIsICJab2REYXRlIiwgIlpvZERlZmF1bHQiLCAiWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwgIlpvZEVudW0iLCAiWm9kRnVuY3Rpb24iLCAiWm9kSW50ZXJzZWN0aW9uIiwgIlpvZExhenkiLCAiWm9kTGl0ZXJhbCIsICJab2RNYXAiLCAiWm9kTmFOIiwgIlpvZE5ldmVyIiwgIlpvZE51bGwiLCAiWm9kTnVsbGFibGUiLCAiWm9kTnVtYmVyIiwgIlpvZE9iamVjdCIsICJab2RPcHRpb25hbCIsICJab2RQcm9taXNlIiwgIlpvZFJlYWRvbmx5IiwgIlpvZFJlY29yZCIsICJab2RTZXQiLCAiWm9kU3RyaW5nIiwgIlpvZFN5bWJvbCIsICJab2RUdXBsZSIsICJab2RUeXBlIiwgIlpvZFVuZGVmaW5lZCIsICJab2RVbmlvbiIsICJab2RVbmtub3duIiwgIlpvZFZvaWQiLCAiYmFzZTY0IiwgImJhc2U2NHVybCIsICJiaWdpbnQiLCAiYm9vbGVhbiIsICJjaWRydjQiLCAiY2lkcnY2IiwgImN1aWQiLCAiY3VpZDIiLCAiZGF0ZSIsICJkZXNjcmliZSIsICJlMTY0IiwgImVtYWlsIiwgImVtb2ppIiwgImd1aWQiLCAiaGV4IiwgImhvc3RuYW1lIiwgImlwdjQiLCAiaXB2NiIsICJrc3VpZCIsICJtYWMiLCAibWV0YSIsICJuYW5vaWQiLCAiX251bGwiLCAibnVsbGlzaCIsICJudW1iZXIiLCAib2JqZWN0IiwgInN0cmluZyIsICJ1bGlkIiwgIl91bmRlZmluZWQiLCAidXVpZCIsICJfdm9pZCIsICJ4aWQiLCAiY2hlY2tzX2V4cG9ydHMiLCAiaXNvX2V4cG9ydHMiLCAiZGF0ZSIsICJkYXRldGltZSIsICJkdXJhdGlvbiIsICJ0aW1lIiwgImRhdGV0aW1lIiwgImRhdGUiLCAidGltZSIsICJkdXJhdGlvbiIsICJpbml0aWFsaXplciIsICJpc3N1ZSIsICJpc3N1ZXMiLCAiWm9kRXJyb3IiLCAicGFyc2UiLCAicGFyc2VBc3luYyIsICJzYWZlUGFyc2UiLCAic2FmZVBhcnNlQXN5bmMiLCAiZW5jb2RlIiwgImRlY29kZSIsICJlbmNvZGVBc3luYyIsICJkZWNvZGVBc3luYyIsICJzYWZlRW5jb2RlIiwgInNhZmVEZWNvZGUiLCAic2FmZUVuY29kZUFzeW5jIiwgInNhZmVEZWNvZGVBc3luYyIsICJab2RUeXBlIiwgImRlZiIsICJtZXRhIiwgInBhcnNlIiwgInNhZmVQYXJzZSIsICJwYXJzZUFzeW5jIiwgInNhZmVQYXJzZUFzeW5jIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlQXN5bmMiLCAiZGVjb2RlQXN5bmMiLCAic2FmZUVuY29kZSIsICJzYWZlRGVjb2RlIiwgInNhZmVFbmNvZGVBc3luYyIsICJzYWZlRGVjb2RlQXN5bmMiLCAiY2hlY2siLCAianNvbiIsICJab2RTdHJpbmciLCAiX2Vtb2ppIiwgImRhdGV0aW1lIiwgImRhdGUiLCAidGltZSIsICJkdXJhdGlvbiIsICJzdHJpbmciLCAiZW1haWwiLCAiZ3VpZCIsICJ1dWlkIiwgImVtb2ppIiwgIm5hbm9pZCIsICJjdWlkIiwgImN1aWQyIiwgInVsaWQiLCAieGlkIiwgImtzdWlkIiwgImlwdjQiLCAibWFjIiwgImlwdjYiLCAiY2lkcnY0IiwgImNpZHJ2NiIsICJiYXNlNjQiLCAiYmFzZTY0dXJsIiwgImUxNjQiLCAiaG9zdG5hbWUiLCAiaGV4IiwgIlpvZE51bWJlciIsICJudW1iZXIiLCAiWm9kQm9vbGVhbiIsICJib29sZWFuIiwgIlpvZEJpZ0ludCIsICJiaWdpbnQiLCAiWm9kU3ltYm9sIiwgIlpvZFVuZGVmaW5lZCIsICJfdW5kZWZpbmVkIiwgIlpvZE51bGwiLCAiWm9kVHlwZSIsICJqc29uIiwgIl9udWxsIiwgIlpvZEFueSIsICJab2RUeXBlIiwgImpzb24iLCAiWm9kVW5rbm93biIsICJab2ROZXZlciIsICJab2RWb2lkIiwgIl92b2lkIiwgIlpvZERhdGUiLCAiWm9kVHlwZSIsICJqc29uIiwgImRhdGUiLCAiWm9kQXJyYXkiLCAiWm9kT2JqZWN0IiwgIlpvZE9wdGlvbmFsIiwgIm9iamVjdCIsICJab2RVbmlvbiIsICJab2REaXNjcmltaW5hdGVkVW5pb24iLCAiWm9kSW50ZXJzZWN0aW9uIiwgIlpvZFR1cGxlIiwgIlpvZFJlY29yZCIsICJab2RNYXAiLCAiWm9kU2V0IiwgIlpvZEVudW0iLCAiWm9kRW51bSIsICJab2RMaXRlcmFsIiwgIlpvZFR5cGUiLCAianNvbiIsICJpc3N1ZSIsICJvdXRwdXQiLCAiWm9kT3B0aW9uYWwiLCAiWm9kTnVsbGFibGUiLCAibnVsbGlzaCIsICJab2REZWZhdWx0IiwgIlpvZENhdGNoIiwgIlpvZE5hTiIsICJab2RUeXBlIiwgImpzb24iLCAiWm9kUmVhZG9ubHkiLCAiWm9kTGF6eSIsICJab2RQcm9taXNlIiwgIlpvZEZ1bmN0aW9uIiwgIlpvZFR5cGUiLCAianNvbiIsICJkZXNjcmliZSIsICJtZXRhIiwgIlpvZEJvb2xlYW4iLCAiWm9kU3RyaW5nIiwgInN0cmluZyIsICJudW1iZXIiLCAiYm9vbGVhbiIsICJfbnVsbCIsICJab2RGaXJzdFBhcnR5VHlwZUtpbmQiLCAic2NoZW1hc19leHBvcnRzIiwgImNoZWNrc19leHBvcnRzIiwgImlzb19leHBvcnRzIiwgImVuX2RlZmF1bHQiLCAic3RyaW5nIiwgIm51bWJlciIsICJfbnVsbCIsICJvYmplY3QiLCAiRXJyb3JDb2RlIiwgIm9iamVjdCIsICJudW1iZXIiLCAic3RyaW5nIiwgInN0cmluZyIsICJvYmplY3QiLCAiYm9vbGVhbiIsICJvYmplY3QiLCAic3RyaW5nIiwgImJvb2xlYW4iLCAib2JqZWN0IiwgIm51bWJlciIsICJzdHJpbmciLCAiX251bGwiLCAiaXNvX2V4cG9ydHMiLCAiYm9vbGVhbiIsICJvYmplY3QiLCAic3RyaW5nIiwgInN0cmluZyIsICJudW1iZXIiLCAiYm9vbGVhbiIsICJvYmplY3QiLCAic2FmZVBhcnNlIiwgImVycm9yIiwgInRhc2siLCAic2FmZVBhcnNlIiwgImpzb25ycGNOb3RpZmljYXRpb24iLCAiaXNQbGFpbk9iamVjdCIsICJBanYiLCAiX2FkZEZvcm1hdHMiLCAic2FmZVBhcnNlIiwgImVycm9yIiwgInByb2Nlc3MiLCAiZXJyb3IiLCAianNvbiIsICJjb25maWciLCAiZXJyb3IiLCAiZG9tYWluIiwgImVycm9yIl0KfQo=
