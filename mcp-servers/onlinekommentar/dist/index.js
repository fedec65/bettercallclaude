#!/usr/bin/env node
import { createRequire } from 'module'; const require = createRequire(import.meta.url);
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf, __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: !0 }) : target,
  mod
));

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        if (super(), !exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return !1;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super(), this._items = typeof code == "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return !1;
        let item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a2;
        return (_a2 = this._str) !== null && _a2 !== void 0 ? _a2 : this._str = this._items.reduce((s, c) => `${s}${c}`, "");
      }
      get names() {
        var _a2;
        return (_a2 = this._names) !== null && _a2 !== void 0 ? _a2 : this._names = this._items.reduce((names, c) => (c instanceof Name && (names[c.str] = (names[c.str] || 0) + 1), names), {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      let code = [strs[0]], i = 0;
      for (; i < args.length; )
        addCodeArg(code, args[i]), code.push(strs[++i]);
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      let expr = [safeStringify(strs[0])], i = 0;
      for (; i < args.length; )
        expr.push(plus), addCodeArg(expr, args[i]), expr.push(plus, safeStringify(strs[++i]));
      return optimize(expr), new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      arg instanceof _Code ? code.push(...arg._items) : arg instanceof Name ? code.push(arg) : code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      for (; i < expr.length - 1; ) {
        if (expr[i] === plus) {
          let res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string")
        return b instanceof Name || a[a.length - 1] !== '"' ? void 0 : typeof b != "string" ? `${a.slice(0, -1)}${b}"` : b[0] === '"' ? a.slice(0, -1) + b.slice(1) : void 0;
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key))
        return new _Code(`${key}`);
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code(), ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`), this.value = name.value;
      }
    }, UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2.Started = 0] = "Started", UsedValueState2[UsedValueState2.Completed = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {}, this._prefixes = prefixes, this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        let ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a2, _b;
        if (!((_b = (_a2 = this._parent) === null || _a2 === void 0 ? void 0 : _a2._prefixes) === null || _b === void 0) && _b.has(prefix) || this._prefixes && !this._prefixes.has(prefix))
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr), this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value, this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`, ValueScope = class extends Scope {
      constructor(opts) {
        super(opts), this._values = {}, this._scope = opts.scope, this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a2;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        let name = this.toName(nameOrPrefix), { prefix } = name, valueKey = (_a2 = value.key) !== null && _a2 !== void 0 ? _a2 : value.ref, vs = this._values[prefix];
        if (vs) {
          let _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        vs.set(valueKey, name);
        let s = this._scope[prefix] || (this._scope[prefix] = []), itemIndex = s.length;
        return s[itemIndex] = value.ref, name.setValue(value, { property: prefix, itemIndex }), name;
      }
      getValue(prefix, keyOrRef) {
        let vs = this._values[prefix];
        if (vs)
          return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (let prefix in values) {
          let vs = values[prefix];
          if (!vs)
            continue;
          let nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c = valueCode(name);
            if (c) {
              let def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c};${this.opts._n}`;
            } else if (c = getCode?.(name))
              code = (0, code_1._)`${code}${c}${this.opts._n}`;
            else
              throw new ValueError(name);
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code(), scope_1 = require_scope(), code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: !0, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: !0, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: !0, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: !0, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: !0, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: !0, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: !0, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    }, Def = class extends Node {
      constructor(varKind, name, rhs) {
        super(), this.varKind = varKind, this.name = name, this.rhs = rhs;
      }
      render({ es5, _n }) {
        let varKind = es5 ? scope_1.varKinds.var : this.varKind, rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (names[this.name.str])
          return this.rhs && (this.rhs = optimizeExpr(this.rhs, names, constants)), this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    }, Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super(), this.lhs = lhs, this.rhs = rhs, this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!(this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects))
          return this.rhs = optimizeExpr(this.rhs, names, constants), this;
      }
      get names() {
        let names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    }, AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects), this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    }, Label = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    }, Break = class extends Node {
      constructor(label) {
        super(), this.label = label, this.names = {};
      }
      render({ _n }) {
        return `break${this.label ? ` ${this.label}` : ""};` + _n;
      }
    }, Throw = class extends Node {
      constructor(error2) {
        super(), this.error = error2;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    }, AnyCode = class extends Node {
      constructor(code) {
        super(), this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        return this.code = optimizeExpr(this.code, names, constants), this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    }, ParentNode = class extends Node {
      constructor(nodes = []) {
        super(), this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n) => code + n.render(opts), "");
      }
      optimizeNodes() {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i].optimizeNodes();
          Array.isArray(n) ? nodes.splice(i, 1, ...n) : n ? nodes[i] = n : nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        let { nodes } = this, i = nodes.length;
        for (; i--; ) {
          let n = nodes[i];
          n.optimizeNames(names, constants) || (subtractNames(names, n.names), nodes.splice(i, 1));
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n) => addNames(names, n.names), {});
      }
    }, BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    }, Root = class extends ParentNode {
    }, Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes), this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        return this.else && (code += "else " + this.else.render(opts)), code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        let cond = this.condition;
        if (cond === !0)
          return this.nodes;
        let e = this.else;
        if (e) {
          let ns = e.optimizeNodes();
          e = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e)
          return cond === !1 ? e instanceof _If ? e : e.nodes : this.nodes.length ? this : new _If(not(cond), e instanceof _If ? [e] : e.nodes);
        if (!(cond === !1 || !this.nodes.length))
          return this;
      }
      optimizeNames(names, constants) {
        var _a2;
        if (this.else = (_a2 = this.else) === null || _a2 === void 0 ? void 0 : _a2.optimizeNames(names, constants), !!(super.optimizeNames(names, constants) || this.else))
          return this.condition = optimizeExpr(this.condition, names, constants), this;
      }
      get names() {
        let names = super.names;
        return addExprNames(names, this.condition), this.else && addNames(names, this.else.names), names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super(), this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iteration = optimizeExpr(this.iteration, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    }, ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super(), this.varKind = varKind, this.name = name, this.from = from, this.to = to;
      }
      render(opts) {
        let varKind = opts.es5 ? scope_1.varKinds.var : this.varKind, { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        let names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    }, ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super(), this.loop = loop, this.varKind = varKind, this.name = name, this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (super.optimizeNames(names, constants))
          return this.iterable = optimizeExpr(this.iterable, names, constants), this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    }, Func = class extends BlockNode {
      constructor(name, args, async) {
        super(), this.name = name, this.args = args, this.async = async;
      }
      render(opts) {
        return `${this.async ? "async " : ""}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        return this.catch && (code += this.catch.render(opts)), this.finally && (code += this.finally.render(opts)), code;
      }
      optimizeNodes() {
        var _a2, _b;
        return super.optimizeNodes(), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNodes(), (_b = this.finally) === null || _b === void 0 || _b.optimizeNodes(), this;
      }
      optimizeNames(names, constants) {
        var _a2, _b;
        return super.optimizeNames(names, constants), (_a2 = this.catch) === null || _a2 === void 0 || _a2.optimizeNames(names, constants), (_b = this.finally) === null || _b === void 0 || _b.optimizeNames(names, constants), this;
      }
      get names() {
        let names = super.names;
        return this.catch && addNames(names, this.catch.names), this.finally && addNames(names, this.finally.names), names;
      }
    }, Catch = class extends BlockNode {
      constructor(error2) {
        super(), this.error = error2;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {}, this._blockStarts = [], this._constants = {}, this.opts = { ...opts, _n: opts.lines ? `
` : "" }, this._extScope = extScope, this._scope = new scope_1.Scope({ parent: extScope }), this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        let name = this._extScope.value(prefixOrName, value);
        return (this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set())).add(name), name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        let name = this._scope.toName(nameOrPrefix);
        return rhs !== void 0 && constant && (this._constants[name.str] = rhs), this._leafNode(new Def(varKind, name, rhs)), name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c) {
        return typeof c == "function" ? c() : c !== code_1.nil && this._leafNode(new AnyCode(c)), this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        let code = ["{"];
        for (let [key, value] of keyValues)
          code.length > 1 && code.push(","), code.push(key), (key !== value || this.opts.es5) && (code.push(":"), (0, code_1.addCodeArg)(code, value));
        return code.push("}"), new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        if (this._blockNode(new If(condition)), thenBody && elseBody)
          this.code(thenBody).else().code(elseBody).endIf();
        else if (thenBody)
          this.code(thenBody).endIf();
        else if (elseBody)
          throw new Error('CodeGen: "else" body without "then" body');
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        return this._blockNode(node), forBody && this.code(forBody).endFor(), this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        let name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          let arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`), forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties)
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        let name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        let node = new Return();
        if (this._blockNode(node), this.code(value), node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        let node = new Try();
        if (this._blockNode(node), this.code(tryBody), catchCode) {
          let error2 = this.name("e");
          this._currNode = node.catch = new Catch(error2), catchCode(error2);
        }
        return finallyCode && (this._currNode = node.finally = new Finally(), this.code(finallyCode)), this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error2) {
        return this._leafNode(new Throw(error2));
      }
      // start self-balancing block
      block(body, nodeCount) {
        return this._blockStarts.push(this._nodes.length), body && this.code(body).endBlock(nodeCount), this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        let len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        let toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount)
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        return this._nodes.length = len, this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        return this._blockNode(new Func(name, args, async)), funcBody && this.code(funcBody).endFunc(), this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n = 1) {
        for (; n-- > 0; )
          this._root.optimizeNodes(), this._root.optimizeNames(this._root.names, this._constants);
      }
      _leafNode(node) {
        return this._currNode.nodes.push(node), this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node), this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        let n = this._currNode;
        if (n instanceof N1 || N2 && n instanceof N2)
          return this._nodes.pop(), this;
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        let n = this._currNode;
        if (!(n instanceof If))
          throw new Error('CodeGen: "else" without "if"');
        return this._currNode = n.else = node, this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        let ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        let ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) + (from[n] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c) => (c instanceof code_1.Name && (c = replaceName(c)), c instanceof code_1._Code ? items.push(...c._items) : items.push(c), items), []));
      function replaceName(n) {
        let c = constants[n.str];
        return c === void 0 || names[n.str] !== 1 ? n : (delete names[n.str], c);
      }
      function canOptimize(e) {
        return e instanceof code_1._Code && e._items.some((c) => c instanceof code_1.Name && names[c.str] === 1 && constants[c.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (let n in from)
        names[n] = (names[n] || 0) - (from[n] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen(), code_1 = require_code();
    function toHash(arr) {
      let hash2 = {};
      for (let item of arr)
        hash2[item] = !0;
      return hash2;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      return typeof schema == "boolean" ? schema : Object.keys(schema).length === 0 ? !0 : (checkUnknownRules(it, schema), !schemaHasRules(schema, it.self.RULES.all));
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      let { opts, self } = it;
      if (!opts.strictSchema || typeof schema == "boolean")
        return;
      let rules = self.RULES.keywords;
      for (let key in schema)
        rules[key] || checkStrictMode(it, `unknown keyword: "${key}"`);
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (rules[key])
          return !0;
      return !1;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (key !== "$ref" && RULES.all[key])
          return !0;
      return !1;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      return typeof str == "number" ? `${str}` : str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs))
        for (let x of xs)
          f(x);
      else
        f(xs);
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues: mergeValues3, resultToName }) {
      return (gen, from, to, toName) => {
        let res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues3(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, !0), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          from === !0 ? gen.assign(to, !0) : (gen.assign(to, (0, codegen_1._)`${to} || {}`), setEvaluated(gen, to, from));
        }),
        mergeValues: (from, to) => from === !0 ? !0 : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === !0 ? !0 : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === !0 ? !0 : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === !0)
        return gen.var("props", !0);
      let props = gen.var("props", (0, codegen_1._)`{}`);
      return ps !== void 0 && setEvaluated(gen, props, ps), props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, !0));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2.Num = 0] = "Num", Type2[Type2.Str = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        let isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (mode) {
        if (msg = `strict mode: ${msg}`, mode === !0)
          throw new Error(msg);
        it.self.logger.warn(msg);
      }
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error2 = exports.keywordError, errorPaths, overrideAllErrors) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      overrideAllErrors ?? (compositeRule || allErrors) ? addError(gen, errObj) : returnErrors(it, (0, codegen_1._)`[${errObj}]`);
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error2 = exports.keywordError, errorPaths) {
      let { it } = cxt, { gen, compositeRule, allErrors } = it, errObj = errorObjectCode(cxt, error2, errorPaths);
      addError(gen, errObj), compositeRule || allErrors || returnErrors(it, names_1.default.vErrors);
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount), gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      let err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`), gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath))), gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`), it.opts.verbose && (gen.assign((0, codegen_1._)`${err}.schema`, schemaValue), gen.assign((0, codegen_1._)`${err}.data`, data));
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      let err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`), gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      let { gen, validateName, schemaEnv } = it;
      schemaEnv.$async ? gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`) : (gen.assign((0, codegen_1._)`${validateName}.errors`, errs), gen.return(!1));
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error2, errorPaths) {
      let { createErrors } = cxt.it;
      return createErrors === !1 ? (0, codegen_1._)`{}` : errorObject(cxt, error2, errorPaths);
    }
    function errorObject(cxt, error2, errorPaths = {}) {
      let { gen, it } = cxt, keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      return extraErrorProps(cxt, error2, keyValues), gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      let instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      return schemaPath && (schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`), [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      let { keyword, data, schemaValue, it } = cxt, { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]), opts.messages && keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]), opts.verbose && keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]), propertyName && keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors(), codegen_1 = require_codegen(), names_1 = require_names(), boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      let { gen, schema, validateName } = it;
      schema === !1 ? falseSchemaError(it, !1) : typeof schema == "object" && schema.$async === !0 ? gen.return(names_1.default.data) : (gen.assign((0, codegen_1._)`${validateName}.errors`, null), gen.return(!0));
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      let { gen, schema } = it;
      schema === !1 ? (gen.var(valid, !1), falseSchemaError(it)) : gen.var(valid, !0);
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      let { gen, data } = it, cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: !1,
        schemaCode: !1,
        schemaValue: !1,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"], jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      let groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: !0, boolean: !0, null: !0 },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      let group = self.RULES.types[type];
      return group && group !== !0 && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a2;
      return schema[rule.keyword] !== void 0 || ((_a2 = rule.definition.implements) === null || _a2 === void 0 ? void 0 : _a2.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules(), applicability_1 = require_applicability(), errors_1 = require_errors(), codegen_1 = require_codegen(), util_1 = require_util(), DataType;
    (function(DataType2) {
      DataType2[DataType2.Correct = 0] = "Correct", DataType2[DataType2.Wrong = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      let types = getJSONTypes(schema.type);
      if (types.includes("null")) {
        if (schema.nullable === !1)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0)
          throw new Error('"nullable" cannot be used without "type"');
        schema.nullable === !0 && types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      let types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      let { gen, data, opts } = it, coerceTo = coerceToTypes(types, opts.coerceTypes), checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        let wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          coerceTo.length ? coerceData(it, types, coerceTo) : reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t) => COERCIBLE.has(t) || coerceTypes === "array" && t === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      let { gen, data, opts } = it, dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`), coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      opts.coerceTypes === "array" && gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data))), gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (let t of coerceTo)
        (COERCIBLE.has(t) || t === "array" && opts.coerceTypes === "array") && coerceSpecificType(t);
      gen.else(), reportTypeError(it), gen.endIf(), gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced), assignParentData(it, coerced);
      });
      function coerceSpecificType(t) {
        switch (t) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, !1).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, !0);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`), gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      let EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ, cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1)
        return checkDataType(dataTypes[0], data, strictNums, correct);
      let cond, types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        let notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`, delete types.null, delete types.array, delete types.object;
      } else
        cond = codegen_1.nil;
      types.number && delete types.integer;
      for (let t in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      let cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      let { gen, data, schema } = it, schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function assignDefaults(it, ty) {
      let { properties, items } = it.schema;
      if (ty === "object" && properties)
        for (let key in properties)
          assignDefault(it, key, properties[key].default);
      else ty === "array" && Array.isArray(items) && items.forEach((sch, i) => assignDefault(it, i, sch.default));
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      let { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      let childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      opts.useDefaults === "empty" && (condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`), gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), names_1 = require_names(), util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      let { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, !0), cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, !0), cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      let cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      let dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data, valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      it.opts.dynamicRef && valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      let args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      let u = opts.unicodeRegExp ? "u" : "", { regExp } = opts.code, rx = regExp(pattern, u);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      if (it.allErrors) {
        let validArr = gen.let("valid", !0);
        return validateItems(() => gen.assign(validArr, !1)), validArr;
      }
      return gen.var(valid, !0), validateItems(() => gen.break()), valid;
      function validateItems(notValid) {
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid), gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      let { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      if (schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch)) && !it.opts.unevaluated)
        return;
      let valid = gen.let("valid", !1), schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        let schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: !0
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`), cxt.mergeValidEvaluated(schCxt, schValid) || gen.if((0, codegen_1.not)(valid));
      })), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
    }
    exports.validateUnion = validateUnion;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen(), names_1 = require_names(), code_1 = require_code2(), errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      let { gen, keyword, schema, parentSchema, it } = cxt, macroSchema = def.macro.call(it.self, schema, parentSchema, it), schemaRef = useKeyword(gen, keyword, macroSchema);
      it.opts.validateSchema !== !1 && it.self.validateSchema(macroSchema, !0);
      let valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: !0
      }, valid), cxt.pass(valid, () => cxt.error(!0));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a2;
      let { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      let validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate, validateRef = useKeyword(gen, keyword, validate), valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword), cxt.ok((_a2 = def.valid) !== null && _a2 !== void 0 ? _a2 : valid);
      function validateKeyword() {
        if (def.errors === !1)
          assignValid(), def.modifying && modifyData(cxt), reportErrs(() => cxt.error());
        else {
          let ruleErrs = def.async ? validateAsync() : validateSync();
          def.modifying && modifyData(cxt), reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        let ruleErrs = gen.let("ruleErrs", null);
        return gen.try(() => assignValid((0, codegen_1._)`await `), (e) => gen.assign(valid, !1).if((0, codegen_1._)`${e} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e}.errors`), () => gen.throw(e))), ruleErrs;
      }
      function validateSync() {
        let validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        return gen.assign(validateErrs, null), assignValid(codegen_1.nil), validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        let passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self, passSchema = !("compile" in def && !$data || def.schema === !1);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a3;
        gen.if((0, codegen_1.not)((_a3 = def.valid) !== null && _a3 !== void 0 ? _a3 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      let { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      let { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`), (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = !1) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema > "u");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword)
        throw new Error("ajv implementation error");
      let deps = def.dependencies;
      if (deps?.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd)))
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      if (def.validateSchema && !def.validateSchema(schema[keyword])) {
        let msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
        if (opts.validateSchema === "log")
          self.logger.error(msg);
        else
          throw new Error(msg);
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0)
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      if (keyword !== void 0) {
        let sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0)
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0)
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      let { gen } = it;
      if (dataProp !== void 0) {
        let { errorPath, dataPathArr, opts } = it, nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, !0);
        dataContextProps(nextData), subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`, subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`, subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        let nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, !0);
        dataContextProps(nextData), propertyName !== void 0 && (subschema.propertyName = propertyName);
      }
      dataTypes && (subschema.dataTypes = dataTypes);
      function dataContextProps(_nextData) {
        subschema.data = _nextData, subschema.dataLevel = it.dataLevel + 1, subschema.dataTypes = [], it.definedProperties = /* @__PURE__ */ new Set(), subschema.parentData = it.data, subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      compositeRule !== void 0 && (subschema.compositeRule = compositeRule), createErrors !== void 0 && (subschema.createErrors = createErrors), allErrors !== void 0 && (subschema.allErrors = allErrors), subschema.jtdDiscriminator = jtdDiscriminator, subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// mcp-servers-src/node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "mcp-servers-src/node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return !0;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return !1;
        var length, i, keys;
        if (Array.isArray(a)) {
          if (length = a.length, length != b.length) return !1;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return !1;
          return !0;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        if (keys = Object.keys(a), length = keys.length, length !== Object.keys(b).length) return !1;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return !1;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal(a[key], b[key])) return !1;
        }
        return !0;
      }
      return a !== a && b !== b;
    };
  }
});

// mcp-servers-src/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "mcp-servers-src/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      typeof opts == "function" && (cb = opts, opts = {}), cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      }, post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: !0,
      items: !0,
      contains: !0,
      additionalProperties: !0,
      propertyNames: !0,
      not: !0,
      if: !0,
      then: !0,
      else: !0
    };
    traverse.arrayKeywords = {
      items: !0,
      allOf: !0,
      anyOf: !0,
      oneOf: !0
    };
    traverse.propsKeywords = {
      $defs: !0,
      definitions: !0,
      properties: !0,
      patternProperties: !0,
      dependencies: !0
    };
    traverse.skipKeywords = {
      default: !0,
      enum: !0,
      const: !0,
      required: !0,
      maximum: !0,
      minimum: !0,
      exclusiveMaximum: !0,
      exclusiveMinimum: !0,
      multipleOf: !0,
      maxLength: !0,
      minLength: !0,
      pattern: !0,
      format: !0,
      maxItems: !0,
      minItems: !0,
      uniqueItems: !0,
      maxProperties: !0,
      minProperties: !0
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords)
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object")
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          } else (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) && _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util(), equal = require_fast_deep_equal(), traverse = require_json_schema_traverse(), SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = !0) {
      return typeof schema == "boolean" ? !0 : limit === !0 ? !hasRef(schema) : limit ? countKeys(schema) <= limit : !1;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (let key in schema) {
        if (REF_KEYWORDS.has(key))
          return !0;
        let sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef) || typeof sch == "object" && hasRef(sch))
          return !0;
      }
      return !1;
    }
    function countKeys(schema) {
      let count = 0;
      for (let key in schema) {
        if (key === "$ref")
          return 1 / 0;
        if (count++, !SIMPLE_INLINED.has(key) && (typeof schema[key] == "object" && (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch)), count === 1 / 0))
          return 1 / 0;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      normalize !== !1 && (id = normalizeId(id));
      let p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      return resolver.serialize(p).split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      return id = normalizeId(id), resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      let { schemaId, uriResolver } = this.opts, schId = normalizeId(schema[schemaId] || baseId), baseIds = { "": schId }, pathPrefix = getFullPath(uriResolver, schId, !1), localRefs = {}, schemaRefs = /* @__PURE__ */ new Set();
      return traverse(schema, { allKeys: !0 }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        let fullPath = pathPrefix + jsonPtr, innerBaseId = baseIds[parentJsonPtr];
        typeof sch[schemaId] == "string" && (innerBaseId = addRef.call(this, sch[schemaId])), addAnchor.call(this, sch.$anchor), addAnchor.call(this, sch.$dynamicAnchor), baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          let _resolve = this.opts.uriResolver.resolve;
          if (ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref), schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          return typeof schOrRef == "string" && (schOrRef = this.refs[schOrRef]), typeof schOrRef == "object" ? checkAmbiguosRef(sch, schOrRef.schema, ref) : ref !== normalizeId(fullPath) && (ref[0] === "#" ? (checkAmbiguosRef(sch, localRefs[ref], ref), localRefs[ref] = sch) : this.refs[ref] = fullPath), ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      }), localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema(), dataType_1 = require_dataType(), applicability_1 = require_applicability(), dataType_2 = require_dataType(), defaults_1 = require_defaults(), keyword_1 = require_keyword(), subschema_1 = require_subschema(), codegen_1 = require_codegen(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        topSchemaObjCode(it);
        return;
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      opts.code.es5 ? gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
        gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`), destructureValCxtES5(gen, opts), gen.code(body);
      }) : gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`), gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`), gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`), gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`), gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`), gen.var(names_1.default.rootData, names_1.default.data), opts.dynamicRef && gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      let { schema, opts, gen } = it;
      validateFunction(it, () => {
        opts.$comment && schema.$comment && commentKeyword(it), checkNoDefault(it), gen.let(names_1.default.vErrors, null), gen.let(names_1.default.errors, 0), opts.unevaluated && resetEvaluated(it), typeAndKeywords(it), returnResults(it);
      });
    }
    function resetEvaluated(it) {
      let { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`), gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`)), gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      let schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it) && (checkKeywords(it), schemaCxtHasRules(it))) {
        subSchemaObjCode(it, valid);
        return;
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (let key in schema)
        if (self.RULES.all[key])
          return !0;
      return !1;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      let { schema, gen, opts } = it;
      opts.$comment && schema.$comment && commentKeyword(it), updateContext(it), checkAsyncSchema(it);
      let errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount), gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it), checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], !1, errsCount);
      let types = (0, dataType_1.getSchemaTypes)(it.schema), checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      let { schema, errSchemaPath, opts, self } = it;
      schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES) && self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
    }
    function checkNoDefault(it) {
      let { schema, opts } = it;
      schema.default !== void 0 && opts.useDefaults && opts.strictSchema && (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
    }
    function updateContext(it) {
      let schId = it.schema[it.opts.schemaId];
      schId && (it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId));
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      let msg = schema.$comment;
      if (opts.$comment === !0)
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      else if (typeof opts.$comment == "function") {
        let schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`, rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      let { gen, schemaEnv, validateName, ValidationError, opts } = it;
      schemaEnv.$async ? gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`)) : (gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors), opts.unevaluated && assignEvaluated(it), gen.return((0, codegen_1._)`${names_1.default.errors} === 0`));
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      props instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.props`, props), items instanceof codegen_1.Name && gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      let { gen, schema, data, allErrors, opts, self } = it, { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      opts.jtd || checkStrictTypes(it, types), gen.block(() => {
        for (let group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        (0, applicability_1.shouldUseGroup)(schema, group) && (group.type ? (gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers)), iterateKeywords(it, group), types.length === 1 && types[0] === group.type && typeErrors && (gen.else(), (0, dataType_2.reportTypeError)(it)), gen.endIf()) : iterateKeywords(it, group), allErrors || gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`));
      }
    }
    function iterateKeywords(it, group) {
      let { gen, schema, opts: { useDefaults } } = it;
      useDefaults && (0, defaults_1.assignDefaults)(it, group.type), gen.block(() => {
        for (let rule of group.rules)
          (0, applicability_1.shouldUseRule)(schema, rule) && keywordCode(it, rule.keyword, rule.definition, group.type);
      });
    }
    function checkStrictTypes(it, types) {
      it.schemaEnv.meta || !it.opts.strictTypes || (checkContextTypes(it, types), it.opts.allowUnionTypes || checkMultipleTypes(it, types), checkKeywordTypes(it, it.dataTypes));
    }
    function checkContextTypes(it, types) {
      if (types.length) {
        if (!it.dataTypes.length) {
          it.dataTypes = types;
          return;
        }
        types.forEach((t) => {
          includesType(it.dataTypes, t) || strictTypesError(it, `type "${t}" not allowed by context "${it.dataTypes.join(",")}"`);
        }), narrowSchemaTypes(it, types);
      }
    }
    function checkMultipleTypes(it, ts) {
      ts.length > 1 && !(ts.length === 2 && ts.includes("null")) && strictTypesError(it, "use allowUnionTypes to allow union type keyword");
    }
    function checkKeywordTypes(it, ts) {
      let rules = it.self.RULES.all;
      for (let keyword in rules) {
        let rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          let { type } = rule.definition;
          type.length && !type.some((t) => hasApplicableType(ts, t)) && strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t) {
      return ts.includes(t) || t === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      let ts = [];
      for (let t of it.dataTypes)
        includesType(withTypes, t) ? ts.push(t) : withTypes.includes("integer") && t === "number" && ts.push("integer");
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      let schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`, (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        if ((0, keyword_1.validateKeywordUsage)(it, def, keyword), this.gen = it.gen, this.allErrors = it.allErrors, this.keyword = keyword, this.data = it.data, this.schema = it.schema[keyword], this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data, this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data), this.schemaType = def.schemaType, this.parentSchema = it.schema, this.params = {}, this.it = it, this.def = def, this.$data)
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        else if (this.schemaCode = this.schemaValue, !(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined))
          throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
        ("code" in def ? def.trackErrors : def.errors !== !1) && (this.errsCount = it.gen.const("_errs", names_1.default.errors));
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition), failAction ? failAction() : this.error(), successAction ? (this.gen.else(), successAction(), this.allErrors && this.gen.endIf()) : this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error(), this.allErrors || this.gen.if(!1);
          return;
        }
        this.gen.if(condition), this.error(), this.allErrors ? this.gen.endIf() : this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        let { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams), this._error(append, errorPaths), this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        this.allErrors || this.gen.if(cond);
      }
      setParams(obj, assign) {
        assign ? Object.assign(this.params, obj) : this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid), codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        let { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid)), valid !== codegen_1.nil && gen.assign(valid, !0), (schemaType.length || def.validateSchema) && (gen.elseIf(this.invalid$data()), this.$dataError(), valid !== codegen_1.nil && gen.assign(valid, !1)), gen.else();
      }
      invalid$data() {
        let { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            let st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            let validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        let subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl), (0, subschema_1.extendSubschemaMode)(subschema, appl);
        let nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        return subschemaCode(nextContext, valid), nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        let { it, gen } = this;
        it.opts.unevaluated && (it.props !== !0 && schemaCxt.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName)), it.items !== !0 && schemaCxt.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName)));
      }
      mergeValidEvaluated(schemaCxt, valid) {
        let { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== !0 || it.items !== !0))
          return gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name)), !0;
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      let cxt = new KeywordCxt(it, def, keyword);
      "code" in def ? def.code(cxt, ruleType) : cxt.$data && def.validate ? (0, keyword_1.funcKeywordCode)(cxt, def) : "macro" in def ? (0, keyword_1.macroKeywordCode)(cxt, def) : (def.compile || def.validate) && (0, keyword_1.funcKeywordCode)(cxt, def);
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/, RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer, data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data, data = names_1.default.rootData;
      } else {
        let matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        let up = +matches[1];
        if (jsonPointer = matches[2], jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        if (data = dataNames[dataLevel - up], !jsonPointer)
          return data;
      }
      let expr = data, segments = jsonPointer.split("/");
      for (let segment of segments)
        segment && (data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`, expr = (0, codegen_1._)`${expr} && ${data}`);
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed"), this.errors = errors, this.ajv = this.validation = !0;
      }
    };
    exports.default = ValidationError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var resolve_1 = require_resolve(), MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`), this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref), this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// mcp-servers-src/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen(), validation_error_1 = require_validation_error(), names_1 = require_names(), resolve_1 = require_resolve(), util_1 = require_util(), validate_1 = require_validate(), SchemaEnv = class {
      constructor(env) {
        var _a2;
        this.refs = {}, this.dynamicAnchors = {};
        let schema;
        typeof env.schema == "object" && (schema = env.schema), this.schema = env.schema, this.schemaId = env.schemaId, this.root = env.root || this, this.baseId = (_a2 = env.baseId) !== null && _a2 !== void 0 ? _a2 : (0, resolve_1.normalizeId)(schema?.[env.schemaId || "$id"]), this.schemaPath = env.schemaPath, this.localRefs = env.localRefs, this.meta = env.meta, this.$async = schema?.$async, this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      let _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      let rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId), { es5, lines } = this.opts.code, { ownProperties } = this.opts, gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties }), _ValidationError;
      sch.$async && (_ValidationError = gen.scopeValue("Error", {
        ref: validation_error_1.default,
        code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
      }));
      let validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      let schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === !0 ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      }, sourceCode;
      try {
        this._compilations.add(sch), (0, validate_1.validateFunctionCode)(schemaCxt), gen.optimize(this.opts.code.optimize);
        let validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`, this.opts.code.process && (sourceCode = this.opts.code.process(sourceCode, sch));
        let validate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode)(this, this.scope.get());
        if (this.scope.value(validateName, { ref: validate }), validate.errors = null, validate.schema = sch.schema, validate.schemaEnv = sch, sch.$async && (validate.$async = !0), this.opts.code.source === !0 && (validate.source = { validateName, validateCode, scopeValues: gen._values }), this.opts.unevaluated) {
          let { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          }, validate.source && (validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated));
        }
        return sch.validate = validate, sch;
      } catch (e) {
        throw delete sch.validate, delete sch.validateName, sourceCode && this.logger.error("Error compiling schema, function code:", sourceCode), e;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a2;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      let schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        let schema = (_a2 = root.localRefs) === null || _a2 === void 0 ? void 0 : _a2[ref], { schemaId } = this.opts;
        schema && (_sch = new SchemaEnv({ schema, schemaId, root, baseId }));
      }
      if (_sch !== void 0)
        return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      return (0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs) ? sch.schema : sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (let sch of this._compilations)
        if (sameSchemaEnv(sch, schEnv))
          return sch;
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      for (; typeof (sch = this.refs[ref]) == "string"; )
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      let p = this.opts.uriResolver.parse(ref), refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p), baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId)
        return getJsonPointer.call(this, p, root);
      let id = (0, resolve_1.normalizeId)(refPath), schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        let sch = resolveSchema.call(this, root, schOrRef);
        return typeof sch?.schema != "object" ? void 0 : getJsonPointer.call(this, p, sch);
      }
      if (typeof schOrRef?.schema == "object") {
        if (schOrRef.validate || compileSchema.call(this, schOrRef), id === (0, resolve_1.normalizeId)(ref)) {
          let { schema } = schOrRef, { schemaId } = this.opts, schId = schema[schemaId];
          return schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId)), new SchemaEnv({ schema, schemaId, root, baseId });
        }
        return getJsonPointer.call(this, p, schOrRef);
      }
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a2;
      if (((_a2 = parsedRef.fragment) === null || _a2 === void 0 ? void 0 : _a2[0]) !== "/")
        return;
      for (let part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema == "boolean")
          return;
        let partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        let schId = typeof schema == "object" && schema[this.opts.schemaId];
        !PREVENT_SCOPE_CHANGE.has(part) && schId && (baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId));
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        let $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      let { schemaId } = this.opts;
      if (env = env || new SchemaEnv({ schema, schemaId, root, baseId }), env.schema !== env.root.schema)
        return env;
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: !1
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu), isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "", code = 0, i = 0;
      for (i = 0; i < input.length; i++)
        if (code = input[i].charCodeAt(0), code !== 48) {
          if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
            return "";
          acc += input[i];
          break;
        }
      for (i += 1; i < input.length; i++) {
        if (code = input[i].charCodeAt(0), !(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102))
          return "";
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      return buffer.length = 0, !0;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        let hex3 = stringArrayToHexStripped(buffer);
        if (hex3 !== "")
          address.push(hex3);
        else
          return output.error = !0, !1;
        buffer.length = 0;
      }
      return !0;
    }
    function getIPV6(input) {
      let tokenCount = 0, output = { error: !1, address: "", zone: "" }, address = [], buffer = [], endipv6Encountered = !1, endIpv6 = !1, consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        let cursor = input[i];
        if (!(cursor === "[" || cursor === "]"))
          if (cursor === ":") {
            if (endipv6Encountered === !0 && (endIpv6 = !0), !consume(buffer, address, output))
              break;
            if (++tokenCount > 7) {
              output.error = !0;
              break;
            }
            i > 0 && input[i - 1] === ":" && (endipv6Encountered = !0), address.push(":");
            continue;
          } else if (cursor === "%") {
            if (!consume(buffer, address, output))
              break;
            consume = consumeIsZone;
          } else {
            buffer.push(cursor);
            continue;
          }
      }
      return buffer.length && (consume === consumeIsZone ? output.zone = buffer.join("") : endIpv6 ? address.push(buffer.join("")) : address.push(stringArrayToHexStripped(buffer))), output.address = address.join(""), output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2)
        return { host, isIPV6: !1 };
      let ipv63 = getIPV6(host);
      if (ipv63.error)
        return { host, isIPV6: !1 };
      {
        let newHost = ipv63.address, escapedHost = ipv63.address;
        return ipv63.zone && (newHost += "%" + ipv63.zone, escapedHost += "%25" + ipv63.zone), { host: newHost, isIPV6: !0, escapedHost };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++)
        str[i] === token && ind++;
      return ind;
    }
    function removeDotSegments(path) {
      let input = path, output = [], nextSlash = -1, len = 0;
      for (; len = input.length; ) {
        if (len === 1) {
          if (input === ".")
            break;
          if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".")
              break;
            if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/" && (input[1] === "." || input[1] === "/")) {
            output.push("/");
            break;
          }
        } else if (len === 3 && input === "/..") {
          output.length !== 0 && output.pop(), output.push("/");
          break;
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/" && input[1] === ".") {
          if (input[2] === "/") {
            input = input.slice(2);
            continue;
          } else if (input[2] === "." && input[3] === "/") {
            input = input.slice(3), output.length !== 0 && output.pop();
            continue;
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else
          output.push(input.slice(0, nextSlash)), input = input.slice(nextSlash);
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc2) {
      let func = esc2 !== !0 ? escape : unescape;
      return component.scheme !== void 0 && (component.scheme = func(component.scheme)), component.userinfo !== void 0 && (component.userinfo = func(component.userinfo)), component.host !== void 0 && (component.host = func(component.host)), component.path !== void 0 && (component.path = func(component.path)), component.query !== void 0 && (component.query = func(component.query)), component.fragment !== void 0 && (component.fragment = func(component.fragment)), component;
    }
    function recomposeAuthority(component) {
      let uriTokens = [];
      if (component.userinfo !== void 0 && (uriTokens.push(component.userinfo), uriTokens.push("@")), component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          let ipV6res = normalizeIPv6(host);
          ipV6res.isIPV6 === !0 ? host = `[${ipV6res.escapedHost}]` : host = component.host;
        }
        uriTokens.push(host);
      }
      return (typeof component.port == "number" || typeof component.port == "string") && (uriTokens.push(":"), uriTokens.push(String(component.port))), uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var { isUUID } = require_utils(), URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu, supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      return wsComponent.secure === !0 ? !0 : wsComponent.secure === !1 ? !1 : wsComponent.scheme ? wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S") : !1;
    }
    function httpParse(component) {
      return component.host || (component.error = component.error || "HTTP URIs must have a host."), component;
    }
    function httpSerialize(component) {
      let secure = String(component.scheme).toLowerCase() === "https";
      return (component.port === (secure ? 443 : 80) || component.port === "") && (component.port = void 0), component.path || (component.path = "/"), component;
    }
    function wsParse(wsComponent) {
      return wsComponent.secure = wsIsSecure(wsComponent), wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : ""), wsComponent.path = void 0, wsComponent.query = void 0, wsComponent;
    }
    function wsSerialize(wsComponent) {
      if ((wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") && (wsComponent.port = void 0), typeof wsComponent.secure == "boolean" && (wsComponent.scheme = wsComponent.secure ? "wss" : "ws", wsComponent.secure = void 0), wsComponent.resourceName) {
        let [path, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path && path !== "/" ? path : void 0, wsComponent.query = query, wsComponent.resourceName = void 0;
      }
      return wsComponent.fragment = void 0, wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path)
        return urnComponent.error = "URN can not be parsed", urnComponent;
      let matches = urnComponent.path.match(URN_REG);
      if (matches) {
        let scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase(), urnComponent.nss = matches[2];
        let urnScheme = `${scheme}:${options.nid || urnComponent.nid}`, schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0, schemeHandler && (urnComponent = schemeHandler.parse(urnComponent, options));
      } else
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0)
        throw new Error("URN without nid cannot be serialized");
      let scheme = options.scheme || urnComponent.scheme || "urn", nid = urnComponent.nid.toLowerCase(), urnScheme = `${scheme}:${options.nid || nid}`, schemeHandler = getSchemeHandler(urnScheme);
      schemeHandler && (urnComponent = schemeHandler.serialize(urnComponent, options));
      let uriComponent = urnComponent, nss = urnComponent.nss;
      return uriComponent.path = `${nid || options.nid}:${nss}`, options.skipEscape = !0, uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      let uuidComponent = urnComponent;
      return uuidComponent.uuid = uuidComponent.nss, uuidComponent.nss = void 0, !options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid)) && (uuidComponent.error = uuidComponent.error || "UUID is not valid."), uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      let urnComponent = uuidComponent;
      return urnComponent.nss = (uuidComponent.uuid || "").toLowerCase(), urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: !0,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    ), ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: !0,
        parse: wsParse,
        serialize: wsSerialize
      }
    ), wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    ), urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: !0
      }
    ), urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: !0
      }
    ), SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// mcp-servers-src/node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "mcp-servers-src/node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils(), { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      return typeof uri == "string" ? uri = /** @type {T} */
      serialize(parse3(uri, options), options) : typeof uri == "object" && (uri = /** @type {T} */
      parse3(serialize(uri, options), options)), uri;
    }
    function resolve(baseURI, relativeURI, options) {
      let schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" }, resolved = resolveComponent(parse3(baseURI, schemelessOptions), parse3(relativeURI, schemelessOptions), schemelessOptions, !0);
      return schemelessOptions.skipEscape = !0, serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      let target = {};
      return skipNormalization || (base = parse3(serialize(base, options), options), relative = parse3(serialize(relative, options), options)), options = options || {}, !options.tolerant && relative.scheme ? (target.scheme = relative.scheme, target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0 ? (target.userinfo = relative.userinfo, target.host = relative.host, target.port = relative.port, target.path = removeDotSegments(relative.path || ""), target.query = relative.query) : (relative.path ? (relative.path[0] === "/" ? target.path = removeDotSegments(relative.path) : ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path ? target.path = "/" + relative.path : base.path ? target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path : target.path = relative.path, target.path = removeDotSegments(target.path)), target.query = relative.query) : (target.path = base.path, relative.query !== void 0 ? target.query = relative.query : target.query = base.query), target.userinfo = base.userinfo, target.host = base.host, target.port = base.port), target.scheme = base.scheme), target.fragment = relative.fragment, target;
    }
    function equal(uriA, uriB, options) {
      return typeof uriA == "string" ? (uriA = unescape(uriA), uriA = serialize(normalizeComponentEncoding(parse3(uriA, options), !0), { ...options, skipEscape: !0 })) : typeof uriA == "object" && (uriA = serialize(normalizeComponentEncoding(uriA, !0), { ...options, skipEscape: !0 })), typeof uriB == "string" ? (uriB = unescape(uriB), uriB = serialize(normalizeComponentEncoding(parse3(uriB, options), !0), { ...options, skipEscape: !0 })) : typeof uriB == "object" && (uriB = serialize(normalizeComponentEncoding(uriB, !0), { ...options, skipEscape: !0 })), uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      let component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      }, options = Object.assign({}, opts), uriTokens = [], schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      schemeHandler && schemeHandler.serialize && schemeHandler.serialize(component, options), component.path !== void 0 && (options.skipEscape ? component.path = unescape(component.path) : (component.path = escape(component.path), component.scheme !== void 0 && (component.path = component.path.split("%3A").join(":")))), options.reference !== "suffix" && component.scheme && uriTokens.push(component.scheme, ":");
      let authority = recomposeAuthority(component);
      if (authority !== void 0 && (options.reference !== "suffix" && uriTokens.push("//"), uriTokens.push(authority), component.path && component.path[0] !== "/" && uriTokens.push("/")), component.path !== void 0) {
        let s = component.path;
        !options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath) && (s = removeDotSegments(s)), authority === void 0 && s[0] === "/" && s[1] === "/" && (s = "/%2F" + s.slice(2)), uriTokens.push(s);
      }
      return component.query !== void 0 && uriTokens.push("?", component.query), component.fragment !== void 0 && uriTokens.push("#", component.fragment), uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse3(uri, opts) {
      let options = Object.assign({}, opts), parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      }, isIP = !1;
      options.reference === "suffix" && (options.scheme ? uri = options.scheme + ":" + uri : uri = "//" + uri);
      let matches = uri.match(URI_PARSE);
      if (matches) {
        if (parsed.scheme = matches[1], parsed.userinfo = matches[3], parsed.host = matches[4], parsed.port = parseInt(matches[5], 10), parsed.path = matches[6] || "", parsed.query = matches[7], parsed.fragment = matches[8], isNaN(parsed.port) && (parsed.port = matches[5]), parsed.host)
          if (isIPv4(parsed.host) === !1) {
            let ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase(), isIP = ipv6result.isIPV6;
          } else
            isIP = !0;
        parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path ? parsed.reference = "same-document" : parsed.scheme === void 0 ? parsed.reference = "relative" : parsed.fragment === void 0 ? parsed.reference = "absolute" : parsed.reference = "uri", options.reference && options.reference !== "suffix" && options.reference !== parsed.reference && (parsed.error = parsed.error || "URI is not a " + options.reference + " reference.");
        let schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport) && parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === !1 && nonSimpleDomain(parsed.host))
          try {
            parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
          } catch (e) {
            parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e;
          }
        (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) && (uri.indexOf("%") !== -1 && (parsed.scheme !== void 0 && (parsed.scheme = unescape(parsed.scheme)), parsed.host !== void 0 && (parsed.host = unescape(parsed.host))), parsed.path && (parsed.path = escape(unescape(parsed.path))), parsed.fragment && (parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment)))), schemeHandler && schemeHandler.parse && schemeHandler.parse(parsed, options);
      } else
        parsed.error = parsed.error || "URI can not be parsed.";
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse3
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// mcp-servers-src/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error(), ref_error_1 = require_ref_error(), rules_1 = require_rules(), compile_1 = require_compile(), codegen_2 = require_codegen(), resolve_1 = require_resolve(), dataType_1 = require_dataType(), util_1 = require_util(), $dataRefSchema = require_data(), uri_1 = require_uri(), defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"], EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]), removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    }, deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    }, MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      let s = o.strict, _optz = (_a2 = o.code) === null || _a2 === void 0 ? void 0 : _a2.optimize, optimize = _optz === !0 || _optz === void 0 ? 1 : _optz || 0, regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp, uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : !0,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : !0,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : !1,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : !0,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : !0,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : !0,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : !0,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : !0,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : !0,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : !0,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : !0,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {}, this.refs = {}, this.formats = {}, this._compilations = /* @__PURE__ */ new Set(), this._loading = {}, this._cache = /* @__PURE__ */ new Map(), opts = this.opts = { ...opts, ...requiredOptions(opts) };
        let { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines }), this.logger = getLogger(opts.logger);
        let formatOpt = opts.validateFormats;
        opts.validateFormats = !1, this.RULES = (0, rules_1.getRules)(), checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED"), checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn"), this._metaOpts = getMetaSchemaOptions.call(this), opts.formats && addInitialFormats.call(this), this._addVocabularies(), this._addDefaultMetaSchema(), opts.keywords && addInitialKeywords.call(this, opts.keywords), typeof opts.meta == "object" && this.addMetaSchema(opts.meta), addInitialSchemas.call(this), opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        let { $data, meta: meta3, schemaId } = this.opts, _dataRefSchema = $dataRefSchema;
        schemaId === "id" && (_dataRefSchema = { ...$dataRefSchema }, _dataRefSchema.id = _dataRefSchema.$id, delete _dataRefSchema.$id), meta3 && $data && this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], !1);
      }
      defaultMeta() {
        let { meta: meta3, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta3 == "object" ? meta3[schemaId] || meta3 : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          if (v = this.getSchema(schemaKeyRef), !v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else
          v = this.compile(schemaKeyRef);
        let valid = v(data);
        return "$async" in v || (this.errors = v.errors), valid;
      }
      compile(schema, _meta) {
        let sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta3) {
        if (typeof this.opts.loadSchema != "function")
          throw new Error("options.loadSchema should be a function");
        let { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta3);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          let sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          $ref && !this.getSchema($ref) && await runCompileAsync.call(this, { $ref }, !0);
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e) {
            if (!(e instanceof ref_error_1.default))
              throw e;
            return checkLoaded.call(this, e), await loadMissingSchema.call(this, e.missingSchema), _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref])
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
        }
        async function loadMissingSchema(ref) {
          let _schema = await _loadSchema.call(this, ref);
          this.refs[ref] || await loadMetaSchema.call(this, _schema.$schema), this.refs[ref] || this.addSchema(_schema, ref, meta3);
        }
        async function _loadSchema(ref) {
          let p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (let sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema == "object") {
          let { schemaId } = this.opts;
          if (id = schema[schemaId], id !== void 0 && typeof id != "string")
            throw new Error(`schema ${schemaId} must be string`);
        }
        return key = (0, resolve_1.normalizeId)(key || id), this._checkUnique(key), this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, !0), this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        return this.addSchema(schema, key, !0, _validateSchema), this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return !0;
        let $schema;
        if ($schema = schema.$schema, $schema !== void 0 && typeof $schema != "string")
          throw new Error("$schema must be a string");
        if ($schema = $schema || this.opts.defaultMeta || this.defaultMeta(), !$schema)
          return this.logger.warn("meta-schema not available"), this.errors = null, !0;
        let valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          let message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        for (; typeof (sch = getSchEnv.call(this, keyRef)) == "string"; )
          keyRef = sch;
        if (sch === void 0) {
          let { schemaId } = this.opts, root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          if (sch = compile_1.resolveSchema.call(this, root, keyRef), !sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp)
          return this._removeAllSchemas(this.schemas, schemaKeyRef), this._removeAllSchemas(this.refs, schemaKeyRef), this;
        switch (typeof schemaKeyRef) {
          case "undefined":
            return this._removeAllSchemas(this.schemas), this._removeAllSchemas(this.refs), this._cache.clear(), this;
          case "string": {
            let sch = getSchEnv.call(this, schemaKeyRef);
            return typeof sch == "object" && this._cache.delete(sch.schema), delete this.schemas[schemaKeyRef], delete this.refs[schemaKeyRef], this;
          }
          case "object": {
            let cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            return id && (id = (0, resolve_1.normalizeId)(id), delete this.schemas[id], delete this.refs[id]), this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (let def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string")
          keyword = kwdOrDef, typeof def == "object" && (this.logger.warn("these parameters are deprecated, see docs for addKeyword"), def.keyword = keyword);
        else if (typeof kwdOrDef == "object" && def === void 0) {
          if (def = kwdOrDef, keyword = def.keyword, Array.isArray(keyword) && !keyword.length)
            throw new Error("addKeywords: keyword must be string or non-empty array");
        } else
          throw new Error("invalid addKeywords parameters");
        if (checkKeyword.call(this, keyword, def), !def)
          return (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd)), this;
        keywordMetaschema.call(this, def);
        let definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        return (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t) => addRule.call(this, k, definition, t))), this;
      }
      getKeyword(keyword) {
        let rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        let { RULES } = this;
        delete RULES.keywords[keyword], delete RULES.all[keyword];
        for (let group of RULES.rules) {
          let i = group.rules.findIndex((rule) => rule.keyword === keyword);
          i >= 0 && group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        return typeof format == "string" && (format = new RegExp(format)), this.formats[name] = format, this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        return !errors || errors.length === 0 ? "No errors" : errors.map((e) => `${dataVar}${e.instancePath} ${e.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        let rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (let jsonPointer of keywordsJsonPointers) {
          let segments = jsonPointer.split("/").slice(1), keywords = metaSchema;
          for (let seg of segments)
            keywords = keywords[seg];
          for (let key in rules) {
            let rule = rules[key];
            if (typeof rule != "object")
              continue;
            let { $data } = rule.definition, schema = keywords[key];
            $data && schema && (keywords[key] = schemaOrData(schema));
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (let keyRef in schemas) {
          let sch = schemas[keyRef];
          (!regex || regex.test(keyRef)) && (typeof sch == "string" ? delete schemas[keyRef] : sch && !sch.meta && (this._cache.delete(sch.schema), delete schemas[keyRef]));
        }
      }
      _addSchema(schema, meta3, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id, { schemaId } = this.opts;
        if (typeof schema == "object")
          id = schema[schemaId];
        else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        let localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        return sch = new compile_1.SchemaEnv({ schema, schemaId, meta: meta3, baseId, localRefs }), this._cache.set(sch.schema, sch), addSchema && !baseId.startsWith("#") && (baseId && this._checkUnique(baseId), this.refs[baseId] = sch), validateSchema && this.validateSchema(schema, !0), sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id])
          throw new Error(`schema with key or id "${id}" already exists`);
      }
      _compileSchemaEnv(sch) {
        if (sch.meta ? this._compileMetaSchema(sch) : compile_1.compileSchema.call(this, sch), !sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        let currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (let key in checkOpts) {
        let opt = key;
        opt in options && this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      return keyRef = (0, resolve_1.normalizeId)(keyRef), this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      let optsSchemas = this.opts.schemas;
      if (optsSchemas)
        if (Array.isArray(optsSchemas))
          this.addSchema(optsSchemas);
        else
          for (let key in optsSchemas)
            this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (let name in this.opts.formats) {
        let format = this.opts.formats[name];
        format && this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (let keyword in defs) {
        let def = defs[keyword];
        def.keyword || (def.keyword = keyword), this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      let metaOpts = { ...this.opts };
      for (let opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === !1)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      let { RULES } = this;
      if ((0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      }), !!def && def.$data && !("code" in def || "validate" in def))
        throw new Error('$data keyword must have "code" or "validate" function');
    }
    function addRule(keyword, definition, dataType) {
      var _a2;
      let post = definition?.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      let { RULES } = this, ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t }) => t === dataType);
      if (ruleGroup || (ruleGroup = { type: dataType, rules: [] }, RULES.rules.push(ruleGroup)), RULES.keywords[keyword] = !0, !definition)
        return;
      let rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      definition.before ? addBeforeRule.call(this, ruleGroup, rule, definition.before) : ruleGroup.rules.push(rule), RULES.all[keyword] = rule, (_a2 = definition.implements) === null || _a2 === void 0 || _a2.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      let i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      i >= 0 ? ruleGroup.rules.splice(i, 0, rule) : (ruleGroup.rules.push(rule), this.logger.warn(`rule ${before} is not defined`));
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      metaSchema !== void 0 && (def.$data && this.opts.$data && (metaSchema = schemaOrData(metaSchema)), def.validateSchema = this.compile(metaSchema, !0));
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error(), code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), compile_1 = require_compile(), util_1 = require_util(), def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        let { gen, schema: $ref, it } = cxt, { baseId, schemaEnv: env, validateName, opts, self } = it, { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        let schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          let rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          let v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          let schName = gen.scopeValue("schema", opts.code.source === !0 ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch }), valid = gen.name("valid"), schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt), cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      let { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      let { gen, it } = cxt, { allErrors, schemaEnv: env, opts } = it, passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      $async ? callAsyncRef() : callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        let valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`), addEvaluatedFrom(v), allErrors || gen.assign(valid, !0);
        }, (e) => {
          gen.if((0, codegen_1._)`!(${e} instanceof ${it.ValidationError})`, () => gen.throw(e)), addErrorsFrom(e), allErrors || gen.assign(valid, !1);
        }), cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        let errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`), gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a2;
        if (!it.opts.unevaluated)
          return;
        let schEvaluated = (_a2 = sch?.validate) === null || _a2 === void 0 ? void 0 : _a2.evaluated;
        if (it.props !== !0)
          if (schEvaluated && !schEvaluated.dynamicProps)
            schEvaluated.props !== void 0 && (it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props));
          else {
            let props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        if (it.items !== !0)
          if (schEvaluated && !schEvaluated.dynamicItems)
            schEvaluated.items !== void 0 && (it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items));
          else {
            let items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var id_1 = require_id(), ref_1 = require_ref(), core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    }, def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    }, def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, it } = cxt, prec = it.opts.multipleOfPrecision, res = gen.let("res"), invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    function ucs2length(str) {
      let len = str.length, length = 0, pos = 0, value;
      for (; pos < len; )
        length++, value = str.charCodeAt(pos++), value >= 55296 && value <= 56319 && pos < len && (value = str.charCodeAt(pos), (value & 64512) === 56320 && pos++);
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), ucs2length_1 = require_ucs2length(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode, it } = cxt, op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT, len = it.opts.unicode === !1 ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    }, def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { data, $data, schema, schemaCode, it } = cxt, u = it.opts.unicodeRegExp ? "u" : "", regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    }, def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, schemaCode, data, $data, it } = cxt, { opts } = it;
        if (!$data && schema.length === 0)
          return;
        let useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors ? allErrorsMode() : exitOnErrorMode(), opts.strictRequired) {
          let props = cxt.parentSchema.properties, { definedProperties } = cxt.it;
          for (let requiredKey of schema)
            if (props?.[requiredKey] === void 0 && !definedProperties.has(requiredKey)) {
              let schemaPath = it.schemaEnv.baseId + it.errSchemaPath, msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
        }
        function allErrorsMode() {
          if (useLoop || $data)
            cxt.block$data(codegen_1.nil, loopAllRequired);
          else
            for (let prop of schema)
              (0, code_1.checkReportMissingProp)(cxt, prop);
        }
        function exitOnErrorMode() {
          let missing = gen.let("missing");
          if (useLoop || $data) {
            let valid = gen.let("valid", !0);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid)), cxt.ok(valid);
          } else
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing)), (0, code_1.reportMissingProp)(cxt, missing), gen.else();
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop }), gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing }), gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties)), gen.if((0, codegen_1.not)(valid), () => {
              cxt.error(), gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message({ keyword, schemaCode }) {
        let comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    }, def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: !0,
      error: error2,
      code(cxt) {
        let { keyword, data, schemaCode } = cxt, op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var dataType_1 = require_dataType(), codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    }, def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        let valid = gen.let("valid"), itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`), cxt.ok(valid);
        function validateUniqueItems() {
          let i = gen.let("i", (0, codegen_1._)`${data}.length`), j = gen.let("j");
          cxt.setParams({ i, j }), gen.assign(valid, !0), gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t) => t === "object" || t === "array");
        }
        function loopN(i, j) {
          let item = gen.name("item"), wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong), indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`), gen.if(wrongType, (0, codegen_1._)`continue`), itemTypes.length > 1 && gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`), gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`), cxt.error(), gen.assign(valid, !1).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          let eql = (0, util_1.useFunc)(gen, equal_1.default), outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error(), gen.assign(valid, !1).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    }, def = {
      keyword: "const",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schemaCode, schema } = cxt;
        $data || schema && typeof schema == "object" ? cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`) : cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), equal_1 = require_equal(), error2 = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    }, def = {
      keyword: "enum",
      schemaType: "array",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        let useLoop = schema.length >= it.opts.loopEnum, eql, getEql = () => eql ?? (eql = (0, util_1.useFunc)(gen, equal_1.default)), valid;
        if (useLoop || $data)
          valid = gen.let("valid"), cxt.block$data(valid, loopEnum);
        else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          let vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, !1), gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, !0).break()));
        }
        function equalCode(vSchema, i) {
          let sch = schema[i];
          return typeof sch == "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var limitNumber_1 = require_limitNumber(), multipleOf_1 = require_multipleOf(), limitLength_1 = require_limitLength(), pattern_1 = require_pattern(), limitProperties_1 = require_limitProperties(), required_1 = require_required(), limitItems_1 = require_limitItems(), uniqueItems_1 = require_uniqueItems(), const_1 = require_const(), enum_1 = require_enum(), validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { parentSchema, it } = cxt, { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      let { gen, schema, data, keyword, it } = cxt;
      it.items = !0;
      let len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === !1)
        cxt.setParams({ len: items.length }), cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        let valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid)), cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid), it.allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        let { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      let { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema), it.opts.unevaluated && schArr.length && it.items !== !0 && (it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items));
      let valid = gen.name("valid"), len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        (0, util_1.alwaysValidSchema)(it, sch) || (gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid)), cxt.ok(valid));
      });
      function checkStrictTuple(sch) {
        let { opts, errSchemaPath } = it, l = schArr.length, fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === !1);
        if (opts.strictTuples && !fullTuple) {
          let msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var items_1 = require_items(), def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2(), additionalItems_1 = require_additionalItems(), error2 = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    }, def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error: error2,
      code(cxt) {
        let { schema, parentSchema, it } = cxt, { prefixItems } = parentSchema;
        it.items = !0, !(0, util_1.alwaysValidSchema)(it, schema) && (prefixItems ? (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems) : cxt.ok((0, code_1.validateArray)(cxt)));
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    }, def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt, min, max, { minContains, maxContains } = parentSchema;
        it.opts.next ? (min = minContains === void 0 ? 1 : minContains, max = maxContains) : min = 1;
        let len = gen.const("len", (0, codegen_1._)`${data}.length`);
        if (cxt.setParams({ min, max }), max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, '"minContains" == 0 without "maxContains": "contains" keyword ignored');
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, '"minContains" > "maxContains" is always invalid'), cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          max !== void 0 && (cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`), cxt.pass(cond);
          return;
        }
        it.items = !0;
        let valid = gen.name("valid");
        max === void 0 && min === 1 ? validateItems(valid, () => gen.if(valid, () => gen.break())) : min === 0 ? (gen.let(valid, !0), max !== void 0 && gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount)) : (gen.let(valid, !1), validateItemsWithCount()), cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          let schValid = gen.name("_valid"), count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: !0
            }, _valid), block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`), max === void 0 ? gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0).break()) : (gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, !1).break()), min === 1 ? gen.assign(valid, !0) : gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, !0)));
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen(), util_1 = require_util(), code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        let property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        let [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps), validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      let propertyDeps = {}, schemaDeps = {};
      for (let key in schema) {
        if (key === "__proto__")
          continue;
        let deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      let { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      let missing = gen.let("missing");
      for (let prop in propertyDeps) {
        let deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        let hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        }), it.allErrors ? gen.if(hasProperty, () => {
          for (let depProp of deps)
            (0, code_1.checkReportMissingProp)(cxt, depProp);
        }) : (gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`), (0, code_1.reportMissingProp)(cxt, missing), gen.else());
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      let { gen, data, keyword, it } = cxt, valid = gen.name("valid");
      for (let prop in schemaDeps)
        (0, util_1.alwaysValidSchema)(it, schemaDeps[prop]) || (gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            let schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, !0)
          // TODO var
        ), cxt.ok(valid));
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    }, def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error: error2,
      code(cxt) {
        let { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        let valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key }), cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: !0
          }, valid), gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(!0), it.allErrors || gen.break();
          });
        }), cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), names_1 = require_names(), util_1 = require_util(), error2 = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    }, def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: !0,
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        let { allErrors, opts } = it;
        if (it.props = !0, opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        let props = (0, code_1.allSchemaProperties)(parentSchema.properties), patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties(), cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            !props.length && !patProps.length ? additionalPropertyCode(key) : gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            let propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else props.length ? definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`)) : definedProp = codegen_1.nil;
          return patProps.length && (definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`))), (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === !1) {
            deleteAdditional(key);
            return;
          }
          if (schema === !1) {
            cxt.setParams({ additionalProperty: key }), cxt.error(), allErrors || gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            let valid = gen.name("valid");
            opts.removeAdditional === "failing" ? (applyAdditionalSchema(key, valid, !1), gen.if((0, codegen_1.not)(valid), () => {
              cxt.reset(), deleteAdditional(key);
            })) : (applyAdditionalSchema(key, valid), allErrors || gen.if((0, codegen_1.not)(valid), () => gen.break()));
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          let subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          errors === !1 && Object.assign(subschema, {
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }), cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var validate_1 = require_validate(), code_1 = require_code2(), util_1 = require_util(), additionalProperties_1 = require_additionalProperties(), def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, parentSchema, data, it } = cxt;
        it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0 && additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        let allProps = (0, code_1.allSchemaProperties)(schema);
        for (let prop of allProps)
          it.definedProperties.add(prop);
        it.opts.unevaluated && allProps.length && it.props !== !0 && (it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props));
        let properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        let valid = gen.name("valid");
        for (let prop of properties)
          hasDefault(prop) ? applyPropertySchema(prop) : (gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties)), applyPropertySchema(prop), it.allErrors || gen.else().var(valid, !0), gen.endIf()), cxt.it.definedProperties.add(prop), cxt.ok(valid);
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), codegen_1 = require_codegen(), util_1 = require_util(), util_2 = require_util(), def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        let { gen, schema, data, parentSchema, it } = cxt, { opts } = it, patterns = (0, code_1.allSchemaProperties)(schema), alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === !0))
          return;
        let checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties, valid = gen.name("valid");
        it.props !== !0 && !(it.props instanceof codegen_1.Name) && (it.props = (0, util_2.evaluatedPropsToName)(gen, it.props));
        let { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (let pat of patterns)
            checkProperties && checkMatchingProperties(pat), it.allErrors ? validateProperties(pat) : (gen.var(valid, !0), validateProperties(pat), gen.if(valid));
        }
        function checkMatchingProperties(pat) {
          for (let prop in checkProperties)
            new RegExp(pat).test(prop) && (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              let alwaysValid = alwaysValidPatterns.includes(pat);
              alwaysValid || cxt.subschema({
                keyword: "patternProperties",
                schemaProp: pat,
                dataProp: key,
                dataPropType: util_2.Type.Str
              }, valid), it.opts.unevaluated && props !== !0 ? gen.assign((0, codegen_1._)`${props}[${key}]`, !0) : !alwaysValid && !it.allErrors && gen.if((0, codegen_1.not)(valid), () => gen.break());
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      code(cxt) {
        let { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        let valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: !0,
          createErrors: !1,
          allErrors: !1
        }, valid), cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var code_1 = require_code2(), def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: !0,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    }, def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        let schArr = schema, valid = gen.let("valid", !1), passing = gen.let("passing", null), schValid = gen.name("_valid");
        cxt.setParams({ passing }), gen.block(validateOneOf), cxt.result(valid, () => cxt.reset(), () => cxt.error(!0));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            (0, util_1.alwaysValidSchema)(it, sch) ? gen.var(schValid, !0) : schCxt = cxt.subschema({
              keyword: "oneOf",
              schemaProp: i,
              compositeRule: !0
            }, schValid), i > 0 && gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, !1).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else(), gen.if(schValid, () => {
              gen.assign(valid, !0), gen.assign(passing, i), schCxt && cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        let { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        let valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          let schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid), cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), util_1 = require_util(), error2 = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    }, def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: !0,
      error: error2,
      code(cxt) {
        let { gen, parentSchema, it } = cxt;
        parentSchema.then === void 0 && parentSchema.else === void 0 && (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        let hasThen = hasSchema(it, "then"), hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        let valid = gen.let("valid", !0), schValid = gen.name("_valid");
        if (validateIf(), cxt.reset(), hasThen && hasElse) {
          let ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause }), gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else hasThen ? gen.if(schValid, validateClause("then")) : gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        cxt.pass(valid, () => cxt.error(!0));
        function validateIf() {
          let schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: !0,
            createErrors: !1,
            allErrors: !1
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            let schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid), cxt.mergeValidEvaluated(schCxt, valid), ifClause ? gen.assign(ifClause, (0, codegen_1._)`${keyword}`) : cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      let schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var util_1 = require_util(), def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        parentSchema.if === void 0 && (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var additionalItems_1 = require_additionalItems(), prefixItems_1 = require_prefixItems(), items_1 = require_items(), items2020_1 = require_items2020(), contains_1 = require_contains(), dependencies_1 = require_dependencies(), propertyNames_1 = require_propertyNames(), additionalProperties_1 = require_additionalProperties(), properties_1 = require_properties(), patternProperties_1 = require_patternProperties(), not_1 = require_not(), anyOf_1 = require_anyOf(), oneOf_1 = require_oneOf(), allOf_1 = require_allOf(), if_1 = require_if(), thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = !1) {
      let applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      return draft2020 ? applicator.push(prefixItems_1.default, items2020_1.default) : applicator.push(additionalItems_1.default, items_1.default), applicator.push(contains_1.default), applicator;
    }
    exports.default = getApplicator;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), error2 = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    }, def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt, ruleType) {
        let { gen, data, $data, schema, schemaCode, it } = cxt, { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        $data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`), fType = gen.let("fType"), format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef)), cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            return opts.strictSchema === !1 ? codegen_1.nil : (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            let callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`, validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          let formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === !0)
            return;
          let [fmtType, format, fmtRef] = getFormat(formatDef);
          fmtType === ruleType && cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === !1) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            let code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0, fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            return typeof fmtDef == "object" && !(fmtDef instanceof RegExp) ? [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`] : ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var format_1 = require_format(), format = [format_1.default];
    exports.default = format;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var core_1 = require_core2(), validation_1 = require_validation(), applicator_1 = require_applicator(), format_1 = require_format2(), metadata_1 = require_metadata(), draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2.Tag = "tag", DiscrError2.Mapping = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var codegen_1 = require_codegen(), types_1 = require_types(), compile_1 = require_compile(), ref_error_1 = require_ref_error(), util_1 = require_util(), error2 = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    }, def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error: error2,
      code(cxt) {
        let { gen, data, schema, parentSchema, it } = cxt, { oneOf } = parentSchema;
        if (!it.opts.discriminator)
          throw new Error("discriminator: requires discriminator option");
        let tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        let valid = gen.let("valid", !1), tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(!1, { discrError: types_1.DiscrError.Tag, tag, tagName })), cxt.ok(valid);
        function validateMapping() {
          let mapping = getMapping();
          gen.if(!1);
          for (let tagValue in mapping)
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`), gen.assign(valid, applyTagSchema(mapping[tagValue]));
          gen.else(), cxt.error(!1, { discrError: types_1.DiscrError.Mapping, tag, tagName }), gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          let _valid = gen.name("valid"), schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          return cxt.mergeEvaluated(schCxt, codegen_1.Name), _valid;
        }
        function getMapping() {
          var _a2;
          let oneOfMapping = {}, topRequired = hasRequired(parentSchema), tagRequired = !0;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if (sch?.$ref && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              let ref = sch.$ref;
              if (sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref), sch instanceof compile_1.SchemaEnv && (sch = sch.schema), sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            let propSch = (_a2 = sch?.properties) === null || _a2 === void 0 ? void 0 : _a2[tagName];
            if (typeof propSch != "object")
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            tagRequired = tagRequired && (topRequired || hasRequired(sch)), addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required: required2 }) {
            return Array.isArray(required2) && required2.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const)
              addMapping(sch.const, i);
            else if (sch.enum)
              for (let tagValue of sch.enum)
                addMapping(tagValue, i);
            else
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping)
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: !0,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: !0,
        readOnly: {
          type: "boolean",
          default: !1
        },
        examples: {
          type: "array",
          items: !0
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: !0
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: !1
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: !0,
        enum: {
          type: "array",
          items: !0,
          minItems: 1,
          uniqueItems: !0
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: !0
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: !0
    };
  }
});

// mcp-servers-src/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "mcp-servers-src/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core(), draft7_1 = require_draft7(), discriminator_1 = require_discriminator(), draft7MetaSchema = require_json_schema_draft_07(), META_SUPPORT_DATA = ["/properties"], META_SCHEMA_ID = "http://json-schema.org/draft-07/schema", Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies(), draft7_1.default.forEach((v) => this.addVocabulary(v)), this.opts.discriminator && this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        if (super._addDefaultMetaSchema(), !this.opts.meta)
          return;
        let metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, !1), this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: !0, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: !0, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: !0, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: !0, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: !0, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: !0, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: !0, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: !0, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: !0, get: function() {
      return ref_error_1.default;
    } });
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date4, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(!0), compareTime),
      "date-time": fmtDef(getDateTime(!0), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: !0,
      // unchecked string payload
      binary: !0
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/, DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date4(str) {
      let matches = DATE.exec(str);
      if (!matches)
        return !1;
      let year = +matches[1], month = +matches[2], day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (d1 && d2)
        return d1 > d2 ? 1 : d1 < d2 ? -1 : 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function(str) {
        let matches = TIME.exec(str);
        if (!matches)
          return !1;
        let hr = +matches[1], min = +matches[2], sec = +matches[3], tz = matches[4], tzSign = matches[5] === "-" ? -1 : 1, tzH = +(matches[6] || 0), tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return !1;
        if (hr <= 23 && min <= 59 && sec < 60)
          return !0;
        let utcMin = min - tzM * tzSign, utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return;
      let t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf(), t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (t1 && t2)
        return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return;
      let a1 = TIME.exec(t1), a2 = TIME.exec(t2);
      if (a1 && a2)
        return t1 = a1[1] + a1[2] + a1[3], t2 = a2[1] + a2[2] + a2[3], t1 > t2 ? 1 : t1 < t2 ? -1 : 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      let time3 = getTime(strictTimeZone);
      return function(str) {
        let dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date4(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let d1 = new Date(dt1).valueOf(), d2 = new Date(dt2).valueOf();
      if (d1 && d2)
        return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return;
      let [d1, t1] = dt1.split(DATE_TIME_SEPARATOR), [d2, t2] = dt2.split(DATE_TIME_SEPARATOR), res = compareDate(d1, d2);
      if (res !== void 0)
        return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/, URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      return BYTE.lastIndex = 0, BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31), MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return !0;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return !1;
      try {
        return new RegExp(str), !0;
      } catch {
        return !1;
      }
    }
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv(), codegen_1 = require_codegen(), ops = codegen_1.operators, KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    }, error2 = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: !0,
      error: error2,
      code(cxt) {
        let { gen, data, schemaCode, keyword, it } = cxt, { opts, self } = it;
        if (!opts.validateFormats)
          return;
        let fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        fCxt.$data ? validate$DataFormat() : validateFormat();
        function validate$DataFormat() {
          let fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          }), fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          let format = fCxt.schema, fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === !0)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function")
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          let fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => (ajv.addKeyword(exports.formatLimitDefinition), ajv);
    exports.default = formatLimitPlugin;
  }
});

// mcp-servers-src/node_modules/ajv-formats/dist/index.js
var require_dist = __commonJS({
  "mcp-servers-src/node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: !0 });
    var formats_1 = require_formats(), limit_1 = require_limit(), codegen_1 = require_codegen(), fullName = new codegen_1.Name("fullFormats"), fastName = new codegen_1.Name("fastFormats"), formatsPlugin = (ajv, opts = { keywords: !0 }) => {
      if (Array.isArray(opts))
        return addFormats(ajv, opts, formats_1.fullFormats, fullName), ajv;
      let [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName], list = opts.formats || formats_1.formatNames;
      return addFormats(ajv, list, formats, exportName), opts.keywords && (0, limit_1.default)(ajv), ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      let f = (mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats)[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a2, _b;
      (_a2 = (_b = ajv.opts.code).formats) !== null && _a2 !== void 0 || (_b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`);
      for (let f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: !0 });
    exports.default = formatsPlugin;
  }
});

// mcp-servers-src/node_modules/zod/v3/helpers/util.js
var util;
(function(util2) {
  util2.assertEqual = (_) => {
  };
  function assertIs2(_arg) {
  }
  util2.assertIs = assertIs2;
  function assertNever2(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever2, util2.arrayToEnum = (items) => {
    let obj = {};
    for (let item of items)
      obj[item] = item;
    return obj;
  }, util2.getValidEnumValues = (obj) => {
    let validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] != "number"), filtered = {};
    for (let k of validKeys)
      filtered[k] = obj[k];
    return util2.objectValues(filtered);
  }, util2.objectValues = (obj) => util2.objectKeys(obj).map(function(e) {
    return obj[e];
  }), util2.objectKeys = typeof Object.keys == "function" ? (obj) => Object.keys(obj) : (object3) => {
    let keys = [];
    for (let key in object3)
      Object.prototype.hasOwnProperty.call(object3, key) && keys.push(key);
    return keys;
  }, util2.find = (arr, checker) => {
    for (let item of arr)
      if (checker(item))
        return item;
  }, util2.isInteger = typeof Number.isInteger == "function" ? (val) => Number.isInteger(val) : (val) => typeof val == "number" && Number.isFinite(val) && Math.floor(val) === val;
  function joinValues2(array2, separator = " | ") {
    return array2.map((val) => typeof val == "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues2, util2.jsonStringifyReplacer = (_, value) => typeof value == "bigint" ? value.toString() : value;
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => ({
    ...first,
    ...second
    // second overwrites first
  });
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]), getParsedType = (data) => {
  switch (typeof data) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return Number.isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      return Array.isArray(data) ? ZodParsedType.array : data === null ? ZodParsedType.null : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? ZodParsedType.promise : typeof Map < "u" && data instanceof Map ? ZodParsedType.map : typeof Set < "u" && data instanceof Set ? ZodParsedType.set : typeof Date < "u" && data instanceof Date ? ZodParsedType.date : ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};

// mcp-servers-src/node_modules/zod/v3/ZodError.js
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var ZodError = class _ZodError extends Error {
  get errors() {
    return this.issues;
  }
  constructor(issues) {
    super(), this.issues = [], this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    }, this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    let actualProto = new.target.prototype;
    Object.setPrototypeOf ? Object.setPrototypeOf(this, actualProto) : this.__proto__ = actualProto, this.name = "ZodError", this.issues = issues;
  }
  format(_mapper) {
    let mapper = _mapper || function(issue2) {
      return issue2.message;
    }, fieldErrors = { _errors: [] }, processError = (error2) => {
      for (let issue2 of error2.issues)
        if (issue2.code === "invalid_union")
          issue2.unionErrors.map(processError);
        else if (issue2.code === "invalid_return_type")
          processError(issue2.returnTypeError);
        else if (issue2.code === "invalid_arguments")
          processError(issue2.argumentsError);
        else if (issue2.path.length === 0)
          fieldErrors._errors.push(mapper(issue2));
        else {
          let curr = fieldErrors, i = 0;
          for (; i < issue2.path.length; ) {
            let el = issue2.path[i];
            i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
          }
        }
    };
    return processError(this), fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError))
      throw new Error(`Not a ZodError: ${value}`);
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue2) => issue2.message) {
    let fieldErrors = /* @__PURE__ */ Object.create(null), formErrors = [];
    for (let sub of this.issues)
      if (sub.path.length > 0) {
        let firstEl = sub.path[0];
        fieldErrors[firstEl] = fieldErrors[firstEl] || [], fieldErrors[firstEl].push(mapper(sub));
      } else
        formErrors.push(mapper(sub));
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => new ZodError(issues);

// mcp-servers-src/node_modules/zod/v3/locales/en.js
var errorMap = (issue2, _ctx) => {
  let message;
  switch (issue2.code) {
    case ZodIssueCode.invalid_type:
      issue2.received === ZodParsedType.undefined ? message = "Required" : message = `Expected ${issue2.expected}, received ${issue2.received}`;
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue2.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue2.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue2.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue2.options)}, received '${issue2.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = "Invalid function arguments";
      break;
    case ZodIssueCode.invalid_return_type:
      message = "Invalid function return type";
      break;
    case ZodIssueCode.invalid_date:
      message = "Invalid date";
      break;
    case ZodIssueCode.invalid_string:
      typeof issue2.validation == "object" ? "includes" in issue2.validation ? (message = `Invalid input: must include "${issue2.validation.includes}"`, typeof issue2.validation.position == "number" && (message = `${message} at one or more positions greater than or equal to ${issue2.validation.position}`)) : "startsWith" in issue2.validation ? message = `Invalid input: must start with "${issue2.validation.startsWith}"` : "endsWith" in issue2.validation ? message = `Invalid input: must end with "${issue2.validation.endsWith}"` : util.assertNever(issue2.validation) : issue2.validation !== "regex" ? message = `Invalid ${issue2.validation}` : message = "Invalid";
      break;
    case ZodIssueCode.too_small:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "more than"} ${issue2.minimum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at least" : "over"} ${issue2.minimum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "bigint" ? message = `Number must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${issue2.minimum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly equal to " : issue2.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(issue2.minimum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      issue2.type === "array" ? message = `Array must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "less than"} ${issue2.maximum} element(s)` : issue2.type === "string" ? message = `String must contain ${issue2.exact ? "exactly" : issue2.inclusive ? "at most" : "under"} ${issue2.maximum} character(s)` : issue2.type === "number" ? message = `Number must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "bigint" ? message = `BigInt must be ${issue2.exact ? "exactly" : issue2.inclusive ? "less than or equal to" : "less than"} ${issue2.maximum}` : issue2.type === "date" ? message = `Date must be ${issue2.exact ? "exactly" : issue2.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(issue2.maximum))}` : message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = "Invalid input";
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = "Intersection results could not be merged";
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue2.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError, util.assertNever(issue2);
  }
  return { message };
}, en_default = errorMap;

// mcp-servers-src/node_modules/zod/v3/errors.js
var overrideErrorMap = en_default;
function getErrorMap() {
  return overrideErrorMap;
}

// mcp-servers-src/node_modules/zod/v3/helpers/parseUtil.js
var makeIssue = (params) => {
  let { data, path, errorMaps, issueData } = params, fullPath = [...path, ...issueData.path || []], fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0)
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  let errorMessage = "", maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (let map2 of maps)
    errorMessage = map2(fullIssue, { data, defaultError: errorMessage }).message;
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
function addIssueToContext(ctx, issueData) {
  let overrideMap = getErrorMap(), issue2 = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === en_default ? void 0 : en_default
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue2);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    this.value === "valid" && (this.value = "dirty");
  }
  abort() {
    this.value !== "aborted" && (this.value = "aborted");
  }
  static mergeArray(status, results) {
    let arrayValue = [];
    for (let s of results) {
      if (s.status === "aborted")
        return INVALID;
      s.status === "dirty" && status.dirty(), arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    let syncPairs = [];
    for (let pair of pairs) {
      let key = await pair.key, value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    let finalObject = {};
    for (let pair of pairs) {
      let { key, value } = pair;
      if (key.status === "aborted" || value.status === "aborted")
        return INVALID;
      key.status === "dirty" && status.dirty(), value.status === "dirty" && status.dirty(), key.value !== "__proto__" && (typeof value.value < "u" || pair.alwaysSet) && (finalObject[key.value] = value.value);
    }
    return { status: status.value, value: finalObject };
  }
}, INVALID = Object.freeze({
  status: "aborted"
}), DIRTY = (value) => ({ status: "dirty", value }), OK = (value) => ({ status: "valid", value }), isAborted = (x) => x.status === "aborted", isDirty = (x) => x.status === "dirty", isValid = (x) => x.status === "valid", isAsync = (x) => typeof Promise < "u" && x instanceof Promise;

// mcp-servers-src/node_modules/zod/v3/helpers/errorUtil.js
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message == "string" ? { message } : message || {}, errorUtil2.toString = (message) => typeof message == "string" ? message : message?.message;
})(errorUtil || (errorUtil = {}));

// mcp-servers-src/node_modules/zod/v3/types.js
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [], this.parent = parent, this.data = value, this._path = path, this._key = key;
  }
  get path() {
    return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath;
  }
}, handleResult = (ctx, result) => {
  if (isValid(result))
    return { success: !0, data: result.value };
  if (!ctx.common.issues.length)
    throw new Error("Validation failed but no issues detected.");
  return {
    success: !1,
    get error() {
      if (this._error)
        return this._error;
      let error2 = new ZodError(ctx.common.issues);
      return this._error = error2, this._error;
    }
  };
};
function processCreateParams(params) {
  if (!params)
    return {};
  let { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error))
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  return errorMap2 ? { errorMap: errorMap2, description } : { errorMap: (iss, ctx) => {
    let { message } = params;
    return iss.code === "invalid_enum_value" ? { message: message ?? ctx.defaultError } : typeof ctx.data > "u" ? { message: message ?? required_error ?? ctx.defaultError } : iss.code !== "invalid_type" ? { message: ctx.defaultError } : { message: message ?? invalid_type_error ?? ctx.defaultError };
  }, description };
}
var ZodType = class {
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    let result = this._parse(input);
    if (isAsync(result))
      throw new Error("Synchronous parse encountered promise.");
    return result;
  }
  _parseAsync(input) {
    let result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    let result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    let ctx = {
      common: {
        issues: [],
        async: params?.async ?? !1,
        contextualErrorMap: params?.errorMap
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  "~validate"(data) {
    let ctx = {
      common: {
        issues: [],
        async: !!this["~standard"].async
      },
      path: [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    if (!this["~standard"].async)
      try {
        let result = this._parseSync({ data, path: [], parent: ctx });
        return isValid(result) ? {
          value: result.value
        } : {
          issues: ctx.common.issues
        };
      } catch (err) {
        err?.message?.toLowerCase()?.includes("encountered") && (this["~standard"].async = !0), ctx.common = {
          issues: [],
          async: !0
        };
      }
    return this._parseAsync({ data, path: [], parent: ctx }).then((result) => isValid(result) ? {
      value: result.value
    } : {
      issues: ctx.common.issues
    });
  }
  async parseAsync(data, params) {
    let result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    let ctx = {
      common: {
        issues: [],
        contextualErrorMap: params?.errorMap,
        async: !0
      },
      path: params?.path || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    }, maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx }), result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check2, message) {
    let getIssueProperties = (val) => typeof message == "string" || typeof message > "u" ? { message } : typeof message == "function" ? message(val) : message;
    return this._refinement((val, ctx) => {
      let result = check2(val), setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      return typeof Promise < "u" && result instanceof Promise ? result.then((data) => data ? !0 : (setError(), !1)) : result ? !0 : (setError(), !1);
    });
  }
  refinement(check2, refinementData) {
    return this._refinement((val, ctx) => check2(val) ? !0 : (ctx.addIssue(typeof refinementData == "function" ? refinementData(val, ctx) : refinementData), !1));
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  constructor(def) {
    this.spa = this.safeParseAsync, this._def = def, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this), this["~standard"] = {
      version: 1,
      vendor: "zod",
      validate: (data) => this["~validate"](data)
    };
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform2) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform: transform2 }
    });
  }
  default(def) {
    let defaultValueFunc = typeof def == "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    let catchValueFunc = typeof def == "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    let This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}, cuidRegex = /^c[^\s-]{8,}$/i, cuid2Regex = /^[0-9a-z]+$/, ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i, uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, nanoidRegex = /^[a-z0-9_-]{21}$/i, jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/, durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, _emojiRegex = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$", emojiRegex, ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/, ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/, ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/, dateRegexSource = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let secondsRegexSource = "[0-5]\\d";
  args.precision ? secondsRegexSource = `${secondsRegexSource}\\.\\d{${args.precision}}` : args.precision == null && (secondsRegexSource = `${secondsRegexSource}(\\.\\d+)?`);
  let secondsQuantifier = args.precision ? "+" : "?";
  return `([01]\\d|2[0-3]):[0-5]\\d(:${secondsRegexSource})${secondsQuantifier}`;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`, opts = [];
  return opts.push(args.local ? "Z?" : "Z"), args.offset && opts.push("([+-]\\d{2}:?\\d{2})"), regex = `${regex}(${opts.join("|")})`, new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4Regex.test(ip) || (version2 === "v6" || !version2) && ipv6Regex.test(ip));
}
function isValidJWT(jwt2, alg) {
  if (!jwtRegex.test(jwt2))
    return !1;
  try {
    let [header] = jwt2.split(".");
    if (!header)
      return !1;
    let base643 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "="), decoded = JSON.parse(atob(base643));
    return !(typeof decoded != "object" || decoded === null || "typ" in decoded && decoded?.typ !== "JWT" || !decoded.alg || alg && decoded.alg !== alg);
  } catch {
    return !1;
  }
}
function isValidCidr(ip, version2) {
  return !!((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip) || (version2 === "v6" || !version2) && ipv6CidrRegex.test(ip));
}
var ZodString = class _ZodString2 extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = String(input.data)), this._getType(input) !== ZodParsedType.string) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      if (check2.kind === "min")
        input.data.length < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "max")
        input.data.length > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !1,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "length") {
        let tooBig = input.data.length > check2.value, tooSmall = input.data.length < check2.value;
        (tooBig || tooSmall) && (ctx = this._getOrReturnCtx(input, ctx), tooBig ? addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }) : tooSmall && addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: check2.value,
          type: "string",
          inclusive: !0,
          exact: !0,
          message: check2.message
        }), status.dirty());
      } else if (check2.kind === "email")
        emailRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "email",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "emoji")
        emojiRegex || (emojiRegex = new RegExp(_emojiRegex, "u")), emojiRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "emoji",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "uuid")
        uuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "uuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "nanoid")
        nanoidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "nanoid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid")
        cuidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "cuid2")
        cuid2Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "cuid2",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "ulid")
        ulidRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
          validation: "ulid",
          code: ZodIssueCode.invalid_string,
          message: check2.message
        }), status.dirty());
      else if (check2.kind === "url")
        try {
          new URL(input.data);
        } catch {
          ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check2.message
          }), status.dirty();
        }
      else check2.kind === "regex" ? (check2.regex.lastIndex = 0, check2.regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "regex",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty())) : check2.kind === "trim" ? input.data = input.data.trim() : check2.kind === "includes" ? input.data.includes(check2.value, check2.position) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { includes: check2.value, position: check2.position },
        message: check2.message
      }), status.dirty()) : check2.kind === "toLowerCase" ? input.data = input.data.toLowerCase() : check2.kind === "toUpperCase" ? input.data = input.data.toUpperCase() : check2.kind === "startsWith" ? input.data.startsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { startsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "endsWith" ? input.data.endsWith(check2.value) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: { endsWith: check2.value },
        message: check2.message
      }), status.dirty()) : check2.kind === "datetime" ? datetimeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "datetime",
        message: check2.message
      }), status.dirty()) : check2.kind === "date" ? dateRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "date",
        message: check2.message
      }), status.dirty()) : check2.kind === "time" ? timeRegex(check2).test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_string,
        validation: "time",
        message: check2.message
      }), status.dirty()) : check2.kind === "duration" ? durationRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "duration",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "ip" ? isValidIP(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "ip",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "jwt" ? isValidJWT(input.data, check2.alg) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "jwt",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "cidr" ? isValidCidr(input.data, check2.version) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "cidr",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64" ? base64Regex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : check2.kind === "base64url" ? base64urlRegex.test(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        validation: "base64url",
        code: ZodIssueCode.invalid_string,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check2) {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  base64url(message) {
    return this._addCheck({
      kind: "base64url",
      ...errorUtil.errToObj(message)
    });
  }
  jwt(options) {
    return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  cidr(options) {
    return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "datetime",
      precision: null,
      offset: !1,
      local: !1,
      message: options
    }) : this._addCheck({
      kind: "datetime",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      offset: options?.offset ?? !1,
      local: options?.local ?? !1,
      ...errorUtil.errToObj(options?.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    return typeof options == "string" ? this._addCheck({
      kind: "time",
      precision: null,
      message: options
    }) : this._addCheck({
      kind: "time",
      precision: typeof options?.precision > "u" ? null : options?.precision,
      ...errorUtil.errToObj(options?.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options?.position,
      ...errorUtil.errToObj(options?.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * Equivalent to `.min(1)`
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString2({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isCIDR() {
    return !!this._def.checks.find((ch) => ch.kind === "cidr");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get isBase64url() {
    return !!this._def.checks.find((ch) => ch.kind === "base64url");
  }
  get minLength() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxLength() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodString.create = (params) => new ZodString({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodString,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
function floatSafeRemainder(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepDecCount = (step.toString().split(".")[1] || "").length, decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce && (input.data = Number(input.data)), this._getType(input) !== ZodParsedType.number) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      }), INVALID;
    }
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "int" ? util.isInteger(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: "integer",
        received: "float",
        message: check2.message
      }), status.dirty()) : check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: check2.value,
        type: "number",
        inclusive: check2.inclusive,
        exact: !1,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? floatSafeRemainder(input.data, check2.value) !== 0 && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : check2.kind === "finite" ? Number.isFinite(input.data) || (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_finite,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: !0,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: !0,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (let ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf")
        return !0;
      ch.kind === "min" ? (min === null || ch.value > min) && (min = ch.value) : ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
};
ZodNumber.create = (params) => new ZodNumber({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodNumber,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments), this.min = this.gte, this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce)
      try {
        input.data = BigInt(input.data);
      } catch {
        return this._getInvalidInput(input);
      }
    if (this._getType(input) !== ZodParsedType.bigint)
      return this._getInvalidInput(input);
    let ctx, status = new ParseStatus();
    for (let check2 of this._def.checks)
      check2.kind === "min" ? (check2.inclusive ? input.data < check2.value : input.data <= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        type: "bigint",
        minimum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "max" ? (check2.inclusive ? input.data > check2.value : input.data >= check2.value) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        type: "bigint",
        maximum: check2.value,
        inclusive: check2.inclusive,
        message: check2.message
      }), status.dirty()) : check2.kind === "multipleOf" ? input.data % check2.value !== BigInt(0) && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.not_multiple_of,
        multipleOf: check2.value,
        message: check2.message
      }), status.dirty()) : util.assertNever(check2);
    return { status: status.value, value: input.data };
  }
  _getInvalidInput(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.bigint,
      received: ctx.parsedType
    }), INVALID;
  }
  gte(value, message) {
    return this.setLimit("min", value, !0, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, !1, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, !0, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, !1, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check2) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !1,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: !0,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min;
  }
  get maxValue() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max;
  }
};
ZodBigInt.create = (params) => new ZodBigInt({
  checks: [],
  typeName: ZodFirstPartyTypeKind.ZodBigInt,
  coerce: params?.coerce ?? !1,
  ...processCreateParams(params)
});
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = !!input.data), this._getType(input) !== ZodParsedType.boolean) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => new ZodBoolean({
  typeName: ZodFirstPartyTypeKind.ZodBoolean,
  coerce: params?.coerce || !1,
  ...processCreateParams(params)
});
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce && (input.data = new Date(input.data)), this._getType(input) !== ZodParsedType.date) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      }), INVALID;
    }
    if (Number.isNaN(input.data.getTime())) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      }), INVALID;
    }
    let status = new ParseStatus(), ctx;
    for (let check2 of this._def.checks)
      check2.kind === "min" ? input.data.getTime() < check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        minimum: check2.value,
        type: "date"
      }), status.dirty()) : check2.kind === "max" ? input.data.getTime() > check2.value && (ctx = this._getOrReturnCtx(input, ctx), addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        message: check2.message,
        inclusive: !0,
        exact: !1,
        maximum: check2.value,
        type: "date"
      }), status.dirty()) : util.assertNever(check2);
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check2) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check2]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (let ch of this._def.checks)
      ch.kind === "min" && (min === null || ch.value > min) && (min = ch.value);
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (let ch of this._def.checks)
      ch.kind === "max" && (max === null || ch.value < max) && (max = ch.value);
    return max != null ? new Date(max) : null;
  }
};
ZodDate.create = (params) => new ZodDate({
  checks: [],
  coerce: params?.coerce || !1,
  typeName: ZodFirstPartyTypeKind.ZodDate,
  ...processCreateParams(params)
});
var ZodSymbol = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.symbol) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => new ZodSymbol({
  typeName: ZodFirstPartyTypeKind.ZodSymbol,
  ...processCreateParams(params)
});
var ZodUndefined = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => new ZodUndefined({
  typeName: ZodFirstPartyTypeKind.ZodUndefined,
  ...processCreateParams(params)
});
var ZodNull = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.null) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => new ZodNull({
  typeName: ZodFirstPartyTypeKind.ZodNull,
  ...processCreateParams(params)
});
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments), this._any = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => new ZodAny({
  typeName: ZodFirstPartyTypeKind.ZodAny,
  ...processCreateParams(params)
});
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments), this._unknown = !0;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => new ZodUnknown({
  typeName: ZodFirstPartyTypeKind.ZodUnknown,
  ...processCreateParams(params)
});
var ZodNever = class extends ZodType {
  _parse(input) {
    let ctx = this._getOrReturnCtx(input);
    return addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    }), INVALID;
  }
};
ZodNever.create = (params) => new ZodNever({
  typeName: ZodFirstPartyTypeKind.ZodNever,
  ...processCreateParams(params)
});
var ZodVoid = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.undefined) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      }), INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => new ZodVoid({
  typeName: ZodFirstPartyTypeKind.ZodVoid,
  ...processCreateParams(params)
});
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    let { ctx, status } = this._processInputParams(input), def = this._def;
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (def.exactLength !== null) {
      let tooBig = ctx.data.length > def.exactLength.value, tooSmall = ctx.data.length < def.exactLength.value;
      (tooBig || tooSmall) && (addIssueToContext(ctx, {
        code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
        minimum: tooSmall ? def.exactLength.value : void 0,
        maximum: tooBig ? def.exactLength.value : void 0,
        type: "array",
        inclusive: !0,
        exact: !0,
        message: def.exactLength.message
      }), status.dirty());
    }
    if (def.minLength !== null && ctx.data.length < def.minLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.minLength.message
    }), status.dirty()), def.maxLength !== null && ctx.data.length > def.maxLength.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxLength.value,
      type: "array",
      inclusive: !0,
      exact: !1,
      message: def.maxLength.message
    }), status.dirty()), ctx.common.async)
      return Promise.all([...ctx.data].map((item, i) => def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i)))).then((result2) => ParseStatus.mergeArray(status, result2));
    let result = [...ctx.data].map((item, i) => def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => new ZodArray({
  type: schema,
  minLength: null,
  maxLength: null,
  exactLength: null,
  typeName: ZodFirstPartyTypeKind.ZodArray,
  ...processCreateParams(params)
});
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    let newShape = {};
    for (let key in schema.shape) {
      let fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else return schema instanceof ZodArray ? new ZodArray({
    ...schema._def,
    type: deepPartialify(schema.element)
  }) : schema instanceof ZodOptional ? ZodOptional.create(deepPartialify(schema.unwrap())) : schema instanceof ZodNullable ? ZodNullable.create(deepPartialify(schema.unwrap())) : schema instanceof ZodTuple ? ZodTuple.create(schema.items.map((item) => deepPartialify(item))) : schema;
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    let shape = this._def.shape(), keys = util.objectKeys(shape);
    return this._cached = { shape, keys }, this._cached;
  }
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.object) {
      let ctx2 = this._getOrReturnCtx(input);
      return addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      }), INVALID;
    }
    let { status, ctx } = this._processInputParams(input), { shape, keys: shapeKeys } = this._getCached(), extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip"))
      for (let key in ctx.data)
        shapeKeys.includes(key) || extraKeys.push(key);
    let pairs = [];
    for (let key of shapeKeys) {
      let keyValidator = shape[key], value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      let unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough")
        for (let key of extraKeys)
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
      else if (unknownKeys === "strict")
        extraKeys.length > 0 && (addIssueToContext(ctx, {
          code: ZodIssueCode.unrecognized_keys,
          keys: extraKeys
        }), status.dirty());
      else if (unknownKeys !== "strip")
        throw new Error("Internal ZodObject error: invalid unknownKeys value.");
    } else {
      let catchall = this._def.catchall;
      for (let key of extraKeys) {
        let value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    return ctx.common.async ? Promise.resolve().then(async () => {
      let syncPairs = [];
      for (let pair of pairs) {
        let key = await pair.key, value = await pair.value;
        syncPairs.push({
          key,
          value,
          alwaysSet: pair.alwaysSet
        });
      }
      return syncPairs;
    }).then((syncPairs) => ParseStatus.mergeObjectSync(status, syncPairs)) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    return errorUtil.errToObj, new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue2, ctx) => {
          let defaultError = this._def.errorMap?.(issue2, ctx).message ?? ctx.defaultError;
          return issue2.code === "unrecognized_keys" ? {
            message: errorUtil.errToObj(message).message ?? defaultError
          } : {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    return new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    let shape = {};
    for (let key of util.objectKeys(mask))
      mask[key] && this.shape[key] && (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    let shape = {};
    for (let key of util.objectKeys(this.shape))
      mask[key] || (shape[key] = this.shape[key]);
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape)) {
      let fieldSchema = this.shape[key];
      mask && !mask[key] ? newShape[key] = fieldSchema : newShape[key] = fieldSchema.optional();
    }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    let newShape = {};
    for (let key of util.objectKeys(this.shape))
      if (mask && !mask[key])
        newShape[key] = this.shape[key];
      else {
        let newField = this.shape[key];
        for (; newField instanceof ZodOptional; )
          newField = newField._def.innerType;
        newShape[key] = newField;
      }
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.strictCreate = (shape, params) => new ZodObject({
  shape: () => shape,
  unknownKeys: "strict",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
ZodObject.lazycreate = (shape, params) => new ZodObject({
  shape,
  unknownKeys: "strip",
  catchall: ZodNever.create(),
  typeName: ZodFirstPartyTypeKind.ZodObject,
  ...processCreateParams(params)
});
var ZodUnion = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), options = this._def.options;
    function handleResults(results) {
      for (let result of results)
        if (result.result.status === "valid")
          return result.result;
      for (let result of results)
        if (result.result.status === "dirty")
          return ctx.common.issues.push(...result.ctx.common.issues), result.result;
      let unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
    if (ctx.common.async)
      return Promise.all(options.map(async (option) => {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    {
      let dirty, issues = [];
      for (let option of options) {
        let childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        }, result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid")
          return result;
        result.status === "dirty" && !dirty && (dirty = { result, ctx: childCtx }), childCtx.common.issues.length && issues.push(childCtx.common.issues);
      }
      if (dirty)
        return ctx.common.issues.push(...dirty.ctx.common.issues), dirty.result;
      let unionErrors = issues.map((issues2) => new ZodError(issues2));
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      }), INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => new ZodUnion({
  options: types,
  typeName: ZodFirstPartyTypeKind.ZodUnion,
  ...processCreateParams(params)
});
var getDiscriminator = (type) => type instanceof ZodLazy ? getDiscriminator(type.schema) : type instanceof ZodEffects ? getDiscriminator(type.innerType()) : type instanceof ZodLiteral ? [type.value] : type instanceof ZodEnum ? type.options : type instanceof ZodNativeEnum ? util.objectValues(type.enum) : type instanceof ZodDefault ? getDiscriminator(type._def.innerType) : type instanceof ZodUndefined ? [void 0] : type instanceof ZodNull ? [null] : type instanceof ZodOptional ? [void 0, ...getDiscriminator(type.unwrap())] : type instanceof ZodNullable ? [null, ...getDiscriminator(type.unwrap())] : type instanceof ZodBranded || type instanceof ZodReadonly ? getDiscriminator(type.unwrap()) : type instanceof ZodCatch ? getDiscriminator(type._def.innerType) : [], ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let discriminator = this.discriminator, discriminatorValue = ctx.data[discriminator], option = this.optionsMap.get(discriminatorValue);
    return option ? ctx.common.async ? option._parseAsync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : option._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }) : (addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_union_discriminator,
      options: Array.from(this.optionsMap.keys()),
      path: [discriminator]
    }), INVALID);
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    let optionsMap = /* @__PURE__ */ new Map();
    for (let type of options) {
      let discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length)
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      for (let value of discriminatorValues) {
        if (optionsMap.has(value))
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  let aType = getParsedType(a), bType = getParsedType(b);
  if (a === b)
    return { valid: !0, data: a };
  if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    let bKeys = util.objectKeys(b), sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid)
        return { valid: !1 };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length)
      return { valid: !1 };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid)
        return { valid: !1 };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  } else return aType === ZodParsedType.date && bType === ZodParsedType.date && +a == +b ? { valid: !0, data: a } : { valid: !1 };
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight))
        return INVALID;
      let merged = mergeValues(parsedLeft.value, parsedRight.value);
      return merged.valid ? ((isDirty(parsedLeft) || isDirty(parsedRight)) && status.dirty(), { status: status.value, value: merged.data }) : (addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_intersection_types
      }), INVALID);
    };
    return ctx.common.async ? Promise.all([
      this._def.left._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }),
      this._def.right._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      })
    ]).then(([left, right]) => handleParsed(left, right)) : handleParsed(this._def.left._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }), this._def.right._parseSync({
      data: ctx.data,
      path: ctx.path,
      parent: ctx
    }));
  }
};
ZodIntersection.create = (left, right, params) => new ZodIntersection({
  left,
  right,
  typeName: ZodFirstPartyTypeKind.ZodIntersection,
  ...processCreateParams(params)
});
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      }), INVALID;
    if (ctx.data.length < this._def.items.length)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: !0,
        exact: !1,
        type: "array"
      }), INVALID;
    !this._def.rest && ctx.data.length > this._def.items.length && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: this._def.items.length,
      inclusive: !0,
      exact: !1,
      type: "array"
    }), status.dirty());
    let items = [...ctx.data].map((item, itemIndex) => {
      let schema = this._def.items[itemIndex] || this._def.rest;
      return schema ? schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex)) : null;
    }).filter((x) => !!x);
    return ctx.common.async ? Promise.all(items).then((results) => ParseStatus.mergeArray(status, results)) : ParseStatus.mergeArray(status, items);
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas))
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      }), INVALID;
    let pairs = [], keyType = this._def.keyType, valueType = this._def.valueType;
    for (let key in ctx.data)
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    return ctx.common.async ? ParseStatus.mergeObjectAsync(status, pairs) : ParseStatus.mergeObjectSync(status, pairs);
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    return second instanceof ZodType ? new _ZodRecord({
      keyType: first,
      valueType: second,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(third)
    }) : new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}, ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      }), INVALID;
    let keyType = this._def.keyType, valueType = this._def.valueType, pairs = [...ctx.data.entries()].map(([key, value], index) => ({
      key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
      value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
    }));
    if (ctx.common.async) {
      let finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (let pair of pairs) {
          let key = await pair.key, value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted")
            return INVALID;
          (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      let finalMap = /* @__PURE__ */ new Map();
      for (let pair of pairs) {
        let key = pair.key, value = pair.value;
        if (key.status === "aborted" || value.status === "aborted")
          return INVALID;
        (key.status === "dirty" || value.status === "dirty") && status.dirty(), finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => new ZodMap({
  valueType,
  keyType,
  typeName: ZodFirstPartyTypeKind.ZodMap,
  ...processCreateParams(params)
});
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      }), INVALID;
    let def = this._def;
    def.minSize !== null && ctx.data.size < def.minSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_small,
      minimum: def.minSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.minSize.message
    }), status.dirty()), def.maxSize !== null && ctx.data.size > def.maxSize.value && (addIssueToContext(ctx, {
      code: ZodIssueCode.too_big,
      maximum: def.maxSize.value,
      type: "set",
      inclusive: !0,
      exact: !1,
      message: def.maxSize.message
    }), status.dirty());
    let valueType = this._def.valueType;
    function finalizeSet(elements2) {
      let parsedSet = /* @__PURE__ */ new Set();
      for (let element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        element.status === "dirty" && status.dirty(), parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    let elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    return ctx.common.async ? Promise.all(elements).then((elements2) => finalizeSet(elements2)) : finalizeSet(elements);
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => new ZodSet({
  valueType,
  minSize: null,
  maxSize: null,
  typeName: ZodFirstPartyTypeKind.ZodSet,
  ...processCreateParams(params)
});
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments), this.validate = this.implement;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      }), INVALID;
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [ctx.common.contextualErrorMap, ctx.schemaErrorMap, getErrorMap(), en_default].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    let params = { errorMap: ctx.common.contextualErrorMap }, fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      let me = this;
      return OK(async function(...args) {
        let error2 = new ZodError([]), parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          throw error2.addIssue(makeArgsIssue(args, e)), error2;
        }), result = await Reflect.apply(fn, this, parsedArgs);
        return await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          throw error2.addIssue(makeReturnsIssue(result, e)), error2;
        });
      });
    } else {
      let me = this;
      return OK(function(...args) {
        let parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success)
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        let result = Reflect.apply(fn, this, parsedArgs.data), parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success)
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    return this.parse(func);
  }
  strictImplement(func) {
    return this.parse(func);
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args || ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}, ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    return this._def.getter()._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => new ZodLazy({
  getter,
  typeName: ZodFirstPartyTypeKind.ZodLazy,
  ...processCreateParams(params)
});
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => new ZodLiteral({
  value,
  typeName: ZodFirstPartyTypeKind.ZodLiteral,
  ...processCreateParams(params)
});
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data != "string") {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(this._def.values)), !this._cache.has(input.data)) {
      let ctx = this._getOrReturnCtx(input), expectedValues = this._def.values;
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Values() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  get Enum() {
    let enumValues = {};
    for (let val of this._def.values)
      enumValues[val] = val;
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    let nativeEnumValues = util.getValidEnumValues(this._def.values), ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      }), INVALID;
    }
    if (this._cache || (this._cache = new Set(util.getValidEnumValues(this._def.values))), !this._cache.has(input.data)) {
      let expectedValues = util.objectValues(nativeEnumValues);
      return addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      }), INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values, params) => new ZodNativeEnum({
  values,
  typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
  ...processCreateParams(params)
});
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    let { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === !1)
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      }), INVALID;
    let promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => this._def.type.parseAsync(data, {
      path: ctx.path,
      errorMap: ctx.common.contextualErrorMap
    })));
  }
};
ZodPromise.create = (schema, params) => new ZodPromise({
  type: schema,
  typeName: ZodFirstPartyTypeKind.ZodPromise,
  ...processCreateParams(params)
});
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    let { status, ctx } = this._processInputParams(input), effect = this._def.effect || null, checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg), arg.fatal ? status.abort() : status.dirty();
      },
      get path() {
        return ctx.path;
      }
    };
    if (checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx), effect.type === "preprocess") {
      let processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async)
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          let result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
        });
      {
        if (status.value === "aborted")
          return INVALID;
        let result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        return result.status === "aborted" ? INVALID : result.status === "dirty" ? DIRTY(result.value) : status.value === "dirty" ? DIRTY(result.value) : result;
      }
    }
    if (effect.type === "refinement") {
      let executeRefinement = (acc) => {
        let result = effect.refinement(acc, checkCtx);
        if (ctx.common.async)
          return Promise.resolve(result);
        if (result instanceof Promise)
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        return acc;
      };
      if (ctx.common.async === !1) {
        let inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value), { status: status.value, value: inner.value });
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => inner.status === "aborted" ? INVALID : (inner.status === "dirty" && status.dirty(), executeRefinement(inner.value).then(() => ({ status: status.value, value: inner.value }))));
    }
    if (effect.type === "transform")
      if (ctx.common.async === !1) {
        let base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return INVALID;
        let result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise)
          throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
        return { status: status.value, value: result };
      } else
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => isValid(base) ? Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({
          status: status.value,
          value: result
        })) : INVALID);
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => new ZodEffects({
  schema,
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  effect,
  ...processCreateParams(params)
});
ZodEffects.createWithPreprocess = (preprocess2, schema, params) => new ZodEffects({
  schema,
  effect: { type: "preprocess", transform: preprocess2 },
  typeName: ZodFirstPartyTypeKind.ZodEffects,
  ...processCreateParams(params)
});
var ZodOptional = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.undefined ? OK(void 0) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => new ZodOptional({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodOptional,
  ...processCreateParams(params)
});
var ZodNullable = class extends ZodType {
  _parse(input) {
    return this._getType(input) === ZodParsedType.null ? OK(null) : this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => new ZodNullable({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodNullable,
  ...processCreateParams(params)
});
var ZodDefault = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return ctx.parsedType === ZodParsedType.undefined && (data = this._def.defaultValue()), this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => new ZodDefault({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodDefault,
  defaultValue: typeof params.default == "function" ? params.default : () => params.default,
  ...processCreateParams(params)
});
var ZodCatch = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    }, result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    return isAsync(result) ? result.then((result2) => ({
      status: "valid",
      value: result2.status === "valid" ? result2.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    })) : {
      status: "valid",
      value: result.status === "valid" ? result.value : this._def.catchValue({
        get error() {
          return new ZodError(newCtx.common.issues);
        },
        input: newCtx.data
      })
    };
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => new ZodCatch({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodCatch,
  catchValue: typeof params.catch == "function" ? params.catch : () => params.catch,
  ...processCreateParams(params)
});
var ZodNaN = class extends ZodType {
  _parse(input) {
    if (this._getType(input) !== ZodParsedType.nan) {
      let ctx = this._getOrReturnCtx(input);
      return addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      }), INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => new ZodNaN({
  typeName: ZodFirstPartyTypeKind.ZodNaN,
  ...processCreateParams(params)
});
var BRAND = Symbol("zod_brand"), ZodBranded = class extends ZodType {
  _parse(input) {
    let { ctx } = this._processInputParams(input), data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}, ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    let { status, ctx } = this._processInputParams(input);
    if (ctx.common.async)
      return (async () => {
        let inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), DIRTY(inResult.value)) : this._def.out._parseAsync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      })();
    {
      let inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      return inResult.status === "aborted" ? INVALID : inResult.status === "dirty" ? (status.dirty(), {
        status: "dirty",
        value: inResult.value
      }) : this._def.out._parseSync({
        data: inResult.value,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}, ZodReadonly = class extends ZodType {
  _parse(input) {
    let result = this._def.innerType._parse(input), freeze = (data) => (isValid(data) && (data.value = Object.freeze(data.value)), data);
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => new ZodReadonly({
  innerType: type,
  typeName: ZodFirstPartyTypeKind.ZodReadonly,
  ...processCreateParams(params)
});
var late = {
  object: ZodObject.lazycreate
}, ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind3) {
  ZodFirstPartyTypeKind3.ZodString = "ZodString", ZodFirstPartyTypeKind3.ZodNumber = "ZodNumber", ZodFirstPartyTypeKind3.ZodNaN = "ZodNaN", ZodFirstPartyTypeKind3.ZodBigInt = "ZodBigInt", ZodFirstPartyTypeKind3.ZodBoolean = "ZodBoolean", ZodFirstPartyTypeKind3.ZodDate = "ZodDate", ZodFirstPartyTypeKind3.ZodSymbol = "ZodSymbol", ZodFirstPartyTypeKind3.ZodUndefined = "ZodUndefined", ZodFirstPartyTypeKind3.ZodNull = "ZodNull", ZodFirstPartyTypeKind3.ZodAny = "ZodAny", ZodFirstPartyTypeKind3.ZodUnknown = "ZodUnknown", ZodFirstPartyTypeKind3.ZodNever = "ZodNever", ZodFirstPartyTypeKind3.ZodVoid = "ZodVoid", ZodFirstPartyTypeKind3.ZodArray = "ZodArray", ZodFirstPartyTypeKind3.ZodObject = "ZodObject", ZodFirstPartyTypeKind3.ZodUnion = "ZodUnion", ZodFirstPartyTypeKind3.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", ZodFirstPartyTypeKind3.ZodIntersection = "ZodIntersection", ZodFirstPartyTypeKind3.ZodTuple = "ZodTuple", ZodFirstPartyTypeKind3.ZodRecord = "ZodRecord", ZodFirstPartyTypeKind3.ZodMap = "ZodMap", ZodFirstPartyTypeKind3.ZodSet = "ZodSet", ZodFirstPartyTypeKind3.ZodFunction = "ZodFunction", ZodFirstPartyTypeKind3.ZodLazy = "ZodLazy", ZodFirstPartyTypeKind3.ZodLiteral = "ZodLiteral", ZodFirstPartyTypeKind3.ZodEnum = "ZodEnum", ZodFirstPartyTypeKind3.ZodEffects = "ZodEffects", ZodFirstPartyTypeKind3.ZodNativeEnum = "ZodNativeEnum", ZodFirstPartyTypeKind3.ZodOptional = "ZodOptional", ZodFirstPartyTypeKind3.ZodNullable = "ZodNullable", ZodFirstPartyTypeKind3.ZodDefault = "ZodDefault", ZodFirstPartyTypeKind3.ZodCatch = "ZodCatch", ZodFirstPartyTypeKind3.ZodPromise = "ZodPromise", ZodFirstPartyTypeKind3.ZodBranded = "ZodBranded", ZodFirstPartyTypeKind3.ZodPipeline = "ZodPipeline", ZodFirstPartyTypeKind3.ZodReadonly = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var stringType = ZodString.create, numberType = ZodNumber.create, nanType = ZodNaN.create, bigIntType = ZodBigInt.create, booleanType = ZodBoolean.create, dateType = ZodDate.create, symbolType = ZodSymbol.create, undefinedType = ZodUndefined.create, nullType = ZodNull.create, anyType = ZodAny.create, unknownType = ZodUnknown.create, neverType = ZodNever.create, voidType = ZodVoid.create, arrayType = ZodArray.create, objectType = ZodObject.create, strictObjectType = ZodObject.strictCreate, unionType = ZodUnion.create, discriminatedUnionType = ZodDiscriminatedUnion.create, intersectionType = ZodIntersection.create, tupleType = ZodTuple.create, recordType = ZodRecord.create, mapType = ZodMap.create, setType = ZodSet.create, functionType = ZodFunction.create, lazyType = ZodLazy.create, literalType = ZodLiteral.create, enumType = ZodEnum.create, nativeEnumType = ZodNativeEnum.create, promiseType = ZodPromise.create, effectsType = ZodEffects.create, optionalType = ZodOptional.create, nullableType = ZodNullable.create, preprocessType = ZodEffects.createWithPreprocess, pipelineType = ZodPipeline.create;

// mcp-servers-src/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
// @__NO_SIDE_EFFECTS__
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (inst._zod || Object.defineProperty(inst, "_zod", {
      value: {
        def,
        constr: _,
        traits: /* @__PURE__ */ new Set()
      },
      enumerable: !1
    }), inst._zod.traits.has(name))
      return;
    inst._zod.traits.add(name), initializer3(inst, def);
    let proto = _.prototype, keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      let k = keys[i];
      k in inst || (inst[k] = proto[k].bind(inst));
    }
  }
  let Parent = params?.Parent ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    let inst = params?.Parent ? new Definition() : this;
    init(inst, def), (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (let fn of inst._zod.deferred)
      fn();
    return inst;
  }
  return Object.defineProperty(_, "init", { value: init }), Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => params?.Parent && inst instanceof params.Parent ? !0 : inst?._zod?.traits?.has(name)
  }), Object.defineProperty(_, "name", { value: name }), _;
}
var $brand = Symbol("zod_brand"), $ZodAsyncError = class extends Error {
  constructor() {
    super("Encountered Promise during synchronous parse. Use .parseAsync() instead.");
  }
}, $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`), this.name = "ZodEncodeError";
  }
}, globalConfig = {};
function config(newConfig) {
  return newConfig && Object.assign(globalConfig, newConfig), globalConfig;
}

// mcp-servers-src/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder2,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType2,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  let numericValues = Object.values(entries).filter((v) => typeof v == "number");
  return Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  return typeof value == "bigint" ? value.toString() : value;
}
function cached(getter) {
  return {
    get value() {
      {
        let value = getter();
        return Object.defineProperty(this, "value", { value }), value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input == null;
}
function cleanRegex(source) {
  let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder2(val, step) {
  let valDecCount = (val.toString().split(".")[1] || "").length, stepString = step.toString(), stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    let match = stepString.match(/\d?e-(\d?)/);
    match?.[1] && (stepDecCount = Number.parseInt(match[1]));
  }
  let decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount, valInt = Number.parseInt(val.toFixed(decCount).replace(".", "")), stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object3, key, getter) {
  let value;
  Object.defineProperty(object3, key, {
    get() {
      if (value !== EVALUATING)
        return value === void 0 && (value = EVALUATING, value = getter()), value;
    },
    set(v) {
      Object.defineProperty(object3, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: !0
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: !0,
    enumerable: !0,
    configurable: !0
  });
}
function mergeDefs(...defs) {
  let mergedDescriptors = {};
  for (let def of defs) {
    let descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  return path ? path.reduce((acc, key) => acc?.[key], obj) : obj;
}
function promiseAllObject(promisesObj) {
  let keys = Object.keys(promisesObj), promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    let resolvedObj = {};
    for (let i = 0; i < keys.length; i++)
      resolvedObj[keys[i]] = results[i];
    return resolvedObj;
  });
}
function randomString(length = 10) {
  let chars = "abcdefghijklmnopqrstuvwxyz", str = "";
  for (let i = 0; i < length; i++)
    str += chars[Math.floor(Math.random() * chars.length)];
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data == "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  if (typeof navigator < "u" && navigator?.userAgent?.includes("Cloudflare"))
    return !1;
  try {
    let F = Function;
    return new F(""), !0;
  } catch {
    return !1;
  }
});
function isPlainObject(o) {
  if (isObject(o) === !1)
    return !1;
  let ctor = o.constructor;
  if (ctor === void 0 || typeof ctor != "function")
    return !0;
  let prot = ctor.prototype;
  return !(isObject(prot) === !1 || Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === !1);
}
function shallowClone(o) {
  return isPlainObject(o) ? { ...o } : Array.isArray(o) ? [...o] : o;
}
function numKeys(data) {
  let keyCount = 0;
  for (let key in data)
    Object.prototype.hasOwnProperty.call(data, key) && keyCount++;
  return keyCount;
}
var getParsedType2 = (data) => {
  let t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      return Array.isArray(data) ? "array" : data === null ? "null" : data.then && typeof data.then == "function" && data.catch && typeof data.catch == "function" ? "promise" : typeof Map < "u" && data instanceof Map ? "map" : typeof Set < "u" && data instanceof Set ? "set" : typeof Date < "u" && data instanceof Date ? "date" : typeof File < "u" && data instanceof File ? "file" : "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
}, propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]), primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  let cl = new inst._zod.constr(def ?? inst._zod.def);
  return (!def || params?.parent) && (cl._zod.parent = inst), cl;
}
function normalizeParams(_params) {
  let params = _params;
  if (!params)
    return {};
  if (typeof params == "string")
    return { error: () => params };
  if (params?.message !== void 0) {
    if (params?.error !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  return delete params.message, typeof params.error == "string" ? { ...params, error: () => params.error } : params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      return target ?? (target = getter()), Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      return target ?? (target = getter()), Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      return target ?? (target = getter()), Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      return target ?? (target = getter()), Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      return target ?? (target = getter()), Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      return target ?? (target = getter()), Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      return target ?? (target = getter()), Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  return typeof value == "bigint" ? value.toString() + "n" : typeof value == "string" ? `"${value}"` : `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional");
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
}, BIGINT_FORMAT_RANGES = {
  int64: [/* @__PURE__ */ BigInt("-9223372036854775808"), /* @__PURE__ */ BigInt("9223372036854775807")],
  uint64: [/* @__PURE__ */ BigInt(0), /* @__PURE__ */ BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = {};
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && (newShape[key] = currDef.shape[key]);
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  let currDef = schema._zod.def, checks = currDef.checks;
  if (checks && checks.length > 0)
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let newShape = { ...schema._zod.def.shape };
      for (let key in mask) {
        if (!(key in currDef.shape))
          throw new Error(`Unrecognized key: "${key}"`);
        mask[key] && delete newShape[key];
      }
      return assignProp(this, "shape", newShape), newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to extend: expected a plain object");
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0) {
    let existingShape = schema._zod.def.shape;
    for (let key in shape)
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0)
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
  }
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape))
    throw new Error("Invalid input to safeExtend: expected a plain object");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let _shape = { ...schema._zod.def.shape, ...shape };
      return assignProp(this, "shape", _shape), _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  let def = mergeDefs(a._zod.def, {
    get shape() {
      let _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      return assignProp(this, "shape", _shape), _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  let checks = schema._zod.def.checks;
  if (checks && checks.length > 0)
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in oldShape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key]);
        }
      else
        for (let key in oldShape)
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
      return assignProp(this, "shape", shape), shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  let def = mergeDefs(schema._zod.def, {
    get shape() {
      let oldShape = schema._zod.def.shape, shape = { ...oldShape };
      if (mask)
        for (let key in mask) {
          if (!(key in shape))
            throw new Error(`Unrecognized key: "${key}"`);
          mask[key] && (shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          }));
        }
      else
        for (let key in oldShape)
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
      return assignProp(this, "shape", shape), shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  if (x.aborted === !0)
    return !0;
  for (let i = startIndex; i < x.issues.length; i++)
    if (x.issues[i]?.continue !== !0)
      return !0;
  return !1;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    return (_a2 = iss).path ?? (_a2.path = []), iss.path.unshift(path), iss;
  });
}
function unwrapMessage(message) {
  return typeof message == "string" ? message : message?.message;
}
function finalizeIssue(iss, ctx, config2) {
  let full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    let message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config2.customError?.(iss)) ?? unwrapMessage(config2.localeError?.(iss)) ?? "Invalid input";
    full.message = message;
  }
  return delete full.inst, delete full.continue, ctx?.reportInput || delete full.input, full;
}
function getSizableOrigin(input) {
  return input instanceof Set ? "set" : input instanceof Map ? "map" : input instanceof File ? "file" : "unknown";
}
function getLengthableOrigin(input) {
  return Array.isArray(input) ? "array" : typeof input == "string" ? "string" : "unknown";
}
function parsedType(data) {
  let t = typeof data;
  switch (t) {
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "object": {
      if (data === null)
        return "null";
      if (Array.isArray(data))
        return "array";
      let obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor)
        return obj.constructor.name;
    }
  }
  return t;
}
function issue(...args) {
  let [iss, input, inst] = args;
  return typeof iss == "string" ? {
    message: iss,
    code: "custom",
    input,
    inst
  } : { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => Number.isNaN(Number.parseInt(k, 10))).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  let binaryString = atob(base643), bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++)
    bytes[i] = binaryString.charCodeAt(i);
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++)
    binaryString += String.fromCharCode(bytes[i]);
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  let base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/"), padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  let cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0)
    throw new Error("Invalid hex string length");
  let bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2)
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// mcp-servers-src/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError", Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: !1
  }), Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: !1
  }), inst.message = JSON.stringify(def, jsonStringifyReplacer, 2), Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: !1
  });
}, $ZodError = $constructor("$ZodError", initializer), $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = {}, formErrors = [];
  for (let sub of error2.issues)
    sub.path.length > 0 ? (fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [], fieldErrors[sub.path[0]].push(mapper(sub))) : formErrors.push(mapper(sub));
  return { formErrors, fieldErrors };
}
function formatError(error2, mapper = (issue2) => issue2.message) {
  let fieldErrors = { _errors: [] }, processError = (error3) => {
    for (let issue2 of error3.issues)
      if (issue2.code === "invalid_union" && issue2.errors.length)
        issue2.errors.map((issues) => processError({ issues }));
      else if (issue2.code === "invalid_key")
        processError({ issues: issue2.issues });
      else if (issue2.code === "invalid_element")
        processError({ issues: issue2.issues });
      else if (issue2.path.length === 0)
        fieldErrors._errors.push(mapper(issue2));
      else {
        let curr = fieldErrors, i = 0;
        for (; i < issue2.path.length; ) {
          let el = issue2.path[i];
          i === issue2.path.length - 1 ? (curr[el] = curr[el] || { _errors: [] }, curr[el]._errors.push(mapper(issue2))) : curr[el] = curr[el] || { _errors: [] }, curr = curr[el], i++;
        }
      }
  };
  return processError(error2), fieldErrors;
}

// mcp-servers-src/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !1 }) : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  if (result.issues.length) {
    let e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, _params?.callee), e;
  }
  return result.value;
}, parse = /* @__PURE__ */ _parse($ZodRealError), _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise && (result = await result), result.issues.length) {
    let e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    throw captureStackTrace(e, params?.callee), e;
  }
  return result.value;
}, parseAsync = /* @__PURE__ */ _parseAsync($ZodRealError), _safeParse = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? { ..._ctx, async: !1 } : { async: !1 }, result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    throw new $ZodAsyncError();
  return result.issues.length ? {
    success: !1,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParse = /* @__PURE__ */ _safeParse($ZodRealError), _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { async: !0 }) : { async: !0 }, result = schema._zod.run({ value, issues: [] }, ctx);
  return result instanceof Promise && (result = await result), result.issues.length ? {
    success: !1,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: !0, data: result.value };
}, safeParseAsync = /* @__PURE__ */ _safeParseAsync($ZodRealError), _encode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var _decode = (_Err) => (schema, value, _ctx) => _parse(_Err)(schema, value, _ctx);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var _decodeAsync = (_Err) => async (schema, value, _ctx) => _parseAsync(_Err)(schema, value, _ctx);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var _safeDecode = (_Err) => (schema, value, _ctx) => _safeParse(_Err)(schema, value, _ctx);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  let ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => _safeParseAsync(_Err)(schema, value, _ctx);

// mcp-servers-src/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/, cuid2 = /^[0-9a-z]+$/, ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/, xid = /^[0-9a-vA-V]{20}$/, ksuid = /^[A-Za-z0-9]{27}$/, nanoid = /^[a-zA-Z0-9_-]{21}$/, duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/, extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/, uuid = (version2) => version2 ? new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`) : /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/, uuid4 = /* @__PURE__ */ uuid(4), uuid6 = /* @__PURE__ */ uuid(6), uuid7 = /* @__PURE__ */ uuid(7), email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/, html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/, unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u, idnEmail = unicodeEmail, browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/, _emoji = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/, mac = (delimiter) => {
  let escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
}, cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/, cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/, base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/, base64url = /^[A-Za-z0-9_-]*$/, hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/, domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/, e164 = /^\+[1-9]\d{6,14}$/, dateSource = "(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))", date = /* @__PURE__ */ new RegExp(`^${dateSource}$`);
function timeSource(args) {
  let hhmm = "(?:[01]\\d|2[0-3]):[0-5]\\d";
  return typeof args.precision == "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  let time3 = timeSource({ precision: args.precision }), opts = ["Z"];
  args.local && opts.push(""), args.offset && opts.push("([+-](?:[01]\\d|2[0-3]):[0-5]\\d)");
  let timeRegex2 = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex2})$`);
}
var string = (params) => {
  let regex = params ? `[\\s\\S]{${params?.minimum ?? 0},${params?.maximum ?? ""}}` : "[\\s\\S]*";
  return new RegExp(`^${regex}$`);
}, bigint = /^-?\d+n?$/, integer = /^-?\d+$/, number = /^-?\d+(?:\.\d+)?$/, boolean = /^(?:true|false)$/i, _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/, uppercase = /^[^a-z]*$/, hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/, md5_base64 = /* @__PURE__ */ fixedBase64(22, "=="), md5_base64url = /* @__PURE__ */ fixedBase64url(22), sha1_hex = /^[0-9a-fA-F]{40}$/, sha1_base64 = /* @__PURE__ */ fixedBase64(27, "="), sha1_base64url = /* @__PURE__ */ fixedBase64url(27), sha256_hex = /^[0-9a-fA-F]{64}$/, sha256_base64 = /* @__PURE__ */ fixedBase64(43, "="), sha256_base64url = /* @__PURE__ */ fixedBase64url(43), sha384_hex = /^[0-9a-fA-F]{96}$/, sha384_base64 = /* @__PURE__ */ fixedBase64(64, ""), sha384_base64url = /* @__PURE__ */ fixedBase64url(64), sha512_hex = /^[0-9a-fA-F]{128}$/, sha512_base64 = /* @__PURE__ */ fixedBase64(86, "=="), sha512_base64url = /* @__PURE__ */ fixedBase64url(86);

// mcp-servers-src/node_modules/zod/v4/core/checks.js
var $ZodCheck = /* @__PURE__ */ $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {}), inst._zod.def = def, (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
}), numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
}, $ZodCheckLessThan = /* @__PURE__ */ $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    def.value < curr && (def.inclusive ? bag.maximum = def.value : bag.exclusiveMaximum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value <= def.value : payload.value < def.value) || payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckGreaterThan = /* @__PURE__ */ $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  let origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag, curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    def.value > curr && (def.inclusive ? bag.minimum = def.value : bag.exclusiveMinimum = def.value);
  }), inst._zod.check = (payload) => {
    (def.inclusive ? payload.value >= def.value : payload.value > def.value) || payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value == "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMultipleOf = /* @__PURE__ */ $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  }), inst._zod.check = (payload) => {
    if (typeof payload.value != typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    (typeof payload.value == "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder2(payload.value, def.value) === 0) || payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckNumberFormat = /* @__PURE__ */ $constructor("$ZodCheckNumberFormat", (inst, def) => {
  $ZodCheck.init(inst, def), def.format = def.format || "float64";
  let isInt = def.format?.includes("int"), origin = isInt ? "int" : "number", [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum, isInt && (bag.pattern = integer);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: !1,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        input > 0 ? payload.issues.push({
          input,
          code: "too_big",
          maximum: Number.MAX_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        }) : payload.issues.push({
          input,
          code: "too_small",
          minimum: Number.MIN_SAFE_INTEGER,
          note: "Integers must be within the safe integer range.",
          inst,
          origin,
          inclusive: !0,
          continue: !def.abort
        });
        return;
      }
    }
    input < minimum && payload.issues.push({
      origin: "number",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "number",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckBigIntFormat = /* @__PURE__ */ $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  let [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, bag.minimum = minimum, bag.maximum = maximum;
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input < minimum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_small",
      minimum,
      inclusive: !0,
      inst,
      continue: !def.abort
    }), input > maximum && payload.issues.push({
      origin: "bigint",
      input,
      code: "too_big",
      maximum,
      inclusive: !0,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxSize = /* @__PURE__ */ $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size <= def.maximum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinSize = /* @__PURE__ */ $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    input.size >= def.minimum || payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckSizeEquals = /* @__PURE__ */ $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.size !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.size, bag.maximum = def.size, bag.size = def.size;
  }), inst._zod.check = (payload) => {
    let input = payload.value, size = input.size;
    if (size === def.size)
      return;
    let tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMaxLength = /* @__PURE__ */ $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    def.maximum < curr && (inst2._zod.bag.maximum = def.maximum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length <= def.maximum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckMinLength = /* @__PURE__ */ $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    def.minimum > curr && (inst2._zod.bag.minimum = def.minimum);
  }), inst._zod.check = (payload) => {
    let input = payload.value;
    if (input.length >= def.minimum)
      return;
    let origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: !0,
      input,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLengthEquals = /* @__PURE__ */ $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def), (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    let val = payload.value;
    return !nullish(val) && val.length !== void 0;
  }), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.minimum = def.length, bag.maximum = def.length, bag.length = def.length;
  }), inst._zod.check = (payload) => {
    let input = payload.value, length = input.length;
    if (length === def.length)
      return;
    let origin = getLengthableOrigin(input), tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: !0,
      exact: !0,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStringFormat = /* @__PURE__ */ $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.format = def.format, def.pattern && (bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(def.pattern));
  }), def.pattern ? (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      ...def.pattern ? { pattern: def.pattern.toString() } : {},
      inst,
      continue: !def.abort
    });
  }) : (_b = inst._zod).check ?? (_b.check = () => {
  });
}), $ZodCheckRegex = /* @__PURE__ */ $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0, !def.pattern.test(payload.value) && payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckLowerCase = /* @__PURE__ */ $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckUpperCase = /* @__PURE__ */ $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase), $ZodCheckStringFormat.init(inst, def);
}), $ZodCheckIncludes = /* @__PURE__ */ $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  let escapedRegex = escapeRegex(def.includes), pattern = new RegExp(typeof def.position == "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern, inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.includes(def.includes, def.position) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckStartsWith = /* @__PURE__ */ $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.startsWith(def.prefix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckEndsWith = /* @__PURE__ */ $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  let pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern), inst._zod.onattach.push((inst2) => {
    let bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set()), bag.patterns.add(pattern);
  }), inst._zod.check = (payload) => {
    payload.value.endsWith(def.suffix) || payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  result.issues.length && payload.issues.push(...prefixIssues(property, result.issues));
}
var $ZodCheckProperty = /* @__PURE__ */ $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    let result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise)
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    handleCheckPropertyResult(result, payload, def.property);
  };
}), $ZodCheckMimeType = /* @__PURE__ */ $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  let mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  }), inst._zod.check = (payload) => {
    mimeSet.has(payload.value.type) || payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCheckOverwrite = /* @__PURE__ */ $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def), inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// mcp-servers-src/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [], this.indent = 0, this && (this.args = args);
  }
  indented(fn) {
    this.indent += 1, fn(this), this.indent -= 1;
  }
  write(arg) {
    if (typeof arg == "function") {
      arg(this, { execution: "sync" }), arg(this, { execution: "async" });
      return;
    }
    let lines = arg.split(`
`).filter((x) => x), minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length)), dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (let line of dedented)
      this.content.push(line);
  }
  compile() {
    let F = Function, args = this?.args, lines = [...(this?.content ?? [""]).map((x) => `  ${x}`)];
    return new F(...args, lines.join(`
`));
  }
};

// mcp-servers-src/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 3,
  patch: 6
};

// mcp-servers-src/node_modules/zod/v4/core/schemas.js
var $ZodType = /* @__PURE__ */ $constructor("$ZodType", (inst, def) => {
  var _a2;
  inst ?? (inst = {}), inst._zod.def = def, inst._zod.bag = inst._zod.bag || {}, inst._zod.version = version;
  let checks = [...inst._zod.def.checks ?? []];
  inst._zod.traits.has("$ZodCheck") && checks.unshift(inst);
  for (let ch of checks)
    for (let fn of ch._zod.onattach)
      fn(inst);
  if (checks.length === 0)
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []), inst._zod.deferred?.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  else {
    let runChecks = (payload, checks2, ctx) => {
      let isAborted2 = aborted(payload), asyncResult;
      for (let ch of checks2) {
        if (ch._zod.def.when) {
          if (!ch._zod.def.when(payload))
            continue;
        } else if (isAborted2)
          continue;
        let currLen = payload.issues.length, _ = ch._zod.check(payload);
        if (_ instanceof Promise && ctx?.async === !1)
          throw new $ZodAsyncError();
        if (asyncResult || _ instanceof Promise)
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _, payload.issues.length !== currLen && (isAborted2 || (isAborted2 = aborted(payload, currLen)));
          });
        else {
          if (payload.issues.length === currLen)
            continue;
          isAborted2 || (isAborted2 = aborted(payload, currLen));
        }
      }
      return asyncResult ? asyncResult.then(() => payload) : payload;
    }, handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary))
        return canary.aborted = !0, canary;
      let checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks)
        return inst._zod.parse(payload, ctx);
      if (ctx.direction === "backward") {
        let canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: !0 });
        return canary instanceof Promise ? canary.then((canary2) => handleCanaryResult(canary2, payload, ctx)) : handleCanaryResult(canary, payload, ctx);
      }
      let result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === !1)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      try {
        let r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: r.error?.issues };
      } catch {
        return safeParseAsync(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });
      }
    },
    vendor: "zod",
    version: 1
  }));
}), $ZodString = /* @__PURE__ */ $constructor("$ZodString", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = [...inst?._zod.bag?.patterns ?? []].pop() ?? string(inst._zod.bag), inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch {
      }
    return typeof payload.value == "string" || payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodStringFormat = /* @__PURE__ */ $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def), $ZodString.init(inst, def);
}), $ZodGUID = /* @__PURE__ */ $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid), $ZodStringFormat.init(inst, def);
}), $ZodUUID = /* @__PURE__ */ $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    let v = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    }[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
}), $ZodEmail = /* @__PURE__ */ $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email), $ZodStringFormat.init(inst, def);
}), $ZodURL = /* @__PURE__ */ $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    try {
      let trimmed = payload.value.trim(), url2 = new URL(trimmed);
      def.hostname && (def.hostname.lastIndex = 0, def.hostname.test(url2.hostname) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid hostname",
        pattern: def.hostname.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.protocol && (def.protocol.lastIndex = 0, def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol) || payload.issues.push({
        code: "invalid_format",
        format: "url",
        note: "Invalid protocol",
        pattern: def.protocol.source,
        input: payload.value,
        inst,
        continue: !def.abort
      })), def.normalize ? payload.value = url2.href : payload.value = trimmed;
      return;
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodEmoji = /* @__PURE__ */ $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji()), $ZodStringFormat.init(inst, def);
}), $ZodNanoID = /* @__PURE__ */ $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid), $ZodStringFormat.init(inst, def);
}), $ZodCUID = /* @__PURE__ */ $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid), $ZodStringFormat.init(inst, def);
}), $ZodCUID2 = /* @__PURE__ */ $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2), $ZodStringFormat.init(inst, def);
}), $ZodULID = /* @__PURE__ */ $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid), $ZodStringFormat.init(inst, def);
}), $ZodXID = /* @__PURE__ */ $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid), $ZodStringFormat.init(inst, def);
}), $ZodKSUID = /* @__PURE__ */ $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid), $ZodStringFormat.init(inst, def);
}), $ZodISODateTime = /* @__PURE__ */ $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODate = /* @__PURE__ */ $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date), $ZodStringFormat.init(inst, def);
}), $ZodISOTime = /* @__PURE__ */ $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def)), $ZodStringFormat.init(inst, def);
}), $ZodISODuration = /* @__PURE__ */ $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration), $ZodStringFormat.init(inst, def);
}), $ZodIPv4 = /* @__PURE__ */ $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv4";
}), $ZodIPv6 = /* @__PURE__ */ $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "ipv6", inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
}), $ZodMAC = /* @__PURE__ */ $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter)), $ZodStringFormat.init(inst, def), inst._zod.bag.format = "mac";
}), $ZodCIDRv4 = /* @__PURE__ */ $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4), $ZodStringFormat.init(inst, def);
}), $ZodCIDRv6 = /* @__PURE__ */ $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6), $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    let parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      let [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      let prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return !0;
  if (data.length % 4 !== 0)
    return !1;
  try {
    return atob(data), !0;
  } catch {
    return !1;
  }
}
var $ZodBase64 = /* @__PURE__ */ $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64", inst._zod.check = (payload) => {
    isValidBase64(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return !1;
  let base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/"), padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = /* @__PURE__ */ $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url), $ZodStringFormat.init(inst, def), inst._zod.bag.contentEncoding = "base64url", inst._zod.check = (payload) => {
    isValidBase64URL(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodE164 = /* @__PURE__ */ $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164), $ZodStringFormat.init(inst, def);
});
function isValidJWT2(token, algorithm = null) {
  try {
    let tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return !1;
    let [header] = tokensParts;
    if (!header)
      return !1;
    let parsedHeader = JSON.parse(atob(header));
    return !("typ" in parsedHeader && parsedHeader?.typ !== "JWT" || !parsedHeader.alg || algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm));
  } catch {
    return !1;
  }
}
var $ZodJWT = /* @__PURE__ */ $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    isValidJWT2(payload.value, def.alg) || payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodCustomStringFormat = /* @__PURE__ */ $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), inst._zod.check = (payload) => {
    def.fn(payload.value) || payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
}), $ZodNumber = /* @__PURE__ */ $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = inst._zod.bag.pattern ?? number, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch {
      }
    let input = payload.value;
    if (typeof input == "number" && !Number.isNaN(input) && Number.isFinite(input))
      return payload;
    let received = typeof input == "number" ? Number.isNaN(input) ? "NaN" : Number.isFinite(input) ? void 0 : "Infinity" : void 0;
    return payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    }), payload;
  };
}), $ZodNumberFormat = /* @__PURE__ */ $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def), $ZodNumber.init(inst, def);
}), $ZodBoolean = /* @__PURE__ */ $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = boolean, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = !!payload.value;
      } catch {
      }
    let input = payload.value;
    return typeof input == "boolean" || payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodBigInt = /* @__PURE__ */ $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = bigint, inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch {
      }
    return typeof payload.value == "bigint" || payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    }), payload;
  };
}), $ZodBigIntFormat = /* @__PURE__ */ $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def), $ZodBigInt.init(inst, def);
}), $ZodSymbol = /* @__PURE__ */ $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input == "symbol" || payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodUndefined = /* @__PURE__ */ $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _undefined, inst._zod.values = /* @__PURE__ */ new Set([void 0]), inst._zod.optin = "optional", inst._zod.optout = "optional", inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodNull = /* @__PURE__ */ $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.pattern = _null, inst._zod.values = /* @__PURE__ */ new Set([null]), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input === null || payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodAny = /* @__PURE__ */ $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodUnknown = /* @__PURE__ */ $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload) => payload;
}), $ZodNever = /* @__PURE__ */ $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => (payload.issues.push({
    expected: "never",
    code: "invalid_type",
    input: payload.value,
    inst
  }), payload);
}), $ZodVoid = /* @__PURE__ */ $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return typeof input > "u" || payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodDate = /* @__PURE__ */ $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = new Date(payload.value);
      } catch {
      }
    let input = payload.value, isDate = input instanceof Date;
    return isDate && !Number.isNaN(input.getTime()) || payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    }), payload;
  };
});
function handleArrayResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodArray = /* @__PURE__ */ $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = Array(input.length);
    let proms = [];
    for (let i = 0; i < input.length; i++) {
      let item = input[i], result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleArrayResult(result2, payload, i))) : handleArrayResult(result, payload, i);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input))
      return;
    final.issues.push(...prefixIssues(key, result.issues));
  }
  result.value === void 0 ? key in input && (final.value[key] = void 0) : final.value[key] = result.value;
}
function normalizeDef(def) {
  let keys = Object.keys(def.shape);
  for (let k of keys)
    if (!def.shape?.[k]?._zod?.traits?.has("$ZodType"))
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
  let okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  let unrecognized = [], keySet = def.keySet, _catchall = def.catchall._zod, t = _catchall.def.type, isOptionalOut = _catchall.optout === "optional";
  for (let key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    let r = _catchall.run({ value: input[key], issues: [] }, ctx);
    r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
  }
  return unrecognized.length && payload.issues.push({
    code: "unrecognized_keys",
    keys: unrecognized,
    input,
    inst
  }), proms.length ? Promise.all(proms).then(() => payload) : payload;
}
var $ZodObject = /* @__PURE__ */ $constructor("$ZodObject", (inst, def) => {
  if ($ZodType.init(inst, def), !Object.getOwnPropertyDescriptor(def, "shape")?.get) {
    let sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        let newSh = { ...sh };
        return Object.defineProperty(def, "shape", {
          value: newSh
        }), newSh;
      }
    });
  }
  let _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    let shape = def.shape, propValues = {};
    for (let key in shape) {
      let field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (let v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  let isObject2 = isObject, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    if (!isObject2(input))
      return payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      }), payload;
    payload.value = {};
    let proms = [], shape = value.shape;
    for (let key of value.keys) {
      let el = shape[key], isOptionalOut = el._zod.optout === "optional", r = el._zod.run({ value: input[key], issues: [] }, ctx);
      r instanceof Promise ? proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut))) : handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
    return catchall ? handleCatchall(proms, input, payload, ctx, _normalized.value, inst) : proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodObjectJIT = /* @__PURE__ */ $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  let superParse = inst._zod.parse, _normalized = cached(() => normalizeDef(def)), generateFastpass = (shape) => {
    let doc = new Doc(["shape", "payload", "ctx"]), normalized = _normalized.value, parseStr = (key) => {
      let k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write("const input = payload.value;");
    let ids = /* @__PURE__ */ Object.create(null), counter = 0;
    for (let key of normalized.keys)
      ids[key] = `key_${counter++}`;
    doc.write("const newResult = {};");
    for (let key of normalized.keys) {
      let id = ids[key], k = esc(key), isOptionalOut = shape[key]?._zod?.optout === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`), isOptionalOut ? doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `) : doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write("payload.value = newResult;"), doc.write("return payload;");
    let fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  }, fastpass, isObject2 = isObject, jit = !globalConfig.jitless, fastEnabled = jit && allowsEval.value, catchall = def.catchall, value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    let input = payload.value;
    return isObject2(input) ? jit && fastEnabled && ctx?.async === !1 && ctx.jitless !== !0 ? (fastpass || (fastpass = generateFastpass(def.shape)), payload = fastpass(payload, ctx), catchall ? handleCatchall([], input, payload, ctx, value, inst) : payload) : superParse(payload, ctx) : (payload.issues.push({
      expected: "object",
      code: "invalid_type",
      input,
      inst
    }), payload);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (let result of results)
    if (result.issues.length === 0)
      return final.value = result.value, final;
  let nonaborted = results.filter((r) => !aborted(r));
  return nonaborted.length === 1 ? (final.value = nonaborted[0].value, nonaborted[0]) : (final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }), final);
}
var $ZodUnion = /* @__PURE__ */ $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0), defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0), defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values))
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
  }), defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      let patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
  });
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise)
        results.push(result), async = !0;
      else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    return async ? Promise.all(results).then((results2) => handleUnionResults(results2, payload, inst, ctx)) : handleUnionResults(results, payload, inst, ctx);
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  let successes = results.filter((r) => r.issues.length === 0);
  return successes.length === 1 ? (final.value = successes[0].value, final) : (successes.length === 0 ? final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  }) : final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: [],
    inclusive: !1
  }), final);
}
var $ZodXor = /* @__PURE__ */ $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def), def.inclusive = !1;
  let single = def.options.length === 1, first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single)
      return first(payload, ctx);
    let async = !1, results = [];
    for (let option of def.options) {
      let result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      result instanceof Promise ? (results.push(result), async = !0) : results.push(result);
    }
    return async ? Promise.all(results).then((results2) => handleExclusiveUnionResults(results2, payload, inst, ctx)) : handleExclusiveUnionResults(results, payload, inst, ctx);
  };
}), $ZodDiscriminatedUnion = /* @__PURE__ */ $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = !1, $ZodUnion.init(inst, def);
  let _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    let propValues = {};
    for (let option of def.options) {
      let pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (let [k, v] of Object.entries(pv)) {
        propValues[k] || (propValues[k] = /* @__PURE__ */ new Set());
        for (let val of v)
          propValues[k].add(val);
      }
    }
    return propValues;
  });
  let disc = cached(() => {
    let opts = def.options, map2 = /* @__PURE__ */ new Map();
    for (let o of opts) {
      let values = o._zod.propValues?.[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (let v of values) {
        if (map2.has(v))
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isObject(input))
      return payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      }), payload;
    let opt = disc.value.get(input?.[def.discriminator]);
    return opt ? opt._zod.run(payload, ctx) : def.unionFallback ? _super(payload, ctx) : (payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    }), payload);
  };
}), $ZodIntersection = /* @__PURE__ */ $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value, left = def.left._zod.run({ value: input, issues: [] }, ctx), right = def.right._zod.run({ value: input, issues: [] }, ctx);
    return left instanceof Promise || right instanceof Promise ? Promise.all([left, right]).then(([left2, right2]) => handleIntersectionResults(payload, left2, right2)) : handleIntersectionResults(payload, left, right);
  };
});
function mergeValues2(a, b) {
  if (a === b)
    return { valid: !0, data: a };
  if (a instanceof Date && b instanceof Date && +a == +b)
    return { valid: !0, data: a };
  if (isPlainObject(a) && isPlainObject(b)) {
    let bKeys = Object.keys(b), sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1), newObj = { ...a, ...b };
    for (let key of sharedKeys) {
      let sharedValue = mergeValues2(a[key], b[key]);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      newObj[key] = sharedValue.data;
    }
    return { valid: !0, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length)
      return { valid: !1, mergeErrorPath: [] };
    let newArray = [];
    for (let index = 0; index < a.length; index++) {
      let itemA = a[index], itemB = b[index], sharedValue = mergeValues2(itemA, itemB);
      if (!sharedValue.valid)
        return {
          valid: !1,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      newArray.push(sharedValue.data);
    }
    return { valid: !0, data: newArray };
  }
  return { valid: !1, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  let unrecKeys = /* @__PURE__ */ new Map(), unrecIssue;
  for (let iss of left.issues)
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).l = !0;
    } else
      result.issues.push(iss);
  for (let iss of right.issues)
    if (iss.code === "unrecognized_keys")
      for (let k of iss.keys)
        unrecKeys.has(k) || unrecKeys.set(k, {}), unrecKeys.get(k).r = !0;
    else
      result.issues.push(iss);
  let bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue && result.issues.push({ ...unrecIssue, keys: bothKeys }), aborted(result))
    return result;
  let merged = mergeValues2(left.value, right.value);
  if (!merged.valid)
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  return result.value = merged.data, result;
}
var $ZodTuple = /* @__PURE__ */ $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  let items = def.items;
  inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!Array.isArray(input))
      return payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      }), payload;
    payload.value = [];
    let proms = [], reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional"), optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      let tooBig = input.length > items.length, tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall)
        return payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: !0 } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        }), payload;
    }
    let i = -1;
    for (let item of items) {
      if (i++, i >= input.length && i >= optStart)
        continue;
      let result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
    }
    if (def.rest) {
      let rest = input.slice(items.length);
      for (let el of rest) {
        i++;
        let result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => handleTupleResult(result2, payload, i))) : handleTupleResult(result, payload, i);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleTupleResult(result, final, index) {
  result.issues.length && final.issues.push(...prefixIssues(index, result.issues)), final.value[index] = result.value;
}
var $ZodRecord = /* @__PURE__ */ $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!isPlainObject(input))
      return payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [], values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      let recordKeys = /* @__PURE__ */ new Set();
      for (let key of values)
        if (typeof key == "string" || typeof key == "number" || typeof key == "symbol") {
          recordKeys.add(typeof key == "number" ? key.toString() : key);
          let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          result instanceof Promise ? proms.push(result.then((result2) => {
            result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[key] = result2.value;
          })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[key] = result.value);
        }
      let unrecognized;
      for (let key in input)
        recordKeys.has(key) || (unrecognized = unrecognized ?? [], unrecognized.push(key));
      unrecognized && unrecognized.length > 0 && payload.issues.push({
        code: "unrecognized_keys",
        input,
        inst,
        keys: unrecognized
      });
    } else {
      payload.value = {};
      for (let key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise)
          throw new Error("Async schemas not supported in object keys currently");
        if (typeof key == "string" && number.test(key) && keyResult.issues.length) {
          let retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise)
            throw new Error("Async schemas not supported in object keys currently");
          retryResult.issues.length === 0 && (keyResult = retryResult);
        }
        if (keyResult.issues.length) {
          def.mode === "loose" ? payload.value[key] = input[key] : payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          continue;
        }
        let result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        result instanceof Promise ? proms.push(result.then((result2) => {
          result2.issues.length && payload.issues.push(...prefixIssues(key, result2.issues)), payload.value[keyResult.value] = result2.value;
        })) : (result.issues.length && payload.issues.push(...prefixIssues(key, result.issues)), payload.value[keyResult.value] = result.value);
      }
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
}), $ZodMap = /* @__PURE__ */ $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Map))
      return payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (let [key, value] of input) {
      let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx), valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      keyResult instanceof Promise || valueResult instanceof Promise ? proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
        handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
      })) : handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  keyResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, keyResult.issues)) : final.issues.push({
    code: "invalid_key",
    origin: "map",
    input,
    inst,
    issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), valueResult.issues.length && (propertyKeyTypes.has(typeof key) ? final.issues.push(...prefixIssues(key, valueResult.issues)) : final.issues.push({
    origin: "map",
    code: "invalid_element",
    input,
    inst,
    key,
    issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
  })), final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = /* @__PURE__ */ $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    let input = payload.value;
    if (!(input instanceof Set))
      return payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      }), payload;
    let proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (let item of input) {
      let result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      result instanceof Promise ? proms.push(result.then((result2) => handleSetResult(result2, payload))) : handleSetResult(result, payload);
    }
    return proms.length ? Promise.all(proms).then(() => payload) : payload;
  };
});
function handleSetResult(result, final) {
  result.issues.length && final.issues.push(...result.issues), final.value.add(result.value);
}
var $ZodEnum = /* @__PURE__ */ $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  let values = getEnumValues(def.entries), valuesSet = new Set(values);
  inst._zod.values = valuesSet, inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o == "string" ? escapeRegex(o) : o.toString()).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return valuesSet.has(input) || payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    }), payload;
  };
}), $ZodLiteral = /* @__PURE__ */ $constructor("$ZodLiteral", (inst, def) => {
  if ($ZodType.init(inst, def), def.values.length === 0)
    throw new Error("Cannot create literal schema with no valid values");
  let values = new Set(def.values);
  inst._zod.values = values, inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o == "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return values.has(input) || payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    }), payload;
  };
}), $ZodFile = /* @__PURE__ */ $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => {
    let input = payload.value;
    return input instanceof File || payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    }), payload;
  };
}), $ZodTransform = /* @__PURE__ */ $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    let _out = def.transform(payload.value, payload);
    if (ctx.async)
      return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output2) => (payload.value = output2, payload));
    if (_out instanceof Promise)
      throw new $ZodAsyncError();
    return payload.value = _out, payload;
  };
});
function handleOptionalResult(result, input) {
  return result.issues.length && input === void 0 ? { issues: [], value: void 0 } : result;
}
var $ZodOptional = /* @__PURE__ */ $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", inst._zod.optout = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      let result = def.innerType._zod.run(payload, ctx);
      return result instanceof Promise ? result.then((r) => handleOptionalResult(r, payload.value)) : handleOptionalResult(result, payload.value);
    }
    return payload.value === void 0 ? payload : def.innerType._zod.run(payload, ctx);
  };
}), $ZodExactOptional = /* @__PURE__ */ $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern), inst._zod.parse = (payload, ctx) => def.innerType._zod.run(payload, ctx);
}), $ZodNullable = /* @__PURE__ */ $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "pattern", () => {
    let pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  }), defineLazy(inst._zod, "values", () => def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0), inst._zod.parse = (payload, ctx) => payload.value === null ? payload : def.innerType._zod.run(payload, ctx);
}), $ZodDefault = /* @__PURE__ */ $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    if (payload.value === void 0)
      return payload.value = def.defaultValue, payload;
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleDefaultResult(result2, def)) : handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  return payload.value === void 0 && (payload.value = def.defaultValue), payload;
}
var $ZodPrefault = /* @__PURE__ */ $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.optin = "optional", defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => (ctx.direction === "backward" || payload.value === void 0 && (payload.value = def.defaultValue), def.innerType._zod.run(payload, ctx));
}), $ZodNonOptional = /* @__PURE__ */ $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => {
    let v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  }), inst._zod.parse = (payload, ctx) => {
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => handleNonOptionalResult(result2, inst)) : handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  return !payload.issues.length && payload.value === void 0 && payload.issues.push({
    code: "invalid_type",
    expected: "nonoptional",
    input: payload.value,
    inst
  }), payload;
}
var $ZodSuccess = /* @__PURE__ */ $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      throw new $ZodEncodeError("ZodSuccess");
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.issues.length === 0, payload)) : (payload.value = result.issues.length === 0, payload);
  };
}), $ZodCatch = /* @__PURE__ */ $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "optin", () => def.innerType._zod.optin), defineLazy(inst._zod, "optout", () => def.innerType._zod.optout), defineLazy(inst._zod, "values", () => def.innerType._zod.values), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then((result2) => (payload.value = result2.value, result2.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload)) : (payload.value = result.value, result.issues.length && (payload.value = def.catchValue({
      ...payload,
      error: {
        issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      },
      input: payload.value
    }), payload.issues = []), payload);
  };
}), $ZodNaN = /* @__PURE__ */ $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, _ctx) => ((typeof payload.value != "number" || !Number.isNaN(payload.value)) && payload.issues.push({
    input: payload.value,
    inst,
    expected: "nan",
    code: "invalid_type"
  }), payload);
}), $ZodPipe = /* @__PURE__ */ $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handlePipeResult(right2, def.in, ctx)) : handlePipeResult(right, def.in, ctx);
    }
    let left = def.in._zod.run(payload, ctx);
    return left instanceof Promise ? left.then((left2) => handlePipeResult(left2, def.out, ctx)) : handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = /* @__PURE__ */ $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "values", () => def.in._zod.values), defineLazy(inst._zod, "optin", () => def.in._zod.optin), defineLazy(inst._zod, "optout", () => def.out._zod.optout), defineLazy(inst._zod, "propValues", () => def.in._zod.propValues), inst._zod.parse = (payload, ctx) => {
    if ((ctx.direction || "forward") === "forward") {
      let left = def.in._zod.run(payload, ctx);
      return left instanceof Promise ? left.then((left2) => handleCodecAResult(left2, def, ctx)) : handleCodecAResult(left, def, ctx);
    } else {
      let right = def.out._zod.run(payload, ctx);
      return right instanceof Promise ? right.then((right2) => handleCodecAResult(right2, def, ctx)) : handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length)
    return result.aborted = !0, result;
  if ((ctx.direction || "forward") === "forward") {
    let transformed = def.transform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx)) : handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    let transformed = def.reverseTransform(result.value, result);
    return transformed instanceof Promise ? transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx)) : handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  return left.issues.length ? (left.aborted = !0, left) : nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = /* @__PURE__ */ $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues), defineLazy(inst._zod, "values", () => def.innerType._zod.values), defineLazy(inst._zod, "optin", () => def.innerType?._zod?.optin), defineLazy(inst._zod, "optout", () => def.innerType?._zod?.optout), inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward")
      return def.innerType._zod.run(payload, ctx);
    let result = def.innerType._zod.run(payload, ctx);
    return result instanceof Promise ? result.then(handleReadonlyResult) : handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  return payload.value = Object.freeze(payload.value), payload;
}
var $ZodTemplateLiteral = /* @__PURE__ */ $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  let regexParts = [];
  for (let part of def.parts)
    if (typeof part == "object" && part !== null) {
      if (!part._zod.pattern)
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      let source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      let start = source.startsWith("^") ? 1 : 0, end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part))
      regexParts.push(escapeRegex(`${part}`));
    else
      throw new Error(`Invalid template literal part: ${part}`);
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`), inst._zod.parse = (payload, _ctx) => typeof payload.value != "string" ? (payload.issues.push({
    input: payload.value,
    inst,
    expected: "string",
    code: "invalid_type"
  }), payload) : (inst._zod.pattern.lastIndex = 0, inst._zod.pattern.test(payload.value) || payload.issues.push({
    input: payload.value,
    inst,
    code: "invalid_format",
    format: def.format ?? "template_literal",
    pattern: inst._zod.pattern.source
  }), payload);
}), $ZodFunction = /* @__PURE__ */ $constructor("$ZodFunction", (inst, def) => ($ZodType.init(inst, def), inst._def = def, inst._zod.def = def, inst.implement = (func) => {
  if (typeof func != "function")
    throw new Error("implement() must be called with a function");
  return function(...args) {
    let parsedArgs = inst._def.input ? parse(inst._def.input, args) : args, result = Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? parse(inst._def.output, result) : result;
  };
}, inst.implementAsync = (func) => {
  if (typeof func != "function")
    throw new Error("implementAsync() must be called with a function");
  return async function(...args) {
    let parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args, result = await Reflect.apply(func, this, parsedArgs);
    return inst._def.output ? await parseAsync(inst._def.output, result) : result;
  };
}, inst._zod.parse = (payload, _ctx) => typeof payload.value != "function" ? (payload.issues.push({
  code: "invalid_type",
  expected: "function",
  input: payload.value,
  inst
}), payload) : (inst._def.output && inst._def.output._zod.def.type === "promise" ? payload.value = inst.implementAsync(payload.value) : payload.value = inst.implement(payload.value), payload), inst.input = (...args) => {
  let F = inst.constructor;
  return Array.isArray(args[0]) ? new F({
    type: "function",
    input: new $ZodTuple({
      type: "tuple",
      items: args[0],
      rest: args[1]
    }),
    output: inst._def.output
  }) : new F({
    type: "function",
    input: args[0],
    output: inst._def.output
  });
}, inst.output = (output) => {
  let F = inst.constructor;
  return new F({
    type: "function",
    input: inst._def.input,
    output
  });
}, inst)), $ZodPromise = /* @__PURE__ */ $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def), inst._zod.parse = (payload, ctx) => Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
}), $ZodLazy = /* @__PURE__ */ $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def), defineLazy(inst._zod, "innerType", () => def.getter()), defineLazy(inst._zod, "pattern", () => inst._zod.innerType?._zod?.pattern), defineLazy(inst._zod, "propValues", () => inst._zod.innerType?._zod?.propValues), defineLazy(inst._zod, "optin", () => inst._zod.innerType?._zod?.optin ?? void 0), defineLazy(inst._zod, "optout", () => inst._zod.innerType?._zod?.optout ?? void 0), inst._zod.parse = (payload, ctx) => inst._zod.innerType._zod.run(payload, ctx);
}), $ZodCustom = /* @__PURE__ */ $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def), $ZodType.init(inst, def), inst._zod.parse = (payload, _) => payload, inst._zod.check = (payload) => {
    let input = payload.value, r = def.fn(input);
    if (r instanceof Promise)
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    handleRefineResult(r, payload, input, inst);
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    let _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    inst._zod.def.params && (_iss.params = inst._zod.def.params), payload.issues.push(issue(_iss));
  }
}

// mcp-servers-src/node_modules/zod/v4/locales/en.js
var error = () => {
  let Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  let FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  }, TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        let expected = TypeDictionary[issue2.expected] ?? issue2.expected, receivedType = parsedType(issue2.input), received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        return issue2.values.length === 1 ? `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}` : `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        let adj = issue2.inclusive ? "<=" : "<", sizing = getSizing(issue2.origin);
        return sizing ? `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}` : `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        let adj = issue2.inclusive ? ">=" : ">", sizing = getSizing(issue2.origin);
        return sizing ? `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}` : `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        let _issue = issue2;
        return _issue.format === "starts_with" ? `Invalid string: must start with "${_issue.prefix}"` : _issue.format === "ends_with" ? `Invalid string: must end with "${_issue.suffix}"` : _issue.format === "includes" ? `Invalid string: must include "${_issue.includes}"` : _issue.format === "regex" ? `Invalid string: must match pattern ${_issue.pattern}` : `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return "Invalid input";
    }
  };
};
function en_default2() {
  return {
    localeError: error()
  };
}

// mcp-servers-src/node_modules/zod/v4/core/registries.js
var _a, $output = Symbol("ZodOutput"), $input = Symbol("ZodInput"), $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    let meta3 = _meta[0];
    return this._map.set(schema, meta3), meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.set(meta3.id, schema), this;
  }
  clear() {
    return this._map = /* @__PURE__ */ new WeakMap(), this._idmap = /* @__PURE__ */ new Map(), this;
  }
  remove(schema) {
    let meta3 = this._map.get(schema);
    return meta3 && typeof meta3 == "object" && "id" in meta3 && this._idmap.delete(meta3.id), this._map.delete(schema), this;
  }
  get(schema) {
    let p = schema._zod.parent;
    if (p) {
      let pm = { ...this.get(p) ?? {} };
      delete pm.id;
      let f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// mcp-servers-src/node_modules/zod/v4/core/api.js
// @__NO_SIDE_EFFECTS__
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v4",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v6",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: !1,
    version: "v7",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: !1,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: !1,
    local: !1,
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "safeint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "float64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "int32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: !1,
    format: "uint32",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "int64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: !1,
    format: "uint64",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
// @__NO_SIDE_EFFECTS__
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
// @__NO_SIDE_EFFECTS__
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !1
  });
}
// @__NO_SIDE_EFFECTS__
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: !0
  });
}
// @__NO_SIDE_EFFECTS__
function _positive(params) {
  return /* @__PURE__ */ _gt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _negative(params) {
  return /* @__PURE__ */ _lt(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonpositive(params) {
  return /* @__PURE__ */ _lte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _nonnegative(params) {
  return /* @__PURE__ */ _gte(0, params);
}
// @__NO_SIDE_EFFECTS__
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
// @__NO_SIDE_EFFECTS__
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
// @__NO_SIDE_EFFECTS__
function _maxLength(maximum, params) {
  return new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
}
// @__NO_SIDE_EFFECTS__
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
// @__NO_SIDE_EFFECTS__
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
// @__NO_SIDE_EFFECTS__
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
// @__NO_SIDE_EFFECTS__
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
// @__NO_SIDE_EFFECTS__
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
// @__NO_SIDE_EFFECTS__
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
// @__NO_SIDE_EFFECTS__
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
// @__NO_SIDE_EFFECTS__
function _normalize(form) {
  return /* @__PURE__ */ _overwrite((input) => input.normalize(form));
}
// @__NO_SIDE_EFFECTS__
function _trim() {
  return /* @__PURE__ */ _overwrite((input) => input.trim());
}
// @__NO_SIDE_EFFECTS__
function _toLowerCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toLowerCase());
}
// @__NO_SIDE_EFFECTS__
function _toUpperCase() {
  return /* @__PURE__ */ _overwrite((input) => input.toUpperCase());
}
// @__NO_SIDE_EFFECTS__
function _slugify() {
  return /* @__PURE__ */ _overwrite((input) => slugify(input));
}
// @__NO_SIDE_EFFECTS__
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
// @__NO_SIDE_EFFECTS__
function _custom(Class2, fn, _params) {
  let norm = normalizeParams(_params);
  return norm.abort ?? (norm.abort = !0), new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
}
// @__NO_SIDE_EFFECTS__
function _refine(Class2, fn, _params) {
  return new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
}
// @__NO_SIDE_EFFECTS__
function _superRefine(fn) {
  let ch = /* @__PURE__ */ _check((payload) => (payload.addIssue = (issue2) => {
    if (typeof issue2 == "string")
      payload.issues.push(issue(issue2, payload.value, ch._zod.def));
    else {
      let _issue = issue2;
      _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = ch), _issue.continue ?? (_issue.continue = !ch._zod.def.abort), payload.issues.push(issue(_issue));
    }
  }, fn(payload.value, payload)));
  return ch;
}
// @__NO_SIDE_EFFECTS__
function _check(fn, params) {
  let ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  return ch._zod.check = fn, ch;
}
// @__NO_SIDE_EFFECTS__
function describe(description) {
  let ch = new $ZodCheck({ check: "describe" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function meta(metadata) {
  let ch = new $ZodCheck({ check: "meta" });
  return ch._zod.onattach = [
    (inst) => {
      let existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ], ch._zod.check = () => {
  }, ch;
}
// @__NO_SIDE_EFFECTS__
function _stringbool(Classes, _params) {
  let params = normalizeParams(_params), truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"], falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  params.case !== "sensitive" && (truthyArray = truthyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v), falsyArray = falsyArray.map((v) => typeof v == "string" ? v.toLowerCase() : v));
  let truthySet = new Set(truthyArray), falsySet = new Set(falsyArray), _Codec = Classes.Codec ?? $ZodCodec, _Boolean = Classes.Boolean ?? $ZodBoolean, _String = Classes.String ?? $ZodString, stringSchema = new _String({ type: "string", error: params.error }), booleanSchema = new _Boolean({ type: "boolean", error: params.error }), codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      return params.case !== "sensitive" && (data = data.toLowerCase()), truthySet.has(data) ? !0 : falsySet.has(data) ? !1 : (payload.issues.push({
        code: "invalid_value",
        expected: "stringbool",
        values: [...truthySet, ...falsySet],
        input: payload.value,
        inst: codec2,
        continue: !1
      }), {});
    },
    reverseTransform: (input, _payload) => input === !0 ? truthyArray[0] || "true" : falsyArray[0] || "false",
    error: params.error
  });
  return codec2;
}
// @__NO_SIDE_EFFECTS__
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  let params = normalizeParams(_params), def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex == "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  return fnOrRegex instanceof RegExp && (def.pattern = fnOrRegex), new Class2(def);
}

// mcp-servers-src/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = params?.target ?? "draft-2020-12";
  return target === "draft-4" && (target = "draft-04"), target === "draft-7" && (target = "draft-07"), {
    processors: params.processors ?? {},
    metadataRegistry: params?.metadata ?? globalRegistry,
    target,
    unrepresentable: params?.unrepresentable ?? "throw",
    override: params?.override ?? (() => {
    }),
    io: params?.io ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: params?.cycles ?? "ref",
    reused: params?.reused ?? "inline",
    external: params?.external ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a2;
  let def = schema._zod.def, seen = ctx.seen.get(schema);
  if (seen)
    return seen.count++, _params.schemaPath.includes(schema) && (seen.cycle = _params.path), seen.schema;
  let result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  let overrideSchema = schema._zod.toJSONSchema?.();
  if (overrideSchema)
    result.schema = overrideSchema;
  else {
    let params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema)
      schema._zod.processJSONSchema(ctx, result.schema, params);
    else {
      let _json = result.schema, processor = ctx.processors[def.type];
      if (!processor)
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      processor(schema, ctx, _json, params);
    }
    let parent = schema._zod.parent;
    parent && (result.ref || (result.ref = parent), process2(parent, ctx, params), ctx.seen.get(parent).isParent = !0);
  }
  let meta3 = ctx.metadataRegistry.get(schema);
  return meta3 && Object.assign(result.schema, meta3), ctx.io === "input" && isTransforming(schema) && (delete result.schema.examples, delete result.schema.default), ctx.io === "input" && result.schema._prefault && ((_a2 = result.schema).default ?? (_a2.default = result.schema._prefault)), delete result.schema._prefault, ctx.seen.get(schema).schema;
}
function extractDefs(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let idToSchema = /* @__PURE__ */ new Map();
  for (let entry of ctx.seen.entries()) {
    let id = ctx.metadataRegistry.get(entry[0])?.id;
    if (id) {
      let existing = idToSchema.get(id);
      if (existing && existing !== entry[0])
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      idToSchema.set(id, entry[0]);
    }
  }
  let makeURI = (entry) => {
    let defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      let externalId = ctx.external.registry.get(entry[0])?.id, uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId)
        return { ref: uriGenerator(externalId) };
      let id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      return entry[1].defId = id, { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root)
      return { ref: "#" };
    let defUriPrefix = `#/${defsSegment}/`, defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  }, extractToDef = (entry) => {
    if (entry[1].schema.$ref)
      return;
    let seen = entry[1], { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema }, defId && (seen.defId = defId);
    let schema2 = seen.schema;
    for (let key in schema2)
      delete schema2[key];
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw")
    for (let entry of ctx.seen.entries()) {
      let seen = entry[1];
      if (seen.cycle)
        throw new Error(`Cycle detected: #/${seen.cycle?.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
    }
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      let ext = ctx.external.registry.get(entry[0])?.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    if (ctx.metadataRegistry.get(entry[0])?.id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1 && ctx.reused === "ref") {
      extractToDef(entry);
      continue;
    }
  }
}
function finalize(ctx, schema) {
  let root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  let flattenRef = (zodSchema) => {
    let seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    let schema2 = seen.def ?? seen.schema, _cached = { ...schema2 }, ref = seen.ref;
    if (seen.ref = null, ref) {
      flattenRef(ref);
      let refSeen = ctx.seen.get(ref), refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0") ? (schema2.allOf = schema2.allOf ?? [], schema2.allOf.push(refSchema)) : Object.assign(schema2, refSchema), Object.assign(schema2, _cached), zodSchema._zod.parent === ref)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in _cached || delete schema2[key];
      if (refSchema.$ref && refSeen.def)
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key]) && delete schema2[key];
    }
    let parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      let parentSeen = ctx.seen.get(parent);
      if (parentSeen?.schema.$ref && (schema2.$ref = parentSeen.schema.$ref, parentSeen.def))
        for (let key in schema2)
          key === "$ref" || key === "allOf" || key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key]) && delete schema2[key];
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (let entry of [...ctx.seen.entries()].reverse())
    flattenRef(entry[0]);
  let result = {};
  if (ctx.target === "draft-2020-12" ? result.$schema = "https://json-schema.org/draft/2020-12/schema" : ctx.target === "draft-07" ? result.$schema = "http://json-schema.org/draft-07/schema#" : ctx.target === "draft-04" ? result.$schema = "http://json-schema.org/draft-04/schema#" : ctx.target, ctx.external?.uri) {
    let id = ctx.external.registry.get(schema)?.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  let defs = ctx.external?.defs ?? {};
  for (let entry of ctx.seen.entries()) {
    let seen = entry[1];
    seen.def && seen.defId && (defs[seen.defId] = seen.def);
  }
  ctx.external || Object.keys(defs).length > 0 && (ctx.target === "draft-2020-12" ? result.$defs = defs : result.definitions = defs);
  try {
    let finalized = JSON.parse(JSON.stringify(result));
    return Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: !1,
      writable: !1
    }), finalized;
  } catch {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  let ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return !1;
  ctx.seen.add(_schema);
  let def = _schema._zod.def;
  if (def.type === "transform")
    return !0;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault")
    return isTransforming(def.innerType, ctx);
  if (def.type === "intersection")
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  if (def.type === "record" || def.type === "map")
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  if (def.type === "pipe")
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  if (def.type === "object") {
    for (let key in def.shape)
      if (isTransforming(def.shape[key], ctx))
        return !0;
    return !1;
  }
  if (def.type === "union") {
    for (let option of def.options)
      if (isTransforming(option, ctx))
        return !0;
    return !1;
  }
  if (def.type === "tuple") {
    for (let item of def.items)
      if (isTransforming(item, ctx))
        return !0;
    return !!(def.rest && isTransforming(def.rest, ctx));
  }
  return !1;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  let ctx = initializeContext({ ...params, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
}, createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  let { libraryOptions, target } = params ?? {}, ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  return process2(schema, ctx), extractDefs(ctx, schema), finalize(ctx, schema);
};

// mcp-servers-src/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
}, stringProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json;
  json2.type = "string";
  let { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum == "number" && (json2.minLength = minimum), typeof maximum == "number" && (json2.maxLength = maximum), format && (json2.format = formatMap[format] ?? format, json2.format === "" && delete json2.format, format === "time" && delete json2.format), contentEncoding && (json2.contentEncoding = contentEncoding), patterns && patterns.size > 0) {
    let regexes = [...patterns];
    regexes.length === 1 ? json2.pattern = regexes[0].source : regexes.length > 1 && (json2.allOf = [
      ...regexes.map((regex) => ({
        ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
        pattern: regex.source
      }))
    ]);
  }
}, numberProcessor = (schema, ctx, _json, _params) => {
  let json2 = _json, { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  typeof format == "string" && format.includes("int") ? json2.type = "integer" : json2.type = "number", typeof exclusiveMinimum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.minimum = exclusiveMinimum, json2.exclusiveMinimum = !0) : json2.exclusiveMinimum = exclusiveMinimum), typeof minimum == "number" && (json2.minimum = minimum, typeof exclusiveMinimum == "number" && ctx.target !== "draft-04" && (exclusiveMinimum >= minimum ? delete json2.minimum : delete json2.exclusiveMinimum)), typeof exclusiveMaximum == "number" && (ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? (json2.maximum = exclusiveMaximum, json2.exclusiveMaximum = !0) : json2.exclusiveMaximum = exclusiveMaximum), typeof maximum == "number" && (json2.maximum = maximum, typeof exclusiveMaximum == "number" && ctx.target !== "draft-04" && (exclusiveMaximum <= maximum ? delete json2.maximum : delete json2.exclusiveMaximum)), typeof multipleOf == "number" && (json2.multipleOf = multipleOf);
}, booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("BigInt cannot be represented in JSON Schema");
}, symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Symbols cannot be represented in JSON Schema");
}, nullProcessor = (_schema, ctx, json2, _params) => {
  ctx.target === "openapi-3.0" ? (json2.type = "string", json2.nullable = !0, json2.enum = [null]) : json2.type = "null";
}, undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Undefined cannot be represented in JSON Schema");
}, voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Void cannot be represented in JSON Schema");
}, neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
}, anyProcessor = (_schema, _ctx, _json, _params) => {
}, unknownProcessor = (_schema, _ctx, _json, _params) => {
}, dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Date cannot be represented in JSON Schema");
}, enumProcessor = (schema, _ctx, json2, _params) => {
  let def = schema._zod.def, values = getEnumValues(def.entries);
  values.every((v) => typeof v == "number") && (json2.type = "number"), values.every((v) => typeof v == "string") && (json2.type = "string"), json2.enum = values;
}, literalProcessor = (schema, ctx, json2, _params) => {
  let def = schema._zod.def, vals = [];
  for (let val of def.values)
    if (val === void 0) {
      if (ctx.unrepresentable === "throw")
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
    } else if (typeof val == "bigint") {
      if (ctx.unrepresentable === "throw")
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      vals.push(Number(val));
    } else
      vals.push(val);
  if (vals.length !== 0)
    if (vals.length === 1) {
      let val = vals[0];
      json2.type = val === null ? "null" : typeof val, ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? json2.enum = [val] : json2.const = val;
    } else
      vals.every((v) => typeof v == "number") && (json2.type = "number"), vals.every((v) => typeof v == "string") && (json2.type = "string"), vals.every((v) => typeof v == "boolean") && (json2.type = "boolean"), vals.every((v) => v === null) && (json2.type = "null"), json2.enum = vals;
}, nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("NaN cannot be represented in JSON Schema");
}, templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string", _json.pattern = pattern.source;
}, fileProcessor = (schema, _ctx, json2, _params) => {
  let _json = json2, file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  }, { minimum, maximum, mime } = schema._zod.bag;
  minimum !== void 0 && (file2.minLength = minimum), maximum !== void 0 && (file2.maxLength = maximum), mime ? mime.length === 1 ? (file2.contentMediaType = mime[0], Object.assign(_json, file2)) : (Object.assign(_json, file2), _json.anyOf = mime.map((m) => ({ contentMediaType: m }))) : Object.assign(_json, file2);
}, successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
}, customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Custom types cannot be represented in JSON Schema");
}, functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Function types cannot be represented in JSON Schema");
}, transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Transforms cannot be represented in JSON Schema");
}, mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Map cannot be represented in JSON Schema");
}, setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw")
    throw new Error("Set cannot be represented in JSON Schema");
}, arrayProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def, { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum), json2.type = "array", json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
}, objectProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object", json2.properties = {};
  let shape = def.shape;
  for (let key in shape)
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  let allKeys = new Set(Object.keys(shape)), requiredKeys = new Set([...allKeys].filter((key) => {
    let v = def.shape[key]._zod;
    return ctx.io === "input" ? v.optin === void 0 : v.optout === void 0;
  }));
  requiredKeys.size > 0 && (json2.required = Array.from(requiredKeys)), def.catchall?._zod.def.type === "never" ? json2.additionalProperties = !1 : def.catchall ? def.catchall && (json2.additionalProperties = process2(def.catchall, ctx, {
    ...params,
    path: [...params.path, "additionalProperties"]
  })) : ctx.io === "output" && (json2.additionalProperties = !1);
}, unionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, isExclusive = def.inclusive === !1, options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  isExclusive ? json2.oneOf = options : json2.anyOf = options;
}, intersectionProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  }), b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  }), isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1, allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
}, tupleProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "array";
  let prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items", restPath = ctx.target === "draft-2020-12" || ctx.target === "openapi-3.0" ? "items" : "additionalItems", prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  })), rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  ctx.target === "draft-2020-12" ? (json2.prefixItems = prefixItems, rest && (json2.items = rest)) : ctx.target === "openapi-3.0" ? (json2.items = {
    anyOf: prefixItems
  }, rest && json2.items.anyOf.push(rest), json2.minItems = prefixItems.length, rest || (json2.maxItems = prefixItems.length)) : (json2.items = prefixItems, rest && (json2.additionalItems = rest));
  let { minimum, maximum } = schema._zod.bag;
  typeof minimum == "number" && (json2.minItems = minimum), typeof maximum == "number" && (json2.maxItems = maximum);
}, recordProcessor = (schema, ctx, _json, params) => {
  let json2 = _json, def = schema._zod.def;
  json2.type = "object";
  let keyType = def.keyType, patterns = keyType._zod.bag?.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    let valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (let pattern of patterns)
      json2.patternProperties[pattern.source] = valueSchema;
  } else
    (ctx.target === "draft-07" || ctx.target === "draft-2020-12") && (json2.propertyNames = process2(def.keyType, ctx, {
      ...params,
      path: [...params.path, "propertyNames"]
    })), json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  let keyValues = keyType._zod.values;
  if (keyValues) {
    let validKeyValues = [...keyValues].filter((v) => typeof v == "string" || typeof v == "number");
    validKeyValues.length > 0 && (json2.required = validKeyValues);
  }
}, nullableProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def, inner = process2(def.innerType, ctx, params), seen = ctx.seen.get(schema);
  ctx.target === "openapi-3.0" ? (seen.ref = def.innerType, json2.nullable = !0) : json2.anyOf = [inner, { type: "null" }];
}, nonoptionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, defaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.default = JSON.parse(JSON.stringify(def.defaultValue));
}, prefaultProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, ctx.io === "input" && (json2._prefault = JSON.parse(JSON.stringify(def.defaultValue)));
}, catchProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
}, pipeProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def, innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
}, readonlyProcessor = (schema, ctx, json2, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType, json2.readOnly = !0;
}, promiseProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, optionalProcessor = (schema, ctx, _json, params) => {
  let def = schema._zod.def;
  process2(def.innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
}, lazyProcessor = (schema, ctx, _json, params) => {
  let innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  let seen = ctx.seen.get(schema);
  seen.ref = innerType;
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  return !!s._zod;
}
function safeParse2(schema, data) {
  return isZ4Schema(schema) ? safeParse(schema, data) : schema.safeParse(data);
}
function getObjectShape(schema) {
  if (!schema)
    return;
  let rawShape;
  if (isZ4Schema(schema) ? rawShape = schema._zod?.def?.shape : rawShape = schema.shape, !!rawShape) {
    if (typeof rawShape == "function")
      try {
        return rawShape();
      } catch {
        return;
      }
    return rawShape;
  }
}
function getLiteralValue(schema) {
  if (isZ4Schema(schema)) {
    let def2 = schema._zod?.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0)
        return def2.values[0];
    }
  }
  let def = schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0)
      return def.values[0];
  }
  let directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
}

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var schemas_exports3 = {};
__export(schemas_exports3, {
  ZodAny: () => ZodAny2,
  ZodArray: () => ZodArray2,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt2,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean2,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch2,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate2,
  ZodDefault: () => ZodDefault2,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion2,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum2,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction2,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection2,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy2,
  ZodLiteral: () => ZodLiteral2,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap2,
  ZodNaN: () => ZodNaN2,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever2,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull2,
  ZodNullable: () => ZodNullable2,
  ZodNumber: () => ZodNumber2,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject2,
  ZodOptional: () => ZodOptional2,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise2,
  ZodReadonly: () => ZodReadonly2,
  ZodRecord: () => ZodRecord2,
  ZodSet: () => ZodSet2,
  ZodString: () => ZodString2,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol2,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple2,
  ZodType: () => ZodType2,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined2,
  ZodUnion: () => ZodUnion2,
  ZodUnknown: () => ZodUnknown2,
  ZodVoid: () => ZodVoid2,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object2,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// mcp-servers-src/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// mcp-servers-src/node_modules/zod/v4/classic/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = /* @__PURE__ */ $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = /* @__PURE__ */ $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def), ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = /* @__PURE__ */ $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def), ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = /* @__PURE__ */ $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def), ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// mcp-servers-src/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues), inst.name = "ZodError", Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2), inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
}, ZodError2 = $constructor("ZodError", initializer2), ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// mcp-servers-src/node_modules/zod/v4/classic/parse.js
var parse2 = /* @__PURE__ */ _parse(ZodRealError), parseAsync2 = /* @__PURE__ */ _parseAsync(ZodRealError), safeParse3 = /* @__PURE__ */ _safeParse(ZodRealError), safeParseAsync2 = /* @__PURE__ */ _safeParseAsync(ZodRealError), encode2 = /* @__PURE__ */ _encode(ZodRealError), decode2 = /* @__PURE__ */ _decode(ZodRealError), encodeAsync2 = /* @__PURE__ */ _encodeAsync(ZodRealError), decodeAsync2 = /* @__PURE__ */ _decodeAsync(ZodRealError), safeEncode2 = /* @__PURE__ */ _safeEncode(ZodRealError), safeDecode2 = /* @__PURE__ */ _safeDecode(ZodRealError), safeEncodeAsync2 = /* @__PURE__ */ _safeEncodeAsync(ZodRealError), safeDecodeAsync2 = /* @__PURE__ */ _safeDecodeAsync(ZodRealError);

// mcp-servers-src/node_modules/zod/v4/classic/schemas.js
var ZodType2 = /* @__PURE__ */ $constructor("ZodType", (inst, def) => ($ZodType.init(inst, def), Object.assign(inst["~standard"], {
  jsonSchema: {
    input: createStandardJSONSchemaMethod(inst, "input"),
    output: createStandardJSONSchemaMethod(inst, "output")
  }
}), inst.toJSONSchema = createToJSONSchemaMethod(inst, {}), inst.def = def, inst.type = def.type, Object.defineProperty(inst, "_def", { value: def }), inst.check = (...checks) => inst.clone(util_exports.mergeDefs(def, {
  checks: [
    ...def.checks ?? [],
    ...checks.map((ch) => typeof ch == "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
  ]
}), {
  parent: !0
}), inst.with = inst.check, inst.clone = (def2, params) => clone(inst, def2, params), inst.brand = () => inst, inst.register = (reg, meta3) => (reg.add(inst, meta3), inst), inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse }), inst.safeParse = (data, params) => safeParse3(inst, data, params), inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync }), inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params), inst.spa = inst.safeParseAsync, inst.encode = (data, params) => encode2(inst, data, params), inst.decode = (data, params) => decode2(inst, data, params), inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params), inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params), inst.safeEncode = (data, params) => safeEncode2(inst, data, params), inst.safeDecode = (data, params) => safeDecode2(inst, data, params), inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params), inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params), inst.refine = (check2, params) => inst.check(refine(check2, params)), inst.superRefine = (refinement) => inst.check(superRefine(refinement)), inst.overwrite = (fn) => inst.check(_overwrite(fn)), inst.optional = () => optional(inst), inst.exactOptional = () => exactOptional(inst), inst.nullable = () => nullable(inst), inst.nullish = () => optional(nullable(inst)), inst.nonoptional = (params) => nonoptional(inst, params), inst.array = () => array(inst), inst.or = (arg) => union([inst, arg]), inst.and = (arg) => intersection(inst, arg), inst.transform = (tx) => pipe(inst, transform(tx)), inst.default = (def2) => _default(inst, def2), inst.prefault = (def2) => prefault(inst, def2), inst.catch = (params) => _catch(inst, params), inst.pipe = (target) => pipe(inst, target), inst.readonly = () => readonly(inst), inst.describe = (description) => {
  let cl = inst.clone();
  return globalRegistry.add(cl, { description }), cl;
}, Object.defineProperty(inst, "description", {
  get() {
    return globalRegistry.get(inst)?.description;
  },
  configurable: !0
}), inst.meta = (...args) => {
  if (args.length === 0)
    return globalRegistry.get(inst);
  let cl = inst.clone();
  return globalRegistry.add(cl, args[0]), cl;
}, inst.isOptional = () => inst.safeParse(void 0).success, inst.isNullable = () => inst.safeParse(null).success, inst.apply = (fn) => fn(inst), inst)), _ZodString = /* @__PURE__ */ $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  let bag = inst._zod.bag;
  inst.format = bag.format ?? null, inst.minLength = bag.minimum ?? null, inst.maxLength = bag.maximum ?? null, inst.regex = (...args) => inst.check(_regex(...args)), inst.includes = (...args) => inst.check(_includes(...args)), inst.startsWith = (...args) => inst.check(_startsWith(...args)), inst.endsWith = (...args) => inst.check(_endsWith(...args)), inst.min = (...args) => inst.check(_minLength(...args)), inst.max = (...args) => inst.check(_maxLength(...args)), inst.length = (...args) => inst.check(_length(...args)), inst.nonempty = (...args) => inst.check(_minLength(1, ...args)), inst.lowercase = (params) => inst.check(_lowercase(params)), inst.uppercase = (params) => inst.check(_uppercase(params)), inst.trim = () => inst.check(_trim()), inst.normalize = (...args) => inst.check(_normalize(...args)), inst.toLowerCase = () => inst.check(_toLowerCase()), inst.toUpperCase = () => inst.check(_toUpperCase()), inst.slugify = () => inst.check(_slugify());
}), ZodString2 = /* @__PURE__ */ $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def), _ZodString.init(inst, def), inst.email = (params) => inst.check(_email(ZodEmail, params)), inst.url = (params) => inst.check(_url(ZodURL, params)), inst.jwt = (params) => inst.check(_jwt(ZodJWT, params)), inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.uuid = (params) => inst.check(_uuid(ZodUUID, params)), inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params)), inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params)), inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params)), inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params)), inst.guid = (params) => inst.check(_guid(ZodGUID, params)), inst.cuid = (params) => inst.check(_cuid(ZodCUID, params)), inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params)), inst.ulid = (params) => inst.check(_ulid(ZodULID, params)), inst.base64 = (params) => inst.check(_base64(ZodBase64, params)), inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params)), inst.xid = (params) => inst.check(_xid(ZodXID, params)), inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params)), inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params)), inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params)), inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params)), inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params)), inst.e164 = (params) => inst.check(_e164(ZodE164, params)), inst.datetime = (params) => inst.check(datetime2(params)), inst.date = (params) => inst.check(date2(params)), inst.time = (params) => inst.check(time2(params)), inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString2, params);
}
var ZodStringFormat = /* @__PURE__ */ $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def), _ZodString.init(inst, def);
}), ZodEmail = /* @__PURE__ */ $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def), ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = /* @__PURE__ */ $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = /* @__PURE__ */ $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = /* @__PURE__ */ $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def), ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = /* @__PURE__ */ $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def), ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = /* @__PURE__ */ $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def), ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = /* @__PURE__ */ $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = /* @__PURE__ */ $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def), ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = /* @__PURE__ */ $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = /* @__PURE__ */ $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def), ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = /* @__PURE__ */ $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def), ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = /* @__PURE__ */ $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = /* @__PURE__ */ $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def), ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = /* @__PURE__ */ $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = /* @__PURE__ */ $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = /* @__PURE__ */ $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def), ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = /* @__PURE__ */ $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def), ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = /* @__PURE__ */ $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def), ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = /* @__PURE__ */ $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def), ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = /* @__PURE__ */ $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def), ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = /* @__PURE__ */ $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def), ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  let enc = params?.enc ?? "hex", format = `${alg}_${enc}`, regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber2 = /* @__PURE__ */ $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.int = (params) => inst.check(int(params)), inst.safe = (params) => inst.check(int(params)), inst.positive = (params) => inst.check(_gt(0, params)), inst.nonnegative = (params) => inst.check(_gte(0, params)), inst.negative = (params) => inst.check(_lt(0, params)), inst.nonpositive = (params) => inst.check(_lte(0, params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params)), inst.step = (value, params) => inst.check(_multipleOf(value, params)), inst.finite = () => inst;
  let bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null, inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null, inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5), inst.isFinite = !0, inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber2, params);
}
var ZodNumberFormat = /* @__PURE__ */ $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def), ZodNumber2.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean2 = /* @__PURE__ */ $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean2, params);
}
var ZodBigInt2 = /* @__PURE__ */ $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.gt = (value, params) => inst.check(_gt(value, params)), inst.gte = (value, params) => inst.check(_gte(value, params)), inst.min = (value, params) => inst.check(_gte(value, params)), inst.lt = (value, params) => inst.check(_lt(value, params)), inst.lte = (value, params) => inst.check(_lte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params)), inst.positive = (params) => inst.check(_gt(BigInt(0), params)), inst.negative = (params) => inst.check(_lt(BigInt(0), params)), inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params)), inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params)), inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  let bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null, inst.maxValue = bag.maximum ?? null, inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt2, params);
}
var ZodBigIntFormat = /* @__PURE__ */ $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def), ZodBigInt2.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol2 = /* @__PURE__ */ $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol2, params);
}
var ZodUndefined2 = /* @__PURE__ */ $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined2, params);
}
var ZodNull2 = /* @__PURE__ */ $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull2, params);
}
var ZodAny2 = /* @__PURE__ */ $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny2);
}
var ZodUnknown2 = /* @__PURE__ */ $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown2);
}
var ZodNever2 = /* @__PURE__ */ $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever2, params);
}
var ZodVoid2 = /* @__PURE__ */ $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid2, params);
}
var ZodDate2 = /* @__PURE__ */ $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params), inst.min = (value, params) => inst.check(_gte(value, params)), inst.max = (value, params) => inst.check(_lte(value, params));
  let c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null, inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate2, params);
}
var ZodArray2 = /* @__PURE__ */ $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params), inst.element = def.element, inst.min = (minLength, params) => inst.check(_minLength(minLength, params)), inst.nonempty = (params) => inst.check(_minLength(1, params)), inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params)), inst.length = (len, params) => inst.check(_length(len, params)), inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray2, element, params);
}
function keyof(schema) {
  let shape = schema._zod.def.shape;
  return _enum(Object.keys(shape));
}
var ZodObject2 = /* @__PURE__ */ $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params), util_exports.defineLazy(inst, "shape", () => def.shape), inst.keyof = () => _enum(Object.keys(inst._zod.def.shape)), inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall }), inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() }), inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() }), inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 }), inst.extend = (incoming) => util_exports.extend(inst, incoming), inst.safeExtend = (incoming) => util_exports.safeExtend(inst, incoming), inst.merge = (other) => util_exports.merge(inst, other), inst.pick = (mask) => util_exports.pick(inst, mask), inst.omit = (mask) => util_exports.omit(inst, mask), inst.partial = (...args) => util_exports.partial(ZodOptional2, inst, args[0]), inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object2(shape, params) {
  let def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject2(def);
}
function strictObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject2({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion2 = /* @__PURE__ */ $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion2({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = /* @__PURE__ */ $constructor("ZodXor", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodXor.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params), inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: !1,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion2 = /* @__PURE__ */ $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion2.init(inst, def), $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion2({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection2 = /* @__PURE__ */ $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection2({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple2 = /* @__PURE__ */ $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params), inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  let hasRest = _paramsOrRest instanceof $ZodType, params = hasRest ? _params : _paramsOrRest, rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple2({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord2 = /* @__PURE__ */ $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  let k = clone(keyType);
  return k._zod.values = void 0, new ZodRecord2({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord2({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap2 = /* @__PURE__ */ $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params), inst.keyType = def.keyType, inst.valueType = def.valueType, inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap2({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet2 = /* @__PURE__ */ $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params), inst.min = (...args) => inst.check(_minSize(...args)), inst.nonempty = (params) => inst.check(_minSize(1, params)), inst.max = (...args) => inst.check(_maxSize(...args)), inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet2({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum2 = /* @__PURE__ */ $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params), inst.enum = def.entries, inst.options = Object.values(def.entries);
  let keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    let newEntries = {};
    for (let value of values)
      if (keys.has(value))
        newEntries[value] = def.entries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  }, inst.exclude = (values, params) => {
    let newEntries = { ...def.entries };
    for (let value of values)
      if (keys.has(value))
        delete newEntries[value];
      else
        throw new Error(`Key ${value} not found in enum`);
    return new ZodEnum2({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  let entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum2({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral2 = /* @__PURE__ */ $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params), inst.values = new Set(def.values), Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1)
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = /* @__PURE__ */ $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params), inst.min = (size, params) => inst.check(_minSize(size, params)), inst.max = (size, params) => inst.check(_maxSize(size, params)), inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = /* @__PURE__ */ $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params), inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward")
      throw new $ZodEncodeError(inst.constructor.name);
    payload.addIssue = (issue2) => {
      if (typeof issue2 == "string")
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      else {
        let _issue = issue2;
        _issue.fatal && (_issue.continue = !1), _issue.code ?? (_issue.code = "custom"), _issue.input ?? (_issue.input = payload.value), _issue.inst ?? (_issue.inst = inst), payload.issues.push(util_exports.issue(_issue));
      }
    };
    let output = def.transform(payload.value, payload);
    return output instanceof Promise ? output.then((output2) => (payload.value = output2, payload)) : (payload.value = output, payload);
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional2 = /* @__PURE__ */ $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional2({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = /* @__PURE__ */ $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable2 = /* @__PURE__ */ $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable2({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault2 = /* @__PURE__ */ $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = /* @__PURE__ */ $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue == "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = /* @__PURE__ */ $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = /* @__PURE__ */ $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch2 = /* @__PURE__ */ $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType, inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue == "function" ? catchValue : () => catchValue
  });
}
var ZodNaN2 = /* @__PURE__ */ $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN2, params);
}
var ZodPipe = /* @__PURE__ */ $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params), inst.in = def.in, inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = /* @__PURE__ */ $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def), $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly2 = /* @__PURE__ */ $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly2({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = /* @__PURE__ */ $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy2 = /* @__PURE__ */ $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy2({
    type: "lazy",
    getter
  });
}
var ZodPromise2 = /* @__PURE__ */ $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params), inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise2({
    type: "promise",
    innerType
  });
}
var ZodFunction2 = /* @__PURE__ */ $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction2({
    type: "function",
    input: Array.isArray(params?.input) ? tuple(params?.input) : params?.input ?? array(unknown()),
    output: params?.output ?? unknown()
  });
}
var ZodCustom = /* @__PURE__ */ $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def), ZodType2.init(inst, def), inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  let ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  return ch._zod.check = fn, ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => !0), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe, meta2 = meta;
function _instanceof(cls, params = {}) {
  let inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: !0,
    ...util_exports.normalizeParams(params)
  });
  return inst._zod.bag.Class = cls, inst._zod.check = (payload) => {
    payload.value instanceof cls || payload.issues.push({
      code: "invalid_type",
      expected: cls.name,
      input: payload.value,
      inst,
      path: [...inst._zod.def.path ?? []]
    });
  }, inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean2,
  String: ZodString2
}, ...args);
function json(params) {
  let jsonSchema = lazy(() => union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]));
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// mcp-servers-src/node_modules/zod/v4/classic/compat.js
var ZodFirstPartyTypeKind2;
ZodFirstPartyTypeKind2 || (ZodFirstPartyTypeKind2 = {});

// mcp-servers-src/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports3,
  ...checks_exports2,
  iso: iso_exports2
};

// mcp-servers-src/node_modules/zod/v4/classic/external.js
config(en_default2());

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"], RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task", JSONRPC_VERSION = "2.0", AssertObjectSchema = custom((v) => v !== null && (typeof v == "object" || typeof v == "function")), ProgressTokenSchema = union([string2(), number2().int()]), CursorSchema = string2(), TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number2().optional()
}), TaskMetadataSchema = object2({
  ttl: number2().optional()
}), RelatedTaskMetadataSchema = object2({
  taskId: string2()
}), RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
}), BaseRequestParamsSchema = object2({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
}), TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
}), isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success, RequestSchema = object2({
  method: string2(),
  params: BaseRequestParamsSchema.loose().optional()
}), NotificationsParamsSchema = object2({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), NotificationSchema = object2({
  method: string2(),
  params: NotificationsParamsSchema.loose().optional()
}), ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
}), RequestIdSchema = union([string2(), number2().int()]), JSONRPCRequestSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict(), isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success, JSONRPCNotificationSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict(), isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success, JSONRPCResultResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict(), isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2.ConnectionClosed = -32e3] = "ConnectionClosed", ErrorCode2[ErrorCode2.RequestTimeout = -32001] = "RequestTimeout", ErrorCode2[ErrorCode2.ParseError = -32700] = "ParseError", ErrorCode2[ErrorCode2.InvalidRequest = -32600] = "InvalidRequest", ErrorCode2[ErrorCode2.MethodNotFound = -32601] = "MethodNotFound", ErrorCode2[ErrorCode2.InvalidParams = -32602] = "InvalidParams", ErrorCode2[ErrorCode2.InternalError = -32603] = "InternalError", ErrorCode2[ErrorCode2.UrlElicitationRequired = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object2({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object2({
    /**
     * The error type that occurred.
     */
    code: number2().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string2(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]), JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]), EmptyResultSchema = ResultSchema.strict(), CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string2().optional()
}), CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
}), IconSchema = object2({
  /**
   * URL or data URI for the icon.
   */
  src: string2(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string2().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string2()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
}), IconsSchema = object2({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
}), BaseMetadataSchema = object2({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string2(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string2().optional()
}), ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string2(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string2().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string2().optional()
}), FormElicitationCapabilitySchema = intersection(object2({
  applyDefaults: boolean2().optional()
}), record(string2(), unknown())), ElicitationCapabilitySchema = preprocess((value) => value && typeof value == "object" && !Array.isArray(value) && Object.keys(value).length === 0 ? { form: {} } : value, intersection(object2({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string2(), unknown()).optional())), ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
}), ClientCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object2({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object2({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
}), InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string2(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
}), InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object2({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string2(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object2({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object2({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean2().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object2({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean2().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
}), InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string2(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string2().optional()
}), InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
}), ProgressSchema = object2({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number2(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number2()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string2())
}), ProgressNotificationParamsSchema = object2({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
}), ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
}), PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
}), PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
}), PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
}), TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]), TaskSchema = object2({
  taskId: string2(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number2(), _null3()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string2(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string2(),
  pollInterval: optional(number2()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string2())
}), CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
}), TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema), TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
}), GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskResultSchema = ResultSchema.merge(TaskSchema), GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), GetTaskPayloadResultSchema = ResultSchema.loose(), ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
}), ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
}), CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string2()
  })
}), CancelTaskResultSchema = ResultSchema.merge(TaskSchema), ResourceContentsSchema = object2({
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string2()
}), Base64Schema = string2().refine((val) => {
  try {
    return atob(val), !0;
  } catch {
    return !1;
  }
}, { message: "Invalid Base64 string" }), BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
}), RoleSchema = _enum(["user", "assistant"]), AnnotationsSchema = object2({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number2().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports2.datetime({ offset: !0 }).optional()
}), ResourceSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string2(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ResourceTemplateSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string2(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string2()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string2()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
}), ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
}), ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
}), ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
}), ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string2()
}), ReadResourceRequestParamsSchema = ResourceRequestParamsSchema, ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
}), ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
}), ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
}), SubscribeRequestParamsSchema = ResourceRequestParamsSchema, SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
}), UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema, UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
}), ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string2()
}), ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
}), PromptArgumentSchema = object2({
  /**
   * The name of the argument.
   */
  name: string2(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string2()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean2())
}), PromptSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string2()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
}), ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
}), ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
}), GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string2(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string2(), string2()).optional()
}), GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
}), TextContentSchema = object2({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ImageContentSchema = object2({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), AudioContentSchema = object2({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string2(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ToolUseContentSchema = object2({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string2(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string2(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string2(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), EmbeddedResourceSchema = object2({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
}), ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]), PromptMessageSchema = object2({
  role: RoleSchema,
  content: ContentBlockSchema
}), GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string2().optional(),
  messages: array(PromptMessageSchema)
}), PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ToolAnnotationsSchema = object2({
  /**
   * A human-readable title for the tool.
   */
  title: string2().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean2().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean2().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean2().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean2().optional()
}), ToolExecutionSchema = object2({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
}), ToolSchema = object2({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string2().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object2({
    type: literal("object"),
    properties: record(string2(), AssertObjectSchema).optional(),
    required: array(string2()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
}), ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
}), CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string2(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean2().optional()
}), CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
})), CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string2(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string2(), unknown()).optional()
}), CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
}), ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ListChangedOptionsBaseSchema = object2({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean2().default(!0),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number2().int().nonnegative().default(300)
}), LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]), SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
}), SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
}), LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string2().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
}), LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
}), ModelHintSchema = object2({
  /**
   * A hint for a model name.
   */
  name: string2().optional()
}), ModelPreferencesSchema = object2({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number2().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number2().min(0).max(1).optional()
}), ToolChoiceSchema = object2({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
}), ToolResultContentSchema = object2({
  type: literal("tool_result"),
  toolUseId: string2().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object2({}).loose().optional(),
  isError: boolean2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]), SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]), SamplingMessageSchema = object2({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string2().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number2().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number2().int(),
  stopSequences: array(string2()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
}), CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
}), CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
}), CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string2(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string2())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
}), BooleanSchemaSchema = object2({
  type: literal("boolean"),
  title: string2().optional(),
  description: string2().optional(),
  default: boolean2().optional()
}), StringSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  minLength: number2().optional(),
  maxLength: number2().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string2().optional()
}), NumberSchemaSchema = object2({
  type: _enum(["number", "integer"]),
  title: string2().optional(),
  description: string2().optional(),
  minimum: number2().optional(),
  maximum: number2().optional(),
  default: number2().optional()
}), UntitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  default: string2().optional()
}), TitledSingleSelectEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  oneOf: array(object2({
    const: string2(),
    title: string2()
  })),
  default: string2().optional()
}), LegacyTitledEnumSchemaSchema = object2({
  type: literal("string"),
  title: string2().optional(),
  description: string2().optional(),
  enum: array(string2()),
  enumNames: array(string2()).optional(),
  default: string2().optional()
}), SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]), UntitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    type: literal("string"),
    enum: array(string2())
  }),
  default: array(string2()).optional()
}), TitledMultiSelectEnumSchemaSchema = object2({
  type: literal("array"),
  title: string2().optional(),
  description: string2().optional(),
  minItems: number2().optional(),
  maxItems: number2().optional(),
  items: object2({
    anyOf: array(object2({
      const: string2(),
      title: string2()
    }))
  }),
  default: array(string2()).optional()
}), MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]), EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]), PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]), ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string2(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object2({
    type: literal("object"),
    properties: record(string2(), PrimitiveSchemaDefinitionSchema),
    required: array(string2()).optional()
  })
}), ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string2(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string2(),
  /**
   * The URL that the user should navigate to.
   */
  url: string2().url()
}), ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]), ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
}), ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string2()
}), ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
}), ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string2(), union([string2(), number2(), boolean2(), array(string2())])).optional())
}), ResourceTemplateReferenceSchema = object2({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string2()
});
var PromptReferenceSchema = object2({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string2()
}), CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object2({
    /**
     * The name of the argument
     */
    name: string2(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string2()
  }),
  context: object2({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string2(), string2()).optional()
  }).optional()
}), CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string2()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number2().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean2())
  })
}), RootSchema = object2({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string2().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string2().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string2(), unknown()).optional()
}), ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
}), ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
}), RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
}), ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]), ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]), ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]), ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]), McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`), this.code = code, this.data = data, this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      let errorData = data;
      if (errorData.elicitations)
        return new UrlElicitationRequiredError(errorData.elicitations, message);
    }
    return new _McpError(code, message, data);
  }
}, UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    return this.data?.elicitations ?? [];
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/Options.js
var ignoreOverride = Symbol("Let zodToJsonSchema decide on which parser to use");

// mcp-servers-src/node_modules/zod-to-json-schema/dist/esm/parsers/string.js
var ALPHA_NUMERIC = new Set("ABCDEFGHIJKLMNOPQRSTUVXYZabcdefghijklmnopqrstuvxyz0123456789");

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  let methodSchema = getObjectShape(schema)?.method;
  if (!methodSchema)
    throw new Error("Schema is missing a method literal");
  let value = getLiteralValue(methodSchema);
  if (typeof value != "string")
    throw new Error("Schema method literal must be a string");
  return value;
}
function parseWithCompat(schema, data) {
  let result = safeParse2(schema, data);
  if (!result.success)
    throw result.error;
  return result.data;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4, Protocol = class {
  constructor(_options) {
    this._options = _options, this._requestMessageId = 0, this._requestHandlers = /* @__PURE__ */ new Map(), this._requestHandlerAbortControllers = /* @__PURE__ */ new Map(), this._notificationHandlers = /* @__PURE__ */ new Map(), this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers = /* @__PURE__ */ new Map(), this._timeoutInfo = /* @__PURE__ */ new Map(), this._pendingDebouncedNotifications = /* @__PURE__ */ new Set(), this._taskProgressTokens = /* @__PURE__ */ new Map(), this._requestResolvers = /* @__PURE__ */ new Map(), this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    }), this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    }), this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    ), this._taskStore = _options?.taskStore, this._taskMessageQueue = _options?.taskMessageQueue, this._taskStore && (this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
      let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
      if (!task)
        throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
      return {
        ...task
      };
    }), this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
      let handleTaskResult = async () => {
        let taskId = request.params.taskId;
        if (this._taskMessageQueue) {
          let queuedMessage;
          for (; queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId); ) {
            if (queuedMessage.type === "response" || queuedMessage.type === "error") {
              let message = queuedMessage.message, requestId = message.id, resolver = this._requestResolvers.get(requestId);
              if (resolver)
                if (this._requestResolvers.delete(requestId), queuedMessage.type === "response")
                  resolver(message);
                else {
                  let errorMessage = message, error2 = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                  resolver(error2);
                }
              else {
                let messageType = queuedMessage.type === "response" ? "Response" : "Error";
                this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
              }
              continue;
            }
            await this._transport?.send(queuedMessage.message, { relatedRequestId: extra.requestId });
          }
        }
        let task = await this._taskStore.getTask(taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
        if (!isTerminal(task.status))
          return await this._waitForTaskUpdate(taskId, extra.signal), await handleTaskResult();
        if (isTerminal(task.status)) {
          let result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
          return this._clearTaskQueue(taskId), {
            ...result,
            _meta: {
              ...result._meta,
              [RELATED_TASK_META_KEY]: {
                taskId
              }
            }
          };
        }
        return await handleTaskResult();
      };
      return await handleTaskResult();
    }), this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
      try {
        let { tasks, nextCursor } = await this._taskStore.listTasks(request.params?.cursor, extra.sessionId);
        return {
          tasks,
          nextCursor,
          _meta: {}
        };
      } catch (error2) {
        throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }), this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
      try {
        let task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
        await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId), this._clearTaskQueue(request.params.taskId);
        let cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!cancelledTask)
          throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
        return {
          _meta: {},
          ...cancelledTask
        };
      } catch (error2) {
        throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error2 instanceof Error ? error2.message : String(error2)}`);
      }
    }));
  }
  async _oncancel(notification) {
    if (!notification.params.requestId)
      return;
    this._requestHandlerAbortControllers.get(notification.params.requestId)?.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = !1) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    if (!info)
      return !1;
    let totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout)
      throw this._timeoutInfo.delete(messageId), McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    return clearTimeout(info.timeoutId), info.timeoutId = setTimeout(info.onTimeout, info.timeout), !0;
  }
  _cleanupTimeout(messageId) {
    let info = this._timeoutInfo.get(messageId);
    info && (clearTimeout(info.timeoutId), this._timeoutInfo.delete(messageId));
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    if (this._transport)
      throw new Error("Already connected to a transport. Call close() before connecting to a new transport, or use a separate Protocol instance per connection.");
    this._transport = transport;
    let _onclose = this.transport?.onclose;
    this._transport.onclose = () => {
      _onclose?.(), this._onclose();
    };
    let _onerror = this.transport?.onerror;
    this._transport.onerror = (error2) => {
      _onerror?.(error2), this._onerror(error2);
    };
    let _onmessage = this._transport?.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage?.(message, extra), isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message) ? this._onresponse(message) : isJSONRPCRequest(message) ? this._onrequest(message, extra) : isJSONRPCNotification(message) ? this._onnotification(message) : this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
    }, await this._transport.start();
  }
  _onclose() {
    let responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map(), this._progressHandlers.clear(), this._taskProgressTokens.clear(), this._pendingDebouncedNotifications.clear();
    for (let controller of this._requestHandlerAbortControllers.values())
      controller.abort();
    this._requestHandlerAbortControllers.clear();
    let error2 = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0, this.onclose?.();
    for (let handler of responseHandlers.values())
      handler(error2);
  }
  _onerror(error2) {
    this.onerror?.(error2);
  }
  _onnotification(notification) {
    let handler = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    handler !== void 0 && Promise.resolve().then(() => handler(notification)).catch((error2) => this._onerror(new Error(`Uncaught error in notification handler: ${error2}`)));
  }
  _onrequest(request, extra) {
    let handler = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler, capturedTransport = this._transport, relatedTaskId = request.params?._meta?.[RELATED_TASK_META_KEY]?.taskId;
    if (handler === void 0) {
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      relatedTaskId && this._taskMessageQueue ? this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId).catch((error2) => this._onerror(new Error(`Failed to enqueue error response: ${error2}`))) : capturedTransport?.send(errorResponse).catch((error2) => this._onerror(new Error(`Failed to send an error response: ${error2}`)));
      return;
    }
    let abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    let taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0, taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport?.sessionId) : void 0, fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport?.sessionId,
      _meta: request.params?._meta,
      sendNotification: async (notification) => {
        if (abortController.signal.aborted)
          return;
        let notificationOptions = { relatedRequestId: request.id };
        relatedTaskId && (notificationOptions.relatedTask = { taskId: relatedTaskId }), await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r, resultSchema, options) => {
        if (abortController.signal.aborted)
          throw new McpError(ErrorCode.ConnectionClosed, "Request was cancelled");
        let requestOptions = { ...options, relatedRequestId: request.id };
        relatedTaskId && !requestOptions.relatedTask && (requestOptions.relatedTask = { taskId: relatedTaskId });
        let effectiveTaskId = requestOptions.relatedTask?.taskId ?? relatedTaskId;
        return effectiveTaskId && taskStore && await taskStore.updateTaskStatus(effectiveTaskId, "input_required"), await this.request(r, resultSchema, requestOptions);
      },
      authInfo: extra?.authInfo,
      requestId: request.id,
      requestInfo: extra?.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams?.ttl,
      closeSSEStream: extra?.closeSSEStream,
      closeStandaloneSSEStream: extra?.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      taskCreationParams && this.assertTaskHandlerCapability(request.method);
    }).then(() => handler(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted)
        return;
      let response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "response",
        message: response,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(response);
    }, async (error2) => {
      if (abortController.signal.aborted)
        return;
      let errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error2.code) ? error2.code : ErrorCode.InternalError,
          message: error2.message ?? "Internal error",
          ...error2.data !== void 0 && { data: error2.data }
        }
      };
      relatedTaskId && this._taskMessageQueue ? await this._enqueueTaskMessage(relatedTaskId, {
        type: "error",
        message: errorResponse,
        timestamp: Date.now()
      }, capturedTransport?.sessionId) : await capturedTransport?.send(errorResponse);
    }).catch((error2) => this._onerror(new Error(`Failed to send response: ${error2}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    let { progressToken, ...params } = notification.params, messageId = Number(progressToken), handler = this._progressHandlers.get(messageId);
    if (!handler) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    let responseHandler = this._responseHandlers.get(messageId), timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress)
      try {
        this._resetTimeout(messageId);
      } catch (error2) {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), responseHandler(error2);
        return;
      }
    handler(params);
  }
  _onresponse(response) {
    let messageId = Number(response.id), resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      if (this._requestResolvers.delete(messageId), isJSONRPCResultResponse(response))
        resolver(response);
      else {
        let error2 = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error2);
      }
      return;
    }
    let handler = this._responseHandlers.get(messageId);
    if (handler === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId), this._cleanupTimeout(messageId);
    let isTaskResponse = !1;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result == "object") {
      let result = response.result;
      if (result.task && typeof result.task == "object") {
        let task = result.task;
        typeof task.taskId == "string" && (isTaskResponse = !0, this._taskProgressTokens.set(task.taskId, messageId));
      }
    }
    if (isTaskResponse || this._progressHandlers.delete(messageId), isJSONRPCResultResponse(response))
      handler(response);
    else {
      let error2 = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler(error2);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    await this._transport?.close();
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    let { task } = options ?? {};
    if (!task) {
      try {
        yield { type: "result", result: await this.request(request, resultSchema, options) };
      } catch (error2) {
        yield {
          type: "error",
          error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
        };
      }
      return;
    }
    let taskId;
    try {
      let createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task)
        taskId = createResult.task.taskId, yield { type: "taskCreated", task: createResult.task };
      else
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      for (; ; ) {
        let task2 = await this.getTask({ taskId }, options);
        if (yield { type: "taskStatus", task: task2 }, isTerminal(task2.status)) {
          task2.status === "completed" ? yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) } : task2.status === "failed" ? yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
          } : task2.status === "cancelled" && (yield {
            type: "error",
            error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
          });
          return;
        }
        if (task2.status === "input_required") {
          yield { type: "result", result: await this.getTaskResult({ taskId }, resultSchema, options) };
          return;
        }
        let pollInterval = task2.pollInterval ?? this._options?.defaultTaskPollInterval ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval)), options?.signal?.throwIfAborted();
      }
    } catch (error2) {
      yield {
        type: "error",
        error: error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, String(error2))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    let { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      let earlyReject = (error2) => {
        reject(error2);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (this._options?.enforceStrictCapabilities === !0)
        try {
          this.assertCapabilityForMethod(request.method), task && this.assertTaskCapability(request.method);
        } catch (e) {
          earlyReject(e);
          return;
        }
      options?.signal?.throwIfAborted();
      let messageId = this._requestMessageId++, jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      options?.onprogress && (this._progressHandlers.set(messageId, options.onprogress), jsonrpcRequest.params = {
        ...request.params,
        _meta: {
          ...request.params?._meta || {},
          progressToken: messageId
        }
      }), task && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        task
      }), relatedTask && (jsonrpcRequest.params = {
        ...jsonrpcRequest.params,
        _meta: {
          ...jsonrpcRequest.params?._meta || {},
          [RELATED_TASK_META_KEY]: relatedTask
        }
      });
      let cancel = (reason) => {
        this._responseHandlers.delete(messageId), this._progressHandlers.delete(messageId), this._cleanupTimeout(messageId), this._transport?.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error3) => this._onerror(new Error(`Failed to send cancellation: ${error3}`)));
        let error2 = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error2);
      };
      this._responseHandlers.set(messageId, (response) => {
        if (!options?.signal?.aborted) {
          if (response instanceof Error)
            return reject(response);
          try {
            let parseResult = safeParse2(resultSchema, response.result);
            parseResult.success ? resolve(parseResult.data) : reject(parseResult.error);
          } catch (error2) {
            reject(error2);
          }
        }
      }), options?.signal?.addEventListener("abort", () => {
        cancel(options?.signal?.reason);
      });
      let timeout = options?.timeout ?? DEFAULT_REQUEST_TIMEOUT_MSEC, timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options?.maxTotalTimeout, timeoutHandler, options?.resetTimeoutOnProgress ?? !1);
      let relatedTaskId = relatedTask?.taskId;
      if (relatedTaskId) {
        let responseResolver = (response) => {
          let handler = this._responseHandlers.get(messageId);
          handler ? handler(response) : this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
        };
        this._requestResolvers.set(messageId, responseResolver), this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
      } else
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => {
          this._cleanupTimeout(messageId), reject(error2);
        });
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    if (!this._transport)
      throw new Error("Not connected");
    this.assertNotificationCapability(notification.method);
    let relatedTaskId = options?.relatedTask?.taskId;
    if (relatedTaskId) {
      let jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...notification.params?._meta || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    if ((this._options?.debouncedNotificationMethods ?? []).includes(notification.method) && !notification.params && !options?.relatedRequestId && !options?.relatedTask) {
      if (this._pendingDebouncedNotifications.has(notification.method))
        return;
      this._pendingDebouncedNotifications.add(notification.method), Promise.resolve().then(() => {
        if (this._pendingDebouncedNotifications.delete(notification.method), !this._transport)
          return;
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        options?.relatedTask && (jsonrpcNotification2 = {
          ...jsonrpcNotification2,
          params: {
            ...jsonrpcNotification2.params,
            _meta: {
              ...jsonrpcNotification2.params?._meta || {},
              [RELATED_TASK_META_KEY]: options.relatedTask
            }
          }
        }), this._transport?.send(jsonrpcNotification2, options).catch((error2) => this._onerror(error2));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    options?.relatedTask && (jsonrpcNotification = {
      ...jsonrpcNotification,
      params: {
        ...jsonrpcNotification.params,
        _meta: {
          ...jsonrpcNotification.params?._meta || {},
          [RELATED_TASK_META_KEY]: options.relatedTask
        }
      }
    }), await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler) {
    let method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method), this._requestHandlers.set(method, (request, extra) => {
      let parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method))
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler) {
    let method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      let parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    let progressToken = this._taskProgressTokens.get(taskId);
    progressToken !== void 0 && (this._progressHandlers.delete(progressToken), this._taskProgressTokens.delete(taskId));
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    if (!this._taskStore || !this._taskMessageQueue)
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    let maxQueueSize = this._options?.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      let messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (let message of messages)
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          let requestId = message.message.id, resolver = this._requestResolvers.get(requestId);
          resolver ? (resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed")), this._requestResolvers.delete(requestId)) : this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
        }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    let interval = this._options?.defaultTaskPollInterval ?? 1e3;
    try {
      let task = await this._taskStore?.getTask(taskId);
      task?.pollInterval && (interval = task.pollInterval);
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      let timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId), reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: !0 });
    });
  }
  requestTaskStore(request, sessionId) {
    let taskStore = this._taskStore;
    if (!taskStore)
      throw new Error("No task store configured");
    return {
      createTask: async (taskParams) => {
        if (!request)
          throw new Error("No request provided");
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        let task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification), isTerminal(task.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      getTaskResult: (taskId) => taskStore.getTaskResult(taskId, sessionId),
      updateTaskStatus: async (taskId, status, statusMessage) => {
        let task = await taskStore.getTask(taskId, sessionId);
        if (!task)
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        if (isTerminal(task.status))
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        let updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          let notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification), isTerminal(updatedTask.status) && this._cleanupTaskProgressHandler(taskId);
        }
      },
      listTasks: (cursor) => taskStore.listTasks(cursor, sessionId)
    };
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  let result = { ...base };
  for (let key in additional) {
    let k = key, addValue = additional[k];
    if (addValue === void 0)
      continue;
    let baseValue = result[k];
    isPlainObject2(baseValue) && isPlainObject2(addValue) ? result[k] = { ...baseValue, ...addValue } : result[k] = addValue;
  }
  return result;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1), import_ajv_formats = __toESM(require_dist(), 1);
function createDefaultAjvInstance() {
  let ajv = new import_ajv.default({
    strict: !1,
    validateFormats: !0,
    validateSchema: !1,
    allErrors: !0
  });
  return (0, import_ajv_formats.default)(ajv), ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    let ajvValidator = "$id" in schema && typeof schema.$id == "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => ajvValidator(input) ? {
      valid: !0,
      data: input,
      errorMessage: void 0
    } : {
      valid: !1,
      data: void 0,
      errorMessage: this._ajv.errorsText(ajvValidator.errors)
    };
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/server.js
var ExperimentalServerTasks = class {
  constructor(_server) {
    this._server = _server;
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._server.requestStream(request, resultSchema, options);
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._server.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._server.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._server.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._server.cancelTask({ taskId }, options);
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "tools/call":
      if (!requests.tools?.call)
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  if (!requests)
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  switch (method) {
    case "sampling/createMessage":
      if (!requests.sampling?.createMessage)
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      break;
    case "elicitation/create":
      if (!requests.elicitation?.create)
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      break;
    default:
      break;
  }
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/index.js
var Server = class extends Protocol {
  /**
   * Initializes this server with the given name and version information.
   */
  constructor(_serverInfo, options) {
    super(options), this._serverInfo = _serverInfo, this._loggingLevels = /* @__PURE__ */ new Map(), this.LOG_LEVEL_SEVERITY = new Map(LoggingLevelSchema.options.map((level, index) => [level, index])), this.isMessageIgnored = (level, sessionId) => {
      let currentLevel = this._loggingLevels.get(sessionId);
      return currentLevel ? this.LOG_LEVEL_SEVERITY.get(level) < this.LOG_LEVEL_SEVERITY.get(currentLevel) : !1;
    }, this._capabilities = options?.capabilities ?? {}, this._instructions = options?.instructions, this._jsonSchemaValidator = options?.jsonSchemaValidator ?? new AjvJsonSchemaValidator(), this.setRequestHandler(InitializeRequestSchema, (request) => this._oninitialize(request)), this.setNotificationHandler(InitializedNotificationSchema, () => this.oninitialized?.()), this._capabilities.logging && this.setRequestHandler(SetLevelRequestSchema, async (request, extra) => {
      let transportSessionId = extra.sessionId || extra.requestInfo?.headers["mcp-session-id"] || void 0, { level } = request.params, parseResult = LoggingLevelSchema.safeParse(level);
      return parseResult.success && this._loggingLevels.set(transportSessionId, parseResult.data), {};
    });
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    return this._experimental || (this._experimental = {
      tasks: new ExperimentalServerTasks(this)
    }), this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport)
      throw new Error("Cannot register capabilities after connecting to transport");
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce server-side validation for tools/call.
   */
  setRequestHandler(requestSchema, handler) {
    let methodSchema = getObjectShape(requestSchema)?.method;
    if (!methodSchema)
      throw new Error("Schema is missing a method literal");
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      let v4Schema = methodSchema;
      methodValue = v4Schema._zod?.def?.value ?? v4Schema.value;
    } else {
      let v3Schema = methodSchema;
      methodValue = v3Schema._def?.value ?? v3Schema.value;
    }
    if (typeof methodValue != "string")
      throw new Error("Schema method literal must be a string");
    if (methodValue === "tools/call") {
      let wrappedHandler = async (request, extra) => {
        let validatedRequest = safeParse2(CallToolRequestSchema, request);
        if (!validatedRequest.success) {
          let errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call request: ${errorMessage}`);
        }
        let { params } = validatedRequest.data, result = await Promise.resolve(handler(request, extra));
        if (params.task) {
          let taskValidationResult = safeParse2(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            let errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        let validationResult = safeParse2(CallToolResultSchema, result);
        if (!validationResult.success) {
          let errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid tools/call result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler);
  }
  assertCapabilityForMethod(method) {
    switch (method) {
      case "sampling/createMessage":
        if (!this._clientCapabilities?.sampling)
          throw new Error(`Client does not support sampling (required for ${method})`);
        break;
      case "elicitation/create":
        if (!this._clientCapabilities?.elicitation)
          throw new Error(`Client does not support elicitation (required for ${method})`);
        break;
      case "roots/list":
        if (!this._clientCapabilities?.roots)
          throw new Error(`Client does not support listing roots (required for ${method})`);
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    switch (method) {
      case "notifications/message":
        if (!this._capabilities.logging)
          throw new Error(`Server does not support logging (required for ${method})`);
        break;
      case "notifications/resources/updated":
      case "notifications/resources/list_changed":
        if (!this._capabilities.resources)
          throw new Error(`Server does not support notifying about resources (required for ${method})`);
        break;
      case "notifications/tools/list_changed":
        if (!this._capabilities.tools)
          throw new Error(`Server does not support notifying of tool list changes (required for ${method})`);
        break;
      case "notifications/prompts/list_changed":
        if (!this._capabilities.prompts)
          throw new Error(`Server does not support notifying of prompt list changes (required for ${method})`);
        break;
      case "notifications/elicitation/complete":
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error(`Client does not support URL elicitation (required for ${method})`);
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (this._capabilities)
      switch (method) {
        case "completion/complete":
          if (!this._capabilities.completions)
            throw new Error(`Server does not support completions (required for ${method})`);
          break;
        case "logging/setLevel":
          if (!this._capabilities.logging)
            throw new Error(`Server does not support logging (required for ${method})`);
          break;
        case "prompts/get":
        case "prompts/list":
          if (!this._capabilities.prompts)
            throw new Error(`Server does not support prompts (required for ${method})`);
          break;
        case "resources/list":
        case "resources/templates/list":
        case "resources/read":
          if (!this._capabilities.resources)
            throw new Error(`Server does not support resources (required for ${method})`);
          break;
        case "tools/call":
        case "tools/list":
          if (!this._capabilities.tools)
            throw new Error(`Server does not support tools (required for ${method})`);
          break;
        case "tasks/get":
        case "tasks/list":
        case "tasks/result":
        case "tasks/cancel":
          if (!this._capabilities.tasks)
            throw new Error(`Server does not support tasks capability (required for ${method})`);
          break;
        case "ping":
        case "initialize":
          break;
      }
  }
  assertTaskCapability(method) {
    assertClientRequestTaskCapability(this._clientCapabilities?.tasks?.requests, method, "Client");
  }
  assertTaskHandlerCapability(method) {
    this._capabilities && assertToolsCallTaskCapability(this._capabilities.tasks?.requests, method, "Server");
  }
  async _oninitialize(request) {
    let requestedVersion = request.params.protocolVersion;
    return this._clientCapabilities = request.params.capabilities, this._clientVersion = request.params.clientInfo, {
      protocolVersion: SUPPORTED_PROTOCOL_VERSIONS.includes(requestedVersion) ? requestedVersion : LATEST_PROTOCOL_VERSION,
      capabilities: this.getCapabilities(),
      serverInfo: this._serverInfo,
      ...this._instructions && { instructions: this._instructions }
    };
  }
  /**
   * After initialization has completed, this will be populated with the client's reported capabilities.
   */
  getClientCapabilities() {
    return this._clientCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the client's name and version.
   */
  getClientVersion() {
    return this._clientVersion;
  }
  getCapabilities() {
    return this._capabilities;
  }
  async ping() {
    return this.request({ method: "ping" }, EmptyResultSchema);
  }
  // Implementation
  async createMessage(params, options) {
    if ((params.tools || params.toolChoice) && !this._clientCapabilities?.sampling?.tools)
      throw new Error("Client does not support sampling tools capability.");
    if (params.messages.length > 0) {
      let lastMessage = params.messages[params.messages.length - 1], lastContent = Array.isArray(lastMessage.content) ? lastMessage.content : [lastMessage.content], hasToolResults = lastContent.some((c) => c.type === "tool_result"), previousMessage = params.messages.length > 1 ? params.messages[params.messages.length - 2] : void 0, previousContent = previousMessage ? Array.isArray(previousMessage.content) ? previousMessage.content : [previousMessage.content] : [], hasPreviousToolUse = previousContent.some((c) => c.type === "tool_use");
      if (hasToolResults) {
        if (lastContent.some((c) => c.type !== "tool_result"))
          throw new Error("The last message must contain only tool_result content if any is present");
        if (!hasPreviousToolUse)
          throw new Error("tool_result blocks are not matching any tool_use from the previous message");
      }
      if (hasPreviousToolUse) {
        let toolUseIds = new Set(previousContent.filter((c) => c.type === "tool_use").map((c) => c.id)), toolResultIds = new Set(lastContent.filter((c) => c.type === "tool_result").map((c) => c.toolUseId));
        if (toolUseIds.size !== toolResultIds.size || ![...toolUseIds].every((id) => toolResultIds.has(id)))
          throw new Error("ids of tool_result blocks and tool_use blocks from previous message do not match");
      }
    }
    return params.tools ? this.request({ method: "sampling/createMessage", params }, CreateMessageResultWithToolsSchema, options) : this.request({ method: "sampling/createMessage", params }, CreateMessageResultSchema, options);
  }
  /**
   * Creates an elicitation request for the given parameters.
   * For backwards compatibility, `mode` may be omitted for form requests and will default to `'form'`.
   * @param params The parameters for the elicitation request.
   * @param options Optional request options.
   * @returns The result of the elicitation request.
   */
  async elicitInput(params, options) {
    switch (params.mode ?? "form") {
      case "url": {
        if (!this._clientCapabilities?.elicitation?.url)
          throw new Error("Client does not support url elicitation.");
        let urlParams = params;
        return this.request({ method: "elicitation/create", params: urlParams }, ElicitResultSchema, options);
      }
      case "form": {
        if (!this._clientCapabilities?.elicitation?.form)
          throw new Error("Client does not support form elicitation.");
        let formParams = params.mode === "form" ? params : { ...params, mode: "form" }, result = await this.request({ method: "elicitation/create", params: formParams }, ElicitResultSchema, options);
        if (result.action === "accept" && result.content && formParams.requestedSchema)
          try {
            let validationResult = this._jsonSchemaValidator.getValidator(formParams.requestedSchema)(result.content);
            if (!validationResult.valid)
              throw new McpError(ErrorCode.InvalidParams, `Elicitation response content does not match requested schema: ${validationResult.errorMessage}`);
          } catch (error2) {
            throw error2 instanceof McpError ? error2 : new McpError(ErrorCode.InternalError, `Error validating elicitation response: ${error2 instanceof Error ? error2.message : String(error2)}`);
          }
        return result;
      }
    }
  }
  /**
   * Creates a reusable callback that, when invoked, will send a `notifications/elicitation/complete`
   * notification for the specified elicitation ID.
   *
   * @param elicitationId The ID of the elicitation to mark as complete.
   * @param options Optional notification options. Useful when the completion notification should be related to a prior request.
   * @returns A function that emits the completion notification when awaited.
   */
  createElicitationCompletionNotifier(elicitationId, options) {
    if (!this._clientCapabilities?.elicitation?.url)
      throw new Error("Client does not support URL elicitation (required for notifications/elicitation/complete)");
    return () => this.notification({
      method: "notifications/elicitation/complete",
      params: {
        elicitationId
      }
    }, options);
  }
  async listRoots(params, options) {
    return this.request({ method: "roots/list", params }, ListRootsResultSchema, options);
  }
  /**
   * Sends a logging message to the client, if connected.
   * Note: You only need to send the parameters object, not the entire JSON RPC message
   * @see LoggingMessageNotification
   * @param params
   * @param sessionId optional for stateless and backward compatibility
   */
  async sendLoggingMessage(params, sessionId) {
    if (this._capabilities.logging && !this.isMessageIgnored(params.level, sessionId))
      return this.notification({ method: "notifications/message", params });
  }
  async sendResourceUpdated(params) {
    return this.notification({
      method: "notifications/resources/updated",
      params
    });
  }
  async sendResourceListChanged() {
    return this.notification({
      method: "notifications/resources/list_changed"
    });
  }
  async sendToolListChanged() {
    return this.notification({ method: "notifications/tools/list_changed" });
  }
  async sendPromptListChanged() {
    return this.notification({ method: "notifications/prompts/list_changed" });
  }
};

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
import process3 from "node:process";

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/shared/stdio.js
var ReadBuffer = class {
  append(chunk) {
    this._buffer = this._buffer ? Buffer.concat([this._buffer, chunk]) : chunk;
  }
  readMessage() {
    if (!this._buffer)
      return null;
    let index = this._buffer.indexOf(`
`);
    if (index === -1)
      return null;
    let line = this._buffer.toString("utf8", 0, index).replace(/\r$/, "");
    return this._buffer = this._buffer.subarray(index + 1), deserializeMessage(line);
  }
  clear() {
    this._buffer = void 0;
  }
};
function deserializeMessage(line) {
  return JSONRPCMessageSchema.parse(JSON.parse(line));
}
function serializeMessage(message) {
  return JSON.stringify(message) + `
`;
}

// mcp-servers-src/node_modules/@modelcontextprotocol/sdk/dist/esm/server/stdio.js
var StdioServerTransport = class {
  constructor(_stdin = process3.stdin, _stdout = process3.stdout) {
    this._stdin = _stdin, this._stdout = _stdout, this._readBuffer = new ReadBuffer(), this._started = !1, this._ondata = (chunk) => {
      this._readBuffer.append(chunk), this.processReadBuffer();
    }, this._onerror = (error2) => {
      this.onerror?.(error2);
    };
  }
  /**
   * Starts listening for messages on stdin.
   */
  async start() {
    if (this._started)
      throw new Error("StdioServerTransport already started! If using Server class, note that connect() calls start() automatically.");
    this._started = !0, this._stdin.on("data", this._ondata), this._stdin.on("error", this._onerror);
  }
  processReadBuffer() {
    for (; ; )
      try {
        let message = this._readBuffer.readMessage();
        if (message === null)
          break;
        this.onmessage?.(message);
      } catch (error2) {
        this.onerror?.(error2);
      }
  }
  async close() {
    this._stdin.off("data", this._ondata), this._stdin.off("error", this._onerror), this._stdin.listenerCount("data") === 0 && this._stdin.pause(), this._readBuffer.clear(), this.onclose?.();
  }
  send(message) {
    return new Promise((resolve) => {
      let json2 = serializeMessage(message);
      this._stdout.write(json2) ? resolve() : this._stdout.once("drain", resolve);
    });
  }
};

// mcp-servers-src/onlinekommentar/src/client.ts
var DEFAULT_BASE_URL = "https://onlinekommentar.ch/api";
var OnlineKommentarClient = class {
  baseUrl;
  rateLimitMs;
  timeoutMs;
  lastRequestTime = 0;
  legislativeActMapping = {};
  constructor(options = {}) {
    this.baseUrl = options.baseUrl ?? DEFAULT_BASE_URL, this.rateLimitMs = options.rateLimitMs ?? 1e3, this.timeoutMs = options.timeoutMs ?? 3e4;
  }
  /**
   * Rate-limited fetch wrapper
   */
  async rateLimitedFetch(url2, options = {}) {
    let timeSinceLastRequest = Date.now() - this.lastRequestTime;
    if (timeSinceLastRequest < this.rateLimitMs) {
      let waitTime = this.rateLimitMs - timeSinceLastRequest;
      await new Promise((resolve) => setTimeout(resolve, waitTime));
    }
    this.lastRequestTime = Date.now();
    let controller = new AbortController(), timeoutId = setTimeout(() => controller.abort(), this.timeoutMs);
    try {
      let response = await fetch(url2, {
        ...options,
        signal: controller.signal,
        headers: {
          Accept: "application/json",
          "Content-Type": "application/json",
          ...options.headers
        }
      });
      if (clearTimeout(timeoutId), !response.ok)
        throw new Error(`API error: ${response.status} ${response.statusText}`);
      return response;
    } catch (error2) {
      if (clearTimeout(timeoutId), error2 instanceof Error) {
        if (error2.name === "AbortError")
          throw new Error("Request timeout");
        if (error2.message.includes("fetch") || error2.message.includes("network"))
          throw new Error("Network request failed");
      }
      throw error2;
    }
  }
  /**
   * Build URL with query parameters
   */
  buildUrl(endpoint, params = {}) {
    let url2 = new URL(`${this.baseUrl}${endpoint}`);
    for (let [key, value] of Object.entries(params))
      value !== void 0 && value !== "" && url2.searchParams.append(key, String(value));
    return url2.toString();
  }
  /**
   * Search commentaries with filtering and pagination
   *
   * @param query - Search query string
   * @param options - Search options (language, legislative_act, sort, page)
   * @returns SearchResult with matching commentaries
   */
  async searchCommentaries(query, options = {}) {
    let { language, legislative_act, sort, page } = options, url2 = this.buildUrl("/commentaries", {
      search: query || void 0,
      language,
      legislative_act,
      sort,
      page
    }), data = await (await this.rateLimitedFetch(url2)).json();
    if (!data.success && data.error)
      throw new Error(data.error);
    return data.data ? data.data : data;
  }
  /**
   * Get detailed commentary by ID
   *
   * @param id - Commentary UUID
   * @returns CommentaryDetail with full content
   */
  async getCommentary(id) {
    if (!id || !/^[a-zA-Z0-9-]+$/.test(id))
      throw new Error("Invalid commentary ID");
    let url2 = this.buildUrl(`/commentaries/${encodeURIComponent(id)}`), data = await (await this.rateLimitedFetch(url2)).json();
    if (!data.success && data.error)
      throw data.error.includes("not found") || data.error.includes("404") ? new Error("Commentary not found") : new Error(data.error);
    return data.data ? data.data : data;
  }
  /**
   * List all available legislative acts
   *
   * @param language - Optional language filter
   * @returns Array of LegislativeAct
   */
  async listLegislativeActs(language) {
    let url2 = this.buildUrl("/legislative-acts", { language }), data = await (await this.rateLimitedFetch(url2)).json();
    if (!data.success && data.error)
      throw new Error(data.error);
    let acts = data.data ?? data;
    for (let act of acts)
      act.abbreviation && (this.legislativeActMapping[act.abbreviation.toLowerCase()] = act.id), act.abbreviation_de && (this.legislativeActMapping[act.abbreviation_de.toLowerCase()] = act.id), act.abbreviation_fr && (this.legislativeActMapping[act.abbreviation_fr.toLowerCase()] = act.id), act.abbreviation_it && (this.legislativeActMapping[act.abbreviation_it.toLowerCase()] = act.id);
    return acts;
  }
  /**
   * Get commentary for a specific article reference
   *
   * KEY FEATURE: Maps "Art. 97 OR" to commentary search
   *
   * @param articleReference - Article reference (e.g., "Art. 97 OR", "art. 97 CO")
   * @param language - Optional language preference
   * @returns SearchResult with matching commentaries
   */
  async getCommentaryForArticle(articleReference, language) {
    let parsed = this.parseArticleReference(articleReference);
    if (!parsed)
      throw new Error(
        `Invalid article reference format: ${articleReference}. Expected format like "Art. 97 OR" or "art. 97 al. 2 CO"`
      );
    let legislativeActId = this.legislativeActMapping[parsed.act.toLowerCase()];
    if (legislativeActId || (await this.listLegislativeActs(), legislativeActId = this.legislativeActMapping[parsed.act.toLowerCase()]), !legislativeActId)
      throw new Error(`Unknown legislative act: ${parsed.act}`);
    let searchQuery = `${parsed.article}${parsed.paragraph ? ` ${parsed.paragraph}` : ""}`;
    return this.searchCommentaries(searchQuery, {
      language,
      legislative_act: legislativeActId
    });
  }
  /**
   * Parse article reference into components
   *
   * Handles multiple formats:
   * - German: "Art. 97 Abs. 1 lit. a OR"
   * - French: "art. 97 al. 2 let. a CO"
   * - Italian: "art. 97 cpv. 1 lett. a CO"
   */
  parseArticleReference(reference) {
    let normalized = reference.trim(), patterns = [
      // Full pattern with paragraph and letter
      /^art\.?\s*(\d+(?:bis|ter|quater)?)\s*(?:abs\.?|al\.?|cpv\.?)\s*(\d+)\s*(?:lit\.?|let\.?|lett\.?)\s*([a-z])\s+(\w+)$/i,
      // Pattern with paragraph only
      /^art\.?\s*(\d+(?:bis|ter|quater)?)\s*(?:abs\.?|al\.?|cpv\.?)\s*(\d+)\s+(\w+)$/i,
      // Simple pattern: Art. X STATUTE
      /^art\.?\s*(\d+(?:bis|ter|quater)?)\s+(\w+)$/i
    ];
    for (let pattern of patterns) {
      let match = normalized.match(pattern);
      if (match) {
        if (match.length === 5)
          return {
            article: `Art. ${match[1]}`,
            paragraph: `Abs. ${match[2]} lit. ${match[3]}`,
            act: match[4]
          };
        if (match.length === 4)
          return {
            article: `Art. ${match[1]}`,
            paragraph: `Abs. ${match[2]}`,
            act: match[3]
          };
        if (match.length === 3)
          return {
            article: `Art. ${match[1]}`,
            act: match[2]
          };
      }
    }
    return null;
  }
  /**
   * Get the legislative act mapping (abbreviation -> UUID)
   */
  getLegislativeActMapping() {
    return { ...this.legislativeActMapping };
  }
  /**
   * Manually set legislative act mapping (useful for testing)
   */
  setLegislativeActMapping(mapping) {
    this.legislativeActMapping = { ...mapping };
  }
};

// mcp-servers-src/onlinekommentar/src/index.ts
var server = new Server(
  {
    name: "onlinekommentar",
    version: "2.2.0"
  },
  {
    capabilities: {
      tools: {}
    }
  }
), client = new OnlineKommentarClient();
server.setRequestHandler(ListToolsRequestSchema, async () => ({
  tools: [
    {
      name: "search_commentaries",
      description: `Search Swiss legal commentaries on OnlineKommentar.ch.

Supports filtering by:
- Language (de, fr, it, en)
- Legislative act (UUID from list_legislative_acts)
- Sorting (title, -title, date, -date)
- Pagination

Example queries:
- "Art. 97 OR" - Find commentaries on contractual liability
- "Vertragshaftung" - Search for contract liability commentaries
- "responsabilit\xE9 contractuelle" - French search`,
      inputSchema: {
        type: "object",
        properties: {
          query: {
            type: "string",
            description: "Search query string (article reference, legal term, etc.)"
          },
          language: {
            type: "string",
            enum: ["de", "fr", "it", "en"],
            description: "Filter by language (de=German, fr=French, it=Italian, en=English)"
          },
          legislative_act: {
            type: "string",
            description: "Filter by legislative act UUID (get UUIDs from list_legislative_acts)"
          },
          sort: {
            type: "string",
            enum: ["title", "-title", "date", "-date"],
            description: "Sort order: title (A-Z), -title (Z-A), date (oldest), -date (newest)"
          },
          page: {
            type: "number",
            description: "Page number for pagination (default: 1)"
          }
        },
        required: []
      }
    },
    {
      name: "get_commentary",
      description: `Get detailed commentary content by ID.

Returns:
- Full commentary text and sections
- Authors and metadata
- Citations (BGE, ATF, DTF references)
- Related commentaries
- Direct URL to source

Use after search_commentaries to get full content.`,
      inputSchema: {
        type: "object",
        properties: {
          id: {
            type: "string",
            description: "Commentary UUID (from search_commentaries results)"
          }
        },
        required: ["id"]
      }
    },
    {
      name: "get_commentary_for_article",
      description: `KEY FEATURE: Find commentaries for a specific Swiss law article reference.

Automatically parses article references in multiple formats:
- German: "Art. 97 OR", "Art. 97 Abs. 1 OR", "Art. 97 Abs. 1 lit. a OR"
- French: "art. 97 CO", "art. 97 al. 2 CO", "art. 97 al. 2 let. a CO"
- Italian: "art. 97 CO", "art. 97 cpv. 1 CO", "art. 97 cpv. 1 lett. a CO"

Resolves abbreviations across languages:
- OR/CO \u2192 Obligationenrecht / Code des obligations
- ZGB/CC \u2192 Zivilgesetzbuch / Code civil
- StGB/CP \u2192 Strafgesetzbuch / Code p\xE9nal

Example: "Art. 97 OR" \u2192 Finds all commentaries on OR Article 97`,
      inputSchema: {
        type: "object",
        properties: {
          article_reference: {
            type: "string",
            description: 'Article reference (e.g., "Art. 97 OR", "art. 97 al. 2 CO")'
          },
          language: {
            type: "string",
            enum: ["de", "fr", "it", "en"],
            description: "Preferred language for results"
          }
        },
        required: ["article_reference"]
      }
    },
    {
      name: "list_legislative_acts",
      description: `List all available Swiss legislative acts (codes/statutes).

Returns:
- Legislative act UUIDs (for filtering searches)
- Names and abbreviations in all languages
- DE: OR, ZGB, StGB, ZPO, StPO, BV, DSG, UWG...
- FR: CO, CC, CP, CPC, CPP...
- IT: CO, CC, CP, CPC, CPP...

Use this to get UUIDs for filtering search_commentaries by legislative act.`,
      inputSchema: {
        type: "object",
        properties: {
          language: {
            type: "string",
            enum: ["de", "fr", "it", "en"],
            description: "Filter by language (optional)"
          }
        },
        required: []
      }
    }
  ]
}));
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  let { name, arguments: args } = request.params;
  try {
    switch (name) {
      case "search_commentaries": {
        let query = args?.query || "", options = {
          language: args?.language,
          legislative_act: args?.legislative_act,
          sort: args?.sort,
          page: args?.page
        }, result = await client.searchCommentaries(query, options);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  success: !0,
                  count: result.count,
                  page: result.page,
                  total_pages: result.total_pages,
                  commentaries: result.commentaries.map((c) => ({
                    id: c.id,
                    title: c.title,
                    authors: c.authors,
                    legislative_act: c.legislative_act.abbreviation,
                    language: c.language,
                    updated: c.updated,
                    url: c.url
                  }))
                },
                null,
                2
              )
            }
          ]
        };
      }
      case "get_commentary": {
        let id = args?.id;
        if (!id)
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({ success: !1, error: "Commentary ID is required" })
              }
            ],
            isError: !0
          };
        let result = await client.getCommentary(id);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  success: !0,
                  commentary: {
                    id: result.id,
                    title: result.title,
                    authors: result.authors,
                    legislative_act: result.legislative_act,
                    language: result.language,
                    updated: result.updated,
                    url: result.url,
                    abstract: result.abstract,
                    content: result.content,
                    sections: result.sections,
                    citations: result.citations,
                    related_commentaries: result.related_commentaries
                  }
                },
                null,
                2
              )
            }
          ]
        };
      }
      case "get_commentary_for_article": {
        let articleReference = args?.article_reference, language = args?.language;
        if (!articleReference)
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: !1,
                  error: 'Article reference is required (e.g., "Art. 97 OR")'
                })
              }
            ],
            isError: !0
          };
        let result = await client.getCommentaryForArticle(articleReference, language);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  success: !0,
                  article_reference: articleReference,
                  count: result.count,
                  page: result.page,
                  total_pages: result.total_pages,
                  commentaries: result.commentaries.map((c) => ({
                    id: c.id,
                    title: c.title,
                    authors: c.authors,
                    legislative_act: c.legislative_act.abbreviation,
                    language: c.language,
                    updated: c.updated,
                    url: c.url
                  }))
                },
                null,
                2
              )
            }
          ]
        };
      }
      case "list_legislative_acts": {
        let language = args?.language, result = await client.listLegislativeActs(language);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(
                {
                  success: !0,
                  count: result.length,
                  legislative_acts: result.map((act) => ({
                    id: act.id,
                    name: act.name,
                    abbreviation: act.abbreviation,
                    abbreviation_de: act.abbreviation_de,
                    abbreviation_fr: act.abbreviation_fr,
                    abbreviation_it: act.abbreviation_it,
                    language: act.language
                  })),
                  mapping: client.getLegislativeActMapping()
                },
                null,
                2
              )
            }
          ]
        };
      }
      default:
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: !1,
                error: `Unknown tool: ${name}`
              })
            }
          ],
          isError: !0
        };
    }
  } catch (error2) {
    let errorMessage = error2 instanceof Error ? error2.message : "Unknown error occurred";
    return {
      content: [
        {
          type: "text",
          text: JSON.stringify({
            success: !1,
            error: errorMessage
          })
        }
      ],
      isError: !0
    };
  }
});
async function main() {
  let transport = new StdioServerTransport();
  await server.connect(transport), console.error("OnlineKommentar MCP Server v2.2.0 running on stdio");
}
main().catch((error2) => {
  console.error("Fatal error:", error2), process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2NvZGVnZW4vc2NvcGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvY29kZWdlbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS91dGlsLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL25hbWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL2Vycm9ycy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9ib29sU2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3J1bGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2FwcGxpY2FiaWxpdHkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGF0YVR5cGUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvZGVmYXVsdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb2RlLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3ZhbGlkYXRlL2tleXdvcmQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvdmFsaWRhdGUvc3Vic2NoZW1hLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC1kZWVwLWVxdWFsL2luZGV4LmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvanNvbi1zY2hlbWEtdHJhdmVyc2UvaW5kZXguanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvbXBpbGUvcmVzb2x2ZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS92YWxpZGF0ZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS92YWxpZGF0aW9uX2Vycm9yLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi9jb21waWxlL3JlZl9lcnJvci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvY29tcGlsZS9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvZGF0YS5qc29uIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3V0aWxzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvZmFzdC11cmkvbGliL3NjaGVtZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9mYXN0LXVyaS9pbmRleC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91cmkudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL2NvcmUudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2lkLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvY29yZS9yZWYudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9jb3JlL2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdE51bWJlci50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbXVsdGlwbGVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS91Y3MybGVuZ3RoLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9saW1pdExlbmd0aC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vcGF0dGVybi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRQcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9yZXF1aXJlZC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vbGltaXRJdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvcnVudGltZS9lcXVhbC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL3ZhbGlkYXRpb24vdW5pcXVlSXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy92YWxpZGF0aW9uL2NvbnN0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9lbnVtLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvdmFsaWRhdGlvbi9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbEl0ZW1zLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9pdGVtcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJlZml4SXRlbXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2l0ZW1zMjAyMC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvY29udGFpbnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2RlcGVuZGVuY2llcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvcHJvcGVydHlOYW1lcy50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWRkaXRpb25hbFByb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3Byb3BlcnRpZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL3BhdHRlcm5Qcm9wZXJ0aWVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9ub3QudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2FueU9mLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci9vbmVPZi50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvYWxsT2YudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9hcHBsaWNhdG9yL2lmLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvYXBwbGljYXRvci90aGVuRWxzZS50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvdm9jYWJ1bGFyaWVzL2FwcGxpY2F0b3IvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9mb3JtYXQvZm9ybWF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZm9ybWF0L2luZGV4LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvbWV0YWRhdGEudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kcmFmdDcudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYvbGliL3ZvY2FidWxhcmllcy9kaXNjcmltaW5hdG9yL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2L2xpYi92b2NhYnVsYXJpZXMvZGlzY3JpbWluYXRvci9pbmRleC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9kaXN0L3JlZnMvanNvbi1zY2hlbWEtZHJhZnQtMDcuanNvbiIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL2Fqdi9saWIvYWp2LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvYWp2LWZvcm1hdHMvc3JjL2Zvcm1hdHMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvbGltaXQudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9hanYtZm9ybWF0cy9zcmMvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvaGVscGVycy91dGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL1pvZEVycm9yLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2xvY2FsZXMvZW4uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjMvZXJyb3JzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvcGFyc2VVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL2hlbHBlcnMvZXJyb3JVdGlsLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3YzL3R5cGVzLmpzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY29yZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3V0aWwuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2V4ZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9kb2MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS92ZXJzaW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvbG9jYWxlcy9lbi5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2lzdHJpZXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9hcGkuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS90by1qc29uLXNjaGVtYS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2pzb24tc2NoZW1hLXByb2Nlc3NvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvem9kLWNvbXBhdC50cyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL3NjaGVtYXMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9jaGVja3MuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9pc28uanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9lcnJvcnMuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9wYXJzZS5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2NvbXBhdC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC92NC9jbGFzc2ljL2Zyb20tanNvbi1zY2hlbWEuanMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9leHRlcm5hbC5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3R5cGVzLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2ludGVyZmFjZXMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy96b2QtdG8tanNvbi1zY2hlbWEvZGlzdC9lc20vT3B0aW9ucy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL3pvZC10by1qc29uLXNjaGVtYS9kaXN0L2VzbS9wYXJzZXJzL3N0cmluZy5qcyIsICIuLi8uLi8uLi9tY3Atc2VydmVycy1zcmMvbm9kZV9tb2R1bGVzL0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc3JjL3NlcnZlci96b2QtanNvbi1zY2hlbWEtY29tcGF0LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvc2hhcmVkL3Byb3RvY29sLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvdmFsaWRhdGlvbi9hanYtcHJvdmlkZXIudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9leHBlcmltZW50YWwvdGFza3Mvc2VydmVyLnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9ub2RlX21vZHVsZXMvQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay9zcmMvZXhwZXJpbWVudGFsL3Rhc2tzL2hlbHBlcnMudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvaW5kZXgudHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zZXJ2ZXIvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL25vZGVfbW9kdWxlcy9AbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NyYy9zaGFyZWQvc3RkaW8udHMiLCAiLi4vLi4vLi4vbWNwLXNlcnZlcnMtc3JjL29ubGluZWtvbW1lbnRhci9zcmMvY2xpZW50LnRzIiwgIi4uLy4uLy4uL21jcC1zZXJ2ZXJzLXNyYy9vbmxpbmVrb21tZW50YXIvc3JjL2luZGV4LnRzIl0sCiAgInNvdXJjZXNDb250ZW50IjogWyIvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4dHJhbmVvdXMtY2xhc3NcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBfQ29kZU9yTmFtZSB7XG4gIGFic3RyYWN0IHJlYWRvbmx5IHN0cjogc3RyaW5nXG4gIGFic3RyYWN0IHJlYWRvbmx5IG5hbWVzOiBVc2VkTmFtZXNcbiAgYWJzdHJhY3QgdG9TdHJpbmcoKTogc3RyaW5nXG4gIGFic3RyYWN0IGVtcHR5U3RyKCk6IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNvbnN0IElERU5USUZJRVIgPSAvXlthLXokX11bYS16JF8wLTldKiQvaVxuXG5leHBvcnQgY2xhc3MgTmFtZSBleHRlbmRzIF9Db2RlT3JOYW1lIHtcbiAgcmVhZG9ubHkgc3RyOiBzdHJpbmdcbiAgY29uc3RydWN0b3Ioczogc3RyaW5nKSB7XG4gICAgc3VwZXIoKVxuICAgIGlmICghSURFTlRJRklFUi50ZXN0KHMpKSB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiBuYW1lIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXCIpXG4gICAgdGhpcy5zdHIgPSBzXG4gIH1cblxuICB0b1N0cmluZygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLnN0clxuICB9XG5cbiAgZW1wdHlTdHIoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4ge1t0aGlzLnN0cl06IDF9XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIF9Db2RlIGV4dGVuZHMgX0NvZGVPck5hbWUge1xuICByZWFkb25seSBfaXRlbXM6IHJlYWRvbmx5IENvZGVJdGVtW11cbiAgcHJpdmF0ZSBfc3RyPzogc3RyaW5nXG4gIHByaXZhdGUgX25hbWVzPzogVXNlZE5hbWVzXG5cbiAgY29uc3RydWN0b3IoY29kZTogc3RyaW5nIHwgcmVhZG9ubHkgQ29kZUl0ZW1bXSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pdGVtcyA9IHR5cGVvZiBjb2RlID09PSBcInN0cmluZ1wiID8gW2NvZGVdIDogY29kZVxuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5zdHJcbiAgfVxuXG4gIGVtcHR5U3RyKCk6IGJvb2xlYW4ge1xuICAgIGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbXNbMF1cbiAgICByZXR1cm4gaXRlbSA9PT0gXCJcIiB8fCBpdGVtID09PSAnXCJcIidcbiAgfVxuXG4gIGdldCBzdHIoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gKHRoaXMuX3N0ciA/Pz0gdGhpcy5faXRlbXMucmVkdWNlKChzOiBzdHJpbmcsIGM6IENvZGVJdGVtKSA9PiBgJHtzfSR7Y31gLCBcIlwiKSlcbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiAodGhpcy5fbmFtZXMgPz89IHRoaXMuX2l0ZW1zLnJlZHVjZSgobmFtZXM6IFVzZWROYW1lcywgYykgPT4ge1xuICAgICAgaWYgKGMgaW5zdGFuY2VvZiBOYW1lKSBuYW1lc1tjLnN0cl0gPSAobmFtZXNbYy5zdHJdIHx8IDApICsgMVxuICAgICAgcmV0dXJuIG5hbWVzXG4gICAgfSwge30pKVxuICB9XG59XG5cbmV4cG9ydCB0eXBlIENvZGVJdGVtID0gTmFtZSB8IHN0cmluZyB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsXG5cbmV4cG9ydCB0eXBlIFVzZWROYW1lcyA9IFJlY29yZDxzdHJpbmcsIG51bWJlciB8IHVuZGVmaW5lZD5cblxuZXhwb3J0IHR5cGUgQ29kZSA9IF9Db2RlIHwgTmFtZVxuXG5leHBvcnQgdHlwZSBTYWZlRXhwciA9IENvZGUgfCBudW1iZXIgfCBib29sZWFuIHwgbnVsbFxuXG5leHBvcnQgY29uc3QgbmlsID0gbmV3IF9Db2RlKFwiXCIpXG5cbnR5cGUgQ29kZUFyZyA9IFNhZmVFeHByIHwgc3RyaW5nIHwgdW5kZWZpbmVkXG5cbmV4cG9ydCBmdW5jdGlvbiBfKHN0cnM6IFRlbXBsYXRlU3RyaW5nc0FycmF5LCAuLi5hcmdzOiBDb2RlQXJnW10pOiBfQ29kZSB7XG4gIGNvbnN0IGNvZGU6IENvZGVJdGVtW10gPSBbc3Ryc1swXV1cbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICBhZGRDb2RlQXJnKGNvZGUsIGFyZ3NbaV0pXG4gICAgY29kZS5wdXNoKHN0cnNbKytpXSlcbiAgfVxuICByZXR1cm4gbmV3IF9Db2RlKGNvZGUpXG59XG5cbmNvbnN0IHBsdXMgPSBuZXcgX0NvZGUoXCIrXCIpXG5cbmV4cG9ydCBmdW5jdGlvbiBzdHIoc3RyczogVGVtcGxhdGVTdHJpbmdzQXJyYXksIC4uLmFyZ3M6IChDb2RlQXJnIHwgc3RyaW5nW10pW10pOiBfQ29kZSB7XG4gIGNvbnN0IGV4cHI6IENvZGVJdGVtW10gPSBbc2FmZVN0cmluZ2lmeShzdHJzWzBdKV1cbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICBleHByLnB1c2gocGx1cylcbiAgICBhZGRDb2RlQXJnKGV4cHIsIGFyZ3NbaV0pXG4gICAgZXhwci5wdXNoKHBsdXMsIHNhZmVTdHJpbmdpZnkoc3Ryc1srK2ldKSlcbiAgfVxuICBvcHRpbWl6ZShleHByKVxuICByZXR1cm4gbmV3IF9Db2RlKGV4cHIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRDb2RlQXJnKGNvZGU6IENvZGVJdGVtW10sIGFyZzogQ29kZUFyZyB8IHN0cmluZ1tdKTogdm9pZCB7XG4gIGlmIChhcmcgaW5zdGFuY2VvZiBfQ29kZSkgY29kZS5wdXNoKC4uLmFyZy5faXRlbXMpXG4gIGVsc2UgaWYgKGFyZyBpbnN0YW5jZW9mIE5hbWUpIGNvZGUucHVzaChhcmcpXG4gIGVsc2UgY29kZS5wdXNoKGludGVycG9sYXRlKGFyZykpXG59XG5cbmZ1bmN0aW9uIG9wdGltaXplKGV4cHI6IENvZGVJdGVtW10pOiB2b2lkIHtcbiAgbGV0IGkgPSAxXG4gIHdoaWxlIChpIDwgZXhwci5sZW5ndGggLSAxKSB7XG4gICAgaWYgKGV4cHJbaV0gPT09IHBsdXMpIHtcbiAgICAgIGNvbnN0IHJlcyA9IG1lcmdlRXhwckl0ZW1zKGV4cHJbaSAtIDFdLCBleHByW2kgKyAxXSlcbiAgICAgIGlmIChyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHByLnNwbGljZShpIC0gMSwgMywgcmVzKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgZXhwcltpKytdID0gXCIrXCJcbiAgICB9XG4gICAgaSsrXG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VFeHBySXRlbXMoYTogQ29kZUl0ZW0sIGI6IENvZGVJdGVtKTogQ29kZUl0ZW0gfCB1bmRlZmluZWQge1xuICBpZiAoYiA9PT0gJ1wiXCInKSByZXR1cm4gYVxuICBpZiAoYSA9PT0gJ1wiXCInKSByZXR1cm4gYlxuICBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIikge1xuICAgIGlmIChiIGluc3RhbmNlb2YgTmFtZSB8fCBhW2EubGVuZ3RoIC0gMV0gIT09ICdcIicpIHJldHVyblxuICAgIGlmICh0eXBlb2YgYiAhPSBcInN0cmluZ1wiKSByZXR1cm4gYCR7YS5zbGljZSgwLCAtMSl9JHtifVwiYFxuICAgIGlmIChiWzBdID09PSAnXCInKSByZXR1cm4gYS5zbGljZSgwLCAtMSkgKyBiLnNsaWNlKDEpXG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKHR5cGVvZiBiID09IFwic3RyaW5nXCIgJiYgYlswXSA9PT0gJ1wiJyAmJiAhKGEgaW5zdGFuY2VvZiBOYW1lKSkgcmV0dXJuIGBcIiR7YX0ke2Iuc2xpY2UoMSl9YFxuICByZXR1cm5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0ckNvbmNhdChjMTogQ29kZSwgYzI6IENvZGUpOiBDb2RlIHtcbiAgcmV0dXJuIGMyLmVtcHR5U3RyKCkgPyBjMSA6IGMxLmVtcHR5U3RyKCkgPyBjMiA6IHN0cmAke2MxfSR7YzJ9YFxufVxuXG4vLyBUT0RPIGRvIG5vdCBhbGxvdyBhcnJheXMgaGVyZVxuZnVuY3Rpb24gaW50ZXJwb2xhdGUoeD86IHN0cmluZyB8IHN0cmluZ1tdIHwgbnVtYmVyIHwgYm9vbGVhbiB8IG51bGwpOiBTYWZlRXhwciB8IHN0cmluZyB7XG4gIHJldHVybiB0eXBlb2YgeCA9PSBcIm51bWJlclwiIHx8IHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHggPT09IG51bGxcbiAgICA/IHhcbiAgICA6IHNhZmVTdHJpbmdpZnkoQXJyYXkuaXNBcnJheSh4KSA/IHguam9pbihcIixcIikgOiB4KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5KHg6IHVua25vd24pOiBDb2RlIHtcbiAgcmV0dXJuIG5ldyBfQ29kZShzYWZlU3RyaW5naWZ5KHgpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FmZVN0cmluZ2lmeSh4OiB1bmtub3duKTogc3RyaW5nIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHgpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UHJvcGVydHkoa2V5OiBDb2RlIHwgc3RyaW5nIHwgbnVtYmVyKTogQ29kZSB7XG4gIHJldHVybiB0eXBlb2Yga2V5ID09IFwic3RyaW5nXCIgJiYgSURFTlRJRklFUi50ZXN0KGtleSkgPyBuZXcgX0NvZGUoYC4ke2tleX1gKSA6IF9gWyR7a2V5fV1gXG59XG5cbi8vRG9lcyBiZXN0IGVmZm9ydCB0byBmb3JtYXQgdGhlIG5hbWUgcHJvcGVybHlcbmV4cG9ydCBmdW5jdGlvbiBnZXRFc21FeHBvcnROYW1lKGtleTogQ29kZSB8IHN0cmluZyB8IG51bWJlcik6IENvZGUge1xuICBpZiAodHlwZW9mIGtleSA9PSBcInN0cmluZ1wiICYmIElERU5USUZJRVIudGVzdChrZXkpKSB7XG4gICAgcmV0dXJuIG5ldyBfQ29kZShgJHtrZXl9YClcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IGludmFsaWQgZXhwb3J0IG5hbWU6ICR7a2V5fSwgdXNlIGV4cGxpY2l0ICRpZCBuYW1lIG1hcHBpbmdgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVnZXhwQ29kZShyeDogUmVnRXhwKTogQ29kZSB7XG4gIHJldHVybiBuZXcgX0NvZGUocngudG9TdHJpbmcoKSlcbn1cbiIsICJpbXBvcnQge18sIG5pbCwgQ29kZSwgTmFtZX0gZnJvbSBcIi4vY29kZVwiXG5cbmludGVyZmFjZSBOYW1lR3JvdXAge1xuICBwcmVmaXg6IHN0cmluZ1xuICBpbmRleDogbnVtYmVyXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTmFtZVZhbHVlIHtcbiAgcmVmOiBWYWx1ZVJlZmVyZW5jZSAvLyB0aGlzIGlzIHRoZSByZWZlcmVuY2UgdG8gYW55IHZhbHVlIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGZyb20gZ2VuZXJhdGVkIGNvZGUgdmlhIGBnbG9iYWxzYCB2YXIgaW4gdGhlIGNsb3N1cmVcbiAga2V5PzogdW5rbm93biAvLyBhbnkga2V5IHRvIGlkZW50aWZ5IGEgZ2xvYmFsIHRvIGF2b2lkIGR1cGxpY2F0ZXMsIGlmIG5vdCBwYXNzZWQgcmVmIGlzIHVzZWRcbiAgY29kZT86IENvZGUgLy8gdGhpcyBpcyB0aGUgY29kZSBjcmVhdGluZyB0aGUgdmFsdWUgbmVlZGVkIGZvciBzdGFuZGFsb25lIGNvZGUgd2l0X291dCBjbG9zdXJlIC0gY2FuIGJlIGEgcHJpbWl0aXZlIHZhbHVlLCBmdW5jdGlvbiBvciBpbXBvcnQgKGByZXF1aXJlYClcbn1cblxuZXhwb3J0IHR5cGUgVmFsdWVSZWZlcmVuY2UgPSB1bmtub3duIC8vIHBvc3NpYmx5IG1ha2UgQ29kZUdlbiBwYXJhbWV0ZXJpemVkIHR5cGUgb24gdGhpcyB0eXBlXG5cbmNsYXNzIFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHJlYWRvbmx5IHZhbHVlPzogTmFtZVZhbHVlXG4gIGNvbnN0cnVjdG9yKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSB7XG4gICAgc3VwZXIoYENvZGVHZW46IFwiY29kZVwiIGZvciAke25hbWV9IG5vdCBkZWZpbmVkYClcbiAgICB0aGlzLnZhbHVlID0gbmFtZS52YWx1ZVxuICB9XG59XG5cbmludGVyZmFjZSBTY29wZU9wdGlvbnMge1xuICBwcmVmaXhlcz86IFNldDxzdHJpbmc+XG4gIHBhcmVudD86IFNjb3BlXG59XG5cbmludGVyZmFjZSBWYWx1ZVNjb3BlT3B0aW9ucyBleHRlbmRzIFNjb3BlT3B0aW9ucyB7XG4gIHNjb3BlOiBTY29wZVN0b3JlXG4gIGVzNT86IGJvb2xlYW5cbiAgbGluZXM/OiBib29sZWFuXG59XG5cbmV4cG9ydCB0eXBlIFNjb3BlU3RvcmUgPSBSZWNvcmQ8c3RyaW5nLCBWYWx1ZVJlZmVyZW5jZVtdIHwgdW5kZWZpbmVkPlxuXG50eXBlIFNjb3BlVmFsdWVzID0ge1xuICBbUHJlZml4IGluIHN0cmluZ10/OiBNYXA8dW5rbm93biwgVmFsdWVTY29wZU5hbWU+XG59XG5cbmV4cG9ydCB0eXBlIFNjb3BlVmFsdWVTZXRzID0ge1xuICBbUHJlZml4IGluIHN0cmluZ10/OiBTZXQ8VmFsdWVTY29wZU5hbWU+XG59XG5cbmV4cG9ydCBlbnVtIFVzZWRWYWx1ZVN0YXRlIHtcbiAgU3RhcnRlZCxcbiAgQ29tcGxldGVkLFxufVxuXG5leHBvcnQgdHlwZSBVc2VkU2NvcGVWYWx1ZXMgPSB7XG4gIFtQcmVmaXggaW4gc3RyaW5nXT86IE1hcDxWYWx1ZVNjb3BlTmFtZSwgVXNlZFZhbHVlU3RhdGUgfCB1bmRlZmluZWQ+XG59XG5cbmV4cG9ydCBjb25zdCB2YXJLaW5kcyA9IHtcbiAgY29uc3Q6IG5ldyBOYW1lKFwiY29uc3RcIiksXG4gIGxldDogbmV3IE5hbWUoXCJsZXRcIiksXG4gIHZhcjogbmV3IE5hbWUoXCJ2YXJcIiksXG59XG5cbmV4cG9ydCBjbGFzcyBTY29wZSB7XG4gIHByb3RlY3RlZCByZWFkb25seSBfbmFtZXM6IHtbUHJlZml4IGluIHN0cmluZ10/OiBOYW1lR3JvdXB9ID0ge31cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9wcmVmaXhlcz86IFNldDxzdHJpbmc+XG4gIHByb3RlY3RlZCByZWFkb25seSBfcGFyZW50PzogU2NvcGVcblxuICBjb25zdHJ1Y3Rvcih7cHJlZml4ZXMsIHBhcmVudH06IFNjb3BlT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5fcHJlZml4ZXMgPSBwcmVmaXhlc1xuICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudFxuICB9XG5cbiAgdG9OYW1lKG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyk6IE5hbWUge1xuICAgIHJldHVybiBuYW1lT3JQcmVmaXggaW5zdGFuY2VvZiBOYW1lID8gbmFtZU9yUHJlZml4IDogdGhpcy5uYW1lKG5hbWVPclByZWZpeClcbiAgfVxuXG4gIG5hbWUocHJlZml4OiBzdHJpbmcpOiBOYW1lIHtcbiAgICByZXR1cm4gbmV3IE5hbWUodGhpcy5fbmV3TmFtZShwcmVmaXgpKVxuICB9XG5cbiAgcHJvdGVjdGVkIF9uZXdOYW1lKHByZWZpeDogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBuZyA9IHRoaXMuX25hbWVzW3ByZWZpeF0gfHwgdGhpcy5fbmFtZUdyb3VwKHByZWZpeClcbiAgICByZXR1cm4gYCR7cHJlZml4fSR7bmcuaW5kZXgrK31gXG4gIH1cblxuICBwcml2YXRlIF9uYW1lR3JvdXAocHJlZml4OiBzdHJpbmcpOiBOYW1lR3JvdXAge1xuICAgIGlmICh0aGlzLl9wYXJlbnQ/Ll9wcmVmaXhlcz8uaGFzKHByZWZpeCkgfHwgKHRoaXMuX3ByZWZpeGVzICYmICF0aGlzLl9wcmVmaXhlcy5oYXMocHJlZml4KSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUdlbjogcHJlZml4IFwiJHtwcmVmaXh9XCIgaXMgbm90IGFsbG93ZWQgaW4gdGhpcyBzY29wZWApXG4gICAgfVxuICAgIHJldHVybiAodGhpcy5fbmFtZXNbcHJlZml4XSA9IHtwcmVmaXgsIGluZGV4OiAwfSlcbiAgfVxufVxuXG5pbnRlcmZhY2UgU2NvcGVQYXRoIHtcbiAgcHJvcGVydHk6IHN0cmluZ1xuICBpdGVtSW5kZXg6IG51bWJlclxufVxuXG5leHBvcnQgY2xhc3MgVmFsdWVTY29wZU5hbWUgZXh0ZW5kcyBOYW1lIHtcbiAgcmVhZG9ubHkgcHJlZml4OiBzdHJpbmdcbiAgdmFsdWU/OiBOYW1lVmFsdWVcbiAgc2NvcGVQYXRoPzogQ29kZVxuXG4gIGNvbnN0cnVjdG9yKHByZWZpeDogc3RyaW5nLCBuYW1lU3RyOiBzdHJpbmcpIHtcbiAgICBzdXBlcihuYW1lU3RyKVxuICAgIHRoaXMucHJlZml4ID0gcHJlZml4XG4gIH1cblxuICBzZXRWYWx1ZSh2YWx1ZTogTmFtZVZhbHVlLCB7cHJvcGVydHksIGl0ZW1JbmRleH06IFNjb3BlUGF0aCk6IHZvaWQge1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuc2NvcGVQYXRoID0gX2AuJHtuZXcgTmFtZShwcm9wZXJ0eSl9WyR7aXRlbUluZGV4fV1gXG4gIH1cbn1cblxuaW50ZXJmYWNlIFZTT3B0aW9ucyBleHRlbmRzIFZhbHVlU2NvcGVPcHRpb25zIHtcbiAgX246IENvZGVcbn1cblxuY29uc3QgbGluZSA9IF9gXFxuYFxuXG5leHBvcnQgY2xhc3MgVmFsdWVTY29wZSBleHRlbmRzIFNjb3BlIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF92YWx1ZXM6IFNjb3BlVmFsdWVzID0ge31cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9zY29wZTogU2NvcGVTdG9yZVxuICByZWFkb25seSBvcHRzOiBWU09wdGlvbnNcblxuICBjb25zdHJ1Y3RvcihvcHRzOiBWYWx1ZVNjb3BlT3B0aW9ucykge1xuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpcy5fc2NvcGUgPSBvcHRzLnNjb3BlXG4gICAgdGhpcy5vcHRzID0gey4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gbGluZSA6IG5pbH1cbiAgfVxuXG4gIGdldCgpOiBTY29wZVN0b3JlIHtcbiAgICByZXR1cm4gdGhpcy5fc2NvcGVcbiAgfVxuXG4gIG5hbWUocHJlZml4OiBzdHJpbmcpOiBWYWx1ZVNjb3BlTmFtZSB7XG4gICAgcmV0dXJuIG5ldyBWYWx1ZVNjb3BlTmFtZShwcmVmaXgsIHRoaXMuX25ld05hbWUocHJlZml4KSlcbiAgfVxuXG4gIHZhbHVlKG5hbWVPclByZWZpeDogVmFsdWVTY29wZU5hbWUgfCBzdHJpbmcsIHZhbHVlOiBOYW1lVmFsdWUpOiBWYWx1ZVNjb3BlTmFtZSB7XG4gICAgaWYgKHZhbHVlLnJlZiA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJDb2RlR2VuOiByZWYgbXVzdCBiZSBwYXNzZWQgaW4gdmFsdWVcIilcbiAgICBjb25zdCBuYW1lID0gdGhpcy50b05hbWUobmFtZU9yUHJlZml4KSBhcyBWYWx1ZVNjb3BlTmFtZVxuICAgIGNvbnN0IHtwcmVmaXh9ID0gbmFtZVxuICAgIGNvbnN0IHZhbHVlS2V5ID0gdmFsdWUua2V5ID8/IHZhbHVlLnJlZlxuICAgIGxldCB2cyA9IHRoaXMuX3ZhbHVlc1twcmVmaXhdXG4gICAgaWYgKHZzKSB7XG4gICAgICBjb25zdCBfbmFtZSA9IHZzLmdldCh2YWx1ZUtleSlcbiAgICAgIGlmIChfbmFtZSkgcmV0dXJuIF9uYW1lXG4gICAgfSBlbHNlIHtcbiAgICAgIHZzID0gdGhpcy5fdmFsdWVzW3ByZWZpeF0gPSBuZXcgTWFwKClcbiAgICB9XG4gICAgdnMuc2V0KHZhbHVlS2V5LCBuYW1lKVxuXG4gICAgY29uc3QgcyA9IHRoaXMuX3Njb3BlW3ByZWZpeF0gfHwgKHRoaXMuX3Njb3BlW3ByZWZpeF0gPSBbXSlcbiAgICBjb25zdCBpdGVtSW5kZXggPSBzLmxlbmd0aFxuICAgIHNbaXRlbUluZGV4XSA9IHZhbHVlLnJlZlxuICAgIG5hbWUuc2V0VmFsdWUodmFsdWUsIHtwcm9wZXJ0eTogcHJlZml4LCBpdGVtSW5kZXh9KVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICBnZXRWYWx1ZShwcmVmaXg6IHN0cmluZywga2V5T3JSZWY6IHVua25vd24pOiBWYWx1ZVNjb3BlTmFtZSB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdnMgPSB0aGlzLl92YWx1ZXNbcHJlZml4XVxuICAgIGlmICghdnMpIHJldHVyblxuICAgIHJldHVybiB2cy5nZXQoa2V5T3JSZWYpXG4gIH1cblxuICBzY29wZVJlZnMoc2NvcGVOYW1lOiBOYW1lLCB2YWx1ZXM6IFNjb3BlVmFsdWVzIHwgU2NvcGVWYWx1ZVNldHMgPSB0aGlzLl92YWx1ZXMpOiBDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fcmVkdWNlVmFsdWVzKHZhbHVlcywgKG5hbWU6IFZhbHVlU2NvcGVOYW1lKSA9PiB7XG4gICAgICBpZiAobmFtZS5zY29wZVBhdGggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiBuYW1lIFwiJHtuYW1lfVwiIGhhcyBubyB2YWx1ZWApXG4gICAgICByZXR1cm4gX2Ake3Njb3BlTmFtZX0ke25hbWUuc2NvcGVQYXRofWBcbiAgICB9KVxuICB9XG5cbiAgc2NvcGVDb2RlKFxuICAgIHZhbHVlczogU2NvcGVWYWx1ZXMgfCBTY29wZVZhbHVlU2V0cyA9IHRoaXMuX3ZhbHVlcyxcbiAgICB1c2VkVmFsdWVzPzogVXNlZFNjb3BlVmFsdWVzLFxuICAgIGdldENvZGU/OiAobjogVmFsdWVTY29wZU5hbWUpID0+IENvZGUgfCB1bmRlZmluZWRcbiAgKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlZHVjZVZhbHVlcyhcbiAgICAgIHZhbHVlcyxcbiAgICAgIChuYW1lOiBWYWx1ZVNjb3BlTmFtZSkgPT4ge1xuICAgICAgICBpZiAobmFtZS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5hbWUgXCIke25hbWV9XCIgaGFzIG5vIHZhbHVlYClcbiAgICAgICAgcmV0dXJuIG5hbWUudmFsdWUuY29kZVxuICAgICAgfSxcbiAgICAgIHVzZWRWYWx1ZXMsXG4gICAgICBnZXRDb2RlXG4gICAgKVxuICB9XG5cbiAgcHJpdmF0ZSBfcmVkdWNlVmFsdWVzKFxuICAgIHZhbHVlczogU2NvcGVWYWx1ZXMgfCBTY29wZVZhbHVlU2V0cyxcbiAgICB2YWx1ZUNvZGU6IChuOiBWYWx1ZVNjb3BlTmFtZSkgPT4gQ29kZSB8IHVuZGVmaW5lZCxcbiAgICB1c2VkVmFsdWVzOiBVc2VkU2NvcGVWYWx1ZXMgPSB7fSxcbiAgICBnZXRDb2RlPzogKG46IFZhbHVlU2NvcGVOYW1lKSA9PiBDb2RlIHwgdW5kZWZpbmVkXG4gICk6IENvZGUge1xuICAgIGxldCBjb2RlOiBDb2RlID0gbmlsXG4gICAgZm9yIChjb25zdCBwcmVmaXggaW4gdmFsdWVzKSB7XG4gICAgICBjb25zdCB2cyA9IHZhbHVlc1twcmVmaXhdXG4gICAgICBpZiAoIXZzKSBjb250aW51ZVxuICAgICAgY29uc3QgbmFtZVNldCA9ICh1c2VkVmFsdWVzW3ByZWZpeF0gPSB1c2VkVmFsdWVzW3ByZWZpeF0gfHwgbmV3IE1hcCgpKVxuICAgICAgdnMuZm9yRWFjaCgobmFtZTogVmFsdWVTY29wZU5hbWUpID0+IHtcbiAgICAgICAgaWYgKG5hbWVTZXQuaGFzKG5hbWUpKSByZXR1cm5cbiAgICAgICAgbmFtZVNldC5zZXQobmFtZSwgVXNlZFZhbHVlU3RhdGUuU3RhcnRlZClcbiAgICAgICAgbGV0IGMgPSB2YWx1ZUNvZGUobmFtZSlcbiAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICBjb25zdCBkZWYgPSB0aGlzLm9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdmFyS2luZHMuY29uc3RcbiAgICAgICAgICBjb2RlID0gX2Ake2NvZGV9JHtkZWZ9ICR7bmFtZX0gPSAke2N9OyR7dGhpcy5vcHRzLl9ufWBcbiAgICAgICAgfSBlbHNlIGlmICgoYyA9IGdldENvZGU/LihuYW1lKSkpIHtcbiAgICAgICAgICBjb2RlID0gX2Ake2NvZGV9JHtjfSR7dGhpcy5vcHRzLl9ufWBcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihuYW1lKVxuICAgICAgICB9XG4gICAgICAgIG5hbWVTZXQuc2V0KG5hbWUsIFVzZWRWYWx1ZVN0YXRlLkNvbXBsZXRlZClcbiAgICAgIH0pXG4gICAgfVxuICAgIHJldHVybiBjb2RlXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7U2NvcGVWYWx1ZVNldHMsIE5hbWVWYWx1ZSwgVmFsdWVTY29wZSwgVmFsdWVTY29wZU5hbWV9IGZyb20gXCIuL3Njb3BlXCJcbmltcG9ydCB7XywgbmlsLCBfQ29kZSwgQ29kZSwgTmFtZSwgVXNlZE5hbWVzLCBDb2RlSXRlbSwgYWRkQ29kZUFyZywgX0NvZGVPck5hbWV9IGZyb20gXCIuL2NvZGVcIlxuaW1wb3J0IHtTY29wZSwgdmFyS2luZHN9IGZyb20gXCIuL3Njb3BlXCJcblxuZXhwb3J0IHtfLCBzdHIsIHN0ckNvbmNhdCwgbmlsLCBnZXRQcm9wZXJ0eSwgc3RyaW5naWZ5LCByZWdleHBDb2RlLCBOYW1lLCBDb2RlfSBmcm9tIFwiLi9jb2RlXCJcbmV4cG9ydCB7U2NvcGUsIFNjb3BlU3RvcmUsIFZhbHVlU2NvcGUsIFZhbHVlU2NvcGVOYW1lLCBTY29wZVZhbHVlU2V0cywgdmFyS2luZHN9IGZyb20gXCIuL3Njb3BlXCJcblxuLy8gdHlwZSBmb3IgZXhwcmVzc2lvbnMgdGhhdCBjYW4gYmUgc2FmZWx5IGluc2VydGVkIGluIGNvZGUgd2l0aG91dCBxdW90ZXNcbmV4cG9ydCB0eXBlIFNhZmVFeHByID0gQ29kZSB8IG51bWJlciB8IGJvb2xlYW4gfCBudWxsXG5cbi8vIHR5cGUgdGhhdCBpcyBlaXRoZXIgQ29kZSBvZiBmdW5jdGlvbiB0aGF0IGFkZHMgY29kZSB0byBDb2RlR2VuIGluc3RhbmNlIHVzaW5nIGl0cyBtZXRob2RzXG5leHBvcnQgdHlwZSBCbG9jayA9IENvZGUgfCAoKCkgPT4gdm9pZClcblxuZXhwb3J0IGNvbnN0IG9wZXJhdG9ycyA9IHtcbiAgR1Q6IG5ldyBfQ29kZShcIj5cIiksXG4gIEdURTogbmV3IF9Db2RlKFwiPj1cIiksXG4gIExUOiBuZXcgX0NvZGUoXCI8XCIpLFxuICBMVEU6IG5ldyBfQ29kZShcIjw9XCIpLFxuICBFUTogbmV3IF9Db2RlKFwiPT09XCIpLFxuICBORVE6IG5ldyBfQ29kZShcIiE9PVwiKSxcbiAgTk9UOiBuZXcgX0NvZGUoXCIhXCIpLFxuICBPUjogbmV3IF9Db2RlKFwifHxcIiksXG4gIEFORDogbmV3IF9Db2RlKFwiJiZcIiksXG4gIEFERDogbmV3IF9Db2RlKFwiK1wiKSxcbn1cblxuYWJzdHJhY3QgY2xhc3MgTm9kZSB7XG4gIGFic3RyYWN0IHJlYWRvbmx5IG5hbWVzOiBVc2VkTmFtZXNcblxuICBvcHRpbWl6ZU5vZGVzKCk6IHRoaXMgfCBDaGlsZE5vZGUgfCBDaGlsZE5vZGVbXSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMoX25hbWVzOiBVc2VkTmFtZXMsIF9jb25zdGFudHM6IENvbnN0YW50cyk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBnZXQgY291bnQoKTogbnVtYmVyIHtcbiAgLy8gICByZXR1cm4gMVxuICAvLyB9XG59XG5cbmNsYXNzIERlZiBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZhcktpbmQ6IE5hbWUsXG4gICAgcHJpdmF0ZSByZWFkb25seSBuYW1lOiBOYW1lLFxuICAgIHByaXZhdGUgcmhzPzogU2FmZUV4cHJcbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtlczUsIF9ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCB2YXJLaW5kID0gZXM1ID8gdmFyS2luZHMudmFyIDogdGhpcy52YXJLaW5kXG4gICAgY29uc3QgcmhzID0gdGhpcy5yaHMgPT09IHVuZGVmaW5lZCA/IFwiXCIgOiBgID0gJHt0aGlzLnJoc31gXG4gICAgcmV0dXJuIGAke3ZhcktpbmR9ICR7dGhpcy5uYW1lfSR7cmhzfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIW5hbWVzW3RoaXMubmFtZS5zdHJdKSByZXR1cm5cbiAgICBpZiAodGhpcy5yaHMpIHRoaXMucmhzID0gb3B0aW1pemVFeHByKHRoaXMucmhzLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5yaHMgaW5zdGFuY2VvZiBfQ29kZU9yTmFtZSA/IHRoaXMucmhzLm5hbWVzIDoge31cbiAgfVxufVxuXG5jbGFzcyBBc3NpZ24gZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcmVhZG9ubHkgbGhzOiBDb2RlLFxuICAgIHB1YmxpYyByaHM6IFNhZmVFeHByLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2lkZUVmZmVjdHM/OiBib29sZWFuXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxoc30gPSAke3RoaXMucmhzfTtgICsgX25cbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAodGhpcy5saHMgaW5zdGFuY2VvZiBOYW1lICYmICFuYW1lc1t0aGlzLmxocy5zdHJdICYmICF0aGlzLnNpZGVFZmZlY3RzKSByZXR1cm5cbiAgICB0aGlzLnJocyA9IG9wdGltaXplRXhwcih0aGlzLnJocywgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSB0aGlzLmxocyBpbnN0YW5jZW9mIE5hbWUgPyB7fSA6IHsuLi50aGlzLmxocy5uYW1lc31cbiAgICByZXR1cm4gYWRkRXhwck5hbWVzKG5hbWVzLCB0aGlzLnJocylcbiAgfVxufVxuXG5jbGFzcyBBc3NpZ25PcCBleHRlbmRzIEFzc2lnbiB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIGxoczogQ29kZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG9wOiBDb2RlLFxuICAgIHJoczogU2FmZUV4cHIsXG4gICAgc2lkZUVmZmVjdHM/OiBib29sZWFuXG4gICkge1xuICAgIHN1cGVyKGxocywgcmhzLCBzaWRlRWZmZWN0cylcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgJHt0aGlzLmxoc30gJHt0aGlzLm9wfT0gJHt0aGlzLnJoc307YCArIF9uXG4gIH1cbn1cblxuY2xhc3MgTGFiZWwgZXh0ZW5kcyBOb2RlIHtcbiAgcmVhZG9ubHkgbmFtZXM6IFVzZWROYW1lcyA9IHt9XG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGxhYmVsOiBOYW1lKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMubGFiZWx9OmAgKyBfblxuICB9XG59XG5cbmNsYXNzIEJyZWFrIGV4dGVuZHMgTm9kZSB7XG4gIHJlYWRvbmx5IG5hbWVzOiBVc2VkTmFtZXMgPSB7fVxuICBjb25zdHJ1Y3RvcihyZWFkb25seSBsYWJlbD86IENvZGUpIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIoe19ufTogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICBjb25zdCBsYWJlbCA9IHRoaXMubGFiZWwgPyBgICR7dGhpcy5sYWJlbH1gIDogXCJcIlxuICAgIHJldHVybiBgYnJlYWske2xhYmVsfTtgICsgX25cbiAgfVxufVxuXG5jbGFzcyBUaHJvdyBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3RvcihyZWFkb25seSBlcnJvcjogQ29kZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcih7X259OiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgdGhyb3cgJHt0aGlzLmVycm9yfTtgICsgX25cbiAgfVxuXG4gIGdldCBuYW1lcygpOiBVc2VkTmFtZXMge1xuICAgIHJldHVybiB0aGlzLmVycm9yLm5hbWVzXG4gIH1cbn1cblxuY2xhc3MgQW55Q29kZSBleHRlbmRzIE5vZGUge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGNvZGU6IFNhZmVFeHByKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKHtfbn06IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29kZX07YCArIF9uXG4gIH1cblxuICBvcHRpbWl6ZU5vZGVzKCk6IHRoaXMgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiBgJHt0aGlzLmNvZGV9YCA/IHRoaXMgOiB1bmRlZmluZWRcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHtcbiAgICB0aGlzLmNvZGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5jb2RlLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gdGhpcy5jb2RlIGluc3RhbmNlb2YgX0NvZGVPck5hbWUgPyB0aGlzLmNvZGUubmFtZXMgOiB7fVxuICB9XG59XG5cbmFic3RyYWN0IGNsYXNzIFBhcmVudE5vZGUgZXh0ZW5kcyBOb2RlIHtcbiAgY29uc3RydWN0b3IocmVhZG9ubHkgbm9kZXM6IENoaWxkTm9kZVtdID0gW10pIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlcy5yZWR1Y2UoKGNvZGUsIG4pID0+IGNvZGUgKyBuLnJlbmRlcihvcHRzKSwgXCJcIilcbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB8IENoaWxkTm9kZSB8IENoaWxkTm9kZVtdIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB7bm9kZXN9ID0gdGhpc1xuICAgIGxldCBpID0gbm9kZXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgY29uc3QgbiA9IG5vZGVzW2ldLm9wdGltaXplTm9kZXMoKVxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobikpIG5vZGVzLnNwbGljZShpLCAxLCAuLi5uKVxuICAgICAgZWxzZSBpZiAobikgbm9kZXNbaV0gPSBuXG4gICAgICBlbHNlIG5vZGVzLnNwbGljZShpLCAxKVxuICAgIH1cbiAgICByZXR1cm4gbm9kZXMubGVuZ3RoID4gMCA/IHRoaXMgOiB1bmRlZmluZWRcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBjb25zdCB7bm9kZXN9ID0gdGhpc1xuICAgIGxldCBpID0gbm9kZXMubGVuZ3RoXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgLy8gaXRlcmF0aW5nIGJhY2t3YXJkcyBpbXByb3ZlcyAxLXBhc3Mgb3B0aW1pemF0aW9uXG4gICAgICBjb25zdCBuID0gbm9kZXNbaV1cbiAgICAgIGlmIChuLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpIGNvbnRpbnVlXG4gICAgICBzdWJ0cmFjdE5hbWVzKG5hbWVzLCBuLm5hbWVzKVxuICAgICAgbm9kZXMuc3BsaWNlKGksIDEpXG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGggPiAwID8gdGhpcyA6IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChuYW1lczogVXNlZE5hbWVzLCBuKSA9PiBhZGROYW1lcyhuYW1lcywgbi5uYW1lcyksIHt9KVxuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHRoaXMubm9kZXMucmVkdWNlKChjLCBuKSA9PiBjICsgbi5jb3VudCwgMSlcbiAgLy8gfVxufVxuXG5hYnN0cmFjdCBjbGFzcyBCbG9ja05vZGUgZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwie1wiICsgb3B0cy5fbiArIHN1cGVyLnJlbmRlcihvcHRzKSArIFwifVwiICsgb3B0cy5fblxuICB9XG59XG5cbmNsYXNzIFJvb3QgZXh0ZW5kcyBQYXJlbnROb2RlIHt9XG5cbmNsYXNzIEVsc2UgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiZWxzZVwiXG59XG5cbmNsYXNzIElmIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImlmXCJcbiAgZWxzZT86IElmIHwgRWxzZVxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGNvbmRpdGlvbjogQ29kZSB8IGJvb2xlYW4sXG4gICAgbm9kZXM/OiBDaGlsZE5vZGVbXVxuICApIHtcbiAgICBzdXBlcihub2RlcylcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGxldCBjb2RlID0gYGlmKCR7dGhpcy5jb25kaXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgICBpZiAodGhpcy5lbHNlKSBjb2RlICs9IFwiZWxzZSBcIiArIHRoaXMuZWxzZS5yZW5kZXIob3B0cylcbiAgICByZXR1cm4gY29kZVxuICB9XG5cbiAgb3B0aW1pemVOb2RlcygpOiBJZiB8IENoaWxkTm9kZVtdIHwgdW5kZWZpbmVkIHtcbiAgICBzdXBlci5vcHRpbWl6ZU5vZGVzKClcbiAgICBjb25zdCBjb25kID0gdGhpcy5jb25kaXRpb25cbiAgICBpZiAoY29uZCA9PT0gdHJ1ZSkgcmV0dXJuIHRoaXMubm9kZXMgLy8gZWxzZSBpcyBpZ25vcmVkIGhlcmVcbiAgICBsZXQgZSA9IHRoaXMuZWxzZVxuICAgIGlmIChlKSB7XG4gICAgICBjb25zdCBucyA9IGUub3B0aW1pemVOb2RlcygpXG4gICAgICBlID0gdGhpcy5lbHNlID0gQXJyYXkuaXNBcnJheShucykgPyBuZXcgRWxzZShucykgOiAobnMgYXMgRWxzZSB8IHVuZGVmaW5lZClcbiAgICB9XG4gICAgaWYgKGUpIHtcbiAgICAgIGlmIChjb25kID09PSBmYWxzZSkgcmV0dXJuIGUgaW5zdGFuY2VvZiBJZiA/IGUgOiBlLm5vZGVzXG4gICAgICBpZiAodGhpcy5ub2Rlcy5sZW5ndGgpIHJldHVybiB0aGlzXG4gICAgICByZXR1cm4gbmV3IElmKG5vdChjb25kKSwgZSBpbnN0YW5jZW9mIElmID8gW2VdIDogZS5ub2RlcylcbiAgICB9XG4gICAgaWYgKGNvbmQgPT09IGZhbHNlIHx8ICF0aGlzLm5vZGVzLmxlbmd0aCkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB8IHVuZGVmaW5lZCB7XG4gICAgdGhpcy5lbHNlID0gdGhpcy5lbHNlPy5vcHRpbWl6ZU5hbWVzKG5hbWVzLCBjb25zdGFudHMpXG4gICAgaWYgKCEoc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKSB8fCB0aGlzLmVsc2UpKSByZXR1cm5cbiAgICB0aGlzLmNvbmRpdGlvbiA9IG9wdGltaXplRXhwcih0aGlzLmNvbmRpdGlvbiwgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lc1xuICAgIGFkZEV4cHJOYW1lcyhuYW1lcywgdGhpcy5jb25kaXRpb24pXG4gICAgaWYgKHRoaXMuZWxzZSkgYWRkTmFtZXMobmFtZXMsIHRoaXMuZWxzZS5uYW1lcylcbiAgICByZXR1cm4gbmFtZXNcbiAgfVxuXG4gIC8vIGdldCBjb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiBzdXBlci5jb3VudCArICh0aGlzLmVsc2U/LmNvdW50IHx8IDApXG4gIC8vIH1cbn1cblxuYWJzdHJhY3QgY2xhc3MgRm9yIGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImZvclwiXG59XG5cbmNsYXNzIEZvckxvb3AgZXh0ZW5kcyBGb3Ige1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGl0ZXJhdGlvbjogQ29kZSkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIHJldHVybiBgZm9yKCR7dGhpcy5pdGVyYXRpb259KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpIHJldHVyblxuICAgIHRoaXMuaXRlcmF0aW9uID0gb3B0aW1pemVFeHByKHRoaXMuaXRlcmF0aW9uLCBuYW1lcywgY29uc3RhbnRzKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICByZXR1cm4gYWRkTmFtZXMoc3VwZXIubmFtZXMsIHRoaXMuaXRlcmF0aW9uLm5hbWVzKVxuICB9XG59XG5cbmNsYXNzIEZvclJhbmdlIGV4dGVuZHMgRm9yIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YXJLaW5kOiBOYW1lLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbmFtZTogTmFtZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGZyb206IFNhZmVFeHByLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdG86IFNhZmVFeHByXG4gICkge1xuICAgIHN1cGVyKClcbiAgfVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZhcktpbmQgPSBvcHRzLmVzNSA/IHZhcktpbmRzLnZhciA6IHRoaXMudmFyS2luZFxuICAgIGNvbnN0IHtuYW1lLCBmcm9tLCB0b30gPSB0aGlzXG4gICAgcmV0dXJuIGBmb3IoJHt2YXJLaW5kfSAke25hbWV9PSR7ZnJvbX07ICR7bmFtZX08JHt0b307ICR7bmFtZX0rKylgICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cblxuICBnZXQgbmFtZXMoKTogVXNlZE5hbWVzIHtcbiAgICBjb25zdCBuYW1lcyA9IGFkZEV4cHJOYW1lcyhzdXBlci5uYW1lcywgdGhpcy5mcm9tKVxuICAgIHJldHVybiBhZGRFeHByTmFtZXMobmFtZXMsIHRoaXMudG8pXG4gIH1cbn1cblxuY2xhc3MgRm9ySXRlciBleHRlbmRzIEZvciB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbG9vcDogXCJvZlwiIHwgXCJpblwiLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdmFyS2luZDogTmFtZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IG5hbWU6IE5hbWUsXG4gICAgcHJpdmF0ZSBpdGVyYWJsZTogQ29kZVxuICApIHtcbiAgICBzdXBlcigpXG4gIH1cblxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gYGZvcigke3RoaXMudmFyS2luZH0gJHt0aGlzLm5hbWV9ICR7dGhpcy5sb29wfSAke3RoaXMuaXRlcmFibGV9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxuXG4gIG9wdGltaXplTmFtZXMobmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiB0aGlzIHwgdW5kZWZpbmVkIHtcbiAgICBpZiAoIXN1cGVyLm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cykpIHJldHVyblxuICAgIHRoaXMuaXRlcmFibGUgPSBvcHRpbWl6ZUV4cHIodGhpcy5pdGVyYWJsZSwgbmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgcmV0dXJuIGFkZE5hbWVzKHN1cGVyLm5hbWVzLCB0aGlzLml0ZXJhYmxlLm5hbWVzKVxuICB9XG59XG5cbmNsYXNzIEZ1bmMgZXh0ZW5kcyBCbG9ja05vZGUge1xuICBzdGF0aWMgcmVhZG9ubHkga2luZCA9IFwiZnVuY1wiXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBuYW1lOiBOYW1lLFxuICAgIHB1YmxpYyBhcmdzOiBDb2RlLFxuICAgIHB1YmxpYyBhc3luYz86IGJvb2xlYW5cbiAgKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgY29uc3QgX2FzeW5jID0gdGhpcy5hc3luYyA/IFwiYXN5bmMgXCIgOiBcIlwiXG4gICAgcmV0dXJuIGAke19hc3luY31mdW5jdGlvbiAke3RoaXMubmFtZX0oJHt0aGlzLmFyZ3N9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBSZXR1cm4gZXh0ZW5kcyBQYXJlbnROb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcInJldHVyblwiXG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwicmV0dXJuIFwiICsgc3VwZXIucmVuZGVyKG9wdHMpXG4gIH1cbn1cblxuY2xhc3MgVHJ5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgY2F0Y2g/OiBDYXRjaFxuICBmaW5hbGx5PzogRmluYWxseVxuXG4gIHJlbmRlcihvcHRzOiBDR09wdGlvbnMpOiBzdHJpbmcge1xuICAgIGxldCBjb2RlID0gXCJ0cnlcIiArIHN1cGVyLnJlbmRlcihvcHRzKVxuICAgIGlmICh0aGlzLmNhdGNoKSBjb2RlICs9IHRoaXMuY2F0Y2gucmVuZGVyKG9wdHMpXG4gICAgaWYgKHRoaXMuZmluYWxseSkgY29kZSArPSB0aGlzLmZpbmFsbHkucmVuZGVyKG9wdHMpXG4gICAgcmV0dXJuIGNvZGVcbiAgfVxuXG4gIG9wdGltaXplTm9kZXMoKTogdGhpcyB7XG4gICAgc3VwZXIub3B0aW1pemVOb2RlcygpXG4gICAgdGhpcy5jYXRjaD8ub3B0aW1pemVOb2RlcygpIGFzIENhdGNoIHwgdW5kZWZpbmVkXG4gICAgdGhpcy5maW5hbGx5Py5vcHRpbWl6ZU5vZGVzKCkgYXMgRmluYWxseSB8IHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBvcHRpbWl6ZU5hbWVzKG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogdGhpcyB7XG4gICAgc3VwZXIub3B0aW1pemVOYW1lcyhuYW1lcywgY29uc3RhbnRzKVxuICAgIHRoaXMuY2F0Y2g/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICB0aGlzLmZpbmFsbHk/Lm9wdGltaXplTmFtZXMobmFtZXMsIGNvbnN0YW50cylcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZ2V0IG5hbWVzKCk6IFVzZWROYW1lcyB7XG4gICAgY29uc3QgbmFtZXMgPSBzdXBlci5uYW1lc1xuICAgIGlmICh0aGlzLmNhdGNoKSBhZGROYW1lcyhuYW1lcywgdGhpcy5jYXRjaC5uYW1lcylcbiAgICBpZiAodGhpcy5maW5hbGx5KSBhZGROYW1lcyhuYW1lcywgdGhpcy5maW5hbGx5Lm5hbWVzKVxuICAgIHJldHVybiBuYW1lc1xuICB9XG5cbiAgLy8gZ2V0IGNvdW50KCk6IG51bWJlciB7XG4gIC8vICAgcmV0dXJuIHN1cGVyLmNvdW50ICsgKHRoaXMuY2F0Y2g/LmNvdW50IHx8IDApICsgKHRoaXMuZmluYWxseT8uY291bnQgfHwgMClcbiAgLy8gfVxufVxuXG5jbGFzcyBDYXRjaCBleHRlbmRzIEJsb2NrTm9kZSB7XG4gIHN0YXRpYyByZWFkb25seSBraW5kID0gXCJjYXRjaFwiXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGVycm9yOiBOYW1lKSB7XG4gICAgc3VwZXIoKVxuICB9XG5cbiAgcmVuZGVyKG9wdHM6IENHT3B0aW9ucyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBjYXRjaCgke3RoaXMuZXJyb3J9KWAgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG5jbGFzcyBGaW5hbGx5IGV4dGVuZHMgQmxvY2tOb2RlIHtcbiAgc3RhdGljIHJlYWRvbmx5IGtpbmQgPSBcImZpbmFsbHlcIlxuICByZW5kZXIob3B0czogQ0dPcHRpb25zKTogc3RyaW5nIHtcbiAgICByZXR1cm4gXCJmaW5hbGx5XCIgKyBzdXBlci5yZW5kZXIob3B0cylcbiAgfVxufVxuXG50eXBlIFN0YXJ0QmxvY2tOb2RlID0gSWYgfCBGb3IgfCBGdW5jIHwgUmV0dXJuIHwgVHJ5XG5cbnR5cGUgTGVhZk5vZGUgPSBEZWYgfCBBc3NpZ24gfCBMYWJlbCB8IEJyZWFrIHwgVGhyb3cgfCBBbnlDb2RlXG5cbnR5cGUgQ2hpbGROb2RlID0gU3RhcnRCbG9ja05vZGUgfCBMZWFmTm9kZVxuXG50eXBlIEVuZEJsb2NrTm9kZVR5cGUgPVxuICB8IHR5cGVvZiBJZlxuICB8IHR5cGVvZiBFbHNlXG4gIHwgdHlwZW9mIEZvclxuICB8IHR5cGVvZiBGdW5jXG4gIHwgdHlwZW9mIFJldHVyblxuICB8IHR5cGVvZiBDYXRjaFxuICB8IHR5cGVvZiBGaW5hbGx5XG5cbnR5cGUgQ29uc3RhbnRzID0gUmVjb3JkPHN0cmluZywgU2FmZUV4cHIgfCB1bmRlZmluZWQ+XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUdlbk9wdGlvbnMge1xuICBlczU/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxuICBvd25Qcm9wZXJ0aWVzPzogYm9vbGVhblxufVxuXG5pbnRlcmZhY2UgQ0dPcHRpb25zIGV4dGVuZHMgQ29kZUdlbk9wdGlvbnMge1xuICBfbjogXCJcXG5cIiB8IFwiXCJcbn1cblxuZXhwb3J0IGNsYXNzIENvZGVHZW4ge1xuICByZWFkb25seSBfc2NvcGU6IFNjb3BlXG4gIHJlYWRvbmx5IF9leHRTY29wZTogVmFsdWVTY29wZVxuICByZWFkb25seSBfdmFsdWVzOiBTY29wZVZhbHVlU2V0cyA9IHt9XG4gIHByaXZhdGUgcmVhZG9ubHkgX25vZGVzOiBQYXJlbnROb2RlW11cbiAgcHJpdmF0ZSByZWFkb25seSBfYmxvY2tTdGFydHM6IG51bWJlcltdID0gW11cbiAgcHJpdmF0ZSByZWFkb25seSBfY29uc3RhbnRzOiBDb25zdGFudHMgPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IG9wdHM6IENHT3B0aW9uc1xuXG4gIGNvbnN0cnVjdG9yKGV4dFNjb3BlOiBWYWx1ZVNjb3BlLCBvcHRzOiBDb2RlR2VuT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5vcHRzID0gey4uLm9wdHMsIF9uOiBvcHRzLmxpbmVzID8gXCJcXG5cIiA6IFwiXCJ9XG4gICAgdGhpcy5fZXh0U2NvcGUgPSBleHRTY29wZVxuICAgIHRoaXMuX3Njb3BlID0gbmV3IFNjb3BlKHtwYXJlbnQ6IGV4dFNjb3BlfSlcbiAgICB0aGlzLl9ub2RlcyA9IFtuZXcgUm9vdCgpXVxuICB9XG5cbiAgdG9TdHJpbmcoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdC5yZW5kZXIodGhpcy5vcHRzKVxuICB9XG5cbiAgLy8gcmV0dXJucyB1bmlxdWUgbmFtZSBpbiB0aGUgaW50ZXJuYWwgc2NvcGVcbiAgbmFtZShwcmVmaXg6IHN0cmluZyk6IE5hbWUge1xuICAgIHJldHVybiB0aGlzLl9zY29wZS5uYW1lKHByZWZpeClcbiAgfVxuXG4gIC8vIHJlc2VydmVzIHVuaXF1ZSBuYW1lIGluIHRoZSBleHRlcm5hbCBzY29wZVxuICBzY29wZU5hbWUocHJlZml4OiBzdHJpbmcpOiBWYWx1ZVNjb3BlTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLm5hbWUocHJlZml4KVxuICB9XG5cbiAgLy8gcmVzZXJ2ZXMgdW5pcXVlIG5hbWUgaW4gdGhlIGV4dGVybmFsIHNjb3BlIGFuZCBhc3NpZ25zIHZhbHVlIHRvIGl0XG4gIHNjb3BlVmFsdWUocHJlZml4T3JOYW1lOiBWYWx1ZVNjb3BlTmFtZSB8IHN0cmluZywgdmFsdWU6IE5hbWVWYWx1ZSk6IE5hbWUge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9leHRTY29wZS52YWx1ZShwcmVmaXhPck5hbWUsIHZhbHVlKVxuICAgIGNvbnN0IHZzID0gdGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSB8fCAodGhpcy5fdmFsdWVzW25hbWUucHJlZml4XSA9IG5ldyBTZXQoKSlcbiAgICB2cy5hZGQobmFtZSlcbiAgICByZXR1cm4gbmFtZVxuICB9XG5cbiAgZ2V0U2NvcGVWYWx1ZShwcmVmaXg6IHN0cmluZywga2V5T3JSZWY6IHVua25vd24pOiBWYWx1ZVNjb3BlTmFtZSB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLmdldFZhbHVlKHByZWZpeCwga2V5T3JSZWYpXG4gIH1cblxuICAvLyByZXR1cm4gY29kZSB0aGF0IGFzc2lnbnMgdmFsdWVzIGluIHRoZSBleHRlcm5hbCBzY29wZSB0byB0aGUgbmFtZXMgdGhhdCBhcmUgdXNlZCBpbnRlcm5hbGx5XG4gIC8vIChzYW1lIG5hbWVzIHRoYXQgd2VyZSByZXR1cm5lZCBieSBnZW4uc2NvcGVOYW1lIG9yIGdlbi5zY29wZVZhbHVlKVxuICBzY29wZVJlZnMoc2NvcGVOYW1lOiBOYW1lKTogQ29kZSB7XG4gICAgcmV0dXJuIHRoaXMuX2V4dFNjb3BlLnNjb3BlUmVmcyhzY29wZU5hbWUsIHRoaXMuX3ZhbHVlcylcbiAgfVxuXG4gIHNjb3BlQ29kZSgpOiBDb2RlIHtcbiAgICByZXR1cm4gdGhpcy5fZXh0U2NvcGUuc2NvcGVDb2RlKHRoaXMuX3ZhbHVlcylcbiAgfVxuXG4gIHByaXZhdGUgX2RlZihcbiAgICB2YXJLaW5kOiBOYW1lLFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICByaHM/OiBTYWZlRXhwcixcbiAgICBjb25zdGFudD86IGJvb2xlYW5cbiAgKTogTmFtZSB7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgaWYgKHJocyAhPT0gdW5kZWZpbmVkICYmIGNvbnN0YW50KSB0aGlzLl9jb25zdGFudHNbbmFtZS5zdHJdID0gcmhzXG4gICAgdGhpcy5fbGVhZk5vZGUobmV3IERlZih2YXJLaW5kLCBuYW1lLCByaHMpKVxuICAgIHJldHVybiBuYW1lXG4gIH1cblxuICAvLyBgY29uc3RgIGRlY2xhcmF0aW9uIChgdmFyYCBpbiBlczUgbW9kZSlcbiAgY29uc3QobmFtZU9yUHJlZml4OiBOYW1lIHwgc3RyaW5nLCByaHM6IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy5jb25zdCwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGBsZXRgIGRlY2xhcmF0aW9uIHdpdGggb3B0aW9uYWwgYXNzaWdubWVudCAoYHZhcmAgaW4gZXM1IG1vZGUpXG4gIGxldChuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsIHJocz86IFNhZmVFeHByLCBfY29uc3RhbnQ/OiBib29sZWFuKTogTmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX2RlZih2YXJLaW5kcy5sZXQsIG5hbWVPclByZWZpeCwgcmhzLCBfY29uc3RhbnQpXG4gIH1cblxuICAvLyBgdmFyYCBkZWNsYXJhdGlvbiB3aXRoIG9wdGlvbmFsIGFzc2lnbm1lbnRcbiAgdmFyKG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZywgcmhzPzogU2FmZUV4cHIsIF9jb25zdGFudD86IGJvb2xlYW4pOiBOYW1lIHtcbiAgICByZXR1cm4gdGhpcy5fZGVmKHZhcktpbmRzLnZhciwgbmFtZU9yUHJlZml4LCByaHMsIF9jb25zdGFudClcbiAgfVxuXG4gIC8vIGFzc2lnbm1lbnQgY29kZVxuICBhc3NpZ24obGhzOiBDb2RlLCByaHM6IFNhZmVFeHByLCBzaWRlRWZmZWN0cz86IGJvb2xlYW4pOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbihsaHMsIHJocywgc2lkZUVmZmVjdHMpKVxuICB9XG5cbiAgLy8gYCs9YCBjb2RlXG4gIGFkZChsaHM6IENvZGUsIHJoczogU2FmZUV4cHIpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IEFzc2lnbk9wKGxocywgb3BlcmF0b3JzLkFERCwgcmhzKSlcbiAgfVxuXG4gIC8vIGFwcGVuZHMgcGFzc2VkIFNhZmVFeHByIHRvIGNvZGUgb3IgZXhlY3V0ZXMgQmxvY2tcbiAgY29kZShjOiBCbG9jayB8IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgaWYgKHR5cGVvZiBjID09IFwiZnVuY3Rpb25cIikgYygpXG4gICAgZWxzZSBpZiAoYyAhPT0gbmlsKSB0aGlzLl9sZWFmTm9kZShuZXcgQW55Q29kZShjKSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gcmV0dXJucyBjb2RlIGZvciBvYmplY3QgbGl0ZXJhbCBmb3IgdGhlIHBhc3NlZCBhcmd1bWVudCBsaXN0IG9mIGtleS12YWx1ZSBwYWlyc1xuICBvYmplY3QoLi4ua2V5VmFsdWVzOiBbTmFtZSB8IHN0cmluZywgU2FmZUV4cHIgfCBzdHJpbmddW10pOiBfQ29kZSB7XG4gICAgY29uc3QgY29kZTogQ29kZUl0ZW1bXSA9IFtcIntcIl1cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBrZXlWYWx1ZXMpIHtcbiAgICAgIGlmIChjb2RlLmxlbmd0aCA+IDEpIGNvZGUucHVzaChcIixcIilcbiAgICAgIGNvZGUucHVzaChrZXkpXG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZSB8fCB0aGlzLm9wdHMuZXM1KSB7XG4gICAgICAgIGNvZGUucHVzaChcIjpcIilcbiAgICAgICAgYWRkQ29kZUFyZyhjb2RlLCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgY29kZS5wdXNoKFwifVwiKVxuICAgIHJldHVybiBuZXcgX0NvZGUoY29kZSlcbiAgfVxuXG4gIC8vIGBpZmAgY2xhdXNlIChvciBzdGF0ZW1lbnQgaWYgYHRoZW5Cb2R5YCBhbmQsIG9wdGlvbmFsbHksIGBlbHNlQm9keWAgYXJlIHBhc3NlZClcbiAgaWYoY29uZGl0aW9uOiBDb2RlIHwgYm9vbGVhbiwgdGhlbkJvZHk/OiBCbG9jaywgZWxzZUJvZHk/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIHRoaXMuX2Jsb2NrTm9kZShuZXcgSWYoY29uZGl0aW9uKSlcblxuICAgIGlmICh0aGVuQm9keSAmJiBlbHNlQm9keSkge1xuICAgICAgdGhpcy5jb2RlKHRoZW5Cb2R5KS5lbHNlKCkuY29kZShlbHNlQm9keSkuZW5kSWYoKVxuICAgIH0gZWxzZSBpZiAodGhlbkJvZHkpIHtcbiAgICAgIHRoaXMuY29kZSh0aGVuQm9keSkuZW5kSWYoKVxuICAgIH0gZWxzZSBpZiAoZWxzZUJvZHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJlbHNlXCIgYm9keSB3aXRob3V0IFwidGhlblwiIGJvZHknKVxuICAgIH1cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gYGVsc2UgaWZgIGNsYXVzZSAtIGludmFsaWQgd2l0aG91dCBgaWZgIG9yIGFmdGVyIGBlbHNlYCBjbGF1c2VzXG4gIGVsc2VJZihjb25kaXRpb246IENvZGUgfCBib29sZWFuKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2Vsc2VOb2RlKG5ldyBJZihjb25kaXRpb24pKVxuICB9XG5cbiAgLy8gYGVsc2VgIGNsYXVzZSAtIG9ubHkgdmFsaWQgYWZ0ZXIgYGlmYCBvciBgZWxzZSBpZmAgY2xhdXNlc1xuICBlbHNlKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbHNlTm9kZShuZXcgRWxzZSgpKVxuICB9XG5cbiAgLy8gZW5kIGBpZmAgc3RhdGVtZW50IChuZWVkZWQgaWYgZ2VuLmlmIHdhcyB1c2VkIG9ubHkgd2l0aCBjb25kaXRpb24pXG4gIGVuZElmKCk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9lbmRCbG9ja05vZGUoSWYsIEVsc2UpXG4gIH1cblxuICBwcml2YXRlIF9mb3Iobm9kZTogRm9yLCBmb3JCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9ibG9ja05vZGUobm9kZSlcbiAgICBpZiAoZm9yQm9keSkgdGhpcy5jb2RlKGZvckJvZHkpLmVuZEZvcigpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGEgZ2VuZXJpYyBgZm9yYCBjbGF1c2UgKG9yIHN0YXRlbWVudCBpZiBgZm9yQm9keWAgaXMgcGFzc2VkKVxuICBmb3IoaXRlcmF0aW9uOiBDb2RlLCBmb3JCb2R5PzogQmxvY2spOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JMb29wKGl0ZXJhdGlvbiksIGZvckJvZHkpXG4gIH1cblxuICAvLyBgZm9yYCBzdGF0ZW1lbnQgZm9yIGEgcmFuZ2Ugb2YgdmFsdWVzXG4gIGZvclJhbmdlKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBmcm9tOiBTYWZlRXhwcixcbiAgICB0bzogU2FmZUV4cHIsXG4gICAgZm9yQm9keTogKGluZGV4OiBOYW1lKSA9PiB2b2lkLFxuICAgIHZhcktpbmQ6IENvZGUgPSB0aGlzLm9wdHMuZXM1ID8gdmFyS2luZHMudmFyIDogdmFyS2luZHMubGV0XG4gICk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIHJldHVybiB0aGlzLl9mb3IobmV3IEZvclJhbmdlKHZhcktpbmQsIG5hbWUsIGZyb20sIHRvKSwgKCkgPT4gZm9yQm9keShuYW1lKSlcbiAgfVxuXG4gIC8vIGBmb3Itb2ZgIHN0YXRlbWVudCAoaW4gZXM1IG1vZGUgcmVwbGFjZSB3aXRoIGEgbm9ybWFsIGZvciBsb29wKVxuICBmb3JPZihcbiAgICBuYW1lT3JQcmVmaXg6IE5hbWUgfCBzdHJpbmcsXG4gICAgaXRlcmFibGU6IENvZGUsXG4gICAgZm9yQm9keTogKGl0ZW06IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHZhcktpbmRzLmNvbnN0XG4gICk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9zY29wZS50b05hbWUobmFtZU9yUHJlZml4KVxuICAgIGlmICh0aGlzLm9wdHMuZXM1KSB7XG4gICAgICBjb25zdCBhcnIgPSBpdGVyYWJsZSBpbnN0YW5jZW9mIE5hbWUgPyBpdGVyYWJsZSA6IHRoaXMudmFyKFwiX2FyclwiLCBpdGVyYWJsZSlcbiAgICAgIHJldHVybiB0aGlzLmZvclJhbmdlKFwiX2lcIiwgMCwgX2Ake2Fycn0ubGVuZ3RoYCwgKGkpID0+IHtcbiAgICAgICAgdGhpcy52YXIobmFtZSwgX2Ake2Fycn1bJHtpfV1gKVxuICAgICAgICBmb3JCb2R5KG5hbWUpXG4gICAgICB9KVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZm9yKG5ldyBGb3JJdGVyKFwib2ZcIiwgdmFyS2luZCwgbmFtZSwgaXRlcmFibGUpLCAoKSA9PiBmb3JCb2R5KG5hbWUpKVxuICB9XG5cbiAgLy8gYGZvci1pbmAgc3RhdGVtZW50LlxuICAvLyBXaXRoIG9wdGlvbiBgb3duUHJvcGVydGllc2AgcmVwbGFjZWQgd2l0aCBhIGBmb3Itb2ZgIGxvb3AgZm9yIG9iamVjdCBrZXlzXG4gIGZvckluKFxuICAgIG5hbWVPclByZWZpeDogTmFtZSB8IHN0cmluZyxcbiAgICBvYmo6IENvZGUsXG4gICAgZm9yQm9keTogKGl0ZW06IE5hbWUpID0+IHZvaWQsXG4gICAgdmFyS2luZDogQ29kZSA9IHRoaXMub3B0cy5lczUgPyB2YXJLaW5kcy52YXIgOiB2YXJLaW5kcy5jb25zdFxuICApOiBDb2RlR2VuIHtcbiAgICBpZiAodGhpcy5vcHRzLm93blByb3BlcnRpZXMpIHtcbiAgICAgIHJldHVybiB0aGlzLmZvck9mKG5hbWVPclByZWZpeCwgX2BPYmplY3Qua2V5cygke29ian0pYCwgZm9yQm9keSlcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX3Njb3BlLnRvTmFtZShuYW1lT3JQcmVmaXgpXG4gICAgcmV0dXJuIHRoaXMuX2ZvcihuZXcgRm9ySXRlcihcImluXCIsIHZhcktpbmQsIG5hbWUsIG9iaiksICgpID0+IGZvckJvZHkobmFtZSkpXG4gIH1cblxuICAvLyBlbmQgYGZvcmAgbG9vcFxuICBlbmRGb3IoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGb3IpXG4gIH1cblxuICAvLyBgbGFiZWxgIHN0YXRlbWVudFxuICBsYWJlbChsYWJlbDogTmFtZSk6IENvZGVHZW4ge1xuICAgIHJldHVybiB0aGlzLl9sZWFmTm9kZShuZXcgTGFiZWwobGFiZWwpKVxuICB9XG5cbiAgLy8gYGJyZWFrYCBzdGF0ZW1lbnRcbiAgYnJlYWsobGFiZWw/OiBDb2RlKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2xlYWZOb2RlKG5ldyBCcmVhayhsYWJlbCkpXG4gIH1cblxuICAvLyBgcmV0dXJuYCBzdGF0ZW1lbnRcbiAgcmV0dXJuKHZhbHVlOiBCbG9jayB8IFNhZmVFeHByKTogQ29kZUdlbiB7XG4gICAgY29uc3Qgbm9kZSA9IG5ldyBSZXR1cm4oKVxuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIHRoaXMuY29kZSh2YWx1ZSlcbiAgICBpZiAobm9kZS5ub2Rlcy5sZW5ndGggIT09IDEpIHRocm93IG5ldyBFcnJvcignQ29kZUdlbjogXCJyZXR1cm5cIiBzaG91bGQgaGF2ZSBvbmUgbm9kZScpXG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShSZXR1cm4pXG4gIH1cblxuICAvLyBgdHJ5YCBzdGF0ZW1lbnRcbiAgdHJ5KHRyeUJvZHk6IEJsb2NrLCBjYXRjaENvZGU/OiAoZTogTmFtZSkgPT4gdm9pZCwgZmluYWxseUNvZGU/OiBCbG9jayk6IENvZGVHZW4ge1xuICAgIGlmICghY2F0Y2hDb2RlICYmICFmaW5hbGx5Q29kZSkgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcInRyeVwiIHdpdGhvdXQgXCJjYXRjaFwiIGFuZCBcImZpbmFsbHlcIicpXG4gICAgY29uc3Qgbm9kZSA9IG5ldyBUcnkoKVxuICAgIHRoaXMuX2Jsb2NrTm9kZShub2RlKVxuICAgIHRoaXMuY29kZSh0cnlCb2R5KVxuICAgIGlmIChjYXRjaENvZGUpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5uYW1lKFwiZVwiKVxuICAgICAgdGhpcy5fY3Vyck5vZGUgPSBub2RlLmNhdGNoID0gbmV3IENhdGNoKGVycm9yKVxuICAgICAgY2F0Y2hDb2RlKGVycm9yKVxuICAgIH1cbiAgICBpZiAoZmluYWxseUNvZGUpIHtcbiAgICAgIHRoaXMuX2N1cnJOb2RlID0gbm9kZS5maW5hbGx5ID0gbmV3IEZpbmFsbHkoKVxuICAgICAgdGhpcy5jb2RlKGZpbmFsbHlDb2RlKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZW5kQmxvY2tOb2RlKENhdGNoLCBGaW5hbGx5KVxuICB9XG5cbiAgLy8gYHRocm93YCBzdGF0ZW1lbnRcbiAgdGhyb3coZXJyb3I6IENvZGUpOiBDb2RlR2VuIHtcbiAgICByZXR1cm4gdGhpcy5fbGVhZk5vZGUobmV3IFRocm93KGVycm9yKSlcbiAgfVxuXG4gIC8vIHN0YXJ0IHNlbGYtYmFsYW5jaW5nIGJsb2NrXG4gIGJsb2NrKGJvZHk/OiBCbG9jaywgbm9kZUNvdW50PzogbnVtYmVyKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tTdGFydHMucHVzaCh0aGlzLl9ub2Rlcy5sZW5ndGgpXG4gICAgaWYgKGJvZHkpIHRoaXMuY29kZShib2R5KS5lbmRCbG9jayhub2RlQ291bnQpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGVuZCB0aGUgY3VycmVudCBzZWxmLWJhbGFuY2luZyBibG9ja1xuICBlbmRCbG9jayhub2RlQ291bnQ/OiBudW1iZXIpOiBDb2RlR2VuIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLl9ibG9ja1N0YXJ0cy5wb3AoKVxuICAgIGlmIChsZW4gPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiQ29kZUdlbjogbm90IGluIHNlbGYtYmFsYW5jaW5nIGJsb2NrXCIpXG4gICAgY29uc3QgdG9DbG9zZSA9IHRoaXMuX25vZGVzLmxlbmd0aCAtIGxlblxuICAgIGlmICh0b0Nsb3NlIDwgMCB8fCAobm9kZUNvdW50ICE9PSB1bmRlZmluZWQgJiYgdG9DbG9zZSAhPT0gbm9kZUNvdW50KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb2RlR2VuOiB3cm9uZyBudW1iZXIgb2Ygbm9kZXM6ICR7dG9DbG9zZX0gdnMgJHtub2RlQ291bnR9IGV4cGVjdGVkYClcbiAgICB9XG4gICAgdGhpcy5fbm9kZXMubGVuZ3RoID0gbGVuXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGBmdW5jdGlvbmAgaGVhZGluZyAob3IgZGVmaW5pdGlvbiBpZiBmdW5jQm9keSBpcyBwYXNzZWQpXG4gIGZ1bmMobmFtZTogTmFtZSwgYXJnczogQ29kZSA9IG5pbCwgYXN5bmM/OiBib29sZWFuLCBmdW5jQm9keT86IEJsb2NrKTogQ29kZUdlbiB7XG4gICAgdGhpcy5fYmxvY2tOb2RlKG5ldyBGdW5jKG5hbWUsIGFyZ3MsIGFzeW5jKSlcbiAgICBpZiAoZnVuY0JvZHkpIHRoaXMuY29kZShmdW5jQm9keSkuZW5kRnVuYygpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIC8vIGVuZCBmdW5jdGlvbiBkZWZpbml0aW9uXG4gIGVuZEZ1bmMoKTogQ29kZUdlbiB7XG4gICAgcmV0dXJuIHRoaXMuX2VuZEJsb2NrTm9kZShGdW5jKVxuICB9XG5cbiAgb3B0aW1pemUobiA9IDEpOiB2b2lkIHtcbiAgICB3aGlsZSAobi0tID4gMCkge1xuICAgICAgdGhpcy5fcm9vdC5vcHRpbWl6ZU5vZGVzKClcbiAgICAgIHRoaXMuX3Jvb3Qub3B0aW1pemVOYW1lcyh0aGlzLl9yb290Lm5hbWVzLCB0aGlzLl9jb25zdGFudHMpXG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfbGVhZk5vZGUobm9kZTogTGVhZk5vZGUpOiBDb2RlR2VuIHtcbiAgICB0aGlzLl9jdXJyTm9kZS5ub2Rlcy5wdXNoKG5vZGUpXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHByaXZhdGUgX2Jsb2NrTm9kZShub2RlOiBTdGFydEJsb2NrTm9kZSk6IHZvaWQge1xuICAgIHRoaXMuX2N1cnJOb2RlLm5vZGVzLnB1c2gobm9kZSlcbiAgICB0aGlzLl9ub2Rlcy5wdXNoKG5vZGUpXG4gIH1cblxuICBwcml2YXRlIF9lbmRCbG9ja05vZGUoTjE6IEVuZEJsb2NrTm9kZVR5cGUsIE4yPzogRW5kQmxvY2tOb2RlVHlwZSk6IENvZGVHZW4ge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9jdXJyTm9kZVxuICAgIGlmIChuIGluc3RhbmNlb2YgTjEgfHwgKE4yICYmIG4gaW5zdGFuY2VvZiBOMikpIHtcbiAgICAgIHRoaXMuX25vZGVzLnBvcCgpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvZGVHZW46IG5vdCBpbiBibG9jayBcIiR7TjIgPyBgJHtOMS5raW5kfS8ke04yLmtpbmR9YCA6IE4xLmtpbmR9XCJgKVxuICB9XG5cbiAgcHJpdmF0ZSBfZWxzZU5vZGUobm9kZTogSWYgfCBFbHNlKTogQ29kZUdlbiB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2N1cnJOb2RlXG4gICAgaWYgKCEobiBpbnN0YW5jZW9mIElmKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb2RlR2VuOiBcImVsc2VcIiB3aXRob3V0IFwiaWZcIicpXG4gICAgfVxuICAgIHRoaXMuX2N1cnJOb2RlID0gbi5lbHNlID0gbm9kZVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBwcml2YXRlIGdldCBfcm9vdCgpOiBSb290IHtcbiAgICByZXR1cm4gdGhpcy5fbm9kZXNbMF0gYXMgUm9vdFxuICB9XG5cbiAgcHJpdmF0ZSBnZXQgX2N1cnJOb2RlKCk6IFBhcmVudE5vZGUge1xuICAgIGNvbnN0IG5zID0gdGhpcy5fbm9kZXNcbiAgICByZXR1cm4gbnNbbnMubGVuZ3RoIC0gMV1cbiAgfVxuXG4gIHByaXZhdGUgc2V0IF9jdXJyTm9kZShub2RlOiBQYXJlbnROb2RlKSB7XG4gICAgY29uc3QgbnMgPSB0aGlzLl9ub2Rlc1xuICAgIG5zW25zLmxlbmd0aCAtIDFdID0gbm9kZVxuICB9XG5cbiAgLy8gZ2V0IG5vZGVDb3VudCgpOiBudW1iZXIge1xuICAvLyAgIHJldHVybiB0aGlzLl9yb290LmNvdW50XG4gIC8vIH1cbn1cblxuZnVuY3Rpb24gYWRkTmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogVXNlZE5hbWVzKTogVXNlZE5hbWVzIHtcbiAgZm9yIChjb25zdCBuIGluIGZyb20pIG5hbWVzW25dID0gKG5hbWVzW25dIHx8IDApICsgKGZyb21bbl0gfHwgMClcbiAgcmV0dXJuIG5hbWVzXG59XG5cbmZ1bmN0aW9uIGFkZEV4cHJOYW1lcyhuYW1lczogVXNlZE5hbWVzLCBmcm9tOiBTYWZlRXhwcik6IFVzZWROYW1lcyB7XG4gIHJldHVybiBmcm9tIGluc3RhbmNlb2YgX0NvZGVPck5hbWUgPyBhZGROYW1lcyhuYW1lcywgZnJvbS5uYW1lcykgOiBuYW1lc1xufVxuXG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHI8VCBleHRlbmRzIFNhZmVFeHByIHwgQ29kZT4oZXhwcjogVCwgbmFtZXM6IFVzZWROYW1lcywgY29uc3RhbnRzOiBDb25zdGFudHMpOiBUXG5mdW5jdGlvbiBvcHRpbWl6ZUV4cHIoZXhwcjogU2FmZUV4cHIsIG5hbWVzOiBVc2VkTmFtZXMsIGNvbnN0YW50czogQ29uc3RhbnRzKTogU2FmZUV4cHIge1xuICBpZiAoZXhwciBpbnN0YW5jZW9mIE5hbWUpIHJldHVybiByZXBsYWNlTmFtZShleHByKVxuICBpZiAoIWNhbk9wdGltaXplKGV4cHIpKSByZXR1cm4gZXhwclxuICByZXR1cm4gbmV3IF9Db2RlKFxuICAgIGV4cHIuX2l0ZW1zLnJlZHVjZSgoaXRlbXM6IENvZGVJdGVtW10sIGM6IFNhZmVFeHByIHwgc3RyaW5nKSA9PiB7XG4gICAgICBpZiAoYyBpbnN0YW5jZW9mIE5hbWUpIGMgPSByZXBsYWNlTmFtZShjKVxuICAgICAgaWYgKGMgaW5zdGFuY2VvZiBfQ29kZSkgaXRlbXMucHVzaCguLi5jLl9pdGVtcylcbiAgICAgIGVsc2UgaXRlbXMucHVzaChjKVxuICAgICAgcmV0dXJuIGl0ZW1zXG4gICAgfSwgW10pXG4gIClcblxuICBmdW5jdGlvbiByZXBsYWNlTmFtZShuOiBOYW1lKTogU2FmZUV4cHIge1xuICAgIGNvbnN0IGMgPSBjb25zdGFudHNbbi5zdHJdXG4gICAgaWYgKGMgPT09IHVuZGVmaW5lZCB8fCBuYW1lc1tuLnN0cl0gIT09IDEpIHJldHVybiBuXG4gICAgZGVsZXRlIG5hbWVzW24uc3RyXVxuICAgIHJldHVybiBjXG4gIH1cblxuICBmdW5jdGlvbiBjYW5PcHRpbWl6ZShlOiBTYWZlRXhwcik6IGUgaXMgX0NvZGUge1xuICAgIHJldHVybiAoXG4gICAgICBlIGluc3RhbmNlb2YgX0NvZGUgJiZcbiAgICAgIGUuX2l0ZW1zLnNvbWUoXG4gICAgICAgIChjKSA9PiBjIGluc3RhbmNlb2YgTmFtZSAmJiBuYW1lc1tjLnN0cl0gPT09IDEgJiYgY29uc3RhbnRzW2Muc3RyXSAhPT0gdW5kZWZpbmVkXG4gICAgICApXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnRyYWN0TmFtZXMobmFtZXM6IFVzZWROYW1lcywgZnJvbTogVXNlZE5hbWVzKTogdm9pZCB7XG4gIGZvciAoY29uc3QgbiBpbiBmcm9tKSBuYW1lc1tuXSA9IChuYW1lc1tuXSB8fCAwKSAtIChmcm9tW25dIHx8IDApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub3Q8VCBleHRlbmRzIENvZGUgfCBTYWZlRXhwcj4oeDogVCk6IFRcbmV4cG9ydCBmdW5jdGlvbiBub3QoeDogQ29kZSB8IFNhZmVFeHByKTogQ29kZSB8IFNhZmVFeHByIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09IFwiYm9vbGVhblwiIHx8IHR5cGVvZiB4ID09IFwibnVtYmVyXCIgfHwgeCA9PT0gbnVsbCA/ICF4IDogX2AhJHtwYXIoeCl9YFxufVxuXG5jb25zdCBhbmRDb2RlID0gbWFwcGVuZChvcGVyYXRvcnMuQU5EKVxuXG4vLyBib29sZWFuIEFORCAoJiYpIGV4cHJlc3Npb24gd2l0aCB0aGUgcGFzc2VkIGFyZ3VtZW50c1xuZXhwb3J0IGZ1bmN0aW9uIGFuZCguLi5hcmdzOiBDb2RlW10pOiBDb2RlIHtcbiAgcmV0dXJuIGFyZ3MucmVkdWNlKGFuZENvZGUpXG59XG5cbmNvbnN0IG9yQ29kZSA9IG1hcHBlbmQob3BlcmF0b3JzLk9SKVxuXG4vLyBib29sZWFuIE9SICh8fCkgZXhwcmVzc2lvbiB3aXRoIHRoZSBwYXNzZWQgYXJndW1lbnRzXG5leHBvcnQgZnVuY3Rpb24gb3IoLi4uYXJnczogQ29kZVtdKTogQ29kZSB7XG4gIHJldHVybiBhcmdzLnJlZHVjZShvckNvZGUpXG59XG5cbnR5cGUgTUFwcGVuZCA9ICh4OiBDb2RlLCB5OiBDb2RlKSA9PiBDb2RlXG5cbmZ1bmN0aW9uIG1hcHBlbmQob3A6IENvZGUpOiBNQXBwZW5kIHtcbiAgcmV0dXJuICh4LCB5KSA9PiAoeCA9PT0gbmlsID8geSA6IHkgPT09IG5pbCA/IHggOiBfYCR7cGFyKHgpfSAke29wfSAke3Bhcih5KX1gKVxufVxuXG5mdW5jdGlvbiBwYXIoeDogQ29kZSk6IENvZGUge1xuICByZXR1cm4geCBpbnN0YW5jZW9mIE5hbWUgPyB4IDogX2AoJHt4fSlgXG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYSwgRXZhbHVhdGVkUHJvcGVydGllcywgRXZhbHVhdGVkSXRlbXN9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIENvZGUsIE5hbWUsIENvZGVHZW59IGZyb20gXCIuL2NvZGVnZW5cIlxuaW1wb3J0IHtfQ29kZX0gZnJvbSBcIi4vY29kZWdlbi9jb2RlXCJcbmltcG9ydCB0eXBlIHtSdWxlLCBWYWxpZGF0aW9uUnVsZXN9IGZyb20gXCIuL3J1bGVzXCJcblxuLy8gVE9ETyByZWZhY3RvciB0byB1c2UgU2V0XG5leHBvcnQgZnVuY3Rpb24gdG9IYXNoPFQgZXh0ZW5kcyBzdHJpbmcgPSBzdHJpbmc+KGFycjogVFtdKToge1tLIGluIFRdPzogdHJ1ZX0ge1xuICBjb25zdCBoYXNoOiB7W0sgaW4gVF0/OiB0cnVlfSA9IHt9XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIGhhc2hbaXRlbV0gPSB0cnVlXG4gIHJldHVybiBoYXNoXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbHdheXNWYWxpZFNjaGVtYShpdDogU2NoZW1hQ3h0LCBzY2hlbWE6IEFueVNjaGVtYSk6IGJvb2xlYW4gfCB2b2lkIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiBzY2hlbWFcbiAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYSkubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZVxuICBjaGVja1Vua25vd25SdWxlcyhpdCwgc2NoZW1hKVxuICByZXR1cm4gIXNjaGVtYUhhc1J1bGVzKHNjaGVtYSwgaXQuc2VsZi5SVUxFUy5hbGwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Vua25vd25SdWxlcyhpdDogU2NoZW1hQ3h0LCBzY2hlbWE6IEFueVNjaGVtYSA9IGl0LnNjaGVtYSk6IHZvaWQge1xuICBjb25zdCB7b3B0cywgc2VsZn0gPSBpdFxuICBpZiAoIW9wdHMuc3RyaWN0U2NoZW1hKSByZXR1cm5cbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSByZXR1cm5cbiAgY29uc3QgcnVsZXMgPSBzZWxmLlJVTEVTLmtleXdvcmRzXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmICghcnVsZXNba2V5XSkgY2hlY2tTdHJpY3RNb2RlKGl0LCBgdW5rbm93biBrZXl3b3JkOiBcIiR7a2V5fVwiYClcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXMoXG4gIHNjaGVtYTogQW55U2NoZW1hLFxuICBydWxlczoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW4gfCBSdWxlfVxuKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChydWxlc1trZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYTogQW55U2NoZW1hLCBSVUxFUzogVmFsaWRhdGlvblJ1bGVzKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChrZXkgIT09IFwiJHJlZlwiICYmIFJVTEVTLmFsbFtrZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNjaGVtYVJlZk9yVmFsKFxuICB7dG9wU2NoZW1hUmVmLCBzY2hlbWFQYXRofTogU2NoZW1hT2JqQ3h0LFxuICBzY2hlbWE6IHVua25vd24sXG4gIGtleXdvcmQ6IHN0cmluZyxcbiAgJGRhdGE/OiBzdHJpbmcgfCBmYWxzZVxuKTogQ29kZSB8IG51bWJlciB8IGJvb2xlYW4ge1xuICBpZiAoISRkYXRhKSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJudW1iZXJcIiB8fCB0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gc2NoZW1hXG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIikgcmV0dXJuIF9gJHtzY2hlbWF9YFxuICB9XG4gIHJldHVybiBfYCR7dG9wU2NoZW1hUmVmfSR7c2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfWBcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlRnJhZ21lbnQoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gdW5lc2NhcGVKc29uUG9pbnRlcihkZWNvZGVVUklDb21wb25lbnQoc3RyKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZUZyYWdtZW50KHN0cjogc3RyaW5nIHwgbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChlc2NhcGVKc29uUG9pbnRlcihzdHIpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXNjYXBlSnNvblBvaW50ZXIoc3RyOiBzdHJpbmcgfCBudW1iZXIpOiBzdHJpbmcge1xuICBpZiAodHlwZW9mIHN0ciA9PSBcIm51bWJlclwiKSByZXR1cm4gYCR7c3RyfWBcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFwvL2csIFwifjFcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVuZXNjYXBlSnNvblBvaW50ZXIoc3RyOiBzdHJpbmcpOiBzdHJpbmcge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34xL2csIFwiL1wiKS5yZXBsYWNlKC9+MC9nLCBcIn5cIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVhY2hJdGVtPFQ+KHhzOiBUIHwgVFtdLCBmOiAoeDogVCkgPT4gdm9pZCk6IHZvaWQge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4cykpIHtcbiAgICBmb3IgKGNvbnN0IHggb2YgeHMpIGYoeClcbiAgfSBlbHNlIHtcbiAgICBmKHhzKVxuICB9XG59XG5cbnR5cGUgU29tZUV2YWx1YXRlZCA9IEV2YWx1YXRlZFByb3BlcnRpZXMgfCBFdmFsdWF0ZWRJdGVtc1xuXG50eXBlIE1lcmdlRXZhbHVhdGVkRnVuYzxUIGV4dGVuZHMgU29tZUV2YWx1YXRlZD4gPSAoXG4gIGdlbjogQ29kZUdlbixcbiAgZnJvbTogTmFtZSB8IFQsXG4gIHRvOiBOYW1lIHwgRXhjbHVkZTxULCB0cnVlPiB8IHVuZGVmaW5lZCxcbiAgdG9OYW1lPzogdHlwZW9mIE5hbWVcbikgPT4gTmFtZSB8IFRcblxuaW50ZXJmYWNlIE1ha2VNZXJnZUZ1bmNBcmdzPFQgZXh0ZW5kcyBTb21lRXZhbHVhdGVkPiB7XG4gIG1lcmdlTmFtZXM6IChnZW46IENvZGVHZW4sIGZyb206IE5hbWUsIHRvOiBOYW1lKSA9PiB2b2lkXG4gIG1lcmdlVG9OYW1lOiAoZ2VuOiBDb2RlR2VuLCBmcm9tOiBULCB0bzogTmFtZSkgPT4gdm9pZFxuICBtZXJnZVZhbHVlczogKGZyb206IFQsIHRvOiBFeGNsdWRlPFQsIHRydWU+KSA9PiBUXG4gIHJlc3VsdFRvTmFtZTogKGdlbjogQ29kZUdlbiwgcmVzPzogVCkgPT4gTmFtZVxufVxuXG5mdW5jdGlvbiBtYWtlTWVyZ2VFdmFsdWF0ZWQ8VCBleHRlbmRzIFNvbWVFdmFsdWF0ZWQ+KHtcbiAgbWVyZ2VOYW1lcyxcbiAgbWVyZ2VUb05hbWUsXG4gIG1lcmdlVmFsdWVzLFxuICByZXN1bHRUb05hbWUsXG59OiBNYWtlTWVyZ2VGdW5jQXJnczxUPik6IE1lcmdlRXZhbHVhdGVkRnVuYzxUPiB7XG4gIHJldHVybiAoZ2VuLCBmcm9tLCB0bywgdG9OYW1lKSA9PiB7XG4gICAgY29uc3QgcmVzID1cbiAgICAgIHRvID09PSB1bmRlZmluZWRcbiAgICAgICAgPyBmcm9tXG4gICAgICAgIDogdG8gaW5zdGFuY2VvZiBOYW1lXG4gICAgICAgID8gKGZyb20gaW5zdGFuY2VvZiBOYW1lID8gbWVyZ2VOYW1lcyhnZW4sIGZyb20sIHRvKSA6IG1lcmdlVG9OYW1lKGdlbiwgZnJvbSwgdG8pLCB0bylcbiAgICAgICAgOiBmcm9tIGluc3RhbmNlb2YgTmFtZVxuICAgICAgICA/IChtZXJnZVRvTmFtZShnZW4sIHRvLCBmcm9tKSwgZnJvbSlcbiAgICAgICAgOiBtZXJnZVZhbHVlcyhmcm9tLCB0bylcbiAgICByZXR1cm4gdG9OYW1lID09PSBOYW1lICYmICEocmVzIGluc3RhbmNlb2YgTmFtZSkgPyByZXN1bHRUb05hbWUoZ2VuLCByZXMpIDogcmVzXG4gIH1cbn1cblxuaW50ZXJmYWNlIE1lcmdlRXZhbHVhdGVkIHtcbiAgcHJvcHM6IE1lcmdlRXZhbHVhdGVkRnVuYzxFdmFsdWF0ZWRQcm9wZXJ0aWVzPlxuICBpdGVtczogTWVyZ2VFdmFsdWF0ZWRGdW5jPEV2YWx1YXRlZEl0ZW1zPlxufVxuXG5leHBvcnQgY29uc3QgbWVyZ2VFdmFsdWF0ZWQ6IE1lcmdlRXZhbHVhdGVkID0ge1xuICBwcm9wczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+IHtcbiAgICAgICAgZ2VuLmlmKFxuICAgICAgICAgIF9gJHtmcm9tfSA9PT0gdHJ1ZWAsXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbih0bywgdHJ1ZSksXG4gICAgICAgICAgKCkgPT4gZ2VuLmFzc2lnbih0bywgX2Ake3RvfSB8fCB7fWApLmNvZGUoX2BPYmplY3QuYXNzaWduKCR7dG99LCAke2Zyb219KWApXG4gICAgICAgIClcbiAgICAgIH0pLFxuICAgIG1lcmdlVG9OYW1lOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlYCwgKCkgPT4ge1xuICAgICAgICBpZiAoZnJvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGdlbi5hc3NpZ24odG8sIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih0bywgX2Ake3RvfSB8fCB7fWApXG4gICAgICAgICAgc2V0RXZhbHVhdGVkKGdlbiwgdG8sIGZyb20pXG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgIG1lcmdlVmFsdWVzOiAoZnJvbSwgdG8pID0+IChmcm9tID09PSB0cnVlID8gdHJ1ZSA6IHsuLi5mcm9tLCAuLi50b30pLFxuICAgIHJlc3VsdFRvTmFtZTogZXZhbHVhdGVkUHJvcHNUb05hbWUsXG4gIH0pLFxuICBpdGVtczogbWFrZU1lcmdlRXZhbHVhdGVkKHtcbiAgICBtZXJnZU5hbWVzOiAoZ2VuLCBmcm9tLCB0bykgPT5cbiAgICAgIGdlbi5pZihfYCR7dG99ICE9PSB0cnVlICYmICR7ZnJvbX0gIT09IHVuZGVmaW5lZGAsICgpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odG8sIF9gJHtmcm9tfSA9PT0gdHJ1ZSA/IHRydWUgOiAke3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKVxuICAgICAgKSxcbiAgICBtZXJnZVRvTmFtZTogKGdlbiwgZnJvbSwgdG8pID0+XG4gICAgICBnZW4uaWYoX2Ake3RvfSAhPT0gdHJ1ZWAsICgpID0+XG4gICAgICAgIGdlbi5hc3NpZ24odG8sIGZyb20gPT09IHRydWUgPyB0cnVlIDogX2Ake3RvfSA+ICR7ZnJvbX0gPyAke3RvfSA6ICR7ZnJvbX1gKVxuICAgICAgKSxcbiAgICBtZXJnZVZhbHVlczogKGZyb20sIHRvKSA9PiAoZnJvbSA9PT0gdHJ1ZSA/IHRydWUgOiBNYXRoLm1heChmcm9tLCB0bykpLFxuICAgIHJlc3VsdFRvTmFtZTogKGdlbiwgaXRlbXMpID0+IGdlbi52YXIoXCJpdGVtc1wiLCBpdGVtcyksXG4gIH0pLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXZhbHVhdGVkUHJvcHNUb05hbWUoZ2VuOiBDb2RlR2VuLCBwcz86IEV2YWx1YXRlZFByb3BlcnRpZXMpOiBOYW1lIHtcbiAgaWYgKHBzID09PSB0cnVlKSByZXR1cm4gZ2VuLnZhcihcInByb3BzXCIsIHRydWUpXG4gIGNvbnN0IHByb3BzID0gZ2VuLnZhcihcInByb3BzXCIsIF9ge31gKVxuICBpZiAocHMgIT09IHVuZGVmaW5lZCkgc2V0RXZhbHVhdGVkKGdlbiwgcHJvcHMsIHBzKVxuICByZXR1cm4gcHJvcHNcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldEV2YWx1YXRlZChnZW46IENvZGVHZW4sIHByb3BzOiBOYW1lLCBwczoge1tLIGluIHN0cmluZ10/OiB0cnVlfSk6IHZvaWQge1xuICBPYmplY3Qua2V5cyhwcykuZm9yRWFjaCgocCkgPT4gZ2VuLmFzc2lnbihfYCR7cHJvcHN9JHtnZXRQcm9wZXJ0eShwKX1gLCB0cnVlKSlcbn1cblxuY29uc3Qgc25pcHBldHM6IHtbUyBpbiBzdHJpbmddPzogX0NvZGV9ID0ge31cblxuZXhwb3J0IGZ1bmN0aW9uIHVzZUZ1bmMoZ2VuOiBDb2RlR2VuLCBmOiB7Y29kZTogc3RyaW5nfSk6IE5hbWUge1xuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJmdW5jXCIsIHtcbiAgICByZWY6IGYsXG4gICAgY29kZTogc25pcHBldHNbZi5jb2RlXSB8fCAoc25pcHBldHNbZi5jb2RlXSA9IG5ldyBfQ29kZShmLmNvZGUpKSxcbiAgfSlcbn1cblxuZXhwb3J0IGVudW0gVHlwZSB7XG4gIE51bSxcbiAgU3RyLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JQYXRoKFxuICBkYXRhUHJvcDogTmFtZSB8IHN0cmluZyB8IG51bWJlcixcbiAgZGF0YVByb3BUeXBlPzogVHlwZSxcbiAganNQcm9wZXJ0eVN5bnRheD86IGJvb2xlYW5cbik6IENvZGUgfCBzdHJpbmcge1xuICAvLyBsZXQgcGF0aFxuICBpZiAoZGF0YVByb3AgaW5zdGFuY2VvZiBOYW1lKSB7XG4gICAgY29uc3QgaXNOdW1iZXIgPSBkYXRhUHJvcFR5cGUgPT09IFR5cGUuTnVtXG4gICAgcmV0dXJuIGpzUHJvcGVydHlTeW50YXhcbiAgICAgID8gaXNOdW1iZXJcbiAgICAgICAgPyBfYFwiW1wiICsgJHtkYXRhUHJvcH0gKyBcIl1cImBcbiAgICAgICAgOiBfYFwiWydcIiArICR7ZGF0YVByb3B9ICsgXCInXVwiYFxuICAgICAgOiBpc051bWJlclxuICAgICAgPyBfYFwiL1wiICsgJHtkYXRhUHJvcH1gXG4gICAgICA6IF9gXCIvXCIgKyAke2RhdGFQcm9wfS5yZXBsYWNlKC9+L2csIFwifjBcIikucmVwbGFjZSgvXFxcXC8vZywgXCJ+MVwiKWAgLy8gVE9ETyBtYXliZSB1c2UgZ2xvYmFsIGVzY2FwZVBvaW50ZXJcbiAgfVxuICByZXR1cm4ganNQcm9wZXJ0eVN5bnRheCA/IGdldFByb3BlcnR5KGRhdGFQcm9wKS50b1N0cmluZygpIDogXCIvXCIgKyBlc2NhcGVKc29uUG9pbnRlcihkYXRhUHJvcClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrU3RyaWN0TW9kZShcbiAgaXQ6IFNjaGVtYUN4dCxcbiAgbXNnOiBzdHJpbmcsXG4gIG1vZGU6IGJvb2xlYW4gfCBcImxvZ1wiID0gaXQub3B0cy5zdHJpY3RTY2hlbWFcbik6IHZvaWQge1xuICBpZiAoIW1vZGUpIHJldHVyblxuICBtc2cgPSBgc3RyaWN0IG1vZGU6ICR7bXNnfWBcbiAgaWYgKG1vZGUgPT09IHRydWUpIHRocm93IG5ldyBFcnJvcihtc2cpXG4gIGl0LnNlbGYubG9nZ2VyLndhcm4obXNnKVxufVxuIiwgImltcG9ydCB7TmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5cbmNvbnN0IG5hbWVzID0ge1xuICAvLyB2YWxpZGF0aW9uIGZ1bmN0aW9uIGFyZ3VtZW50c1xuICBkYXRhOiBuZXcgTmFtZShcImRhdGFcIiksIC8vIGRhdGEgcGFzc2VkIHRvIHZhbGlkYXRpb24gZnVuY3Rpb25cbiAgLy8gYXJncyBwYXNzZWQgZnJvbSByZWZlcmVuY2luZyBzY2hlbWFcbiAgdmFsQ3h0OiBuZXcgTmFtZShcInZhbEN4dFwiKSwgLy8gdmFsaWRhdGlvbi9kYXRhIGNvbnRleHQgLSBzaG91bGQgbm90IGJlIHVzZWQgZGlyZWN0bHksIGl0IGlzIGRlc3RydWN0dXJlZCB0byB0aGUgbmFtZXMgYmVsb3dcbiAgaW5zdGFuY2VQYXRoOiBuZXcgTmFtZShcImluc3RhbmNlUGF0aFwiKSxcbiAgcGFyZW50RGF0YTogbmV3IE5hbWUoXCJwYXJlbnREYXRhXCIpLFxuICBwYXJlbnREYXRhUHJvcGVydHk6IG5ldyBOYW1lKFwicGFyZW50RGF0YVByb3BlcnR5XCIpLFxuICByb290RGF0YTogbmV3IE5hbWUoXCJyb290RGF0YVwiKSwgLy8gcm9vdCBkYXRhIC0gc2FtZSBhcyB0aGUgZGF0YSBwYXNzZWQgdG8gdGhlIGZpcnN0L3RvcCB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGR5bmFtaWNBbmNob3JzOiBuZXcgTmFtZShcImR5bmFtaWNBbmNob3JzXCIpLCAvLyB1c2VkIHRvIHN1cHBvcnQgcmVjdXJzaXZlUmVmIGFuZCBkeW5hbWljUmVmXG4gIC8vIGZ1bmN0aW9uIHNjb3BlZCB2YXJpYWJsZXNcbiAgdkVycm9yczogbmV3IE5hbWUoXCJ2RXJyb3JzXCIpLCAvLyBudWxsIG9yIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gIGVycm9yczogbmV3IE5hbWUoXCJlcnJvcnNcIiksIC8vIGNvdW50ZXIgb2YgdmFsaWRhdGlvbiBlcnJvcnNcbiAgdGhpczogbmV3IE5hbWUoXCJ0aGlzXCIpLFxuICAvLyBcImdsb2JhbHNcIlxuICBzZWxmOiBuZXcgTmFtZShcInNlbGZcIiksXG4gIHNjb3BlOiBuZXcgTmFtZShcInNjb3BlXCIpLFxuICAvLyBKVEQgc2VyaWFsaXplL3BhcnNlIG5hbWUgZm9yIEpTT04gc3RyaW5nIGFuZCBwb3NpdGlvblxuICBqc29uOiBuZXcgTmFtZShcImpzb25cIiksXG4gIGpzb25Qb3M6IG5ldyBOYW1lKFwianNvblBvc1wiKSxcbiAganNvbkxlbjogbmV3IE5hbWUoXCJqc29uTGVuXCIpLFxuICBqc29uUGFydDogbmV3IE5hbWUoXCJqc29uUGFydFwiKSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmFtZXNcbiIsICJpbXBvcnQgdHlwZSB7S2V5d29yZEVycm9yQ3h0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYUN4dH0gZnJvbSBcIi4vaW5kZXhcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBzdHIsIHN0ckNvbmNhdCwgQ29kZSwgTmFtZX0gZnJvbSBcIi4vY29kZWdlblwiXG5pbXBvcnQge1NhZmVFeHByfSBmcm9tIFwiLi9jb2RlZ2VuL2NvZGVcIlxuaW1wb3J0IHtnZXRFcnJvclBhdGgsIFR5cGV9IGZyb20gXCIuL3V0aWxcIlxuaW1wb3J0IE4gZnJvbSBcIi4vbmFtZXNcIlxuXG5leHBvcnQgY29uc3Qga2V5d29yZEVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe2tleXdvcmR9KSA9PiBzdHJgbXVzdCBwYXNzIFwiJHtrZXl3b3JkfVwiIGtleXdvcmQgdmFsaWRhdGlvbmAsXG59XG5cbmV4cG9ydCBjb25zdCBrZXl3b3JkJERhdGFFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkLCBzY2hlbWFUeXBlfSkgPT5cbiAgICBzY2hlbWFUeXBlXG4gICAgICA/IHN0cmBcIiR7a2V5d29yZH1cIiBrZXl3b3JkIG11c3QgYmUgJHtzY2hlbWFUeXBlfSAoJGRhdGEpYFxuICAgICAgOiBzdHJgXCIke2tleXdvcmR9XCIga2V5d29yZCBpcyBpbnZhbGlkICgkZGF0YSlgLFxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yUGF0aHMge1xuICBpbnN0YW5jZVBhdGg/OiBDb2RlXG4gIHNjaGVtYVBhdGg/OiBzdHJpbmdcbiAgcGFyZW50U2NoZW1hPzogYm9vbGVhblxufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwb3J0RXJyb3IoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IGtleXdvcmRFcnJvcixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHMsXG4gIG92ZXJyaWRlQWxsRXJyb3JzPzogYm9vbGVhblxuKTogdm9pZCB7XG4gIGNvbnN0IHtpdH0gPSBjeHRcbiAgY29uc3Qge2dlbiwgY29tcG9zaXRlUnVsZSwgYWxsRXJyb3JzfSA9IGl0XG4gIGNvbnN0IGVyck9iaiA9IGVycm9yT2JqZWN0Q29kZShjeHQsIGVycm9yLCBlcnJvclBhdGhzKVxuICBpZiAob3ZlcnJpZGVBbGxFcnJvcnMgPz8gKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgIGFkZEVycm9yKGdlbiwgZXJyT2JqKVxuICB9IGVsc2Uge1xuICAgIHJldHVybkVycm9ycyhpdCwgX2BbJHtlcnJPYmp9XWApXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydEV4dHJhRXJyb3IoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IGtleXdvcmRFcnJvcixcbiAgZXJyb3JQYXRocz86IEVycm9yUGF0aHNcbik6IHZvaWQge1xuICBjb25zdCB7aXR9ID0gY3h0XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGFsbEVycm9yc30gPSBpdFxuICBjb25zdCBlcnJPYmogPSBlcnJvck9iamVjdENvZGUoY3h0LCBlcnJvciwgZXJyb3JQYXRocylcbiAgYWRkRXJyb3IoZ2VuLCBlcnJPYmopXG4gIGlmICghKGNvbXBvc2l0ZVJ1bGUgfHwgYWxsRXJyb3JzKSkge1xuICAgIHJldHVybkVycm9ycyhpdCwgTi52RXJyb3JzKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNldEVycm9yc0NvdW50KGdlbjogQ29kZUdlbiwgZXJyc0NvdW50OiBOYW1lKTogdm9pZCB7XG4gIGdlbi5hc3NpZ24oTi5lcnJvcnMsIGVycnNDb3VudClcbiAgZ2VuLmlmKF9gJHtOLnZFcnJvcnN9ICE9PSBudWxsYCwgKCkgPT5cbiAgICBnZW4uaWYoXG4gICAgICBlcnJzQ291bnQsXG4gICAgICAoKSA9PiBnZW4uYXNzaWduKF9gJHtOLnZFcnJvcnN9Lmxlbmd0aGAsIGVycnNDb3VudCksXG4gICAgICAoKSA9PiBnZW4uYXNzaWduKE4udkVycm9ycywgbnVsbClcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZEVycm9ycyh7XG4gIGdlbixcbiAga2V5d29yZCxcbiAgc2NoZW1hVmFsdWUsXG4gIGRhdGEsXG4gIGVycnNDb3VudCxcbiAgaXQsXG59OiBLZXl3b3JkRXJyb3JDeHQpOiB2b2lkIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChlcnJzQ291bnQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIGNvbnN0IGVyciA9IGdlbi5uYW1lKFwiZXJyXCIpXG4gIGdlbi5mb3JSYW5nZShcImlcIiwgZXJyc0NvdW50LCBOLmVycm9ycywgKGkpID0+IHtcbiAgICBnZW4uY29uc3QoZXJyLCBfYCR7Ti52RXJyb3JzfVske2l9XWApXG4gICAgZ2VuLmlmKF9gJHtlcnJ9Lmluc3RhbmNlUGF0aCA9PT0gdW5kZWZpbmVkYCwgKCkgPT5cbiAgICAgIGdlbi5hc3NpZ24oX2Ake2Vycn0uaW5zdGFuY2VQYXRoYCwgc3RyQ29uY2F0KE4uaW5zdGFuY2VQYXRoLCBpdC5lcnJvclBhdGgpKVxuICAgIClcbiAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LnNjaGVtYVBhdGhgLCBzdHJgJHtpdC5lcnJTY2hlbWFQYXRofS8ke2tleXdvcmR9YClcbiAgICBpZiAoaXQub3B0cy52ZXJib3NlKSB7XG4gICAgICBnZW4uYXNzaWduKF9gJHtlcnJ9LnNjaGVtYWAsIHNjaGVtYVZhbHVlKVxuICAgICAgZ2VuLmFzc2lnbihfYCR7ZXJyfS5kYXRhYCwgZGF0YSlcbiAgICB9XG4gIH0pXG59XG5cbmZ1bmN0aW9uIGFkZEVycm9yKGdlbjogQ29kZUdlbiwgZXJyT2JqOiBDb2RlKTogdm9pZCB7XG4gIGNvbnN0IGVyciA9IGdlbi5jb25zdChcImVyclwiLCBlcnJPYmopXG4gIGdlbi5pZihcbiAgICBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbGAsXG4gICAgKCkgPT4gZ2VuLmFzc2lnbihOLnZFcnJvcnMsIF9gWyR7ZXJyfV1gKSxcbiAgICBfYCR7Ti52RXJyb3JzfS5wdXNoKCR7ZXJyfSlgXG4gIClcbiAgZ2VuLmNvZGUoX2Ake04uZXJyb3JzfSsrYClcbn1cblxuZnVuY3Rpb24gcmV0dXJuRXJyb3JzKGl0OiBTY2hlbWFDeHQsIGVycnM6IENvZGUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgdmFsaWRhdGVOYW1lLCBzY2hlbWFFbnZ9ID0gaXRcbiAgaWYgKHNjaGVtYUVudi4kYXN5bmMpIHtcbiAgICBnZW4udGhyb3coX2BuZXcgJHtpdC5WYWxpZGF0aW9uRXJyb3IgYXMgTmFtZX0oJHtlcnJzfSlgKVxuICB9IGVsc2Uge1xuICAgIGdlbi5hc3NpZ24oX2Ake3ZhbGlkYXRlTmFtZX0uZXJyb3JzYCwgZXJycylcbiAgICBnZW4ucmV0dXJuKGZhbHNlKVxuICB9XG59XG5cbmNvbnN0IEUgPSB7XG4gIGtleXdvcmQ6IG5ldyBOYW1lKFwia2V5d29yZFwiKSxcbiAgc2NoZW1hUGF0aDogbmV3IE5hbWUoXCJzY2hlbWFQYXRoXCIpLCAvLyBhbHNvIHVzZWQgaW4gSlREIGVycm9yc1xuICBwYXJhbXM6IG5ldyBOYW1lKFwicGFyYW1zXCIpLFxuICBwcm9wZXJ0eU5hbWU6IG5ldyBOYW1lKFwicHJvcGVydHlOYW1lXCIpLFxuICBtZXNzYWdlOiBuZXcgTmFtZShcIm1lc3NhZ2VcIiksXG4gIHNjaGVtYTogbmV3IE5hbWUoXCJzY2hlbWFcIiksXG4gIHBhcmVudFNjaGVtYTogbmV3IE5hbWUoXCJwYXJlbnRTY2hlbWFcIiksXG59XG5cbmZ1bmN0aW9uIGVycm9yT2JqZWN0Q29kZShcbiAgY3h0OiBLZXl3b3JkRXJyb3JDeHQsXG4gIGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBlcnJvclBhdGhzPzogRXJyb3JQYXRoc1xuKTogQ29kZSB7XG4gIGNvbnN0IHtjcmVhdGVFcnJvcnN9ID0gY3h0Lml0XG4gIGlmIChjcmVhdGVFcnJvcnMgPT09IGZhbHNlKSByZXR1cm4gX2B7fWBcbiAgcmV0dXJuIGVycm9yT2JqZWN0KGN4dCwgZXJyb3IsIGVycm9yUGF0aHMpXG59XG5cbmZ1bmN0aW9uIGVycm9yT2JqZWN0KFxuICBjeHQ6IEtleXdvcmRFcnJvckN4dCxcbiAgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIGVycm9yUGF0aHM6IEVycm9yUGF0aHMgPSB7fVxuKTogQ29kZSB7XG4gIGNvbnN0IHtnZW4sIGl0fSA9IGN4dFxuICBjb25zdCBrZXlWYWx1ZXM6IFtOYW1lLCBTYWZlRXhwciB8IHN0cmluZ11bXSA9IFtcbiAgICBlcnJvckluc3RhbmNlUGF0aChpdCwgZXJyb3JQYXRocyksXG4gICAgZXJyb3JTY2hlbWFQYXRoKGN4dCwgZXJyb3JQYXRocyksXG4gIF1cbiAgZXh0cmFFcnJvclByb3BzKGN4dCwgZXJyb3IsIGtleVZhbHVlcylcbiAgcmV0dXJuIGdlbi5vYmplY3QoLi4ua2V5VmFsdWVzKVxufVxuXG5mdW5jdGlvbiBlcnJvckluc3RhbmNlUGF0aCh7ZXJyb3JQYXRofTogU2NoZW1hQ3h0LCB7aW5zdGFuY2VQYXRofTogRXJyb3JQYXRocyk6IFtOYW1lLCBDb2RlXSB7XG4gIGNvbnN0IGluc3RQYXRoID0gaW5zdGFuY2VQYXRoXG4gICAgPyBzdHJgJHtlcnJvclBhdGh9JHtnZXRFcnJvclBhdGgoaW5zdGFuY2VQYXRoLCBUeXBlLlN0cil9YFxuICAgIDogZXJyb3JQYXRoXG4gIHJldHVybiBbTi5pbnN0YW5jZVBhdGgsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgaW5zdFBhdGgpXVxufVxuXG5mdW5jdGlvbiBlcnJvclNjaGVtYVBhdGgoXG4gIHtrZXl3b3JkLCBpdDoge2VyclNjaGVtYVBhdGh9fTogS2V5d29yZEVycm9yQ3h0LFxuICB7c2NoZW1hUGF0aCwgcGFyZW50U2NoZW1hfTogRXJyb3JQYXRoc1xuKTogW05hbWUsIHN0cmluZyB8IENvZGVdIHtcbiAgbGV0IHNjaFBhdGggPSBwYXJlbnRTY2hlbWEgPyBlcnJTY2hlbWFQYXRoIDogc3RyYCR7ZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWBcbiAgaWYgKHNjaGVtYVBhdGgpIHtcbiAgICBzY2hQYXRoID0gc3RyYCR7c2NoUGF0aH0ke2dldEVycm9yUGF0aChzY2hlbWFQYXRoLCBUeXBlLlN0cil9YFxuICB9XG4gIHJldHVybiBbRS5zY2hlbWFQYXRoLCBzY2hQYXRoXVxufVxuXG5mdW5jdGlvbiBleHRyYUVycm9yUHJvcHMoXG4gIGN4dDogS2V5d29yZEVycm9yQ3h0LFxuICB7cGFyYW1zLCBtZXNzYWdlfTogS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAga2V5VmFsdWVzOiBbTmFtZSwgU2FmZUV4cHIgfCBzdHJpbmddW11cbik6IHZvaWQge1xuICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hVmFsdWUsIGl0fSA9IGN4dFxuICBjb25zdCB7b3B0cywgcHJvcGVydHlOYW1lLCB0b3BTY2hlbWFSZWYsIHNjaGVtYVBhdGh9ID0gaXRcbiAga2V5VmFsdWVzLnB1c2goXG4gICAgW0Uua2V5d29yZCwga2V5d29yZF0sXG4gICAgW0UucGFyYW1zLCB0eXBlb2YgcGFyYW1zID09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcyhjeHQpIDogcGFyYW1zIHx8IF9ge31gXVxuICApXG4gIGlmIChvcHRzLm1lc3NhZ2VzKSB7XG4gICAga2V5VmFsdWVzLnB1c2goW0UubWVzc2FnZSwgdHlwZW9mIG1lc3NhZ2UgPT0gXCJmdW5jdGlvblwiID8gbWVzc2FnZShjeHQpIDogbWVzc2FnZV0pXG4gIH1cbiAgaWYgKG9wdHMudmVyYm9zZSkge1xuICAgIGtleVZhbHVlcy5wdXNoKFxuICAgICAgW0Uuc2NoZW1hLCBzY2hlbWFWYWx1ZV0sXG4gICAgICBbRS5wYXJlbnRTY2hlbWEsIF9gJHt0b3BTY2hlbWFSZWZ9JHtzY2hlbWFQYXRofWBdLFxuICAgICAgW04uZGF0YSwgZGF0YV1cbiAgICApXG4gIH1cbiAgaWYgKHByb3BlcnR5TmFtZSkga2V5VmFsdWVzLnB1c2goW0UucHJvcGVydHlOYW1lLCBwcm9wZXJ0eU5hbWVdKVxufVxuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkRXJyb3JEZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JDeHR9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtyZXBvcnRFcnJvcn0gZnJvbSBcIi4uL2Vycm9yc1wiXG5pbXBvcnQge18sIE5hbWV9IGZyb20gXCIuLi9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi9uYW1lc1wiXG5cbmNvbnN0IGJvb2xFcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJib29sZWFuIHNjaGVtYSBpcyBmYWxzZVwiLFxufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wQm9vbE9yRW1wdHlTY2hlbWEoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWEsIHZhbGlkYXRlTmFtZX0gPSBpdFxuICBpZiAoc2NoZW1hID09PSBmYWxzZSkge1xuICAgIGZhbHNlU2NoZW1hRXJyb3IoaXQsIGZhbHNlKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiBzY2hlbWEuJGFzeW5jID09PSB0cnVlKSB7XG4gICAgZ2VuLnJldHVybihOLmRhdGEpXG4gIH0gZWxzZSB7XG4gICAgZ2VuLmFzc2lnbihfYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBudWxsKVxuICAgIGdlbi5yZXR1cm4odHJ1ZSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYm9vbE9yRW1wdHlTY2hlbWEoaXQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hfSA9IGl0XG4gIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgZ2VuLnZhcih2YWxpZCwgZmFsc2UpIC8vIFRPRE8gdmFyXG4gICAgZmFsc2VTY2hlbWFFcnJvcihpdClcbiAgfSBlbHNlIHtcbiAgICBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICB9XG59XG5cbmZ1bmN0aW9uIGZhbHNlU2NoZW1hRXJyb3IoaXQ6IFNjaGVtYUN4dCwgb3ZlcnJpZGVBbGxFcnJvcnM/OiBib29sZWFuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGF9ID0gaXRcbiAgLy8gVE9ETyBtYXliZSBzb21lIG90aGVyIGludGVyZmFjZSBzaG91bGQgYmUgdXNlZCBmb3Igbm9uLWtleXdvcmQgdmFsaWRhdGlvbiBlcnJvcnMuLi5cbiAgY29uc3QgY3h0OiBLZXl3b3JkRXJyb3JDeHQgPSB7XG4gICAgZ2VuLFxuICAgIGtleXdvcmQ6IFwiZmFsc2Ugc2NoZW1hXCIsXG4gICAgZGF0YSxcbiAgICBzY2hlbWE6IGZhbHNlLFxuICAgIHNjaGVtYUNvZGU6IGZhbHNlLFxuICAgIHNjaGVtYVZhbHVlOiBmYWxzZSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIGl0LFxuICB9XG4gIHJlcG9ydEVycm9yKGN4dCwgYm9vbEVycm9yLCB1bmRlZmluZWQsIG92ZXJyaWRlQWxsRXJyb3JzKVxufVxuIiwgImltcG9ydCB0eXBlIHtBZGRlZEtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5jb25zdCBfanNvblR5cGVzID0gW1wic3RyaW5nXCIsIFwibnVtYmVyXCIsIFwiaW50ZWdlclwiLCBcImJvb2xlYW5cIiwgXCJudWxsXCIsIFwib2JqZWN0XCIsIFwiYXJyYXlcIl0gYXMgY29uc3RcblxuZXhwb3J0IHR5cGUgSlNPTlR5cGUgPSAodHlwZW9mIF9qc29uVHlwZXMpW251bWJlcl1cblxuY29uc3QganNvblR5cGVzOiBTZXQ8c3RyaW5nPiA9IG5ldyBTZXQoX2pzb25UeXBlcylcblxuZXhwb3J0IGZ1bmN0aW9uIGlzSlNPTlR5cGUoeDogdW5rbm93bik6IHggaXMgSlNPTlR5cGUge1xuICByZXR1cm4gdHlwZW9mIHggPT0gXCJzdHJpbmdcIiAmJiBqc29uVHlwZXMuaGFzKHgpXG59XG5cbnR5cGUgVmFsaWRhdGlvblR5cGVzID0ge1xuICBbSyBpbiBKU09OVHlwZV06IGJvb2xlYW4gfCBSdWxlR3JvdXAgfCB1bmRlZmluZWRcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWYWxpZGF0aW9uUnVsZXMge1xuICBydWxlczogUnVsZUdyb3VwW11cbiAgcG9zdDogUnVsZUdyb3VwXG4gIGFsbDoge1tLZXkgaW4gc3RyaW5nXT86IGJvb2xlYW4gfCBSdWxlfSAvLyBydWxlcyB0aGF0IGhhdmUgdG8gYmUgdmFsaWRhdGVkXG4gIGtleXdvcmRzOiB7W0tleSBpbiBzdHJpbmddPzogYm9vbGVhbn0gLy8gYWxsIGtub3duIGtleXdvcmRzIChzdXBlcnNldCBvZiBcImFsbFwiKVxuICB0eXBlczogVmFsaWRhdGlvblR5cGVzXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVsZUdyb3VwIHtcbiAgdHlwZT86IEpTT05UeXBlXG4gIHJ1bGVzOiBSdWxlW11cbn1cblxuLy8gVGhpcyBpbnRlcmZhY2Ugd3JhcHMgS2V5d29yZERlZmluaXRpb24gYmVjYXVzZSBkZWZpbml0aW9uIGNhbiBoYXZlIG11bHRpcGxlIGtleXdvcmRzXG5leHBvcnQgaW50ZXJmYWNlIFJ1bGUge1xuICBrZXl3b3JkOiBzdHJpbmdcbiAgZGVmaW5pdGlvbjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvblxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UnVsZXMoKTogVmFsaWRhdGlvblJ1bGVzIHtcbiAgY29uc3QgZ3JvdXBzOiBSZWNvcmQ8XCJudW1iZXJcIiB8IFwic3RyaW5nXCIgfCBcImFycmF5XCIgfCBcIm9iamVjdFwiLCBSdWxlR3JvdXA+ID0ge1xuICAgIG51bWJlcjoge3R5cGU6IFwibnVtYmVyXCIsIHJ1bGVzOiBbXX0sXG4gICAgc3RyaW5nOiB7dHlwZTogXCJzdHJpbmdcIiwgcnVsZXM6IFtdfSxcbiAgICBhcnJheToge3R5cGU6IFwiYXJyYXlcIiwgcnVsZXM6IFtdfSxcbiAgICBvYmplY3Q6IHt0eXBlOiBcIm9iamVjdFwiLCBydWxlczogW119LFxuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZXM6IHsuLi5ncm91cHMsIGludGVnZXI6IHRydWUsIGJvb2xlYW46IHRydWUsIG51bGw6IHRydWV9LFxuICAgIHJ1bGVzOiBbe3J1bGVzOiBbXX0sIGdyb3Vwcy5udW1iZXIsIGdyb3Vwcy5zdHJpbmcsIGdyb3Vwcy5hcnJheSwgZ3JvdXBzLm9iamVjdF0sXG4gICAgcG9zdDoge3J1bGVzOiBbXX0sXG4gICAgYWxsOiB7fSxcbiAgICBrZXl3b3Jkczoge30sXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hT2JqZWN0fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZSwgUnVsZUdyb3VwLCBSdWxlfSBmcm9tIFwiLi4vcnVsZXNcIlxuXG5leHBvcnQgZnVuY3Rpb24gc2NoZW1hSGFzUnVsZXNGb3JUeXBlKFxuICB7c2NoZW1hLCBzZWxmfTogU2NoZW1hT2JqQ3h0LFxuICB0eXBlOiBKU09OVHlwZVxuKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IGdyb3VwID0gc2VsZi5SVUxFUy50eXBlc1t0eXBlXVxuICByZXR1cm4gZ3JvdXAgJiYgZ3JvdXAgIT09IHRydWUgJiYgc2hvdWxkVXNlR3JvdXAoc2NoZW1hLCBncm91cClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3VsZFVzZUdyb3VwKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LCBncm91cDogUnVsZUdyb3VwKTogYm9vbGVhbiB7XG4gIHJldHVybiBncm91cC5ydWxlcy5zb21lKChydWxlKSA9PiBzaG91bGRVc2VSdWxlKHNjaGVtYSwgcnVsZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaG91bGRVc2VSdWxlKHNjaGVtYTogQW55U2NoZW1hT2JqZWN0LCBydWxlOiBSdWxlKTogYm9vbGVhbiB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoXG4gICAgc2NoZW1hW3J1bGUua2V5d29yZF0gIT09IHVuZGVmaW5lZCB8fFxuICAgIHJ1bGUuZGVmaW5pdGlvbi5pbXBsZW1lbnRzPy5zb21lKChrd2QpID0+IHNjaGVtYVtrd2RdICE9PSB1bmRlZmluZWQpXG4gIClcbn1cbiIsICJpbXBvcnQgdHlwZSB7XG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckN4dCxcbiAgRXJyb3JPYmplY3QsXG4gIEFueVNjaGVtYU9iamVjdCxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQge2lzSlNPTlR5cGUsIEpTT05UeXBlfSBmcm9tIFwiLi4vcnVsZXNcIlxuaW1wb3J0IHtzY2hlbWFIYXNSdWxlc0ZvclR5cGV9IGZyb20gXCIuL2FwcGxpY2FiaWxpdHlcIlxuaW1wb3J0IHtyZXBvcnRFcnJvcn0gZnJvbSBcIi4uL2Vycm9yc1wiXG5pbXBvcnQge18sIG5pbCwgYW5kLCBub3QsIG9wZXJhdG9ycywgQ29kZSwgTmFtZX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IHt0b0hhc2gsIHNjaGVtYVJlZk9yVmFsfSBmcm9tIFwiLi4vdXRpbFwiXG5cbmV4cG9ydCBlbnVtIERhdGFUeXBlIHtcbiAgQ29ycmVjdCxcbiAgV3JvbmcsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFUeXBlcyhzY2hlbWE6IEFueVNjaGVtYU9iamVjdCk6IEpTT05UeXBlW10ge1xuICBjb25zdCB0eXBlcyA9IGdldEpTT05UeXBlcyhzY2hlbWEudHlwZSlcbiAgY29uc3QgaGFzTnVsbCA9IHR5cGVzLmluY2x1ZGVzKFwibnVsbFwiKVxuICBpZiAoaGFzTnVsbCkge1xuICAgIGlmIChzY2hlbWEubnVsbGFibGUgPT09IGZhbHNlKSB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlOiBudWxsIGNvbnRyYWRpY3RzIG51bGxhYmxlOiBmYWxzZVwiKVxuICB9IGVsc2Uge1xuICAgIGlmICghdHlwZXMubGVuZ3RoICYmIHNjaGVtYS5udWxsYWJsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibnVsbGFibGVcIiBjYW5ub3QgYmUgdXNlZCB3aXRob3V0IFwidHlwZVwiJylcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSkgdHlwZXMucHVzaChcIm51bGxcIilcbiAgfVxuICByZXR1cm4gdHlwZXNcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbmV4cG9ydCBmdW5jdGlvbiBnZXRKU09OVHlwZXModHM6IHVua25vd24gfCB1bmtub3duW10pOiBKU09OVHlwZVtdIHtcbiAgY29uc3QgdHlwZXM6IHVua25vd25bXSA9IEFycmF5LmlzQXJyYXkodHMpID8gdHMgOiB0cyA/IFt0c10gOiBbXVxuICBpZiAodHlwZXMuZXZlcnkoaXNKU09OVHlwZSkpIHJldHVybiB0eXBlc1xuICB0aHJvdyBuZXcgRXJyb3IoXCJ0eXBlIG11c3QgYmUgSlNPTlR5cGUgb3IgSlNPTlR5cGVbXTogXCIgKyB0eXBlcy5qb2luKFwiLFwiKSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvZXJjZUFuZENoZWNrRGF0YVR5cGUoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiBib29sZWFuIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgb3B0c30gPSBpdFxuICBjb25zdCBjb2VyY2VUbyA9IGNvZXJjZVRvVHlwZXModHlwZXMsIG9wdHMuY29lcmNlVHlwZXMpXG4gIGNvbnN0IGNoZWNrVHlwZXMgPVxuICAgIHR5cGVzLmxlbmd0aCA+IDAgJiZcbiAgICAhKGNvZXJjZVRvLmxlbmd0aCA9PT0gMCAmJiB0eXBlcy5sZW5ndGggPT09IDEgJiYgc2NoZW1hSGFzUnVsZXNGb3JUeXBlKGl0LCB0eXBlc1swXSkpXG4gIGlmIChjaGVja1R5cGVzKSB7XG4gICAgY29uc3Qgd3JvbmdUeXBlID0gY2hlY2tEYXRhVHlwZXModHlwZXMsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpXG4gICAgZ2VuLmlmKHdyb25nVHlwZSwgKCkgPT4ge1xuICAgICAgaWYgKGNvZXJjZVRvLmxlbmd0aCkgY29lcmNlRGF0YShpdCwgdHlwZXMsIGNvZXJjZVRvKVxuICAgICAgZWxzZSByZXBvcnRUeXBlRXJyb3IoaXQpXG4gICAgfSlcbiAgfVxuICByZXR1cm4gY2hlY2tUeXBlc1xufVxuXG5jb25zdCBDT0VSQ0lCTEU6IFNldDxKU09OVHlwZT4gPSBuZXcgU2V0KFtcInN0cmluZ1wiLCBcIm51bWJlclwiLCBcImludGVnZXJcIiwgXCJib29sZWFuXCIsIFwibnVsbFwiXSlcbmZ1bmN0aW9uIGNvZXJjZVRvVHlwZXModHlwZXM6IEpTT05UeXBlW10sIGNvZXJjZVR5cGVzPzogYm9vbGVhbiB8IFwiYXJyYXlcIik6IEpTT05UeXBlW10ge1xuICByZXR1cm4gY29lcmNlVHlwZXNcbiAgICA/IHR5cGVzLmZpbHRlcigodCkgPT4gQ09FUkNJQkxFLmhhcyh0KSB8fCAoY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIiAmJiB0ID09PSBcImFycmF5XCIpKVxuICAgIDogW11cbn1cblxuZnVuY3Rpb24gY29lcmNlRGF0YShpdDogU2NoZW1hT2JqQ3h0LCB0eXBlczogSlNPTlR5cGVbXSwgY29lcmNlVG86IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgZGF0YSwgb3B0c30gPSBpdFxuICBjb25zdCBkYXRhVHlwZSA9IGdlbi5sZXQoXCJkYXRhVHlwZVwiLCBfYHR5cGVvZiAke2RhdGF9YClcbiAgY29uc3QgY29lcmNlZCA9IGdlbi5sZXQoXCJjb2VyY2VkXCIsIF9gdW5kZWZpbmVkYClcbiAgaWYgKG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikge1xuICAgIGdlbi5pZihfYCR7ZGF0YVR5cGV9ID09ICdvYmplY3QnICYmIEFycmF5LmlzQXJyYXkoJHtkYXRhfSkgJiYgJHtkYXRhfS5sZW5ndGggPT0gMWAsICgpID0+XG4gICAgICBnZW5cbiAgICAgICAgLmFzc2lnbihkYXRhLCBfYCR7ZGF0YX1bMF1gKVxuICAgICAgICAuYXNzaWduKGRhdGFUeXBlLCBfYHR5cGVvZiAke2RhdGF9YClcbiAgICAgICAgLmlmKGNoZWNrRGF0YVR5cGVzKHR5cGVzLCBkYXRhLCBvcHRzLnN0cmljdE51bWJlcnMpLCAoKSA9PiBnZW4uYXNzaWduKGNvZXJjZWQsIGRhdGEpKVxuICAgIClcbiAgfVxuICBnZW4uaWYoX2Ake2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgKVxuICBmb3IgKGNvbnN0IHQgb2YgY29lcmNlVG8pIHtcbiAgICBpZiAoQ09FUkNJQkxFLmhhcyh0KSB8fCAodCA9PT0gXCJhcnJheVwiICYmIG9wdHMuY29lcmNlVHlwZXMgPT09IFwiYXJyYXlcIikpIHtcbiAgICAgIGNvZXJjZVNwZWNpZmljVHlwZSh0KVxuICAgIH1cbiAgfVxuICBnZW4uZWxzZSgpXG4gIHJlcG9ydFR5cGVFcnJvcihpdClcbiAgZ2VuLmVuZElmKClcblxuICBnZW4uaWYoX2Ake2NvZXJjZWR9ICE9PSB1bmRlZmluZWRgLCAoKSA9PiB7XG4gICAgZ2VuLmFzc2lnbihkYXRhLCBjb2VyY2VkKVxuICAgIGFzc2lnblBhcmVudERhdGEoaXQsIGNvZXJjZWQpXG4gIH0pXG5cbiAgZnVuY3Rpb24gY29lcmNlU3BlY2lmaWNUeXBlKHQ6IHN0cmluZyk6IHZvaWQge1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhVHlwZX0gPT0gXCJudW1iZXJcIiB8fCAke2RhdGFUeXBlfSA9PSBcImJvb2xlYW5cImApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFwiXCIgKyAke2RhdGF9YClcbiAgICAgICAgICAuZWxzZUlmKF9gJHtkYXRhfSA9PT0gbnVsbGApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFwiXCJgKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmVsc2VJZihcbiAgICAgICAgICAgIF9gJHtkYXRhVHlwZX0gPT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbFxuICAgICAgICAgICAgICB8fCAoJHtkYXRhVHlwZX0gPT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0pYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gKyR7ZGF0YX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJpbnRlZ2VyXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoXG4gICAgICAgICAgICBfYCR7ZGF0YVR5cGV9ID09PSBcImJvb2xlYW5cIiB8fCAke2RhdGF9ID09PSBudWxsXG4gICAgICAgICAgICAgIHx8ICgke2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiAmJiAke2RhdGF9ICYmICR7ZGF0YX0gPT0gKyR7ZGF0YX0gJiYgISgke2RhdGF9ICUgMSkpYFxuICAgICAgICAgIClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIF9gKyR7ZGF0YX1gKVxuICAgICAgICByZXR1cm5cbiAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgIGdlblxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBcImZhbHNlXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBudWxsYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIGZhbHNlKVxuICAgICAgICAgIC5lbHNlSWYoX2Ake2RhdGF9ID09PSBcInRydWVcIiB8fCAke2RhdGF9ID09PSAxYClcbiAgICAgICAgICAuYXNzaWduKGNvZXJjZWQsIHRydWUpXG4gICAgICAgIHJldHVyblxuICAgICAgY2FzZSBcIm51bGxcIjpcbiAgICAgICAgZ2VuLmVsc2VJZihfYCR7ZGF0YX0gPT09IFwiXCIgfHwgJHtkYXRhfSA9PT0gMCB8fCAke2RhdGF9ID09PSBmYWxzZWApXG4gICAgICAgIGdlbi5hc3NpZ24oY29lcmNlZCwgbnVsbClcbiAgICAgICAgcmV0dXJuXG5cbiAgICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgICBnZW5cbiAgICAgICAgICAuZWxzZUlmKFxuICAgICAgICAgICAgX2Ake2RhdGFUeXBlfSA9PT0gXCJzdHJpbmdcIiB8fCAke2RhdGFUeXBlfSA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICB8fCAke2RhdGFUeXBlfSA9PT0gXCJib29sZWFuXCIgfHwgJHtkYXRhfSA9PT0gbnVsbGBcbiAgICAgICAgICApXG4gICAgICAgICAgLmFzc2lnbihjb2VyY2VkLCBfYFske2RhdGF9XWApXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnblBhcmVudERhdGEoe2dlbiwgcGFyZW50RGF0YSwgcGFyZW50RGF0YVByb3BlcnR5fTogU2NoZW1hT2JqQ3h0LCBleHByOiBOYW1lKTogdm9pZCB7XG4gIC8vIFRPRE8gdXNlIGdlbi5wcm9wZXJ0eVxuICBnZW4uaWYoX2Ake3BhcmVudERhdGF9ICE9PSB1bmRlZmluZWRgLCAoKSA9PlxuICAgIGdlbi5hc3NpZ24oX2Ake3BhcmVudERhdGF9WyR7cGFyZW50RGF0YVByb3BlcnR5fV1gLCBleHByKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RhdGFUeXBlKFxuICBkYXRhVHlwZTogSlNPTlR5cGUsXG4gIGRhdGE6IE5hbWUsXG4gIHN0cmljdE51bXM/OiBib29sZWFuIHwgXCJsb2dcIixcbiAgY29ycmVjdCA9IERhdGFUeXBlLkNvcnJlY3Rcbik6IENvZGUge1xuICBjb25zdCBFUSA9IGNvcnJlY3QgPT09IERhdGFUeXBlLkNvcnJlY3QgPyBvcGVyYXRvcnMuRVEgOiBvcGVyYXRvcnMuTkVRXG4gIGxldCBjb25kOiBDb2RlXG4gIHN3aXRjaCAoZGF0YVR5cGUpIHtcbiAgICBjYXNlIFwibnVsbFwiOlxuICAgICAgcmV0dXJuIF9gJHtkYXRhfSAke0VRfSBudWxsYFxuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgY29uZCA9IF9gQXJyYXkuaXNBcnJheSgke2RhdGF9KWBcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgY29uZCA9IF9gJHtkYXRhfSAmJiB0eXBlb2YgJHtkYXRhfSA9PSBcIm9iamVjdFwiICYmICFBcnJheS5pc0FycmF5KCR7ZGF0YX0pYFxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwiaW50ZWdlclwiOlxuICAgICAgY29uZCA9IG51bUNvbmQoX2AhKCR7ZGF0YX0gJSAxKSAmJiAhaXNOYU4oJHtkYXRhfSlgKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICBjb25kID0gbnVtQ29uZCgpXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gX2B0eXBlb2YgJHtkYXRhfSAke0VRfSAke2RhdGFUeXBlfWBcbiAgfVxuICByZXR1cm4gY29ycmVjdCA9PT0gRGF0YVR5cGUuQ29ycmVjdCA/IGNvbmQgOiBub3QoY29uZClcblxuICBmdW5jdGlvbiBudW1Db25kKF9jb25kOiBDb2RlID0gbmlsKTogQ29kZSB7XG4gICAgcmV0dXJuIGFuZChfYHR5cGVvZiAke2RhdGF9ID09IFwibnVtYmVyXCJgLCBfY29uZCwgc3RyaWN0TnVtcyA/IF9gaXNGaW5pdGUoJHtkYXRhfSlgIDogbmlsKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0RhdGFUeXBlcyhcbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdLFxuICBkYXRhOiBOYW1lLFxuICBzdHJpY3ROdW1zPzogYm9vbGVhbiB8IFwibG9nXCIsXG4gIGNvcnJlY3Q/OiBEYXRhVHlwZVxuKTogQ29kZSB7XG4gIGlmIChkYXRhVHlwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGNoZWNrRGF0YVR5cGUoZGF0YVR5cGVzWzBdLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KVxuICB9XG4gIGxldCBjb25kOiBDb2RlXG4gIGNvbnN0IHR5cGVzID0gdG9IYXNoKGRhdGFUeXBlcylcbiAgaWYgKHR5cGVzLmFycmF5ICYmIHR5cGVzLm9iamVjdCkge1xuICAgIGNvbnN0IG5vdE9iaiA9IF9gdHlwZW9mICR7ZGF0YX0gIT0gXCJvYmplY3RcImBcbiAgICBjb25kID0gdHlwZXMubnVsbCA/IG5vdE9iaiA6IF9gISR7ZGF0YX0gfHwgJHtub3RPYmp9YFxuICAgIGRlbGV0ZSB0eXBlcy5udWxsXG4gICAgZGVsZXRlIHR5cGVzLmFycmF5XG4gICAgZGVsZXRlIHR5cGVzLm9iamVjdFxuICB9IGVsc2Uge1xuICAgIGNvbmQgPSBuaWxcbiAgfVxuICBpZiAodHlwZXMubnVtYmVyKSBkZWxldGUgdHlwZXMuaW50ZWdlclxuICBmb3IgKGNvbnN0IHQgaW4gdHlwZXMpIGNvbmQgPSBhbmQoY29uZCwgY2hlY2tEYXRhVHlwZSh0IGFzIEpTT05UeXBlLCBkYXRhLCBzdHJpY3ROdW1zLCBjb3JyZWN0KSlcbiAgcmV0dXJuIGNvbmRcbn1cblxuZXhwb3J0IHR5cGUgVHlwZUVycm9yID0gRXJyb3JPYmplY3Q8XCJ0eXBlXCIsIHt0eXBlOiBzdHJpbmd9PlxuXG5jb25zdCB0eXBlRXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hfSkgPT4gYG11c3QgYmUgJHtzY2hlbWF9YCxcbiAgcGFyYW1zOiAoe3NjaGVtYSwgc2NoZW1hVmFsdWV9KSA9PlxuICAgIHR5cGVvZiBzY2hlbWEgPT0gXCJzdHJpbmdcIiA/IF9ge3R5cGU6ICR7c2NoZW1hfX1gIDogX2B7dHlwZTogJHtzY2hlbWFWYWx1ZX19YCxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydFR5cGVFcnJvcihpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IGN4dCA9IGdldFR5cGVFcnJvckNvbnRleHQoaXQpXG4gIHJlcG9ydEVycm9yKGN4dCwgdHlwZUVycm9yKVxufVxuXG5mdW5jdGlvbiBnZXRUeXBlRXJyb3JDb250ZXh0KGl0OiBTY2hlbWFPYmpDeHQpOiBLZXl3b3JkRXJyb3JDeHQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBzY2hlbWF9ID0gaXRcbiAgY29uc3Qgc2NoZW1hQ29kZSA9IHNjaGVtYVJlZk9yVmFsKGl0LCBzY2hlbWEsIFwidHlwZVwiKVxuICByZXR1cm4ge1xuICAgIGdlbixcbiAgICBrZXl3b3JkOiBcInR5cGVcIixcbiAgICBkYXRhLFxuICAgIHNjaGVtYTogc2NoZW1hLnR5cGUsXG4gICAgc2NoZW1hQ29kZSxcbiAgICBzY2hlbWFWYWx1ZTogc2NoZW1hQ29kZSxcbiAgICBwYXJlbnRTY2hlbWE6IHNjaGVtYSxcbiAgICBwYXJhbXM6IHt9LFxuICAgIGl0LFxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIHN0cmluZ2lmeX0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IHtjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi91dGlsXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkRlZmF1bHRzKGl0OiBTY2hlbWFPYmpDeHQsIHR5Pzogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHtwcm9wZXJ0aWVzLCBpdGVtc30gPSBpdC5zY2hlbWFcbiAgaWYgKHR5ID09PSBcIm9iamVjdFwiICYmIHByb3BlcnRpZXMpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBhc3NpZ25EZWZhdWx0KGl0LCBrZXksIHByb3BlcnRpZXNba2V5XS5kZWZhdWx0KVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eSA9PT0gXCJhcnJheVwiICYmIEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgaXRlbXMuZm9yRWFjaCgoc2NoLCBpOiBudW1iZXIpID0+IGFzc2lnbkRlZmF1bHQoaXQsIGksIHNjaC5kZWZhdWx0KSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NpZ25EZWZhdWx0KGl0OiBTY2hlbWFPYmpDeHQsIHByb3A6IHN0cmluZyB8IG51bWJlciwgZGVmYXVsdFZhbHVlOiB1bmtub3duKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGNvbXBvc2l0ZVJ1bGUsIGRhdGEsIG9wdHN9ID0gaXRcbiAgaWYgKGRlZmF1bHRWYWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgY29uc3QgY2hpbGREYXRhID0gX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eShwcm9wKX1gXG4gIGlmIChjb21wb3NpdGVSdWxlKSB7XG4gICAgY2hlY2tTdHJpY3RNb2RlKGl0LCBgZGVmYXVsdCBpcyBpZ25vcmVkIGZvcjogJHtjaGlsZERhdGF9YClcbiAgICByZXR1cm5cbiAgfVxuXG4gIGxldCBjb25kaXRpb24gPSBfYCR7Y2hpbGREYXRhfSA9PT0gdW5kZWZpbmVkYFxuICBpZiAob3B0cy51c2VEZWZhdWx0cyA9PT0gXCJlbXB0eVwiKSB7XG4gICAgY29uZGl0aW9uID0gX2Ake2NvbmRpdGlvbn0gfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImBcbiAgfVxuICAvLyBgJHtjaGlsZERhdGF9ID09PSB1bmRlZmluZWRgICtcbiAgLy8gKG9wdHMudXNlRGVmYXVsdHMgPT09IFwiZW1wdHlcIiA/IGAgfHwgJHtjaGlsZERhdGF9ID09PSBudWxsIHx8ICR7Y2hpbGREYXRhfSA9PT0gXCJcImAgOiBcIlwiKVxuICBnZW4uaWYoY29uZGl0aW9uLCBfYCR7Y2hpbGREYXRhfSA9ICR7c3RyaW5naWZ5KGRlZmF1bHRWYWx1ZSl9YClcbn1cbiIsICJpbXBvcnQgdHlwZSB7QW55U2NoZW1hLCBTY2hlbWFNYXB9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0fSBmcm9tIFwiLi4vY29tcGlsZVwiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtDb2RlR2VuLCBfLCBhbmQsIG9yLCBub3QsIG5pbCwgc3RyQ29uY2F0LCBnZXRQcm9wZXJ0eSwgQ29kZSwgTmFtZX0gZnJvbSBcIi4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBUeXBlfSBmcm9tIFwiLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBOIGZyb20gXCIuLi9jb21waWxlL25hbWVzXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uL2NvbXBpbGUvdXRpbFwiXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXBvcnRNaXNzaW5nUHJvcChjeHQ6IEtleXdvcmRDeHQsIHByb3A6IHN0cmluZyk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgZ2VuLmlmKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpLCAoKSA9PiB7XG4gICAgY3h0LnNldFBhcmFtcyh7bWlzc2luZ1Byb3BlcnR5OiBfYCR7cHJvcH1gfSwgdHJ1ZSlcbiAgICBjeHQuZXJyb3IoKVxuICB9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tNaXNzaW5nUHJvcChcbiAge2dlbiwgZGF0YSwgaXQ6IHtvcHRzfX06IEtleXdvcmRDeHQsXG4gIHByb3BlcnRpZXM6IHN0cmluZ1tdLFxuICBtaXNzaW5nOiBOYW1lXG4pOiBDb2RlIHtcbiAgcmV0dXJuIG9yKFxuICAgIC4uLnByb3BlcnRpZXMubWFwKChwcm9wKSA9PlxuICAgICAgYW5kKG5vUHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBvcHRzLm93blByb3BlcnRpZXMpLCBfYCR7bWlzc2luZ30gPSAke3Byb3B9YClcbiAgICApXG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlcG9ydE1pc3NpbmdQcm9wKGN4dDogS2V5d29yZEN4dCwgbWlzc2luZzogTmFtZSk6IHZvaWQge1xuICBjeHQuc2V0UGFyYW1zKHttaXNzaW5nUHJvcGVydHk6IG1pc3Npbmd9LCB0cnVlKVxuICBjeHQuZXJyb3IoKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaGFzUHJvcEZ1bmMoZ2VuOiBDb2RlR2VuKTogTmFtZSB7XG4gIHJldHVybiBnZW4uc2NvcGVWYWx1ZShcImZ1bmNcIiwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5ib3VuZC1tZXRob2RcbiAgICByZWY6IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgY29kZTogX2BPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5YCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzT3duUHJvcGVydHkoZ2VuOiBDb2RlR2VuLCBkYXRhOiBOYW1lLCBwcm9wZXJ0eTogTmFtZSB8IHN0cmluZyk6IENvZGUge1xuICByZXR1cm4gX2Ake2hhc1Byb3BGdW5jKGdlbil9LmNhbGwoJHtkYXRhfSwgJHtwcm9wZXJ0eX0pYFxufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcGVydHlJbkRhdGEoXG4gIGdlbjogQ29kZUdlbixcbiAgZGF0YTogTmFtZSxcbiAgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcsXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgY29uZCA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcGVydHkpfSAhPT0gdW5kZWZpbmVkYFxuICByZXR1cm4gb3duUHJvcGVydGllcyA/IF9gJHtjb25kfSAmJiAke2lzT3duUHJvcGVydHkoZ2VuLCBkYXRhLCBwcm9wZXJ0eSl9YCA6IGNvbmRcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5vUHJvcGVydHlJbkRhdGEoXG4gIGdlbjogQ29kZUdlbixcbiAgZGF0YTogTmFtZSxcbiAgcHJvcGVydHk6IE5hbWUgfCBzdHJpbmcsXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4pOiBDb2RlIHtcbiAgY29uc3QgY29uZCA9IF9gJHtkYXRhfSR7Z2V0UHJvcGVydHkocHJvcGVydHkpfSA9PT0gdW5kZWZpbmVkYFxuICByZXR1cm4gb3duUHJvcGVydGllcyA/IG9yKGNvbmQsIG5vdChpc093blByb3BlcnR5KGdlbiwgZGF0YSwgcHJvcGVydHkpKSkgOiBjb25kXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYU1hcD86IFNjaGVtYU1hcCk6IHN0cmluZ1tdIHtcbiAgcmV0dXJuIHNjaGVtYU1hcCA/IE9iamVjdC5rZXlzKHNjaGVtYU1hcCkuZmlsdGVyKChwKSA9PiBwICE9PSBcIl9fcHJvdG9fX1wiKSA6IFtdXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzY2hlbWFQcm9wZXJ0aWVzKGl0OiBTY2hlbWFDeHQsIHNjaGVtYU1hcDogU2NoZW1hTWFwKTogc3RyaW5nW10ge1xuICByZXR1cm4gYWxsU2NoZW1hUHJvcGVydGllcyhzY2hlbWFNYXApLmZpbHRlcihcbiAgICAocCkgPT4gIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFNYXBbcF0gYXMgQW55U2NoZW1hKVxuICApXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsVmFsaWRhdGVDb2RlKFxuICB7c2NoZW1hQ29kZSwgZGF0YSwgaXQ6IHtnZW4sIHRvcFNjaGVtYVJlZiwgc2NoZW1hUGF0aCwgZXJyb3JQYXRofSwgaXR9OiBLZXl3b3JkQ3h0LFxuICBmdW5jOiBDb2RlLFxuICBjb250ZXh0OiBDb2RlLFxuICBwYXNzU2NoZW1hPzogYm9vbGVhblxuKTogQ29kZSB7XG4gIGNvbnN0IGRhdGFBbmRTY2hlbWEgPSBwYXNzU2NoZW1hID8gX2Ake3NjaGVtYUNvZGV9LCAke2RhdGF9LCAke3RvcFNjaGVtYVJlZn0ke3NjaGVtYVBhdGh9YCA6IGRhdGFcbiAgY29uc3QgdmFsQ3h0OiBbTmFtZSwgQ29kZSB8IG51bWJlcl1bXSA9IFtcbiAgICBbTi5pbnN0YW5jZVBhdGgsIHN0ckNvbmNhdChOLmluc3RhbmNlUGF0aCwgZXJyb3JQYXRoKV0sXG4gICAgW04ucGFyZW50RGF0YSwgaXQucGFyZW50RGF0YV0sXG4gICAgW04ucGFyZW50RGF0YVByb3BlcnR5LCBpdC5wYXJlbnREYXRhUHJvcGVydHldLFxuICAgIFtOLnJvb3REYXRhLCBOLnJvb3REYXRhXSxcbiAgXVxuICBpZiAoaXQub3B0cy5keW5hbWljUmVmKSB2YWxDeHQucHVzaChbTi5keW5hbWljQW5jaG9ycywgTi5keW5hbWljQW5jaG9yc10pXG4gIGNvbnN0IGFyZ3MgPSBfYCR7ZGF0YUFuZFNjaGVtYX0sICR7Z2VuLm9iamVjdCguLi52YWxDeHQpfWBcbiAgcmV0dXJuIGNvbnRleHQgIT09IG5pbCA/IF9gJHtmdW5jfS5jYWxsKCR7Y29udGV4dH0sICR7YXJnc30pYCA6IF9gJHtmdW5jfSgke2FyZ3N9KWBcbn1cblxuY29uc3QgbmV3UmVnRXhwID0gX2BuZXcgUmVnRXhwYFxuXG5leHBvcnQgZnVuY3Rpb24gdXNlUGF0dGVybih7Z2VuLCBpdDoge29wdHN9fTogS2V5d29yZEN4dCwgcGF0dGVybjogc3RyaW5nKTogTmFtZSB7XG4gIGNvbnN0IHUgPSBvcHRzLnVuaWNvZGVSZWdFeHAgPyBcInVcIiA6IFwiXCJcbiAgY29uc3Qge3JlZ0V4cH0gPSBvcHRzLmNvZGVcbiAgY29uc3QgcnggPSByZWdFeHAocGF0dGVybiwgdSlcblxuICByZXR1cm4gZ2VuLnNjb3BlVmFsdWUoXCJwYXR0ZXJuXCIsIHtcbiAgICBrZXk6IHJ4LnRvU3RyaW5nKCksXG4gICAgcmVmOiByeCxcbiAgICBjb2RlOiBfYCR7cmVnRXhwLmNvZGUgPT09IFwibmV3IFJlZ0V4cFwiID8gbmV3UmVnRXhwIDogdXNlRnVuYyhnZW4sIHJlZ0V4cCl9KCR7cGF0dGVybn0sICR7dX0pYCxcbiAgfSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQXJyYXkoY3h0OiBLZXl3b3JkQ3h0KTogTmFtZSB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgaWYgKGl0LmFsbEVycm9ycykge1xuICAgIGNvbnN0IHZhbGlkQXJyID0gZ2VuLmxldChcInZhbGlkXCIsIHRydWUpXG4gICAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYXNzaWduKHZhbGlkQXJyLCBmYWxzZSkpXG4gICAgcmV0dXJuIHZhbGlkQXJyXG4gIH1cbiAgZ2VuLnZhcih2YWxpZCwgdHJ1ZSlcbiAgdmFsaWRhdGVJdGVtcygoKSA9PiBnZW4uYnJlYWsoKSlcbiAgcmV0dXJuIHZhbGlkXG5cbiAgZnVuY3Rpb24gdmFsaWRhdGVJdGVtcyhub3RWYWxpZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIGNvbnN0IGxlbiA9IGdlbi5jb25zdChcImxlblwiLCBfYCR7ZGF0YX0ubGVuZ3RoYClcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIDAsIGxlbiwgKGkpID0+IHtcbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5OdW0sXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgICBnZW4uaWYobm90KHZhbGlkKSwgbm90VmFsaWQpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVVbmlvbihjeHQ6IEtleXdvcmRDeHQpOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBrZXl3b3JkLCBpdH0gPSBjeHRcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgY29uc3QgYWx3YXlzVmFsaWQgPSBzY2hlbWEuc29tZSgoc2NoOiBBbnlTY2hlbWEpID0+IGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKVxuICBpZiAoYWx3YXlzVmFsaWQgJiYgIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuXG4gIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG5cbiAgZ2VuLmJsb2NrKCgpID0+XG4gICAgc2NoZW1hLmZvckVhY2goKF9zY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAga2V5d29yZCxcbiAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIHNjaFZhbGlkXG4gICAgICApXG4gICAgICBnZW4uYXNzaWduKHZhbGlkLCBfYCR7dmFsaWR9IHx8ICR7c2NoVmFsaWR9YClcbiAgICAgIGNvbnN0IG1lcmdlZCA9IGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgc2NoVmFsaWQpXG4gICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzL0l0ZW1zYCBub3Qgc3VwcG9ydGVkIChvcHRzLnVuZXZhbHVhdGVkICE9PSB0cnVlKVxuICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgYW5kIGl0ZW1zIHdlcmUgZXZhbHVhdGVkIChpdC5wcm9wcyA9PT0gdHJ1ZSAmJiBpdC5pdGVtcyA9PT0gdHJ1ZSlcbiAgICAgIGlmICghbWVyZ2VkKSBnZW4uaWYobm90KHZhbGlkKSlcbiAgICB9KVxuICApXG5cbiAgY3h0LnJlc3VsdChcbiAgICB2YWxpZCxcbiAgICAoKSA9PiBjeHQucmVzZXQoKSxcbiAgICAoKSA9PiBjeHQuZXJyb3IodHJ1ZSlcbiAgKVxufVxuIiwgImltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLlwiXG5pbXBvcnQgdHlwZSB7XG4gIEFueVNjaGVtYSxcbiAgU2NoZW1hVmFsaWRhdGVGdW5jdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge1NjaGVtYU9iakN4dH0gZnJvbSBcIi4uXCJcbmltcG9ydCB7XywgbmlsLCBub3QsIHN0cmluZ2lmeSwgQ29kZSwgTmFtZSwgQ29kZUdlbn0gZnJvbSBcIi4uL2NvZGVnZW5cIlxuaW1wb3J0IE4gZnJvbSBcIi4uL25hbWVzXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7Y2FsbFZhbGlkYXRlQ29kZX0gZnJvbSBcIi4uLy4uL3ZvY2FidWxhcmllcy9jb2RlXCJcbmltcG9ydCB7ZXh0ZW5kRXJyb3JzfSBmcm9tIFwiLi4vZXJyb3JzXCJcblxudHlwZSBLZXl3b3JkQ29tcGlsYXRpb25SZXN1bHQgPSBBbnlTY2hlbWEgfCBTY2hlbWFWYWxpZGF0ZUZ1bmN0aW9uIHwgQW55VmFsaWRhdGVGdW5jdGlvblxuXG5leHBvcnQgZnVuY3Rpb24gbWFjcm9LZXl3b3JkQ29kZShjeHQ6IEtleXdvcmRDeHQsIGRlZjogTWFjcm9LZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gIGNvbnN0IG1hY3JvU2NoZW1hID0gZGVmLm1hY3JvLmNhbGwoaXQuc2VsZiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGl0KVxuICBjb25zdCBzY2hlbWFSZWYgPSB1c2VLZXl3b3JkKGdlbiwga2V5d29yZCwgbWFjcm9TY2hlbWEpXG4gIGlmIChpdC5vcHRzLnZhbGlkYXRlU2NoZW1hICE9PSBmYWxzZSkgaXQuc2VsZi52YWxpZGF0ZVNjaGVtYShtYWNyb1NjaGVtYSwgdHJ1ZSlcblxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgY3h0LnN1YnNjaGVtYShcbiAgICB7XG4gICAgICBzY2hlbWE6IG1hY3JvU2NoZW1hLFxuICAgICAgc2NoZW1hUGF0aDogbmlsLFxuICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICB0b3BTY2hlbWFSZWY6IHNjaGVtYVJlZixcbiAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgfSxcbiAgICB2YWxpZFxuICApXG4gIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jS2V5d29yZENvZGUoY3h0OiBLZXl3b3JkQ3h0LCBkZWY6IEZ1bmNLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBrZXl3b3JkLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgJGRhdGEsIGl0fSA9IGN4dFxuICBjaGVja0FzeW5jS2V5d29yZChpdCwgZGVmKVxuICBjb25zdCB2YWxpZGF0ZSA9XG4gICAgISRkYXRhICYmIGRlZi5jb21waWxlID8gZGVmLmNvbXBpbGUuY2FsbChpdC5zZWxmLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXQpIDogZGVmLnZhbGlkYXRlXG4gIGNvbnN0IHZhbGlkYXRlUmVmID0gdXNlS2V5d29yZChnZW4sIGtleXdvcmQsIHZhbGlkYXRlKVxuICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiKVxuICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgdmFsaWRhdGVLZXl3b3JkKVxuICBjeHQub2soZGVmLnZhbGlkID8/IHZhbGlkKVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlS2V5d29yZCgpOiB2b2lkIHtcbiAgICBpZiAoZGVmLmVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgIGFzc2lnblZhbGlkKClcbiAgICAgIGlmIChkZWYubW9kaWZ5aW5nKSBtb2RpZnlEYXRhKGN4dClcbiAgICAgIHJlcG9ydEVycnMoKCkgPT4gY3h0LmVycm9yKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJ1bGVFcnJzID0gZGVmLmFzeW5jID8gdmFsaWRhdGVBc3luYygpIDogdmFsaWRhdGVTeW5jKClcbiAgICAgIGlmIChkZWYubW9kaWZ5aW5nKSBtb2RpZnlEYXRhKGN4dClcbiAgICAgIHJlcG9ydEVycnMoKCkgPT4gYWRkRXJycyhjeHQsIHJ1bGVFcnJzKSlcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUFzeW5jKCk6IE5hbWUge1xuICAgIGNvbnN0IHJ1bGVFcnJzID0gZ2VuLmxldChcInJ1bGVFcnJzXCIsIG51bGwpXG4gICAgZ2VuLnRyeShcbiAgICAgICgpID0+IGFzc2lnblZhbGlkKF9gYXdhaXQgYCksXG4gICAgICAoZSkgPT5cbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpLmlmKFxuICAgICAgICAgIF9gJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9YCxcbiAgICAgICAgICAoKSA9PiBnZW4uYXNzaWduKHJ1bGVFcnJzLCBfYCR7ZX0uZXJyb3JzYCksXG4gICAgICAgICAgKCkgPT4gZ2VuLnRocm93KGUpXG4gICAgICAgIClcbiAgICApXG4gICAgcmV0dXJuIHJ1bGVFcnJzXG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN5bmMoKTogQ29kZSB7XG4gICAgY29uc3QgdmFsaWRhdGVFcnJzID0gX2Ake3ZhbGlkYXRlUmVmfS5lcnJvcnNgXG4gICAgZ2VuLmFzc2lnbih2YWxpZGF0ZUVycnMsIG51bGwpXG4gICAgYXNzaWduVmFsaWQobmlsKVxuICAgIHJldHVybiB2YWxpZGF0ZUVycnNcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnblZhbGlkKF9hd2FpdDogQ29kZSA9IGRlZi5hc3luYyA/IF9gYXdhaXQgYCA6IG5pbCk6IHZvaWQge1xuICAgIGNvbnN0IHBhc3NDeHQgPSBpdC5vcHRzLnBhc3NDb250ZXh0ID8gTi50aGlzIDogTi5zZWxmXG4gICAgY29uc3QgcGFzc1NjaGVtYSA9ICEoKFwiY29tcGlsZVwiIGluIGRlZiAmJiAhJGRhdGEpIHx8IGRlZi5zY2hlbWEgPT09IGZhbHNlKVxuICAgIGdlbi5hc3NpZ24oXG4gICAgICB2YWxpZCxcbiAgICAgIF9gJHtfYXdhaXR9JHtjYWxsVmFsaWRhdGVDb2RlKGN4dCwgdmFsaWRhdGVSZWYsIHBhc3NDeHQsIHBhc3NTY2hlbWEpfWAsXG4gICAgICBkZWYubW9kaWZ5aW5nXG4gICAgKVxuICB9XG5cbiAgZnVuY3Rpb24gcmVwb3J0RXJycyhlcnJvcnM6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICBnZW4uaWYobm90KGRlZi52YWxpZCA/PyB2YWxpZCksIGVycm9ycylcbiAgfVxufVxuXG5mdW5jdGlvbiBtb2RpZnlEYXRhKGN4dDogS2V5d29yZEN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgZ2VuLmlmKGl0LnBhcmVudERhdGEsICgpID0+IGdlbi5hc3NpZ24oZGF0YSwgX2Ake2l0LnBhcmVudERhdGF9WyR7aXQucGFyZW50RGF0YVByb3BlcnR5fV1gKSlcbn1cblxuZnVuY3Rpb24gYWRkRXJycyhjeHQ6IEtleXdvcmRDeHQsIGVycnM6IENvZGUpOiB2b2lkIHtcbiAgY29uc3Qge2dlbn0gPSBjeHRcbiAgZ2VuLmlmKFxuICAgIF9gQXJyYXkuaXNBcnJheSgke2VycnN9KWAsXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuXG4gICAgICAgIC5hc3NpZ24oTi52RXJyb3JzLCBfYCR7Ti52RXJyb3JzfSA9PT0gbnVsbCA/ICR7ZXJyc30gOiAke04udkVycm9yc30uY29uY2F0KCR7ZXJyc30pYClcbiAgICAgICAgLmFzc2lnbihOLmVycm9ycywgX2Ake04udkVycm9yc30ubGVuZ3RoYClcbiAgICAgIGV4dGVuZEVycm9ycyhjeHQpXG4gICAgfSxcbiAgICAoKSA9PiBjeHQuZXJyb3IoKVxuICApXG59XG5cbmZ1bmN0aW9uIGNoZWNrQXN5bmNLZXl3b3JkKHtzY2hlbWFFbnZ9OiBTY2hlbWFPYmpDeHQsIGRlZjogRnVuY0tleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGlmIChkZWYuYXN5bmMgJiYgIXNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIGtleXdvcmQgaW4gc3luYyBzY2hlbWFcIilcbn1cblxuZnVuY3Rpb24gdXNlS2V5d29yZChnZW46IENvZGVHZW4sIGtleXdvcmQ6IHN0cmluZywgcmVzdWx0PzogS2V5d29yZENvbXBpbGF0aW9uUmVzdWx0KTogTmFtZSB7XG4gIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKGBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiIGZhaWxlZCB0byBjb21waWxlYClcbiAgcmV0dXJuIGdlbi5zY29wZVZhbHVlKFxuICAgIFwia2V5d29yZFwiLFxuICAgIHR5cGVvZiByZXN1bHQgPT0gXCJmdW5jdGlvblwiID8ge3JlZjogcmVzdWx0fSA6IHtyZWY6IHJlc3VsdCwgY29kZTogc3RyaW5naWZ5KHJlc3VsdCl9XG4gIClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkU2NoZW1hVHlwZShcbiAgc2NoZW1hOiB1bmtub3duLFxuICBzY2hlbWFUeXBlOiBKU09OVHlwZVtdLFxuICBhbGxvd1VuZGVmaW5lZCA9IGZhbHNlXG4pOiBib29sZWFuIHtcbiAgLy8gVE9ETyBhZGQgdGVzdHNcbiAgcmV0dXJuIChcbiAgICAhc2NoZW1hVHlwZS5sZW5ndGggfHxcbiAgICBzY2hlbWFUeXBlLnNvbWUoKHN0KSA9PlxuICAgICAgc3QgPT09IFwiYXJyYXlcIlxuICAgICAgICA/IEFycmF5LmlzQXJyYXkoc2NoZW1hKVxuICAgICAgICA6IHN0ID09PSBcIm9iamVjdFwiXG4gICAgICAgID8gc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpXG4gICAgICAgIDogdHlwZW9mIHNjaGVtYSA9PSBzdCB8fCAoYWxsb3dVbmRlZmluZWQgJiYgdHlwZW9mIHNjaGVtYSA9PSBcInVuZGVmaW5lZFwiKVxuICAgIClcbiAgKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVLZXl3b3JkVXNhZ2UoXG4gIHtzY2hlbWEsIG9wdHMsIHNlbGYsIGVyclNjaGVtYVBhdGh9OiBTY2hlbWFPYmpDeHQsXG4gIGRlZjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAga2V5d29yZDogc3RyaW5nXG4pOiB2b2lkIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChBcnJheS5pc0FycmF5KGRlZi5rZXl3b3JkKSA/ICFkZWYua2V5d29yZC5pbmNsdWRlcyhrZXl3b3JkKSA6IGRlZi5rZXl3b3JkICE9PSBrZXl3b3JkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gIH1cblxuICBjb25zdCBkZXBzID0gZGVmLmRlcGVuZGVuY2llc1xuICBpZiAoZGVwcz8uc29tZSgoa3dkKSA9PiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNjaGVtYSwga3dkKSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYHBhcmVudCBzY2hlbWEgbXVzdCBoYXZlIGRlcGVuZGVuY2llcyBvZiAke2tleXdvcmR9OiAke2RlcHMuam9pbihcIixcIil9YClcbiAgfVxuXG4gIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICBjb25zdCB2YWxpZCA9IGRlZi52YWxpZGF0ZVNjaGVtYShzY2hlbWFba2V5d29yZF0pXG4gICAgaWYgKCF2YWxpZCkge1xuICAgICAgY29uc3QgbXNnID1cbiAgICAgICAgYGtleXdvcmQgXCIke2tleXdvcmR9XCIgdmFsdWUgaXMgaW52YWxpZCBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiOiBgICtcbiAgICAgICAgc2VsZi5lcnJvcnNUZXh0KGRlZi52YWxpZGF0ZVNjaGVtYS5lcnJvcnMpXG4gICAgICBpZiAob3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIikgc2VsZi5sb2dnZXIuZXJyb3IobXNnKVxuICAgICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IobXNnKVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi5cIlxuaW1wb3J0IHtfLCBzdHIsIGdldFByb3BlcnR5LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQge2VzY2FwZUZyYWdtZW50LCBnZXRFcnJvclBhdGgsIFR5cGV9IGZyb20gXCIuLi91dGlsXCJcbmltcG9ydCB0eXBlIHtKU09OVHlwZX0gZnJvbSBcIi4uL3J1bGVzXCJcblxuZXhwb3J0IGludGVyZmFjZSBTdWJzY2hlbWFDb250ZXh0IHtcbiAgLy8gVE9ETyB1c2UgT3B0aW9uYWw/IGFsaWduIHdpdGggU2NoZW1DeHQgcHJvcGVydHkgdHlwZXNcbiAgc2NoZW1hOiBBbnlTY2hlbWFcbiAgc2NoZW1hUGF0aDogQ29kZVxuICBlcnJTY2hlbWFQYXRoOiBzdHJpbmdcbiAgdG9wU2NoZW1hUmVmPzogQ29kZVxuICBlcnJvclBhdGg/OiBDb2RlXG4gIGRhdGFMZXZlbD86IG51bWJlclxuICBkYXRhVHlwZXM/OiBKU09OVHlwZVtdXG4gIGRhdGE/OiBOYW1lXG4gIHBhcmVudERhdGE/OiBOYW1lXG4gIHBhcmVudERhdGFQcm9wZXJ0eT86IENvZGUgfCBudW1iZXJcbiAgZGF0YU5hbWVzPzogTmFtZVtdXG4gIGRhdGFQYXRoQXJyPzogKENvZGUgfCBudW1iZXIpW11cbiAgcHJvcGVydHlOYW1lPzogTmFtZVxuICBqdGREaXNjcmltaW5hdG9yPzogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhPzogYm9vbGVhblxuICBjb21wb3NpdGVSdWxlPzogdHJ1ZVxuICBjcmVhdGVFcnJvcnM/OiBib29sZWFuXG4gIGFsbEVycm9ycz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgU3Vic2NoZW1hQXJncyA9IFBhcnRpYWw8e1xuICBrZXl3b3JkOiBzdHJpbmdcbiAgc2NoZW1hUHJvcDogc3RyaW5nIHwgbnVtYmVyXG4gIHNjaGVtYTogQW55U2NoZW1hXG4gIHNjaGVtYVBhdGg6IENvZGVcbiAgZXJyU2NoZW1hUGF0aDogc3RyaW5nXG4gIHRvcFNjaGVtYVJlZjogQ29kZVxuICBkYXRhOiBOYW1lIHwgQ29kZVxuICBkYXRhUHJvcDogQ29kZSB8IHN0cmluZyB8IG51bWJlclxuICBkYXRhVHlwZXM6IEpTT05UeXBlW11cbiAgZGVmaW5lZFByb3BlcnRpZXM6IFNldDxzdHJpbmc+XG4gIHByb3BlcnR5TmFtZTogTmFtZVxuICBkYXRhUHJvcFR5cGU6IFR5cGVcbiAganRkRGlzY3JpbWluYXRvcjogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhOiBib29sZWFuXG4gIGNvbXBvc2l0ZVJ1bGU6IHRydWVcbiAgY3JlYXRlRXJyb3JzOiBib29sZWFuXG4gIGFsbEVycm9yczogYm9vbGVhblxufT5cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFN1YnNjaGVtYShcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAge2tleXdvcmQsIHNjaGVtYVByb3AsIHNjaGVtYSwgc2NoZW1hUGF0aCwgZXJyU2NoZW1hUGF0aCwgdG9wU2NoZW1hUmVmfTogU3Vic2NoZW1hQXJnc1xuKTogU3Vic2NoZW1hQ29udGV4dCB7XG4gIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQgJiYgc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2JvdGggXCJrZXl3b3JkXCIgYW5kIFwic2NoZW1hXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJylcbiAgfVxuXG4gIGlmIChrZXl3b3JkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzY2ggPSBpdC5zY2hlbWFba2V5d29yZF1cbiAgICByZXR1cm4gc2NoZW1hUHJvcCA9PT0gdW5kZWZpbmVkXG4gICAgICA/IHtcbiAgICAgICAgICBzY2hlbWE6IHNjaCxcbiAgICAgICAgICBzY2hlbWFQYXRoOiBfYCR7aXQuc2NoZW1hUGF0aH0ke2dldFByb3BlcnR5KGtleXdvcmQpfWAsXG4gICAgICAgICAgZXJyU2NoZW1hUGF0aDogYCR7aXQuZXJyU2NoZW1hUGF0aH0vJHtrZXl3b3JkfWAsXG4gICAgICAgIH1cbiAgICAgIDoge1xuICAgICAgICAgIHNjaGVtYTogc2NoW3NjaGVtYVByb3BdLFxuICAgICAgICAgIHNjaGVtYVBhdGg6IF9gJHtpdC5zY2hlbWFQYXRofSR7Z2V0UHJvcGVydHkoa2V5d29yZCl9JHtnZXRQcm9wZXJ0eShzY2hlbWFQcm9wKX1gLFxuICAgICAgICAgIGVyclNjaGVtYVBhdGg6IGAke2l0LmVyclNjaGVtYVBhdGh9LyR7a2V5d29yZH0vJHtlc2NhcGVGcmFnbWVudChzY2hlbWFQcm9wKX1gLFxuICAgICAgICB9XG4gIH1cblxuICBpZiAoc2NoZW1hICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoc2NoZW1hUGF0aCA9PT0gdW5kZWZpbmVkIHx8IGVyclNjaGVtYVBhdGggPT09IHVuZGVmaW5lZCB8fCB0b3BTY2hlbWFSZWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNjaGVtYVBhdGhcIiwgXCJlcnJTY2hlbWFQYXRoXCIgYW5kIFwidG9wU2NoZW1hUmVmXCIgYXJlIHJlcXVpcmVkIHdpdGggXCJzY2hlbWFcIicpXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWEsXG4gICAgICBzY2hlbWFQYXRoLFxuICAgICAgdG9wU2NoZW1hUmVmLFxuICAgICAgZXJyU2NoZW1hUGF0aCxcbiAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ2VpdGhlciBcImtleXdvcmRcIiBvciBcInNjaGVtYVwiIG11c3QgYmUgcGFzc2VkJylcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZFN1YnNjaGVtYURhdGEoXG4gIHN1YnNjaGVtYTogU3Vic2NoZW1hQ29udGV4dCxcbiAgaXQ6IFNjaGVtYU9iakN4dCxcbiAge2RhdGFQcm9wLCBkYXRhUHJvcFR5cGU6IGRwVHlwZSwgZGF0YSwgZGF0YVR5cGVzLCBwcm9wZXJ0eU5hbWV9OiBTdWJzY2hlbWFBcmdzXG4pOiB2b2lkIHtcbiAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCAmJiBkYXRhUHJvcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdib3RoIFwiZGF0YVwiIGFuZCBcImRhdGFQcm9wXCIgcGFzc2VkLCBvbmx5IG9uZSBhbGxvd2VkJylcbiAgfVxuXG4gIGNvbnN0IHtnZW59ID0gaXRcblxuICBpZiAoZGF0YVByb3AgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IHtlcnJvclBhdGgsIGRhdGFQYXRoQXJyLCBvcHRzfSA9IGl0XG4gICAgY29uc3QgbmV4dERhdGEgPSBnZW4ubGV0KFwiZGF0YVwiLCBfYCR7aXQuZGF0YX0ke2dldFByb3BlcnR5KGRhdGFQcm9wKX1gLCB0cnVlKVxuICAgIGRhdGFDb250ZXh0UHJvcHMobmV4dERhdGEpXG4gICAgc3Vic2NoZW1hLmVycm9yUGF0aCA9IHN0cmAke2Vycm9yUGF0aH0ke2dldEVycm9yUGF0aChkYXRhUHJvcCwgZHBUeXBlLCBvcHRzLmpzUHJvcGVydHlTeW50YXgpfWBcbiAgICBzdWJzY2hlbWEucGFyZW50RGF0YVByb3BlcnR5ID0gX2Ake2RhdGFQcm9wfWBcbiAgICBzdWJzY2hlbWEuZGF0YVBhdGhBcnIgPSBbLi4uZGF0YVBhdGhBcnIsIHN1YnNjaGVtYS5wYXJlbnREYXRhUHJvcGVydHldXG4gIH1cblxuICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc3QgbmV4dERhdGEgPSBkYXRhIGluc3RhbmNlb2YgTmFtZSA/IGRhdGEgOiBnZW4ubGV0KFwiZGF0YVwiLCBkYXRhLCB0cnVlKSAvLyByZXBsYWNlYWJsZSBpZiB1c2VkIG9uY2U/XG4gICAgZGF0YUNvbnRleHRQcm9wcyhuZXh0RGF0YSlcbiAgICBpZiAocHJvcGVydHlOYW1lICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5wcm9wZXJ0eU5hbWUgPSBwcm9wZXJ0eU5hbWVcbiAgICAvLyBUT0RPIHNvbWV0aGluZyBpcyBwb3NzaWJseSB3cm9uZyBoZXJlIHdpdGggbm90IGNoYW5naW5nIHBhcmVudERhdGFQcm9wZXJ0eSBhbmQgbm90IGFwcGVuZGluZyBkYXRhUGF0aEFyclxuICB9XG5cbiAgaWYgKGRhdGFUeXBlcykgc3Vic2NoZW1hLmRhdGFUeXBlcyA9IGRhdGFUeXBlc1xuXG4gIGZ1bmN0aW9uIGRhdGFDb250ZXh0UHJvcHMoX25leHREYXRhOiBOYW1lKTogdm9pZCB7XG4gICAgc3Vic2NoZW1hLmRhdGEgPSBfbmV4dERhdGFcbiAgICBzdWJzY2hlbWEuZGF0YUxldmVsID0gaXQuZGF0YUxldmVsICsgMVxuICAgIHN1YnNjaGVtYS5kYXRhVHlwZXMgPSBbXVxuICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzID0gbmV3IFNldDxzdHJpbmc+KClcbiAgICBzdWJzY2hlbWEucGFyZW50RGF0YSA9IGl0LmRhdGFcbiAgICBzdWJzY2hlbWEuZGF0YU5hbWVzID0gWy4uLml0LmRhdGFOYW1lcywgX25leHREYXRhXVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmRTdWJzY2hlbWFNb2RlKFxuICBzdWJzY2hlbWE6IFN1YnNjaGVtYUNvbnRleHQsXG4gIHtqdGREaXNjcmltaW5hdG9yLCBqdGRNZXRhZGF0YSwgY29tcG9zaXRlUnVsZSwgY3JlYXRlRXJyb3JzLCBhbGxFcnJvcnN9OiBTdWJzY2hlbWFBcmdzXG4pOiB2b2lkIHtcbiAgaWYgKGNvbXBvc2l0ZVJ1bGUgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmNvbXBvc2l0ZVJ1bGUgPSBjb21wb3NpdGVSdWxlXG4gIGlmIChjcmVhdGVFcnJvcnMgIT09IHVuZGVmaW5lZCkgc3Vic2NoZW1hLmNyZWF0ZUVycm9ycyA9IGNyZWF0ZUVycm9yc1xuICBpZiAoYWxsRXJyb3JzICE9PSB1bmRlZmluZWQpIHN1YnNjaGVtYS5hbGxFcnJvcnMgPSBhbGxFcnJvcnNcbiAgc3Vic2NoZW1hLmp0ZERpc2NyaW1pbmF0b3IgPSBqdGREaXNjcmltaW5hdG9yIC8vIG5vdCBpbmhlcml0ZWRcbiAgc3Vic2NoZW1hLmp0ZE1ldGFkYXRhID0ganRkTWV0YWRhdGEgLy8gbm90IGluaGVyaXRlZFxufVxuIiwgIid1c2Ugc3RyaWN0JztcblxuLy8gZG8gbm90IGVkaXQgLmpzIGZpbGVzIGRpcmVjdGx5IC0gZWRpdCBzcmMvaW5kZXguanN0XG5cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuXG4gIGlmIChhICYmIGIgJiYgdHlwZW9mIGEgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGIgPT0gJ29iamVjdCcpIHtcbiAgICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3RvcikgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxlbmd0aCwgaSwga2V5cztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuXG5cbiAgICBpZiAoYS5jb25zdHJ1Y3RvciA9PT0gUmVnRXhwKSByZXR1cm4gYS5zb3VyY2UgPT09IGIuc291cmNlICYmIGEuZmxhZ3MgPT09IGIuZmxhZ3M7XG4gICAgaWYgKGEudmFsdWVPZiAhPT0gT2JqZWN0LnByb3RvdHlwZS52YWx1ZU9mKSByZXR1cm4gYS52YWx1ZU9mKCkgPT09IGIudmFsdWVPZigpO1xuICAgIGlmIChhLnRvU3RyaW5nICE9PSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nKSByZXR1cm4gYS50b1N0cmluZygpID09PSBiLnRvU3RyaW5nKCk7XG5cbiAgICBrZXlzID0gT2JqZWN0LmtleXMoYSk7XG4gICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMoYikubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG5cbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSAhPT0gMDspXG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBrZXlzW2ldKSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gIT09IDA7KSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcblxuICAgICAgaWYgKCFlcXVhbChhW2tleV0sIGJba2V5XSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIHRydWUgaWYgYm90aCBOYU4sIGZhbHNlIG90aGVyd2lzZVxuICByZXR1cm4gYSE9PWEgJiYgYiE9PWI7XG59O1xuIiwgIid1c2Ugc3RyaWN0JztcblxudmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2NoZW1hLCBvcHRzLCBjYikge1xuICAvLyBMZWdhY3kgc3VwcG9ydCBmb3IgdjAuMy4xIGFuZCBlYXJsaWVyLlxuICBpZiAodHlwZW9mIG9wdHMgPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cblxuICBjYiA9IG9wdHMuY2IgfHwgY2I7XG4gIHZhciBwcmUgPSAodHlwZW9mIGNiID09ICdmdW5jdGlvbicpID8gY2IgOiBjYi5wcmUgfHwgZnVuY3Rpb24oKSB7fTtcbiAgdmFyIHBvc3QgPSBjYi5wb3N0IHx8IGZ1bmN0aW9uKCkge307XG5cbiAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCAnJywgc2NoZW1hKTtcbn07XG5cblxudHJhdmVyc2Uua2V5d29yZHMgPSB7XG4gIGFkZGl0aW9uYWxJdGVtczogdHJ1ZSxcbiAgaXRlbXM6IHRydWUsXG4gIGNvbnRhaW5zOiB0cnVlLFxuICBhZGRpdGlvbmFsUHJvcGVydGllczogdHJ1ZSxcbiAgcHJvcGVydHlOYW1lczogdHJ1ZSxcbiAgbm90OiB0cnVlLFxuICBpZjogdHJ1ZSxcbiAgdGhlbjogdHJ1ZSxcbiAgZWxzZTogdHJ1ZVxufTtcblxudHJhdmVyc2UuYXJyYXlLZXl3b3JkcyA9IHtcbiAgaXRlbXM6IHRydWUsXG4gIGFsbE9mOiB0cnVlLFxuICBhbnlPZjogdHJ1ZSxcbiAgb25lT2Y6IHRydWVcbn07XG5cbnRyYXZlcnNlLnByb3BzS2V5d29yZHMgPSB7XG4gICRkZWZzOiB0cnVlLFxuICBkZWZpbml0aW9uczogdHJ1ZSxcbiAgcHJvcGVydGllczogdHJ1ZSxcbiAgcGF0dGVyblByb3BlcnRpZXM6IHRydWUsXG4gIGRlcGVuZGVuY2llczogdHJ1ZVxufTtcblxudHJhdmVyc2Uuc2tpcEtleXdvcmRzID0ge1xuICBkZWZhdWx0OiB0cnVlLFxuICBlbnVtOiB0cnVlLFxuICBjb25zdDogdHJ1ZSxcbiAgcmVxdWlyZWQ6IHRydWUsXG4gIG1heGltdW06IHRydWUsXG4gIG1pbmltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1heGltdW06IHRydWUsXG4gIGV4Y2x1c2l2ZU1pbmltdW06IHRydWUsXG4gIG11bHRpcGxlT2Y6IHRydWUsXG4gIG1heExlbmd0aDogdHJ1ZSxcbiAgbWluTGVuZ3RoOiB0cnVlLFxuICBwYXR0ZXJuOiB0cnVlLFxuICBmb3JtYXQ6IHRydWUsXG4gIG1heEl0ZW1zOiB0cnVlLFxuICBtaW5JdGVtczogdHJ1ZSxcbiAgdW5pcXVlSXRlbXM6IHRydWUsXG4gIG1heFByb3BlcnRpZXM6IHRydWUsXG4gIG1pblByb3BlcnRpZXM6IHRydWVcbn07XG5cblxuZnVuY3Rpb24gX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoZW1hLCBqc29uUHRyLCByb290U2NoZW1hLCBwYXJlbnRKc29uUHRyLCBwYXJlbnRLZXl3b3JkLCBwYXJlbnRTY2hlbWEsIGtleUluZGV4KSB7XG4gIGlmIChzY2hlbWEgJiYgdHlwZW9mIHNjaGVtYSA9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShzY2hlbWEpKSB7XG4gICAgcHJlKHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gICAgZm9yICh2YXIga2V5IGluIHNjaGVtYSkge1xuICAgICAgdmFyIHNjaCA9IHNjaGVtYVtrZXldO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc2NoKSkge1xuICAgICAgICBpZiAoa2V5IGluIHRyYXZlcnNlLmFycmF5S2V5d29yZHMpIHtcbiAgICAgICAgICBmb3IgKHZhciBpPTA7IGk8c2NoLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW2ldLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgaSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIGkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5wcm9wc0tleXdvcmRzKSB7XG4gICAgICAgIGlmIChzY2ggJiYgdHlwZW9mIHNjaCA9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gc2NoKVxuICAgICAgICAgICAgX3RyYXZlcnNlKG9wdHMsIHByZSwgcG9zdCwgc2NoW3Byb3BdLCBqc29uUHRyICsgJy8nICsga2V5ICsgJy8nICsgZXNjYXBlSnNvblB0cihwcm9wKSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEsIHByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGtleSBpbiB0cmF2ZXJzZS5rZXl3b3JkcyB8fCAob3B0cy5hbGxLZXlzICYmICEoa2V5IGluIHRyYXZlcnNlLnNraXBLZXl3b3JkcykpKSB7XG4gICAgICAgIF90cmF2ZXJzZShvcHRzLCBwcmUsIHBvc3QsIHNjaCwganNvblB0ciArICcvJyArIGtleSwgcm9vdFNjaGVtYSwganNvblB0ciwga2V5LCBzY2hlbWEpO1xuICAgICAgfVxuICAgIH1cbiAgICBwb3N0KHNjaGVtYSwganNvblB0ciwgcm9vdFNjaGVtYSwgcGFyZW50SnNvblB0ciwgcGFyZW50S2V5d29yZCwgcGFyZW50U2NoZW1hLCBrZXlJbmRleCk7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBlc2NhcGVKc29uUHRyKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL34vZywgJ34wJykucmVwbGFjZSgvXFwvL2csICd+MScpO1xufVxuIiwgImltcG9ydCB0eXBlIHtBbnlTY2hlbWEsIEFueVNjaGVtYU9iamVjdCwgVXJpUmVzb2x2ZXJ9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcIi4uL2FqdlwiXG5pbXBvcnQgdHlwZSB7VVJJQ29tcG9uZW50fSBmcm9tIFwiZmFzdC11cmlcIlxuaW1wb3J0IHtlYWNoSXRlbX0gZnJvbSBcIi4vdXRpbFwiXG5pbXBvcnQgKiBhcyBlcXVhbCBmcm9tIFwiZmFzdC1kZWVwLWVxdWFsXCJcbmltcG9ydCAqIGFzIHRyYXZlcnNlIGZyb20gXCJqc29uLXNjaGVtYS10cmF2ZXJzZVwiXG5cbi8vIHRoZSBoYXNoIG9mIGxvY2FsIHJlZmVyZW5jZXMgaW5zaWRlIHRoZSBzY2hlbWEgKGNyZWF0ZWQgYnkgZ2V0U2NoZW1hUmVmcyksIHVzZWQgZm9yIGlubGluZSByZXNvbHV0aW9uXG5leHBvcnQgdHlwZSBMb2NhbFJlZnMgPSB7W1JlZiBpbiBzdHJpbmddPzogQW55U2NoZW1hT2JqZWN0fVxuXG4vLyBUT0RPIHJlZmFjdG9yIHRvIHVzZSBrZXl3b3JkIGRlZmluaXRpb25zXG5jb25zdCBTSU1QTEVfSU5MSU5FRCA9IG5ldyBTZXQoW1xuICBcInR5cGVcIixcbiAgXCJmb3JtYXRcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwibWF4TGVuZ3RoXCIsXG4gIFwibWluTGVuZ3RoXCIsXG4gIFwibWF4UHJvcGVydGllc1wiLFxuICBcIm1pblByb3BlcnRpZXNcIixcbiAgXCJtYXhJdGVtc1wiLFxuICBcIm1pbkl0ZW1zXCIsXG4gIFwibWF4aW11bVwiLFxuICBcIm1pbmltdW1cIixcbiAgXCJ1bmlxdWVJdGVtc1wiLFxuICBcIm11bHRpcGxlT2ZcIixcbiAgXCJyZXF1aXJlZFwiLFxuICBcImVudW1cIixcbiAgXCJjb25zdFwiLFxuXSlcblxuZXhwb3J0IGZ1bmN0aW9uIGlubGluZVJlZihzY2hlbWE6IEFueVNjaGVtYSwgbGltaXQ6IGJvb2xlYW4gfCBudW1iZXIgPSB0cnVlKTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gdHJ1ZVxuICBpZiAobGltaXQgPT09IHRydWUpIHJldHVybiAhaGFzUmVmKHNjaGVtYSlcbiAgaWYgKCFsaW1pdCkgcmV0dXJuIGZhbHNlXG4gIHJldHVybiBjb3VudEtleXMoc2NoZW1hKSA8PSBsaW1pdFxufVxuXG5jb25zdCBSRUZfS0VZV09SRFMgPSBuZXcgU2V0KFtcbiAgXCIkcmVmXCIsXG4gIFwiJHJlY3Vyc2l2ZVJlZlwiLFxuICBcIiRyZWN1cnNpdmVBbmNob3JcIixcbiAgXCIkZHluYW1pY1JlZlwiLFxuICBcIiRkeW5hbWljQW5jaG9yXCIsXG5dKVxuXG5mdW5jdGlvbiBoYXNSZWYoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpOiBib29sZWFuIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgaWYgKFJFRl9LRVlXT1JEUy5oYXMoa2V5KSkgcmV0dXJuIHRydWVcbiAgICBjb25zdCBzY2ggPSBzY2hlbWFba2V5XVxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaCkgJiYgc2NoLnNvbWUoaGFzUmVmKSkgcmV0dXJuIHRydWVcbiAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiICYmIGhhc1JlZihzY2gpKSByZXR1cm4gdHJ1ZVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBjb3VudEtleXMoc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QpOiBudW1iZXIge1xuICBsZXQgY291bnQgPSAwXG4gIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgIGlmIChrZXkgPT09IFwiJHJlZlwiKSByZXR1cm4gSW5maW5pdHlcbiAgICBjb3VudCsrXG4gICAgaWYgKFNJTVBMRV9JTkxJTkVELmhhcyhrZXkpKSBjb250aW51ZVxuICAgIGlmICh0eXBlb2Ygc2NoZW1hW2tleV0gPT0gXCJvYmplY3RcIikge1xuICAgICAgZWFjaEl0ZW0oc2NoZW1hW2tleV0sIChzY2gpID0+IChjb3VudCArPSBjb3VudEtleXMoc2NoKSkpXG4gICAgfVxuICAgIGlmIChjb3VudCA9PT0gSW5maW5pdHkpIHJldHVybiBJbmZpbml0eVxuICB9XG4gIHJldHVybiBjb3VudFxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnVsbFBhdGgocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBpZCA9IFwiXCIsIG5vcm1hbGl6ZT86IGJvb2xlYW4pOiBzdHJpbmcge1xuICBpZiAobm9ybWFsaXplICE9PSBmYWxzZSkgaWQgPSBub3JtYWxpemVJZChpZClcbiAgY29uc3QgcCA9IHJlc29sdmVyLnBhcnNlKGlkKVxuICByZXR1cm4gX2dldEZ1bGxQYXRoKHJlc29sdmVyLCBwKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2dldEZ1bGxQYXRoKHJlc29sdmVyOiBVcmlSZXNvbHZlciwgcDogVVJJQ29tcG9uZW50KTogc3RyaW5nIHtcbiAgY29uc3Qgc2VyaWFsaXplZCA9IHJlc29sdmVyLnNlcmlhbGl6ZShwKVxuICByZXR1cm4gc2VyaWFsaXplZC5zcGxpdChcIiNcIilbMF0gKyBcIiNcIlxufVxuXG5jb25zdCBUUkFJTElOR19TTEFTSF9IQVNIID0gLyNcXC8/JC9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVJZChpZDogc3RyaW5nIHwgdW5kZWZpbmVkKTogc3RyaW5nIHtcbiAgcmV0dXJuIGlkID8gaWQucmVwbGFjZShUUkFJTElOR19TTEFTSF9IQVNILCBcIlwiKSA6IFwiXCJcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVVcmwocmVzb2x2ZXI6IFVyaVJlc29sdmVyLCBiYXNlSWQ6IHN0cmluZywgaWQ6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlkID0gbm9ybWFsaXplSWQoaWQpXG4gIHJldHVybiByZXNvbHZlci5yZXNvbHZlKGJhc2VJZCwgaWQpXG59XG5cbmNvbnN0IEFOQ0hPUiA9IC9eW2Etel9dWy1hLXowLTkuX10qJC9pXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY2hlbWFSZWZzKHRoaXM6IEFqdiwgc2NoZW1hOiBBbnlTY2hlbWEsIGJhc2VJZDogc3RyaW5nKTogTG9jYWxSZWZzIHtcbiAgaWYgKHR5cGVvZiBzY2hlbWEgPT0gXCJib29sZWFuXCIpIHJldHVybiB7fVxuICBjb25zdCB7c2NoZW1hSWQsIHVyaVJlc29sdmVyfSA9IHRoaXMub3B0c1xuICBjb25zdCBzY2hJZCA9IG5vcm1hbGl6ZUlkKHNjaGVtYVtzY2hlbWFJZF0gfHwgYmFzZUlkKVxuICBjb25zdCBiYXNlSWRzOiB7W0pzb25QdHIgaW4gc3RyaW5nXT86IHN0cmluZ30gPSB7XCJcIjogc2NoSWR9XG4gIGNvbnN0IHBhdGhQcmVmaXggPSBnZXRGdWxsUGF0aCh1cmlSZXNvbHZlciwgc2NoSWQsIGZhbHNlKVxuICBjb25zdCBsb2NhbFJlZnM6IExvY2FsUmVmcyA9IHt9XG4gIGNvbnN0IHNjaGVtYVJlZnM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpXG5cbiAgdHJhdmVyc2Uoc2NoZW1hLCB7YWxsS2V5czogdHJ1ZX0sIChzY2gsIGpzb25QdHIsIF8sIHBhcmVudEpzb25QdHIpID0+IHtcbiAgICBpZiAocGFyZW50SnNvblB0ciA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGhQcmVmaXggKyBqc29uUHRyXG4gICAgbGV0IGlubmVyQmFzZUlkID0gYmFzZUlkc1twYXJlbnRKc29uUHRyXVxuICAgIGlmICh0eXBlb2Ygc2NoW3NjaGVtYUlkXSA9PSBcInN0cmluZ1wiKSBpbm5lckJhc2VJZCA9IGFkZFJlZi5jYWxsKHRoaXMsIHNjaFtzY2hlbWFJZF0pXG4gICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRhbmNob3IpXG4gICAgYWRkQW5jaG9yLmNhbGwodGhpcywgc2NoLiRkeW5hbWljQW5jaG9yKVxuICAgIGJhc2VJZHNbanNvblB0cl0gPSBpbm5lckJhc2VJZFxuXG4gICAgZnVuY3Rpb24gYWRkUmVmKHRoaXM6IEFqdiwgcmVmOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmJvdW5kLW1ldGhvZFxuICAgICAgY29uc3QgX3Jlc29sdmUgPSB0aGlzLm9wdHMudXJpUmVzb2x2ZXIucmVzb2x2ZVxuICAgICAgcmVmID0gbm9ybWFsaXplSWQoaW5uZXJCYXNlSWQgPyBfcmVzb2x2ZShpbm5lckJhc2VJZCwgcmVmKSA6IHJlZilcbiAgICAgIGlmIChzY2hlbWFSZWZzLmhhcyhyZWYpKSB0aHJvdyBhbWJpZ3VvcyhyZWYpXG4gICAgICBzY2hlbWFSZWZzLmFkZChyZWYpXG4gICAgICBsZXQgc2NoT3JSZWYgPSB0aGlzLnJlZnNbcmVmXVxuICAgICAgaWYgKHR5cGVvZiBzY2hPclJlZiA9PSBcInN0cmluZ1wiKSBzY2hPclJlZiA9IHRoaXMucmVmc1tzY2hPclJlZl1cbiAgICAgIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJvYmplY3RcIikge1xuICAgICAgICBjaGVja0FtYmlndW9zUmVmKHNjaCwgc2NoT3JSZWYuc2NoZW1hLCByZWYpXG4gICAgICB9IGVsc2UgaWYgKHJlZiAhPT0gbm9ybWFsaXplSWQoZnVsbFBhdGgpKSB7XG4gICAgICAgIGlmIChyZWZbMF0gPT09IFwiI1wiKSB7XG4gICAgICAgICAgY2hlY2tBbWJpZ3Vvc1JlZihzY2gsIGxvY2FsUmVmc1tyZWZdLCByZWYpXG4gICAgICAgICAgbG9jYWxSZWZzW3JlZl0gPSBzY2hcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlZnNbcmVmXSA9IGZ1bGxQYXRoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZWZcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRBbmNob3IodGhpczogQWp2LCBhbmNob3I6IHVua25vd24pOiB2b2lkIHtcbiAgICAgIGlmICh0eXBlb2YgYW5jaG9yID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgaWYgKCFBTkNIT1IudGVzdChhbmNob3IpKSB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgYW5jaG9yIFwiJHthbmNob3J9XCJgKVxuICAgICAgICBhZGRSZWYuY2FsbCh0aGlzLCBgIyR7YW5jaG9yfWApXG4gICAgICB9XG4gICAgfVxuICB9KVxuXG4gIHJldHVybiBsb2NhbFJlZnNcblxuICBmdW5jdGlvbiBjaGVja0FtYmlndW9zUmVmKHNjaDE6IEFueVNjaGVtYSwgc2NoMjogQW55U2NoZW1hIHwgdW5kZWZpbmVkLCByZWY6IHN0cmluZyk6IHZvaWQge1xuICAgIGlmIChzY2gyICE9PSB1bmRlZmluZWQgJiYgIWVxdWFsKHNjaDEsIHNjaDIpKSB0aHJvdyBhbWJpZ3VvcyhyZWYpXG4gIH1cblxuICBmdW5jdGlvbiBhbWJpZ3VvcyhyZWY6IHN0cmluZyk6IEVycm9yIHtcbiAgICByZXR1cm4gbmV3IEVycm9yKGByZWZlcmVuY2UgXCIke3JlZn1cIiByZXNvbHZlcyB0byBtb3JlIHRoYW4gb25lIHNjaGVtYWApXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7XG4gIEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JDeHQsXG4gIEtleXdvcmRDeHRQYXJhbXMsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuLlwiXG5pbXBvcnQgdHlwZSB7SW5zdGFuY2VPcHRpb25zfSBmcm9tIFwiLi4vLi4vY29yZVwiXG5pbXBvcnQge2Jvb2xPckVtcHR5U2NoZW1hLCB0b3BCb29sT3JFbXB0eVNjaGVtYX0gZnJvbSBcIi4vYm9vbFNjaGVtYVwiXG5pbXBvcnQge2NvZXJjZUFuZENoZWNrRGF0YVR5cGUsIGdldFNjaGVtYVR5cGVzfSBmcm9tIFwiLi9kYXRhVHlwZVwiXG5pbXBvcnQge3Nob3VsZFVzZUdyb3VwLCBzaG91bGRVc2VSdWxlfSBmcm9tIFwiLi9hcHBsaWNhYmlsaXR5XCJcbmltcG9ydCB7Y2hlY2tEYXRhVHlwZSwgY2hlY2tEYXRhVHlwZXMsIHJlcG9ydFR5cGVFcnJvciwgRGF0YVR5cGV9IGZyb20gXCIuL2RhdGFUeXBlXCJcbmltcG9ydCB7YXNzaWduRGVmYXVsdHN9IGZyb20gXCIuL2RlZmF1bHRzXCJcbmltcG9ydCB7ZnVuY0tleXdvcmRDb2RlLCBtYWNyb0tleXdvcmRDb2RlLCB2YWxpZGF0ZUtleXdvcmRVc2FnZSwgdmFsaWRTY2hlbWFUeXBlfSBmcm9tIFwiLi9rZXl3b3JkXCJcbmltcG9ydCB7Z2V0U3Vic2NoZW1hLCBleHRlbmRTdWJzY2hlbWFEYXRhLCBTdWJzY2hlbWFBcmdzLCBleHRlbmRTdWJzY2hlbWFNb2RlfSBmcm9tIFwiLi9zdWJzY2hlbWFcIlxuaW1wb3J0IHtfLCBuaWwsIHN0ciwgb3IsIG5vdCwgZ2V0UHJvcGVydHksIEJsb2NrLCBDb2RlLCBOYW1lLCBDb2RlR2VufSBmcm9tIFwiLi4vY29kZWdlblwiXG5pbXBvcnQgTiBmcm9tIFwiLi4vbmFtZXNcIlxuaW1wb3J0IHtyZXNvbHZlVXJsfSBmcm9tIFwiLi4vcmVzb2x2ZVwiXG5pbXBvcnQge1xuICBzY2hlbWFSZWZPclZhbCxcbiAgc2NoZW1hSGFzUnVsZXNCdXRSZWYsXG4gIGNoZWNrVW5rbm93blJ1bGVzLFxuICBjaGVja1N0cmljdE1vZGUsXG4gIHVuZXNjYXBlSnNvblBvaW50ZXIsXG4gIG1lcmdlRXZhbHVhdGVkLFxufSBmcm9tIFwiLi4vdXRpbFwiXG5pbXBvcnQgdHlwZSB7SlNPTlR5cGUsIFJ1bGUsIFJ1bGVHcm91cH0gZnJvbSBcIi4uL3J1bGVzXCJcbmltcG9ydCB7XG4gIEVycm9yUGF0aHMsXG4gIHJlcG9ydEVycm9yLFxuICByZXBvcnRFeHRyYUVycm9yLFxuICByZXNldEVycm9yc0NvdW50LFxuICBrZXl3b3JkJERhdGFFcnJvcixcbn0gZnJvbSBcIi4uL2Vycm9yc1wiXG5cbi8vIHNjaGVtYSBjb21waWxhdGlvbiAtIGdlbmVyYXRlcyB2YWxpZGF0aW9uIGZ1bmN0aW9uLCBzdWJzY2hlbWFDb2RlIChiZWxvdykgaXMgdXNlZCBmb3Igc3Vic2NoZW1hc1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db2RlKGl0OiBTY2hlbWFDeHQpOiB2b2lkIHtcbiAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgIGNoZWNrS2V5d29yZHMoaXQpXG4gICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgdG9wU2NoZW1hT2JqQ29kZShpdClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuICB2YWxpZGF0ZUZ1bmN0aW9uKGl0LCAoKSA9PiB0b3BCb29sT3JFbXB0eVNjaGVtYShpdCkpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb24oXG4gIHtnZW4sIHZhbGlkYXRlTmFtZSwgc2NoZW1hLCBzY2hlbWFFbnYsIG9wdHN9OiBTY2hlbWFDeHQsXG4gIGJvZHk6IEJsb2NrXG4pOiB2b2lkIHtcbiAgaWYgKG9wdHMuY29kZS5lczUpIHtcbiAgICBnZW4uZnVuYyh2YWxpZGF0ZU5hbWUsIF9gJHtOLmRhdGF9LCAke04udmFsQ3h0fWAsIHNjaGVtYUVudi4kYXN5bmMsICgpID0+IHtcbiAgICAgIGdlbi5jb2RlKF9gXCJ1c2Ugc3RyaWN0XCI7ICR7ZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpfWApXG4gICAgICBkZXN0cnVjdHVyZVZhbEN4dEVTNShnZW4sIG9wdHMpXG4gICAgICBnZW4uY29kZShib2R5KVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZ2VuLmZ1bmModmFsaWRhdGVOYW1lLCBfYCR7Ti5kYXRhfSwgJHtkZXN0cnVjdHVyZVZhbEN4dChvcHRzKX1gLCBzY2hlbWFFbnYuJGFzeW5jLCAoKSA9PlxuICAgICAgZ2VuLmNvZGUoZnVuY1NvdXJjZVVybChzY2hlbWEsIG9wdHMpKS5jb2RlKGJvZHkpXG4gICAgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlc3RydWN0dXJlVmFsQ3h0KG9wdHM6IEluc3RhbmNlT3B0aW9ucyk6IENvZGUge1xuICByZXR1cm4gX2B7JHtOLmluc3RhbmNlUGF0aH09XCJcIiwgJHtOLnBhcmVudERhdGF9LCAke04ucGFyZW50RGF0YVByb3BlcnR5fSwgJHtOLnJvb3REYXRhfT0ke1xuICAgIE4uZGF0YVxuICB9JHtvcHRzLmR5bmFtaWNSZWYgPyBfYCwgJHtOLmR5bmFtaWNBbmNob3JzfT17fWAgOiBuaWx9fT17fWBcbn1cblxuZnVuY3Rpb24gZGVzdHJ1Y3R1cmVWYWxDeHRFUzUoZ2VuOiBDb2RlR2VuLCBvcHRzOiBJbnN0YW5jZU9wdGlvbnMpOiB2b2lkIHtcbiAgZ2VuLmlmKFxuICAgIE4udmFsQ3h0LFxuICAgICgpID0+IHtcbiAgICAgIGdlbi52YXIoTi5pbnN0YW5jZVBhdGgsIF9gJHtOLnZhbEN4dH0uJHtOLmluc3RhbmNlUGF0aH1gKVxuICAgICAgZ2VuLnZhcihOLnBhcmVudERhdGEsIF9gJHtOLnZhbEN4dH0uJHtOLnBhcmVudERhdGF9YClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhUHJvcGVydHksIF9gJHtOLnZhbEN4dH0uJHtOLnBhcmVudERhdGFQcm9wZXJ0eX1gKVxuICAgICAgZ2VuLnZhcihOLnJvb3REYXRhLCBfYCR7Ti52YWxDeHR9LiR7Ti5yb290RGF0YX1gKVxuICAgICAgaWYgKG9wdHMuZHluYW1pY1JlZikgZ2VuLnZhcihOLmR5bmFtaWNBbmNob3JzLCBfYCR7Ti52YWxDeHR9LiR7Ti5keW5hbWljQW5jaG9yc31gKVxuICAgIH0sXG4gICAgKCkgPT4ge1xuICAgICAgZ2VuLnZhcihOLmluc3RhbmNlUGF0aCwgX2BcIlwiYClcbiAgICAgIGdlbi52YXIoTi5wYXJlbnREYXRhLCBfYHVuZGVmaW5lZGApXG4gICAgICBnZW4udmFyKE4ucGFyZW50RGF0YVByb3BlcnR5LCBfYHVuZGVmaW5lZGApXG4gICAgICBnZW4udmFyKE4ucm9vdERhdGEsIE4uZGF0YSlcbiAgICAgIGlmIChvcHRzLmR5bmFtaWNSZWYpIGdlbi52YXIoTi5keW5hbWljQW5jaG9ycywgX2B7fWApXG4gICAgfVxuICApXG59XG5cbmZ1bmN0aW9uIHRvcFNjaGVtYU9iakNvZGUoaXQ6IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCB7c2NoZW1hLCBvcHRzLCBnZW59ID0gaXRcbiAgdmFsaWRhdGVGdW5jdGlvbihpdCwgKCkgPT4ge1xuICAgIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudCkgY29tbWVudEtleXdvcmQoaXQpXG4gICAgY2hlY2tOb0RlZmF1bHQoaXQpXG4gICAgZ2VuLmxldChOLnZFcnJvcnMsIG51bGwpXG4gICAgZ2VuLmxldChOLmVycm9ycywgMClcbiAgICBpZiAob3B0cy51bmV2YWx1YXRlZCkgcmVzZXRFdmFsdWF0ZWQoaXQpXG4gICAgdHlwZUFuZEtleXdvcmRzKGl0KVxuICAgIHJldHVyblJlc3VsdHMoaXQpXG4gIH0pXG4gIHJldHVyblxufVxuXG5mdW5jdGlvbiByZXNldEV2YWx1YXRlZChpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIC8vIFRPRE8gbWF5YmUgc29tZSBob29rIHRvIGV4ZWN1dGUgaXQgaW4gdGhlIGVuZCB0byBjaGVjayB3aGV0aGVyIHByb3BzL2l0ZW1zIGFyZSBOYW1lLCBhcyBpbiBhc3NpZ25FdmFsdWF0ZWRcbiAgY29uc3Qge2dlbiwgdmFsaWRhdGVOYW1lfSA9IGl0XG4gIGl0LmV2YWx1YXRlZCA9IGdlbi5jb25zdChcImV2YWx1YXRlZFwiLCBfYCR7dmFsaWRhdGVOYW1lfS5ldmFsdWF0ZWRgKVxuICBnZW4uaWYoX2Ake2l0LmV2YWx1YXRlZH0uZHluYW1pY1Byb3BzYCwgKCkgPT4gZ2VuLmFzc2lnbihfYCR7aXQuZXZhbHVhdGVkfS5wcm9wc2AsIF9gdW5kZWZpbmVkYCkpXG4gIGdlbi5pZihfYCR7aXQuZXZhbHVhdGVkfS5keW5hbWljSXRlbXNgLCAoKSA9PiBnZW4uYXNzaWduKF9gJHtpdC5ldmFsdWF0ZWR9Lml0ZW1zYCwgX2B1bmRlZmluZWRgKSlcbn1cblxuZnVuY3Rpb24gZnVuY1NvdXJjZVVybChzY2hlbWE6IEFueVNjaGVtYSwgb3B0czogSW5zdGFuY2VPcHRpb25zKTogQ29kZSB7XG4gIGNvbnN0IHNjaElkID0gdHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmIHNjaGVtYVtvcHRzLnNjaGVtYUlkXVxuICByZXR1cm4gc2NoSWQgJiYgKG9wdHMuY29kZS5zb3VyY2UgfHwgb3B0cy5jb2RlLnByb2Nlc3MpID8gX2AvKiMgc291cmNlVVJMPSR7c2NoSWR9ICovYCA6IG5pbFxufVxuXG4vLyBzY2hlbWEgY29tcGlsYXRpb24gLSB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgcmVjdXJzaXZlbHkgdG8gZ2VuZXJhdGUgY29kZSBmb3Igc3ViLXNjaGVtYXNcbmZ1bmN0aW9uIHN1YnNjaGVtYUNvZGUoaXQ6IFNjaGVtYUN4dCwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgaWYgKGlzU2NoZW1hT2JqKGl0KSkge1xuICAgIGNoZWNrS2V5d29yZHMoaXQpXG4gICAgaWYgKHNjaGVtYUN4dEhhc1J1bGVzKGl0KSkge1xuICAgICAgc3ViU2NoZW1hT2JqQ29kZShpdCwgdmFsaWQpXG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgYm9vbE9yRW1wdHlTY2hlbWEoaXQsIHZhbGlkKVxufVxuXG5mdW5jdGlvbiBzY2hlbWFDeHRIYXNSdWxlcyh7c2NoZW1hLCBzZWxmfTogU2NoZW1hQ3h0KTogYm9vbGVhbiB7XG4gIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gIXNjaGVtYVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIGlmIChzZWxmLlJVTEVTLmFsbFtrZXldKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gaXNTY2hlbWFPYmooaXQ6IFNjaGVtYUN4dCk6IGl0IGlzIFNjaGVtYU9iakN4dCB7XG4gIHJldHVybiB0eXBlb2YgaXQuc2NoZW1hICE9IFwiYm9vbGVhblwiXG59XG5cbmZ1bmN0aW9uIHN1YlNjaGVtYU9iakNvZGUoaXQ6IFNjaGVtYU9iakN4dCwgdmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgY29uc3Qge3NjaGVtYSwgZ2VuLCBvcHRzfSA9IGl0XG4gIGlmIChvcHRzLiRjb21tZW50ICYmIHNjaGVtYS4kY29tbWVudCkgY29tbWVudEtleXdvcmQoaXQpXG4gIHVwZGF0ZUNvbnRleHQoaXQpXG4gIGNoZWNrQXN5bmNTY2hlbWEoaXQpXG4gIGNvbnN0IGVycnNDb3VudCA9IGdlbi5jb25zdChcIl9lcnJzXCIsIE4uZXJyb3JzKVxuICB0eXBlQW5kS2V5d29yZHMoaXQsIGVycnNDb3VudClcbiAgLy8gVE9ETyB2YXJcbiAgZ2VuLnZhcih2YWxpZCwgX2Ake2VycnNDb3VudH0gPT09ICR7Ti5lcnJvcnN9YClcbn1cblxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkcyhpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNoZWNrVW5rbm93blJ1bGVzKGl0KVxuICBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdClcbn1cblxuZnVuY3Rpb24gdHlwZUFuZEtleXdvcmRzKGl0OiBTY2hlbWFPYmpDeHQsIGVycnNDb3VudD86IE5hbWUpOiB2b2lkIHtcbiAgaWYgKGl0Lm9wdHMuanRkKSByZXR1cm4gc2NoZW1hS2V5d29yZHMoaXQsIFtdLCBmYWxzZSwgZXJyc0NvdW50KVxuICBjb25zdCB0eXBlcyA9IGdldFNjaGVtYVR5cGVzKGl0LnNjaGVtYSlcbiAgY29uc3QgY2hlY2tlZFR5cGVzID0gY29lcmNlQW5kQ2hlY2tEYXRhVHlwZShpdCwgdHlwZXMpXG4gIHNjaGVtYUtleXdvcmRzKGl0LCB0eXBlcywgIWNoZWNrZWRUeXBlcywgZXJyc0NvdW50KVxufVxuXG5mdW5jdGlvbiBjaGVja1JlZnNBbmRLZXl3b3JkcyhpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIGVyclNjaGVtYVBhdGgsIG9wdHMsIHNlbGZ9ID0gaXRcbiAgaWYgKHNjaGVtYS4kcmVmICYmIG9wdHMuaWdub3JlS2V5d29yZHNXaXRoUmVmICYmIHNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgc2VsZi5SVUxFUykpIHtcbiAgICBzZWxmLmxvZ2dlci53YXJuKGAkcmVmOiBrZXl3b3JkcyBpZ25vcmVkIGluIHNjaGVtYSBhdCBwYXRoIFwiJHtlcnJTY2hlbWFQYXRofVwiYClcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja05vRGVmYXVsdChpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHtzY2hlbWEsIG9wdHN9ID0gaXRcbiAgaWYgKHNjaGVtYS5kZWZhdWx0ICE9PSB1bmRlZmluZWQgJiYgb3B0cy51c2VEZWZhdWx0cyAmJiBvcHRzLnN0cmljdFNjaGVtYSkge1xuICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgXCJkZWZhdWx0IGlzIGlnbm9yZWQgaW4gdGhlIHNjaGVtYSByb290XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dChpdDogU2NoZW1hT2JqQ3h0KTogdm9pZCB7XG4gIGNvbnN0IHNjaElkID0gaXQuc2NoZW1hW2l0Lm9wdHMuc2NoZW1hSWRdXG4gIGlmIChzY2hJZCkgaXQuYmFzZUlkID0gcmVzb2x2ZVVybChpdC5vcHRzLnVyaVJlc29sdmVyLCBpdC5iYXNlSWQsIHNjaElkKVxufVxuXG5mdW5jdGlvbiBjaGVja0FzeW5jU2NoZW1hKGl0OiBTY2hlbWFPYmpDeHQpOiB2b2lkIHtcbiAgaWYgKGl0LnNjaGVtYS4kYXN5bmMgJiYgIWl0LnNjaGVtYUVudi4kYXN5bmMpIHRocm93IG5ldyBFcnJvcihcImFzeW5jIHNjaGVtYSBpbiBzeW5jIHNjaGVtYVwiKVxufVxuXG5mdW5jdGlvbiBjb21tZW50S2V5d29yZCh7Z2VuLCBzY2hlbWFFbnYsIHNjaGVtYSwgZXJyU2NoZW1hUGF0aCwgb3B0c306IFNjaGVtYU9iakN4dCk6IHZvaWQge1xuICBjb25zdCBtc2cgPSBzY2hlbWEuJGNvbW1lbnRcbiAgaWYgKG9wdHMuJGNvbW1lbnQgPT09IHRydWUpIHtcbiAgICBnZW4uY29kZShfYCR7Ti5zZWxmfS5sb2dnZXIubG9nKCR7bXNnfSlgKVxuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLiRjb21tZW50ID09IFwiZnVuY3Rpb25cIikge1xuICAgIGNvbnN0IHNjaGVtYVBhdGggPSBzdHJgJHtlcnJTY2hlbWFQYXRofS8kY29tbWVudGBcbiAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7cmVmOiBzY2hlbWFFbnYucm9vdH0pXG4gICAgZ2VuLmNvZGUoX2Ake04uc2VsZn0ub3B0cy4kY29tbWVudCgke21zZ30sICR7c2NoZW1hUGF0aH0sICR7cm9vdE5hbWV9LnNjaGVtYSlgKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJldHVyblJlc3VsdHMoaXQ6IFNjaGVtYUN4dCk6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBzY2hlbWFFbnYsIHZhbGlkYXRlTmFtZSwgVmFsaWRhdGlvbkVycm9yLCBvcHRzfSA9IGl0XG4gIGlmIChzY2hlbWFFbnYuJGFzeW5jKSB7XG4gICAgLy8gVE9ETyBhc3NpZ24gdW5ldmFsdWF0ZWRcbiAgICBnZW4uaWYoXG4gICAgICBfYCR7Ti5lcnJvcnN9ID09PSAwYCxcbiAgICAgICgpID0+IGdlbi5yZXR1cm4oTi5kYXRhKSxcbiAgICAgICgpID0+IGdlbi50aHJvdyhfYG5ldyAke1ZhbGlkYXRpb25FcnJvciBhcyBOYW1lfSgke04udkVycm9yc30pYClcbiAgICApXG4gIH0gZWxzZSB7XG4gICAgZ2VuLmFzc2lnbihfYCR7dmFsaWRhdGVOYW1lfS5lcnJvcnNgLCBOLnZFcnJvcnMpXG4gICAgaWYgKG9wdHMudW5ldmFsdWF0ZWQpIGFzc2lnbkV2YWx1YXRlZChpdClcbiAgICBnZW4ucmV0dXJuKF9gJHtOLmVycm9yc30gPT09IDBgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbkV2YWx1YXRlZCh7Z2VuLCBldmFsdWF0ZWQsIHByb3BzLCBpdGVtc306IFNjaGVtYUN4dCk6IHZvaWQge1xuICBpZiAocHJvcHMgaW5zdGFuY2VvZiBOYW1lKSBnZW4uYXNzaWduKF9gJHtldmFsdWF0ZWR9LnByb3BzYCwgcHJvcHMpXG4gIGlmIChpdGVtcyBpbnN0YW5jZW9mIE5hbWUpIGdlbi5hc3NpZ24oX2Ake2V2YWx1YXRlZH0uaXRlbXNgLCBpdGVtcylcbn1cblxuZnVuY3Rpb24gc2NoZW1hS2V5d29yZHMoXG4gIGl0OiBTY2hlbWFPYmpDeHQsXG4gIHR5cGVzOiBKU09OVHlwZVtdLFxuICB0eXBlRXJyb3JzOiBib29sZWFuLFxuICBlcnJzQ291bnQ/OiBOYW1lXG4pOiB2b2lkIHtcbiAgY29uc3Qge2dlbiwgc2NoZW1hLCBkYXRhLCBhbGxFcnJvcnMsIG9wdHMsIHNlbGZ9ID0gaXRcbiAgY29uc3Qge1JVTEVTfSA9IHNlbGZcbiAgaWYgKHNjaGVtYS4kcmVmICYmIChvcHRzLmlnbm9yZUtleXdvcmRzV2l0aFJlZiB8fCAhc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoZW1hLCBSVUxFUykpKSB7XG4gICAgZ2VuLmJsb2NrKCgpID0+IGtleXdvcmRDb2RlKGl0LCBcIiRyZWZcIiwgKFJVTEVTLmFsbC4kcmVmIGFzIFJ1bGUpLmRlZmluaXRpb24pKSAvLyBUT0RPIHR5cGVjYXN0XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKCFvcHRzLmp0ZCkgY2hlY2tTdHJpY3RUeXBlcyhpdCwgdHlwZXMpXG4gIGdlbi5ibG9jaygoKSA9PiB7XG4gICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykgZ3JvdXBLZXl3b3Jkcyhncm91cClcbiAgICBncm91cEtleXdvcmRzKFJVTEVTLnBvc3QpXG4gIH0pXG5cbiAgZnVuY3Rpb24gZ3JvdXBLZXl3b3Jkcyhncm91cDogUnVsZUdyb3VwKTogdm9pZCB7XG4gICAgaWYgKCFzaG91bGRVc2VHcm91cChzY2hlbWEsIGdyb3VwKSkgcmV0dXJuXG4gICAgaWYgKGdyb3VwLnR5cGUpIHtcbiAgICAgIGdlbi5pZihjaGVja0RhdGFUeXBlKGdyb3VwLnR5cGUsIGRhdGEsIG9wdHMuc3RyaWN0TnVtYmVycykpXG4gICAgICBpdGVyYXRlS2V5d29yZHMoaXQsIGdyb3VwKVxuICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSAmJiB0eXBlc1swXSA9PT0gZ3JvdXAudHlwZSAmJiB0eXBlRXJyb3JzKSB7XG4gICAgICAgIGdlbi5lbHNlKClcbiAgICAgICAgcmVwb3J0VHlwZUVycm9yKGl0KVxuICAgICAgfVxuICAgICAgZ2VuLmVuZElmKClcbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZUtleXdvcmRzKGl0LCBncm91cClcbiAgICB9XG4gICAgLy8gVE9ETyBtYWtlIGl0IFwib2tcIiBjYWxsP1xuICAgIGlmICghYWxsRXJyb3JzKSBnZW4uaWYoX2Ake04uZXJyb3JzfSA9PT0gJHtlcnJzQ291bnQgfHwgMH1gKVxuICB9XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVLZXl3b3JkcyhpdDogU2NoZW1hT2JqQ3h0LCBncm91cDogUnVsZUdyb3VwKTogdm9pZCB7XG4gIGNvbnN0IHtcbiAgICBnZW4sXG4gICAgc2NoZW1hLFxuICAgIG9wdHM6IHt1c2VEZWZhdWx0c30sXG4gIH0gPSBpdFxuICBpZiAodXNlRGVmYXVsdHMpIGFzc2lnbkRlZmF1bHRzKGl0LCBncm91cC50eXBlKVxuICBnZW4uYmxvY2soKCkgPT4ge1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiBncm91cC5ydWxlcykge1xuICAgICAgaWYgKHNob3VsZFVzZVJ1bGUoc2NoZW1hLCBydWxlKSkge1xuICAgICAgICBrZXl3b3JkQ29kZShpdCwgcnVsZS5rZXl3b3JkLCBydWxlLmRlZmluaXRpb24sIGdyb3VwLnR5cGUpXG4gICAgICB9XG4gICAgfVxuICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja1N0cmljdFR5cGVzKGl0OiBTY2hlbWFPYmpDeHQsIHR5cGVzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGlmIChpdC5zY2hlbWFFbnYubWV0YSB8fCAhaXQub3B0cy5zdHJpY3RUeXBlcykgcmV0dXJuXG4gIGNoZWNrQ29udGV4dFR5cGVzKGl0LCB0eXBlcylcbiAgaWYgKCFpdC5vcHRzLmFsbG93VW5pb25UeXBlcykgY2hlY2tNdWx0aXBsZVR5cGVzKGl0LCB0eXBlcylcbiAgY2hlY2tLZXl3b3JkVHlwZXMoaXQsIGl0LmRhdGFUeXBlcylcbn1cblxuZnVuY3Rpb24gY2hlY2tDb250ZXh0VHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHlwZXM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgaWYgKCF0eXBlcy5sZW5ndGgpIHJldHVyblxuICBpZiAoIWl0LmRhdGFUeXBlcy5sZW5ndGgpIHtcbiAgICBpdC5kYXRhVHlwZXMgPSB0eXBlc1xuICAgIHJldHVyblxuICB9XG4gIHR5cGVzLmZvckVhY2goKHQpID0+IHtcbiAgICBpZiAoIWluY2x1ZGVzVHlwZShpdC5kYXRhVHlwZXMsIHQpKSB7XG4gICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgdHlwZSBcIiR7dH1cIiBub3QgYWxsb3dlZCBieSBjb250ZXh0IFwiJHtpdC5kYXRhVHlwZXMuam9pbihcIixcIil9XCJgKVxuICAgIH1cbiAgfSlcbiAgbmFycm93U2NoZW1hVHlwZXMoaXQsIHR5cGVzKVxufVxuXG5mdW5jdGlvbiBjaGVja011bHRpcGxlVHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgdHM6IEpTT05UeXBlW10pOiB2b2lkIHtcbiAgaWYgKHRzLmxlbmd0aCA+IDEgJiYgISh0cy5sZW5ndGggPT09IDIgJiYgdHMuaW5jbHVkZXMoXCJudWxsXCIpKSkge1xuICAgIHN0cmljdFR5cGVzRXJyb3IoaXQsIFwidXNlIGFsbG93VW5pb25UeXBlcyB0byBhbGxvdyB1bmlvbiB0eXBlIGtleXdvcmRcIilcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0tleXdvcmRUeXBlcyhpdDogU2NoZW1hT2JqQ3h0LCB0czogSlNPTlR5cGVbXSk6IHZvaWQge1xuICBjb25zdCBydWxlcyA9IGl0LnNlbGYuUlVMRVMuYWxsXG4gIGZvciAoY29uc3Qga2V5d29yZCBpbiBydWxlcykge1xuICAgIGNvbnN0IHJ1bGUgPSBydWxlc1trZXl3b3JkXVxuICAgIGlmICh0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiICYmIHNob3VsZFVzZVJ1bGUoaXQuc2NoZW1hLCBydWxlKSkge1xuICAgICAgY29uc3Qge3R5cGV9ID0gcnVsZS5kZWZpbml0aW9uXG4gICAgICBpZiAodHlwZS5sZW5ndGggJiYgIXR5cGUuc29tZSgodCkgPT4gaGFzQXBwbGljYWJsZVR5cGUodHMsIHQpKSkge1xuICAgICAgICBzdHJpY3RUeXBlc0Vycm9yKGl0LCBgbWlzc2luZyB0eXBlIFwiJHt0eXBlLmpvaW4oXCIsXCIpfVwiIGZvciBrZXl3b3JkIFwiJHtrZXl3b3JkfVwiYClcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFzQXBwbGljYWJsZVR5cGUoc2NoVHM6IEpTT05UeXBlW10sIGt3ZFQ6IEpTT05UeXBlKTogYm9vbGVhbiB7XG4gIHJldHVybiBzY2hUcy5pbmNsdWRlcyhrd2RUKSB8fCAoa3dkVCA9PT0gXCJudW1iZXJcIiAmJiBzY2hUcy5pbmNsdWRlcyhcImludGVnZXJcIikpXG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzVHlwZSh0czogSlNPTlR5cGVbXSwgdDogSlNPTlR5cGUpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRzLmluY2x1ZGVzKHQpIHx8ICh0ID09PSBcImludGVnZXJcIiAmJiB0cy5pbmNsdWRlcyhcIm51bWJlclwiKSlcbn1cblxuZnVuY3Rpb24gbmFycm93U2NoZW1hVHlwZXMoaXQ6IFNjaGVtYU9iakN4dCwgd2l0aFR5cGVzOiBKU09OVHlwZVtdKTogdm9pZCB7XG4gIGNvbnN0IHRzOiBKU09OVHlwZVtdID0gW11cbiAgZm9yIChjb25zdCB0IG9mIGl0LmRhdGFUeXBlcykge1xuICAgIGlmIChpbmNsdWRlc1R5cGUod2l0aFR5cGVzLCB0KSkgdHMucHVzaCh0KVxuICAgIGVsc2UgaWYgKHdpdGhUeXBlcy5pbmNsdWRlcyhcImludGVnZXJcIikgJiYgdCA9PT0gXCJudW1iZXJcIikgdHMucHVzaChcImludGVnZXJcIilcbiAgfVxuICBpdC5kYXRhVHlwZXMgPSB0c1xufVxuXG5mdW5jdGlvbiBzdHJpY3RUeXBlc0Vycm9yKGl0OiBTY2hlbWFPYmpDeHQsIG1zZzogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aFxuICBtc2cgKz0gYCBhdCBcIiR7c2NoZW1hUGF0aH1cIiAoc3RyaWN0VHlwZXMpYFxuICBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RUeXBlcylcbn1cblxuZXhwb3J0IGNsYXNzIEtleXdvcmRDeHQgaW1wbGVtZW50cyBLZXl3b3JkRXJyb3JDeHQge1xuICByZWFkb25seSBnZW46IENvZGVHZW5cbiAgcmVhZG9ubHkgYWxsRXJyb3JzPzogYm9vbGVhblxuICByZWFkb25seSBrZXl3b3JkOiBzdHJpbmdcbiAgcmVhZG9ubHkgZGF0YTogTmFtZSAvLyBOYW1lIHJlZmVyZW5jaW5nIHRoZSBjdXJyZW50IGxldmVsIG9mIHRoZSBkYXRhIGluc3RhbmNlXG4gIHJlYWRvbmx5ICRkYXRhPzogc3RyaW5nIHwgZmFsc2VcbiAgc2NoZW1hOiBhbnkgLy8ga2V5d29yZCB2YWx1ZSBpbiB0aGUgc2NoZW1hXG4gIHJlYWRvbmx5IHNjaGVtYVZhbHVlOiBDb2RlIHwgbnVtYmVyIHwgYm9vbGVhbiAvLyBDb2RlIHJlZmVyZW5jZSB0byBrZXl3b3JkIHNjaGVtYSB2YWx1ZSBvciBwcmltaXRpdmUgdmFsdWVcbiAgcmVhZG9ubHkgc2NoZW1hQ29kZTogQ29kZSB8IG51bWJlciB8IGJvb2xlYW4gLy8gQ29kZSByZWZlcmVuY2UgdG8gcmVzb2x2ZWQgc2NoZW1hIHZhbHVlIChkaWZmZXJlbnQgaWYgc2NoZW1hIGlzICRkYXRhKVxuICByZWFkb25seSBzY2hlbWFUeXBlOiBKU09OVHlwZVtdIC8vIGFsbG93ZWQgdHlwZShzKSBvZiBrZXl3b3JkIHZhbHVlIGluIHRoZSBzY2hlbWFcbiAgcmVhZG9ubHkgcGFyZW50U2NoZW1hOiBBbnlTY2hlbWFPYmplY3RcbiAgcmVhZG9ubHkgZXJyc0NvdW50PzogTmFtZSAvLyBOYW1lIHJlZmVyZW5jZSB0byB0aGUgbnVtYmVyIG9mIHZhbGlkYXRpb24gZXJyb3JzIGNvbGxlY3RlZCBiZWZvcmUgdGhpcyBrZXl3b3JkLFxuICAvLyByZXF1aXJlcyBvcHRpb24gdHJhY2tFcnJvcnMgaW4ga2V5d29yZCBkZWZpbml0aW9uXG4gIHBhcmFtczogS2V5d29yZEN4dFBhcmFtcyAvLyBvYmplY3QgdG8gcGFzcyBwYXJhbWV0ZXJzIHRvIGVycm9yIG1lc3NhZ2VzIGZyb20ga2V5d29yZCBjb2RlXG4gIHJlYWRvbmx5IGl0OiBTY2hlbWFPYmpDeHQgLy8gc2NoZW1hIGNvbXBpbGF0aW9uIGNvbnRleHQgKHNjaGVtYSBpcyBndWFyYW50ZWVkIHRvIGJlIGFuIG9iamVjdCwgbm90IGJvb2xlYW4pXG4gIHJlYWRvbmx5IGRlZjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvblxuXG4gIGNvbnN0cnVjdG9yKGl0OiBTY2hlbWFPYmpDeHQsIGRlZjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiwga2V5d29yZDogc3RyaW5nKSB7XG4gICAgdmFsaWRhdGVLZXl3b3JkVXNhZ2UoaXQsIGRlZiwga2V5d29yZClcbiAgICB0aGlzLmdlbiA9IGl0LmdlblxuICAgIHRoaXMuYWxsRXJyb3JzID0gaXQuYWxsRXJyb3JzXG4gICAgdGhpcy5rZXl3b3JkID0ga2V5d29yZFxuICAgIHRoaXMuZGF0YSA9IGl0LmRhdGFcbiAgICB0aGlzLnNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXVxuICAgIHRoaXMuJGRhdGEgPSBkZWYuJGRhdGEgJiYgaXQub3B0cy4kZGF0YSAmJiB0aGlzLnNjaGVtYSAmJiB0aGlzLnNjaGVtYS4kZGF0YVxuICAgIHRoaXMuc2NoZW1hVmFsdWUgPSBzY2hlbWFSZWZPclZhbChpdCwgdGhpcy5zY2hlbWEsIGtleXdvcmQsIHRoaXMuJGRhdGEpXG4gICAgdGhpcy5zY2hlbWFUeXBlID0gZGVmLnNjaGVtYVR5cGVcbiAgICB0aGlzLnBhcmVudFNjaGVtYSA9IGl0LnNjaGVtYVxuICAgIHRoaXMucGFyYW1zID0ge31cbiAgICB0aGlzLml0ID0gaXRcbiAgICB0aGlzLmRlZiA9IGRlZlxuXG4gICAgaWYgKHRoaXMuJGRhdGEpIHtcbiAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IGl0Lmdlbi5jb25zdChcInZTY2hlbWFcIiwgZ2V0RGF0YSh0aGlzLiRkYXRhLCBpdCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2NoZW1hQ29kZSA9IHRoaXMuc2NoZW1hVmFsdWVcbiAgICAgIGlmICghdmFsaWRTY2hlbWFUeXBlKHRoaXMuc2NoZW1hLCBkZWYuc2NoZW1hVHlwZSwgZGVmLmFsbG93VW5kZWZpbmVkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7a2V5d29yZH0gdmFsdWUgbXVzdCBiZSAke0pTT04uc3RyaW5naWZ5KGRlZi5zY2hlbWFUeXBlKX1gKVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChcImNvZGVcIiBpbiBkZWYgPyBkZWYudHJhY2tFcnJvcnMgOiBkZWYuZXJyb3JzICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5lcnJzQ291bnQgPSBpdC5nZW4uY29uc3QoXCJfZXJyc1wiLCBOLmVycm9ycylcbiAgICB9XG4gIH1cblxuICByZXN1bHQoY29uZGl0aW9uOiBDb2RlLCBzdWNjZXNzQWN0aW9uPzogKCkgPT4gdm9pZCwgZmFpbEFjdGlvbj86ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmZhaWxSZXN1bHQobm90KGNvbmRpdGlvbiksIHN1Y2Nlc3NBY3Rpb24sIGZhaWxBY3Rpb24pXG4gIH1cblxuICBmYWlsUmVzdWx0KGNvbmRpdGlvbjogQ29kZSwgc3VjY2Vzc0FjdGlvbj86ICgpID0+IHZvaWQsIGZhaWxBY3Rpb24/OiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5nZW4uaWYoY29uZGl0aW9uKVxuICAgIGlmIChmYWlsQWN0aW9uKSBmYWlsQWN0aW9uKClcbiAgICBlbHNlIHRoaXMuZXJyb3IoKVxuICAgIGlmIChzdWNjZXNzQWN0aW9uKSB7XG4gICAgICB0aGlzLmdlbi5lbHNlKClcbiAgICAgIHN1Y2Nlc3NBY3Rpb24oKVxuICAgICAgaWYgKHRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5lbmRJZigpXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uZW5kSWYoKVxuICAgICAgZWxzZSB0aGlzLmdlbi5lbHNlKClcbiAgICB9XG4gIH1cblxuICBwYXNzKGNvbmRpdGlvbjogQ29kZSwgZmFpbEFjdGlvbj86ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLmZhaWxSZXN1bHQobm90KGNvbmRpdGlvbiksIHVuZGVmaW5lZCwgZmFpbEFjdGlvbilcbiAgfVxuXG4gIGZhaWwoY29uZGl0aW9uPzogQ29kZSk6IHZvaWQge1xuICAgIGlmIChjb25kaXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5lcnJvcigpXG4gICAgICBpZiAoIXRoaXMuYWxsRXJyb3JzKSB0aGlzLmdlbi5pZihmYWxzZSkgLy8gdGhpcyBicmFuY2ggd2lsbCBiZSByZW1vdmVkIGJ5IGdlbi5vcHRpbWl6ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHRoaXMuZ2VuLmlmKGNvbmRpdGlvbilcbiAgICB0aGlzLmVycm9yKClcbiAgICBpZiAodGhpcy5hbGxFcnJvcnMpIHRoaXMuZ2VuLmVuZElmKClcbiAgICBlbHNlIHRoaXMuZ2VuLmVsc2UoKVxuICB9XG5cbiAgZmFpbCRkYXRhKGNvbmRpdGlvbjogQ29kZSk6IHZvaWQge1xuICAgIGlmICghdGhpcy4kZGF0YSkgcmV0dXJuIHRoaXMuZmFpbChjb25kaXRpb24pXG4gICAgY29uc3Qge3NjaGVtYUNvZGV9ID0gdGhpc1xuICAgIHRoaXMuZmFpbChfYCR7c2NoZW1hQ29kZX0gIT09IHVuZGVmaW5lZCAmJiAoJHtvcih0aGlzLmludmFsaWQkZGF0YSgpLCBjb25kaXRpb24pfSlgKVxuICB9XG5cbiAgZXJyb3IoYXBwZW5kPzogYm9vbGVhbiwgZXJyb3JQYXJhbXM/OiBLZXl3b3JkQ3h0UGFyYW1zLCBlcnJvclBhdGhzPzogRXJyb3JQYXRocyk6IHZvaWQge1xuICAgIGlmIChlcnJvclBhcmFtcykge1xuICAgICAgdGhpcy5zZXRQYXJhbXMoZXJyb3JQYXJhbXMpXG4gICAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpXG4gICAgICB0aGlzLnNldFBhcmFtcyh7fSlcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLl9lcnJvcihhcHBlbmQsIGVycm9yUGF0aHMpXG4gIH1cblxuICBwcml2YXRlIF9lcnJvcihhcHBlbmQ/OiBib29sZWFuLCBlcnJvclBhdGhzPzogRXJyb3JQYXRocyk6IHZvaWQge1xuICAgIDsoYXBwZW5kID8gcmVwb3J0RXh0cmFFcnJvciA6IHJlcG9ydEVycm9yKSh0aGlzLCB0aGlzLmRlZi5lcnJvciwgZXJyb3JQYXRocylcbiAgfVxuXG4gICRkYXRhRXJyb3IoKTogdm9pZCB7XG4gICAgcmVwb3J0RXJyb3IodGhpcywgdGhpcy5kZWYuJGRhdGFFcnJvciB8fCBrZXl3b3JkJERhdGFFcnJvcilcbiAgfVxuXG4gIHJlc2V0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmVycnNDb3VudCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoJ2FkZCBcInRyYWNrRXJyb3JzXCIgdG8ga2V5d29yZCBkZWZpbml0aW9uJylcbiAgICByZXNldEVycm9yc0NvdW50KHRoaXMuZ2VuLCB0aGlzLmVycnNDb3VudClcbiAgfVxuXG4gIG9rKGNvbmQ6IENvZGUgfCBib29sZWFuKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLmFsbEVycm9ycykgdGhpcy5nZW4uaWYoY29uZClcbiAgfVxuXG4gIHNldFBhcmFtcyhvYmo6IEtleXdvcmRDeHRQYXJhbXMsIGFzc2lnbj86IHRydWUpOiB2b2lkIHtcbiAgICBpZiAoYXNzaWduKSBPYmplY3QuYXNzaWduKHRoaXMucGFyYW1zLCBvYmopXG4gICAgZWxzZSB0aGlzLnBhcmFtcyA9IG9ialxuICB9XG5cbiAgYmxvY2skZGF0YSh2YWxpZDogTmFtZSwgY29kZUJsb2NrOiAoKSA9PiB2b2lkLCAkZGF0YVZhbGlkOiBDb2RlID0gbmlsKTogdm9pZCB7XG4gICAgdGhpcy5nZW4uYmxvY2soKCkgPT4ge1xuICAgICAgdGhpcy5jaGVjayRkYXRhKHZhbGlkLCAkZGF0YVZhbGlkKVxuICAgICAgY29kZUJsb2NrKClcbiAgICB9KVxuICB9XG5cbiAgY2hlY2skZGF0YSh2YWxpZDogTmFtZSA9IG5pbCwgJGRhdGFWYWxpZDogQ29kZSA9IG5pbCk6IHZvaWQge1xuICAgIGlmICghdGhpcy4kZGF0YSkgcmV0dXJuXG4gICAgY29uc3Qge2dlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmfSA9IHRoaXNcbiAgICBnZW4uaWYob3IoX2Ake3NjaGVtYUNvZGV9ID09PSB1bmRlZmluZWRgLCAkZGF0YVZhbGlkKSlcbiAgICBpZiAodmFsaWQgIT09IG5pbCkgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGggfHwgZGVmLnZhbGlkYXRlU2NoZW1hKSB7XG4gICAgICBnZW4uZWxzZUlmKHRoaXMuaW52YWxpZCRkYXRhKCkpXG4gICAgICB0aGlzLiRkYXRhRXJyb3IoKVxuICAgICAgaWYgKHZhbGlkICE9PSBuaWwpIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgIH1cbiAgICBnZW4uZWxzZSgpXG4gIH1cblxuICBpbnZhbGlkJGRhdGEoKTogQ29kZSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hQ29kZSwgc2NoZW1hVHlwZSwgZGVmLCBpdH0gPSB0aGlzXG4gICAgcmV0dXJuIG9yKHdyb25nJERhdGFUeXBlKCksIGludmFsaWQkRGF0YVNjaGVtYSgpKVxuXG4gICAgZnVuY3Rpb24gd3JvbmckRGF0YVR5cGUoKTogQ29kZSB7XG4gICAgICBpZiAoc2NoZW1hVHlwZS5sZW5ndGgpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmICghKHNjaGVtYUNvZGUgaW5zdGFuY2VvZiBOYW1lKSkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgICAgIGNvbnN0IHN0ID0gQXJyYXkuaXNBcnJheShzY2hlbWFUeXBlKSA/IHNjaGVtYVR5cGUgOiBbc2NoZW1hVHlwZV1cbiAgICAgICAgcmV0dXJuIF9gJHtjaGVja0RhdGFUeXBlcyhzdCwgc2NoZW1hQ29kZSwgaXQub3B0cy5zdHJpY3ROdW1iZXJzLCBEYXRhVHlwZS5Xcm9uZyl9YFxuICAgICAgfVxuICAgICAgcmV0dXJuIG5pbFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGludmFsaWQkRGF0YVNjaGVtYSgpOiBDb2RlIHtcbiAgICAgIGlmIChkZWYudmFsaWRhdGVTY2hlbWEpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVTY2hlbWFSZWYgPSBnZW4uc2NvcGVWYWx1ZShcInZhbGlkYXRlJGRhdGFcIiwge3JlZjogZGVmLnZhbGlkYXRlU2NoZW1hfSkgLy8gVE9ETyB2YWx1ZS5jb2RlIGZvciBzdGFuZGFsb25lXG4gICAgICAgIHJldHVybiBfYCEke3ZhbGlkYXRlU2NoZW1hUmVmfSgke3NjaGVtYUNvZGV9KWBcbiAgICAgIH1cbiAgICAgIHJldHVybiBuaWxcbiAgICB9XG4gIH1cblxuICBzdWJzY2hlbWEoYXBwbDogU3Vic2NoZW1hQXJncywgdmFsaWQ6IE5hbWUpOiBTY2hlbWFDeHQge1xuICAgIGNvbnN0IHN1YnNjaGVtYSA9IGdldFN1YnNjaGVtYSh0aGlzLml0LCBhcHBsKVxuICAgIGV4dGVuZFN1YnNjaGVtYURhdGEoc3Vic2NoZW1hLCB0aGlzLml0LCBhcHBsKVxuICAgIGV4dGVuZFN1YnNjaGVtYU1vZGUoc3Vic2NoZW1hLCBhcHBsKVxuICAgIGNvbnN0IG5leHRDb250ZXh0ID0gey4uLnRoaXMuaXQsIC4uLnN1YnNjaGVtYSwgaXRlbXM6IHVuZGVmaW5lZCwgcHJvcHM6IHVuZGVmaW5lZH1cbiAgICBzdWJzY2hlbWFDb2RlKG5leHRDb250ZXh0LCB2YWxpZClcbiAgICByZXR1cm4gbmV4dENvbnRleHRcbiAgfVxuXG4gIG1lcmdlRXZhbHVhdGVkKHNjaGVtYUN4dDogU2NoZW1hQ3h0LCB0b05hbWU/OiB0eXBlb2YgTmFtZSk6IHZvaWQge1xuICAgIGNvbnN0IHtpdCwgZ2VufSA9IHRoaXNcbiAgICBpZiAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQpIHJldHVyblxuICAgIGlmIChpdC5wcm9wcyAhPT0gdHJ1ZSAmJiBzY2hlbWFDeHQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaXQucHJvcHMgPSBtZXJnZUV2YWx1YXRlZC5wcm9wcyhnZW4sIHNjaGVtYUN4dC5wcm9wcywgaXQucHJvcHMsIHRvTmFtZSlcbiAgICB9XG4gICAgaWYgKGl0Lml0ZW1zICE9PSB0cnVlICYmIHNjaGVtYUN4dC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpdC5pdGVtcyA9IG1lcmdlRXZhbHVhdGVkLml0ZW1zKGdlbiwgc2NoZW1hQ3h0Lml0ZW1zLCBpdC5pdGVtcywgdG9OYW1lKVxuICAgIH1cbiAgfVxuXG4gIG1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoZW1hQ3h0OiBTY2hlbWFDeHQsIHZhbGlkOiBOYW1lKTogYm9vbGVhbiB8IHZvaWQge1xuICAgIGNvbnN0IHtpdCwgZ2VufSA9IHRoaXNcbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiAoaXQucHJvcHMgIT09IHRydWUgfHwgaXQuaXRlbXMgIT09IHRydWUpKSB7XG4gICAgICBnZW4uaWYodmFsaWQsICgpID0+IHRoaXMubWVyZ2VFdmFsdWF0ZWQoc2NoZW1hQ3h0LCBOYW1lKSlcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGtleXdvcmRDb2RlKFxuICBpdDogU2NoZW1hT2JqQ3h0LFxuICBrZXl3b3JkOiBzdHJpbmcsXG4gIGRlZjogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgcnVsZVR5cGU/OiBKU09OVHlwZVxuKTogdm9pZCB7XG4gIGNvbnN0IGN4dCA9IG5ldyBLZXl3b3JkQ3h0KGl0LCBkZWYsIGtleXdvcmQpXG4gIGlmIChcImNvZGVcIiBpbiBkZWYpIHtcbiAgICBkZWYuY29kZShjeHQsIHJ1bGVUeXBlKVxuICB9IGVsc2UgaWYgKGN4dC4kZGF0YSAmJiBkZWYudmFsaWRhdGUpIHtcbiAgICBmdW5jS2V5d29yZENvZGUoY3h0LCBkZWYpXG4gIH0gZWxzZSBpZiAoXCJtYWNyb1wiIGluIGRlZikge1xuICAgIG1hY3JvS2V5d29yZENvZGUoY3h0LCBkZWYpXG4gIH0gZWxzZSBpZiAoZGVmLmNvbXBpbGUgfHwgZGVmLnZhbGlkYXRlKSB7XG4gICAgZnVuY0tleXdvcmRDb2RlKGN4dCwgZGVmKVxuICB9XG59XG5cbmNvbnN0IEpTT05fUE9JTlRFUiA9IC9eXFwvKD86W15+XXx+MHx+MSkqJC9cbmNvbnN0IFJFTEFUSVZFX0pTT05fUE9JTlRFUiA9IC9eKFswLTldKykoI3xcXC8oPzpbXn5dfH4wfH4xKSopPyQvXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGF0YShcbiAgJGRhdGE6IHN0cmluZyxcbiAge2RhdGFMZXZlbCwgZGF0YU5hbWVzLCBkYXRhUGF0aEFycn06IFNjaGVtYUN4dFxuKTogQ29kZSB8IG51bWJlciB7XG4gIGxldCBqc29uUG9pbnRlclxuICBsZXQgZGF0YTogQ29kZVxuICBpZiAoJGRhdGEgPT09IFwiXCIpIHJldHVybiBOLnJvb3REYXRhXG4gIGlmICgkZGF0YVswXSA9PT0gXCIvXCIpIHtcbiAgICBpZiAoIUpTT05fUE9JTlRFUi50ZXN0KCRkYXRhKSkgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIEpTT04tcG9pbnRlcjogJHskZGF0YX1gKVxuICAgIGpzb25Qb2ludGVyID0gJGRhdGFcbiAgICBkYXRhID0gTi5yb290RGF0YVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IG1hdGNoZXMgPSBSRUxBVElWRV9KU09OX1BPSU5URVIuZXhlYygkZGF0YSlcbiAgICBpZiAoIW1hdGNoZXMpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBKU09OLXBvaW50ZXI6ICR7JGRhdGF9YClcbiAgICBjb25zdCB1cDogbnVtYmVyID0gK21hdGNoZXNbMV1cbiAgICBqc29uUG9pbnRlciA9IG1hdGNoZXNbMl1cbiAgICBpZiAoanNvblBvaW50ZXIgPT09IFwiI1wiKSB7XG4gICAgICBpZiAodXAgPj0gZGF0YUxldmVsKSB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNc2coXCJwcm9wZXJ0eS9pbmRleFwiLCB1cCkpXG4gICAgICByZXR1cm4gZGF0YVBhdGhBcnJbZGF0YUxldmVsIC0gdXBdXG4gICAgfVxuICAgIGlmICh1cCA+IGRhdGFMZXZlbCkgdGhyb3cgbmV3IEVycm9yKGVycm9yTXNnKFwiZGF0YVwiLCB1cCkpXG4gICAgZGF0YSA9IGRhdGFOYW1lc1tkYXRhTGV2ZWwgLSB1cF1cbiAgICBpZiAoIWpzb25Qb2ludGVyKSByZXR1cm4gZGF0YVxuICB9XG5cbiAgbGV0IGV4cHIgPSBkYXRhXG4gIGNvbnN0IHNlZ21lbnRzID0ganNvblBvaW50ZXIuc3BsaXQoXCIvXCIpXG4gIGZvciAoY29uc3Qgc2VnbWVudCBvZiBzZWdtZW50cykge1xuICAgIGlmIChzZWdtZW50KSB7XG4gICAgICBkYXRhID0gX2Ake2RhdGF9JHtnZXRQcm9wZXJ0eSh1bmVzY2FwZUpzb25Qb2ludGVyKHNlZ21lbnQpKX1gXG4gICAgICBleHByID0gX2Ake2V4cHJ9ICYmICR7ZGF0YX1gXG4gICAgfVxuICB9XG4gIHJldHVybiBleHByXG5cbiAgZnVuY3Rpb24gZXJyb3JNc2cocG9pbnRlclR5cGU6IHN0cmluZywgdXA6IG51bWJlcik6IHN0cmluZyB7XG4gICAgcmV0dXJuIGBDYW5ub3QgYWNjZXNzICR7cG9pbnRlclR5cGV9ICR7dXB9IGxldmVscyB1cCwgY3VycmVudCBsZXZlbCBpcyAke2RhdGFMZXZlbH1gXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7RXJyb3JPYmplY3R9IGZyb20gXCIuLi90eXBlc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVhZG9ubHkgZXJyb3JzOiBQYXJ0aWFsPEVycm9yT2JqZWN0PltdXG4gIHJlYWRvbmx5IGFqdjogdHJ1ZVxuICByZWFkb25seSB2YWxpZGF0aW9uOiB0cnVlXG5cbiAgY29uc3RydWN0b3IoZXJyb3JzOiBQYXJ0aWFsPEVycm9yT2JqZWN0PltdKSB7XG4gICAgc3VwZXIoXCJ2YWxpZGF0aW9uIGZhaWxlZFwiKVxuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzXG4gICAgdGhpcy5hanYgPSB0aGlzLnZhbGlkYXRpb24gPSB0cnVlXG4gIH1cbn1cbiIsICJpbXBvcnQge3Jlc29sdmVVcmwsIG5vcm1hbGl6ZUlkLCBnZXRGdWxsUGF0aH0gZnJvbSBcIi4vcmVzb2x2ZVwiXG5pbXBvcnQgdHlwZSB7VXJpUmVzb2x2ZXJ9IGZyb20gXCIuLi90eXBlc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1pc3NpbmdSZWZFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgcmVhZG9ubHkgbWlzc2luZ1JlZjogc3RyaW5nXG4gIHJlYWRvbmx5IG1pc3NpbmdTY2hlbWE6IHN0cmluZ1xuXG4gIGNvbnN0cnVjdG9yKHJlc29sdmVyOiBVcmlSZXNvbHZlciwgYmFzZUlkOiBzdHJpbmcsIHJlZjogc3RyaW5nLCBtc2c/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtc2cgfHwgYGNhbid0IHJlc29sdmUgcmVmZXJlbmNlICR7cmVmfSBmcm9tIGlkICR7YmFzZUlkfWApXG4gICAgdGhpcy5taXNzaW5nUmVmID0gcmVzb2x2ZVVybChyZXNvbHZlciwgYmFzZUlkLCByZWYpXG4gICAgdGhpcy5taXNzaW5nU2NoZW1hID0gbm9ybWFsaXplSWQoZ2V0RnVsbFBhdGgocmVzb2x2ZXIsIHRoaXMubWlzc2luZ1JlZikpXG4gIH1cbn1cbiIsICJpbXBvcnQgdHlwZSB7XG4gIEFueVNjaGVtYSxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBBbnlWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIEV2YWx1YXRlZFByb3BlcnRpZXMsXG4gIEV2YWx1YXRlZEl0ZW1zLFxufSBmcm9tIFwiLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUgQWp2IGZyb20gXCIuLi9jb3JlXCJcbmltcG9ydCB0eXBlIHtJbnN0YW5jZU9wdGlvbnN9IGZyb20gXCIuLi9jb3JlXCJcbmltcG9ydCB7Q29kZUdlbiwgXywgbmlsLCBzdHJpbmdpZnksIE5hbWUsIENvZGUsIFZhbHVlU2NvcGVOYW1lfSBmcm9tIFwiLi9jb2RlZ2VuXCJcbmltcG9ydCBWYWxpZGF0aW9uRXJyb3IgZnJvbSBcIi4uL3J1bnRpbWUvdmFsaWRhdGlvbl9lcnJvclwiXG5pbXBvcnQgTiBmcm9tIFwiLi9uYW1lc1wiXG5pbXBvcnQge0xvY2FsUmVmcywgZ2V0RnVsbFBhdGgsIF9nZXRGdWxsUGF0aCwgaW5saW5lUmVmLCBub3JtYWxpemVJZCwgcmVzb2x2ZVVybH0gZnJvbSBcIi4vcmVzb2x2ZVwiXG5pbXBvcnQge3NjaGVtYUhhc1J1bGVzQnV0UmVmLCB1bmVzY2FwZUZyYWdtZW50fSBmcm9tIFwiLi91dGlsXCJcbmltcG9ydCB7dmFsaWRhdGVGdW5jdGlvbkNvZGV9IGZyb20gXCIuL3ZhbGlkYXRlXCJcbmltcG9ydCB7VVJJQ29tcG9uZW50fSBmcm9tIFwiZmFzdC11cmlcIlxuaW1wb3J0IHtKU09OVHlwZX0gZnJvbSBcIi4vcnVsZXNcIlxuXG5leHBvcnQgdHlwZSBTY2hlbWFSZWZzID0ge1xuICBbUmVmIGluIHN0cmluZ10/OiBTY2hlbWFFbnYgfCBBbnlTY2hlbWFcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFDeHQge1xuICByZWFkb25seSBnZW46IENvZGVHZW5cbiAgcmVhZG9ubHkgYWxsRXJyb3JzPzogYm9vbGVhbiAvLyB2YWxpZGF0aW9uIG1vZGUgLSB3aGV0aGVyIHRvIGNvbGxlY3QgYWxsIGVycm9ycyBvciBicmVhayBvbiBlcnJvclxuICByZWFkb25seSBkYXRhOiBOYW1lIC8vIE5hbWUgd2l0aCByZWZlcmVuY2UgdG8gdGhlIGN1cnJlbnQgcGFydCBvZiBkYXRhIGluc3RhbmNlXG4gIHJlYWRvbmx5IHBhcmVudERhdGE6IE5hbWUgLy8gc2hvdWxkIGJlIHVzZWQgaW4ga2V5d29yZHMgbW9kaWZ5aW5nIGRhdGFcbiAgcmVhZG9ubHkgcGFyZW50RGF0YVByb3BlcnR5OiBDb2RlIHwgbnVtYmVyIC8vIHNob3VsZCBiZSB1c2VkIGluIGtleXdvcmRzIG1vZGlmeWluZyBkYXRhXG4gIHJlYWRvbmx5IGRhdGFOYW1lczogTmFtZVtdXG4gIHJlYWRvbmx5IGRhdGFQYXRoQXJyOiAoQ29kZSB8IG51bWJlcilbXVxuICByZWFkb25seSBkYXRhTGV2ZWw6IG51bWJlciAvLyB0aGUgbGV2ZWwgb2YgdGhlIGN1cnJlbnRseSB2YWxpZGF0ZWQgZGF0YSxcbiAgLy8gaXQgY2FuIGJlIHVzZWQgdG8gYWNjZXNzIGJvdGggdGhlIHByb3BlcnR5IG5hbWVzIGFuZCB0aGUgZGF0YSBvbiBhbGwgbGV2ZWxzIGZyb20gdGhlIHRvcC5cbiAgZGF0YVR5cGVzOiBKU09OVHlwZVtdIC8vIGRhdGEgdHlwZXMgYXBwbGllZCB0byB0aGUgY3VycmVudCBwYXJ0IG9mIGRhdGEgaW5zdGFuY2VcbiAgZGVmaW5lZFByb3BlcnRpZXM6IFNldDxzdHJpbmc+IC8vIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGtlZXAgdHJhY2sgb2YgZm9yIHJlcXVpcmVkIGNoZWNrc1xuICByZWFkb25seSB0b3BTY2hlbWFSZWY6IENvZGVcbiAgcmVhZG9ubHkgdmFsaWRhdGVOYW1lOiBOYW1lXG4gIGV2YWx1YXRlZD86IE5hbWVcbiAgcmVhZG9ubHkgVmFsaWRhdGlvbkVycm9yPzogTmFtZVxuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYSAvLyBjdXJyZW50IHNjaGVtYSBvYmplY3QgLSBlcXVhbCB0byBwYXJlbnRTY2hlbWEgcGFzc2VkIHZpYSBLZXl3b3JkQ3h0XG4gIHJlYWRvbmx5IHNjaGVtYUVudjogU2NoZW1hRW52XG4gIHJlYWRvbmx5IHJvb3RJZDogc3RyaW5nXG4gIGJhc2VJZDogc3RyaW5nIC8vIHRoZSBjdXJyZW50IHNjaGVtYSBiYXNlIFVSSSB0aGF0IHNob3VsZCBiZSB1c2VkIGFzIHRoZSBiYXNlIGZvciByZXNvbHZpbmcgVVJJcyBpbiByZWZlcmVuY2VzIChcXCRyZWYpXG4gIHJlYWRvbmx5IHNjaGVtYVBhdGg6IENvZGUgLy8gdGhlIHJ1bi10aW1lIGV4cHJlc3Npb24gdGhhdCBldmFsdWF0ZXMgdG8gdGhlIHByb3BlcnR5IG5hbWUgb2YgdGhlIGN1cnJlbnQgc2NoZW1hXG4gIHJlYWRvbmx5IGVyclNjaGVtYVBhdGg6IHN0cmluZyAvLyB0aGlzIGlzIGFjdHVhbCBzdHJpbmcsIHNob3VsZCBub3QgYmUgY2hhbmdlZCB0byBDb2RlXG4gIHJlYWRvbmx5IGVycm9yUGF0aDogQ29kZVxuICByZWFkb25seSBwcm9wZXJ0eU5hbWU/OiBOYW1lXG4gIHJlYWRvbmx5IGNvbXBvc2l0ZVJ1bGU/OiBib29sZWFuIC8vIHRydWUgaW5kaWNhdGVzIHRoYXQgdGhlIGN1cnJlbnQgc2NoZW1hIGlzIGluc2lkZSB0aGUgY29tcG91bmQga2V5d29yZCxcbiAgLy8gd2hlcmUgZmFpbGluZyBzb21lIHJ1bGUgZG9lc24ndCBtZWFuIHZhbGlkYXRpb24gZmFpbHVyZSAoYGFueU9mYCwgYG9uZU9mYCwgYG5vdGAsIGBpZmApLlxuICAvLyBUaGlzIGZsYWcgaXMgdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB5b3UgY2FuIHJldHVybiB2YWxpZGF0aW9uIHJlc3VsdCBpbW1lZGlhdGVseSBhZnRlciBhbnkgZXJyb3IgaW4gY2FzZSB0aGUgb3B0aW9uIGBhbGxFcnJvcnNgIGlzIG5vdCBgdHJ1ZS5cbiAgLy8gWW91IG9ubHkgbmVlZCB0byB1c2UgaXQgaWYgeW91IGhhdmUgbWFueSBzdGVwcyBpbiB5b3VyIGtleXdvcmRzIGFuZCBwb3RlbnRpYWxseSBjYW4gZGVmaW5lIG11bHRpcGxlIGVycm9ycy5cbiAgcHJvcHM/OiBFdmFsdWF0ZWRQcm9wZXJ0aWVzIHwgTmFtZSAvLyBwcm9wZXJ0aWVzIGV2YWx1YXRlZCBieSB0aGlzIHNjaGVtYSAtIHVzZWQgYnkgcGFyZW50IHNjaGVtYSBvciBhc3NpZ25lZCB0byB2YWxpZGF0aW9uIGZ1bmN0aW9uXG4gIGl0ZW1zPzogRXZhbHVhdGVkSXRlbXMgfCBOYW1lIC8vIGxhc3QgaXRlbSBldmFsdWF0ZWQgYnkgdGhpcyBzY2hlbWEgLSB1c2VkIGJ5IHBhcmVudCBzY2hlbWEgb3IgYXNzaWduZWQgdG8gdmFsaWRhdGlvbiBmdW5jdGlvblxuICBqdGREaXNjcmltaW5hdG9yPzogc3RyaW5nXG4gIGp0ZE1ldGFkYXRhPzogYm9vbGVhblxuICByZWFkb25seSBjcmVhdGVFcnJvcnM/OiBib29sZWFuXG4gIHJlYWRvbmx5IG9wdHM6IEluc3RhbmNlT3B0aW9ucyAvLyBBanYgaW5zdGFuY2Ugb3B0aW9uLlxuICByZWFkb25seSBzZWxmOiBBanYgLy8gY3VycmVudCBBanYgaW5zdGFuY2Vcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTY2hlbWFPYmpDeHQgZXh0ZW5kcyBTY2hlbWFDeHQge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYU9iamVjdFxufVxuaW50ZXJmYWNlIFNjaGVtYUVudkFyZ3Mge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYVxuICByZWFkb25seSBzY2hlbWFJZD86IFwiJGlkXCIgfCBcImlkXCJcbiAgcmVhZG9ubHkgcm9vdD86IFNjaGVtYUVudlxuICByZWFkb25seSBiYXNlSWQ/OiBzdHJpbmdcbiAgcmVhZG9ubHkgc2NoZW1hUGF0aD86IHN0cmluZ1xuICByZWFkb25seSBsb2NhbFJlZnM/OiBMb2NhbFJlZnNcbiAgcmVhZG9ubHkgbWV0YT86IGJvb2xlYW5cbn1cblxuZXhwb3J0IGNsYXNzIFNjaGVtYUVudiBpbXBsZW1lbnRzIFNjaGVtYUVudkFyZ3Mge1xuICByZWFkb25seSBzY2hlbWE6IEFueVNjaGVtYVxuICByZWFkb25seSBzY2hlbWFJZD86IFwiJGlkXCIgfCBcImlkXCJcbiAgcmVhZG9ubHkgcm9vdDogU2NoZW1hRW52XG4gIGJhc2VJZDogc3RyaW5nIC8vIFRPRE8gcG9zc2libHksIGl0IHNob3VsZCBiZSByZWFkb25seVxuICBzY2hlbWFQYXRoPzogc3RyaW5nXG4gIGxvY2FsUmVmcz86IExvY2FsUmVmc1xuICByZWFkb25seSBtZXRhPzogYm9vbGVhblxuICByZWFkb25seSAkYXN5bmM/OiBib29sZWFuIC8vIHRydWUgaWYgdGhlIGN1cnJlbnQgc2NoZW1hIGlzIGFzeW5jaHJvbm91cy5cbiAgcmVhZG9ubHkgcmVmczogU2NoZW1hUmVmcyA9IHt9XG4gIHJlYWRvbmx5IGR5bmFtaWNBbmNob3JzOiB7W1JlZiBpbiBzdHJpbmddPzogdHJ1ZX0gPSB7fVxuICB2YWxpZGF0ZT86IEFueVZhbGlkYXRlRnVuY3Rpb25cbiAgdmFsaWRhdGVOYW1lPzogVmFsdWVTY29wZU5hbWVcbiAgc2VyaWFsaXplPzogKGRhdGE6IHVua25vd24pID0+IHN0cmluZ1xuICBzZXJpYWxpemVOYW1lPzogVmFsdWVTY29wZU5hbWVcbiAgcGFyc2U/OiAoZGF0YTogc3RyaW5nKSA9PiB1bmtub3duXG4gIHBhcnNlTmFtZT86IFZhbHVlU2NvcGVOYW1lXG5cbiAgY29uc3RydWN0b3IoZW52OiBTY2hlbWFFbnZBcmdzKSB7XG4gICAgbGV0IHNjaGVtYTogQW55U2NoZW1hT2JqZWN0IHwgdW5kZWZpbmVkXG4gICAgaWYgKHR5cGVvZiBlbnYuc2NoZW1hID09IFwib2JqZWN0XCIpIHNjaGVtYSA9IGVudi5zY2hlbWFcbiAgICB0aGlzLnNjaGVtYSA9IGVudi5zY2hlbWFcbiAgICB0aGlzLnNjaGVtYUlkID0gZW52LnNjaGVtYUlkXG4gICAgdGhpcy5yb290ID0gZW52LnJvb3QgfHwgdGhpc1xuICAgIHRoaXMuYmFzZUlkID0gZW52LmJhc2VJZCA/PyBub3JtYWxpemVJZChzY2hlbWE/LltlbnYuc2NoZW1hSWQgfHwgXCIkaWRcIl0pXG4gICAgdGhpcy5zY2hlbWFQYXRoID0gZW52LnNjaGVtYVBhdGhcbiAgICB0aGlzLmxvY2FsUmVmcyA9IGVudi5sb2NhbFJlZnNcbiAgICB0aGlzLm1ldGEgPSBlbnYubWV0YVxuICAgIHRoaXMuJGFzeW5jID0gc2NoZW1hPy4kYXN5bmNcbiAgICB0aGlzLnJlZnMgPSB7fVxuICB9XG59XG5cbi8vIGxldCBjb2RlU2l6ZSA9IDBcbi8vIGxldCBub2RlQ291bnQgPSAwXG5cbi8vIENvbXBpbGVzIHNjaGVtYSBpbiBTY2hlbWFFbnZcbmV4cG9ydCBmdW5jdGlvbiBjb21waWxlU2NoZW1hKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBTY2hlbWFFbnYge1xuICAvLyBUT0RPIHJlZmFjdG9yIC0gcmVtb3ZlIGNvbXBpbGF0aW9uc1xuICBjb25zdCBfc2NoID0gZ2V0Q29tcGlsaW5nU2NoZW1hLmNhbGwodGhpcywgc2NoKVxuICBpZiAoX3NjaCkgcmV0dXJuIF9zY2hcbiAgY29uc3Qgcm9vdElkID0gZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBzY2gucm9vdC5iYXNlSWQpIC8vIFRPRE8gaWYgZ2V0RnVsbFBhdGggcmVtb3ZlZCAxIHRlc3RzIGZhaWxzXG4gIGNvbnN0IHtlczUsIGxpbmVzfSA9IHRoaXMub3B0cy5jb2RlXG4gIGNvbnN0IHtvd25Qcm9wZXJ0aWVzfSA9IHRoaXMub3B0c1xuICBjb25zdCBnZW4gPSBuZXcgQ29kZUdlbih0aGlzLnNjb3BlLCB7ZXM1LCBsaW5lcywgb3duUHJvcGVydGllc30pXG4gIGxldCBfVmFsaWRhdGlvbkVycm9yXG4gIGlmIChzY2guJGFzeW5jKSB7XG4gICAgX1ZhbGlkYXRpb25FcnJvciA9IGdlbi5zY29wZVZhbHVlKFwiRXJyb3JcIiwge1xuICAgICAgcmVmOiBWYWxpZGF0aW9uRXJyb3IsXG4gICAgICBjb2RlOiBfYHJlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIikuZGVmYXVsdGAsXG4gICAgfSlcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlTmFtZSA9IGdlbi5zY29wZU5hbWUoXCJ2YWxpZGF0ZVwiKVxuICBzY2gudmFsaWRhdGVOYW1lID0gdmFsaWRhdGVOYW1lXG5cbiAgY29uc3Qgc2NoZW1hQ3h0OiBTY2hlbWFDeHQgPSB7XG4gICAgZ2VuLFxuICAgIGFsbEVycm9yczogdGhpcy5vcHRzLmFsbEVycm9ycyxcbiAgICBkYXRhOiBOLmRhdGEsXG4gICAgcGFyZW50RGF0YTogTi5wYXJlbnREYXRhLFxuICAgIHBhcmVudERhdGFQcm9wZXJ0eTogTi5wYXJlbnREYXRhUHJvcGVydHksXG4gICAgZGF0YU5hbWVzOiBbTi5kYXRhXSxcbiAgICBkYXRhUGF0aEFycjogW25pbF0sIC8vIFRPRE8gY2FuIGl0cyBsZW5ndGggYmUgdXNlZCBhcyBkYXRhTGV2ZWwgaWYgbmlsIGlzIHJlbW92ZWQ/XG4gICAgZGF0YUxldmVsOiAwLFxuICAgIGRhdGFUeXBlczogW10sXG4gICAgZGVmaW5lZFByb3BlcnRpZXM6IG5ldyBTZXQ8c3RyaW5nPigpLFxuICAgIHRvcFNjaGVtYVJlZjogZ2VuLnNjb3BlVmFsdWUoXG4gICAgICBcInNjaGVtYVwiLFxuICAgICAgdGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlXG4gICAgICAgID8ge3JlZjogc2NoLnNjaGVtYSwgY29kZTogc3RyaW5naWZ5KHNjaC5zY2hlbWEpfVxuICAgICAgICA6IHtyZWY6IHNjaC5zY2hlbWF9XG4gICAgKSxcbiAgICB2YWxpZGF0ZU5hbWUsXG4gICAgVmFsaWRhdGlvbkVycm9yOiBfVmFsaWRhdGlvbkVycm9yLFxuICAgIHNjaGVtYTogc2NoLnNjaGVtYSxcbiAgICBzY2hlbWFFbnY6IHNjaCxcbiAgICByb290SWQsXG4gICAgYmFzZUlkOiBzY2guYmFzZUlkIHx8IHJvb3RJZCxcbiAgICBzY2hlbWFQYXRoOiBuaWwsXG4gICAgZXJyU2NoZW1hUGF0aDogc2NoLnNjaGVtYVBhdGggfHwgKHRoaXMub3B0cy5qdGQgPyBcIlwiIDogXCIjXCIpLFxuICAgIGVycm9yUGF0aDogX2BcIlwiYCxcbiAgICBvcHRzOiB0aGlzLm9wdHMsXG4gICAgc2VsZjogdGhpcyxcbiAgfVxuXG4gIGxldCBzb3VyY2VDb2RlOiBzdHJpbmcgfCB1bmRlZmluZWRcbiAgdHJ5IHtcbiAgICB0aGlzLl9jb21waWxhdGlvbnMuYWRkKHNjaClcbiAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29kZShzY2hlbWFDeHQpXG4gICAgZ2VuLm9wdGltaXplKHRoaXMub3B0cy5jb2RlLm9wdGltaXplKVxuICAgIC8vIGdlbi5vcHRpbWl6ZSgxKVxuICAgIGNvbnN0IHZhbGlkYXRlQ29kZSA9IGdlbi50b1N0cmluZygpXG4gICAgc291cmNlQ29kZSA9IGAke2dlbi5zY29wZVJlZnMoTi5zY29wZSl9cmV0dXJuICR7dmFsaWRhdGVDb2RlfWBcbiAgICAvLyBjb25zb2xlLmxvZygoY29kZVNpemUgKz0gc291cmNlQ29kZS5sZW5ndGgpLCAobm9kZUNvdW50ICs9IGdlbi5ub2RlQ291bnQpKVxuICAgIGlmICh0aGlzLm9wdHMuY29kZS5wcm9jZXNzKSBzb3VyY2VDb2RlID0gdGhpcy5vcHRzLmNvZGUucHJvY2Vzcyhzb3VyY2VDb2RlLCBzY2gpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlKVxuICAgIGNvbnN0IG1ha2VWYWxpZGF0ZSA9IG5ldyBGdW5jdGlvbihgJHtOLnNlbGZ9YCwgYCR7Ti5zY29wZX1gLCBzb3VyY2VDb2RlKVxuICAgIGNvbnN0IHZhbGlkYXRlOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uID0gbWFrZVZhbGlkYXRlKHRoaXMsIHRoaXMuc2NvcGUuZ2V0KCkpXG4gICAgdGhpcy5zY29wZS52YWx1ZSh2YWxpZGF0ZU5hbWUsIHtyZWY6IHZhbGlkYXRlfSlcblxuICAgIHZhbGlkYXRlLmVycm9ycyA9IG51bGxcbiAgICB2YWxpZGF0ZS5zY2hlbWEgPSBzY2guc2NoZW1hXG4gICAgdmFsaWRhdGUuc2NoZW1hRW52ID0gc2NoXG4gICAgaWYgKHNjaC4kYXN5bmMpICh2YWxpZGF0ZSBhcyBBc3luY1ZhbGlkYXRlRnVuY3Rpb24pLiRhc3luYyA9IHRydWVcbiAgICBpZiAodGhpcy5vcHRzLmNvZGUuc291cmNlID09PSB0cnVlKSB7XG4gICAgICB2YWxpZGF0ZS5zb3VyY2UgPSB7dmFsaWRhdGVOYW1lLCB2YWxpZGF0ZUNvZGUsIHNjb3BlVmFsdWVzOiBnZW4uX3ZhbHVlc31cbiAgICB9XG4gICAgaWYgKHRoaXMub3B0cy51bmV2YWx1YXRlZCkge1xuICAgICAgY29uc3Qge3Byb3BzLCBpdGVtc30gPSBzY2hlbWFDeHRcbiAgICAgIHZhbGlkYXRlLmV2YWx1YXRlZCA9IHtcbiAgICAgICAgcHJvcHM6IHByb3BzIGluc3RhbmNlb2YgTmFtZSA/IHVuZGVmaW5lZCA6IHByb3BzLFxuICAgICAgICBpdGVtczogaXRlbXMgaW5zdGFuY2VvZiBOYW1lID8gdW5kZWZpbmVkIDogaXRlbXMsXG4gICAgICAgIGR5bmFtaWNQcm9wczogcHJvcHMgaW5zdGFuY2VvZiBOYW1lLFxuICAgICAgICBkeW5hbWljSXRlbXM6IGl0ZW1zIGluc3RhbmNlb2YgTmFtZSxcbiAgICAgIH1cbiAgICAgIGlmICh2YWxpZGF0ZS5zb3VyY2UpIHZhbGlkYXRlLnNvdXJjZS5ldmFsdWF0ZWQgPSBzdHJpbmdpZnkodmFsaWRhdGUuZXZhbHVhdGVkKVxuICAgIH1cbiAgICBzY2gudmFsaWRhdGUgPSB2YWxpZGF0ZVxuICAgIHJldHVybiBzY2hcbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlbGV0ZSBzY2gudmFsaWRhdGVcbiAgICBkZWxldGUgc2NoLnZhbGlkYXRlTmFtZVxuICAgIGlmIChzb3VyY2VDb2RlKSB0aGlzLmxvZ2dlci5lcnJvcihcIkVycm9yIGNvbXBpbGluZyBzY2hlbWEsIGZ1bmN0aW9uIGNvZGU6XCIsIHNvdXJjZUNvZGUpXG4gICAgLy8gY29uc29sZS5sb2coXCJcXG5cXG5cXG4gKioqIFxcblwiLCBzb3VyY2VDb2RlLCB0aGlzLm9wdHMpXG4gICAgdGhyb3cgZVxuICB9IGZpbmFsbHkge1xuICAgIHRoaXMuX2NvbXBpbGF0aW9ucy5kZWxldGUoc2NoKVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlUmVmKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudixcbiAgYmFzZUlkOiBzdHJpbmcsXG4gIHJlZjogc3RyaW5nXG4pOiBBbnlTY2hlbWEgfCBTY2hlbWFFbnYgfCB1bmRlZmluZWQge1xuICByZWYgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCByZWYpXG4gIGNvbnN0IHNjaE9yRnVuYyA9IHJvb3QucmVmc1tyZWZdXG4gIGlmIChzY2hPckZ1bmMpIHJldHVybiBzY2hPckZ1bmNcblxuICBsZXQgX3NjaCA9IHJlc29sdmUuY2FsbCh0aGlzLCByb290LCByZWYpXG4gIGlmIChfc2NoID09PSB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBzY2hlbWEgPSByb290LmxvY2FsUmVmcz8uW3JlZl0gLy8gVE9ETyBtYXliZSBsb2NhbFJlZnMgc2hvdWxkIGhvbGQgU2NoZW1hRW52XG4gICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGlmIChzY2hlbWEpIF9zY2ggPSBuZXcgU2NoZW1hRW52KHtzY2hlbWEsIHNjaGVtYUlkLCByb290LCBiYXNlSWR9KVxuICB9XG5cbiAgaWYgKF9zY2ggPT09IHVuZGVmaW5lZCkgcmV0dXJuXG4gIHJldHVybiAocm9vdC5yZWZzW3JlZl0gPSBpbmxpbmVPckNvbXBpbGUuY2FsbCh0aGlzLCBfc2NoKSlcbn1cblxuZnVuY3Rpb24gaW5saW5lT3JDb21waWxlKHRoaXM6IEFqdiwgc2NoOiBTY2hlbWFFbnYpOiBBbnlTY2hlbWEgfCBTY2hlbWFFbnYge1xuICBpZiAoaW5saW5lUmVmKHNjaC5zY2hlbWEsIHRoaXMub3B0cy5pbmxpbmVSZWZzKSkgcmV0dXJuIHNjaC5zY2hlbWFcbiAgcmV0dXJuIHNjaC52YWxpZGF0ZSA/IHNjaCA6IGNvbXBpbGVTY2hlbWEuY2FsbCh0aGlzLCBzY2gpXG59XG5cbi8vIEluZGV4IG9mIHNjaGVtYSBjb21waWxhdGlvbiBpbiB0aGUgY3VycmVudGx5IGNvbXBpbGVkIGxpc3RcbmV4cG9ydCBmdW5jdGlvbiBnZXRDb21waWxpbmdTY2hlbWEodGhpczogQWp2LCBzY2hFbnY6IFNjaGVtYUVudik6IFNjaGVtYUVudiB8IHZvaWQge1xuICBmb3IgKGNvbnN0IHNjaCBvZiB0aGlzLl9jb21waWxhdGlvbnMpIHtcbiAgICBpZiAoc2FtZVNjaGVtYUVudihzY2gsIHNjaEVudikpIHJldHVybiBzY2hcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW1lU2NoZW1hRW52KHMxOiBTY2hlbWFFbnYsIHMyOiBTY2hlbWFFbnYpOiBib29sZWFuIHtcbiAgcmV0dXJuIHMxLnNjaGVtYSA9PT0gczIuc2NoZW1hICYmIHMxLnJvb3QgPT09IHMyLnJvb3QgJiYgczEuYmFzZUlkID09PSBzMi5iYXNlSWRcbn1cblxuLy8gcmVzb2x2ZSBhbmQgY29tcGlsZSB0aGUgcmVmZXJlbmNlcyAoJHJlZilcbi8vIFRPRE8gcmV0dXJucyBBbnlTY2hlbWFPYmplY3QgKGlmIHRoZSBzY2hlbWEgY2FuIGJlIGlubGluZWQpIG9yIHZhbGlkYXRpb24gZnVuY3Rpb25cbmZ1bmN0aW9uIHJlc29sdmUoXG4gIHRoaXM6IEFqdixcbiAgcm9vdDogU2NoZW1hRW52LCAvLyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgcm9vdCBzY2hlbWEgZm9yIHRoZSBjdXJyZW50IHNjaGVtYVxuICByZWY6IHN0cmluZyAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgbGV0IHNjaFxuICB3aGlsZSAodHlwZW9mIChzY2ggPSB0aGlzLnJlZnNbcmVmXSkgPT0gXCJzdHJpbmdcIikgcmVmID0gc2NoXG4gIHJldHVybiBzY2ggfHwgdGhpcy5zY2hlbWFzW3JlZl0gfHwgcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIHJlZilcbn1cblxuLy8gUmVzb2x2ZSBzY2hlbWEsIGl0cyByb290IGFuZCBiYXNlSWRcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU2NoZW1hKFxuICB0aGlzOiBBanYsXG4gIHJvb3Q6IFNjaGVtYUVudiwgLy8gcm9vdCBvYmplY3Qgd2l0aCBwcm9wZXJ0aWVzIHNjaGVtYSwgcmVmcyBUT0RPIGJlbG93IFNjaGVtYUVudiBpcyBhc3NpZ25lZCB0byBpdFxuICByZWY6IHN0cmluZyAvLyByZWZlcmVuY2UgdG8gcmVzb2x2ZVxuKTogU2NoZW1hRW52IHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgcCA9IHRoaXMub3B0cy51cmlSZXNvbHZlci5wYXJzZShyZWYpXG4gIGNvbnN0IHJlZlBhdGggPSBfZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBwKVxuICBsZXQgYmFzZUlkID0gZ2V0RnVsbFBhdGgodGhpcy5vcHRzLnVyaVJlc29sdmVyLCByb290LmJhc2VJZCwgdW5kZWZpbmVkKVxuICAvLyBUT0RPIGBPYmplY3Qua2V5cyhyb290LnNjaGVtYSkubGVuZ3RoID4gMGAgc2hvdWxkIG5vdCBiZSBuZWVkZWQgLSBidXQgcmVtb3ZpbmcgYnJlYWtzIDIgdGVzdHNcbiAgaWYgKE9iamVjdC5rZXlzKHJvb3Quc2NoZW1hKS5sZW5ndGggPiAwICYmIHJlZlBhdGggPT09IGJhc2VJZCkge1xuICAgIHJldHVybiBnZXRKc29uUG9pbnRlci5jYWxsKHRoaXMsIHAsIHJvb3QpXG4gIH1cblxuICBjb25zdCBpZCA9IG5vcm1hbGl6ZUlkKHJlZlBhdGgpXG4gIGNvbnN0IHNjaE9yUmVmID0gdGhpcy5yZWZzW2lkXSB8fCB0aGlzLnNjaGVtYXNbaWRdXG4gIGlmICh0eXBlb2Ygc2NoT3JSZWYgPT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IHNjaCA9IHJlc29sdmVTY2hlbWEuY2FsbCh0aGlzLCByb290LCBzY2hPclJlZilcbiAgICBpZiAodHlwZW9mIHNjaD8uc2NoZW1hICE9PSBcIm9iamVjdFwiKSByZXR1cm5cbiAgICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2gpXG4gIH1cblxuICBpZiAodHlwZW9mIHNjaE9yUmVmPy5zY2hlbWEgIT09IFwib2JqZWN0XCIpIHJldHVyblxuICBpZiAoIXNjaE9yUmVmLnZhbGlkYXRlKSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoT3JSZWYpXG4gIGlmIChpZCA9PT0gbm9ybWFsaXplSWQocmVmKSkge1xuICAgIGNvbnN0IHtzY2hlbWF9ID0gc2NoT3JSZWZcbiAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgY29uc3Qgc2NoSWQgPSBzY2hlbWFbc2NoZW1hSWRdXG4gICAgaWYgKHNjaElkKSBiYXNlSWQgPSByZXNvbHZlVXJsKHRoaXMub3B0cy51cmlSZXNvbHZlciwgYmFzZUlkLCBzY2hJZClcbiAgICByZXR1cm4gbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkfSlcbiAgfVxuICByZXR1cm4gZ2V0SnNvblBvaW50ZXIuY2FsbCh0aGlzLCBwLCBzY2hPclJlZilcbn1cblxuY29uc3QgUFJFVkVOVF9TQ09QRV9DSEFOR0UgPSBuZXcgU2V0KFtcbiAgXCJwcm9wZXJ0aWVzXCIsXG4gIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgXCJlbnVtXCIsXG4gIFwiZGVwZW5kZW5jaWVzXCIsXG4gIFwiZGVmaW5pdGlvbnNcIixcbl0pXG5cbmZ1bmN0aW9uIGdldEpzb25Qb2ludGVyKFxuICB0aGlzOiBBanYsXG4gIHBhcnNlZFJlZjogVVJJQ29tcG9uZW50LFxuICB7YmFzZUlkLCBzY2hlbWEsIHJvb3R9OiBTY2hlbWFFbnZcbik6IFNjaGVtYUVudiB8IHVuZGVmaW5lZCB7XG4gIGlmIChwYXJzZWRSZWYuZnJhZ21lbnQ/LlswXSAhPT0gXCIvXCIpIHJldHVyblxuICBmb3IgKGNvbnN0IHBhcnQgb2YgcGFyc2VkUmVmLmZyYWdtZW50LnNsaWNlKDEpLnNwbGl0KFwiL1wiKSkge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcImJvb2xlYW5cIikgcmV0dXJuXG4gICAgY29uc3QgcGFydFNjaGVtYSA9IHNjaGVtYVt1bmVzY2FwZUZyYWdtZW50KHBhcnQpXVxuICAgIGlmIChwYXJ0U2NoZW1hID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIHNjaGVtYSA9IHBhcnRTY2hlbWFcbiAgICAvLyBUT0RPIFBSRVZFTlRfU0NPUEVfQ0hBTkdFIGNvdWxkIGJlIGRlZmluZWQgaW4ga2V5d29yZCBkZWY/XG4gICAgY29uc3Qgc2NoSWQgPSB0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiICYmIHNjaGVtYVt0aGlzLm9wdHMuc2NoZW1hSWRdXG4gICAgaWYgKCFQUkVWRU5UX1NDT1BFX0NIQU5HRS5oYXMocGFydCkgJiYgc2NoSWQpIHtcbiAgICAgIGJhc2VJZCA9IHJlc29sdmVVcmwodGhpcy5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsIHNjaElkKVxuICAgIH1cbiAgfVxuICBsZXQgZW52OiBTY2hlbWFFbnYgfCB1bmRlZmluZWRcbiAgaWYgKHR5cGVvZiBzY2hlbWEgIT0gXCJib29sZWFuXCIgJiYgc2NoZW1hLiRyZWYgJiYgIXNjaGVtYUhhc1J1bGVzQnV0UmVmKHNjaGVtYSwgdGhpcy5SVUxFUykpIHtcbiAgICBjb25zdCAkcmVmID0gcmVzb2x2ZVVybCh0aGlzLm9wdHMudXJpUmVzb2x2ZXIsIGJhc2VJZCwgc2NoZW1hLiRyZWYpXG4gICAgZW52ID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsICRyZWYpXG4gIH1cbiAgLy8gZXZlbiB0aG91Z2ggcmVzb2x1dGlvbiBmYWlsZWQgd2UgbmVlZCB0byByZXR1cm4gU2NoZW1hRW52IHRvIHRocm93IGV4Y2VwdGlvblxuICAvLyBzbyB0aGF0IGNvbXBpbGVBc3luYyBsb2FkcyBtaXNzaW5nIHNjaGVtYS5cbiAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICBlbnYgPSBlbnYgfHwgbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgcm9vdCwgYmFzZUlkfSlcbiAgaWYgKGVudi5zY2hlbWEgIT09IGVudi5yb290LnNjaGVtYSkgcmV0dXJuIGVudlxuICByZXR1cm4gdW5kZWZpbmVkXG59XG4iLCAie1xuICBcIiRpZFwiOiBcImh0dHBzOi8vcmF3LmdpdGh1YnVzZXJjb250ZW50LmNvbS9hanYtdmFsaWRhdG9yL2Fqdi9tYXN0ZXIvbGliL3JlZnMvZGF0YS5qc29uI1wiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTWV0YS1zY2hlbWEgZm9yICRkYXRhIHJlZmVyZW5jZSAoSlNPTiBBbnlTY2hlbWEgZXh0ZW5zaW9uIHByb3Bvc2FsKVwiLFxuICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgXCJyZXF1aXJlZFwiOiBbXCIkZGF0YVwiXSxcbiAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICBcIiRkYXRhXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJhbnlPZlwiOiBbe1wiZm9ybWF0XCI6IFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCJ9LCB7XCJmb3JtYXRcIjogXCJqc29uLXBvaW50ZXJcIn1dXG4gICAgfVxuICB9LFxuICBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCI6IGZhbHNlXG59XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbi8qKiBAdHlwZSB7KHZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW59ICovXG5jb25zdCBpc1VVSUQgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXltcXGRhLWZdezh9LVtcXGRhLWZdezR9LVtcXGRhLWZdezR9LVtcXGRhLWZdezR9LVtcXGRhLWZdezEyfSQvaXUpXG5cbi8qKiBAdHlwZSB7KHZhbHVlOiBzdHJpbmcpID0+IGJvb2xlYW59ICovXG5jb25zdCBpc0lQdjQgPSBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXig/Oig/OjI1WzAtNV18MlswLTRdXFxkfDFcXGR7Mn18WzEtOV1cXGR8XFxkKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVxcZHwxXFxkezJ9fFsxLTldXFxkfFxcZCkkL3UpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBpbnB1dFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkIChpbnB1dCkge1xuICBsZXQgYWNjID0gJydcbiAgbGV0IGNvZGUgPSAwXG4gIGxldCBpID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvZGUgPSBpbnB1dFtpXS5jaGFyQ29kZUF0KDApXG4gICAgaWYgKGNvZGUgPT09IDQ4KSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoISgoY29kZSA+PSA0OCAmJiBjb2RlIDw9IDU3KSB8fCAoY29kZSA+PSA2NSAmJiBjb2RlIDw9IDcwKSB8fCAoY29kZSA+PSA5NyAmJiBjb2RlIDw9IDEwMikpKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgYWNjICs9IGlucHV0W2ldXG4gICAgYnJlYWtcbiAgfVxuXG4gIGZvciAoaSArPSAxOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaW5wdXRbaV0uY2hhckNvZGVBdCgwKVxuICAgIGlmICghKChjb2RlID49IDQ4ICYmIGNvZGUgPD0gNTcpIHx8IChjb2RlID49IDY1ICYmIGNvZGUgPD0gNzApIHx8IChjb2RlID49IDk3ICYmIGNvZGUgPD0gMTAyKSkpIHtcbiAgICAgIHJldHVybiAnJ1xuICAgIH1cbiAgICBhY2MgKz0gaW5wdXRbaV1cbiAgfVxuICByZXR1cm4gYWNjXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gR2V0SVBWNlJlc3VsdFxuICogQHByb3BlcnR5IHtib29sZWFufSBlcnJvciAtIEluZGljYXRlcyBpZiB0aGVyZSB3YXMgYW4gZXJyb3IgcGFyc2luZyB0aGUgSVB2NiBhZGRyZXNzLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IGFkZHJlc3MgLSBUaGUgcGFyc2VkIElQdjYgYWRkcmVzcy5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbem9uZV0gLSBUaGUgem9uZSBpZGVudGlmaWVyLCBpZiBwcmVzZW50LlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgbm9uU2ltcGxlRG9tYWluID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL1teIVwiJCYnKCkqKyxcXC0uOz1fYGEtent9fl0vdSlcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGJ1ZmZlclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGNvbnN1bWVJc1pvbmUgKGJ1ZmZlcikge1xuICBidWZmZXIubGVuZ3RoID0gMFxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYnVmZmVyXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGFkZHJlc3NcbiAqIEBwYXJhbSB7R2V0SVBWNlJlc3VsdH0gb3V0cHV0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29uc3VtZUhleHRldHMgKGJ1ZmZlciwgYWRkcmVzcywgb3V0cHV0KSB7XG4gIGlmIChidWZmZXIubGVuZ3RoKSB7XG4gICAgY29uc3QgaGV4ID0gc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkKGJ1ZmZlcilcbiAgICBpZiAoaGV4ICE9PSAnJykge1xuICAgICAgYWRkcmVzcy5wdXNoKGhleClcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LmVycm9yID0gdHJ1ZVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIGJ1ZmZlci5sZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5wdXRcbiAqIEByZXR1cm5zIHtHZXRJUFY2UmVzdWx0fVxuICovXG5mdW5jdGlvbiBnZXRJUFY2IChpbnB1dCkge1xuICBsZXQgdG9rZW5Db3VudCA9IDBcbiAgY29uc3Qgb3V0cHV0ID0geyBlcnJvcjogZmFsc2UsIGFkZHJlc3M6ICcnLCB6b25lOiAnJyB9XG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgYWRkcmVzcyA9IFtdXG4gIC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3QgYnVmZmVyID0gW11cbiAgbGV0IGVuZGlwdjZFbmNvdW50ZXJlZCA9IGZhbHNlXG4gIGxldCBlbmRJcHY2ID0gZmFsc2VcblxuICBsZXQgY29uc3VtZSA9IGNvbnN1bWVIZXh0ZXRzXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnNvciA9IGlucHV0W2ldXG4gICAgaWYgKGN1cnNvciA9PT0gJ1snIHx8IGN1cnNvciA9PT0gJ10nKSB7IGNvbnRpbnVlIH1cbiAgICBpZiAoY3Vyc29yID09PSAnOicpIHtcbiAgICAgIGlmIChlbmRpcHY2RW5jb3VudGVyZWQgPT09IHRydWUpIHtcbiAgICAgICAgZW5kSXB2NiA9IHRydWVcbiAgICAgIH1cbiAgICAgIGlmICghY29uc3VtZShidWZmZXIsIGFkZHJlc3MsIG91dHB1dCkpIHsgYnJlYWsgfVxuICAgICAgaWYgKCsrdG9rZW5Db3VudCA+IDcpIHtcbiAgICAgICAgLy8gbm90IHZhbGlkXG4gICAgICAgIG91dHB1dC5lcnJvciA9IHRydWVcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChpID4gMCAmJiBpbnB1dFtpIC0gMV0gPT09ICc6Jykge1xuICAgICAgICBlbmRpcHY2RW5jb3VudGVyZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBhZGRyZXNzLnB1c2goJzonKVxuICAgICAgY29udGludWVcbiAgICB9IGVsc2UgaWYgKGN1cnNvciA9PT0gJyUnKSB7XG4gICAgICBpZiAoIWNvbnN1bWUoYnVmZmVyLCBhZGRyZXNzLCBvdXRwdXQpKSB7IGJyZWFrIH1cbiAgICAgIC8vIHN3aXRjaCB0byB6b25lIGRldGVjdGlvblxuICAgICAgY29uc3VtZSA9IGNvbnN1bWVJc1pvbmVcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmZmVyLnB1c2goY3Vyc29yKVxuICAgICAgY29udGludWVcbiAgICB9XG4gIH1cbiAgaWYgKGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoY29uc3VtZSA9PT0gY29uc3VtZUlzWm9uZSkge1xuICAgICAgb3V0cHV0LnpvbmUgPSBidWZmZXIuam9pbignJylcbiAgICB9IGVsc2UgaWYgKGVuZElwdjYpIHtcbiAgICAgIGFkZHJlc3MucHVzaChidWZmZXIuam9pbignJykpXG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZHJlc3MucHVzaChzdHJpbmdBcnJheVRvSGV4U3RyaXBwZWQoYnVmZmVyKSlcbiAgICB9XG4gIH1cbiAgb3V0cHV0LmFkZHJlc3MgPSBhZGRyZXNzLmpvaW4oJycpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBOb3JtYWxpemVJUHY2UmVzdWx0XG4gKiBAcHJvcGVydHkge3N0cmluZ30gaG9zdCAtIFRoZSBub3JtYWxpemVkIGhvc3QuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW2VzY2FwZWRIb3N0XSAtIFRoZSBlc2NhcGVkIGhvc3QuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IGlzSVBWNiAtIEluZGljYXRlcyBpZiB0aGUgaG9zdCBpcyBhbiBJUHY2IGFkZHJlc3MuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdFxuICogQHJldHVybnMge05vcm1hbGl6ZUlQdjZSZXN1bHR9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZUlQdjYgKGhvc3QpIHtcbiAgaWYgKGZpbmRUb2tlbihob3N0LCAnOicpIDwgMikgeyByZXR1cm4geyBob3N0LCBpc0lQVjY6IGZhbHNlIH0gfVxuICBjb25zdCBpcHY2ID0gZ2V0SVBWNihob3N0KVxuXG4gIGlmICghaXB2Ni5lcnJvcikge1xuICAgIGxldCBuZXdIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgbGV0IGVzY2FwZWRIb3N0ID0gaXB2Ni5hZGRyZXNzXG4gICAgaWYgKGlwdjYuem9uZSkge1xuICAgICAgbmV3SG9zdCArPSAnJScgKyBpcHY2LnpvbmVcbiAgICAgIGVzY2FwZWRIb3N0ICs9ICclMjUnICsgaXB2Ni56b25lXG4gICAgfVxuICAgIHJldHVybiB7IGhvc3Q6IG5ld0hvc3QsIGlzSVBWNjogdHJ1ZSwgZXNjYXBlZEhvc3QgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IGhvc3QsIGlzSVBWNjogZmFsc2UgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5mdW5jdGlvbiBmaW5kVG9rZW4gKHN0ciwgdG9rZW4pIHtcbiAgbGV0IGluZCA9IDBcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoc3RyW2ldID09PSB0b2tlbikgaW5kKytcbiAgfVxuICByZXR1cm4gaW5kXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKlxuICogQHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuNFxuICovXG5mdW5jdGlvbiByZW1vdmVEb3RTZWdtZW50cyAocGF0aCkge1xuICBsZXQgaW5wdXQgPSBwYXRoXG4gIGNvbnN0IG91dHB1dCA9IFtdXG4gIGxldCBuZXh0U2xhc2ggPSAtMVxuICBsZXQgbGVuID0gMFxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25kLWFzc2lnblxuICB3aGlsZSAobGVuID0gaW5wdXQubGVuZ3RoKSB7XG4gICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgaWYgKGlucHV0ID09PSAnLicpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSBpZiAoaW5wdXQgPT09ICcvJykge1xuICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgIGJyZWFrXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXQucHVzaChpbnB1dClcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxlbiA9PT0gMikge1xuICAgICAgaWYgKGlucHV0WzBdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnB1dFswXSA9PT0gJy8nKSB7XG4gICAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nIHx8IGlucHV0WzFdID09PSAnLycpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaCgnLycpXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobGVuID09PSAzKSB7XG4gICAgICBpZiAoaW5wdXQgPT09ICcvLi4nKSB7XG4gICAgICAgIGlmIChvdXRwdXQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgb3V0cHV0LnBvcCgpXG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0LnB1c2goJy8nKVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5wdXRbMF0gPT09ICcuJykge1xuICAgICAgaWYgKGlucHV0WzFdID09PSAnLicpIHtcbiAgICAgICAgaWYgKGlucHV0WzJdID09PSAnLycpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpbnB1dFsxXSA9PT0gJy8nKSB7XG4gICAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UoMilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlucHV0WzBdID09PSAnLycpIHtcbiAgICAgIGlmIChpbnB1dFsxXSA9PT0gJy4nKSB7XG4gICAgICAgIGlmIChpbnB1dFsyXSA9PT0gJy8nKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZSgyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXRbMl0gPT09ICcuJykge1xuICAgICAgICAgIGlmIChpbnB1dFszXSA9PT0gJy8nKSB7XG4gICAgICAgICAgICBpbnB1dCA9IGlucHV0LnNsaWNlKDMpXG4gICAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBvdXRwdXQucG9wKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVsZSAyRTogTW92ZSBub3JtYWwgcGF0aCBzZWdtZW50IHRvIG91dHB1dFxuICAgIGlmICgobmV4dFNsYXNoID0gaW5wdXQuaW5kZXhPZignLycsIDEpKSA9PT0gLTEpIHtcbiAgICAgIG91dHB1dC5wdXNoKGlucHV0KVxuICAgICAgYnJlYWtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goaW5wdXQuc2xpY2UoMCwgbmV4dFNsYXNoKSlcbiAgICAgIGlucHV0ID0gaW5wdXQuc2xpY2UobmV4dFNsYXNoKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtib29sZWFufSBlc2NcbiAqIEByZXR1cm5zIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyAoY29tcG9uZW50LCBlc2MpIHtcbiAgY29uc3QgZnVuYyA9IGVzYyAhPT0gdHJ1ZSA/IGVzY2FwZSA6IHVuZXNjYXBlXG4gIGlmIChjb21wb25lbnQuc2NoZW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb21wb25lbnQuc2NoZW1lID0gZnVuYyhjb21wb25lbnQuc2NoZW1lKVxuICB9XG4gIGlmIChjb21wb25lbnQudXNlcmluZm8gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC51c2VyaW5mbyA9IGZ1bmMoY29tcG9uZW50LnVzZXJpbmZvKVxuICB9XG4gIGlmIChjb21wb25lbnQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50Lmhvc3QgPSBmdW5jKGNvbXBvbmVudC5ob3N0KVxuICB9XG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29tcG9uZW50LnBhdGggPSBmdW5jKGNvbXBvbmVudC5wYXRoKVxuICB9XG4gIGlmIChjb21wb25lbnQucXVlcnkgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5xdWVyeSA9IGZ1bmMoY29tcG9uZW50LnF1ZXJ5KVxuICB9XG4gIGlmIChjb21wb25lbnQuZnJhZ21lbnQgIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbXBvbmVudC5mcmFnbWVudCA9IGZ1bmMoY29tcG9uZW50LmZyYWdtZW50KVxuICB9XG4gIHJldHVybiBjb21wb25lbnRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHJldHVybnMge3N0cmluZ3x1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIHJlY29tcG9zZUF1dGhvcml0eSAoY29tcG9uZW50KSB7XG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgaWYgKGNvbXBvbmVudC51c2VyaW5mbyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goY29tcG9uZW50LnVzZXJpbmZvKVxuICAgIHVyaVRva2Vucy5wdXNoKCdAJylcbiAgfVxuXG4gIGlmIChjb21wb25lbnQuaG9zdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IGhvc3QgPSB1bmVzY2FwZShjb21wb25lbnQuaG9zdClcbiAgICBpZiAoIWlzSVB2NChob3N0KSkge1xuICAgICAgY29uc3QgaXBWNnJlcyA9IG5vcm1hbGl6ZUlQdjYoaG9zdClcbiAgICAgIGlmIChpcFY2cmVzLmlzSVBWNiA9PT0gdHJ1ZSkge1xuICAgICAgICBob3N0ID0gYFske2lwVjZyZXMuZXNjYXBlZEhvc3R9XWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGhvc3QgPSBjb21wb25lbnQuaG9zdFxuICAgICAgfVxuICAgIH1cbiAgICB1cmlUb2tlbnMucHVzaChob3N0KVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQucG9ydCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNvbXBvbmVudC5wb3J0ID09PSAnc3RyaW5nJykge1xuICAgIHVyaVRva2Vucy5wdXNoKCc6JylcbiAgICB1cmlUb2tlbnMucHVzaChTdHJpbmcoY29tcG9uZW50LnBvcnQpKVxuICB9XG5cbiAgcmV0dXJuIHVyaVRva2Vucy5sZW5ndGggPyB1cmlUb2tlbnMuam9pbignJykgOiB1bmRlZmluZWRcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBub25TaW1wbGVEb21haW4sXG4gIHJlY29tcG9zZUF1dGhvcml0eSxcbiAgbm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcsXG4gIHJlbW92ZURvdFNlZ21lbnRzLFxuICBpc0lQdjQsXG4gIGlzVVVJRCxcbiAgbm9ybWFsaXplSVB2NixcbiAgc3RyaW5nQXJyYXlUb0hleFN0cmlwcGVkXG59XG4iLCAiJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IHsgaXNVVUlEIH0gPSByZXF1aXJlKCcuL3V0aWxzJylcbmNvbnN0IFVSTl9SRUcgPSAvKFtcXGRhLXpdW1xcZFxcLWEtel17MCwzMX0pOigoPzpbXFx3ISQnKCkqKyxcXC0uOjs9QF18JVtcXGRhLWZdezJ9KSspL2l1XG5cbmNvbnN0IHN1cHBvcnRlZFNjaGVtZU5hbWVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFsnaHR0cCcsICdodHRwcycsICd3cycsXG4gICd3c3MnLCAndXJuJywgJ3Vybjp1dWlkJ10pXG5cbi8qKiBAdHlwZWRlZiB7c3VwcG9ydGVkU2NoZW1lTmFtZXNbbnVtYmVyXX0gU2NoZW1lTmFtZSAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7bmFtZSBpcyBTY2hlbWVOYW1lfVxuICovXG5mdW5jdGlvbiBpc1ZhbGlkU2NoZW1lTmFtZSAobmFtZSkge1xuICByZXR1cm4gc3VwcG9ydGVkU2NoZW1lTmFtZXMuaW5kZXhPZigvKiogQHR5cGUgeyp9ICovIChuYW1lKSkgIT09IC0xXG59XG5cbi8qKlxuICogQGNhbGxiYWNrIFNjaGVtZUZuXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IGNvbXBvbmVudFxuICogQHBhcmFtIHtpbXBvcnQoJy4uL3R5cGVzL2luZGV4JykuT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBTY2hlbWVIYW5kbGVyXG4gKiBAcHJvcGVydHkge1NjaGVtZU5hbWV9IHNjaGVtZSAtIFRoZSBzY2hlbWUgbmFtZS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2RvbWFpbkhvc3RdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgc3VwcG9ydHMgZG9tYWluIGhvc3RzLlxuICogQHByb3BlcnR5IHtTY2hlbWVGbn0gcGFyc2UgLSBGdW5jdGlvbiB0byBwYXJzZSB0aGUgVVJJIGNvbXBvbmVudCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge1NjaGVtZUZufSBzZXJpYWxpemUgLSBGdW5jdGlvbiB0byBzZXJpYWxpemUgdGhlIFVSSSBjb21wb25lbnQgZm9yIHRoaXMgc2NoZW1lLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbc2tpcE5vcm1hbGl6ZV0gLSBJbmRpY2F0ZXMgaWYgbm9ybWFsaXphdGlvbiBzaG91bGQgYmUgc2tpcHBlZCBmb3IgdGhpcyBzY2hlbWUuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFthYnNvbHV0ZVBhdGhdIC0gSW5kaWNhdGVzIGlmIHRoZSBzY2hlbWUgdXNlcyBhYnNvbHV0ZSBwYXRocy5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW3VuaWNvZGVTdXBwb3J0XSAtIEluZGljYXRlcyBpZiB0aGUgc2NoZW1lIHN1cHBvcnRzIFVuaWNvZGUuXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IHdzQ29tcG9uZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gd3NJc1NlY3VyZSAod3NDb21wb25lbnQpIHtcbiAgaWYgKHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH0gZWxzZSBpZiAod3NDb21wb25lbnQuc2VjdXJlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHdzQ29tcG9uZW50LnNjaGVtZSkge1xuICAgIHJldHVybiAoXG4gICAgICB3c0NvbXBvbmVudC5zY2hlbWUubGVuZ3RoID09PSAzICYmXG4gICAgICAod3NDb21wb25lbnQuc2NoZW1lWzBdID09PSAndycgfHwgd3NDb21wb25lbnQuc2NoZW1lWzBdID09PSAnVycpICYmXG4gICAgICAod3NDb21wb25lbnQuc2NoZW1lWzFdID09PSAncycgfHwgd3NDb21wb25lbnQuc2NoZW1lWzFdID09PSAnUycpICYmXG4gICAgICAod3NDb21wb25lbnQuc2NoZW1lWzJdID09PSAncycgfHwgd3NDb21wb25lbnQuc2NoZW1lWzJdID09PSAnUycpXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiBodHRwUGFyc2UgKGNvbXBvbmVudCkge1xuICBpZiAoIWNvbXBvbmVudC5ob3N0KSB7XG4gICAgY29tcG9uZW50LmVycm9yID0gY29tcG9uZW50LmVycm9yIHx8ICdIVFRQIFVSSXMgbXVzdCBoYXZlIGEgaG9zdC4nXG4gIH1cblxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiBodHRwU2VyaWFsaXplIChjb21wb25lbnQpIHtcbiAgY29uc3Qgc2VjdXJlID0gU3RyaW5nKGNvbXBvbmVudC5zY2hlbWUpLnRvTG93ZXJDYXNlKCkgPT09ICdodHRwcydcblxuICAvLyBub3JtYWxpemUgdGhlIGRlZmF1bHQgcG9ydFxuICBpZiAoY29tcG9uZW50LnBvcnQgPT09IChzZWN1cmUgPyA0NDMgOiA4MCkgfHwgY29tcG9uZW50LnBvcnQgPT09ICcnKSB7XG4gICAgY29tcG9uZW50LnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIG5vcm1hbGl6ZSB0aGUgZW1wdHkgcGF0aFxuICBpZiAoIWNvbXBvbmVudC5wYXRoKSB7XG4gICAgY29tcG9uZW50LnBhdGggPSAnLydcbiAgfVxuXG4gIC8vIE5PVEU6IFdlIGRvIG5vdCBwYXJzZSBxdWVyeSBzdHJpbmdzIGZvciBIVFRQIFVSSXNcbiAgLy8gYXMgV1dXIEZvcm0gVXJsIEVuY29kZWQgcXVlcnkgc3RyaW5ncyBhcmUgcGFydCBvZiB0aGUgSFRNTDQrIHNwZWMsXG4gIC8vIGFuZCBub3QgdGhlIEhUVFAgc3BlYy5cblxuICByZXR1cm4gY29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB3c1BhcnNlICh3c0NvbXBvbmVudCkge1xuLy8gaW5kaWNhdGUgaWYgdGhlIHNlY3VyZSBmbGFnIGlzIHNldFxuICB3c0NvbXBvbmVudC5zZWN1cmUgPSB3c0lzU2VjdXJlKHdzQ29tcG9uZW50KVxuXG4gIC8vIGNvbnN0cnVjdCByZXNvdWNlIG5hbWVcbiAgd3NDb21wb25lbnQucmVzb3VyY2VOYW1lID0gKHdzQ29tcG9uZW50LnBhdGggfHwgJy8nKSArICh3c0NvbXBvbmVudC5xdWVyeSA/ICc/JyArIHdzQ29tcG9uZW50LnF1ZXJ5IDogJycpXG4gIHdzQ29tcG9uZW50LnBhdGggPSB1bmRlZmluZWRcbiAgd3NDb21wb25lbnQucXVlcnkgPSB1bmRlZmluZWRcblxuICByZXR1cm4gd3NDb21wb25lbnRcbn1cblxuLyoqIEB0eXBlIHtTY2hlbWVGbn0gKi9cbmZ1bmN0aW9uIHdzU2VyaWFsaXplICh3c0NvbXBvbmVudCkge1xuLy8gbm9ybWFsaXplIHRoZSBkZWZhdWx0IHBvcnRcbiAgaWYgKHdzQ29tcG9uZW50LnBvcnQgPT09ICh3c0lzU2VjdXJlKHdzQ29tcG9uZW50KSA/IDQ0MyA6IDgwKSB8fCB3c0NvbXBvbmVudC5wb3J0ID09PSAnJykge1xuICAgIHdzQ29tcG9uZW50LnBvcnQgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIGVuc3VyZSBzY2hlbWUgbWF0Y2hlcyBzZWN1cmUgZmxhZ1xuICBpZiAodHlwZW9mIHdzQ29tcG9uZW50LnNlY3VyZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgd3NDb21wb25lbnQuc2NoZW1lID0gKHdzQ29tcG9uZW50LnNlY3VyZSA/ICd3c3MnIDogJ3dzJylcbiAgICB3c0NvbXBvbmVudC5zZWN1cmUgPSB1bmRlZmluZWRcbiAgfVxuXG4gIC8vIHJlY29uc3RydWN0IHBhdGggZnJvbSByZXNvdXJjZSBuYW1lXG4gIGlmICh3c0NvbXBvbmVudC5yZXNvdXJjZU5hbWUpIHtcbiAgICBjb25zdCBbcGF0aCwgcXVlcnldID0gd3NDb21wb25lbnQucmVzb3VyY2VOYW1lLnNwbGl0KCc/JylcbiAgICB3c0NvbXBvbmVudC5wYXRoID0gKHBhdGggJiYgcGF0aCAhPT0gJy8nID8gcGF0aCA6IHVuZGVmaW5lZClcbiAgICB3c0NvbXBvbmVudC5xdWVyeSA9IHF1ZXJ5XG4gICAgd3NDb21wb25lbnQucmVzb3VyY2VOYW1lID0gdW5kZWZpbmVkXG4gIH1cblxuICAvLyBmb3JiaWQgZnJhZ21lbnQgY29tcG9uZW50XG4gIHdzQ29tcG9uZW50LmZyYWdtZW50ID0gdW5kZWZpbmVkXG5cbiAgcmV0dXJuIHdzQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm5QYXJzZSAodXJuQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIGlmICghdXJuQ29tcG9uZW50LnBhdGgpIHtcbiAgICB1cm5Db21wb25lbnQuZXJyb3IgPSAnVVJOIGNhbiBub3QgYmUgcGFyc2VkJ1xuICAgIHJldHVybiB1cm5Db21wb25lbnRcbiAgfVxuICBjb25zdCBtYXRjaGVzID0gdXJuQ29tcG9uZW50LnBhdGgubWF0Y2goVVJOX1JFRylcbiAgaWYgKG1hdGNoZXMpIHtcbiAgICBjb25zdCBzY2hlbWUgPSBvcHRpb25zLnNjaGVtZSB8fCB1cm5Db21wb25lbnQuc2NoZW1lIHx8ICd1cm4nXG4gICAgdXJuQ29tcG9uZW50Lm5pZCA9IG1hdGNoZXNbMV0udG9Mb3dlckNhc2UoKVxuICAgIHVybkNvbXBvbmVudC5uc3MgPSBtYXRjaGVzWzJdXG4gICAgY29uc3QgdXJuU2NoZW1lID0gYCR7c2NoZW1lfToke29wdGlvbnMubmlkIHx8IHVybkNvbXBvbmVudC5uaWR9YFxuICAgIGNvbnN0IHNjaGVtZUhhbmRsZXIgPSBnZXRTY2hlbWVIYW5kbGVyKHVyblNjaGVtZSlcbiAgICB1cm5Db21wb25lbnQucGF0aCA9IHVuZGVmaW5lZFxuXG4gICAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICAgIHVybkNvbXBvbmVudCA9IHNjaGVtZUhhbmRsZXIucGFyc2UodXJuQ29tcG9uZW50LCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cm5Db21wb25lbnQuZXJyb3IgPSB1cm5Db21wb25lbnQuZXJyb3IgfHwgJ1VSTiBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cblxuICByZXR1cm4gdXJuQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm5TZXJpYWxpemUgKHVybkNvbXBvbmVudCwgb3B0aW9ucykge1xuICBpZiAodXJuQ29tcG9uZW50Lm5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVUk4gd2l0aG91dCBuaWQgY2Fubm90IGJlIHNlcmlhbGl6ZWQnKVxuICB9XG4gIGNvbnN0IHNjaGVtZSA9IG9wdGlvbnMuc2NoZW1lIHx8IHVybkNvbXBvbmVudC5zY2hlbWUgfHwgJ3VybidcbiAgY29uc3QgbmlkID0gdXJuQ29tcG9uZW50Lm5pZC50b0xvd2VyQ2FzZSgpXG4gIGNvbnN0IHVyblNjaGVtZSA9IGAke3NjaGVtZX06JHtvcHRpb25zLm5pZCB8fCBuaWR9YFxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcih1cm5TY2hlbWUpXG5cbiAgaWYgKHNjaGVtZUhhbmRsZXIpIHtcbiAgICB1cm5Db21wb25lbnQgPSBzY2hlbWVIYW5kbGVyLnNlcmlhbGl6ZSh1cm5Db21wb25lbnQsIG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB1cmlDb21wb25lbnQgPSB1cm5Db21wb25lbnRcbiAgY29uc3QgbnNzID0gdXJuQ29tcG9uZW50Lm5zc1xuICB1cmlDb21wb25lbnQucGF0aCA9IGAke25pZCB8fCBvcHRpb25zLm5pZH06JHtuc3N9YFxuXG4gIG9wdGlvbnMuc2tpcEVzY2FwZSA9IHRydWVcbiAgcmV0dXJuIHVyaUNvbXBvbmVudFxufVxuXG4vKiogQHR5cGUge1NjaGVtZUZufSAqL1xuZnVuY3Rpb24gdXJudXVpZFBhcnNlICh1cm5Db21wb25lbnQsIG9wdGlvbnMpIHtcbiAgY29uc3QgdXVpZENvbXBvbmVudCA9IHVybkNvbXBvbmVudFxuICB1dWlkQ29tcG9uZW50LnV1aWQgPSB1dWlkQ29tcG9uZW50Lm5zc1xuICB1dWlkQ29tcG9uZW50Lm5zcyA9IHVuZGVmaW5lZFxuXG4gIGlmICghb3B0aW9ucy50b2xlcmFudCAmJiAoIXV1aWRDb21wb25lbnQudXVpZCB8fCAhaXNVVUlEKHV1aWRDb21wb25lbnQudXVpZCkpKSB7XG4gICAgdXVpZENvbXBvbmVudC5lcnJvciA9IHV1aWRDb21wb25lbnQuZXJyb3IgfHwgJ1VVSUQgaXMgbm90IHZhbGlkLidcbiAgfVxuXG4gIHJldHVybiB1dWlkQ29tcG9uZW50XG59XG5cbi8qKiBAdHlwZSB7U2NoZW1lRm59ICovXG5mdW5jdGlvbiB1cm51dWlkU2VyaWFsaXplICh1dWlkQ29tcG9uZW50KSB7XG4gIGNvbnN0IHVybkNvbXBvbmVudCA9IHV1aWRDb21wb25lbnRcbiAgLy8gbm9ybWFsaXplIFVVSURcbiAgdXJuQ29tcG9uZW50Lm5zcyA9ICh1dWlkQ29tcG9uZW50LnV1aWQgfHwgJycpLnRvTG93ZXJDYXNlKClcbiAgcmV0dXJuIHVybkNvbXBvbmVudFxufVxuXG5jb25zdCBodHRwID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICdodHRwJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IGh0dHBQYXJzZSxcbiAgc2VyaWFsaXplOiBodHRwU2VyaWFsaXplXG59KVxuXG5jb25zdCBodHRwcyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnaHR0cHMnLFxuICBkb21haW5Ib3N0OiBodHRwLmRvbWFpbkhvc3QsXG4gIHBhcnNlOiBodHRwUGFyc2UsXG4gIHNlcmlhbGl6ZTogaHR0cFNlcmlhbGl6ZVxufSlcblxuY29uc3Qgd3MgPSAvKiogQHR5cGUge1NjaGVtZUhhbmRsZXJ9ICovICh7XG4gIHNjaGVtZTogJ3dzJyxcbiAgZG9tYWluSG9zdDogdHJ1ZSxcbiAgcGFyc2U6IHdzUGFyc2UsXG4gIHNlcmlhbGl6ZTogd3NTZXJpYWxpemVcbn0pXG5cbmNvbnN0IHdzcyA9IC8qKiBAdHlwZSB7U2NoZW1lSGFuZGxlcn0gKi8gKHtcbiAgc2NoZW1lOiAnd3NzJyxcbiAgZG9tYWluSG9zdDogd3MuZG9tYWluSG9zdCxcbiAgcGFyc2U6IHdzLnBhcnNlLFxuICBzZXJpYWxpemU6IHdzLnNlcmlhbGl6ZVxufSlcblxuY29uc3QgdXJuID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd1cm4nLFxuICBwYXJzZTogdXJuUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJuU2VyaWFsaXplLFxuICBza2lwTm9ybWFsaXplOiB0cnVlXG59KVxuXG5jb25zdCB1cm51dWlkID0gLyoqIEB0eXBlIHtTY2hlbWVIYW5kbGVyfSAqLyAoe1xuICBzY2hlbWU6ICd1cm46dXVpZCcsXG4gIHBhcnNlOiB1cm51dWlkUGFyc2UsXG4gIHNlcmlhbGl6ZTogdXJudXVpZFNlcmlhbGl6ZSxcbiAgc2tpcE5vcm1hbGl6ZTogdHJ1ZVxufSlcblxuY29uc3QgU0NIRU1FUyA9IC8qKiBAdHlwZSB7UmVjb3JkPFNjaGVtZU5hbWUsIFNjaGVtZUhhbmRsZXI+fSAqLyAoe1xuICBodHRwLFxuICBodHRwcyxcbiAgd3MsXG4gIHdzcyxcbiAgdXJuLFxuICAndXJuOnV1aWQnOiB1cm51dWlkXG59KVxuXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoU0NIRU1FUywgbnVsbClcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ3x1bmRlZmluZWR9IHNjaGVtZVxuICogQHJldHVybnMge1NjaGVtZUhhbmRsZXJ8dW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBnZXRTY2hlbWVIYW5kbGVyIChzY2hlbWUpIHtcbiAgcmV0dXJuIChcbiAgICBzY2hlbWUgJiYgKFxuICAgICAgU0NIRU1FU1svKiogQHR5cGUge1NjaGVtZU5hbWV9ICovIChzY2hlbWUpXSB8fFxuICAgICAgU0NIRU1FU1svKiogQHR5cGUge1NjaGVtZU5hbWV9ICovKHNjaGVtZS50b0xvd2VyQ2FzZSgpKV0pXG4gICkgfHxcbiAgICB1bmRlZmluZWRcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHdzSXNTZWN1cmUsXG4gIFNDSEVNRVMsXG4gIGlzVmFsaWRTY2hlbWVOYW1lLFxuICBnZXRTY2hlbWVIYW5kbGVyLFxufVxuIiwgIid1c2Ugc3RyaWN0J1xuXG5jb25zdCB7IG5vcm1hbGl6ZUlQdjYsIHJlbW92ZURvdFNlZ21lbnRzLCByZWNvbXBvc2VBdXRob3JpdHksIG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nLCBpc0lQdjQsIG5vblNpbXBsZURvbWFpbiB9ID0gcmVxdWlyZSgnLi9saWIvdXRpbHMnKVxuY29uc3QgeyBTQ0hFTUVTLCBnZXRTY2hlbWVIYW5kbGVyIH0gPSByZXF1aXJlKCcuL2xpYi9zY2hlbWVzJylcblxuLyoqXG4gKiBAdGVtcGxhdGUge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudHxzdHJpbmd9IFRcbiAqIEBwYXJhbSB7VH0gdXJpXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZSAodXJpLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpID09PSAnc3RyaW5nJykge1xuICAgIHVyaSA9IC8qKiBAdHlwZSB7VH0gKi8gKHNlcmlhbGl6ZShwYXJzZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgfSBlbHNlIGlmICh0eXBlb2YgdXJpID09PSAnb2JqZWN0Jykge1xuICAgIHVyaSA9IC8qKiBAdHlwZSB7VH0gKi8gKHBhcnNlKHNlcmlhbGl6ZSh1cmksIG9wdGlvbnMpLCBvcHRpb25zKSlcbiAgfVxuICByZXR1cm4gdXJpXG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUklcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSSVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlc29sdmUgKGJhc2VVUkksIHJlbGF0aXZlVVJJLCBvcHRpb25zKSB7XG4gIGNvbnN0IHNjaGVtZWxlc3NPcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oeyBzY2hlbWU6ICdudWxsJyB9LCBvcHRpb25zKSA6IHsgc2NoZW1lOiAnbnVsbCcgfVxuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVDb21wb25lbnQocGFyc2UoYmFzZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBwYXJzZShyZWxhdGl2ZVVSSSwgc2NoZW1lbGVzc09wdGlvbnMpLCBzY2hlbWVsZXNzT3B0aW9ucywgdHJ1ZSlcbiAgc2NoZW1lbGVzc09wdGlvbnMuc2tpcEVzY2FwZSA9IHRydWVcbiAgcmV0dXJuIHNlcmlhbGl6ZShyZXNvbHZlZCwgc2NoZW1lbGVzc09wdGlvbnMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSBiYXNlXG4gKiBAcGFyYW0ge2ltcG9ydCAoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnR9IHJlbGF0aXZlXG4gKiBAcGFyYW0ge2ltcG9ydCgnLi90eXBlcy9pbmRleCcpLk9wdGlvbnN9IFtvcHRpb25zXVxuICogQHBhcmFtIHtib29sZWFufSBbc2tpcE5vcm1hbGl6YXRpb249ZmFsc2VdXG4gKiBAcmV0dXJucyB7aW1wb3J0ICgnLi90eXBlcy9pbmRleCcpLlVSSUNvbXBvbmVudH1cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZUNvbXBvbmVudCAoYmFzZSwgcmVsYXRpdmUsIG9wdGlvbnMsIHNraXBOb3JtYWxpemF0aW9uKSB7XG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSAqL1xuICBjb25zdCB0YXJnZXQgPSB7fVxuICBpZiAoIXNraXBOb3JtYWxpemF0aW9uKSB7XG4gICAgYmFzZSA9IHBhcnNlKHNlcmlhbGl6ZShiYXNlLCBvcHRpb25zKSwgb3B0aW9ucykgLy8gbm9ybWFsaXplIGJhc2UgY29tcG9uZW50XG4gICAgcmVsYXRpdmUgPSBwYXJzZShzZXJpYWxpemUocmVsYXRpdmUsIG9wdGlvbnMpLCBvcHRpb25zKSAvLyBub3JtYWxpemUgcmVsYXRpdmUgY29tcG9uZW50XG4gIH1cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge31cblxuICBpZiAoIW9wdGlvbnMudG9sZXJhbnQgJiYgcmVsYXRpdmUuc2NoZW1lKSB7XG4gICAgdGFyZ2V0LnNjaGVtZSA9IHJlbGF0aXZlLnNjaGVtZVxuICAgIC8vIHRhcmdldC5hdXRob3JpdHkgPSByZWxhdGl2ZS5hdXRob3JpdHk7XG4gICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICB0YXJnZXQuaG9zdCA9IHJlbGF0aXZlLmhvc3RcbiAgICB0YXJnZXQucG9ydCA9IHJlbGF0aXZlLnBvcnRcbiAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgdGFyZ2V0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnlcbiAgfSBlbHNlIHtcbiAgICBpZiAocmVsYXRpdmUudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCByZWxhdGl2ZS5ob3N0ICE9PSB1bmRlZmluZWQgfHwgcmVsYXRpdmUucG9ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyB0YXJnZXQuYXV0aG9yaXR5ID0gcmVsYXRpdmUuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gcmVsYXRpdmUudXNlcmluZm9cbiAgICAgIHRhcmdldC5ob3N0ID0gcmVsYXRpdmUuaG9zdFxuICAgICAgdGFyZ2V0LnBvcnQgPSByZWxhdGl2ZS5wb3J0XG4gICAgICB0YXJnZXQucGF0aCA9IHJlbW92ZURvdFNlZ21lbnRzKHJlbGF0aXZlLnBhdGggfHwgJycpXG4gICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoIXJlbGF0aXZlLnBhdGgpIHtcbiAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGhcbiAgICAgICAgaWYgKHJlbGF0aXZlLnF1ZXJ5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRhcmdldC5xdWVyeSA9IGJhc2UucXVlcnlcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHJlbGF0aXZlLnBhdGhbMF0gPT09ICcvJykge1xuICAgICAgICAgIHRhcmdldC5wYXRoID0gcmVtb3ZlRG90U2VnbWVudHMocmVsYXRpdmUucGF0aClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKGJhc2UudXNlcmluZm8gIT09IHVuZGVmaW5lZCB8fCBiYXNlLmhvc3QgIT09IHVuZGVmaW5lZCB8fCBiYXNlLnBvcnQgIT09IHVuZGVmaW5lZCkgJiYgIWJhc2UucGF0aCkge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSAnLycgKyByZWxhdGl2ZS5wYXRoXG4gICAgICAgICAgfSBlbHNlIGlmICghYmFzZS5wYXRoKSB7XG4gICAgICAgICAgICB0YXJnZXQucGF0aCA9IHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFyZ2V0LnBhdGggPSBiYXNlLnBhdGguc2xpY2UoMCwgYmFzZS5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKSArIHJlbGF0aXZlLnBhdGhcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFyZ2V0LnBhdGggPSByZW1vdmVEb3RTZWdtZW50cyh0YXJnZXQucGF0aClcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeVxuICAgICAgfVxuICAgICAgLy8gdGFyZ2V0LmF1dGhvcml0eSA9IGJhc2UuYXV0aG9yaXR5O1xuICAgICAgdGFyZ2V0LnVzZXJpbmZvID0gYmFzZS51c2VyaW5mb1xuICAgICAgdGFyZ2V0Lmhvc3QgPSBiYXNlLmhvc3RcbiAgICAgIHRhcmdldC5wb3J0ID0gYmFzZS5wb3J0XG4gICAgfVxuICAgIHRhcmdldC5zY2hlbWUgPSBiYXNlLnNjaGVtZVxuICB9XG5cbiAgdGFyZ2V0LmZyYWdtZW50ID0gcmVsYXRpdmUuZnJhZ21lbnRcblxuICByZXR1cm4gdGFyZ2V0XG59XG5cbi8qKlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gdXJpQVxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fHN0cmluZ30gdXJpQlxuICogQHBhcmFtIHtpbXBvcnQgKCcuL3R5cGVzL2luZGV4JykuT3B0aW9uc30gb3B0aW9uc1xuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGVxdWFsICh1cmlBLCB1cmlCLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgdXJpQSA9PT0gJ3N0cmluZycpIHtcbiAgICB1cmlBID0gdW5lc2NhcGUodXJpQSlcbiAgICB1cmlBID0gc2VyaWFsaXplKG5vcm1hbGl6ZUNvbXBvbmVudEVuY29kaW5nKHBhcnNlKHVyaUEsIG9wdGlvbnMpLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH0gZWxzZSBpZiAodHlwZW9mIHVyaUEgPT09ICdvYmplY3QnKSB7XG4gICAgdXJpQSA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyh1cmlBLCB0cnVlKSwgeyAuLi5vcHRpb25zLCBza2lwRXNjYXBlOiB0cnVlIH0pXG4gIH1cblxuICBpZiAodHlwZW9mIHVyaUIgPT09ICdzdHJpbmcnKSB7XG4gICAgdXJpQiA9IHVuZXNjYXBlKHVyaUIpXG4gICAgdXJpQiA9IHNlcmlhbGl6ZShub3JtYWxpemVDb21wb25lbnRFbmNvZGluZyhwYXJzZSh1cmlCLCBvcHRpb25zKSwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiB1cmlCID09PSAnb2JqZWN0Jykge1xuICAgIHVyaUIgPSBzZXJpYWxpemUobm9ybWFsaXplQ29tcG9uZW50RW5jb2RpbmcodXJpQiwgdHJ1ZSksIHsgLi4ub3B0aW9ucywgc2tpcEVzY2FwZTogdHJ1ZSB9KVxuICB9XG5cbiAgcmV0dXJuIHVyaUEudG9Mb3dlckNhc2UoKSA9PT0gdXJpQi50b0xvd2VyQ2FzZSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFkb25seTxpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5VUklDb21wb25lbnQ+fSBjbXB0c1xuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0c11cbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZSAoY21wdHMsIG9wdHMpIHtcbiAgY29uc3QgY29tcG9uZW50ID0ge1xuICAgIGhvc3Q6IGNtcHRzLmhvc3QsXG4gICAgc2NoZW1lOiBjbXB0cy5zY2hlbWUsXG4gICAgdXNlcmluZm86IGNtcHRzLnVzZXJpbmZvLFxuICAgIHBvcnQ6IGNtcHRzLnBvcnQsXG4gICAgcGF0aDogY21wdHMucGF0aCxcbiAgICBxdWVyeTogY21wdHMucXVlcnksXG4gICAgbmlkOiBjbXB0cy5uaWQsXG4gICAgbnNzOiBjbXB0cy5uc3MsXG4gICAgdXVpZDogY21wdHMudXVpZCxcbiAgICBmcmFnbWVudDogY21wdHMuZnJhZ21lbnQsXG4gICAgcmVmZXJlbmNlOiBjbXB0cy5yZWZlcmVuY2UsXG4gICAgcmVzb3VyY2VOYW1lOiBjbXB0cy5yZXNvdXJjZU5hbWUsXG4gICAgc2VjdXJlOiBjbXB0cy5zZWN1cmUsXG4gICAgZXJyb3I6ICcnXG4gIH1cbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIGNvbnN0IHVyaVRva2VucyA9IFtdXG5cbiAgLy8gZmluZCBzY2hlbWUgaGFuZGxlclxuICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcihvcHRpb25zLnNjaGVtZSB8fCBjb21wb25lbnQuc2NoZW1lKVxuXG4gIC8vIHBlcmZvcm0gc2NoZW1lIHNwZWNpZmljIHNlcmlhbGl6YXRpb25cbiAgaWYgKHNjaGVtZUhhbmRsZXIgJiYgc2NoZW1lSGFuZGxlci5zZXJpYWxpemUpIHNjaGVtZUhhbmRsZXIuc2VyaWFsaXplKGNvbXBvbmVudCwgb3B0aW9ucylcblxuICBpZiAoY29tcG9uZW50LnBhdGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICghb3B0aW9ucy5za2lwRXNjYXBlKSB7XG4gICAgICBjb21wb25lbnQucGF0aCA9IGVzY2FwZShjb21wb25lbnQucGF0aClcblxuICAgICAgaWYgKGNvbXBvbmVudC5zY2hlbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQucGF0aCA9IGNvbXBvbmVudC5wYXRoLnNwbGl0KCclM0EnKS5qb2luKCc6JylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50LnBhdGggPSB1bmVzY2FwZShjb21wb25lbnQucGF0aClcbiAgICB9XG4gIH1cblxuICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnICYmIGNvbXBvbmVudC5zY2hlbWUpIHtcbiAgICB1cmlUb2tlbnMucHVzaChjb21wb25lbnQuc2NoZW1lLCAnOicpXG4gIH1cblxuICBjb25zdCBhdXRob3JpdHkgPSByZWNvbXBvc2VBdXRob3JpdHkoY29tcG9uZW50KVxuICBpZiAoYXV0aG9yaXR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAob3B0aW9ucy5yZWZlcmVuY2UgIT09ICdzdWZmaXgnKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLy8nKVxuICAgIH1cblxuICAgIHVyaVRva2Vucy5wdXNoKGF1dGhvcml0eSlcblxuICAgIGlmIChjb21wb25lbnQucGF0aCAmJiBjb21wb25lbnQucGF0aFswXSAhPT0gJy8nKSB7XG4gICAgICB1cmlUb2tlbnMucHVzaCgnLycpXG4gICAgfVxuICB9XG4gIGlmIChjb21wb25lbnQucGF0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgbGV0IHMgPSBjb21wb25lbnQucGF0aFxuXG4gICAgaWYgKCFvcHRpb25zLmFic29sdXRlUGF0aCAmJiAoIXNjaGVtZUhhbmRsZXIgfHwgIXNjaGVtZUhhbmRsZXIuYWJzb2x1dGVQYXRoKSkge1xuICAgICAgcyA9IHJlbW92ZURvdFNlZ21lbnRzKHMpXG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgYXV0aG9yaXR5ID09PSB1bmRlZmluZWQgJiZcbiAgICAgIHNbMF0gPT09ICcvJyAmJlxuICAgICAgc1sxXSA9PT0gJy8nXG4gICAgKSB7XG4gICAgICAvLyBkb24ndCBhbGxvdyB0aGUgcGF0aCB0byBzdGFydCB3aXRoIFwiLy9cIlxuICAgICAgcyA9ICcvJTJGJyArIHMuc2xpY2UoMilcbiAgICB9XG5cbiAgICB1cmlUb2tlbnMucHVzaChzKVxuICB9XG5cbiAgaWYgKGNvbXBvbmVudC5xdWVyeSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdXJpVG9rZW5zLnB1c2goJz8nLCBjb21wb25lbnQucXVlcnkpXG4gIH1cblxuICBpZiAoY29tcG9uZW50LmZyYWdtZW50ICE9PSB1bmRlZmluZWQpIHtcbiAgICB1cmlUb2tlbnMucHVzaCgnIycsIGNvbXBvbmVudC5mcmFnbWVudClcbiAgfVxuICByZXR1cm4gdXJpVG9rZW5zLmpvaW4oJycpXG59XG5cbmNvbnN0IFVSSV9QQVJTRSA9IC9eKD86KFteIy86P10rKTopPyg/OlxcL1xcLygoPzooW14jLz9AXSopQCk/KFxcW1teIy8/XFxdXStcXF18W14jLzo/XSopKD86OihcXGQqKSk/KSk/KFteIz9dKikoPzpcXD8oW14jXSopKT8oPzojKCg/Oi58W1xcblxccl0pKikpPy91XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaVxuICogQHBhcmFtIHtpbXBvcnQoJy4vdHlwZXMvaW5kZXgnKS5PcHRpb25zfSBbb3B0c11cbiAqIEByZXR1cm5zXG4gKi9cbmZ1bmN0aW9uIHBhcnNlICh1cmksIG9wdHMpIHtcbiAgY29uc3Qgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdHMpXG4gIC8qKiBAdHlwZSB7aW1wb3J0KCcuL3R5cGVzL2luZGV4JykuVVJJQ29tcG9uZW50fSAqL1xuICBjb25zdCBwYXJzZWQgPSB7XG4gICAgc2NoZW1lOiB1bmRlZmluZWQsXG4gICAgdXNlcmluZm86IHVuZGVmaW5lZCxcbiAgICBob3N0OiAnJyxcbiAgICBwb3J0OiB1bmRlZmluZWQsXG4gICAgcGF0aDogJycsXG4gICAgcXVlcnk6IHVuZGVmaW5lZCxcbiAgICBmcmFnbWVudDogdW5kZWZpbmVkXG4gIH1cblxuICBsZXQgaXNJUCA9IGZhbHNlXG4gIGlmIChvcHRpb25zLnJlZmVyZW5jZSA9PT0gJ3N1ZmZpeCcpIHtcbiAgICBpZiAob3B0aW9ucy5zY2hlbWUpIHtcbiAgICAgIHVyaSA9IG9wdGlvbnMuc2NoZW1lICsgJzonICsgdXJpXG4gICAgfSBlbHNlIHtcbiAgICAgIHVyaSA9ICcvLycgKyB1cmlcbiAgICB9XG4gIH1cblxuICBjb25zdCBtYXRjaGVzID0gdXJpLm1hdGNoKFVSSV9QQVJTRSlcblxuICBpZiAobWF0Y2hlcykge1xuICAgIC8vIHN0b3JlIGVhY2ggY29tcG9uZW50XG4gICAgcGFyc2VkLnNjaGVtZSA9IG1hdGNoZXNbMV1cbiAgICBwYXJzZWQudXNlcmluZm8gPSBtYXRjaGVzWzNdXG4gICAgcGFyc2VkLmhvc3QgPSBtYXRjaGVzWzRdXG4gICAgcGFyc2VkLnBvcnQgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMClcbiAgICBwYXJzZWQucGF0aCA9IG1hdGNoZXNbNl0gfHwgJydcbiAgICBwYXJzZWQucXVlcnkgPSBtYXRjaGVzWzddXG4gICAgcGFyc2VkLmZyYWdtZW50ID0gbWF0Y2hlc1s4XVxuXG4gICAgLy8gZml4IHBvcnQgbnVtYmVyXG4gICAgaWYgKGlzTmFOKHBhcnNlZC5wb3J0KSkge1xuICAgICAgcGFyc2VkLnBvcnQgPSBtYXRjaGVzWzVdXG4gICAgfVxuICAgIGlmIChwYXJzZWQuaG9zdCkge1xuICAgICAgY29uc3QgaXB2NHJlc3VsdCA9IGlzSVB2NChwYXJzZWQuaG9zdClcbiAgICAgIGlmIChpcHY0cmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICBjb25zdCBpcHY2cmVzdWx0ID0gbm9ybWFsaXplSVB2NihwYXJzZWQuaG9zdClcbiAgICAgICAgcGFyc2VkLmhvc3QgPSBpcHY2cmVzdWx0Lmhvc3QudG9Mb3dlckNhc2UoKVxuICAgICAgICBpc0lQID0gaXB2NnJlc3VsdC5pc0lQVjZcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSVAgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXJzZWQuc2NoZW1lID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLnVzZXJpbmZvID09PSB1bmRlZmluZWQgJiYgcGFyc2VkLmhvc3QgPT09IHVuZGVmaW5lZCAmJiBwYXJzZWQucG9ydCA9PT0gdW5kZWZpbmVkICYmIHBhcnNlZC5xdWVyeSA9PT0gdW5kZWZpbmVkICYmICFwYXJzZWQucGF0aCkge1xuICAgICAgcGFyc2VkLnJlZmVyZW5jZSA9ICdzYW1lLWRvY3VtZW50J1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLnNjaGVtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJzZWQucmVmZXJlbmNlID0gJ3JlbGF0aXZlJ1xuICAgIH0gZWxzZSBpZiAocGFyc2VkLmZyYWdtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAnYWJzb2x1dGUnXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlZC5yZWZlcmVuY2UgPSAndXJpJ1xuICAgIH1cblxuICAgIC8vIGNoZWNrIGZvciByZWZlcmVuY2UgZXJyb3JzXG4gICAgaWYgKG9wdGlvbnMucmVmZXJlbmNlICYmIG9wdGlvbnMucmVmZXJlbmNlICE9PSAnc3VmZml4JyAmJiBvcHRpb25zLnJlZmVyZW5jZSAhPT0gcGFyc2VkLnJlZmVyZW5jZSkge1xuICAgICAgcGFyc2VkLmVycm9yID0gcGFyc2VkLmVycm9yIHx8ICdVUkkgaXMgbm90IGEgJyArIG9wdGlvbnMucmVmZXJlbmNlICsgJyByZWZlcmVuY2UuJ1xuICAgIH1cblxuICAgIC8vIGZpbmQgc2NoZW1lIGhhbmRsZXJcbiAgICBjb25zdCBzY2hlbWVIYW5kbGVyID0gZ2V0U2NoZW1lSGFuZGxlcihvcHRpb25zLnNjaGVtZSB8fCBwYXJzZWQuc2NoZW1lKVxuXG4gICAgLy8gY2hlY2sgaWYgc2NoZW1lIGNhbid0IGhhbmRsZSBJUklzXG4gICAgaWYgKCFvcHRpb25zLnVuaWNvZGVTdXBwb3J0ICYmICghc2NoZW1lSGFuZGxlciB8fCAhc2NoZW1lSGFuZGxlci51bmljb2RlU3VwcG9ydCkpIHtcbiAgICAgIC8vIGlmIGhvc3QgY29tcG9uZW50IGlzIGEgZG9tYWluIG5hbWVcbiAgICAgIGlmIChwYXJzZWQuaG9zdCAmJiAob3B0aW9ucy5kb21haW5Ib3N0IHx8IChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIuZG9tYWluSG9zdCkpICYmIGlzSVAgPT09IGZhbHNlICYmIG5vblNpbXBsZURvbWFpbihwYXJzZWQuaG9zdCkpIHtcbiAgICAgICAgLy8gY29udmVydCBVbmljb2RlIElETiAtPiBBU0NJSSBJRE5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IFVSTC5kb21haW5Ub0FTQ0lJKHBhcnNlZC5ob3N0LnRvTG93ZXJDYXNlKCkpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgXCJIb3N0J3MgZG9tYWluIG5hbWUgY2FuIG5vdCBiZSBjb252ZXJ0ZWQgdG8gQVNDSUk6IFwiICsgZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBjb252ZXJ0IElSSSAtPiBVUklcbiAgICB9XG5cbiAgICBpZiAoIXNjaGVtZUhhbmRsZXIgfHwgKHNjaGVtZUhhbmRsZXIgJiYgIXNjaGVtZUhhbmRsZXIuc2tpcE5vcm1hbGl6ZSkpIHtcbiAgICAgIGlmICh1cmkuaW5kZXhPZignJScpICE9PSAtMSkge1xuICAgICAgICBpZiAocGFyc2VkLnNjaGVtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFyc2VkLnNjaGVtZSA9IHVuZXNjYXBlKHBhcnNlZC5zY2hlbWUpXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnNlZC5ob3N0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwYXJzZWQuaG9zdCA9IHVuZXNjYXBlKHBhcnNlZC5ob3N0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGFyc2VkLnBhdGgpIHtcbiAgICAgICAgcGFyc2VkLnBhdGggPSBlc2NhcGUodW5lc2NhcGUocGFyc2VkLnBhdGgpKVxuICAgICAgfVxuICAgICAgaWYgKHBhcnNlZC5mcmFnbWVudCkge1xuICAgICAgICBwYXJzZWQuZnJhZ21lbnQgPSBlbmNvZGVVUkkoZGVjb2RlVVJJQ29tcG9uZW50KHBhcnNlZC5mcmFnbWVudCkpXG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcGVyZm9ybSBzY2hlbWUgc3BlY2lmaWMgcGFyc2luZ1xuICAgIGlmIChzY2hlbWVIYW5kbGVyICYmIHNjaGVtZUhhbmRsZXIucGFyc2UpIHtcbiAgICAgIHNjaGVtZUhhbmRsZXIucGFyc2UocGFyc2VkLCBvcHRpb25zKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwYXJzZWQuZXJyb3IgPSBwYXJzZWQuZXJyb3IgfHwgJ1VSSSBjYW4gbm90IGJlIHBhcnNlZC4nXG4gIH1cbiAgcmV0dXJuIHBhcnNlZFxufVxuXG5jb25zdCBmYXN0VXJpID0ge1xuICBTQ0hFTUVTLFxuICBub3JtYWxpemUsXG4gIHJlc29sdmUsXG4gIHJlc29sdmVDb21wb25lbnQsXG4gIGVxdWFsLFxuICBzZXJpYWxpemUsXG4gIHBhcnNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmFzdFVyaVxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGZhc3RVcmlcbm1vZHVsZS5leHBvcnRzLmZhc3RVcmkgPSBmYXN0VXJpXG4iLCAiaW1wb3J0ICogYXMgdXJpIGZyb20gXCJmYXN0LXVyaVwiXG5cbnR5cGUgVVJJID0gdHlwZW9mIHVyaSAmIHtjb2RlOiBzdHJpbmd9XG47KHVyaSBhcyBVUkkpLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvdXJpXCIpLmRlZmF1bHQnXG5cbmV4cG9ydCBkZWZhdWx0IHVyaSBhcyBVUklcbiIsICJleHBvcnQge1xuICBGb3JtYXQsXG4gIEZvcm1hdERlZmluaXRpb24sXG4gIEFzeW5jRm9ybWF0RGVmaW5pdGlvbixcbiAgS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgTWFjcm9LZXl3b3JkRGVmaW5pdGlvbixcbiAgRnVuY0tleXdvcmREZWZpbml0aW9uLFxuICBWb2NhYnVsYXJ5LFxuICBTY2hlbWEsXG4gIFNjaGVtYU9iamVjdCxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBBc3luY1NjaGVtYSxcbiAgQW55U2NoZW1hLFxuICBWYWxpZGF0ZUZ1bmN0aW9uLFxuICBBc3luY1ZhbGlkYXRlRnVuY3Rpb24sXG4gIEFueVZhbGlkYXRlRnVuY3Rpb24sXG4gIEVycm9yT2JqZWN0LFxuICBFcnJvck5vUGFyYW1zLFxufSBmcm9tIFwiLi90eXBlc1wiXG5cbmV4cG9ydCB7U2NoZW1hQ3h0LCBTY2hlbWFPYmpDeHR9IGZyb20gXCIuL2NvbXBpbGVcIlxuZXhwb3J0IGludGVyZmFjZSBQbHVnaW48T3B0cz4ge1xuICAoYWp2OiBBanYsIG9wdGlvbnM/OiBPcHRzKTogQWp2XG4gIFtwcm9wOiBzdHJpbmddOiBhbnlcbn1cblxuZXhwb3J0IHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi9jb21waWxlL3ZhbGlkYXRlXCJcbmV4cG9ydCB7RGVmaW5lZEVycm9yfSBmcm9tIFwiLi92b2NhYnVsYXJpZXMvZXJyb3JzXCJcbmV4cG9ydCB7SlNPTlR5cGV9IGZyb20gXCIuL2NvbXBpbGUvcnVsZXNcIlxuZXhwb3J0IHtKU09OU2NoZW1hVHlwZX0gZnJvbSBcIi4vdHlwZXMvanNvbi1zY2hlbWFcIlxuZXhwb3J0IHtKVERTY2hlbWFUeXBlLCBTb21lSlREU2NoZW1hVHlwZSwgSlRERGF0YVR5cGV9IGZyb20gXCIuL3R5cGVzL2p0ZC1zY2hlbWFcIlxuZXhwb3J0IHtfLCBzdHIsIHN0cmluZ2lmeSwgbmlsLCBOYW1lLCBDb2RlLCBDb2RlR2VuLCBDb2RlR2VuT3B0aW9uc30gZnJvbSBcIi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuaW1wb3J0IHR5cGUge1xuICBTY2hlbWEsXG4gIEFueVNjaGVtYSxcbiAgQW55U2NoZW1hT2JqZWN0LFxuICBTY2hlbWFPYmplY3QsXG4gIEFzeW5jU2NoZW1hLFxuICBWb2NhYnVsYXJ5LFxuICBLZXl3b3JkRGVmaW5pdGlvbixcbiAgQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgQW55VmFsaWRhdGVGdW5jdGlvbixcbiAgVmFsaWRhdGVGdW5jdGlvbixcbiAgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgRm9ybWF0LFxuICBBZGRlZEZvcm1hdCxcbiAgUmVnRXhwRW5naW5lLFxuICBVcmlSZXNvbHZlcixcbn0gZnJvbSBcIi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0pTT05TY2hlbWFUeXBlfSBmcm9tIFwiLi90eXBlcy9qc29uLXNjaGVtYVwiXG5pbXBvcnQgdHlwZSB7SlREU2NoZW1hVHlwZSwgU29tZUpURFNjaGVtYVR5cGUsIEpURERhdGFUeXBlfSBmcm9tIFwiLi90eXBlcy9qdGQtc2NoZW1hXCJcbmltcG9ydCBWYWxpZGF0aW9uRXJyb3IgZnJvbSBcIi4vcnVudGltZS92YWxpZGF0aW9uX2Vycm9yXCJcbmltcG9ydCBNaXNzaW5nUmVmRXJyb3IgZnJvbSBcIi4vY29tcGlsZS9yZWZfZXJyb3JcIlxuaW1wb3J0IHtnZXRSdWxlcywgVmFsaWRhdGlvblJ1bGVzLCBSdWxlLCBSdWxlR3JvdXAsIEpTT05UeXBlfSBmcm9tIFwiLi9jb21waWxlL3J1bGVzXCJcbmltcG9ydCB7U2NoZW1hRW52LCBjb21waWxlU2NoZW1hLCByZXNvbHZlU2NoZW1hfSBmcm9tIFwiLi9jb21waWxlXCJcbmltcG9ydCB7Q29kZSwgVmFsdWVTY29wZX0gZnJvbSBcIi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7bm9ybWFsaXplSWQsIGdldFNjaGVtYVJlZnN9IGZyb20gXCIuL2NvbXBpbGUvcmVzb2x2ZVwiXG5pbXBvcnQge2dldEpTT05UeXBlc30gZnJvbSBcIi4vY29tcGlsZS92YWxpZGF0ZS9kYXRhVHlwZVwiXG5pbXBvcnQge2VhY2hJdGVtfSBmcm9tIFwiLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0ICogYXMgJGRhdGFSZWZTY2hlbWEgZnJvbSBcIi4vcmVmcy9kYXRhLmpzb25cIlxuXG5pbXBvcnQgRGVmYXVsdFVyaVJlc29sdmVyIGZyb20gXCIuL3J1bnRpbWUvdXJpXCJcblxuY29uc3QgZGVmYXVsdFJlZ0V4cDogUmVnRXhwRW5naW5lID0gKHN0ciwgZmxhZ3MpID0+IG5ldyBSZWdFeHAoc3RyLCBmbGFncylcbmRlZmF1bHRSZWdFeHAuY29kZSA9IFwibmV3IFJlZ0V4cFwiXG5cbmNvbnN0IE1FVEFfSUdOT1JFX09QVElPTlM6IChrZXlvZiBPcHRpb25zKVtdID0gW1wicmVtb3ZlQWRkaXRpb25hbFwiLCBcInVzZURlZmF1bHRzXCIsIFwiY29lcmNlVHlwZXNcIl1cbmNvbnN0IEVYVF9TQ09QRV9OQU1FUyA9IG5ldyBTZXQoW1xuICBcInZhbGlkYXRlXCIsXG4gIFwic2VyaWFsaXplXCIsXG4gIFwicGFyc2VcIixcbiAgXCJ3cmFwcGVyXCIsXG4gIFwicm9vdFwiLFxuICBcInNjaGVtYVwiLFxuICBcImtleXdvcmRcIixcbiAgXCJwYXR0ZXJuXCIsXG4gIFwiZm9ybWF0c1wiLFxuICBcInZhbGlkYXRlJGRhdGFcIixcbiAgXCJmdW5jXCIsXG4gIFwib2JqXCIsXG4gIFwiRXJyb3JcIixcbl0pXG5cbmV4cG9ydCB0eXBlIE9wdGlvbnMgPSBDdXJyZW50T3B0aW9ucyAmIERlcHJlY2F0ZWRPcHRpb25zXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VycmVudE9wdGlvbnMge1xuICAvLyBzdHJpY3QgbW9kZSBvcHRpb25zIChORVcpXG4gIHN0cmljdD86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdFNjaGVtYT86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdE51bWJlcnM/OiBib29sZWFuIHwgXCJsb2dcIlxuICBzdHJpY3RUeXBlcz86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdFR1cGxlcz86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIHN0cmljdFJlcXVpcmVkPzogYm9vbGVhbiB8IFwibG9nXCJcbiAgYWxsb3dNYXRjaGluZ1Byb3BlcnRpZXM/OiBib29sZWFuIC8vIGRpc2FibGVzIGEgc3RyaWN0IG1vZGUgcmVzdHJpY3Rpb25cbiAgYWxsb3dVbmlvblR5cGVzPzogYm9vbGVhblxuICB2YWxpZGF0ZUZvcm1hdHM/OiBib29sZWFuXG4gIC8vIHZhbGlkYXRpb24gYW5kIHJlcG9ydGluZyBvcHRpb25zOlxuICAkZGF0YT86IGJvb2xlYW5cbiAgYWxsRXJyb3JzPzogYm9vbGVhblxuICB2ZXJib3NlPzogYm9vbGVhblxuICBkaXNjcmltaW5hdG9yPzogYm9vbGVhblxuICB1bmljb2RlUmVnRXhwPzogYm9vbGVhblxuICB0aW1lc3RhbXA/OiBcInN0cmluZ1wiIHwgXCJkYXRlXCIgLy8gSlREIG9ubHlcbiAgcGFyc2VEYXRlPzogYm9vbGVhbiAvLyBKVEQgb25seVxuICBhbGxvd0RhdGU/OiBib29sZWFuIC8vIEpURCBvbmx5XG4gICRjb21tZW50PzpcbiAgICB8IHRydWVcbiAgICB8ICgoY29tbWVudDogc3RyaW5nLCBzY2hlbWFQYXRoPzogc3RyaW5nLCByb290U2NoZW1hPzogQW55U2NoZW1hT2JqZWN0KSA9PiB1bmtub3duKVxuICBmb3JtYXRzPzoge1tOYW1lIGluIHN0cmluZ10/OiBGb3JtYXR9XG4gIGtleXdvcmRzPzogVm9jYWJ1bGFyeVxuICBzY2hlbWFzPzogQW55U2NoZW1hW10gfCB7W0tleSBpbiBzdHJpbmddPzogQW55U2NoZW1hfVxuICBsb2dnZXI/OiBMb2dnZXIgfCBmYWxzZVxuICBsb2FkU2NoZW1hPzogKHVyaTogc3RyaW5nKSA9PiBQcm9taXNlPEFueVNjaGVtYU9iamVjdD5cbiAgLy8gb3B0aW9ucyB0byBtb2RpZnkgdmFsaWRhdGVkIGRhdGE6XG4gIHJlbW92ZUFkZGl0aW9uYWw/OiBib29sZWFuIHwgXCJhbGxcIiB8IFwiZmFpbGluZ1wiXG4gIHVzZURlZmF1bHRzPzogYm9vbGVhbiB8IFwiZW1wdHlcIlxuICBjb2VyY2VUeXBlcz86IGJvb2xlYW4gfCBcImFycmF5XCJcbiAgLy8gYWR2YW5jZWQgb3B0aW9uczpcbiAgbmV4dD86IGJvb2xlYW4gLy8gTkVXXG4gIHVuZXZhbHVhdGVkPzogYm9vbGVhbiAvLyBORVdcbiAgZHluYW1pY1JlZj86IGJvb2xlYW4gLy8gTkVXXG4gIHNjaGVtYUlkPzogXCJpZFwiIHwgXCIkaWRcIlxuICBqdGQ/OiBib29sZWFuIC8vIE5FV1xuICBtZXRhPzogU2NoZW1hT2JqZWN0IHwgYm9vbGVhblxuICBkZWZhdWx0TWV0YT86IHN0cmluZyB8IEFueVNjaGVtYU9iamVjdFxuICB2YWxpZGF0ZVNjaGVtYT86IGJvb2xlYW4gfCBcImxvZ1wiXG4gIGFkZFVzZWRTY2hlbWE/OiBib29sZWFuXG4gIGlubGluZVJlZnM/OiBib29sZWFuIHwgbnVtYmVyXG4gIHBhc3NDb250ZXh0PzogYm9vbGVhblxuICBsb29wUmVxdWlyZWQ/OiBudW1iZXJcbiAgbG9vcEVudW0/OiBudW1iZXIgLy8gTkVXXG4gIG93blByb3BlcnRpZXM/OiBib29sZWFuXG4gIG11bHRpcGxlT2ZQcmVjaXNpb24/OiBudW1iZXJcbiAgaW50MzJyYW5nZT86IGJvb2xlYW4gLy8gSlREIG9ubHlcbiAgbWVzc2FnZXM/OiBib29sZWFuXG4gIGNvZGU/OiBDb2RlT3B0aW9ucyAvLyBORVdcbiAgdXJpUmVzb2x2ZXI/OiBVcmlSZXNvbHZlclxufVxuXG5leHBvcnQgaW50ZXJmYWNlIENvZGVPcHRpb25zIHtcbiAgZXM1PzogYm9vbGVhblxuICBlc20/OiBib29sZWFuXG4gIGxpbmVzPzogYm9vbGVhblxuICBvcHRpbWl6ZT86IGJvb2xlYW4gfCBudW1iZXJcbiAgZm9ybWF0cz86IENvZGUgLy8gY29kZSB0byByZXF1aXJlIChvciBjb25zdHJ1Y3QpIG1hcCBvZiBhdmFpbGFibGUgZm9ybWF0cyAtIGZvciBzdGFuZGFsb25lIGNvZGVcbiAgc291cmNlPzogYm9vbGVhblxuICBwcm9jZXNzPzogKGNvZGU6IHN0cmluZywgc2NoZW1hPzogU2NoZW1hRW52KSA9PiBzdHJpbmdcbiAgcmVnRXhwPzogUmVnRXhwRW5naW5lXG59XG5cbmludGVyZmFjZSBJbnN0YW5jZUNvZGVPcHRpb25zIGV4dGVuZHMgQ29kZU9wdGlvbnMge1xuICByZWdFeHA6IFJlZ0V4cEVuZ2luZVxuICBvcHRpbWl6ZTogbnVtYmVyXG59XG5cbmludGVyZmFjZSBEZXByZWNhdGVkT3B0aW9ucyB7XG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBpZ25vcmVLZXl3b3Jkc1dpdGhSZWY/OiBib29sZWFuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBqc1Byb3BlcnR5U3ludGF4PzogYm9vbGVhbiAvLyBhZGRlZCBpbnN0ZWFkIG9mIGpzb25Qb2ludGVyc1xuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgdW5pY29kZT86IGJvb2xlYW5cbn1cblxuaW50ZXJmYWNlIFJlbW92ZWRPcHRpb25zIHtcbiAgZm9ybWF0PzogYm9vbGVhblxuICBlcnJvckRhdGFQYXRoPzogXCJvYmplY3RcIiB8IFwicHJvcGVydHlcIlxuICBudWxsYWJsZT86IGJvb2xlYW4gLy8gXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHRcbiAganNvblBvaW50ZXJzPzogYm9vbGVhblxuICBleHRlbmRSZWZzPzogdHJ1ZSB8IFwiaWdub3JlXCIgfCBcImZhaWxcIlxuICBtaXNzaW5nUmVmcz86IHRydWUgfCBcImlnbm9yZVwiIHwgXCJmYWlsXCJcbiAgcHJvY2Vzc0NvZGU/OiAoY29kZTogc3RyaW5nLCBzY2hlbWE/OiBTY2hlbWFFbnYpID0+IHN0cmluZ1xuICBzb3VyY2VDb2RlPzogYm9vbGVhblxuICBzdHJpY3REZWZhdWx0cz86IGJvb2xlYW5cbiAgc3RyaWN0S2V5d29yZHM/OiBib29sZWFuXG4gIHVuaXF1ZUl0ZW1zPzogYm9vbGVhblxuICB1bmtub3duRm9ybWF0cz86IHRydWUgfCBzdHJpbmdbXSB8IFwiaWdub3JlXCJcbiAgY2FjaGU/OiBhbnlcbiAgc2VyaWFsaXplPzogKHNjaGVtYTogQW55U2NoZW1hKSA9PiB1bmtub3duXG4gIGFqdkVycm9ycz86IGJvb2xlYW5cbn1cblxudHlwZSBPcHRpb25zSW5mbzxUIGV4dGVuZHMgUmVtb3ZlZE9wdGlvbnMgfCBEZXByZWNhdGVkT3B0aW9ucz4gPSB7XG4gIFtLIGluIGtleW9mIFRdLT86IHN0cmluZyB8IHVuZGVmaW5lZFxufVxuXG5jb25zdCByZW1vdmVkT3B0aW9uczogT3B0aW9uc0luZm88UmVtb3ZlZE9wdGlvbnM+ID0ge1xuICBlcnJvckRhdGFQYXRoOiBcIlwiLFxuICBmb3JtYXQ6IFwiYHZhbGlkYXRlRm9ybWF0czogZmFsc2VgIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gIG51bGxhYmxlOiAnXCJudWxsYWJsZVwiIGtleXdvcmQgaXMgc3VwcG9ydGVkIGJ5IGRlZmF1bHQuJyxcbiAganNvblBvaW50ZXJzOiBcIkRlcHJlY2F0ZWQganNQcm9wZXJ0eVN5bnRheCBjYW4gYmUgdXNlZCBpbnN0ZWFkLlwiLFxuICBleHRlbmRSZWZzOiBcIkRlcHJlY2F0ZWQgaWdub3JlS2V5d29yZHNXaXRoUmVmIGNhbiBiZSB1c2VkIGluc3RlYWQuXCIsXG4gIG1pc3NpbmdSZWZzOiBcIlBhc3MgZW1wdHkgc2NoZW1hIHdpdGggJGlkIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWQgdG8gYWp2LmFkZFNjaGVtYS5cIixcbiAgcHJvY2Vzc0NvZGU6IFwiVXNlIG9wdGlvbiBgY29kZToge3Byb2Nlc3M6IChjb2RlLCBzY2hlbWFFbnY6IG9iamVjdCkgPT4gc3RyaW5nfWBcIixcbiAgc291cmNlQ29kZTogXCJVc2Ugb3B0aW9uIGBjb2RlOiB7c291cmNlOiB0cnVlfWBcIixcbiAgc3RyaWN0RGVmYXVsdHM6IFwiSXQgaXMgZGVmYXVsdCBub3csIHNlZSBvcHRpb24gYHN0cmljdGAuXCIsXG4gIHN0cmljdEtleXdvcmRzOiBcIkl0IGlzIGRlZmF1bHQgbm93LCBzZWUgb3B0aW9uIGBzdHJpY3RgLlwiLFxuICB1bmlxdWVJdGVtczogJ1widW5pcXVlSXRlbXNcIiBrZXl3b3JkIGlzIGFsd2F5cyB2YWxpZGF0ZWQuJyxcbiAgdW5rbm93bkZvcm1hdHM6IFwiRGlzYWJsZSBzdHJpY3QgbW9kZSBvciBwYXNzIGB0cnVlYCB0byBgYWp2LmFkZEZvcm1hdGAgKG9yIGBmb3JtYXRzYCBvcHRpb24pLlwiLFxuICBjYWNoZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gIHNlcmlhbGl6ZTogXCJNYXAgaXMgdXNlZCBhcyBjYWNoZSwgc2NoZW1hIG9iamVjdCBhcyBrZXkuXCIsXG4gIGFqdkVycm9yczogXCJJdCBpcyBkZWZhdWx0IG5vdy5cIixcbn1cblxuY29uc3QgZGVwcmVjYXRlZE9wdGlvbnM6IE9wdGlvbnNJbmZvPERlcHJlY2F0ZWRPcHRpb25zPiA9IHtcbiAgaWdub3JlS2V5d29yZHNXaXRoUmVmOiBcIlwiLFxuICBqc1Byb3BlcnR5U3ludGF4OiBcIlwiLFxuICB1bmljb2RlOiAnXCJtaW5MZW5ndGhcIi9cIm1heExlbmd0aFwiIGFjY291bnQgZm9yIHVuaWNvZGUgY2hhcmFjdGVycyBieSBkZWZhdWx0LicsXG59XG5cbnR5cGUgUmVxdWlyZWRJbnN0YW5jZU9wdGlvbnMgPSB7XG4gIFtLIGluXG4gICAgfCBcInN0cmljdFNjaGVtYVwiXG4gICAgfCBcInN0cmljdE51bWJlcnNcIlxuICAgIHwgXCJzdHJpY3RUeXBlc1wiXG4gICAgfCBcInN0cmljdFR1cGxlc1wiXG4gICAgfCBcInN0cmljdFJlcXVpcmVkXCJcbiAgICB8IFwiaW5saW5lUmVmc1wiXG4gICAgfCBcImxvb3BSZXF1aXJlZFwiXG4gICAgfCBcImxvb3BFbnVtXCJcbiAgICB8IFwibWV0YVwiXG4gICAgfCBcIm1lc3NhZ2VzXCJcbiAgICB8IFwic2NoZW1hSWRcIlxuICAgIHwgXCJhZGRVc2VkU2NoZW1hXCJcbiAgICB8IFwidmFsaWRhdGVTY2hlbWFcIlxuICAgIHwgXCJ2YWxpZGF0ZUZvcm1hdHNcIlxuICAgIHwgXCJpbnQzMnJhbmdlXCJcbiAgICB8IFwidW5pY29kZVJlZ0V4cFwiXG4gICAgfCBcInVyaVJlc29sdmVyXCJdOiBOb25OdWxsYWJsZTxPcHRpb25zW0tdPlxufSAmIHtjb2RlOiBJbnN0YW5jZUNvZGVPcHRpb25zfVxuXG5leHBvcnQgdHlwZSBJbnN0YW5jZU9wdGlvbnMgPSBPcHRpb25zICYgUmVxdWlyZWRJbnN0YW5jZU9wdGlvbnNcblxuY29uc3QgTUFYX0VYUFJFU1NJT04gPSAyMDBcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHJlcXVpcmVkT3B0aW9ucyhvOiBPcHRpb25zKTogUmVxdWlyZWRJbnN0YW5jZU9wdGlvbnMge1xuICBjb25zdCBzID0gby5zdHJpY3RcbiAgY29uc3QgX29wdHogPSBvLmNvZGU/Lm9wdGltaXplXG4gIGNvbnN0IG9wdGltaXplID0gX29wdHogPT09IHRydWUgfHwgX29wdHogPT09IHVuZGVmaW5lZCA/IDEgOiBfb3B0eiB8fCAwXG4gIGNvbnN0IHJlZ0V4cCA9IG8uY29kZT8ucmVnRXhwID8/IGRlZmF1bHRSZWdFeHBcbiAgY29uc3QgdXJpUmVzb2x2ZXIgPSBvLnVyaVJlc29sdmVyID8/IERlZmF1bHRVcmlSZXNvbHZlclxuICByZXR1cm4ge1xuICAgIHN0cmljdFNjaGVtYTogby5zdHJpY3RTY2hlbWEgPz8gcyA/PyB0cnVlLFxuICAgIHN0cmljdE51bWJlcnM6IG8uc3RyaWN0TnVtYmVycyA/PyBzID8/IHRydWUsXG4gICAgc3RyaWN0VHlwZXM6IG8uc3RyaWN0VHlwZXMgPz8gcyA/PyBcImxvZ1wiLFxuICAgIHN0cmljdFR1cGxlczogby5zdHJpY3RUdXBsZXMgPz8gcyA/PyBcImxvZ1wiLFxuICAgIHN0cmljdFJlcXVpcmVkOiBvLnN0cmljdFJlcXVpcmVkID8/IHMgPz8gZmFsc2UsXG4gICAgY29kZTogby5jb2RlID8gey4uLm8uY29kZSwgb3B0aW1pemUsIHJlZ0V4cH0gOiB7b3B0aW1pemUsIHJlZ0V4cH0sXG4gICAgbG9vcFJlcXVpcmVkOiBvLmxvb3BSZXF1aXJlZCA/PyBNQVhfRVhQUkVTU0lPTixcbiAgICBsb29wRW51bTogby5sb29wRW51bSA/PyBNQVhfRVhQUkVTU0lPTixcbiAgICBtZXRhOiBvLm1ldGEgPz8gdHJ1ZSxcbiAgICBtZXNzYWdlczogby5tZXNzYWdlcyA/PyB0cnVlLFxuICAgIGlubGluZVJlZnM6IG8uaW5saW5lUmVmcyA/PyB0cnVlLFxuICAgIHNjaGVtYUlkOiBvLnNjaGVtYUlkID8/IFwiJGlkXCIsXG4gICAgYWRkVXNlZFNjaGVtYTogby5hZGRVc2VkU2NoZW1hID8/IHRydWUsXG4gICAgdmFsaWRhdGVTY2hlbWE6IG8udmFsaWRhdGVTY2hlbWEgPz8gdHJ1ZSxcbiAgICB2YWxpZGF0ZUZvcm1hdHM6IG8udmFsaWRhdGVGb3JtYXRzID8/IHRydWUsXG4gICAgdW5pY29kZVJlZ0V4cDogby51bmljb2RlUmVnRXhwID8/IHRydWUsXG4gICAgaW50MzJyYW5nZTogby5pbnQzMnJhbmdlID8/IHRydWUsXG4gICAgdXJpUmVzb2x2ZXI6IHVyaVJlc29sdmVyLFxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTG9nZ2VyIHtcbiAgbG9nKC4uLmFyZ3M6IHVua25vd25bXSk6IHVua25vd25cbiAgd2FybiguLi5hcmdzOiB1bmtub3duW10pOiB1bmtub3duXG4gIGVycm9yKC4uLmFyZ3M6IHVua25vd25bXSk6IHVua25vd25cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQWp2IHtcbiAgb3B0czogSW5zdGFuY2VPcHRpb25zXG4gIGVycm9ycz86IEVycm9yT2JqZWN0W10gfCBudWxsIC8vIGVycm9ycyBmcm9tIHRoZSBsYXN0IHZhbGlkYXRpb25cbiAgbG9nZ2VyOiBMb2dnZXJcbiAgLy8gc2hhcmVkIGV4dGVybmFsIHNjb3BlIHZhbHVlcyBmb3IgY29tcGlsZWQgZnVuY3Rpb25zXG4gIHJlYWRvbmx5IHNjb3BlOiBWYWx1ZVNjb3BlXG4gIHJlYWRvbmx5IHNjaGVtYXM6IHtbS2V5IGluIHN0cmluZ10/OiBTY2hlbWFFbnZ9ID0ge31cbiAgcmVhZG9ubHkgcmVmczoge1tSZWYgaW4gc3RyaW5nXT86IFNjaGVtYUVudiB8IHN0cmluZ30gPSB7fVxuICByZWFkb25seSBmb3JtYXRzOiB7W05hbWUgaW4gc3RyaW5nXT86IEFkZGVkRm9ybWF0fSA9IHt9XG4gIHJlYWRvbmx5IFJVTEVTOiBWYWxpZGF0aW9uUnVsZXNcbiAgcmVhZG9ubHkgX2NvbXBpbGF0aW9uczogU2V0PFNjaGVtYUVudj4gPSBuZXcgU2V0KClcbiAgcHJpdmF0ZSByZWFkb25seSBfbG9hZGluZzoge1tSZWYgaW4gc3RyaW5nXT86IFByb21pc2U8QW55U2NoZW1hT2JqZWN0Pn0gPSB7fVxuICBwcml2YXRlIHJlYWRvbmx5IF9jYWNoZTogTWFwPEFueVNjaGVtYSwgU2NoZW1hRW52PiA9IG5ldyBNYXAoKVxuICBwcml2YXRlIHJlYWRvbmx5IF9tZXRhT3B0czogSW5zdGFuY2VPcHRpb25zXG5cbiAgc3RhdGljIFZhbGlkYXRpb25FcnJvciA9IFZhbGlkYXRpb25FcnJvclxuICBzdGF0aWMgTWlzc2luZ1JlZkVycm9yID0gTWlzc2luZ1JlZkVycm9yXG5cbiAgY29uc3RydWN0b3Iob3B0czogT3B0aW9ucyA9IHt9KSB7XG4gICAgb3B0cyA9IHRoaXMub3B0cyA9IHsuLi5vcHRzLCAuLi5yZXF1aXJlZE9wdGlvbnMob3B0cyl9XG4gICAgY29uc3Qge2VzNSwgbGluZXN9ID0gdGhpcy5vcHRzLmNvZGVcblxuICAgIHRoaXMuc2NvcGUgPSBuZXcgVmFsdWVTY29wZSh7c2NvcGU6IHt9LCBwcmVmaXhlczogRVhUX1NDT1BFX05BTUVTLCBlczUsIGxpbmVzfSlcbiAgICB0aGlzLmxvZ2dlciA9IGdldExvZ2dlcihvcHRzLmxvZ2dlcilcbiAgICBjb25zdCBmb3JtYXRPcHQgPSBvcHRzLnZhbGlkYXRlRm9ybWF0c1xuICAgIG9wdHMudmFsaWRhdGVGb3JtYXRzID0gZmFsc2VcblxuICAgIHRoaXMuUlVMRVMgPSBnZXRSdWxlcygpXG4gICAgY2hlY2tPcHRpb25zLmNhbGwodGhpcywgcmVtb3ZlZE9wdGlvbnMsIG9wdHMsIFwiTk9UIFNVUFBPUlRFRFwiKVxuICAgIGNoZWNrT3B0aW9ucy5jYWxsKHRoaXMsIGRlcHJlY2F0ZWRPcHRpb25zLCBvcHRzLCBcIkRFUFJFQ0FURURcIiwgXCJ3YXJuXCIpXG4gICAgdGhpcy5fbWV0YU9wdHMgPSBnZXRNZXRhU2NoZW1hT3B0aW9ucy5jYWxsKHRoaXMpXG5cbiAgICBpZiAob3B0cy5mb3JtYXRzKSBhZGRJbml0aWFsRm9ybWF0cy5jYWxsKHRoaXMpXG4gICAgdGhpcy5fYWRkVm9jYWJ1bGFyaWVzKClcbiAgICB0aGlzLl9hZGREZWZhdWx0TWV0YVNjaGVtYSgpXG4gICAgaWYgKG9wdHMua2V5d29yZHMpIGFkZEluaXRpYWxLZXl3b3Jkcy5jYWxsKHRoaXMsIG9wdHMua2V5d29yZHMpXG4gICAgaWYgKHR5cGVvZiBvcHRzLm1ldGEgPT0gXCJvYmplY3RcIikgdGhpcy5hZGRNZXRhU2NoZW1hKG9wdHMubWV0YSlcbiAgICBhZGRJbml0aWFsU2NoZW1hcy5jYWxsKHRoaXMpXG4gICAgb3B0cy52YWxpZGF0ZUZvcm1hdHMgPSBmb3JtYXRPcHRcbiAgfVxuXG4gIF9hZGRWb2NhYnVsYXJpZXMoKTogdm9pZCB7XG4gICAgdGhpcy5hZGRLZXl3b3JkKFwiJGFzeW5jXCIpXG4gIH1cblxuICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTogdm9pZCB7XG4gICAgY29uc3QgeyRkYXRhLCBtZXRhLCBzY2hlbWFJZH0gPSB0aGlzLm9wdHNcbiAgICBsZXQgX2RhdGFSZWZTY2hlbWE6IFNjaGVtYU9iamVjdCA9ICRkYXRhUmVmU2NoZW1hXG4gICAgaWYgKHNjaGVtYUlkID09PSBcImlkXCIpIHtcbiAgICAgIF9kYXRhUmVmU2NoZW1hID0gey4uLiRkYXRhUmVmU2NoZW1hfVxuICAgICAgX2RhdGFSZWZTY2hlbWEuaWQgPSBfZGF0YVJlZlNjaGVtYS4kaWRcbiAgICAgIGRlbGV0ZSBfZGF0YVJlZlNjaGVtYS4kaWRcbiAgICB9XG4gICAgaWYgKG1ldGEgJiYgJGRhdGEpIHRoaXMuYWRkTWV0YVNjaGVtYShfZGF0YVJlZlNjaGVtYSwgX2RhdGFSZWZTY2hlbWFbc2NoZW1hSWRdLCBmYWxzZSlcbiAgfVxuXG4gIGRlZmF1bHRNZXRhKCk6IHN0cmluZyB8IEFueVNjaGVtYU9iamVjdCB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3Qge21ldGEsIHNjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID0gdHlwZW9mIG1ldGEgPT0gXCJvYmplY3RcIiA/IG1ldGFbc2NoZW1hSWRdIHx8IG1ldGEgOiB1bmRlZmluZWQpXG4gIH1cblxuICAvLyBWYWxpZGF0ZSBkYXRhIHVzaW5nIHNjaGVtYVxuICAvLyBBbnlTY2hlbWEgd2lsbCBiZSBjb21waWxlZCBhbmQgY2FjaGVkIHVzaW5nIHNjaGVtYSBpdHNlbGYgYXMgYSBrZXkgZm9yIE1hcFxuICB2YWxpZGF0ZShzY2hlbWE6IFNjaGVtYSB8IHN0cmluZywgZGF0YTogdW5rbm93bik6IGJvb2xlYW5cbiAgdmFsaWRhdGUoc2NoZW1hS2V5UmVmOiBBbnlTY2hlbWEgfCBzdHJpbmcsIGRhdGE6IHVua25vd24pOiBib29sZWFuIHwgUHJvbWlzZTx1bmtub3duPlxuICB2YWxpZGF0ZTxUPihzY2hlbWE6IFNjaGVtYSB8IEpTT05TY2hlbWFUeXBlPFQ+IHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogZGF0YSBpcyBUXG4gIC8vIFNlcGFyYXRlZCBmb3IgdHlwZSBpbmZlcmVuY2UgdG8gd29ya1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3VuaWZpZWQtc2lnbmF0dXJlc1xuICB2YWxpZGF0ZTxUPihzY2hlbWE6IEpURFNjaGVtYVR5cGU8VD4sIGRhdGE6IHVua25vd24pOiBkYXRhIGlzIFRcbiAgLy8gVGhpcyBvdmVybG9hZCBpcyBvbmx5IGludGVuZGVkIGZvciB0eXBlc2NyaXB0IGluZmVyZW5jZSwgdGhlIGZpcnN0XG4gIC8vIGFyZ3VtZW50IHByZXZlbnRzIG1hbnVhbCB0eXBlIGFubm90YXRpb24gZnJvbSBtYXRjaGluZyB0aGlzIG92ZXJsb2FkXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgdmFsaWRhdGU8TiBleHRlbmRzIG5ldmVyLCBUIGV4dGVuZHMgU29tZUpURFNjaGVtYVR5cGU+KFxuICAgIHNjaGVtYTogVCxcbiAgICBkYXRhOiB1bmtub3duXG4gICk6IGRhdGEgaXMgSlRERGF0YVR5cGU8VD5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1yZWR1bmRhbnQtdHlwZS1jb25zdGl0dWVudHNcbiAgdmFsaWRhdGU8VD4oc2NoZW1hOiBBc3luY1NjaGVtYSwgZGF0YTogdW5rbm93biB8IFQpOiBQcm9taXNlPFQ+XG4gIHZhbGlkYXRlPFQ+KHNjaGVtYUtleVJlZjogQW55U2NoZW1hIHwgc3RyaW5nLCBkYXRhOiB1bmtub3duKTogZGF0YSBpcyBUIHwgUHJvbWlzZTxUPlxuICB2YWxpZGF0ZTxUPihcbiAgICBzY2hlbWFLZXlSZWY6IEFueVNjaGVtYSB8IHN0cmluZywgLy8ga2V5LCByZWYgb3Igc2NoZW1hIG9iamVjdFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tcmVkdW5kYW50LXR5cGUtY29uc3RpdHVlbnRzXG4gICAgZGF0YTogdW5rbm93biB8IFQgLy8gdG8gYmUgdmFsaWRhdGVkXG4gICk6IGJvb2xlYW4gfCBQcm9taXNlPFQ+IHtcbiAgICBsZXQgdjogQW55VmFsaWRhdGVGdW5jdGlvbiB8IHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2Ygc2NoZW1hS2V5UmVmID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHYgPSB0aGlzLmdldFNjaGVtYTxUPihzY2hlbWFLZXlSZWYpXG4gICAgICBpZiAoIXYpIHRocm93IG5ldyBFcnJvcihgbm8gc2NoZW1hIHdpdGgga2V5IG9yIHJlZiBcIiR7c2NoZW1hS2V5UmVmfVwiYClcbiAgICB9IGVsc2Uge1xuICAgICAgdiA9IHRoaXMuY29tcGlsZTxUPihzY2hlbWFLZXlSZWYpXG4gICAgfVxuXG4gICAgY29uc3QgdmFsaWQgPSB2KGRhdGEpXG4gICAgaWYgKCEoXCIkYXN5bmNcIiBpbiB2KSkgdGhpcy5lcnJvcnMgPSB2LmVycm9yc1xuICAgIHJldHVybiB2YWxpZFxuICB9XG5cbiAgLy8gQ3JlYXRlIHZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIHBhc3NlZCBzY2hlbWFcbiAgLy8gX21ldGE6IHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSB0byBjb21waWxlIG1ldGEgc2NoZW1hcyBvZiB1c2VyLWRlZmluZWQga2V5d29yZHMuXG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogU2NoZW1hIHwgSlNPTlNjaGVtYVR5cGU8VD4sIF9tZXRhPzogYm9vbGVhbik6IFZhbGlkYXRlRnVuY3Rpb248VD5cbiAgLy8gU2VwYXJhdGVkIGZvciB0eXBlIGluZmVyZW5jZSB0byB3b3JrXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogSlREU2NoZW1hVHlwZTxUPiwgX21ldGE/OiBib29sZWFuKTogVmFsaWRhdGVGdW5jdGlvbjxUPlxuICAvLyBUaGlzIG92ZXJsb2FkIGlzIG9ubHkgaW50ZW5kZWQgZm9yIHR5cGVzY3JpcHQgaW5mZXJlbmNlLCB0aGUgZmlyc3RcbiAgLy8gYXJndW1lbnQgcHJldmVudHMgbWFudWFsIHR5cGUgYW5ub3RhdGlvbiBmcm9tIG1hdGNoaW5nIHRoaXMgb3ZlcmxvYWRcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICBjb21waWxlPE4gZXh0ZW5kcyBuZXZlciwgVCBleHRlbmRzIFNvbWVKVERTY2hlbWFUeXBlPihcbiAgICBzY2hlbWE6IFQsXG4gICAgX21ldGE/OiBib29sZWFuXG4gICk6IFZhbGlkYXRlRnVuY3Rpb248SlRERGF0YVR5cGU8VD4+XG4gIGNvbXBpbGU8VCA9IHVua25vd24+KHNjaGVtYTogQXN5bmNTY2hlbWEsIF9tZXRhPzogYm9vbGVhbik6IEFzeW5jVmFsaWRhdGVGdW5jdGlvbjxUPlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEFueVNjaGVtYSwgX21ldGE/OiBib29sZWFuKTogQW55VmFsaWRhdGVGdW5jdGlvbjxUPlxuICBjb21waWxlPFQgPSB1bmtub3duPihzY2hlbWE6IEFueVNjaGVtYSwgX21ldGE/OiBib29sZWFuKTogQW55VmFsaWRhdGVGdW5jdGlvbjxUPiB7XG4gICAgY29uc3Qgc2NoID0gdGhpcy5fYWRkU2NoZW1hKHNjaGVtYSwgX21ldGEpXG4gICAgcmV0dXJuIChzY2gudmFsaWRhdGUgfHwgdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpKSBhcyBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+XG4gIH1cblxuICAvLyBDcmVhdGVzIHZhbGlkYXRpbmcgZnVuY3Rpb24gZm9yIHBhc3NlZCBzY2hlbWEgd2l0aCBhc3luY2hyb25vdXMgbG9hZGluZyBvZiBtaXNzaW5nIHNjaGVtYXMuXG4gIC8vIGBsb2FkU2NoZW1hYCBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHNjaGVtYSB1cmkgYW5kIHJldHVybnMgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdpdGggdGhlIHNjaGVtYS5cbiAgLy8gVE9ETyBhbGxvdyBwYXNzaW5nIHNjaGVtYSBVUklcbiAgLy8gbWV0YSAtIG9wdGlvbmFsIHRydWUgdG8gY29tcGlsZSBtZXRhLXNjaGVtYVxuICBjb21waWxlQXN5bmM8VCA9IHVua25vd24+KFxuICAgIHNjaGVtYTogU2NoZW1hT2JqZWN0IHwgSlNPTlNjaGVtYVR5cGU8VD4sXG4gICAgX21ldGE/OiBib29sZWFuXG4gICk6IFByb21pc2U8VmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgLy8gU2VwYXJhdGVkIGZvciB0eXBlIGluZmVyZW5jZSB0byB3b3JrXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvdW5pZmllZC1zaWduYXR1cmVzXG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oc2NoZW1hOiBKVERTY2hlbWFUeXBlPFQ+LCBfbWV0YT86IGJvb2xlYW4pOiBQcm9taXNlPFZhbGlkYXRlRnVuY3Rpb248VD4+XG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oc2NoZW1hOiBBc3luY1NjaGVtYSwgbWV0YT86IGJvb2xlYW4pOiBQcm9taXNlPEFzeW5jVmFsaWRhdGVGdW5jdGlvbjxUPj5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC91bmlmaWVkLXNpZ25hdHVyZXNcbiAgY29tcGlsZUFzeW5jPFQgPSB1bmtub3duPihcbiAgICBzY2hlbWE6IEFueVNjaGVtYU9iamVjdCxcbiAgICBtZXRhPzogYm9vbGVhblxuICApOiBQcm9taXNlPEFueVZhbGlkYXRlRnVuY3Rpb248VD4+XG4gIGNvbXBpbGVBc3luYzxUID0gdW5rbm93bj4oXG4gICAgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAgbWV0YT86IGJvb2xlYW5cbiAgKTogUHJvbWlzZTxBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+PiB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm9wdHMubG9hZFNjaGVtYSAhPSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIm9wdGlvbnMubG9hZFNjaGVtYSBzaG91bGQgYmUgYSBmdW5jdGlvblwiKVxuICAgIH1cbiAgICBjb25zdCB7bG9hZFNjaGVtYX0gPSB0aGlzLm9wdHNcbiAgICByZXR1cm4gcnVuQ29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoZW1hLCBtZXRhKVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gcnVuQ29tcGlsZUFzeW5jKFxuICAgICAgdGhpczogQWp2LFxuICAgICAgX3NjaGVtYTogQW55U2NoZW1hT2JqZWN0LFxuICAgICAgX21ldGE/OiBib29sZWFuXG4gICAgKTogUHJvbWlzZTxBbnlWYWxpZGF0ZUZ1bmN0aW9uPiB7XG4gICAgICBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSlcbiAgICAgIGNvbnN0IHNjaCA9IHRoaXMuX2FkZFNjaGVtYShfc2NoZW1hLCBfbWV0YSlcbiAgICAgIHJldHVybiBzY2gudmFsaWRhdGUgfHwgX2NvbXBpbGVBc3luYy5jYWxsKHRoaXMsIHNjaClcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWV0YVNjaGVtYSh0aGlzOiBBanYsICRyZWY/OiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgIGlmICgkcmVmICYmICF0aGlzLmdldFNjaGVtYSgkcmVmKSkge1xuICAgICAgICBhd2FpdCBydW5Db21waWxlQXN5bmMuY2FsbCh0aGlzLCB7JHJlZn0sIHRydWUpXG4gICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZnVuY3Rpb24gX2NvbXBpbGVBc3luYyh0aGlzOiBBanYsIHNjaDogU2NoZW1hRW52KTogUHJvbWlzZTxBbnlWYWxpZGF0ZUZ1bmN0aW9uPiB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcGlsZVNjaGVtYUVudihzY2gpXG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBNaXNzaW5nUmVmRXJyb3IpKSB0aHJvdyBlXG4gICAgICAgIGNoZWNrTG9hZGVkLmNhbGwodGhpcywgZSlcbiAgICAgICAgYXdhaXQgbG9hZE1pc3NpbmdTY2hlbWEuY2FsbCh0aGlzLCBlLm1pc3NpbmdTY2hlbWEpXG4gICAgICAgIHJldHVybiBfY29tcGlsZUFzeW5jLmNhbGwodGhpcywgc2NoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTG9hZGVkKHRoaXM6IEFqdiwge21pc3NpbmdTY2hlbWE6IHJlZiwgbWlzc2luZ1JlZn06IE1pc3NpbmdSZWZFcnJvcik6IHZvaWQge1xuICAgICAgaWYgKHRoaXMucmVmc1tyZWZdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQW55U2NoZW1hICR7cmVmfSBpcyBsb2FkZWQgYnV0ICR7bWlzc2luZ1JlZn0gY2Fubm90IGJlIHJlc29sdmVkYClcbiAgICAgIH1cbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBsb2FkTWlzc2luZ1NjaGVtYSh0aGlzOiBBanYsIHJlZjogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgICBjb25zdCBfc2NoZW1hID0gYXdhaXQgX2xvYWRTY2hlbWEuY2FsbCh0aGlzLCByZWYpXG4gICAgICBpZiAoIXRoaXMucmVmc1tyZWZdKSBhd2FpdCBsb2FkTWV0YVNjaGVtYS5jYWxsKHRoaXMsIF9zY2hlbWEuJHNjaGVtYSlcbiAgICAgIGlmICghdGhpcy5yZWZzW3JlZl0pIHRoaXMuYWRkU2NoZW1hKF9zY2hlbWEsIHJlZiwgbWV0YSlcbiAgICB9XG5cbiAgICBhc3luYyBmdW5jdGlvbiBfbG9hZFNjaGVtYSh0aGlzOiBBanYsIHJlZjogc3RyaW5nKTogUHJvbWlzZTxBbnlTY2hlbWFPYmplY3Q+IHtcbiAgICAgIGNvbnN0IHAgPSB0aGlzLl9sb2FkaW5nW3JlZl1cbiAgICAgIGlmIChwKSByZXR1cm4gcFxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGF3YWl0ICh0aGlzLl9sb2FkaW5nW3JlZl0gPSBsb2FkU2NoZW1hKHJlZikpXG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkZWxldGUgdGhpcy5fbG9hZGluZ1tyZWZdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkcyBzY2hlbWEgdG8gdGhlIGluc3RhbmNlXG4gIGFkZFNjaGVtYShcbiAgICBzY2hlbWE6IEFueVNjaGVtYSB8IEFueVNjaGVtYVtdLCAvLyBJZiBhcnJheSBpcyBwYXNzZWQsIGBrZXlgIHdpbGwgYmUgaWdub3JlZFxuICAgIGtleT86IHN0cmluZywgLy8gT3B0aW9uYWwgc2NoZW1hIGtleS4gQ2FuIGJlIHBhc3NlZCB0byBgdmFsaWRhdGVgIG1ldGhvZCBpbnN0ZWFkIG9mIHNjaGVtYSBvYmplY3Qgb3IgaWQvcmVmLiBPbmUgc2NoZW1hIHBlciBpbnN0YW5jZSBjYW4gaGF2ZSBlbXB0eSBgaWRgIGFuZCBga2V5YC5cbiAgICBfbWV0YT86IGJvb2xlYW4sIC8vIHRydWUgaWYgc2NoZW1hIGlzIGEgbWV0YS1zY2hlbWEuIFVzZWQgaW50ZXJuYWxseSwgYWRkTWV0YVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICAgIF92YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSAvLyBmYWxzZSB0byBza2lwIHNjaGVtYSB2YWxpZGF0aW9uLiBVc2VkIGludGVybmFsbHksIG9wdGlvbiB2YWxpZGF0ZVNjaGVtYSBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxuICApOiBBanYge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHtcbiAgICAgIGZvciAoY29uc3Qgc2NoIG9mIHNjaGVtYSkgdGhpcy5hZGRTY2hlbWEoc2NoLCB1bmRlZmluZWQsIF9tZXRhLCBfdmFsaWRhdGVTY2hlbWEpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBsZXQgaWQ6IHN0cmluZyB8IHVuZGVmaW5lZFxuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgICBpZCA9IHNjaGVtYVtzY2hlbWFJZF1cbiAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBpZCAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgc2NoZW1hICR7c2NoZW1hSWR9IG11c3QgYmUgc3RyaW5nYClcbiAgICAgIH1cbiAgICB9XG4gICAga2V5ID0gbm9ybWFsaXplSWQoa2V5IHx8IGlkKVxuICAgIHRoaXMuX2NoZWNrVW5pcXVlKGtleSlcbiAgICB0aGlzLnNjaGVtYXNba2V5XSA9IHRoaXMuX2FkZFNjaGVtYShzY2hlbWEsIF9tZXRhLCBrZXksIF92YWxpZGF0ZVNjaGVtYSwgdHJ1ZSlcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gQWRkIHNjaGVtYSB0aGF0IHdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBvdGhlciBzY2hlbWFzXG4gIC8vIG9wdGlvbnMgaW4gTUVUQV9JR05PUkVfT1BUSU9OUyBhcmUgYWx3YXkgc2V0IHRvIGZhbHNlXG4gIGFkZE1ldGFTY2hlbWEoXG4gICAgc2NoZW1hOiBBbnlTY2hlbWFPYmplY3QsXG4gICAga2V5Pzogc3RyaW5nLCAvLyBzY2hlbWEga2V5XG4gICAgX3ZhbGlkYXRlU2NoZW1hID0gdGhpcy5vcHRzLnZhbGlkYXRlU2NoZW1hIC8vIGZhbHNlIHRvIHNraXAgc2NoZW1hIHZhbGlkYXRpb24sIGNhbiBiZSB1c2VkIHRvIG92ZXJyaWRlIHZhbGlkYXRlU2NoZW1hIG9wdGlvbiBmb3IgbWV0YS1zY2hlbWFcbiAgKTogQWp2IHtcbiAgICB0aGlzLmFkZFNjaGVtYShzY2hlbWEsIGtleSwgdHJ1ZSwgX3ZhbGlkYXRlU2NoZW1hKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyAgVmFsaWRhdGUgc2NoZW1hIGFnYWluc3QgaXRzIG1ldGEtc2NoZW1hXG4gIHZhbGlkYXRlU2NoZW1hKHNjaGVtYTogQW55U2NoZW1hLCB0aHJvd09yTG9nRXJyb3I/OiBib29sZWFuKTogYm9vbGVhbiB8IFByb21pc2U8dW5rbm93bj4ge1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwiYm9vbGVhblwiKSByZXR1cm4gdHJ1ZVxuICAgIGxldCAkc2NoZW1hOiBzdHJpbmcgfCBBbnlTY2hlbWFPYmplY3QgfCB1bmRlZmluZWRcbiAgICAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWFcbiAgICBpZiAoJHNjaGVtYSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiAkc2NoZW1hICE9IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIiRzY2hlbWEgbXVzdCBiZSBhIHN0cmluZ1wiKVxuICAgIH1cbiAgICAkc2NoZW1hID0gJHNjaGVtYSB8fCB0aGlzLm9wdHMuZGVmYXVsdE1ldGEgfHwgdGhpcy5kZWZhdWx0TWV0YSgpXG4gICAgaWYgKCEkc2NoZW1hKSB7XG4gICAgICB0aGlzLmxvZ2dlci53YXJuKFwibWV0YS1zY2hlbWEgbm90IGF2YWlsYWJsZVwiKVxuICAgICAgdGhpcy5lcnJvcnMgPSBudWxsXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBjb25zdCB2YWxpZCA9IHRoaXMudmFsaWRhdGUoJHNjaGVtYSwgc2NoZW1hKVxuICAgIGlmICghdmFsaWQgJiYgdGhyb3dPckxvZ0Vycm9yKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gXCJzY2hlbWEgaXMgaW52YWxpZDogXCIgKyB0aGlzLmVycm9yc1RleHQoKVxuICAgICAgaWYgKHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSA9PT0gXCJsb2dcIikgdGhpcy5sb2dnZXIuZXJyb3IobWVzc2FnZSlcbiAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpXG4gICAgfVxuICAgIHJldHVybiB2YWxpZFxuICB9XG5cbiAgLy8gR2V0IGNvbXBpbGVkIHNjaGVtYSBieSBga2V5YCBvciBgcmVmYC5cbiAgLy8gKGBrZXlgIHRoYXQgd2FzIHBhc3NlZCB0byBgYWRkU2NoZW1hYCBvciBmdWxsIHNjaGVtYSByZWZlcmVuY2UgLSBgc2NoZW1hLiRpZGAgb3IgcmVzb2x2ZWQgaWQpXG4gIGdldFNjaGVtYTxUID0gdW5rbm93bj4oa2V5UmVmOiBzdHJpbmcpOiBBbnlWYWxpZGF0ZUZ1bmN0aW9uPFQ+IHwgdW5kZWZpbmVkIHtcbiAgICBsZXQgc2NoXG4gICAgd2hpbGUgKHR5cGVvZiAoc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywga2V5UmVmKSkgPT0gXCJzdHJpbmdcIikga2V5UmVmID0gc2NoXG4gICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB7c2NoZW1hSWR9ID0gdGhpcy5vcHRzXG4gICAgICBjb25zdCByb290ID0gbmV3IFNjaGVtYUVudih7c2NoZW1hOiB7fSwgc2NoZW1hSWR9KVxuICAgICAgc2NoID0gcmVzb2x2ZVNjaGVtYS5jYWxsKHRoaXMsIHJvb3QsIGtleVJlZilcbiAgICAgIGlmICghc2NoKSByZXR1cm5cbiAgICAgIHRoaXMucmVmc1trZXlSZWZdID0gc2NoXG4gICAgfVxuICAgIHJldHVybiAoc2NoLnZhbGlkYXRlIHx8IHRoaXMuX2NvbXBpbGVTY2hlbWFFbnYoc2NoKSkgYXMgQW55VmFsaWRhdGVGdW5jdGlvbjxUPiB8IHVuZGVmaW5lZFxuICB9XG5cbiAgLy8gUmVtb3ZlIGNhY2hlZCBzY2hlbWEocykuXG4gIC8vIElmIG5vIHBhcmFtZXRlciBpcyBwYXNzZWQgYWxsIHNjaGVtYXMgYnV0IG1ldGEtc2NoZW1hcyBhcmUgcmVtb3ZlZC5cbiAgLy8gSWYgUmVnRXhwIGlzIHBhc3NlZCBhbGwgc2NoZW1hcyB3aXRoIGtleS9pZCBtYXRjaGluZyBwYXR0ZXJuIGJ1dCBtZXRhLXNjaGVtYXMgYXJlIHJlbW92ZWQuXG4gIC8vIEV2ZW4gaWYgc2NoZW1hIGlzIHJlZmVyZW5jZWQgYnkgb3RoZXIgc2NoZW1hcyBpdCBzdGlsbCBjYW4gYmUgcmVtb3ZlZCBhcyBvdGhlciBzY2hlbWFzIGhhdmUgbG9jYWwgcmVmZXJlbmNlcy5cbiAgcmVtb3ZlU2NoZW1hKHNjaGVtYUtleVJlZj86IEFueVNjaGVtYSB8IHN0cmluZyB8IFJlZ0V4cCk6IEFqdiB7XG4gICAgaWYgKHNjaGVtYUtleVJlZiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMsIHNjaGVtYUtleVJlZilcbiAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzLCBzY2hlbWFLZXlSZWYpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cbiAgICBzd2l0Y2ggKHR5cGVvZiBzY2hlbWFLZXlSZWYpIHtcbiAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgdGhpcy5fcmVtb3ZlQWxsU2NoZW1hcyh0aGlzLnNjaGVtYXMpXG4gICAgICAgIHRoaXMuX3JlbW92ZUFsbFNjaGVtYXModGhpcy5yZWZzKVxuICAgICAgICB0aGlzLl9jYWNoZS5jbGVhcigpXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgICAgY29uc3Qgc2NoID0gZ2V0U2NoRW52LmNhbGwodGhpcywgc2NoZW1hS2V5UmVmKVxuICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcIm9iamVjdFwiKSB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSlcbiAgICAgICAgZGVsZXRlIHRoaXMuc2NoZW1hc1tzY2hlbWFLZXlSZWZdXG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbc2NoZW1hS2V5UmVmXVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfVxuICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gc2NoZW1hS2V5UmVmXG4gICAgICAgIHRoaXMuX2NhY2hlLmRlbGV0ZShjYWNoZUtleSlcbiAgICAgICAgbGV0IGlkID0gc2NoZW1hS2V5UmVmW3RoaXMub3B0cy5zY2hlbWFJZF1cbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgaWQgPSBub3JtYWxpemVJZChpZClcbiAgICAgICAgICBkZWxldGUgdGhpcy5zY2hlbWFzW2lkXVxuICAgICAgICAgIGRlbGV0ZSB0aGlzLnJlZnNbaWRdXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImFqdi5yZW1vdmVTY2hlbWE6IGludmFsaWQgcGFyYW1ldGVyXCIpXG4gICAgfVxuICB9XG5cbiAgLy8gYWRkIFwidm9jYWJ1bGFyeVwiIC0gYSBjb2xsZWN0aW9uIG9mIGtleXdvcmRzXG4gIGFkZFZvY2FidWxhcnkoZGVmaW5pdGlvbnM6IFZvY2FidWxhcnkpOiBBanYge1xuICAgIGZvciAoY29uc3QgZGVmIG9mIGRlZmluaXRpb25zKSB0aGlzLmFkZEtleXdvcmQoZGVmKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBhZGRLZXl3b3JkKFxuICAgIGt3ZE9yRGVmOiBzdHJpbmcgfCBLZXl3b3JkRGVmaW5pdGlvbixcbiAgICBkZWY/OiBLZXl3b3JkRGVmaW5pdGlvbiAvLyBkZXByZWNhdGVkXG4gICk6IEFqdiB7XG4gICAgbGV0IGtleXdvcmQ6IHN0cmluZyB8IHN0cmluZ1tdXG4gICAgaWYgKHR5cGVvZiBrd2RPckRlZiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBrZXl3b3JkID0ga3dkT3JEZWZcbiAgICAgIGlmICh0eXBlb2YgZGVmID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgdGhpcy5sb2dnZXIud2FybihcInRoZXNlIHBhcmFtZXRlcnMgYXJlIGRlcHJlY2F0ZWQsIHNlZSBkb2NzIGZvciBhZGRLZXl3b3JkXCIpXG4gICAgICAgIGRlZi5rZXl3b3JkID0ga2V5d29yZFxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGt3ZE9yRGVmID09IFwib2JqZWN0XCIgJiYgZGVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGRlZiA9IGt3ZE9yRGVmXG4gICAgICBrZXl3b3JkID0gZGVmLmtleXdvcmRcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGtleXdvcmQpICYmICFrZXl3b3JkLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRLZXl3b3Jkczoga2V5d29yZCBtdXN0IGJlIHN0cmluZyBvciBub24tZW1wdHkgYXJyYXlcIilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBhZGRLZXl3b3JkcyBwYXJhbWV0ZXJzXCIpXG4gICAgfVxuXG4gICAgY2hlY2tLZXl3b3JkLmNhbGwodGhpcywga2V5d29yZCwgZGVmKVxuICAgIGlmICghZGVmKSB7XG4gICAgICBlYWNoSXRlbShrZXl3b3JkLCAoa3dkKSA9PiBhZGRSdWxlLmNhbGwodGhpcywga3dkKSlcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuICAgIGtleXdvcmRNZXRhc2NoZW1hLmNhbGwodGhpcywgZGVmKVxuICAgIGNvbnN0IGRlZmluaXRpb246IEFkZGVkS2V5d29yZERlZmluaXRpb24gPSB7XG4gICAgICAuLi5kZWYsXG4gICAgICB0eXBlOiBnZXRKU09OVHlwZXMoZGVmLnR5cGUpLFxuICAgICAgc2NoZW1hVHlwZTogZ2V0SlNPTlR5cGVzKGRlZi5zY2hlbWFUeXBlKSxcbiAgICB9XG4gICAgZWFjaEl0ZW0oXG4gICAgICBrZXl3b3JkLFxuICAgICAgZGVmaW5pdGlvbi50eXBlLmxlbmd0aCA9PT0gMFxuICAgICAgICA/IChrKSA9PiBhZGRSdWxlLmNhbGwodGhpcywgaywgZGVmaW5pdGlvbilcbiAgICAgICAgOiAoaykgPT4gZGVmaW5pdGlvbi50eXBlLmZvckVhY2goKHQpID0+IGFkZFJ1bGUuY2FsbCh0aGlzLCBrLCBkZWZpbml0aW9uLCB0KSlcbiAgICApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIGdldEtleXdvcmQoa2V5d29yZDogc3RyaW5nKTogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbiB8IGJvb2xlYW4ge1xuICAgIGNvbnN0IHJ1bGUgPSB0aGlzLlJVTEVTLmFsbFtrZXl3b3JkXVxuICAgIHJldHVybiB0eXBlb2YgcnVsZSA9PSBcIm9iamVjdFwiID8gcnVsZS5kZWZpbml0aW9uIDogISFydWxlXG4gIH1cblxuICAvLyBSZW1vdmUga2V5d29yZFxuICByZW1vdmVLZXl3b3JkKGtleXdvcmQ6IHN0cmluZyk6IEFqdiB7XG4gICAgLy8gVE9ETyByZXR1cm4gdHlwZSBzaG91bGQgYmUgQWp2XG4gICAgY29uc3Qge1JVTEVTfSA9IHRoaXNcbiAgICBkZWxldGUgUlVMRVMua2V5d29yZHNba2V5d29yZF1cbiAgICBkZWxldGUgUlVMRVMuYWxsW2tleXdvcmRdXG4gICAgZm9yIChjb25zdCBncm91cCBvZiBSVUxFUy5ydWxlcykge1xuICAgICAgY29uc3QgaSA9IGdyb3VwLnJ1bGVzLmZpbmRJbmRleCgocnVsZSkgPT4gcnVsZS5rZXl3b3JkID09PSBrZXl3b3JkKVxuICAgICAgaWYgKGkgPj0gMCkgZ3JvdXAucnVsZXMuc3BsaWNlKGksIDEpXG4gICAgfVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBBZGQgZm9ybWF0XG4gIGFkZEZvcm1hdChuYW1lOiBzdHJpbmcsIGZvcm1hdDogRm9ybWF0KTogQWp2IHtcbiAgICBpZiAodHlwZW9mIGZvcm1hdCA9PSBcInN0cmluZ1wiKSBmb3JtYXQgPSBuZXcgUmVnRXhwKGZvcm1hdClcbiAgICB0aGlzLmZvcm1hdHNbbmFtZV0gPSBmb3JtYXRcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgZXJyb3JzVGV4dChcbiAgICBlcnJvcnM6IEVycm9yT2JqZWN0W10gfCBudWxsIHwgdW5kZWZpbmVkID0gdGhpcy5lcnJvcnMsIC8vIG9wdGlvbmFsIGFycmF5IG9mIHZhbGlkYXRpb24gZXJyb3JzXG4gICAge3NlcGFyYXRvciA9IFwiLCBcIiwgZGF0YVZhciA9IFwiZGF0YVwifTogRXJyb3JzVGV4dE9wdGlvbnMgPSB7fSAvLyBvcHRpb25hbCBvcHRpb25zIHdpdGggcHJvcGVydGllcyBgc2VwYXJhdG9yYCBhbmQgYGRhdGFWYXJgXG4gICk6IHN0cmluZyB7XG4gICAgaWYgKCFlcnJvcnMgfHwgZXJyb3JzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIFwiTm8gZXJyb3JzXCJcbiAgICByZXR1cm4gZXJyb3JzXG4gICAgICAubWFwKChlKSA9PiBgJHtkYXRhVmFyfSR7ZS5pbnN0YW5jZVBhdGh9ICR7ZS5tZXNzYWdlfWApXG4gICAgICAucmVkdWNlKCh0ZXh0LCBtc2cpID0+IHRleHQgKyBzZXBhcmF0b3IgKyBtc2cpXG4gIH1cblxuICAkZGF0YU1ldGFTY2hlbWEobWV0YVNjaGVtYTogQW55U2NoZW1hT2JqZWN0LCBrZXl3b3Jkc0pzb25Qb2ludGVyczogc3RyaW5nW10pOiBBbnlTY2hlbWFPYmplY3Qge1xuICAgIGNvbnN0IHJ1bGVzID0gdGhpcy5SVUxFUy5hbGxcbiAgICBtZXRhU2NoZW1hID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShtZXRhU2NoZW1hKSlcbiAgICBmb3IgKGNvbnN0IGpzb25Qb2ludGVyIG9mIGtleXdvcmRzSnNvblBvaW50ZXJzKSB7XG4gICAgICBjb25zdCBzZWdtZW50cyA9IGpzb25Qb2ludGVyLnNwbGl0KFwiL1wiKS5zbGljZSgxKSAvLyBmaXJzdCBzZWdtZW50IGlzIGFuIGVtcHR5IHN0cmluZ1xuICAgICAgbGV0IGtleXdvcmRzID0gbWV0YVNjaGVtYVxuICAgICAgZm9yIChjb25zdCBzZWcgb2Ygc2VnbWVudHMpIGtleXdvcmRzID0ga2V5d29yZHNbc2VnXSBhcyBBbnlTY2hlbWFPYmplY3RcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gcnVsZXMpIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2tleV1cbiAgICAgICAgaWYgKHR5cGVvZiBydWxlICE9IFwib2JqZWN0XCIpIGNvbnRpbnVlXG4gICAgICAgIGNvbnN0IHskZGF0YX0gPSBydWxlLmRlZmluaXRpb25cbiAgICAgICAgY29uc3Qgc2NoZW1hID0ga2V5d29yZHNba2V5XSBhcyBBbnlTY2hlbWFPYmplY3QgfCB1bmRlZmluZWRcbiAgICAgICAgaWYgKCRkYXRhICYmIHNjaGVtYSkga2V5d29yZHNba2V5XSA9IHNjaGVtYU9yRGF0YShzY2hlbWEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGFTY2hlbWFcbiAgfVxuXG4gIHByaXZhdGUgX3JlbW92ZUFsbFNjaGVtYXMoc2NoZW1hczoge1tSZWYgaW4gc3RyaW5nXT86IFNjaGVtYUVudiB8IHN0cmluZ30sIHJlZ2V4PzogUmVnRXhwKTogdm9pZCB7XG4gICAgZm9yIChjb25zdCBrZXlSZWYgaW4gc2NoZW1hcykge1xuICAgICAgY29uc3Qgc2NoID0gc2NoZW1hc1trZXlSZWZdXG4gICAgICBpZiAoIXJlZ2V4IHx8IHJlZ2V4LnRlc3Qoa2V5UmVmKSkge1xuICAgICAgICBpZiAodHlwZW9mIHNjaCA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgZGVsZXRlIHNjaGVtYXNba2V5UmVmXVxuICAgICAgICB9IGVsc2UgaWYgKHNjaCAmJiAhc2NoLm1ldGEpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZS5kZWxldGUoc2NoLnNjaGVtYSlcbiAgICAgICAgICBkZWxldGUgc2NoZW1hc1trZXlSZWZdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfYWRkU2NoZW1hKFxuICAgIHNjaGVtYTogQW55U2NoZW1hLFxuICAgIG1ldGE/OiBib29sZWFuLFxuICAgIGJhc2VJZD86IHN0cmluZyxcbiAgICB2YWxpZGF0ZVNjaGVtYSA9IHRoaXMub3B0cy52YWxpZGF0ZVNjaGVtYSxcbiAgICBhZGRTY2hlbWEgPSB0aGlzLm9wdHMuYWRkVXNlZFNjaGVtYVxuICApOiBTY2hlbWFFbnYge1xuICAgIGxldCBpZDogc3RyaW5nIHwgdW5kZWZpbmVkXG4gICAgY29uc3Qge3NjaGVtYUlkfSA9IHRoaXMub3B0c1xuICAgIGlmICh0eXBlb2Ygc2NoZW1hID09IFwib2JqZWN0XCIpIHtcbiAgICAgIGlkID0gc2NoZW1hW3NjaGVtYUlkXVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5vcHRzLmp0ZCkgdGhyb3cgbmV3IEVycm9yKFwic2NoZW1hIG11c3QgYmUgb2JqZWN0XCIpXG4gICAgICBlbHNlIGlmICh0eXBlb2Ygc2NoZW1hICE9IFwiYm9vbGVhblwiKSB0aHJvdyBuZXcgRXJyb3IoXCJzY2hlbWEgbXVzdCBiZSBvYmplY3Qgb3IgYm9vbGVhblwiKVxuICAgIH1cbiAgICBsZXQgc2NoID0gdGhpcy5fY2FjaGUuZ2V0KHNjaGVtYSlcbiAgICBpZiAoc2NoICE9PSB1bmRlZmluZWQpIHJldHVybiBzY2hcblxuICAgIGJhc2VJZCA9IG5vcm1hbGl6ZUlkKGlkIHx8IGJhc2VJZClcbiAgICBjb25zdCBsb2NhbFJlZnMgPSBnZXRTY2hlbWFSZWZzLmNhbGwodGhpcywgc2NoZW1hLCBiYXNlSWQpXG4gICAgc2NoID0gbmV3IFNjaGVtYUVudih7c2NoZW1hLCBzY2hlbWFJZCwgbWV0YSwgYmFzZUlkLCBsb2NhbFJlZnN9KVxuICAgIHRoaXMuX2NhY2hlLnNldChzY2guc2NoZW1hLCBzY2gpXG4gICAgaWYgKGFkZFNjaGVtYSAmJiAhYmFzZUlkLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAvLyBUT0RPIGF0bSBpdCBpcyBhbGxvd2VkIHRvIG92ZXJ3cml0ZSBzY2hlbWFzIHdpdGhvdXQgaWQgKGluc3RlYWQgb2Ygbm90IGFkZGluZyB0aGVtKVxuICAgICAgaWYgKGJhc2VJZCkgdGhpcy5fY2hlY2tVbmlxdWUoYmFzZUlkKVxuICAgICAgdGhpcy5yZWZzW2Jhc2VJZF0gPSBzY2hcbiAgICB9XG4gICAgaWYgKHZhbGlkYXRlU2NoZW1hKSB0aGlzLnZhbGlkYXRlU2NoZW1hKHNjaGVtYSwgdHJ1ZSlcbiAgICByZXR1cm4gc2NoXG4gIH1cblxuICBwcml2YXRlIF9jaGVja1VuaXF1ZShpZDogc3RyaW5nKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuc2NoZW1hc1tpZF0gfHwgdGhpcy5yZWZzW2lkXSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBzY2hlbWEgd2l0aCBrZXkgb3IgaWQgXCIke2lkfVwiIGFscmVhZHkgZXhpc3RzYClcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIF9jb21waWxlU2NoZW1hRW52KHNjaDogU2NoZW1hRW52KTogQW55VmFsaWRhdGVGdW5jdGlvbiB7XG4gICAgaWYgKHNjaC5tZXRhKSB0aGlzLl9jb21waWxlTWV0YVNjaGVtYShzY2gpXG4gICAgZWxzZSBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKVxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFzY2gudmFsaWRhdGUpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIHJldHVybiBzY2gudmFsaWRhdGVcbiAgfVxuXG4gIHByaXZhdGUgX2NvbXBpbGVNZXRhU2NoZW1hKHNjaDogU2NoZW1hRW52KTogdm9pZCB7XG4gICAgY29uc3QgY3VycmVudE9wdHMgPSB0aGlzLm9wdHNcbiAgICB0aGlzLm9wdHMgPSB0aGlzLl9tZXRhT3B0c1xuICAgIHRyeSB7XG4gICAgICBjb21waWxlU2NoZW1hLmNhbGwodGhpcywgc2NoKVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLm9wdHMgPSBjdXJyZW50T3B0c1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIEVycm9yc1RleHRPcHRpb25zIHtcbiAgc2VwYXJhdG9yPzogc3RyaW5nXG4gIGRhdGFWYXI/OiBzdHJpbmdcbn1cblxuZnVuY3Rpb24gY2hlY2tPcHRpb25zKFxuICB0aGlzOiBBanYsXG4gIGNoZWNrT3B0czogT3B0aW9uc0luZm88UmVtb3ZlZE9wdGlvbnMgfCBEZXByZWNhdGVkT3B0aW9ucz4sXG4gIG9wdGlvbnM6IE9wdGlvbnMgJiBSZW1vdmVkT3B0aW9ucyxcbiAgbXNnOiBzdHJpbmcsXG4gIGxvZzogXCJ3YXJuXCIgfCBcImVycm9yXCIgPSBcImVycm9yXCJcbik6IHZvaWQge1xuICBmb3IgKGNvbnN0IGtleSBpbiBjaGVja09wdHMpIHtcbiAgICBjb25zdCBvcHQgPSBrZXkgYXMga2V5b2YgdHlwZW9mIGNoZWNrT3B0c1xuICAgIGlmIChvcHQgaW4gb3B0aW9ucykgdGhpcy5sb2dnZXJbbG9nXShgJHttc2d9OiBvcHRpb24gJHtrZXl9LiAke2NoZWNrT3B0c1tvcHRdfWApXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0U2NoRW52KHRoaXM6IEFqdiwga2V5UmVmOiBzdHJpbmcpOiBTY2hlbWFFbnYgfCBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBrZXlSZWYgPSBub3JtYWxpemVJZChrZXlSZWYpIC8vIFRPRE8gdGVzdHMgZmFpbCB3aXRob3V0IHRoaXMgbGluZVxuICByZXR1cm4gdGhpcy5zY2hlbWFzW2tleVJlZl0gfHwgdGhpcy5yZWZzW2tleVJlZl1cbn1cblxuZnVuY3Rpb24gYWRkSW5pdGlhbFNjaGVtYXModGhpczogQWp2KTogdm9pZCB7XG4gIGNvbnN0IG9wdHNTY2hlbWFzID0gdGhpcy5vcHRzLnNjaGVtYXNcbiAgaWYgKCFvcHRzU2NoZW1hcykgcmV0dXJuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdHNTY2hlbWFzKSkgdGhpcy5hZGRTY2hlbWEob3B0c1NjaGVtYXMpXG4gIGVsc2UgZm9yIChjb25zdCBrZXkgaW4gb3B0c1NjaGVtYXMpIHRoaXMuYWRkU2NoZW1hKG9wdHNTY2hlbWFzW2tleV0gYXMgQW55U2NoZW1hLCBrZXkpXG59XG5cbmZ1bmN0aW9uIGFkZEluaXRpYWxGb3JtYXRzKHRoaXM6IEFqdik6IHZvaWQge1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5vcHRzLmZvcm1hdHMpIHtcbiAgICBjb25zdCBmb3JtYXQgPSB0aGlzLm9wdHMuZm9ybWF0c1tuYW1lXVxuICAgIGlmIChmb3JtYXQpIHRoaXMuYWRkRm9ybWF0KG5hbWUsIGZvcm1hdClcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRJbml0aWFsS2V5d29yZHMoXG4gIHRoaXM6IEFqdixcbiAgZGVmczogVm9jYWJ1bGFyeSB8IHtbSyBpbiBzdHJpbmddPzogS2V5d29yZERlZmluaXRpb259XG4pOiB2b2lkIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGVmcykpIHtcbiAgICB0aGlzLmFkZFZvY2FidWxhcnkoZGVmcylcbiAgICByZXR1cm5cbiAgfVxuICB0aGlzLmxvZ2dlci53YXJuKFwia2V5d29yZHMgb3B0aW9uIGFzIG1hcCBpcyBkZXByZWNhdGVkLCBwYXNzIGFycmF5XCIpXG4gIGZvciAoY29uc3Qga2V5d29yZCBpbiBkZWZzKSB7XG4gICAgY29uc3QgZGVmID0gZGVmc1trZXl3b3JkXSBhcyBLZXl3b3JkRGVmaW5pdGlvblxuICAgIGlmICghZGVmLmtleXdvcmQpIGRlZi5rZXl3b3JkID0ga2V5d29yZFxuICAgIHRoaXMuYWRkS2V5d29yZChkZWYpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TWV0YVNjaGVtYU9wdGlvbnModGhpczogQWp2KTogSW5zdGFuY2VPcHRpb25zIHtcbiAgY29uc3QgbWV0YU9wdHMgPSB7Li4udGhpcy5vcHRzfVxuICBmb3IgKGNvbnN0IG9wdCBvZiBNRVRBX0lHTk9SRV9PUFRJT05TKSBkZWxldGUgbWV0YU9wdHNbb3B0XVxuICByZXR1cm4gbWV0YU9wdHNcbn1cblxuY29uc3Qgbm9Mb2dzID0ge2xvZygpIHt9LCB3YXJuKCkge30sIGVycm9yKCkge319XG5cbmZ1bmN0aW9uIGdldExvZ2dlcihsb2dnZXI/OiBQYXJ0aWFsPExvZ2dlcj4gfCBmYWxzZSk6IExvZ2dlciB7XG4gIGlmIChsb2dnZXIgPT09IGZhbHNlKSByZXR1cm4gbm9Mb2dzXG4gIGlmIChsb2dnZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGNvbnNvbGVcbiAgaWYgKGxvZ2dlci5sb2cgJiYgbG9nZ2VyLndhcm4gJiYgbG9nZ2VyLmVycm9yKSByZXR1cm4gbG9nZ2VyIGFzIExvZ2dlclxuICB0aHJvdyBuZXcgRXJyb3IoXCJsb2dnZXIgbXVzdCBpbXBsZW1lbnQgbG9nLCB3YXJuIGFuZCBlcnJvciBtZXRob2RzXCIpXG59XG5cbmNvbnN0IEtFWVdPUkRfTkFNRSA9IC9eW2Etel8kXVthLXowLTlfJDotXSokL2lcblxuZnVuY3Rpb24gY2hlY2tLZXl3b3JkKHRoaXM6IEFqdiwga2V5d29yZDogc3RyaW5nIHwgc3RyaW5nW10sIGRlZj86IEtleXdvcmREZWZpbml0aW9uKTogdm9pZCB7XG4gIGNvbnN0IHtSVUxFU30gPSB0aGlzXG4gIGVhY2hJdGVtKGtleXdvcmQsIChrd2QpID0+IHtcbiAgICBpZiAoUlVMRVMua2V5d29yZHNba3dkXSkgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBpcyBhbHJlYWR5IGRlZmluZWRgKVxuICAgIGlmICghS0VZV09SRF9OQU1FLnRlc3Qoa3dkKSkgdGhyb3cgbmV3IEVycm9yKGBLZXl3b3JkICR7a3dkfSBoYXMgaW52YWxpZCBuYW1lYClcbiAgfSlcbiAgaWYgKCFkZWYpIHJldHVyblxuICBpZiAoZGVmLiRkYXRhICYmICEoXCJjb2RlXCIgaW4gZGVmIHx8IFwidmFsaWRhdGVcIiBpbiBkZWYpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCckZGF0YSBrZXl3b3JkIG11c3QgaGF2ZSBcImNvZGVcIiBvciBcInZhbGlkYXRlXCIgZnVuY3Rpb24nKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZFJ1bGUoXG4gIHRoaXM6IEFqdixcbiAga2V5d29yZDogc3RyaW5nLFxuICBkZWZpbml0aW9uPzogQWRkZWRLZXl3b3JkRGVmaW5pdGlvbixcbiAgZGF0YVR5cGU/OiBKU09OVHlwZVxuKTogdm9pZCB7XG4gIGNvbnN0IHBvc3QgPSBkZWZpbml0aW9uPy5wb3N0XG4gIGlmIChkYXRhVHlwZSAmJiBwb3N0KSB0aHJvdyBuZXcgRXJyb3IoJ2tleXdvcmQgd2l0aCBcInBvc3RcIiBmbGFnIGNhbm5vdCBoYXZlIFwidHlwZVwiJylcbiAgY29uc3Qge1JVTEVTfSA9IHRoaXNcbiAgbGV0IHJ1bGVHcm91cCA9IHBvc3QgPyBSVUxFUy5wb3N0IDogUlVMRVMucnVsZXMuZmluZCgoe3R5cGU6IHR9KSA9PiB0ID09PSBkYXRhVHlwZSlcbiAgaWYgKCFydWxlR3JvdXApIHtcbiAgICBydWxlR3JvdXAgPSB7dHlwZTogZGF0YVR5cGUsIHJ1bGVzOiBbXX1cbiAgICBSVUxFUy5ydWxlcy5wdXNoKHJ1bGVHcm91cClcbiAgfVxuICBSVUxFUy5rZXl3b3Jkc1trZXl3b3JkXSA9IHRydWVcbiAgaWYgKCFkZWZpbml0aW9uKSByZXR1cm5cblxuICBjb25zdCBydWxlOiBSdWxlID0ge1xuICAgIGtleXdvcmQsXG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgLi4uZGVmaW5pdGlvbixcbiAgICAgIHR5cGU6IGdldEpTT05UeXBlcyhkZWZpbml0aW9uLnR5cGUpLFxuICAgICAgc2NoZW1hVHlwZTogZ2V0SlNPTlR5cGVzKGRlZmluaXRpb24uc2NoZW1hVHlwZSksXG4gICAgfSxcbiAgfVxuICBpZiAoZGVmaW5pdGlvbi5iZWZvcmUpIGFkZEJlZm9yZVJ1bGUuY2FsbCh0aGlzLCBydWxlR3JvdXAsIHJ1bGUsIGRlZmluaXRpb24uYmVmb3JlKVxuICBlbHNlIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpXG4gIFJVTEVTLmFsbFtrZXl3b3JkXSA9IHJ1bGVcbiAgZGVmaW5pdGlvbi5pbXBsZW1lbnRzPy5mb3JFYWNoKChrd2QpID0+IHRoaXMuYWRkS2V5d29yZChrd2QpKVxufVxuXG5mdW5jdGlvbiBhZGRCZWZvcmVSdWxlKHRoaXM6IEFqdiwgcnVsZUdyb3VwOiBSdWxlR3JvdXAsIHJ1bGU6IFJ1bGUsIGJlZm9yZTogc3RyaW5nKTogdm9pZCB7XG4gIGNvbnN0IGkgPSBydWxlR3JvdXAucnVsZXMuZmluZEluZGV4KChfcnVsZSkgPT4gX3J1bGUua2V5d29yZCA9PT0gYmVmb3JlKVxuICBpZiAoaSA+PSAwKSB7XG4gICAgcnVsZUdyb3VwLnJ1bGVzLnNwbGljZShpLCAwLCBydWxlKVxuICB9IGVsc2Uge1xuICAgIHJ1bGVHcm91cC5ydWxlcy5wdXNoKHJ1bGUpXG4gICAgdGhpcy5sb2dnZXIud2FybihgcnVsZSAke2JlZm9yZX0gaXMgbm90IGRlZmluZWRgKVxuICB9XG59XG5cbmZ1bmN0aW9uIGtleXdvcmRNZXRhc2NoZW1hKHRoaXM6IEFqdiwgZGVmOiBLZXl3b3JkRGVmaW5pdGlvbik6IHZvaWQge1xuICBsZXQge21ldGFTY2hlbWF9ID0gZGVmXG4gIGlmIChtZXRhU2NoZW1hID09PSB1bmRlZmluZWQpIHJldHVyblxuICBpZiAoZGVmLiRkYXRhICYmIHRoaXMub3B0cy4kZGF0YSkgbWV0YVNjaGVtYSA9IHNjaGVtYU9yRGF0YShtZXRhU2NoZW1hKVxuICBkZWYudmFsaWRhdGVTY2hlbWEgPSB0aGlzLmNvbXBpbGUobWV0YVNjaGVtYSwgdHJ1ZSlcbn1cblxuY29uc3QgJGRhdGFSZWYgPSB7XG4gICRyZWY6IFwiaHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2Fqdi12YWxpZGF0b3IvYWp2L21hc3Rlci9saWIvcmVmcy9kYXRhLmpzb24jXCIsXG59XG5cbmZ1bmN0aW9uIHNjaGVtYU9yRGF0YShzY2hlbWE6IEFueVNjaGVtYSk6IEFueVNjaGVtYU9iamVjdCB7XG4gIHJldHVybiB7YW55T2Y6IFtzY2hlbWEsICRkYXRhUmVmXX1cbn1cbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpZFwiLFxuICBjb2RlKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignTk9UIFNVUFBPUlRFRDoga2V5d29yZCBcImlkXCIsIHVzZSBcIiRpZFwiIGZvciBzY2hlbWEgSUQnKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IE1pc3NpbmdSZWZFcnJvciBmcm9tIFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIlxuaW1wb3J0IHtjYWxsVmFsaWRhdGVDb2RlfSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge18sIG5pbCwgc3RyaW5naWZ5LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi8uLi9jb21waWxlL25hbWVzXCJcbmltcG9ydCB7U2NoZW1hRW52LCByZXNvbHZlUmVmfSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5pbXBvcnQge21lcmdlRXZhbHVhdGVkfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiJHJlZlwiLFxuICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCk6IHZvaWQge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYTogJHJlZiwgaXR9ID0gY3h0XG4gICAgY29uc3Qge2Jhc2VJZCwgc2NoZW1hRW52OiBlbnYsIHZhbGlkYXRlTmFtZSwgb3B0cywgc2VsZn0gPSBpdFxuICAgIGNvbnN0IHtyb290fSA9IGVudlxuICAgIGlmICgoJHJlZiA9PT0gXCIjXCIgfHwgJHJlZiA9PT0gXCIjL1wiKSAmJiBiYXNlSWQgPT09IHJvb3QuYmFzZUlkKSByZXR1cm4gY2FsbFJvb3RSZWYoKVxuICAgIGNvbnN0IHNjaE9yRW52ID0gcmVzb2x2ZVJlZi5jYWxsKHNlbGYsIHJvb3QsIGJhc2VJZCwgJHJlZilcbiAgICBpZiAoc2NoT3JFbnYgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IE1pc3NpbmdSZWZFcnJvcihpdC5vcHRzLnVyaVJlc29sdmVyLCBiYXNlSWQsICRyZWYpXG4gICAgaWYgKHNjaE9yRW52IGluc3RhbmNlb2YgU2NoZW1hRW52KSByZXR1cm4gY2FsbFZhbGlkYXRlKHNjaE9yRW52KVxuICAgIHJldHVybiBpbmxpbmVSZWZTY2hlbWEoc2NoT3JFbnYpXG5cbiAgICBmdW5jdGlvbiBjYWxsUm9vdFJlZigpOiB2b2lkIHtcbiAgICAgIGlmIChlbnYgPT09IHJvb3QpIHJldHVybiBjYWxsUmVmKGN4dCwgdmFsaWRhdGVOYW1lLCBlbnYsIGVudi4kYXN5bmMpXG4gICAgICBjb25zdCByb290TmFtZSA9IGdlbi5zY29wZVZhbHVlKFwicm9vdFwiLCB7cmVmOiByb290fSlcbiAgICAgIHJldHVybiBjYWxsUmVmKGN4dCwgX2Ake3Jvb3ROYW1lfS52YWxpZGF0ZWAsIHJvb3QsIHJvb3QuJGFzeW5jKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxWYWxpZGF0ZShzY2g6IFNjaGVtYUVudik6IHZvaWQge1xuICAgICAgY29uc3QgdiA9IGdldFZhbGlkYXRlKGN4dCwgc2NoKVxuICAgICAgY2FsbFJlZihjeHQsIHYsIHNjaCwgc2NoLiRhc3luYylcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbmxpbmVSZWZTY2hlbWEoc2NoOiBBbnlTY2hlbWEpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHNjaE5hbWUgPSBnZW4uc2NvcGVWYWx1ZShcbiAgICAgICAgXCJzY2hlbWFcIixcbiAgICAgICAgb3B0cy5jb2RlLnNvdXJjZSA9PT0gdHJ1ZSA/IHtyZWY6IHNjaCwgY29kZTogc3RyaW5naWZ5KHNjaCl9IDoge3JlZjogc2NofVxuICAgICAgKVxuICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKFxuICAgICAgICB7XG4gICAgICAgICAgc2NoZW1hOiBzY2gsXG4gICAgICAgICAgZGF0YVR5cGVzOiBbXSxcbiAgICAgICAgICBzY2hlbWFQYXRoOiBuaWwsXG4gICAgICAgICAgdG9wU2NoZW1hUmVmOiBzY2hOYW1lLFxuICAgICAgICAgIGVyclNjaGVtYVBhdGg6ICRyZWYsXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0KVxuICAgICAgY3h0Lm9rKHZhbGlkKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZhbGlkYXRlKGN4dDogS2V5d29yZEN4dCwgc2NoOiBTY2hlbWFFbnYpOiBDb2RlIHtcbiAgY29uc3Qge2dlbn0gPSBjeHRcbiAgcmV0dXJuIHNjaC52YWxpZGF0ZVxuICAgID8gZ2VuLnNjb3BlVmFsdWUoXCJ2YWxpZGF0ZVwiLCB7cmVmOiBzY2gudmFsaWRhdGV9KVxuICAgIDogX2Ake2dlbi5zY29wZVZhbHVlKFwid3JhcHBlclwiLCB7cmVmOiBzY2h9KX0udmFsaWRhdGVgXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxsUmVmKGN4dDogS2V5d29yZEN4dCwgdjogQ29kZSwgc2NoPzogU2NoZW1hRW52LCAkYXN5bmM/OiBib29sZWFuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGl0fSA9IGN4dFxuICBjb25zdCB7YWxsRXJyb3JzLCBzY2hlbWFFbnY6IGVudiwgb3B0c30gPSBpdFxuICBjb25zdCBwYXNzQ3h0ID0gb3B0cy5wYXNzQ29udGV4dCA/IE4udGhpcyA6IG5pbFxuICBpZiAoJGFzeW5jKSBjYWxsQXN5bmNSZWYoKVxuICBlbHNlIGNhbGxTeW5jUmVmKClcblxuICBmdW5jdGlvbiBjYWxsQXN5bmNSZWYoKTogdm9pZCB7XG4gICAgaWYgKCFlbnYuJGFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBzY2hlbWEgcmVmZXJlbmNlZCBieSBzeW5jIHNjaGVtYVwiKVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpXG4gICAgZ2VuLnRyeShcbiAgICAgICgpID0+IHtcbiAgICAgICAgZ2VuLmNvZGUoX2Bhd2FpdCAke2NhbGxWYWxpZGF0ZUNvZGUoY3h0LCB2LCBwYXNzQ3h0KX1gKVxuICAgICAgICBhZGRFdmFsdWF0ZWRGcm9tKHYpIC8vIFRPRE8gd2lsbCBub3Qgd29yayB3aXRoIGFzeW5jLCBpdCBoYXMgdG8gYmUgcmV0dXJuZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIChlKSA9PiB7XG4gICAgICAgIGdlbi5pZihfYCEoJHtlfSBpbnN0YW5jZW9mICR7aXQuVmFsaWRhdGlvbkVycm9yIGFzIE5hbWV9KWAsICgpID0+IGdlbi50aHJvdyhlKSlcbiAgICAgICAgYWRkRXJyb3JzRnJvbShlKVxuICAgICAgICBpZiAoIWFsbEVycm9ycykgZ2VuLmFzc2lnbih2YWxpZCwgZmFsc2UpXG4gICAgICB9XG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxTeW5jUmVmKCk6IHZvaWQge1xuICAgIGN4dC5yZXN1bHQoXG4gICAgICBjYWxsVmFsaWRhdGVDb2RlKGN4dCwgdiwgcGFzc0N4dCksXG4gICAgICAoKSA9PiBhZGRFdmFsdWF0ZWRGcm9tKHYpLFxuICAgICAgKCkgPT4gYWRkRXJyb3JzRnJvbSh2KVxuICAgIClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEVycm9yc0Zyb20oc291cmNlOiBDb2RlKTogdm9pZCB7XG4gICAgY29uc3QgZXJycyA9IF9gJHtzb3VyY2V9LmVycm9yc2BcbiAgICBnZW4uYXNzaWduKE4udkVycm9ycywgX2Ake04udkVycm9yc30gPT09IG51bGwgPyAke2VycnN9IDogJHtOLnZFcnJvcnN9LmNvbmNhdCgke2VycnN9KWApIC8vIFRPRE8gdGFnZ2VkXG4gICAgZ2VuLmFzc2lnbihOLmVycm9ycywgX2Ake04udkVycm9yc30ubGVuZ3RoYClcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkZEV2YWx1YXRlZEZyb20oc291cmNlOiBDb2RlKTogdm9pZCB7XG4gICAgaWYgKCFpdC5vcHRzLnVuZXZhbHVhdGVkKSByZXR1cm5cbiAgICBjb25zdCBzY2hFdmFsdWF0ZWQgPSBzY2g/LnZhbGlkYXRlPy5ldmFsdWF0ZWRcbiAgICAvLyBUT0RPIHJlZmFjdG9yXG4gICAgaWYgKGl0LnByb3BzICE9PSB0cnVlKSB7XG4gICAgICBpZiAoc2NoRXZhbHVhdGVkICYmICFzY2hFdmFsdWF0ZWQuZHluYW1pY1Byb3BzKSB7XG4gICAgICAgIGlmIChzY2hFdmFsdWF0ZWQucHJvcHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCBzY2hFdmFsdWF0ZWQucHJvcHMsIGl0LnByb3BzKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcm9wcyA9IGdlbi52YXIoXCJwcm9wc1wiLCBfYCR7c291cmNlfS5ldmFsdWF0ZWQucHJvcHNgKVxuICAgICAgICBpdC5wcm9wcyA9IG1lcmdlRXZhbHVhdGVkLnByb3BzKGdlbiwgcHJvcHMsIGl0LnByb3BzLCBOYW1lKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXQuaXRlbXMgIT09IHRydWUpIHtcbiAgICAgIGlmIChzY2hFdmFsdWF0ZWQgJiYgIXNjaEV2YWx1YXRlZC5keW5hbWljSXRlbXMpIHtcbiAgICAgICAgaWYgKHNjaEV2YWx1YXRlZC5pdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEV2YWx1YXRlZC5pdGVtcywgaXQuaXRlbXMpXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gZ2VuLnZhcihcIml0ZW1zXCIsIF9gJHtzb3VyY2V9LmV2YWx1YXRlZC5pdGVtc2ApXG4gICAgICAgIGl0Lml0ZW1zID0gbWVyZ2VFdmFsdWF0ZWQuaXRlbXMoZ2VuLCBpdGVtcywgaXQuaXRlbXMsIE5hbWUpXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IGlkS2V5d29yZCBmcm9tIFwiLi9pZFwiXG5pbXBvcnQgcmVmS2V5d29yZCBmcm9tIFwiLi9yZWZcIlxuXG5jb25zdCBjb3JlOiBWb2NhYnVsYXJ5ID0gW1xuICBcIiRzY2hlbWFcIixcbiAgXCIkaWRcIixcbiAgXCIkZGVmc1wiLFxuICBcIiR2b2NhYnVsYXJ5XCIsXG4gIHtrZXl3b3JkOiBcIiRjb21tZW50XCJ9LFxuICBcImRlZmluaXRpb25zXCIsXG4gIGlkS2V5d29yZCxcbiAgcmVmS2V5d29yZCxcbl1cblxuZXhwb3J0IGRlZmF1bHQgY29yZVxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBvcGVyYXRvcnMsIENvZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5jb25zdCBvcHMgPSBvcGVyYXRvcnNcblxudHlwZSBLd2QgPSBcIm1heGltdW1cIiB8IFwibWluaW11bVwiIHwgXCJleGNsdXNpdmVNYXhpbXVtXCIgfCBcImV4Y2x1c2l2ZU1pbmltdW1cIlxuXG50eXBlIENvbXBhcmlzb24gPSBcIjw9XCIgfCBcIj49XCIgfCBcIjxcIiB8IFwiPlwiXG5cbmNvbnN0IEtXRHM6IHtbSyBpbiBLd2RdOiB7b2tTdHI6IENvbXBhcmlzb247IG9rOiBDb2RlOyBmYWlsOiBDb2RlfX0gPSB7XG4gIG1heGltdW06IHtva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUfSxcbiAgbWluaW11bToge29rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFR9LFxuICBleGNsdXNpdmVNYXhpbXVtOiB7b2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFfSxcbiAgZXhjbHVzaXZlTWluaW11bToge29rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURX0sXG59XG5cbmV4cG9ydCB0eXBlIExpbWl0TnVtYmVyRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgS3dkLFxuICB7bGltaXQ6IG51bWJlcjsgY29tcGFyaXNvbjogQ29tcGFyaXNvbn0sXG4gIG51bWJlciB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkgPT4gc3RyYG11c3QgYmUgJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gIHBhcmFtczogKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkgPT5cbiAgICBfYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZCBhcyBLd2RdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IE9iamVjdC5rZXlzKEtXRHMpLFxuICB0eXBlOiBcIm51bWJlclwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2tleXdvcmQsIGRhdGEsIHNjaGVtYUNvZGV9ID0gY3h0XG4gICAgY3h0LmZhaWwkZGF0YShfYCR7ZGF0YX0gJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5mYWlsfSAke3NjaGVtYUNvZGV9IHx8IGlzTmFOKCR7ZGF0YX0pYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5leHBvcnQgdHlwZSBNdWx0aXBsZU9mRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJtdWx0aXBsZU9mXCIsXG4gIHttdWx0aXBsZU9mOiBudW1iZXJ9LFxuICBudW1iZXIgfCB7JGRhdGE6IHN0cmluZ31cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IGJlIG11bHRpcGxlIG9mICR7c2NoZW1hQ29kZX1gLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge211bHRpcGxlT2Y6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwibXVsdGlwbGVPZlwiLFxuICB0eXBlOiBcIm51bWJlclwiLFxuICBzY2hlbWFUeXBlOiBcIm51bWJlclwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgc2NoZW1hQ29kZSwgaXR9ID0gY3h0XG4gICAgLy8gY29uc3QgYmR0ID0gYmFkJERhdGFUeXBlKHNjaGVtYUNvZGUsIDxzdHJpbmc+ZGVmLnNjaGVtYVR5cGUsICRkYXRhKVxuICAgIGNvbnN0IHByZWMgPSBpdC5vcHRzLm11bHRpcGxlT2ZQcmVjaXNpb25cbiAgICBjb25zdCByZXMgPSBnZW4ubGV0KFwicmVzXCIpXG4gICAgY29uc3QgaW52YWxpZCA9IHByZWNcbiAgICAgID8gX2BNYXRoLmFicyhNYXRoLnJvdW5kKCR7cmVzfSkgLSAke3Jlc30pID4gMWUtJHtwcmVjfWBcbiAgICAgIDogX2Ake3Jlc30gIT09IHBhcnNlSW50KCR7cmVzfSlgXG4gICAgY3h0LmZhaWwkZGF0YShfYCgke3NjaGVtYUNvZGV9ID09PSAwIHx8ICgke3Jlc30gPSAke2RhdGF9LyR7c2NoZW1hQ29kZX0sICR7aW52YWxpZH0pKWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgIi8vIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMgLSBwdW55Y29kZS51Y3MyLmRlY29kZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdWNzMmxlbmd0aChzdHI6IHN0cmluZyk6IG51bWJlciB7XG4gIGNvbnN0IGxlbiA9IHN0ci5sZW5ndGhcbiAgbGV0IGxlbmd0aCA9IDBcbiAgbGV0IHBvcyA9IDBcbiAgbGV0IHZhbHVlOiBudW1iZXJcbiAgd2hpbGUgKHBvcyA8IGxlbikge1xuICAgIGxlbmd0aCsrXG4gICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MrKylcbiAgICBpZiAodmFsdWUgPj0gMHhkODAwICYmIHZhbHVlIDw9IDB4ZGJmZiAmJiBwb3MgPCBsZW4pIHtcbiAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgdmFsdWUgPSBzdHIuY2hhckNvZGVBdChwb3MpXG4gICAgICBpZiAoKHZhbHVlICYgMHhmYzAwKSA9PT0gMHhkYzAwKSBwb3MrKyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgfVxuICB9XG4gIHJldHVybiBsZW5ndGhcbn1cblxudWNzMmxlbmd0aC5jb2RlID0gJ3JlcXVpcmUoXCJhanYvZGlzdC9ydW50aW1lL3VjczJsZW5ndGhcIikuZGVmYXVsdCdcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBvcGVyYXRvcnN9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB1Y3MybGVuZ3RoIGZyb20gXCIuLi8uLi9ydW50aW1lL3VjczJsZW5ndGhcIlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZSh7a2V5d29yZCwgc2NoZW1hQ29kZX0pIHtcbiAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhMZW5ndGhcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiXG4gICAgcmV0dXJuIHN0cmBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGNoYXJhY3RlcnNgXG4gIH0sXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7bGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFtcIm1heExlbmd0aFwiLCBcIm1pbkxlbmd0aFwiXSxcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4TGVuZ3RoXCIgPyBvcGVyYXRvcnMuR1QgOiBvcGVyYXRvcnMuTFRcbiAgICBjb25zdCBsZW4gPVxuICAgICAgaXQub3B0cy51bmljb2RlID09PSBmYWxzZSA/IF9gJHtkYXRhfS5sZW5ndGhgIDogX2Ake3VzZUZ1bmMoY3h0LmdlbiwgdWNzMmxlbmd0aCl9KCR7ZGF0YX0pYFxuICAgIGN4dC5mYWlsJGRhdGEoX2Ake2xlbn0gJHtvcH0gJHtzY2hlbWFDb2RlfWApXG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7dXNlUGF0dGVybn0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBzdHJ9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5leHBvcnQgdHlwZSBQYXR0ZXJuRXJyb3IgPSBFcnJvck9iamVjdDxcInBhdHRlcm5cIiwge3BhdHRlcm46IHN0cmluZ30sIHN0cmluZyB8IHskZGF0YTogc3RyaW5nfT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7c2NoZW1hQ29kZX0pID0+IHN0cmBtdXN0IG1hdGNoIHBhdHRlcm4gXCIke3NjaGVtYUNvZGV9XCJgLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge3BhdHRlcm46ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicGF0dGVyblwiLFxuICB0eXBlOiBcInN0cmluZ1wiLFxuICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2RhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIC8vIFRPRE8gcmVnZXhwIHNob3VsZCBiZSB3cmFwcGVkIGluIHRyeS9jYXRjaHNcbiAgICBjb25zdCB1ID0gaXQub3B0cy51bmljb2RlUmVnRXhwID8gXCJ1XCIgOiBcIlwiXG4gICAgY29uc3QgcmVnRXhwID0gJGRhdGEgPyBfYChuZXcgUmVnRXhwKCR7c2NoZW1hQ29kZX0sICR7dX0pKWAgOiB1c2VQYXR0ZXJuKGN4dCwgc2NoZW1hKVxuICAgIGN4dC5mYWlsJGRhdGEoX2AhJHtyZWdFeHB9LnRlc3QoJHtkYXRhfSlgKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBvcGVyYXRvcnN9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZSh7a2V5d29yZCwgc2NoZW1hQ29kZX0pIHtcbiAgICBjb25zdCBjb21wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBcIm1vcmVcIiA6IFwiZmV3ZXJcIlxuICAgIHJldHVybiBzdHJgbXVzdCBOT1QgaGF2ZSAke2NvbXB9IHRoYW4gJHtzY2hlbWFDb2RlfSBwcm9wZXJ0aWVzYFxuICB9LFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJtYXhQcm9wZXJ0aWVzXCIsIFwibWluUHJvcGVydGllc1wiXSxcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJudW1iZXJcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtrZXl3b3JkLCBkYXRhLCBzY2hlbWFDb2RlfSA9IGN4dFxuICAgIGNvbnN0IG9wID0ga2V5d29yZCA9PT0gXCJtYXhQcm9wZXJ0aWVzXCIgPyBvcGVyYXRvcnMuR1QgOiBvcGVyYXRvcnMuTFRcbiAgICBjeHQuZmFpbCRkYXRhKF9gT2JqZWN0LmtleXMoJHtkYXRhfSkubGVuZ3RoICR7b3B9ICR7c2NoZW1hQ29kZX1gKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge1xuICBjaGVja1JlcG9ydE1pc3NpbmdQcm9wLFxuICBjaGVja01pc3NpbmdQcm9wLFxuICByZXBvcnRNaXNzaW5nUHJvcCxcbiAgcHJvcGVydHlJbkRhdGEsXG4gIG5vUHJvcGVydHlJbkRhdGEsXG59IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7Xywgc3RyLCBuaWwsIG5vdCwgTmFtZSwgQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2NoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIFJlcXVpcmVkRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJyZXF1aXJlZFwiLFxuICB7bWlzc2luZ1Byb3BlcnR5OiBzdHJpbmd9LFxuICBzdHJpbmdbXSB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHttaXNzaW5nUHJvcGVydHl9fSkgPT4gc3RyYG11c3QgaGF2ZSByZXF1aXJlZCBwcm9wZXJ0eSAnJHttaXNzaW5nUHJvcGVydHl9J2AsXG4gIHBhcmFtczogKHtwYXJhbXM6IHttaXNzaW5nUHJvcGVydHl9fSkgPT4gX2B7bWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicmVxdWlyZWRcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBzY2hlbWFDb2RlLCBkYXRhLCAkZGF0YSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge29wdHN9ID0gaXRcbiAgICBpZiAoISRkYXRhICYmIHNjaGVtYS5sZW5ndGggPT09IDApIHJldHVyblxuICAgIGNvbnN0IHVzZUxvb3AgPSBzY2hlbWEubGVuZ3RoID49IG9wdHMubG9vcFJlcXVpcmVkXG4gICAgaWYgKGl0LmFsbEVycm9ycykgYWxsRXJyb3JzTW9kZSgpXG4gICAgZWxzZSBleGl0T25FcnJvck1vZGUoKVxuXG4gICAgaWYgKG9wdHMuc3RyaWN0UmVxdWlyZWQpIHtcbiAgICAgIGNvbnN0IHByb3BzID0gY3h0LnBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzXG4gICAgICBjb25zdCB7ZGVmaW5lZFByb3BlcnRpZXN9ID0gY3h0Lml0XG4gICAgICBmb3IgKGNvbnN0IHJlcXVpcmVkS2V5IG9mIHNjaGVtYSkge1xuICAgICAgICBpZiAocHJvcHM/LltyZXF1aXJlZEtleV0gPT09IHVuZGVmaW5lZCAmJiAhZGVmaW5lZFByb3BlcnRpZXMuaGFzKHJlcXVpcmVkS2V5KSkge1xuICAgICAgICAgIGNvbnN0IHNjaGVtYVBhdGggPSBpdC5zY2hlbWFFbnYuYmFzZUlkICsgaXQuZXJyU2NoZW1hUGF0aFxuICAgICAgICAgIGNvbnN0IG1zZyA9IGByZXF1aXJlZCBwcm9wZXJ0eSBcIiR7cmVxdWlyZWRLZXl9XCIgaXMgbm90IGRlZmluZWQgYXQgXCIke3NjaGVtYVBhdGh9XCIgKHN0cmljdFJlcXVpcmVkKWBcbiAgICAgICAgICBjaGVja1N0cmljdE1vZGUoaXQsIG1zZywgaXQub3B0cy5zdHJpY3RSZXF1aXJlZClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFsbEVycm9yc01vZGUoKTogdm9pZCB7XG4gICAgICBpZiAodXNlTG9vcCB8fCAkZGF0YSkge1xuICAgICAgICBjeHQuYmxvY2skZGF0YShuaWwsIGxvb3BBbGxSZXF1aXJlZClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2hlbWEpIHtcbiAgICAgICAgICBjaGVja1JlcG9ydE1pc3NpbmdQcm9wKGN4dCwgcHJvcClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4aXRPbkVycm9yTW9kZSgpOiB2b2lkIHtcbiAgICAgIGNvbnN0IG1pc3NpbmcgPSBnZW4ubGV0KFwibWlzc2luZ1wiKVxuICAgICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgICAgY29uc3QgdmFsaWQgPSBnZW4ubGV0KFwidmFsaWRcIiwgdHJ1ZSlcbiAgICAgICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsICgpID0+IGxvb3BVbnRpbE1pc3NpbmcobWlzc2luZywgdmFsaWQpKVxuICAgICAgICBjeHQub2sodmFsaWQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW4uaWYoY2hlY2tNaXNzaW5nUHJvcChjeHQsIHNjaGVtYSwgbWlzc2luZykpXG4gICAgICAgIHJlcG9ydE1pc3NpbmdQcm9wKGN4dCwgbWlzc2luZylcbiAgICAgICAgZ2VuLmVsc2UoKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BBbGxSZXF1aXJlZCgpOiB2b2lkIHtcbiAgICAgIGdlbi5mb3JPZihcInByb3BcIiwgc2NoZW1hQ29kZSBhcyBDb2RlLCAocHJvcCkgPT4ge1xuICAgICAgICBjeHQuc2V0UGFyYW1zKHttaXNzaW5nUHJvcGVydHk6IHByb3B9KVxuICAgICAgICBnZW4uaWYobm9Qcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIG9wdHMub3duUHJvcGVydGllcyksICgpID0+IGN4dC5lcnJvcigpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wVW50aWxNaXNzaW5nKG1pc3Npbmc6IE5hbWUsIHZhbGlkOiBOYW1lKTogdm9pZCB7XG4gICAgICBjeHQuc2V0UGFyYW1zKHttaXNzaW5nUHJvcGVydHk6IG1pc3Npbmd9KVxuICAgICAgZ2VuLmZvck9mKFxuICAgICAgICBtaXNzaW5nLFxuICAgICAgICBzY2hlbWFDb2RlIGFzIENvZGUsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIG1pc3NpbmcsIG9wdHMub3duUHJvcGVydGllcykpXG4gICAgICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgIGN4dC5lcnJvcigpXG4gICAgICAgICAgICBnZW4uYnJlYWsoKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIG5pbFxuICAgICAgKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgb3BlcmF0b3JzfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2Uoe2tleXdvcmQsIHNjaGVtYUNvZGV9KSB7XG4gICAgY29uc3QgY29tcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IFwibW9yZVwiIDogXCJmZXdlclwiXG4gICAgcmV0dXJuIHN0cmBtdXN0IE5PVCBoYXZlICR7Y29tcH0gdGhhbiAke3NjaGVtYUNvZGV9IGl0ZW1zYFxuICB9LFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2xpbWl0OiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBbXCJtYXhJdGVtc1wiLCBcIm1pbkl0ZW1zXCJdLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFwibnVtYmVyXCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7a2V5d29yZCwgZGF0YSwgc2NoZW1hQ29kZX0gPSBjeHRcbiAgICBjb25zdCBvcCA9IGtleXdvcmQgPT09IFwibWF4SXRlbXNcIiA/IG9wZXJhdG9ycy5HVCA6IG9wZXJhdG9ycy5MVFxuICAgIGN4dC5mYWlsJGRhdGEoX2Ake2RhdGF9Lmxlbmd0aCAke29wfSAke3NjaGVtYUNvZGV9YClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiLy8gaHR0cHM6Ly9naXRodWIuY29tL2Fqdi12YWxpZGF0b3IvYWp2L2lzc3Vlcy84ODlcbmltcG9ydCAqIGFzIGVxdWFsIGZyb20gXCJmYXN0LWRlZXAtZXF1YWxcIlxuXG50eXBlIEVxdWFsID0gdHlwZW9mIGVxdWFsICYge2NvZGU6IHN0cmluZ31cbjsoZXF1YWwgYXMgRXF1YWwpLmNvZGUgPSAncmVxdWlyZShcImFqdi9kaXN0L3J1bnRpbWUvZXF1YWxcIikuZGVmYXVsdCdcblxuZXhwb3J0IGRlZmF1bHQgZXF1YWwgYXMgRXF1YWxcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck9iamVjdCwgS2V5d29yZEVycm9yRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge2NoZWNrRGF0YVR5cGVzLCBnZXRTY2hlbWFUeXBlcywgRGF0YVR5cGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlL2RhdGFUeXBlXCJcbmltcG9ydCB7Xywgc3RyLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgZXF1YWwgZnJvbSBcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIlxuXG5leHBvcnQgdHlwZSBVbmlxdWVJdGVtc0Vycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwidW5pcXVlSXRlbXNcIixcbiAge2k6IG51bWJlcjsgajogbnVtYmVyfSxcbiAgYm9vbGVhbiB8IHskZGF0YTogc3RyaW5nfVxuPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtpLCBqfX0pID0+XG4gICAgc3RyYG11c3QgTk9UIGhhdmUgZHVwbGljYXRlIGl0ZW1zIChpdGVtcyAjIyAke2p9IGFuZCAke2l9IGFyZSBpZGVudGljYWwpYCxcbiAgcGFyYW1zOiAoe3BhcmFtczoge2ksIGp9fSkgPT4gX2B7aTogJHtpfSwgajogJHtqfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJ1bmlxdWVJdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFwiYm9vbGVhblwiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgZGF0YSwgJGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBzY2hlbWFDb2RlLCBpdH0gPSBjeHRcbiAgICBpZiAoISRkYXRhICYmICFzY2hlbWEpIHJldHVyblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpXG4gICAgY29uc3QgaXRlbVR5cGVzID0gcGFyZW50U2NoZW1hLml0ZW1zID8gZ2V0U2NoZW1hVHlwZXMocGFyZW50U2NoZW1hLml0ZW1zKSA6IFtdXG4gICAgY3h0LmJsb2NrJGRhdGEodmFsaWQsIHZhbGlkYXRlVW5pcXVlSXRlbXMsIF9gJHtzY2hlbWFDb2RlfSA9PT0gZmFsc2VgKVxuICAgIGN4dC5vayh2YWxpZClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlVW5pcXVlSXRlbXMoKTogdm9pZCB7XG4gICAgICBjb25zdCBpID0gZ2VuLmxldChcImlcIiwgX2Ake2RhdGF9Lmxlbmd0aGApXG4gICAgICBjb25zdCBqID0gZ2VuLmxldChcImpcIilcbiAgICAgIGN4dC5zZXRQYXJhbXMoe2ksIGp9KVxuICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICAgIGdlbi5pZihfYCR7aX0gPiAxYCwgKCkgPT4gKGNhbk9wdGltaXplKCkgPyBsb29wTiA6IGxvb3BOMikoaSwgaikpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuT3B0aW1pemUoKTogYm9vbGVhbiB7XG4gICAgICByZXR1cm4gaXRlbVR5cGVzLmxlbmd0aCA+IDAgJiYgIWl0ZW1UeXBlcy5zb21lKCh0KSA9PiB0ID09PSBcIm9iamVjdFwiIHx8IHQgPT09IFwiYXJyYXlcIilcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb29wTihpOiBOYW1lLCBqOiBOYW1lKTogdm9pZCB7XG4gICAgICBjb25zdCBpdGVtID0gZ2VuLm5hbWUoXCJpdGVtXCIpXG4gICAgICBjb25zdCB3cm9uZ1R5cGUgPSBjaGVja0RhdGFUeXBlcyhpdGVtVHlwZXMsIGl0ZW0sIGl0Lm9wdHMuc3RyaWN0TnVtYmVycywgRGF0YVR5cGUuV3JvbmcpXG4gICAgICBjb25zdCBpbmRpY2VzID0gZ2VuLmNvbnN0KFwiaW5kaWNlc1wiLCBfYHt9YClcbiAgICAgIGdlbi5mb3IoX2A7JHtpfS0tO2AsICgpID0+IHtcbiAgICAgICAgZ2VuLmxldChpdGVtLCBfYCR7ZGF0YX1bJHtpfV1gKVxuICAgICAgICBnZW4uaWYod3JvbmdUeXBlLCBfYGNvbnRpbnVlYClcbiAgICAgICAgaWYgKGl0ZW1UeXBlcy5sZW5ndGggPiAxKSBnZW4uaWYoX2B0eXBlb2YgJHtpdGVtfSA9PSBcInN0cmluZ1wiYCwgX2Ake2l0ZW19ICs9IFwiX1wiYClcbiAgICAgICAgZ2VuXG4gICAgICAgICAgLmlmKF9gdHlwZW9mICR7aW5kaWNlc31bJHtpdGVtfV0gPT0gXCJudW1iZXJcImAsICgpID0+IHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oaiwgX2Ake2luZGljZXN9WyR7aXRlbX1dYClcbiAgICAgICAgICAgIGN4dC5lcnJvcigpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsoKVxuICAgICAgICAgIH0pXG4gICAgICAgICAgLmNvZGUoX2Ake2luZGljZXN9WyR7aXRlbX1dID0gJHtpfWApXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvb3BOMihpOiBOYW1lLCBqOiBOYW1lKTogdm9pZCB7XG4gICAgICBjb25zdCBlcWwgPSB1c2VGdW5jKGdlbiwgZXF1YWwpXG4gICAgICBjb25zdCBvdXRlciA9IGdlbi5uYW1lKFwib3V0ZXJcIilcbiAgICAgIGdlbi5sYWJlbChvdXRlcikuZm9yKF9gOyR7aX0tLTtgLCAoKSA9PlxuICAgICAgICBnZW4uZm9yKF9gJHtqfSA9ICR7aX07ICR7an0tLTtgLCAoKSA9PlxuICAgICAgICAgIGdlbi5pZihfYCR7ZXFsfSgke2RhdGF9WyR7aX1dLCAke2RhdGF9WyR7an1dKWAsICgpID0+IHtcbiAgICAgICAgICAgIGN4dC5lcnJvcigpXG4gICAgICAgICAgICBnZW4uYXNzaWduKHZhbGlkLCBmYWxzZSkuYnJlYWsob3V0ZXIpXG4gICAgICAgICAgfSlcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgRXJyb3JPYmplY3QsIEtleXdvcmRFcnJvckRlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtffSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7dXNlRnVuY30gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQgZXF1YWwgZnJvbSBcIi4uLy4uL3J1bnRpbWUvZXF1YWxcIlxuXG5leHBvcnQgdHlwZSBDb25zdEVycm9yID0gRXJyb3JPYmplY3Q8XCJjb25zdFwiLCB7YWxsb3dlZFZhbHVlOiBhbnl9PlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogXCJtdXN0IGJlIGVxdWFsIHRvIGNvbnN0YW50XCIsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7YWxsb3dlZFZhbHVlOiAke3NjaGVtYUNvZGV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImNvbnN0XCIsXG4gICRkYXRhOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBkYXRhLCAkZGF0YSwgc2NoZW1hQ29kZSwgc2NoZW1hfSA9IGN4dFxuICAgIGlmICgkZGF0YSB8fCAoc2NoZW1hICYmIHR5cGVvZiBzY2hlbWEgPT0gXCJvYmplY3RcIikpIHtcbiAgICAgIGN4dC5mYWlsJGRhdGEoX2AhJHt1c2VGdW5jKGdlbiwgZXF1YWwpfSgke2RhdGF9LCAke3NjaGVtYUNvZGV9KWApXG4gICAgfSBlbHNlIHtcbiAgICAgIGN4dC5mYWlsKF9gJHtzY2hlbWF9ICE9PSAke2RhdGF9YClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb24sIEVycm9yT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgb3IsIE5hbWUsIENvZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHt1c2VGdW5jfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCBlcXVhbCBmcm9tIFwiLi4vLi4vcnVudGltZS9lcXVhbFwiXG5cbmV4cG9ydCB0eXBlIEVudW1FcnJvciA9IEVycm9yT2JqZWN0PFwiZW51bVwiLCB7YWxsb3dlZFZhbHVlczogYW55W119LCBhbnlbXSB8IHskZGF0YTogc3RyaW5nfT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBiZSBlcXVhbCB0byBvbmUgb2YgdGhlIGFsbG93ZWQgdmFsdWVzXCIsXG4gIHBhcmFtczogKHtzY2hlbWFDb2RlfSkgPT4gX2B7YWxsb3dlZFZhbHVlczogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJlbnVtXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGlmICghJGRhdGEgJiYgc2NoZW1hLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiZW51bSBtdXN0IGhhdmUgbm9uLWVtcHR5IGFycmF5XCIpXG4gICAgY29uc3QgdXNlTG9vcCA9IHNjaGVtYS5sZW5ndGggPj0gaXQub3B0cy5sb29wRW51bVxuICAgIGxldCBlcWw6IE5hbWUgfCB1bmRlZmluZWRcbiAgICBjb25zdCBnZXRFcWwgPSAoKTogTmFtZSA9PiAoZXFsID8/PSB1c2VGdW5jKGdlbiwgZXF1YWwpKVxuXG4gICAgbGV0IHZhbGlkOiBDb2RlXG4gICAgaWYgKHVzZUxvb3AgfHwgJGRhdGEpIHtcbiAgICAgIHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIpXG4gICAgICBjeHQuYmxvY2skZGF0YSh2YWxpZCwgbG9vcEVudW0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgICAgY29uc3QgdlNjaGVtYSA9IGdlbi5jb25zdChcInZTY2hlbWFcIiwgc2NoZW1hQ29kZSlcbiAgICAgIHZhbGlkID0gb3IoLi4uc2NoZW1hLm1hcCgoX3g6IHVua25vd24sIGk6IG51bWJlcikgPT4gZXF1YWxDb2RlKHZTY2hlbWEsIGkpKSlcbiAgICB9XG4gICAgY3h0LnBhc3ModmFsaWQpXG5cbiAgICBmdW5jdGlvbiBsb29wRW51bSgpOiB2b2lkIHtcbiAgICAgIGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKVxuICAgICAgZ2VuLmZvck9mKFwidlwiLCBzY2hlbWFDb2RlIGFzIENvZGUsICh2KSA9PlxuICAgICAgICBnZW4uaWYoX2Ake2dldEVxbCgpfSgke2RhdGF9LCAke3Z9KWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpXG4gICAgICApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXF1YWxDb2RlKHZTY2hlbWE6IE5hbWUsIGk6IG51bWJlcik6IENvZGUge1xuICAgICAgY29uc3Qgc2NoID0gc2NoZW1hW2ldXG4gICAgICByZXR1cm4gdHlwZW9mIHNjaCA9PT0gXCJvYmplY3RcIiAmJiBzY2ggIT09IG51bGxcbiAgICAgICAgPyBfYCR7Z2V0RXFsKCl9KCR7ZGF0YX0sICR7dlNjaGVtYX1bJHtpfV0pYFxuICAgICAgICA6IF9gJHtkYXRhfSA9PT0gJHtzY2h9YFxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yT2JqZWN0LCBWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IGxpbWl0TnVtYmVyLCB7TGltaXROdW1iZXJFcnJvcn0gZnJvbSBcIi4vbGltaXROdW1iZXJcIlxuaW1wb3J0IG11bHRpcGxlT2YsIHtNdWx0aXBsZU9mRXJyb3J9IGZyb20gXCIuL211bHRpcGxlT2ZcIlxuaW1wb3J0IGxpbWl0TGVuZ3RoIGZyb20gXCIuL2xpbWl0TGVuZ3RoXCJcbmltcG9ydCBwYXR0ZXJuLCB7UGF0dGVybkVycm9yfSBmcm9tIFwiLi9wYXR0ZXJuXCJcbmltcG9ydCBsaW1pdFByb3BlcnRpZXMgZnJvbSBcIi4vbGltaXRQcm9wZXJ0aWVzXCJcbmltcG9ydCByZXF1aXJlZCwge1JlcXVpcmVkRXJyb3J9IGZyb20gXCIuL3JlcXVpcmVkXCJcbmltcG9ydCBsaW1pdEl0ZW1zIGZyb20gXCIuL2xpbWl0SXRlbXNcIlxuaW1wb3J0IHVuaXF1ZUl0ZW1zLCB7VW5pcXVlSXRlbXNFcnJvcn0gZnJvbSBcIi4vdW5pcXVlSXRlbXNcIlxuaW1wb3J0IGNvbnN0S2V5d29yZCwge0NvbnN0RXJyb3J9IGZyb20gXCIuL2NvbnN0XCJcbmltcG9ydCBlbnVtS2V5d29yZCwge0VudW1FcnJvcn0gZnJvbSBcIi4vZW51bVwiXG5cbmNvbnN0IHZhbGlkYXRpb246IFZvY2FidWxhcnkgPSBbXG4gIC8vIG51bWJlclxuICBsaW1pdE51bWJlcixcbiAgbXVsdGlwbGVPZixcbiAgLy8gc3RyaW5nXG4gIGxpbWl0TGVuZ3RoLFxuICBwYXR0ZXJuLFxuICAvLyBvYmplY3RcbiAgbGltaXRQcm9wZXJ0aWVzLFxuICByZXF1aXJlZCxcbiAgLy8gYXJyYXlcbiAgbGltaXRJdGVtcyxcbiAgdW5pcXVlSXRlbXMsXG4gIC8vIGFueVxuICB7a2V5d29yZDogXCJ0eXBlXCIsIHNjaGVtYVR5cGU6IFtcInN0cmluZ1wiLCBcImFycmF5XCJdfSxcbiAge2tleXdvcmQ6IFwibnVsbGFibGVcIiwgc2NoZW1hVHlwZTogXCJib29sZWFuXCJ9LFxuICBjb25zdEtleXdvcmQsXG4gIGVudW1LZXl3b3JkLFxuXVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0aW9uXG5cbnR5cGUgTGltaXRFcnJvciA9IEVycm9yT2JqZWN0PFxuICBcIm1heEl0ZW1zXCIgfCBcIm1pbkl0ZW1zXCIgfCBcIm1pblByb3BlcnRpZXNcIiB8IFwibWF4UHJvcGVydGllc1wiIHwgXCJtaW5MZW5ndGhcIiB8IFwibWF4TGVuZ3RoXCIsXG4gIHtsaW1pdDogbnVtYmVyfSxcbiAgbnVtYmVyIHwgeyRkYXRhOiBzdHJpbmd9XG4+XG5cbmV4cG9ydCB0eXBlIFZhbGlkYXRpb25LZXl3b3JkRXJyb3IgPVxuICB8IExpbWl0RXJyb3JcbiAgfCBMaW1pdE51bWJlckVycm9yXG4gIHwgTXVsdGlwbGVPZkVycm9yXG4gIHwgUGF0dGVybkVycm9yXG4gIHwgUmVxdWlyZWRFcnJvclxuICB8IFVuaXF1ZUl0ZW1zRXJyb3JcbiAgfCBDb25zdEVycm9yXG4gIHwgRW51bUVycm9yXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBzdHIsIG5vdCwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGUsIFR5cGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBBZGRpdGlvbmFsSXRlbXNFcnJvciA9IEVycm9yT2JqZWN0PFwiYWRkaXRpb25hbEl0ZW1zXCIsIHtsaW1pdDogbnVtYmVyfSwgQW55U2NoZW1hPlxuXG5jb25zdCBlcnJvcjogS2V5d29yZEVycm9yRGVmaW5pdGlvbiA9IHtcbiAgbWVzc2FnZTogKHtwYXJhbXM6IHtsZW59fSkgPT4gc3RyYG11c3QgTk9UIGhhdmUgbW9yZSB0aGFuICR7bGVufSBpdGVtc2AsXG4gIHBhcmFtczogKHtwYXJhbXM6IHtsZW59fSkgPT4gX2B7bGltaXQ6ICR7bGVufX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJhZGRpdGlvbmFsSXRlbXNcIiBhcyBjb25zdCxcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJib29sZWFuXCIsIFwib2JqZWN0XCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge3BhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgY29uc3Qge2l0ZW1zfSA9IHBhcmVudFNjaGVtYVxuICAgIGlmICghQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgJ1wiYWRkaXRpb25hbEl0ZW1zXCIgaXMgaWdub3JlZCB3aGVuIFwiaXRlbXNcIiBpcyBub3QgYW4gYXJyYXkgb2Ygc2NoZW1hcycpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgdmFsaWRhdGVBZGRpdGlvbmFsSXRlbXMoY3h0LCBpdGVtcylcbiAgfSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dDogS2V5d29yZEN4dCwgaXRlbXM6IEFueVNjaGVtYVtdKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIGl0Lml0ZW1zID0gdHJ1ZVxuICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgX2Ake2RhdGF9Lmxlbmd0aGApXG4gIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgY3h0LnNldFBhcmFtcyh7bGVuOiBpdGVtcy5sZW5ndGh9KVxuICAgIGN4dC5wYXNzKF9gJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApXG4gIH0gZWxzZSBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgIGNvbnN0IHZhbGlkID0gZ2VuLnZhcihcInZhbGlkXCIsIF9gJHtsZW59IDw9ICR7aXRlbXMubGVuZ3RofWApIC8vIFRPRE8gdmFyXG4gICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IHZhbGlkYXRlSXRlbXModmFsaWQpKVxuICAgIGN4dC5vayh2YWxpZClcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlSXRlbXModmFsaWQ6IE5hbWUpOiB2b2lkIHtcbiAgICBnZW4uZm9yUmFuZ2UoXCJpXCIsIGl0ZW1zLmxlbmd0aCwgbGVuLCAoaSkgPT4ge1xuICAgICAgY3h0LnN1YnNjaGVtYSh7a2V5d29yZCwgZGF0YVByb3A6IGksIGRhdGFQcm9wVHlwZTogVHlwZS5OdW19LCB2YWxpZClcbiAgICAgIGlmICghaXQuYWxsRXJyb3JzKSBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpXG4gICAgfSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBBbnlTY2hlbWEsIEFueVNjaGVtYU9iamVjdH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge199IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgbWVyZ2VFdmFsdWF0ZWQsIGNoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5pbXBvcnQge3ZhbGlkYXRlQXJyYXl9IGZyb20gXCIuLi9jb2RlXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJhcnJheVwiLCBcImJvb2xlYW5cIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtzY2hlbWEsIGl0fSA9IGN4dFxuICAgIGlmIChBcnJheS5pc0FycmF5KHNjaGVtYSkpIHJldHVybiB2YWxpZGF0ZVR1cGxlKGN4dCwgXCJhZGRpdGlvbmFsSXRlbXNcIiwgc2NoZW1hKVxuICAgIGl0Lml0ZW1zID0gdHJ1ZVxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkgcmV0dXJuXG4gICAgY3h0Lm9rKHZhbGlkYXRlQXJyYXkoY3h0KSlcbiAgfSxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVHVwbGUoXG4gIGN4dDogS2V5d29yZEN4dCxcbiAgZXh0cmFJdGVtczogc3RyaW5nLFxuICBzY2hBcnI6IEFueVNjaGVtYVtdID0gY3h0LnNjaGVtYVxuKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIHBhcmVudFNjaGVtYSwgZGF0YSwga2V5d29yZCwgaXR9ID0gY3h0XG4gIGNoZWNrU3RyaWN0VHVwbGUocGFyZW50U2NoZW1hKVxuICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBzY2hBcnIubGVuZ3RoICYmIGl0Lml0ZW1zICE9PSB0cnVlKSB7XG4gICAgaXQuaXRlbXMgPSBtZXJnZUV2YWx1YXRlZC5pdGVtcyhnZW4sIHNjaEFyci5sZW5ndGgsIGl0Lml0ZW1zKVxuICB9XG4gIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgX2Ake2RhdGF9Lmxlbmd0aGApXG4gIHNjaEFyci5mb3JFYWNoKChzY2g6IEFueVNjaGVtYSwgaTogbnVtYmVyKSA9PiB7XG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKSByZXR1cm5cbiAgICBnZW4uaWYoX2Ake2xlbn0gPiAke2l9YCwgKCkgPT5cbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkLFxuICAgICAgICAgIHNjaGVtYVByb3A6IGksXG4gICAgICAgICAgZGF0YVByb3A6IGksXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgKVxuICAgIGN4dC5vayh2YWxpZClcbiAgfSlcblxuICBmdW5jdGlvbiBjaGVja1N0cmljdFR1cGxlKHNjaDogQW55U2NoZW1hT2JqZWN0KTogdm9pZCB7XG4gICAgY29uc3Qge29wdHMsIGVyclNjaGVtYVBhdGh9ID0gaXRcbiAgICBjb25zdCBsID0gc2NoQXJyLmxlbmd0aFxuICAgIGNvbnN0IGZ1bGxUdXBsZSA9IGwgPT09IHNjaC5taW5JdGVtcyAmJiAobCA9PT0gc2NoLm1heEl0ZW1zIHx8IHNjaFtleHRyYUl0ZW1zXSA9PT0gZmFsc2UpXG4gICAgaWYgKG9wdHMuc3RyaWN0VHVwbGVzICYmICFmdWxsVHVwbGUpIHtcbiAgICAgIGNvbnN0IG1zZyA9IGBcIiR7a2V5d29yZH1cIiBpcyAke2x9LXR1cGxlLCBidXQgbWluSXRlbXMgb3IgbWF4SXRlbXMvJHtleHRyYUl0ZW1zfSBhcmUgbm90IHNwZWNpZmllZCBvciBkaWZmZXJlbnQgYXQgcGF0aCBcIiR7ZXJyU2NoZW1hUGF0aH1cImBcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgbXNnLCBvcHRzLnN0cmljdFR1cGxlcylcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB7dmFsaWRhdGVUdXBsZX0gZnJvbSBcIi4vaXRlbXNcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJwcmVmaXhJdGVtc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcImFycmF5XCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgY29kZTogKGN4dCkgPT4gdmFsaWRhdGVUdXBsZShjeHQsIFwiaXRlbXNcIiksXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWF9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHt2YWxpZGF0ZUFycmF5fSBmcm9tIFwiLi4vY29kZVwiXG5pbXBvcnQge3ZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zfSBmcm9tIFwiLi9hZGRpdGlvbmFsSXRlbXNcIlxuXG5leHBvcnQgdHlwZSBJdGVtc0Vycm9yID0gRXJyb3JPYmplY3Q8XCJpdGVtc1wiLCB7bGltaXQ6IG51bWJlcn0sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7bGVufX0pID0+IHN0cmBtdXN0IE5PVCBoYXZlIG1vcmUgdGhhbiAke2xlbn0gaXRlbXNgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7bGVufX0pID0+IF9ge2xpbWl0OiAke2xlbn19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiaXRlbXNcIixcbiAgdHlwZTogXCJhcnJheVwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICBiZWZvcmU6IFwidW5pcXVlSXRlbXNcIixcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge3NjaGVtYSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7cHJlZml4SXRlbXN9ID0gcGFyZW50U2NoZW1hXG4gICAgaXQuaXRlbXMgPSB0cnVlXG4gICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpKSByZXR1cm5cbiAgICBpZiAocHJlZml4SXRlbXMpIHZhbGlkYXRlQWRkaXRpb25hbEl0ZW1zKGN4dCwgcHJlZml4SXRlbXMpXG4gICAgZWxzZSBjeHQub2sodmFsaWRhdGVBcnJheShjeHQpKVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hLCBjaGVja1N0cmljdE1vZGUsIFR5cGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBDb250YWluc0Vycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwiY29udGFpbnNcIixcbiAge21pbkNvbnRhaW5zOiBudW1iZXI7IG1heENvbnRhaW5zPzogbnVtYmVyfSxcbiAgQW55U2NoZW1hXG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge21pbiwgbWF4fX0pID0+XG4gICAgbWF4ID09PSB1bmRlZmluZWRcbiAgICAgID8gc3RyYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gdmFsaWQgaXRlbShzKWBcbiAgICAgIDogc3RyYG11c3QgY29udGFpbiBhdCBsZWFzdCAke21pbn0gYW5kIG5vIG1vcmUgdGhhbiAke21heH0gdmFsaWQgaXRlbShzKWAsXG4gIHBhcmFtczogKHtwYXJhbXM6IHttaW4sIG1heH19KSA9PlxuICAgIG1heCA9PT0gdW5kZWZpbmVkID8gX2B7bWluQ29udGFpbnM6ICR7bWlufX1gIDogX2B7bWluQ29udGFpbnM6ICR7bWlufSwgbWF4Q29udGFpbnM6ICR7bWF4fX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJjb250YWluc1wiLFxuICB0eXBlOiBcImFycmF5XCIsXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGJlZm9yZTogXCJ1bmlxdWVJdGVtc1wiLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBwYXJlbnRTY2hlbWEsIGRhdGEsIGl0fSA9IGN4dFxuICAgIGxldCBtaW46IG51bWJlclxuICAgIGxldCBtYXg6IG51bWJlciB8IHVuZGVmaW5lZFxuICAgIGNvbnN0IHttaW5Db250YWlucywgbWF4Q29udGFpbnN9ID0gcGFyZW50U2NoZW1hXG4gICAgaWYgKGl0Lm9wdHMubmV4dCkge1xuICAgICAgbWluID0gbWluQ29udGFpbnMgPT09IHVuZGVmaW5lZCA/IDEgOiBtaW5Db250YWluc1xuICAgICAgbWF4ID0gbWF4Q29udGFpbnNcbiAgICB9IGVsc2Uge1xuICAgICAgbWluID0gMVxuICAgIH1cbiAgICBjb25zdCBsZW4gPSBnZW4uY29uc3QoXCJsZW5cIiwgX2Ake2RhdGF9Lmxlbmd0aGApXG4gICAgY3h0LnNldFBhcmFtcyh7bWluLCBtYXh9KVxuICAgIGlmIChtYXggPT09IHVuZGVmaW5lZCAmJiBtaW4gPT09IDApIHtcbiAgICAgIGNoZWNrU3RyaWN0TW9kZShpdCwgYFwibWluQ29udGFpbnNcIiA9PSAwIHdpdGhvdXQgXCJtYXhDb250YWluc1wiOiBcImNvbnRhaW5zXCIga2V5d29yZCBpZ25vcmVkYClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgbWluID4gbWF4KSB7XG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsIGBcIm1pbkNvbnRhaW5zXCIgPiBcIm1heENvbnRhaW5zXCIgaXMgYWx3YXlzIGludmFsaWRgKVxuICAgICAgY3h0LmZhaWwoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgbGV0IGNvbmQgPSBfYCR7bGVufSA+PSAke21pbn1gXG4gICAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIGNvbmQgPSBfYCR7Y29uZH0gJiYgJHtsZW59IDw9ICR7bWF4fWBcbiAgICAgIGN4dC5wYXNzKGNvbmQpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpdC5pdGVtcyA9IHRydWVcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBpZiAobWF4ID09PSB1bmRlZmluZWQgJiYgbWluID09PSAxKSB7XG4gICAgICB2YWxpZGF0ZUl0ZW1zKHZhbGlkLCAoKSA9PiBnZW4uaWYodmFsaWQsICgpID0+IGdlbi5icmVhaygpKSlcbiAgICB9IGVsc2UgaWYgKG1pbiA9PT0gMCkge1xuICAgICAgZ2VuLmxldCh2YWxpZCwgdHJ1ZSlcbiAgICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkgZ2VuLmlmKF9gJHtkYXRhfS5sZW5ndGggPiAwYCwgdmFsaWRhdGVJdGVtc1dpdGhDb3VudClcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuLmxldCh2YWxpZCwgZmFsc2UpXG4gICAgICB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KClcbiAgICB9XG4gICAgY3h0LnJlc3VsdCh2YWxpZCwgKCkgPT4gY3h0LnJlc2V0KCkpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zV2l0aENvdW50KCk6IHZvaWQge1xuICAgICAgY29uc3Qgc2NoVmFsaWQgPSBnZW4ubmFtZShcIl92YWxpZFwiKVxuICAgICAgY29uc3QgY291bnQgPSBnZW4ubGV0KFwiY291bnRcIiwgMClcbiAgICAgIHZhbGlkYXRlSXRlbXMoc2NoVmFsaWQsICgpID0+IGdlbi5pZihzY2hWYWxpZCwgKCkgPT4gY2hlY2tMaW1pdHMoY291bnQpKSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUl0ZW1zKF92YWxpZDogTmFtZSwgYmxvY2s6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICAgIGdlbi5mb3JSYW5nZShcImlcIiwgMCwgbGVuLCAoaSkgPT4ge1xuICAgICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGtleXdvcmQ6IFwiY29udGFpbnNcIixcbiAgICAgICAgICAgIGRhdGFQcm9wOiBpLFxuICAgICAgICAgICAgZGF0YVByb3BUeXBlOiBUeXBlLk51bSxcbiAgICAgICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBfdmFsaWRcbiAgICAgICAgKVxuICAgICAgICBibG9jaygpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrTGltaXRzKGNvdW50OiBOYW1lKTogdm9pZCB7XG4gICAgICBnZW4uY29kZShfYCR7Y291bnR9KytgKVxuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGdlbi5pZihfYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpLmJyZWFrKCkpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZW4uaWYoX2Ake2NvdW50fSA+ICR7bWF4fWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIGZhbHNlKS5icmVhaygpKVxuICAgICAgICBpZiAobWluID09PSAxKSBnZW4uYXNzaWduKHZhbGlkLCB0cnVlKVxuICAgICAgICBlbHNlIGdlbi5pZihfYCR7Y291bnR9ID49ICR7bWlufWAsICgpID0+IGdlbi5hc3NpZ24odmFsaWQsIHRydWUpKVxuICAgICAgfVxuICAgIH1cbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBTY2hlbWFNYXAsXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0cn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7Y2hlY2tSZXBvcnRNaXNzaW5nUHJvcCwgY2hlY2tNaXNzaW5nUHJvcCwgcmVwb3J0TWlzc2luZ1Byb3AsIHByb3BlcnR5SW5EYXRhfSBmcm9tIFwiLi4vY29kZVwiXG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5RGVwZW5kZW5jaWVzID0ge1tLIGluIHN0cmluZ10/OiBzdHJpbmdbXX1cblxuZXhwb3J0IGludGVyZmFjZSBEZXBlbmRlbmNpZXNFcnJvclBhcmFtcyB7XG4gIHByb3BlcnR5OiBzdHJpbmdcbiAgbWlzc2luZ1Byb3BlcnR5OiBzdHJpbmdcbiAgZGVwc0NvdW50OiBudW1iZXJcbiAgZGVwczogc3RyaW5nIC8vIFRPRE8gY2hhbmdlIHRvIHN0cmluZ1tdXG59XG5cbnR5cGUgU2NoZW1hRGVwZW5kZW5jaWVzID0gU2NoZW1hTWFwXG5cbmV4cG9ydCB0eXBlIERlcGVuZGVuY2llc0Vycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwiZGVwZW5kZW5jaWVzXCIsXG4gIERlcGVuZGVuY2llc0Vycm9yUGFyYW1zLFxuICB7W0sgaW4gc3RyaW5nXT86IHN0cmluZ1tdIHwgQW55U2NoZW1hfVxuPlxuXG5leHBvcnQgY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zOiB7cHJvcGVydHksIGRlcHNDb3VudCwgZGVwc319KSA9PiB7XG4gICAgY29uc3QgcHJvcGVydHlfaWVzID0gZGVwc0NvdW50ID09PSAxID8gXCJwcm9wZXJ0eVwiIDogXCJwcm9wZXJ0aWVzXCJcbiAgICByZXR1cm4gc3RyYG11c3QgaGF2ZSAke3Byb3BlcnR5X2llc30gJHtkZXBzfSB3aGVuIHByb3BlcnR5ICR7cHJvcGVydHl9IGlzIHByZXNlbnRgXG4gIH0sXG4gIHBhcmFtczogKHtwYXJhbXM6IHtwcm9wZXJ0eSwgZGVwc0NvdW50LCBkZXBzLCBtaXNzaW5nUHJvcGVydHl9fSkgPT5cbiAgICBfYHtwcm9wZXJ0eTogJHtwcm9wZXJ0eX0sXG4gICAgbWlzc2luZ1Byb3BlcnR5OiAke21pc3NpbmdQcm9wZXJ0eX0sXG4gICAgZGVwc0NvdW50OiAke2RlcHNDb3VudH0sXG4gICAgZGVwczogJHtkZXBzfX1gLCAvLyBUT0RPIGNoYW5nZSB0byByZWZlcmVuY2Vcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiZGVwZW5kZW5jaWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IFtwcm9wRGVwcywgc2NoRGVwc10gPSBzcGxpdERlcGVuZGVuY2llcyhjeHQpXG4gICAgdmFsaWRhdGVQcm9wZXJ0eURlcHMoY3h0LCBwcm9wRGVwcylcbiAgICB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0LCBzY2hEZXBzKVxuICB9LFxufVxuXG5mdW5jdGlvbiBzcGxpdERlcGVuZGVuY2llcyh7c2NoZW1hfTogS2V5d29yZEN4dCk6IFtQcm9wZXJ0eURlcGVuZGVuY2llcywgU2NoZW1hRGVwZW5kZW5jaWVzXSB7XG4gIGNvbnN0IHByb3BlcnR5RGVwczogUHJvcGVydHlEZXBlbmRlbmNpZXMgPSB7fVxuICBjb25zdCBzY2hlbWFEZXBzOiBTY2hlbWFEZXBlbmRlbmNpZXMgPSB7fVxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBpZiAoa2V5ID09PSBcIl9fcHJvdG9fX1wiKSBjb250aW51ZVxuICAgIGNvbnN0IGRlcHMgPSBBcnJheS5pc0FycmF5KHNjaGVtYVtrZXldKSA/IHByb3BlcnR5RGVwcyA6IHNjaGVtYURlcHNcbiAgICBkZXBzW2tleV0gPSBzY2hlbWFba2V5XVxuICB9XG4gIHJldHVybiBbcHJvcGVydHlEZXBzLCBzY2hlbWFEZXBzXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0eURlcHMoXG4gIGN4dDogS2V5d29yZEN4dCxcbiAgcHJvcGVydHlEZXBzOiB7W0sgaW4gc3RyaW5nXT86IHN0cmluZ1tdfSA9IGN4dC5zY2hlbWFcbik6IHZvaWQge1xuICBjb25zdCB7Z2VuLCBkYXRhLCBpdH0gPSBjeHRcbiAgaWYgKE9iamVjdC5rZXlzKHByb3BlcnR5RGVwcykubGVuZ3RoID09PSAwKSByZXR1cm5cbiAgY29uc3QgbWlzc2luZyA9IGdlbi5sZXQoXCJtaXNzaW5nXCIpXG4gIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wZXJ0eURlcHMpIHtcbiAgICBjb25zdCBkZXBzID0gcHJvcGVydHlEZXBzW3Byb3BdIGFzIHN0cmluZ1tdXG4gICAgaWYgKGRlcHMubGVuZ3RoID09PSAwKSBjb250aW51ZVxuICAgIGNvbnN0IGhhc1Byb3BlcnR5ID0gcHJvcGVydHlJbkRhdGEoZ2VuLCBkYXRhLCBwcm9wLCBpdC5vcHRzLm93blByb3BlcnRpZXMpXG4gICAgY3h0LnNldFBhcmFtcyh7XG4gICAgICBwcm9wZXJ0eTogcHJvcCxcbiAgICAgIGRlcHNDb3VudDogZGVwcy5sZW5ndGgsXG4gICAgICBkZXBzOiBkZXBzLmpvaW4oXCIsIFwiKSxcbiAgICB9KVxuICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgIGdlbi5pZihoYXNQcm9wZXJ0eSwgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcFByb3Agb2YgZGVwcykge1xuICAgICAgICAgIGNoZWNrUmVwb3J0TWlzc2luZ1Byb3AoY3h0LCBkZXBQcm9wKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBnZW4uaWYoX2Ake2hhc1Byb3BlcnR5fSAmJiAoJHtjaGVja01pc3NpbmdQcm9wKGN4dCwgZGVwcywgbWlzc2luZyl9KWApXG4gICAgICByZXBvcnRNaXNzaW5nUHJvcChjeHQsIG1pc3NpbmcpXG4gICAgICBnZW4uZWxzZSgpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVNjaGVtYURlcHMoY3h0OiBLZXl3b3JkQ3h0LCBzY2hlbWFEZXBzOiBTY2hlbWFNYXAgPSBjeHQuc2NoZW1hKTogdm9pZCB7XG4gIGNvbnN0IHtnZW4sIGRhdGEsIGtleXdvcmQsIGl0fSA9IGN4dFxuICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgZm9yIChjb25zdCBwcm9wIGluIHNjaGVtYURlcHMpIHtcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYURlcHNbcHJvcF0gYXMgQW55U2NoZW1hKSkgY29udGludWVcbiAgICBnZW4uaWYoXG4gICAgICBwcm9wZXJ0eUluRGF0YShnZW4sIGRhdGEsIHByb3AsIGl0Lm9wdHMub3duUHJvcGVydGllcyksXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe2tleXdvcmQsIHNjaGVtYVByb3A6IHByb3B9LCB2YWxpZClcbiAgICAgICAgY3h0Lm1lcmdlVmFsaWRFdmFsdWF0ZWQoc2NoQ3h0LCB2YWxpZClcbiAgICAgIH0sXG4gICAgICAoKSA9PiBnZW4udmFyKHZhbGlkLCB0cnVlKSAvLyBUT0RPIHZhclxuICAgIClcbiAgICBjeHQub2sodmFsaWQpXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtfLCBub3R9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIFByb3BlcnR5TmFtZXNFcnJvciA9IEVycm9yT2JqZWN0PFwicHJvcGVydHlOYW1lc1wiLCB7cHJvcGVydHlOYW1lOiBzdHJpbmd9LCBBbnlTY2hlbWE+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcInByb3BlcnR5IG5hbWUgbXVzdCBiZSB2YWxpZFwiLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7cHJvcGVydHlOYW1lOiAke3BhcmFtcy5wcm9wZXJ0eU5hbWV9fWAsXG59XG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgdHlwZTogXCJvYmplY3RcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBkYXRhLCBpdH0gPSBjeHRcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuXG4gICAgZ2VuLmZvckluKFwia2V5XCIsIGRhdGEsIChrZXkpID0+IHtcbiAgICAgIGN4dC5zZXRQYXJhbXMoe3Byb3BlcnR5TmFtZToga2V5fSlcbiAgICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICAgIHtcbiAgICAgICAgICBrZXl3b3JkOiBcInByb3BlcnR5TmFtZXNcIixcbiAgICAgICAgICBkYXRhOiBrZXksXG4gICAgICAgICAgZGF0YVR5cGVzOiBbXCJzdHJpbmdcIl0sXG4gICAgICAgICAgcHJvcGVydHlOYW1lOiBrZXksXG4gICAgICAgICAgY29tcG9zaXRlUnVsZTogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgdmFsaWRcbiAgICAgIClcbiAgICAgIGdlbi5pZihub3QodmFsaWQpLCAoKSA9PiB7XG4gICAgICAgIGN4dC5lcnJvcih0cnVlKVxuICAgICAgICBpZiAoIWl0LmFsbEVycm9ycykgZ2VuLmJyZWFrKClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGN4dC5vayh2YWxpZClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge1xuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEFkZGVkS2V5d29yZERlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBBbnlTY2hlbWEsXG59IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQge2FsbFNjaGVtYVByb3BlcnRpZXMsIHVzZVBhdHRlcm4sIGlzT3duUHJvcGVydHl9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7XywgbmlsLCBvciwgbm90LCBDb2RlLCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCBOIGZyb20gXCIuLi8uLi9jb21waWxlL25hbWVzXCJcbmltcG9ydCB0eXBlIHtTdWJzY2hlbWFBcmdzfSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZS9zdWJzY2hlbWFcIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgc2NoZW1hUmVmT3JWYWwsIFR5cGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5leHBvcnQgdHlwZSBBZGRpdGlvbmFsUHJvcGVydGllc0Vycm9yID0gRXJyb3JPYmplY3Q8XG4gIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIixcbiAge2FkZGl0aW9uYWxQcm9wZXJ0eTogc3RyaW5nfSxcbiAgQW55U2NoZW1hXG4+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiBcIm11c3QgTk9UIGhhdmUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXCIsXG4gIHBhcmFtczogKHtwYXJhbXN9KSA9PiBfYHthZGRpdGlvbmFsUHJvcGVydHk6ICR7cGFyYW1zLmFkZGl0aW9uYWxQcm9wZXJ0eX19YCxcbn1cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gJiBBZGRlZEtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFkZGl0aW9uYWxQcm9wZXJ0aWVzXCIsXG4gIHR5cGU6IFtcIm9iamVjdFwiXSxcbiAgc2NoZW1hVHlwZTogW1wiYm9vbGVhblwiLCBcIm9iamVjdFwiXSxcbiAgYWxsb3dVbmRlZmluZWQ6IHRydWUsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgZGF0YSwgZXJyc0NvdW50LCBpdH0gPSBjeHRcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWVycnNDb3VudCkgdGhyb3cgbmV3IEVycm9yKFwiYWp2IGltcGxlbWVudGF0aW9uIGVycm9yXCIpXG4gICAgY29uc3Qge2FsbEVycm9ycywgb3B0c30gPSBpdFxuICAgIGl0LnByb3BzID0gdHJ1ZVxuICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgIT09IFwiYWxsXCIgJiYgYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHJldHVyblxuICAgIGNvbnN0IHByb3BzID0gYWxsU2NoZW1hUHJvcGVydGllcyhwYXJlbnRTY2hlbWEucHJvcGVydGllcylcbiAgICBjb25zdCBwYXRQcm9wcyA9IGFsbFNjaGVtYVByb3BlcnRpZXMocGFyZW50U2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzKVxuICAgIGNoZWNrQWRkaXRpb25hbFByb3BlcnRpZXMoKVxuICAgIGN4dC5vayhfYCR7ZXJyc0NvdW50fSA9PT0gJHtOLmVycm9yc31gKVxuXG4gICAgZnVuY3Rpb24gY2hlY2tBZGRpdGlvbmFsUHJvcGVydGllcygpOiB2b2lkIHtcbiAgICAgIGdlbi5mb3JJbihcImtleVwiLCBkYXRhLCAoa2V5OiBOYW1lKSA9PiB7XG4gICAgICAgIGlmICghcHJvcHMubGVuZ3RoICYmICFwYXRQcm9wcy5sZW5ndGgpIGFkZGl0aW9uYWxQcm9wZXJ0eUNvZGUoa2V5KVxuICAgICAgICBlbHNlIGdlbi5pZihpc0FkZGl0aW9uYWwoa2V5KSwgKCkgPT4gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXkpKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FkZGl0aW9uYWwoa2V5OiBOYW1lKTogQ29kZSB7XG4gICAgICBsZXQgZGVmaW5lZFByb3A6IENvZGVcbiAgICAgIGlmIChwcm9wcy5sZW5ndGggPiA4KSB7XG4gICAgICAgIC8vIFRPRE8gbWF5YmUgYW4gb3B0aW9uIGluc3RlYWQgb2YgaGFyZC1jb2RlZCA4P1xuICAgICAgICBjb25zdCBwcm9wc1NjaGVtYSA9IHNjaGVtYVJlZk9yVmFsKGl0LCBwYXJlbnRTY2hlbWEucHJvcGVydGllcywgXCJwcm9wZXJ0aWVzXCIpXG4gICAgICAgIGRlZmluZWRQcm9wID0gaXNPd25Qcm9wZXJ0eShnZW4sIHByb3BzU2NoZW1hIGFzIENvZGUsIGtleSlcbiAgICAgIH0gZWxzZSBpZiAocHJvcHMubGVuZ3RoKSB7XG4gICAgICAgIGRlZmluZWRQcm9wID0gb3IoLi4ucHJvcHMubWFwKChwKSA9PiBfYCR7a2V5fSA9PT0gJHtwfWApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lZFByb3AgPSBuaWxcbiAgICAgIH1cbiAgICAgIGlmIChwYXRQcm9wcy5sZW5ndGgpIHtcbiAgICAgICAgZGVmaW5lZFByb3AgPSBvcihkZWZpbmVkUHJvcCwgLi4ucGF0UHJvcHMubWFwKChwKSA9PiBfYCR7dXNlUGF0dGVybihjeHQsIHApfS50ZXN0KCR7a2V5fSlgKSlcbiAgICAgIH1cbiAgICAgIHJldHVybiBub3QoZGVmaW5lZFByb3ApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVsZXRlQWRkaXRpb25hbChrZXk6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGdlbi5jb2RlKF9gZGVsZXRlICR7ZGF0YX1bJHtrZXl9XWApXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkaXRpb25hbFByb3BlcnR5Q29kZShrZXk6IE5hbWUpOiB2b2lkIHtcbiAgICAgIGlmIChvcHRzLnJlbW92ZUFkZGl0aW9uYWwgPT09IFwiYWxsXCIgfHwgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCAmJiBzY2hlbWEgPT09IGZhbHNlKSkge1xuICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChzY2hlbWEgPT09IGZhbHNlKSB7XG4gICAgICAgIGN4dC5zZXRQYXJhbXMoe2FkZGl0aW9uYWxQcm9wZXJ0eToga2V5fSlcbiAgICAgICAgY3h0LmVycm9yKClcbiAgICAgICAgaWYgKCFhbGxFcnJvcnMpIGdlbi5icmVhaygpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNjaGVtYSA9PSBcIm9iamVjdFwiICYmICFhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoZW1hKSkge1xuICAgICAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICAgICAgaWYgKG9wdHMucmVtb3ZlQWRkaXRpb25hbCA9PT0gXCJmYWlsaW5nXCIpIHtcbiAgICAgICAgICBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5LCB2YWxpZCwgZmFsc2UpXG4gICAgICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IHtcbiAgICAgICAgICAgIGN4dC5yZXNldCgpXG4gICAgICAgICAgICBkZWxldGVBZGRpdGlvbmFsKGtleSlcbiAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFwcGx5QWRkaXRpb25hbFNjaGVtYShrZXksIHZhbGlkKVxuICAgICAgICAgIGlmICghYWxsRXJyb3JzKSBnZW4uaWYobm90KHZhbGlkKSwgKCkgPT4gZ2VuLmJyZWFrKCkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseUFkZGl0aW9uYWxTY2hlbWEoa2V5OiBOYW1lLCB2YWxpZDogTmFtZSwgZXJyb3JzPzogZmFsc2UpOiB2b2lkIHtcbiAgICAgIGNvbnN0IHN1YnNjaGVtYTogU3Vic2NoZW1hQXJncyA9IHtcbiAgICAgICAga2V5d29yZDogXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICBkYXRhUHJvcFR5cGU6IFR5cGUuU3RyLFxuICAgICAgfVxuICAgICAgaWYgKGVycm9ycyA9PT0gZmFsc2UpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdWJzY2hlbWEsIHtcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICAgIGN4dC5zdWJzY2hlbWEoc3Vic2NoZW1hLCB2YWxpZClcbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7cHJvcGVydHlJbkRhdGEsIGFsbFNjaGVtYVByb3BlcnRpZXN9IGZyb20gXCIuLi9jb2RlXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIHRvSGFzaCwgbWVyZ2VFdmFsdWF0ZWR9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IGFwRGVmIGZyb20gXCIuL2FkZGl0aW9uYWxQcm9wZXJ0aWVzXCJcblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICB0eXBlOiBcIm9iamVjdFwiLFxuICBzY2hlbWFUeXBlOiBcIm9iamVjdFwiLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBkYXRhLCBpdH0gPSBjeHRcbiAgICBpZiAoaXQub3B0cy5yZW1vdmVBZGRpdGlvbmFsID09PSBcImFsbFwiICYmIHBhcmVudFNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcERlZi5jb2RlKG5ldyBLZXl3b3JkQ3h0KGl0LCBhcERlZiwgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiKSlcbiAgICB9XG4gICAgY29uc3QgYWxsUHJvcHMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSlcbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgYWxsUHJvcHMpIHtcbiAgICAgIGl0LmRlZmluZWRQcm9wZXJ0aWVzLmFkZChwcm9wKVxuICAgIH1cbiAgICBpZiAoaXQub3B0cy51bmV2YWx1YXRlZCAmJiBhbGxQcm9wcy5sZW5ndGggJiYgaXQucHJvcHMgIT09IHRydWUpIHtcbiAgICAgIGl0LnByb3BzID0gbWVyZ2VFdmFsdWF0ZWQucHJvcHMoZ2VuLCB0b0hhc2goYWxsUHJvcHMpLCBpdC5wcm9wcylcbiAgICB9XG4gICAgY29uc3QgcHJvcGVydGllcyA9IGFsbFByb3BzLmZpbHRlcigocCkgPT4gIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWFbcF0pKVxuICAgIGlmIChwcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG5cbiAgICBmb3IgKGNvbnN0IHByb3Agb2YgcHJvcGVydGllcykge1xuICAgICAgaWYgKGhhc0RlZmF1bHQocHJvcCkpIHtcbiAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2VuLmlmKHByb3BlcnR5SW5EYXRhKGdlbiwgZGF0YSwgcHJvcCwgaXQub3B0cy5vd25Qcm9wZXJ0aWVzKSlcbiAgICAgICAgYXBwbHlQcm9wZXJ0eVNjaGVtYShwcm9wKVxuICAgICAgICBpZiAoIWl0LmFsbEVycm9ycykgZ2VuLmVsc2UoKS52YXIodmFsaWQsIHRydWUpXG4gICAgICAgIGdlbi5lbmRJZigpXG4gICAgICB9XG4gICAgICBjeHQuaXQuZGVmaW5lZFByb3BlcnRpZXMuYWRkKHByb3ApXG4gICAgICBjeHQub2sodmFsaWQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFzRGVmYXVsdChwcm9wOiBzdHJpbmcpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICAgIHJldHVybiBpdC5vcHRzLnVzZURlZmF1bHRzICYmICFpdC5jb21wb3NpdGVSdWxlICYmIHNjaGVtYVtwcm9wXS5kZWZhdWx0ICE9PSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVByb3BlcnR5U2NoZW1hKHByb3A6IHN0cmluZyk6IHZvaWQge1xuICAgICAgY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQ6IFwicHJvcGVydGllc1wiLFxuICAgICAgICAgIHNjaGVtYVByb3A6IHByb3AsXG4gICAgICAgICAgZGF0YVByb3A6IHByb3AsXG4gICAgICAgIH0sXG4gICAgICAgIHZhbGlkXG4gICAgICApXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7YWxsU2NoZW1hUHJvcGVydGllcywgdXNlUGF0dGVybn0gZnJvbSBcIi4uL2NvZGVcIlxuaW1wb3J0IHtfLCBub3QsIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYSwgY2hlY2tTdHJpY3RNb2RlfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7ZXZhbHVhdGVkUHJvcHNUb05hbWUsIFR5cGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuaW1wb3J0IHtBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcInBhdHRlcm5Qcm9wZXJ0aWVzXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBkYXRhLCBwYXJlbnRTY2hlbWEsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvcHRzfSA9IGl0XG4gICAgY29uc3QgcGF0dGVybnMgPSBhbGxTY2hlbWFQcm9wZXJ0aWVzKHNjaGVtYSlcbiAgICBjb25zdCBhbHdheXNWYWxpZFBhdHRlcm5zID0gcGF0dGVybnMuZmlsdGVyKChwKSA9PlxuICAgICAgYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYVtwXSBhcyBBbnlTY2hlbWEpXG4gICAgKVxuXG4gICAgaWYgKFxuICAgICAgcGF0dGVybnMubGVuZ3RoID09PSAwIHx8XG4gICAgICAoYWx3YXlzVmFsaWRQYXR0ZXJucy5sZW5ndGggPT09IHBhdHRlcm5zLmxlbmd0aCAmJlxuICAgICAgICAoIWl0Lm9wdHMudW5ldmFsdWF0ZWQgfHwgaXQucHJvcHMgPT09IHRydWUpKVxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tQcm9wZXJ0aWVzID1cbiAgICAgIG9wdHMuc3RyaWN0U2NoZW1hICYmICFvcHRzLmFsbG93TWF0Y2hpbmdQcm9wZXJ0aWVzICYmIHBhcmVudFNjaGVtYS5wcm9wZXJ0aWVzXG4gICAgY29uc3QgdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgaWYgKGl0LnByb3BzICE9PSB0cnVlICYmICEoaXQucHJvcHMgaW5zdGFuY2VvZiBOYW1lKSkge1xuICAgICAgaXQucHJvcHMgPSBldmFsdWF0ZWRQcm9wc1RvTmFtZShnZW4sIGl0LnByb3BzKVxuICAgIH1cbiAgICBjb25zdCB7cHJvcHN9ID0gaXRcbiAgICB2YWxpZGF0ZVBhdHRlcm5Qcm9wZXJ0aWVzKClcblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlUGF0dGVyblByb3BlcnRpZXMoKTogdm9pZCB7XG4gICAgICBmb3IgKGNvbnN0IHBhdCBvZiBwYXR0ZXJucykge1xuICAgICAgICBpZiAoY2hlY2tQcm9wZXJ0aWVzKSBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQpXG4gICAgICAgIGlmIChpdC5hbGxFcnJvcnMpIHtcbiAgICAgICAgICB2YWxpZGF0ZVByb3BlcnRpZXMocGF0KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdlbi52YXIodmFsaWQsIHRydWUpIC8vIFRPRE8gdmFyXG4gICAgICAgICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdClcbiAgICAgICAgICBnZW4uaWYodmFsaWQpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja01hdGNoaW5nUHJvcGVydGllcyhwYXQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgZm9yIChjb25zdCBwcm9wIGluIGNoZWNrUHJvcGVydGllcykge1xuICAgICAgICBpZiAobmV3IFJlZ0V4cChwYXQpLnRlc3QocHJvcCkpIHtcbiAgICAgICAgICBjaGVja1N0cmljdE1vZGUoXG4gICAgICAgICAgICBpdCxcbiAgICAgICAgICAgIGBwcm9wZXJ0eSAke3Byb3B9IG1hdGNoZXMgcGF0dGVybiAke3BhdH0gKHVzZSBhbGxvd01hdGNoaW5nUHJvcGVydGllcylgXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzKHBhdDogc3RyaW5nKTogdm9pZCB7XG4gICAgICBnZW4uZm9ySW4oXCJrZXlcIiwgZGF0YSwgKGtleSkgPT4ge1xuICAgICAgICBnZW4uaWYoX2Ake3VzZVBhdHRlcm4oY3h0LCBwYXQpfS50ZXN0KCR7a2V5fSlgLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWx3YXlzVmFsaWQgPSBhbHdheXNWYWxpZFBhdHRlcm5zLmluY2x1ZGVzKHBhdClcbiAgICAgICAgICBpZiAoIWFsd2F5c1ZhbGlkKSB7XG4gICAgICAgICAgICBjeHQuc3Vic2NoZW1hKFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAga2V5d29yZDogXCJwYXR0ZXJuUHJvcGVydGllc1wiLFxuICAgICAgICAgICAgICAgIHNjaGVtYVByb3A6IHBhdCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvcDoga2V5LFxuICAgICAgICAgICAgICAgIGRhdGFQcm9wVHlwZTogVHlwZS5TdHIsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZhbGlkXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGl0Lm9wdHMudW5ldmFsdWF0ZWQgJiYgcHJvcHMgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGdlbi5hc3NpZ24oX2Ake3Byb3BzfVske2tleX1dYCwgdHJ1ZSlcbiAgICAgICAgICB9IGVsc2UgaWYgKCFhbHdheXNWYWxpZCAmJiAhaXQuYWxsRXJyb3JzKSB7XG4gICAgICAgICAgICAvLyBjYW4gc2hvcnQtY2lyY3VpdCBpZiBgdW5ldmFsdWF0ZWRQcm9wZXJ0aWVzYCBpcyBub3Qgc3VwcG9ydGVkIChvcHRzLm5leHQgPT09IGZhbHNlKVxuICAgICAgICAgICAgLy8gb3IgaWYgYWxsIHByb3BlcnRpZXMgd2VyZSBldmFsdWF0ZWQgKHByb3BzID09PSB0cnVlKVxuICAgICAgICAgICAgZ2VuLmlmKG5vdCh2YWxpZCksICgpID0+IGdlbi5icmVhaygpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck5vUGFyYW1zLCBBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIE5vdEtleXdvcmRFcnJvciA9IEVycm9yTm9QYXJhbXM8XCJub3RcIiwgQW55U2NoZW1hPlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJub3RcIixcbiAgc2NoZW1hVHlwZTogW1wib2JqZWN0XCIsIFwiYm9vbGVhblwiXSxcbiAgdHJhY2tFcnJvcnM6IHRydWUsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgc2NoZW1hLCBpdH0gPSBjeHRcbiAgICBpZiAoYWx3YXlzVmFsaWRTY2hlbWEoaXQsIHNjaGVtYSkpIHtcbiAgICAgIGN4dC5mYWlsKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLm5hbWUoXCJ2YWxpZFwiKVxuICAgIGN4dC5zdWJzY2hlbWEoXG4gICAgICB7XG4gICAgICAgIGtleXdvcmQ6IFwibm90XCIsXG4gICAgICAgIGNvbXBvc2l0ZVJ1bGU6IHRydWUsXG4gICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgIGFsbEVycm9yczogZmFsc2UsXG4gICAgICB9LFxuICAgICAgdmFsaWRcbiAgICApXG5cbiAgICBjeHQuZmFpbFJlc3VsdChcbiAgICAgIHZhbGlkLFxuICAgICAgKCkgPT4gY3h0LnJlc2V0KCksXG4gICAgICAoKSA9PiBjeHQuZXJyb3IoKVxuICAgIClcbiAgfSxcbiAgZXJyb3I6IHttZXNzYWdlOiBcIm11c3QgTk9UIGJlIHZhbGlkXCJ9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBFcnJvck5vUGFyYW1zLCBBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQge3ZhbGlkYXRlVW5pb259IGZyb20gXCIuLi9jb2RlXCJcblxuZXhwb3J0IHR5cGUgQW55T2ZFcnJvciA9IEVycm9yTm9QYXJhbXM8XCJhbnlPZlwiLCBBbnlTY2hlbWFbXT5cblxuY29uc3QgZGVmOiBDb2RlS2V5d29yZERlZmluaXRpb24gPSB7XG4gIGtleXdvcmQ6IFwiYW55T2ZcIixcbiAgc2NoZW1hVHlwZTogXCJhcnJheVwiLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgY29kZTogdmFsaWRhdGVVbmlvbixcbiAgZXJyb3I6IHttZXNzYWdlOiBcIm11c3QgbWF0Y2ggYSBzY2hlbWEgaW4gYW55T2ZcIn0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtcbiAgQ29kZUtleXdvcmREZWZpbml0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQW55U2NoZW1hLFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7XywgTmFtZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5pbXBvcnQge2Fsd2F5c1ZhbGlkU2NoZW1hfSBmcm9tIFwiLi4vLi4vY29tcGlsZS91dGlsXCJcbmltcG9ydCB7U2NoZW1hQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZVwiXG5cbmV4cG9ydCB0eXBlIE9uZU9mRXJyb3IgPSBFcnJvck9iamVjdDxcbiAgXCJvbmVPZlwiLFxuICB7cGFzc2luZ1NjaGVtYXM6IFtudW1iZXIsIG51bWJlcl0gfCBudWxsfSxcbiAgQW55U2NoZW1hW11cbj5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6IFwibXVzdCBtYXRjaCBleGFjdGx5IG9uZSBzY2hlbWEgaW4gb25lT2ZcIixcbiAgcGFyYW1zOiAoe3BhcmFtc30pID0+IF9ge3Bhc3NpbmdTY2hlbWFzOiAke3BhcmFtcy5wYXNzaW5nfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJvbmVPZlwiLFxuICBzY2hlbWFUeXBlOiBcImFycmF5XCIsXG4gIHRyYWNrRXJyb3JzOiB0cnVlLFxuICBlcnJvcixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIHBhcmVudFNjaGVtYSwgaXR9ID0gY3h0XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYSkpIHRocm93IG5ldyBFcnJvcihcImFqdiBpbXBsZW1lbnRhdGlvbiBlcnJvclwiKVxuICAgIGlmIChpdC5vcHRzLmRpc2NyaW1pbmF0b3IgJiYgcGFyZW50U2NoZW1hLmRpc2NyaW1pbmF0b3IpIHJldHVyblxuICAgIGNvbnN0IHNjaEFycjogQW55U2NoZW1hW10gPSBzY2hlbWFcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCBmYWxzZSlcbiAgICBjb25zdCBwYXNzaW5nID0gZ2VuLmxldChcInBhc3NpbmdcIiwgbnVsbClcbiAgICBjb25zdCBzY2hWYWxpZCA9IGdlbi5uYW1lKFwiX3ZhbGlkXCIpXG4gICAgY3h0LnNldFBhcmFtcyh7cGFzc2luZ30pXG4gICAgLy8gVE9ETyBwb3NzaWJseSBmYWlsIHN0cmFpZ2h0IGF3YXkgKHdpdGggd2FybmluZyBvciBleGNlcHRpb24pIGlmIHRoZXJlIGFyZSB0d28gZW1wdHkgYWx3YXlzIHZhbGlkIHNjaGVtYXNcblxuICAgIGdlbi5ibG9jayh2YWxpZGF0ZU9uZU9mKVxuXG4gICAgY3h0LnJlc3VsdChcbiAgICAgIHZhbGlkLFxuICAgICAgKCkgPT4gY3h0LnJlc2V0KCksXG4gICAgICAoKSA9PiBjeHQuZXJyb3IodHJ1ZSlcbiAgICApXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZU9uZU9mKCk6IHZvaWQge1xuICAgICAgc2NoQXJyLmZvckVhY2goKHNjaDogQW55U2NoZW1hLCBpOiBudW1iZXIpID0+IHtcbiAgICAgICAgbGV0IHNjaEN4dDogU2NoZW1hQ3h0IHwgdW5kZWZpbmVkXG4gICAgICAgIGlmIChhbHdheXNWYWxpZFNjaGVtYShpdCwgc2NoKSkge1xuICAgICAgICAgIGdlbi52YXIoc2NoVmFsaWQsIHRydWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAga2V5d29yZDogXCJvbmVPZlwiLFxuICAgICAgICAgICAgICBzY2hlbWFQcm9wOiBpLFxuICAgICAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNjaFZhbGlkXG4gICAgICAgICAgKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgZ2VuXG4gICAgICAgICAgICAuaWYoX2Ake3NjaFZhbGlkfSAmJiAke3ZhbGlkfWApXG4gICAgICAgICAgICAuYXNzaWduKHZhbGlkLCBmYWxzZSlcbiAgICAgICAgICAgIC5hc3NpZ24ocGFzc2luZywgX2BbJHtwYXNzaW5nfSwgJHtpfV1gKVxuICAgICAgICAgICAgLmVsc2UoKVxuICAgICAgICB9XG5cbiAgICAgICAgZ2VuLmlmKHNjaFZhbGlkLCAoKSA9PiB7XG4gICAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgdHJ1ZSlcbiAgICAgICAgICBnZW4uYXNzaWduKHBhc3NpbmcsIGkpXG4gICAgICAgICAgaWYgKHNjaEN4dCkgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dCwgTmFtZSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7Q29kZUtleXdvcmREZWZpbml0aW9uLCBBbnlTY2hlbWF9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHthbHdheXNWYWxpZFNjaGVtYX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmNvbnN0IGRlZjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBcImFsbE9mXCIsXG4gIHNjaGVtYVR5cGU6IFwiYXJyYXlcIixcbiAgY29kZShjeHQ6IEtleXdvcmRDeHQpIHtcbiAgICBjb25zdCB7Z2VuLCBzY2hlbWEsIGl0fSA9IGN4dFxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghQXJyYXkuaXNBcnJheShzY2hlbWEpKSB0aHJvdyBuZXcgRXJyb3IoXCJhanYgaW1wbGVtZW50YXRpb24gZXJyb3JcIilcbiAgICBjb25zdCB2YWxpZCA9IGdlbi5uYW1lKFwidmFsaWRcIilcbiAgICBzY2hlbWEuZm9yRWFjaCgoc2NoOiBBbnlTY2hlbWEsIGk6IG51bWJlcikgPT4ge1xuICAgICAgaWYgKGFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2gpKSByZXR1cm5cbiAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe2tleXdvcmQ6IFwiYWxsT2ZcIiwgc2NoZW1hUHJvcDogaX0sIHZhbGlkKVxuICAgICAgY3h0Lm9rKHZhbGlkKVxuICAgICAgY3h0Lm1lcmdlRXZhbHVhdGVkKHNjaEN4dClcbiAgICB9KVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJpbXBvcnQgdHlwZSB7XG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgRXJyb3JPYmplY3QsXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEFueVNjaGVtYSxcbn0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcbmltcG9ydCB0eXBlIHtTY2hlbWFPYmpDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlXCJcbmltcG9ydCB0eXBlIHtLZXl3b3JkQ3h0fSBmcm9tIFwiLi4vLi4vY29tcGlsZS92YWxpZGF0ZVwiXG5pbXBvcnQge18sIHN0ciwgbm90LCBOYW1lfSBmcm9tIFwiLi4vLi4vY29tcGlsZS9jb2RlZ2VuXCJcbmltcG9ydCB7YWx3YXlzVmFsaWRTY2hlbWEsIGNoZWNrU3RyaWN0TW9kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIElmS2V5d29yZEVycm9yID0gRXJyb3JPYmplY3Q8XCJpZlwiLCB7ZmFpbGluZ0tleXdvcmQ6IHN0cmluZ30sIEFueVNjaGVtYT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7cGFyYW1zfSkgPT4gc3RyYG11c3QgbWF0Y2ggXCIke3BhcmFtcy5pZkNsYXVzZX1cIiBzY2hlbWFgLFxuICBwYXJhbXM6ICh7cGFyYW1zfSkgPT4gX2B7ZmFpbGluZ0tleXdvcmQ6ICR7cGFyYW1zLmlmQ2xhdXNlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJpZlwiLFxuICBzY2hlbWFUeXBlOiBbXCJvYmplY3RcIiwgXCJib29sZWFuXCJdLFxuICB0cmFja0Vycm9yczogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0KSB7XG4gICAgY29uc3Qge2dlbiwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBpZiAocGFyZW50U2NoZW1hLnRoZW4gPT09IHVuZGVmaW5lZCAmJiBwYXJlbnRTY2hlbWEuZWxzZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjaGVja1N0cmljdE1vZGUoaXQsICdcImlmXCIgd2l0aG91dCBcInRoZW5cIiBhbmQgXCJlbHNlXCIgaXMgaWdub3JlZCcpXG4gICAgfVxuICAgIGNvbnN0IGhhc1RoZW4gPSBoYXNTY2hlbWEoaXQsIFwidGhlblwiKVxuICAgIGNvbnN0IGhhc0Vsc2UgPSBoYXNTY2hlbWEoaXQsIFwiZWxzZVwiKVxuICAgIGlmICghaGFzVGhlbiAmJiAhaGFzRWxzZSkgcmV0dXJuXG5cbiAgICBjb25zdCB2YWxpZCA9IGdlbi5sZXQoXCJ2YWxpZFwiLCB0cnVlKVxuICAgIGNvbnN0IHNjaFZhbGlkID0gZ2VuLm5hbWUoXCJfdmFsaWRcIilcbiAgICB2YWxpZGF0ZUlmKClcbiAgICBjeHQucmVzZXQoKVxuXG4gICAgaWYgKGhhc1RoZW4gJiYgaGFzRWxzZSkge1xuICAgICAgY29uc3QgaWZDbGF1c2UgPSBnZW4ubGV0KFwiaWZDbGF1c2VcIilcbiAgICAgIGN4dC5zZXRQYXJhbXMoe2lmQ2xhdXNlfSlcbiAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIsIGlmQ2xhdXNlKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIsIGlmQ2xhdXNlKSlcbiAgICB9IGVsc2UgaWYgKGhhc1RoZW4pIHtcbiAgICAgIGdlbi5pZihzY2hWYWxpZCwgdmFsaWRhdGVDbGF1c2UoXCJ0aGVuXCIpKVxuICAgIH0gZWxzZSB7XG4gICAgICBnZW4uaWYobm90KHNjaFZhbGlkKSwgdmFsaWRhdGVDbGF1c2UoXCJlbHNlXCIpKVxuICAgIH1cblxuICAgIGN4dC5wYXNzKHZhbGlkLCAoKSA9PiBjeHQuZXJyb3IodHJ1ZSkpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZUlmKCk6IHZvaWQge1xuICAgICAgY29uc3Qgc2NoQ3h0ID0gY3h0LnN1YnNjaGVtYShcbiAgICAgICAge1xuICAgICAgICAgIGtleXdvcmQ6IFwiaWZcIixcbiAgICAgICAgICBjb21wb3NpdGVSdWxlOiB0cnVlLFxuICAgICAgICAgIGNyZWF0ZUVycm9yczogZmFsc2UsXG4gICAgICAgICAgYWxsRXJyb3JzOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgc2NoVmFsaWRcbiAgICAgIClcbiAgICAgIGN4dC5tZXJnZUV2YWx1YXRlZChzY2hDeHQpXG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVDbGF1c2Uoa2V5d29yZDogc3RyaW5nLCBpZkNsYXVzZT86IE5hbWUpOiAoKSA9PiB2b2lkIHtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNjaEN4dCA9IGN4dC5zdWJzY2hlbWEoe2tleXdvcmR9LCBzY2hWYWxpZClcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgc2NoVmFsaWQpXG4gICAgICAgIGN4dC5tZXJnZVZhbGlkRXZhbHVhdGVkKHNjaEN4dCwgdmFsaWQpXG4gICAgICAgIGlmIChpZkNsYXVzZSkgZ2VuLmFzc2lnbihpZkNsYXVzZSwgX2Ake2tleXdvcmR9YClcbiAgICAgICAgZWxzZSBjeHQuc2V0UGFyYW1zKHtpZkNsYXVzZToga2V5d29yZH0pXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5mdW5jdGlvbiBoYXNTY2hlbWEoaXQ6IFNjaGVtYU9iakN4dCwga2V5d29yZDogc3RyaW5nKTogYm9vbGVhbiB7XG4gIGNvbnN0IHNjaGVtYSA9IGl0LnNjaGVtYVtrZXl3b3JkXVxuICByZXR1cm4gc2NoZW1hICE9PSB1bmRlZmluZWQgJiYgIWFsd2F5c1ZhbGlkU2NoZW1hKGl0LCBzY2hlbWEpXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtDb2RlS2V5d29yZERlZmluaXRpb259IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgdHlwZSB7S2V5d29yZEN4dH0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdmFsaWRhdGVcIlxuaW1wb3J0IHtjaGVja1N0cmljdE1vZGV9IGZyb20gXCIuLi8uLi9jb21waWxlL3V0aWxcIlxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogW1widGhlblwiLCBcImVsc2VcIl0sXG4gIHNjaGVtYVR5cGU6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIGNvZGUoe2tleXdvcmQsIHBhcmVudFNjaGVtYSwgaXR9OiBLZXl3b3JkQ3h0KSB7XG4gICAgaWYgKHBhcmVudFNjaGVtYS5pZiA9PT0gdW5kZWZpbmVkKSBjaGVja1N0cmljdE1vZGUoaXQsIGBcIiR7a2V5d29yZH1cIiB3aXRob3V0IFwiaWZcIiBpcyBpZ25vcmVkYClcbiAgfSxcbn1cblxuZXhwb3J0IGRlZmF1bHQgZGVmXG4iLCAiaW1wb3J0IHR5cGUge0Vycm9yTm9QYXJhbXMsIFZvY2FidWxhcnl9IGZyb20gXCIuLi8uLi90eXBlc1wiXG5pbXBvcnQgYWRkaXRpb25hbEl0ZW1zLCB7QWRkaXRpb25hbEl0ZW1zRXJyb3J9IGZyb20gXCIuL2FkZGl0aW9uYWxJdGVtc1wiXG5pbXBvcnQgcHJlZml4SXRlbXMgZnJvbSBcIi4vcHJlZml4SXRlbXNcIlxuaW1wb3J0IGl0ZW1zIGZyb20gXCIuL2l0ZW1zXCJcbmltcG9ydCBpdGVtczIwMjAsIHtJdGVtc0Vycm9yfSBmcm9tIFwiLi9pdGVtczIwMjBcIlxuaW1wb3J0IGNvbnRhaW5zLCB7Q29udGFpbnNFcnJvcn0gZnJvbSBcIi4vY29udGFpbnNcIlxuaW1wb3J0IGRlcGVuZGVuY2llcywge0RlcGVuZGVuY2llc0Vycm9yfSBmcm9tIFwiLi9kZXBlbmRlbmNpZXNcIlxuaW1wb3J0IHByb3BlcnR5TmFtZXMsIHtQcm9wZXJ0eU5hbWVzRXJyb3J9IGZyb20gXCIuL3Byb3BlcnR5TmFtZXNcIlxuaW1wb3J0IGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCB7QWRkaXRpb25hbFByb3BlcnRpZXNFcnJvcn0gZnJvbSBcIi4vYWRkaXRpb25hbFByb3BlcnRpZXNcIlxuaW1wb3J0IHByb3BlcnRpZXMgZnJvbSBcIi4vcHJvcGVydGllc1wiXG5pbXBvcnQgcGF0dGVyblByb3BlcnRpZXMgZnJvbSBcIi4vcGF0dGVyblByb3BlcnRpZXNcIlxuaW1wb3J0IG5vdEtleXdvcmQsIHtOb3RLZXl3b3JkRXJyb3J9IGZyb20gXCIuL25vdFwiXG5pbXBvcnQgYW55T2YsIHtBbnlPZkVycm9yfSBmcm9tIFwiLi9hbnlPZlwiXG5pbXBvcnQgb25lT2YsIHtPbmVPZkVycm9yfSBmcm9tIFwiLi9vbmVPZlwiXG5pbXBvcnQgYWxsT2YgZnJvbSBcIi4vYWxsT2ZcIlxuaW1wb3J0IGlmS2V5d29yZCwge0lmS2V5d29yZEVycm9yfSBmcm9tIFwiLi9pZlwiXG5pbXBvcnQgdGhlbkVsc2UgZnJvbSBcIi4vdGhlbkVsc2VcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRBcHBsaWNhdG9yKGRyYWZ0MjAyMCA9IGZhbHNlKTogVm9jYWJ1bGFyeSB7XG4gIGNvbnN0IGFwcGxpY2F0b3IgPSBbXG4gICAgLy8gYW55XG4gICAgbm90S2V5d29yZCxcbiAgICBhbnlPZixcbiAgICBvbmVPZixcbiAgICBhbGxPZixcbiAgICBpZktleXdvcmQsXG4gICAgdGhlbkVsc2UsXG4gICAgLy8gb2JqZWN0XG4gICAgcHJvcGVydHlOYW1lcyxcbiAgICBhZGRpdGlvbmFsUHJvcGVydGllcyxcbiAgICBkZXBlbmRlbmNpZXMsXG4gICAgcHJvcGVydGllcyxcbiAgICBwYXR0ZXJuUHJvcGVydGllcyxcbiAgXVxuICAvLyBhcnJheVxuICBpZiAoZHJhZnQyMDIwKSBhcHBsaWNhdG9yLnB1c2gocHJlZml4SXRlbXMsIGl0ZW1zMjAyMClcbiAgZWxzZSBhcHBsaWNhdG9yLnB1c2goYWRkaXRpb25hbEl0ZW1zLCBpdGVtcylcbiAgYXBwbGljYXRvci5wdXNoKGNvbnRhaW5zKVxuICByZXR1cm4gYXBwbGljYXRvclxufVxuXG5leHBvcnQgdHlwZSBBcHBsaWNhdG9yS2V5d29yZEVycm9yID1cbiAgfCBFcnJvck5vUGFyYW1zPFwiZmFsc2Ugc2NoZW1hXCI+XG4gIHwgQWRkaXRpb25hbEl0ZW1zRXJyb3JcbiAgfCBJdGVtc0Vycm9yXG4gIHwgQ29udGFpbnNFcnJvclxuICB8IEFkZGl0aW9uYWxQcm9wZXJ0aWVzRXJyb3JcbiAgfCBEZXBlbmRlbmNpZXNFcnJvclxuICB8IElmS2V5d29yZEVycm9yXG4gIHwgQW55T2ZFcnJvclxuICB8IE9uZU9mRXJyb3JcbiAgfCBOb3RLZXl3b3JkRXJyb3JcbiAgfCBQcm9wZXJ0eU5hbWVzRXJyb3JcbiIsICJpbXBvcnQgdHlwZSB7XG4gIEFkZGVkRm9ybWF0LFxuICBGb3JtYXRWYWxpZGF0b3IsXG4gIEFzeW5jRm9ybWF0VmFsaWRhdG9yLFxuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIEtleXdvcmRFcnJvckRlZmluaXRpb24sXG4gIEVycm9yT2JqZWN0LFxufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7Xywgc3RyLCBuaWwsIG9yLCBDb2RlLCBnZXRQcm9wZXJ0eSwgcmVnZXhwQ29kZX0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvY29kZWdlblwiXG5cbnR5cGUgRm9ybWF0VmFsaWRhdGUgPVxuICB8IEZvcm1hdFZhbGlkYXRvcjxzdHJpbmc+XG4gIHwgRm9ybWF0VmFsaWRhdG9yPG51bWJlcj5cbiAgfCBBc3luY0Zvcm1hdFZhbGlkYXRvcjxzdHJpbmc+XG4gIHwgQXN5bmNGb3JtYXRWYWxpZGF0b3I8bnVtYmVyPlxuICB8IFJlZ0V4cFxuICB8IHN0cmluZ1xuICB8IHRydWVcblxuZXhwb3J0IHR5cGUgRm9ybWF0RXJyb3IgPSBFcnJvck9iamVjdDxcImZvcm1hdFwiLCB7Zm9ybWF0OiBzdHJpbmd9LCBzdHJpbmcgfCB7JGRhdGE6IHN0cmluZ30+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3NjaGVtYUNvZGV9KSA9PiBzdHJgbXVzdCBtYXRjaCBmb3JtYXQgXCIke3NjaGVtYUNvZGV9XCJgLFxuICBwYXJhbXM6ICh7c2NoZW1hQ29kZX0pID0+IF9ge2Zvcm1hdDogJHtzY2hlbWFDb2RlfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJmb3JtYXRcIixcbiAgdHlwZTogW1wibnVtYmVyXCIsIFwic3RyaW5nXCJdLFxuICBzY2hlbWFUeXBlOiBcInN0cmluZ1wiLFxuICAkZGF0YTogdHJ1ZSxcbiAgZXJyb3IsXG4gIGNvZGUoY3h0OiBLZXl3b3JkQ3h0LCBydWxlVHlwZT86IHN0cmluZykge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsICRkYXRhLCBzY2hlbWEsIHNjaGVtYUNvZGUsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvcHRzLCBlcnJTY2hlbWFQYXRoLCBzY2hlbWFFbnYsIHNlbGZ9ID0gaXRcbiAgICBpZiAoIW9wdHMudmFsaWRhdGVGb3JtYXRzKSByZXR1cm5cblxuICAgIGlmICgkZGF0YSkgdmFsaWRhdGUkRGF0YUZvcm1hdCgpXG4gICAgZWxzZSB2YWxpZGF0ZUZvcm1hdCgpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCk6IHZvaWQge1xuICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgIH0pXG4gICAgICBjb25zdCBmRGVmID0gZ2VuLmNvbnN0KFwiZkRlZlwiLCBfYCR7Zm10c31bJHtzY2hlbWFDb2RlfV1gKVxuICAgICAgY29uc3QgZlR5cGUgPSBnZW4ubGV0KFwiZlR5cGVcIilcbiAgICAgIGNvbnN0IGZvcm1hdCA9IGdlbi5sZXQoXCJmb3JtYXRcIilcbiAgICAgIC8vIFRPRE8gc2ltcGxpZnlcbiAgICAgIGdlbi5pZihcbiAgICAgICAgX2B0eXBlb2YgJHtmRGVmfSA9PSBcIm9iamVjdFwiICYmICEoJHtmRGVmfSBpbnN0YW5jZW9mIFJlZ0V4cClgLFxuICAgICAgICAoKSA9PiBnZW4uYXNzaWduKGZUeXBlLCBfYCR7ZkRlZn0udHlwZSB8fCBcInN0cmluZ1wiYCkuYXNzaWduKGZvcm1hdCwgX2Ake2ZEZWZ9LnZhbGlkYXRlYCksXG4gICAgICAgICgpID0+IGdlbi5hc3NpZ24oZlR5cGUsIF9gXCJzdHJpbmdcImApLmFzc2lnbihmb3JtYXQsIGZEZWYpXG4gICAgICApXG4gICAgICBjeHQuZmFpbCRkYXRhKG9yKHVua25vd25GbXQoKSwgaW52YWxpZEZtdCgpKSlcblxuICAgICAgZnVuY3Rpb24gdW5rbm93bkZtdCgpOiBDb2RlIHtcbiAgICAgICAgaWYgKG9wdHMuc3RyaWN0U2NoZW1hID09PSBmYWxzZSkgcmV0dXJuIG5pbFxuICAgICAgICByZXR1cm4gX2Ake3NjaGVtYUNvZGV9ICYmICEke2Zvcm1hdH1gXG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGludmFsaWRGbXQoKTogQ29kZSB7XG4gICAgICAgIGNvbnN0IGNhbGxGb3JtYXQgPSBzY2hlbWFFbnYuJGFzeW5jXG4gICAgICAgICAgPyBfYCgke2ZEZWZ9LmFzeW5jID8gYXdhaXQgJHtmb3JtYXR9KCR7ZGF0YX0pIDogJHtmb3JtYXR9KCR7ZGF0YX0pKWBcbiAgICAgICAgICA6IF9gJHtmb3JtYXR9KCR7ZGF0YX0pYFxuICAgICAgICBjb25zdCB2YWxpZERhdGEgPSBfYCh0eXBlb2YgJHtmb3JtYXR9ID09IFwiZnVuY3Rpb25cIiA/ICR7Y2FsbEZvcm1hdH0gOiAke2Zvcm1hdH0udGVzdCgke2RhdGF9KSlgXG4gICAgICAgIHJldHVybiBfYCR7Zm9ybWF0fSAmJiAke2Zvcm1hdH0gIT09IHRydWUgJiYgJHtmVHlwZX0gPT09ICR7cnVsZVR5cGV9ICYmICEke3ZhbGlkRGF0YX1gXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoKTogdm9pZCB7XG4gICAgICBjb25zdCBmb3JtYXREZWY6IEFkZGVkRm9ybWF0IHwgdW5kZWZpbmVkID0gc2VsZi5mb3JtYXRzW3NjaGVtYV1cbiAgICAgIGlmICghZm9ybWF0RGVmKSB7XG4gICAgICAgIHVua25vd25Gb3JtYXQoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGlmIChmb3JtYXREZWYgPT09IHRydWUpIHJldHVyblxuICAgICAgY29uc3QgW2ZtdFR5cGUsIGZvcm1hdCwgZm10UmVmXSA9IGdldEZvcm1hdChmb3JtYXREZWYpXG4gICAgICBpZiAoZm10VHlwZSA9PT0gcnVsZVR5cGUpIGN4dC5wYXNzKHZhbGlkQ29uZGl0aW9uKCkpXG5cbiAgICAgIGZ1bmN0aW9uIHVua25vd25Gb3JtYXQoKTogdm9pZCB7XG4gICAgICAgIGlmIChvcHRzLnN0cmljdFNjaGVtYSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBzZWxmLmxvZ2dlci53YXJuKHVua25vd25Nc2coKSlcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5rbm93bk1zZygpKVxuXG4gICAgICAgIGZ1bmN0aW9uIHVua25vd25Nc2coKTogc3RyaW5nIHtcbiAgICAgICAgICByZXR1cm4gYHVua25vd24gZm9ybWF0IFwiJHtzY2hlbWEgYXMgc3RyaW5nfVwiIGlnbm9yZWQgaW4gc2NoZW1hIGF0IHBhdGggXCIke2VyclNjaGVtYVBhdGh9XCJgXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gZ2V0Rm9ybWF0KGZtdERlZjogQWRkZWRGb3JtYXQpOiBbc3RyaW5nLCBGb3JtYXRWYWxpZGF0ZSwgQ29kZV0ge1xuICAgICAgICBjb25zdCBjb2RlID1cbiAgICAgICAgICBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHBcbiAgICAgICAgICAgID8gcmVnZXhwQ29kZShmbXREZWYpXG4gICAgICAgICAgICA6IG9wdHMuY29kZS5mb3JtYXRzXG4gICAgICAgICAgICA/IF9gJHtvcHRzLmNvZGUuZm9ybWF0c30ke2dldFByb3BlcnR5KHNjaGVtYSl9YFxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICAgICAgY29uc3QgZm10ID0gZ2VuLnNjb3BlVmFsdWUoXCJmb3JtYXRzXCIsIHtrZXk6IHNjaGVtYSwgcmVmOiBmbXREZWYsIGNvZGV9KVxuICAgICAgICBpZiAodHlwZW9mIGZtdERlZiA9PSBcIm9iamVjdFwiICYmICEoZm10RGVmIGluc3RhbmNlb2YgUmVnRXhwKSkge1xuICAgICAgICAgIHJldHVybiBbZm10RGVmLnR5cGUgfHwgXCJzdHJpbmdcIiwgZm10RGVmLnZhbGlkYXRlLCBfYCR7Zm10fS52YWxpZGF0ZWBdXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gW1wic3RyaW5nXCIsIGZtdERlZiwgZm10XVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB2YWxpZENvbmRpdGlvbigpOiBDb2RlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JtYXREZWYgPT0gXCJvYmplY3RcIiAmJiAhKGZvcm1hdERlZiBpbnN0YW5jZW9mIFJlZ0V4cCkgJiYgZm9ybWF0RGVmLmFzeW5jKSB7XG4gICAgICAgICAgaWYgKCFzY2hlbWFFbnYuJGFzeW5jKSB0aHJvdyBuZXcgRXJyb3IoXCJhc3luYyBmb3JtYXQgaW4gc3luYyBzY2hlbWFcIilcbiAgICAgICAgICByZXR1cm4gX2Bhd2FpdCAke2ZtdFJlZn0oJHtkYXRhfSlgXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBmb3JtYXQgPT0gXCJmdW5jdGlvblwiID8gX2Ake2ZtdFJlZn0oJHtkYXRhfSlgIDogX2Ake2ZtdFJlZn0udGVzdCgke2RhdGF9KWBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG59XG5cbmV4cG9ydCBkZWZhdWx0IGRlZlxuIiwgImltcG9ydCB0eXBlIHtWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IGZvcm1hdEtleXdvcmQgZnJvbSBcIi4vZm9ybWF0XCJcblxuY29uc3QgZm9ybWF0OiBWb2NhYnVsYXJ5ID0gW2Zvcm1hdEtleXdvcmRdXG5cbmV4cG9ydCBkZWZhdWx0IGZvcm1hdFxuIiwgImltcG9ydCB0eXBlIHtWb2NhYnVsYXJ5fSBmcm9tIFwiLi4vdHlwZXNcIlxuXG5leHBvcnQgY29uc3QgbWV0YWRhdGFWb2NhYnVsYXJ5OiBWb2NhYnVsYXJ5ID0gW1xuICBcInRpdGxlXCIsXG4gIFwiZGVzY3JpcHRpb25cIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwiZGVwcmVjYXRlZFwiLFxuICBcInJlYWRPbmx5XCIsXG4gIFwid3JpdGVPbmx5XCIsXG4gIFwiZXhhbXBsZXNcIixcbl1cblxuZXhwb3J0IGNvbnN0IGNvbnRlbnRWb2NhYnVsYXJ5OiBWb2NhYnVsYXJ5ID0gW1xuICBcImNvbnRlbnRNZWRpYVR5cGVcIixcbiAgXCJjb250ZW50RW5jb2RpbmdcIixcbiAgXCJjb250ZW50U2NoZW1hXCIsXG5dXG4iLCAiaW1wb3J0IHR5cGUge1ZvY2FidWxhcnl9IGZyb20gXCIuLi90eXBlc1wiXG5pbXBvcnQgY29yZVZvY2FidWxhcnkgZnJvbSBcIi4vY29yZVwiXG5pbXBvcnQgdmFsaWRhdGlvblZvY2FidWxhcnkgZnJvbSBcIi4vdmFsaWRhdGlvblwiXG5pbXBvcnQgZ2V0QXBwbGljYXRvclZvY2FidWxhcnkgZnJvbSBcIi4vYXBwbGljYXRvclwiXG5pbXBvcnQgZm9ybWF0Vm9jYWJ1bGFyeSBmcm9tIFwiLi9mb3JtYXRcIlxuaW1wb3J0IHttZXRhZGF0YVZvY2FidWxhcnksIGNvbnRlbnRWb2NhYnVsYXJ5fSBmcm9tIFwiLi9tZXRhZGF0YVwiXG5cbmNvbnN0IGRyYWZ0N1ZvY2FidWxhcmllczogVm9jYWJ1bGFyeVtdID0gW1xuICBjb3JlVm9jYWJ1bGFyeSxcbiAgdmFsaWRhdGlvblZvY2FidWxhcnksXG4gIGdldEFwcGxpY2F0b3JWb2NhYnVsYXJ5KCksXG4gIGZvcm1hdFZvY2FidWxhcnksXG4gIG1ldGFkYXRhVm9jYWJ1bGFyeSxcbiAgY29udGVudFZvY2FidWxhcnksXG5dXG5cbmV4cG9ydCBkZWZhdWx0IGRyYWZ0N1ZvY2FidWxhcmllc1xuIiwgImltcG9ydCB0eXBlIHtFcnJvck9iamVjdH0gZnJvbSBcIi4uLy4uL3R5cGVzXCJcblxuZXhwb3J0IGVudW0gRGlzY3JFcnJvciB7XG4gIFRhZyA9IFwidGFnXCIsXG4gIE1hcHBpbmcgPSBcIm1hcHBpbmdcIixcbn1cblxuZXhwb3J0IHR5cGUgRGlzY3JFcnJvck9iajxFIGV4dGVuZHMgRGlzY3JFcnJvcj4gPSBFcnJvck9iamVjdDxcbiAgXCJkaXNjcmltaW5hdG9yXCIsXG4gIHtlcnJvcjogRTsgdGFnOiBzdHJpbmc7IHRhZ1ZhbHVlOiB1bmtub3dufSxcbiAgc3RyaW5nXG4+XG4iLCAiaW1wb3J0IHR5cGUge0NvZGVLZXl3b3JkRGVmaW5pdGlvbiwgQW55U2NoZW1hT2JqZWN0LCBLZXl3b3JkRXJyb3JEZWZpbml0aW9ufSBmcm9tIFwiLi4vLi4vdHlwZXNcIlxuaW1wb3J0IHR5cGUge0tleXdvcmRDeHR9IGZyb20gXCIuLi8uLi9jb21waWxlL3ZhbGlkYXRlXCJcbmltcG9ydCB7XywgZ2V0UHJvcGVydHksIE5hbWV9IGZyb20gXCIuLi8uLi9jb21waWxlL2NvZGVnZW5cIlxuaW1wb3J0IHtEaXNjckVycm9yLCBEaXNjckVycm9yT2JqfSBmcm9tIFwiLi4vZGlzY3JpbWluYXRvci90eXBlc1wiXG5pbXBvcnQge3Jlc29sdmVSZWYsIFNjaGVtYUVudn0gZnJvbSBcIi4uLy4uL2NvbXBpbGVcIlxuaW1wb3J0IE1pc3NpbmdSZWZFcnJvciBmcm9tIFwiLi4vLi4vY29tcGlsZS9yZWZfZXJyb3JcIlxuaW1wb3J0IHtzY2hlbWFIYXNSdWxlc0J1dFJlZn0gZnJvbSBcIi4uLy4uL2NvbXBpbGUvdXRpbFwiXG5cbmV4cG9ydCB0eXBlIERpc2NyaW1pbmF0b3JFcnJvciA9IERpc2NyRXJyb3JPYmo8RGlzY3JFcnJvci5UYWc+IHwgRGlzY3JFcnJvck9iajxEaXNjckVycm9yLk1hcHBpbmc+XG5cbmNvbnN0IGVycm9yOiBLZXl3b3JkRXJyb3JEZWZpbml0aW9uID0ge1xuICBtZXNzYWdlOiAoe3BhcmFtczoge2Rpc2NyRXJyb3IsIHRhZ05hbWV9fSkgPT5cbiAgICBkaXNjckVycm9yID09PSBEaXNjckVycm9yLlRhZ1xuICAgICAgPyBgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgc3RyaW5nYFxuICAgICAgOiBgdmFsdWUgb2YgdGFnIFwiJHt0YWdOYW1lfVwiIG11c3QgYmUgaW4gb25lT2ZgLFxuICBwYXJhbXM6ICh7cGFyYW1zOiB7ZGlzY3JFcnJvciwgdGFnLCB0YWdOYW1lfX0pID0+XG4gICAgX2B7ZXJyb3I6ICR7ZGlzY3JFcnJvcn0sIHRhZzogJHt0YWdOYW1lfSwgdGFnVmFsdWU6ICR7dGFnfX1gLFxufVxuXG5jb25zdCBkZWY6IENvZGVLZXl3b3JkRGVmaW5pdGlvbiA9IHtcbiAga2V5d29yZDogXCJkaXNjcmltaW5hdG9yXCIsXG4gIHR5cGU6IFwib2JqZWN0XCIsXG4gIHNjaGVtYVR5cGU6IFwib2JqZWN0XCIsXG4gIGVycm9yLFxuICBjb2RlKGN4dDogS2V5d29yZEN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsIHNjaGVtYSwgcGFyZW50U2NoZW1hLCBpdH0gPSBjeHRcbiAgICBjb25zdCB7b25lT2Z9ID0gcGFyZW50U2NoZW1hXG4gICAgaWYgKCFpdC5vcHRzLmRpc2NyaW1pbmF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIGRpc2NyaW1pbmF0b3Igb3B0aW9uXCIpXG4gICAgfVxuICAgIGNvbnN0IHRhZ05hbWUgPSBzY2hlbWEucHJvcGVydHlOYW1lXG4gICAgaWYgKHR5cGVvZiB0YWdOYW1lICE9IFwic3RyaW5nXCIpIHRocm93IG5ldyBFcnJvcihcImRpc2NyaW1pbmF0b3I6IHJlcXVpcmVzIHByb3BlcnR5TmFtZVwiKVxuICAgIGlmIChzY2hlbWEubWFwcGluZykgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogbWFwcGluZyBpcyBub3Qgc3VwcG9ydGVkXCIpXG4gICAgaWYgKCFvbmVPZikgdGhyb3cgbmV3IEVycm9yKFwiZGlzY3JpbWluYXRvcjogcmVxdWlyZXMgb25lT2Yga2V5d29yZFwiKVxuICAgIGNvbnN0IHZhbGlkID0gZ2VuLmxldChcInZhbGlkXCIsIGZhbHNlKVxuICAgIGNvbnN0IHRhZyA9IGdlbi5jb25zdChcInRhZ1wiLCBfYCR7ZGF0YX0ke2dldFByb3BlcnR5KHRhZ05hbWUpfWApXG4gICAgZ2VuLmlmKFxuICAgICAgX2B0eXBlb2YgJHt0YWd9ID09IFwic3RyaW5nXCJgLFxuICAgICAgKCkgPT4gdmFsaWRhdGVNYXBwaW5nKCksXG4gICAgICAoKSA9PiBjeHQuZXJyb3IoZmFsc2UsIHtkaXNjckVycm9yOiBEaXNjckVycm9yLlRhZywgdGFnLCB0YWdOYW1lfSlcbiAgICApXG4gICAgY3h0Lm9rKHZhbGlkKVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGVNYXBwaW5nKCk6IHZvaWQge1xuICAgICAgY29uc3QgbWFwcGluZyA9IGdldE1hcHBpbmcoKVxuICAgICAgZ2VuLmlmKGZhbHNlKVxuICAgICAgZm9yIChjb25zdCB0YWdWYWx1ZSBpbiBtYXBwaW5nKSB7XG4gICAgICAgIGdlbi5lbHNlSWYoX2Ake3RhZ30gPT09ICR7dGFnVmFsdWV9YClcbiAgICAgICAgZ2VuLmFzc2lnbih2YWxpZCwgYXBwbHlUYWdTY2hlbWEobWFwcGluZ1t0YWdWYWx1ZV0pKVxuICAgICAgfVxuICAgICAgZ2VuLmVsc2UoKVxuICAgICAgY3h0LmVycm9yKGZhbHNlLCB7ZGlzY3JFcnJvcjogRGlzY3JFcnJvci5NYXBwaW5nLCB0YWcsIHRhZ05hbWV9KVxuICAgICAgZ2VuLmVuZElmKClcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVRhZ1NjaGVtYShzY2hlbWFQcm9wPzogbnVtYmVyKTogTmFtZSB7XG4gICAgICBjb25zdCBfdmFsaWQgPSBnZW4ubmFtZShcInZhbGlkXCIpXG4gICAgICBjb25zdCBzY2hDeHQgPSBjeHQuc3Vic2NoZW1hKHtrZXl3b3JkOiBcIm9uZU9mXCIsIHNjaGVtYVByb3B9LCBfdmFsaWQpXG4gICAgICBjeHQubWVyZ2VFdmFsdWF0ZWQoc2NoQ3h0LCBOYW1lKVxuICAgICAgcmV0dXJuIF92YWxpZFxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldE1hcHBpbmcoKToge1tUIGluIHN0cmluZ10/OiBudW1iZXJ9IHtcbiAgICAgIGNvbnN0IG9uZU9mTWFwcGluZzoge1tUIGluIHN0cmluZ10/OiBudW1iZXJ9ID0ge31cbiAgICAgIGNvbnN0IHRvcFJlcXVpcmVkID0gaGFzUmVxdWlyZWQocGFyZW50U2NoZW1hKVxuICAgICAgbGV0IHRhZ1JlcXVpcmVkID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvbmVPZi5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgc2NoID0gb25lT2ZbaV1cbiAgICAgICAgaWYgKHNjaD8uJHJlZiAmJiAhc2NoZW1hSGFzUnVsZXNCdXRSZWYoc2NoLCBpdC5zZWxmLlJVTEVTKSkge1xuICAgICAgICAgIGNvbnN0IHJlZiA9IHNjaC4kcmVmXG4gICAgICAgICAgc2NoID0gcmVzb2x2ZVJlZi5jYWxsKGl0LnNlbGYsIGl0LnNjaGVtYUVudi5yb290LCBpdC5iYXNlSWQsIHJlZilcbiAgICAgICAgICBpZiAoc2NoIGluc3RhbmNlb2YgU2NoZW1hRW52KSBzY2ggPSBzY2guc2NoZW1hXG4gICAgICAgICAgaWYgKHNjaCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgTWlzc2luZ1JlZkVycm9yKGl0Lm9wdHMudXJpUmVzb2x2ZXIsIGl0LmJhc2VJZCwgcmVmKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3BTY2ggPSBzY2g/LnByb3BlcnRpZXM/Llt0YWdOYW1lXVxuICAgICAgICBpZiAodHlwZW9mIHByb3BTY2ggIT0gXCJvYmplY3RcIikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBkaXNjcmltaW5hdG9yOiBvbmVPZiBzdWJzY2hlbWFzIChvciByZWZlcmVuY2VkIHNjaGVtYXMpIG11c3QgaGF2ZSBcInByb3BlcnRpZXMvJHt0YWdOYW1lfVwiYFxuICAgICAgICAgIClcbiAgICAgICAgfVxuICAgICAgICB0YWdSZXF1aXJlZCA9IHRhZ1JlcXVpcmVkICYmICh0b3BSZXF1aXJlZCB8fCBoYXNSZXF1aXJlZChzY2gpKVxuICAgICAgICBhZGRNYXBwaW5ncyhwcm9wU2NoLCBpKVxuICAgICAgfVxuICAgICAgaWYgKCF0YWdSZXF1aXJlZCkgdGhyb3cgbmV3IEVycm9yKGBkaXNjcmltaW5hdG9yOiBcIiR7dGFnTmFtZX1cIiBtdXN0IGJlIHJlcXVpcmVkYClcbiAgICAgIHJldHVybiBvbmVPZk1hcHBpbmdcblxuICAgICAgZnVuY3Rpb24gaGFzUmVxdWlyZWQoe3JlcXVpcmVkfTogQW55U2NoZW1hT2JqZWN0KTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHJlcXVpcmVkKSAmJiByZXF1aXJlZC5pbmNsdWRlcyh0YWdOYW1lKVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5ncyhzY2g6IEFueVNjaGVtYU9iamVjdCwgaTogbnVtYmVyKTogdm9pZCB7XG4gICAgICAgIGlmIChzY2guY29uc3QpIHtcbiAgICAgICAgICBhZGRNYXBwaW5nKHNjaC5jb25zdCwgaSlcbiAgICAgICAgfSBlbHNlIGlmIChzY2guZW51bSkge1xuICAgICAgICAgIGZvciAoY29uc3QgdGFnVmFsdWUgb2Ygc2NoLmVudW0pIHtcbiAgICAgICAgICAgIGFkZE1hcHBpbmcodGFnVmFsdWUsIGkpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCJwcm9wZXJ0aWVzLyR7dGFnTmFtZX1cIiBtdXN0IGhhdmUgXCJjb25zdFwiIG9yIFwiZW51bVwiYClcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBhZGRNYXBwaW5nKHRhZ1ZhbHVlOiB1bmtub3duLCBpOiBudW1iZXIpOiB2b2lkIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0YWdWYWx1ZSAhPSBcInN0cmluZ1wiIHx8IHRhZ1ZhbHVlIGluIG9uZU9mTWFwcGluZykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlzY3JpbWluYXRvcjogXCIke3RhZ05hbWV9XCIgdmFsdWVzIG11c3QgYmUgdW5pcXVlIHN0cmluZ3NgKVxuICAgICAgICB9XG4gICAgICAgIG9uZU9mTWFwcGluZ1t0YWdWYWx1ZV0gPSBpXG4gICAgICB9XG4gICAgfVxuICB9LFxufVxuXG5leHBvcnQgZGVmYXVsdCBkZWZcbiIsICJ7XG4gIFwiJHNjaGVtYVwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICBcIiRpZFwiOiBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiLFxuICBcInRpdGxlXCI6IFwiQ29yZSBzY2hlbWEgbWV0YS1zY2hlbWFcIixcbiAgXCJkZWZpbml0aW9uc1wiOiB7XG4gICAgXCJzY2hlbWFBcnJheVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgXCJpdGVtc1wiOiB7XCIkcmVmXCI6IFwiI1wifVxuICAgIH0sXG4gICAgXCJub25OZWdhdGl2ZUludGVnZXJcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiaW50ZWdlclwiLFxuICAgICAgXCJtaW5pbXVtXCI6IDBcbiAgICB9LFxuICAgIFwibm9uTmVnYXRpdmVJbnRlZ2VyRGVmYXVsdDBcIjoge1xuICAgICAgXCJhbGxPZlwiOiBbe1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvbm9uTmVnYXRpdmVJbnRlZ2VyXCJ9LCB7XCJkZWZhdWx0XCI6IDB9XVxuICAgIH0sXG4gICAgXCJzaW1wbGVUeXBlc1wiOiB7XG4gICAgICBcImVudW1cIjogW1wiYXJyYXlcIiwgXCJib29sZWFuXCIsIFwiaW50ZWdlclwiLCBcIm51bGxcIiwgXCJudW1iZXJcIiwgXCJvYmplY3RcIiwgXCJzdHJpbmdcIl1cbiAgICB9LFxuICAgIFwic3RyaW5nQXJyYXlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYXJyYXlcIixcbiAgICAgIFwiaXRlbXNcIjoge1widHlwZVwiOiBcInN0cmluZ1wifSxcbiAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZSxcbiAgICAgIFwiZGVmYXVsdFwiOiBbXVxuICAgIH1cbiAgfSxcbiAgXCJ0eXBlXCI6IFtcIm9iamVjdFwiLCBcImJvb2xlYW5cIl0sXG4gIFwicHJvcGVydGllc1wiOiB7XG4gICAgXCIkaWRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInVyaS1yZWZlcmVuY2VcIlxuICAgIH0sXG4gICAgXCIkc2NoZW1hXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmlcIlxuICAgIH0sXG4gICAgXCIkcmVmXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcInN0cmluZ1wiLFxuICAgICAgXCJmb3JtYXRcIjogXCJ1cmktcmVmZXJlbmNlXCJcbiAgICB9LFxuICAgIFwiJGNvbW1lbnRcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIFwidGl0bGVcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIFwiZGVzY3JpcHRpb25cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCJcbiAgICB9LFxuICAgIFwiZGVmYXVsdFwiOiB0cnVlLFxuICAgIFwicmVhZE9ubHlcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImV4YW1wbGVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHRydWVcbiAgICB9LFxuICAgIFwibXVsdGlwbGVPZlwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIixcbiAgICAgIFwiZXhjbHVzaXZlTWluaW11bVwiOiAwXG4gICAgfSxcbiAgICBcIm1heGltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwiZXhjbHVzaXZlTWF4aW11bVwiOiB7XG4gICAgICBcInR5cGVcIjogXCJudW1iZXJcIlxuICAgIH0sXG4gICAgXCJtaW5pbXVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm51bWJlclwiXG4gICAgfSxcbiAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwibnVtYmVyXCJcbiAgICB9LFxuICAgIFwibWF4TGVuZ3RoXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pbkxlbmd0aFwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJEZWZhdWx0MFwifSxcbiAgICBcInBhdHRlcm5cIjoge1xuICAgICAgXCJ0eXBlXCI6IFwic3RyaW5nXCIsXG4gICAgICBcImZvcm1hdFwiOiBcInJlZ2V4XCJcbiAgICB9LFxuICAgIFwiYWRkaXRpb25hbEl0ZW1zXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiaXRlbXNcIjoge1xuICAgICAgXCJhbnlPZlwiOiBbe1wiJHJlZlwiOiBcIiNcIn0sIHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9XSxcbiAgICAgIFwiZGVmYXVsdFwiOiB0cnVlXG4gICAgfSxcbiAgICBcIm1heEl0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlclwifSxcbiAgICBcIm1pbkl0ZW1zXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwidW5pcXVlSXRlbXNcIjoge1xuICAgICAgXCJ0eXBlXCI6IFwiYm9vbGVhblwiLFxuICAgICAgXCJkZWZhdWx0XCI6IGZhbHNlXG4gICAgfSxcbiAgICBcImNvbnRhaW5zXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwibWF4UHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9ub25OZWdhdGl2ZUludGVnZXJcIn0sXG4gICAgXCJtaW5Qcm9wZXJ0aWVzXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL25vbk5lZ2F0aXZlSW50ZWdlckRlZmF1bHQwXCJ9LFxuICAgIFwicmVxdWlyZWRcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc3RyaW5nQXJyYXlcIn0sXG4gICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImRlZmluaXRpb25zXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICAgIFwiZGVmYXVsdFwiOiB7fVxuICAgIH0sXG4gICAgXCJwYXR0ZXJuUHJvcGVydGllc1wiOiB7XG4gICAgICBcInR5cGVcIjogXCJvYmplY3RcIixcbiAgICAgIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgICBcInByb3BlcnR5TmFtZXNcIjoge1wiZm9ybWF0XCI6IFwicmVnZXhcIn0sXG4gICAgICBcImRlZmF1bHRcIjoge31cbiAgICB9LFxuICAgIFwiZGVwZW5kZW5jaWVzXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcIm9iamVjdFwiLFxuICAgICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiOiB7XG4gICAgICAgIFwiYW55T2ZcIjogW3tcIiRyZWZcIjogXCIjXCJ9LCB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zdHJpbmdBcnJheVwifV1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwicHJvcGVydHlOYW1lc1wiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcImNvbnN0XCI6IHRydWUsXG4gICAgXCJlbnVtXCI6IHtcbiAgICAgIFwidHlwZVwiOiBcImFycmF5XCIsXG4gICAgICBcIml0ZW1zXCI6IHRydWUsXG4gICAgICBcIm1pbkl0ZW1zXCI6IDEsXG4gICAgICBcInVuaXF1ZUl0ZW1zXCI6IHRydWVcbiAgICB9LFxuICAgIFwidHlwZVwiOiB7XG4gICAgICBcImFueU9mXCI6IFtcbiAgICAgICAge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIn0sXG4gICAgICAgIHtcbiAgICAgICAgICBcInR5cGVcIjogXCJhcnJheVwiLFxuICAgICAgICAgIFwiaXRlbXNcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2ltcGxlVHlwZXNcIn0sXG4gICAgICAgICAgXCJtaW5JdGVtc1wiOiAxLFxuICAgICAgICAgIFwidW5pcXVlSXRlbXNcIjogdHJ1ZVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfSxcbiAgICBcImZvcm1hdFwiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiY29udGVudE1lZGlhVHlwZVwiOiB7XCJ0eXBlXCI6IFwic3RyaW5nXCJ9LFxuICAgIFwiY29udGVudEVuY29kaW5nXCI6IHtcInR5cGVcIjogXCJzdHJpbmdcIn0sXG4gICAgXCJpZlwiOiB7XCIkcmVmXCI6IFwiI1wifSxcbiAgICBcInRoZW5cIjoge1wiJHJlZlwiOiBcIiNcIn0sXG4gICAgXCJlbHNlXCI6IHtcIiRyZWZcIjogXCIjXCJ9LFxuICAgIFwiYWxsT2ZcIjoge1wiJHJlZlwiOiBcIiMvZGVmaW5pdGlvbnMvc2NoZW1hQXJyYXlcIn0sXG4gICAgXCJhbnlPZlwiOiB7XCIkcmVmXCI6IFwiIy9kZWZpbml0aW9ucy9zY2hlbWFBcnJheVwifSxcbiAgICBcIm9uZU9mXCI6IHtcIiRyZWZcIjogXCIjL2RlZmluaXRpb25zL3NjaGVtYUFycmF5XCJ9LFxuICAgIFwibm90XCI6IHtcIiRyZWZcIjogXCIjXCJ9XG4gIH0sXG4gIFwiZGVmYXVsdFwiOiB0cnVlXG59XG4iLCAiaW1wb3J0IHR5cGUge0FueVNjaGVtYU9iamVjdH0gZnJvbSBcIi4vdHlwZXNcIlxuaW1wb3J0IEFqdkNvcmUgZnJvbSBcIi4vY29yZVwiXG5pbXBvcnQgZHJhZnQ3Vm9jYWJ1bGFyaWVzIGZyb20gXCIuL3ZvY2FidWxhcmllcy9kcmFmdDdcIlxuaW1wb3J0IGRpc2NyaW1pbmF0b3IgZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2Rpc2NyaW1pbmF0b3JcIlxuaW1wb3J0ICogYXMgZHJhZnQ3TWV0YVNjaGVtYSBmcm9tIFwiLi9yZWZzL2pzb24tc2NoZW1hLWRyYWZ0LTA3Lmpzb25cIlxuXG5jb25zdCBNRVRBX1NVUFBPUlRfREFUQSA9IFtcIi9wcm9wZXJ0aWVzXCJdXG5cbmNvbnN0IE1FVEFfU0NIRU1BX0lEID0gXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL2RyYWZ0LTA3L3NjaGVtYVwiXG5cbmV4cG9ydCBjbGFzcyBBanYgZXh0ZW5kcyBBanZDb3JlIHtcbiAgX2FkZFZvY2FidWxhcmllcygpOiB2b2lkIHtcbiAgICBzdXBlci5fYWRkVm9jYWJ1bGFyaWVzKClcbiAgICBkcmFmdDdWb2NhYnVsYXJpZXMuZm9yRWFjaCgodikgPT4gdGhpcy5hZGRWb2NhYnVsYXJ5KHYpKVxuICAgIGlmICh0aGlzLm9wdHMuZGlzY3JpbWluYXRvcikgdGhpcy5hZGRLZXl3b3JkKGRpc2NyaW1pbmF0b3IpXG4gIH1cblxuICBfYWRkRGVmYXVsdE1ldGFTY2hlbWEoKTogdm9pZCB7XG4gICAgc3VwZXIuX2FkZERlZmF1bHRNZXRhU2NoZW1hKClcbiAgICBpZiAoIXRoaXMub3B0cy5tZXRhKSByZXR1cm5cbiAgICBjb25zdCBtZXRhU2NoZW1hID0gdGhpcy5vcHRzLiRkYXRhXG4gICAgICA/IHRoaXMuJGRhdGFNZXRhU2NoZW1hKGRyYWZ0N01ldGFTY2hlbWEsIE1FVEFfU1VQUE9SVF9EQVRBKVxuICAgICAgOiBkcmFmdDdNZXRhU2NoZW1hXG4gICAgdGhpcy5hZGRNZXRhU2NoZW1hKG1ldGFTY2hlbWEsIE1FVEFfU0NIRU1BX0lELCBmYWxzZSlcbiAgICB0aGlzLnJlZnNbXCJodHRwOi8vanNvbi1zY2hlbWEub3JnL3NjaGVtYVwiXSA9IE1FVEFfU0NIRU1BX0lEXG4gIH1cblxuICBkZWZhdWx0TWV0YSgpOiBzdHJpbmcgfCBBbnlTY2hlbWFPYmplY3QgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiAodGhpcy5vcHRzLmRlZmF1bHRNZXRhID1cbiAgICAgIHN1cGVyLmRlZmF1bHRNZXRhKCkgfHwgKHRoaXMuZ2V0U2NoZW1hKE1FVEFfU0NIRU1BX0lEKSA/IE1FVEFfU0NIRU1BX0lEIDogdW5kZWZpbmVkKSlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBBanZcbm1vZHVsZS5leHBvcnRzLkFqdiA9IEFqdlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KVxuXG5leHBvcnQgZGVmYXVsdCBBanZcblxuZXhwb3J0IHtcbiAgRm9ybWF0LFxuICBGb3JtYXREZWZpbml0aW9uLFxuICBBc3luY0Zvcm1hdERlZmluaXRpb24sXG4gIEtleXdvcmREZWZpbml0aW9uLFxuICBLZXl3b3JkRXJyb3JEZWZpbml0aW9uLFxuICBDb2RlS2V5d29yZERlZmluaXRpb24sXG4gIE1hY3JvS2V5d29yZERlZmluaXRpb24sXG4gIEZ1bmNLZXl3b3JkRGVmaW5pdGlvbixcbiAgVm9jYWJ1bGFyeSxcbiAgU2NoZW1hLFxuICBTY2hlbWFPYmplY3QsXG4gIEFueVNjaGVtYU9iamVjdCxcbiAgQXN5bmNTY2hlbWEsXG4gIEFueVNjaGVtYSxcbiAgVmFsaWRhdGVGdW5jdGlvbixcbiAgQXN5bmNWYWxpZGF0ZUZ1bmN0aW9uLFxuICBTY2hlbWFWYWxpZGF0ZUZ1bmN0aW9uLFxuICBFcnJvck9iamVjdCxcbiAgRXJyb3JOb1BhcmFtcyxcbn0gZnJvbSBcIi4vdHlwZXNcIlxuXG5leHBvcnQge1BsdWdpbiwgT3B0aW9ucywgQ29kZU9wdGlvbnMsIEluc3RhbmNlT3B0aW9ucywgTG9nZ2VyLCBFcnJvcnNUZXh0T3B0aW9uc30gZnJvbSBcIi4vY29yZVwiXG5leHBvcnQge1NjaGVtYUN4dCwgU2NoZW1hT2JqQ3h0fSBmcm9tIFwiLi9jb21waWxlXCJcbmV4cG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcIi4vY29tcGlsZS92YWxpZGF0ZVwiXG5leHBvcnQge0RlZmluZWRFcnJvcn0gZnJvbSBcIi4vdm9jYWJ1bGFyaWVzL2Vycm9yc1wiXG5leHBvcnQge0pTT05UeXBlfSBmcm9tIFwiLi9jb21waWxlL3J1bGVzXCJcbmV4cG9ydCB7SlNPTlNjaGVtYVR5cGV9IGZyb20gXCIuL3R5cGVzL2pzb24tc2NoZW1hXCJcbmV4cG9ydCB7Xywgc3RyLCBzdHJpbmdpZnksIG5pbCwgTmFtZSwgQ29kZSwgQ29kZUdlbiwgQ29kZUdlbk9wdGlvbnN9IGZyb20gXCIuL2NvbXBpbGUvY29kZWdlblwiXG5leHBvcnQge2RlZmF1bHQgYXMgVmFsaWRhdGlvbkVycm9yfSBmcm9tIFwiLi9ydW50aW1lL3ZhbGlkYXRpb25fZXJyb3JcIlxuZXhwb3J0IHtkZWZhdWx0IGFzIE1pc3NpbmdSZWZFcnJvcn0gZnJvbSBcIi4vY29tcGlsZS9yZWZfZXJyb3JcIlxuIiwgImltcG9ydCB0eXBlIHtGb3JtYXQsIEZvcm1hdERlZmluaXRpb259IGZyb20gXCJhanZcIlxuaW1wb3J0IHR5cGUge0Zvcm1hdFZhbGlkYXRvciwgRm9ybWF0Q29tcGFyZX0gZnJvbSBcImFqdi9kaXN0L3R5cGVzXCJcblxuZXhwb3J0IHR5cGUgRm9ybWF0TW9kZSA9IFwiZmFzdFwiIHwgXCJmdWxsXCJcblxuZXhwb3J0IHR5cGUgRm9ybWF0TmFtZSA9XG4gIHwgXCJkYXRlXCJcbiAgfCBcInRpbWVcIlxuICB8IFwiZGF0ZS10aW1lXCJcbiAgfCBcImlzby10aW1lXCJcbiAgfCBcImlzby1kYXRlLXRpbWVcIlxuICB8IFwiZHVyYXRpb25cIlxuICB8IFwidXJpXCJcbiAgfCBcInVyaS1yZWZlcmVuY2VcIlxuICB8IFwidXJpLXRlbXBsYXRlXCJcbiAgfCBcInVybFwiXG4gIHwgXCJlbWFpbFwiXG4gIHwgXCJob3N0bmFtZVwiXG4gIHwgXCJpcHY0XCJcbiAgfCBcImlwdjZcIlxuICB8IFwicmVnZXhcIlxuICB8IFwidXVpZFwiXG4gIHwgXCJqc29uLXBvaW50ZXJcIlxuICB8IFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiXG4gIHwgXCJyZWxhdGl2ZS1qc29uLXBvaW50ZXJcIlxuICB8IFwiYnl0ZVwiXG4gIHwgXCJpbnQzMlwiXG4gIHwgXCJpbnQ2NFwiXG4gIHwgXCJmbG9hdFwiXG4gIHwgXCJkb3VibGVcIlxuICB8IFwicGFzc3dvcmRcIlxuICB8IFwiYmluYXJ5XCJcblxuZXhwb3J0IHR5cGUgRGVmaW5lZEZvcm1hdHMgPSB7XG4gIFtrZXkgaW4gRm9ybWF0TmFtZV06IEZvcm1hdFxufVxuXG5mdW5jdGlvbiBmbXREZWYoXG4gIHZhbGlkYXRlOiBSZWdFeHAgfCBGb3JtYXRWYWxpZGF0b3I8c3RyaW5nPixcbiAgY29tcGFyZTogRm9ybWF0Q29tcGFyZTxzdHJpbmc+XG4pOiBGb3JtYXREZWZpbml0aW9uPHN0cmluZz4ge1xuICByZXR1cm4ge3ZhbGlkYXRlLCBjb21wYXJlfVxufVxuXG5leHBvcnQgY29uc3QgZnVsbEZvcm1hdHM6IERlZmluZWRGb3JtYXRzID0ge1xuICAvLyBkYXRlOiBodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzMzM5I3NlY3Rpb24tNS42XG4gIGRhdGU6IGZtdERlZihkYXRlLCBjb21wYXJlRGF0ZSksXG4gIC8vIGRhdGUtdGltZTogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNzZWN0aW9uLTUuNlxuICB0aW1lOiBmbXREZWYoZ2V0VGltZSh0cnVlKSwgY29tcGFyZVRpbWUpLFxuICBcImRhdGUtdGltZVwiOiBmbXREZWYoZ2V0RGF0ZVRpbWUodHJ1ZSksIGNvbXBhcmVEYXRlVGltZSksXG4gIFwiaXNvLXRpbWVcIjogZm10RGVmKGdldFRpbWUoKSwgY29tcGFyZUlzb1RpbWUpLFxuICBcImlzby1kYXRlLXRpbWVcIjogZm10RGVmKGdldERhdGVUaW1lKCksIGNvbXBhcmVJc29EYXRlVGltZSksXG4gIC8vIGR1cmF0aW9uOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzMzOSNhcHBlbmRpeC1BXG4gIGR1cmF0aW9uOiAvXlAoPyEkKSgoXFxkK1kpPyhcXGQrTSk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCtTKT8pP3woXFxkK1cpPykkLyxcbiAgdXJpLFxuICBcInVyaS1yZWZlcmVuY2VcIjpcbiAgICAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KT8oPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PV18JVswLTlhLWZdezJ9KSopKD86OlxcZCopPyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnXCIoKSorLDs9OkBdfCVbMC05YS1mXXsyfSkqKSp8XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT98KD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKT8oPzpcXD8oPzpbYS16MC05XFwtLl9+ISQmJ1wiKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJidcIigpKissOz06QC8/XXwlWzAtOWEtZl17Mn0pKik/JC9pLFxuICAvLyB1cmktdGVtcGxhdGU6IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2NTcwXG4gIFwidXJpLXRlbXBsYXRlXCI6XG4gICAgL14oPzooPzpbXlxceDAwLVxceDIwXCInPD4lXFxcXF5ge3x9XXwlWzAtOWEtZl17Mn0pfFxce1srIy4vOz8mPSwhQHxdPyg/OlthLXowLTlfXXwlWzAtOWEtZl17Mn0pKyg/OjpbMS05XVswLTldezAsM318XFwqKT8oPzosKD86W2EtejAtOV9dfCVbMC05YS1mXXsyfSkrKD86OlsxLTldWzAtOV17MCwzfXxcXCopPykqXFx9KSokL2ksXG4gIC8vIEZvciB0aGUgc291cmNlOiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9kcGVyaW5pLzcyOTI5NFxuICAvLyBGb3IgdGVzdCBjYXNlczogaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL2RlbW8vdXJsLXJlZ2V4XG4gIHVybDogL14oPzpodHRwcz98ZnRwKTpcXC9cXC8oPzpcXFMrKD86OlxcUyopP0ApPyg/Oig/ISg/OjEwfDEyNykoPzpcXC5cXGR7MSwzfSl7M30pKD8hKD86MTY5XFwuMjU0fDE5MlxcLjE2OCkoPzpcXC5cXGR7MSwzfSl7Mn0pKD8hMTcyXFwuKD86MVs2LTldfDJcXGR8M1swLTFdKSg/OlxcLlxcZHsxLDN9KXsyfSkoPzpbMS05XVxcZD98MVxcZFxcZHwyWzAxXVxcZHwyMlswLTNdKSg/OlxcLig/OjE/XFxkezEsMn18MlswLTRdXFxkfDI1WzAtNV0pKXsyfSg/OlxcLig/OlsxLTldXFxkP3wxXFxkXFxkfDJbMC00XVxcZHwyNVswLTRdKSl8KD86KD86W2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKy0pKlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSspKD86XFwuKD86W2EtejAtOVxcdXswMGExfS1cXHV7ZmZmZn1dKy0pKlthLXowLTlcXHV7MDBhMX0tXFx1e2ZmZmZ9XSspKig/OlxcLig/OlthLXpcXHV7MDBhMX0tXFx1e2ZmZmZ9XXsyLH0pKSkoPzo6XFxkezIsNX0pPyg/OlxcL1teXFxzXSopPyQvaXUsXG4gIGVtYWlsOlxuICAgIC9eW2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKkAoPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/JC9pLFxuICBob3N0bmFtZTpcbiAgICAvXig/PS57MSwyNTN9XFwuPyQpW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbLTAtOWEtel17MCw2MX1bMC05YS16XSk/KSpcXC4/JC9pLFxuICAvLyBvcHRpbWl6ZWQgaHR0cHM6Ly93d3cuc2FmYXJpYm9va3NvbmxpbmUuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODA1OTY4MDI4MzcvY2gwN3MxNi5odG1sXG4gIGlwdjQ6IC9eKD86KD86MjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSQvLFxuICBpcHY2OiAvXigoKFswLTlhLWZdezEsNH06KXs3fShbMC05YS1mXXsxLDR9fDopKXwoKFswLTlhLWZdezEsNH06KXs2fSg6WzAtOWEtZl17MSw0fXwoKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezV9KCgoOlswLTlhLWZdezEsNH0pezEsMn0pfDooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSl8OikpfCgoWzAtOWEtZl17MSw0fTopezR9KCgoOlswLTlhLWZdezEsNH0pezEsM30pfCgoOlswLTlhLWZdezEsNH0pPzooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoKFswLTlhLWZdezEsNH06KXszfSgoKDpbMC05YS1mXXsxLDR9KXsxLDR9KXwoKDpbMC05YS1mXXsxLDR9KXswLDJ9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpfCgoWzAtOWEtZl17MSw0fTopezJ9KCgoOlswLTlhLWZdezEsNH0pezEsNX0pfCgoOlswLTlhLWZdezEsNH0pezAsM306KCgyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkoXFwuKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKSl7M30pKXw6KSl8KChbMC05YS1mXXsxLDR9Oil7MX0oKCg6WzAtOWEtZl17MSw0fSl7MSw2fSl8KCg6WzAtOWEtZl17MSw0fSl7MCw0fTooKDI1WzAtNV18MlswLTRdXFxkfDFcXGRcXGR8WzEtOV0/XFxkKShcXC4oMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKXszfSkpfDopKXwoOigoKDpbMC05YS1mXXsxLDR9KXsxLDd9KXwoKDpbMC05YS1mXXsxLDR9KXswLDV9OigoMjVbMC01XXwyWzAtNF1cXGR8MVxcZFxcZHxbMS05XT9cXGQpKFxcLigyNVswLTVdfDJbMC00XVxcZHwxXFxkXFxkfFsxLTldP1xcZCkpezN9KSl8OikpKSQvaSxcbiAgcmVnZXgsXG4gIC8vIHV1aWQ6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQxMjJcbiAgdXVpZDogL14oPzp1cm46dXVpZDopP1swLTlhLWZdezh9LSg/OlswLTlhLWZdezR9LSl7M31bMC05YS1mXXsxMn0kL2ksXG4gIC8vIEpTT04tcG9pbnRlcjogaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzY5MDFcbiAgLy8gdXJpIGZyYWdtZW50OiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzk4NiNhcHBlbmRpeC1BXG4gIFwianNvbi1wb2ludGVyXCI6IC9eKD86XFwvKD86W15+L118fjB8fjEpKikqJC8sXG4gIFwianNvbi1wb2ludGVyLXVyaS1mcmFnbWVudFwiOiAvXiMoPzpcXC8oPzpbYS16MC05X1xcLS4hJCYnKCkqKyw7Oj1AXXwlWzAtOWEtZl17Mn18fjB8fjEpKikqJC9pLFxuICAvLyByZWxhdGl2ZSBKU09OLXBvaW50ZXI6IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWx1ZmYtcmVsYXRpdmUtanNvbi1wb2ludGVyLTAwXG4gIFwicmVsYXRpdmUtanNvbi1wb2ludGVyXCI6IC9eKD86MHxbMS05XVswLTldKikoPzojfCg/OlxcLyg/Oltefi9dfH4wfH4xKSopKikkLyxcbiAgLy8gdGhlIGZvbGxvd2luZyBmb3JtYXRzIGFyZSB1c2VkIGJ5IHRoZSBvcGVuYXBpIHNwZWNpZmljYXRpb246IGh0dHBzOi8vc3BlYy5vcGVuYXBpcy5vcmcvb2FzL3YzLjAuMCNkYXRhLXR5cGVzXG4gIC8vIGJ5dGU6IGh0dHBzOi8vZ2l0aHViLmNvbS9taWd1ZWxtb3RhL2lzLWJhc2U2NFxuICBieXRlLFxuICAvLyBzaWduZWQgMzIgYml0IGludGVnZXJcbiAgaW50MzI6IHt0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVJbnQzMn0sXG4gIC8vIHNpZ25lZCA2NCBiaXQgaW50ZWdlclxuICBpbnQ2NDoge3R5cGU6IFwibnVtYmVyXCIsIHZhbGlkYXRlOiB2YWxpZGF0ZUludDY0fSxcbiAgLy8gQy10eXBlIGZsb2F0XG4gIGZsb2F0OiB7dHlwZTogXCJudW1iZXJcIiwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyfSxcbiAgLy8gQy10eXBlIGRvdWJsZVxuICBkb3VibGU6IHt0eXBlOiBcIm51bWJlclwiLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXJ9LFxuICAvLyBoaW50IHRvIHRoZSBVSSB0byBoaWRlIGlucHV0IHN0cmluZ3NcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIC8vIHVuY2hlY2tlZCBzdHJpbmcgcGF5bG9hZFxuICBiaW5hcnk6IHRydWUsXG59XG5cbmV4cG9ydCBjb25zdCBmYXN0Rm9ybWF0czogRGVmaW5lZEZvcm1hdHMgPSB7XG4gIC4uLmZ1bGxGb3JtYXRzLFxuICBkYXRlOiBmbXREZWYoL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGQkLywgY29tcGFyZURhdGUpLFxuICB0aW1lOiBmbXREZWYoXG4gICAgL14oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KSQvaSxcbiAgICBjb21wYXJlVGltZVxuICApLFxuICBcImRhdGUtdGltZVwiOiBmbXREZWYoXG4gICAgL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGR0KD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPykkL2ksXG4gICAgY29tcGFyZURhdGVUaW1lXG4gICksXG4gIFwiaXNvLXRpbWVcIjogZm10RGVmKFxuICAgIC9eKD86WzAtMl1cXGQ6WzAtNV1cXGQ6WzAtNV1cXGR8MjM6NTk6NjApKD86XFwuXFxkKyk/KD86enxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPyk/JC9pLFxuICAgIGNvbXBhcmVJc29UaW1lXG4gICksXG4gIFwiaXNvLWRhdGUtdGltZVwiOiBmbXREZWYoXG4gICAgL15cXGRcXGRcXGRcXGQtWzAtMV1cXGQtWzAtM11cXGRbdFxcc10oPzpbMC0yXVxcZDpbMC01XVxcZDpbMC01XVxcZHwyMzo1OTo2MCkoPzpcXC5cXGQrKT8oPzp6fFsrLV1cXGRcXGQoPzo6P1xcZFxcZCk/KT8kL2ksXG4gICAgY29tcGFyZUlzb0RhdGVUaW1lXG4gICksXG4gIC8vIHVyaTogaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9pcy1teS1qc29uLXZhbGlkL2Jsb2IvbWFzdGVyL2Zvcm1hdHMuanNcbiAgdXJpOiAvXig/OlthLXpdW2EtejAtOStcXC0uXSo6KSg/OlxcLz9cXC8pP1teXFxzXSokL2ksXG4gIFwidXJpLXJlZmVyZW5jZVwiOiAvXig/Oig/OlthLXpdW2EtejAtOStcXC0uXSo6KT9cXC8/XFwvKT8oPzpbXlxcXFxcXHMjXVteXFxzI10qKT8oPzojW15cXFxcXFxzXSopPyQvaSxcbiAgLy8gZW1haWwgKHNvdXJjZXMgZnJvbSBqc2VuIHZhbGlkYXRvcik6XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjAxMzIzL3VzaW5nLWEtcmVndWxhci1leHByZXNzaW9uLXRvLXZhbGlkYXRlLWFuLWVtYWlsLWFkZHJlc3MjYW5zd2VyLTg4MjkzNjNcbiAgLy8gaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvZm9ybXMuaHRtbCN2YWxpZC1lLW1haWwtYWRkcmVzcyAoc2VhcmNoIGZvciAnd2lsZnVsIHZpb2xhdGlvbicpXG4gIGVtYWlsOlxuICAgIC9eW2EtejAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KD86XFwuW2EtejAtOV0oPzpbYS16MC05LV17MCw2MX1bYS16MC05XSk/KSokL2ksXG59XG5cbmV4cG9ydCBjb25zdCBmb3JtYXROYW1lcyA9IE9iamVjdC5rZXlzKGZ1bGxGb3JtYXRzKSBhcyBGb3JtYXROYW1lW11cblxuZnVuY3Rpb24gaXNMZWFwWWVhcih5ZWFyOiBudW1iZXIpOiBib29sZWFuIHtcbiAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjYXBwZW5kaXgtQ1xuICByZXR1cm4geWVhciAlIDQgPT09IDAgJiYgKHllYXIgJSAxMDAgIT09IDAgfHwgeWVhciAlIDQwMCA9PT0gMClcbn1cblxuY29uc3QgREFURSA9IC9eKFxcZFxcZFxcZFxcZCktKFxcZFxcZCktKFxcZFxcZCkkL1xuY29uc3QgREFZUyA9IFswLCAzMSwgMjgsIDMxLCAzMCwgMzEsIDMwLCAzMSwgMzEsIDMwLCAzMSwgMzAsIDMxXVxuXG5mdW5jdGlvbiBkYXRlKHN0cjogc3RyaW5nKTogYm9vbGVhbiB7XG4gIC8vIGZ1bGwtZGF0ZSBmcm9tIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgY29uc3QgbWF0Y2hlczogc3RyaW5nW10gfCBudWxsID0gREFURS5leGVjKHN0cilcbiAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2VcbiAgY29uc3QgeWVhcjogbnVtYmVyID0gK21hdGNoZXNbMV1cbiAgY29uc3QgbW9udGg6IG51bWJlciA9ICttYXRjaGVzWzJdXG4gIGNvbnN0IGRheTogbnVtYmVyID0gK21hdGNoZXNbM11cbiAgcmV0dXJuIChcbiAgICBtb250aCA+PSAxICYmXG4gICAgbW9udGggPD0gMTIgJiZcbiAgICBkYXkgPj0gMSAmJlxuICAgIGRheSA8PSAobW9udGggPT09IDIgJiYgaXNMZWFwWWVhcih5ZWFyKSA/IDI5IDogREFZU1ttb250aF0pXG4gIClcbn1cblxuZnVuY3Rpb24gY29tcGFyZURhdGUoZDE6IHN0cmluZywgZDI6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICghKGQxICYmIGQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoZDEgPiBkMikgcmV0dXJuIDFcbiAgaWYgKGQxIDwgZDIpIHJldHVybiAtMVxuICByZXR1cm4gMFxufVxuXG5jb25zdCBUSU1FID0gL14oXFxkXFxkKTooXFxkXFxkKTooXFxkXFxkKD86XFwuXFxkKyk/KSh6fChbKy1dKShcXGRcXGQpKD86Oj8oXFxkXFxkKSk/KT8kL2lcblxuZnVuY3Rpb24gZ2V0VGltZShzdHJpY3RUaW1lWm9uZT86IGJvb2xlYW4pOiAoc3RyOiBzdHJpbmcpID0+IGJvb2xlYW4ge1xuICByZXR1cm4gZnVuY3Rpb24gdGltZShzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IG1hdGNoZXM6IHN0cmluZ1tdIHwgbnVsbCA9IFRJTUUuZXhlYyhzdHIpXG4gICAgaWYgKCFtYXRjaGVzKSByZXR1cm4gZmFsc2VcbiAgICBjb25zdCBocjogbnVtYmVyID0gK21hdGNoZXNbMV1cbiAgICBjb25zdCBtaW46IG51bWJlciA9ICttYXRjaGVzWzJdXG4gICAgY29uc3Qgc2VjOiBudW1iZXIgPSArbWF0Y2hlc1szXVxuICAgIGNvbnN0IHR6OiBzdHJpbmcgfCB1bmRlZmluZWQgPSBtYXRjaGVzWzRdXG4gICAgY29uc3QgdHpTaWduOiBudW1iZXIgPSBtYXRjaGVzWzVdID09PSBcIi1cIiA/IC0xIDogMVxuICAgIGNvbnN0IHR6SDogbnVtYmVyID0gKyhtYXRjaGVzWzZdIHx8IDApXG4gICAgY29uc3QgdHpNOiBudW1iZXIgPSArKG1hdGNoZXNbN10gfHwgMClcbiAgICBpZiAodHpIID4gMjMgfHwgdHpNID4gNTkgfHwgKHN0cmljdFRpbWVab25lICYmICF0eikpIHJldHVybiBmYWxzZVxuICAgIGlmIChociA8PSAyMyAmJiBtaW4gPD0gNTkgJiYgc2VjIDwgNjApIHJldHVybiB0cnVlXG4gICAgLy8gbGVhcCBzZWNvbmRcbiAgICBjb25zdCB1dGNNaW4gPSBtaW4gLSB0ek0gKiB0elNpZ25cbiAgICBjb25zdCB1dGNIciA9IGhyIC0gdHpIICogdHpTaWduIC0gKHV0Y01pbiA8IDAgPyAxIDogMClcbiAgICByZXR1cm4gKHV0Y0hyID09PSAyMyB8fCB1dGNIciA9PT0gLTEpICYmICh1dGNNaW4gPT09IDU5IHx8IHV0Y01pbiA9PT0gLTEpICYmIHNlYyA8IDYxXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVRpbWUoczE6IHN0cmluZywgczI6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICghKHMxICYmIHMyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICBjb25zdCB0MSA9IG5ldyBEYXRlKFwiMjAyMC0wMS0wMVRcIiArIHMxKS52YWx1ZU9mKClcbiAgY29uc3QgdDIgPSBuZXcgRGF0ZShcIjIwMjAtMDEtMDFUXCIgKyBzMikudmFsdWVPZigpXG4gIGlmICghKHQxICYmIHQyKSkgcmV0dXJuIHVuZGVmaW5lZFxuICByZXR1cm4gdDEgLSB0MlxufVxuXG5mdW5jdGlvbiBjb21wYXJlSXNvVGltZSh0MTogc3RyaW5nLCB0Mjogc3RyaW5nKTogbnVtYmVyIHwgdW5kZWZpbmVkIHtcbiAgaWYgKCEodDEgJiYgdDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IGExID0gVElNRS5leGVjKHQxKVxuICBjb25zdCBhMiA9IFRJTUUuZXhlYyh0MilcbiAgaWYgKCEoYTEgJiYgYTIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIHQxID0gYTFbMV0gKyBhMVsyXSArIGExWzNdXG4gIHQyID0gYTJbMV0gKyBhMlsyXSArIGEyWzNdXG4gIGlmICh0MSA+IHQyKSByZXR1cm4gMVxuICBpZiAodDEgPCB0MikgcmV0dXJuIC0xXG4gIHJldHVybiAwXG59XG5cbmNvbnN0IERBVEVfVElNRV9TRVBBUkFUT1IgPSAvdHxcXHMvaVxuZnVuY3Rpb24gZ2V0RGF0ZVRpbWUoc3RyaWN0VGltZVpvbmU/OiBib29sZWFuKTogKHN0cjogc3RyaW5nKSA9PiBib29sZWFuIHtcbiAgY29uc3QgdGltZSA9IGdldFRpbWUoc3RyaWN0VGltZVpvbmUpXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGRhdGVfdGltZShzdHI6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIC8vIGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzMzMzkjc2VjdGlvbi01LjZcbiAgICBjb25zdCBkYXRlVGltZTogc3RyaW5nW10gPSBzdHIuc3BsaXQoREFURV9USU1FX1NFUEFSQVRPUilcbiAgICByZXR1cm4gZGF0ZVRpbWUubGVuZ3RoID09PSAyICYmIGRhdGUoZGF0ZVRpbWVbMF0pICYmIHRpbWUoZGF0ZVRpbWVbMV0pXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZURhdGVUaW1lKGR0MTogc3RyaW5nLCBkdDI6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICghKGR0MSAmJiBkdDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IGQxID0gbmV3IERhdGUoZHQxKS52YWx1ZU9mKClcbiAgY29uc3QgZDIgPSBuZXcgRGF0ZShkdDIpLnZhbHVlT2YoKVxuICBpZiAoIShkMSAmJiBkMikpIHJldHVybiB1bmRlZmluZWRcbiAgcmV0dXJuIGQxIC0gZDJcbn1cblxuZnVuY3Rpb24gY29tcGFyZUlzb0RhdGVUaW1lKGR0MTogc3RyaW5nLCBkdDI6IHN0cmluZyk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGlmICghKGR0MSAmJiBkdDIpKSByZXR1cm4gdW5kZWZpbmVkXG4gIGNvbnN0IFtkMSwgdDFdID0gZHQxLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpXG4gIGNvbnN0IFtkMiwgdDJdID0gZHQyLnNwbGl0KERBVEVfVElNRV9TRVBBUkFUT1IpXG4gIGNvbnN0IHJlcyA9IGNvbXBhcmVEYXRlKGQxLCBkMilcbiAgaWYgKHJlcyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdW5kZWZpbmVkXG4gIHJldHVybiByZXMgfHwgY29tcGFyZVRpbWUodDEsIHQyKVxufVxuXG5jb25zdCBOT1RfVVJJX0ZSQUdNRU5UID0gL1xcL3w6L1xuY29uc3QgVVJJID1cbiAgL14oPzpbYS16XVthLXowLTkrXFwtLl0qOikoPzpcXC8/XFwvKD86KD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9Ol18JVswLTlhLWZdezJ9KSpAKT8oPzpcXFsoPzooPzooPzooPzpbMC05YS1mXXsxLDR9Oil7Nn18OjooPzpbMC05YS1mXXsxLDR9Oil7NX18KD86WzAtOWEtZl17MSw0fSk/OjooPzpbMC05YS1mXXsxLDR9Oil7NH18KD86KD86WzAtOWEtZl17MSw0fTopezAsMX1bMC05YS1mXXsxLDR9KT86Oig/OlswLTlhLWZdezEsNH06KXszfXwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCwyfVswLTlhLWZdezEsNH0pPzo6KD86WzAtOWEtZl17MSw0fTopezJ9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDN9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9OnwoPzooPzpbMC05YS1mXXsxLDR9Oil7MCw0fVswLTlhLWZdezEsNH0pPzo6KSg/OlswLTlhLWZdezEsNH06WzAtOWEtZl17MSw0fXwoPzooPzoyNVswLTVdfDJbMC00XVxcZHxbMDFdP1xcZFxcZD8pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPykpfCg/Oig/OlswLTlhLWZdezEsNH06KXswLDV9WzAtOWEtZl17MSw0fSk/OjpbMC05YS1mXXsxLDR9fCg/Oig/OlswLTlhLWZdezEsNH06KXswLDZ9WzAtOWEtZl17MSw0fSk/OjopfFtWdl1bMC05YS1mXStcXC5bYS16MC05XFwtLl9+ISQmJygpKissOz06XSspXFxdfCg/Oig/OjI1WzAtNV18MlswLTRdXFxkfFswMV0/XFxkXFxkPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1cXGR8WzAxXT9cXGRcXGQ/KXwoPzpbYS16MC05XFwtLl9+ISQmJygpKissOz1dfCVbMC05YS1mXXsyfSkqKSg/OjpcXGQqKT8oPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKnxcXC8oPzooPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSsoPzpcXC8oPzpbYS16MC05XFwtLl9+ISQmJygpKissOz06QF18JVswLTlhLWZdezJ9KSopKik/fCg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKyg/OlxcLyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpAXXwlWzAtOWEtZl17Mn0pKikqKSg/OlxcPyg/OlthLXowLTlcXC0uX34hJCYnKCkqKyw7PTpALz9dfCVbMC05YS1mXXsyfSkqKT8oPzojKD86W2EtejAtOVxcLS5ffiEkJicoKSorLDs9OkAvP118JVswLTlhLWZdezJ9KSopPyQvaVxuXG5mdW5jdGlvbiB1cmkoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgLy8gaHR0cDovL2ptcndhcmUuY29tL2FydGljbGVzLzIwMDkvdXJpX3JlZ2V4cC9VUklfcmVnZXguaHRtbCArIG9wdGlvbmFsIHByb3RvY29sICsgcmVxdWlyZWQgXCIuXCJcbiAgcmV0dXJuIE5PVF9VUklfRlJBR01FTlQudGVzdChzdHIpICYmIFVSSS50ZXN0KHN0cilcbn1cblxuY29uc3QgQllURSA9IC9eKD86W0EtWmEtejAtOSsvXXs0fSkqKD86W0EtWmEtejAtOSsvXXsyfT09fFtBLVphLXowLTkrL117M309KT8kL2dtXG5cbmZ1bmN0aW9uIGJ5dGUoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgQllURS5sYXN0SW5kZXggPSAwXG4gIHJldHVybiBCWVRFLnRlc3Qoc3RyKVxufVxuXG5jb25zdCBNSU5fSU5UMzIgPSAtKDIgKiogMzEpXG5jb25zdCBNQVhfSU5UMzIgPSAyICoqIDMxIC0gMVxuXG5mdW5jdGlvbiB2YWxpZGF0ZUludDMyKHZhbHVlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIE51bWJlci5pc0ludGVnZXIodmFsdWUpICYmIHZhbHVlIDw9IE1BWF9JTlQzMiAmJiB2YWx1ZSA+PSBNSU5fSU5UMzJcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVJbnQ2NCh2YWx1ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gIC8vIEpTT04gYW5kIGphdmFzY3JpcHQgbWF4IEludCBpcyAyKio1Mywgc28gYW55IGludCB0aGF0IHBhc3NlcyBpc0ludGVnZXIgaXMgdmFsaWQgZm9yIEludDY0XG4gIHJldHVybiBOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlcigpOiBib29sZWFuIHtcbiAgcmV0dXJuIHRydWVcbn1cblxuY29uc3QgWl9BTkNIT1IgPSAvW15cXFxcXVxcXFxaL1xuZnVuY3Rpb24gcmVnZXgoc3RyOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgaWYgKFpfQU5DSE9SLnRlc3Qoc3RyKSkgcmV0dXJuIGZhbHNlXG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cChzdHIpXG4gICAgcmV0dXJuIHRydWVcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgQWp2IGZyb20gXCJhanZcIlxuaW1wb3J0IHR5cGUge1xuICBQbHVnaW4sXG4gIENvZGVLZXl3b3JkRGVmaW5pdGlvbixcbiAgS2V5d29yZEVycm9yRGVmaW5pdGlvbixcbiAgQ29kZSxcbiAgTmFtZSxcbiAgRXJyb3JPYmplY3QsXG59IGZyb20gXCJhanZcIlxuaW1wb3J0IHR5cGUge0FkZGVkRm9ybWF0fSBmcm9tIFwiYWp2L2Rpc3QvdHlwZXNcIlxuaW1wb3J0IHR5cGUge1J1bGV9IGZyb20gXCJhanYvZGlzdC9jb21waWxlL3J1bGVzXCJcbmltcG9ydCB7S2V5d29yZEN4dH0gZnJvbSBcImFqdlwiXG5pbXBvcnQge18sIHN0ciwgb3IsIGdldFByb3BlcnR5LCBvcGVyYXRvcnN9IGZyb20gXCJhanYvZGlzdC9jb21waWxlL2NvZGVnZW5cIlxuXG50eXBlIEt3ZCA9IFwiZm9ybWF0TWF4aW11bVwiIHwgXCJmb3JtYXRNaW5pbXVtXCIgfCBcImZvcm1hdEV4Y2x1c2l2ZU1heGltdW1cIiB8IFwiZm9ybWF0RXhjbHVzaXZlTWluaW11bVwiXG5cbnR5cGUgQ29tcGFyaXNvbiA9IFwiPD1cIiB8IFwiPj1cIiB8IFwiPFwiIHwgXCI+XCJcblxuY29uc3Qgb3BzID0gb3BlcmF0b3JzXG5cbmNvbnN0IEtXRHM6IHtbSyBpbiBLd2RdOiB7b2tTdHI6IENvbXBhcmlzb247IG9rOiBDb2RlOyBmYWlsOiBDb2RlfX0gPSB7XG4gIGZvcm1hdE1heGltdW06IHtva1N0cjogXCI8PVwiLCBvazogb3BzLkxURSwgZmFpbDogb3BzLkdUfSxcbiAgZm9ybWF0TWluaW11bToge29rU3RyOiBcIj49XCIsIG9rOiBvcHMuR1RFLCBmYWlsOiBvcHMuTFR9LFxuICBmb3JtYXRFeGNsdXNpdmVNYXhpbXVtOiB7b2tTdHI6IFwiPFwiLCBvazogb3BzLkxULCBmYWlsOiBvcHMuR1RFfSxcbiAgZm9ybWF0RXhjbHVzaXZlTWluaW11bToge29rU3RyOiBcIj5cIiwgb2s6IG9wcy5HVCwgZmFpbDogb3BzLkxURX0sXG59XG5cbmV4cG9ydCB0eXBlIExpbWl0Rm9ybWF0RXJyb3IgPSBFcnJvck9iamVjdDxLd2QsIHtsaW1pdDogc3RyaW5nOyBjb21wYXJpc29uOiBDb21wYXJpc29ufT5cblxuY29uc3QgZXJyb3I6IEtleXdvcmRFcnJvckRlZmluaXRpb24gPSB7XG4gIG1lc3NhZ2U6ICh7a2V5d29yZCwgc2NoZW1hQ29kZX0pID0+IHN0cmBzaG91bGQgYmUgJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5va1N0cn0gJHtzY2hlbWFDb2RlfWAsXG4gIHBhcmFtczogKHtrZXl3b3JkLCBzY2hlbWFDb2RlfSkgPT5cbiAgICBfYHtjb21wYXJpc29uOiAke0tXRHNba2V5d29yZCBhcyBLd2RdLm9rU3RyfSwgbGltaXQ6ICR7c2NoZW1hQ29kZX19YCxcbn1cblxuZXhwb3J0IGNvbnN0IGZvcm1hdExpbWl0RGVmaW5pdGlvbjogQ29kZUtleXdvcmREZWZpbml0aW9uID0ge1xuICBrZXl3b3JkOiBPYmplY3Qua2V5cyhLV0RzKSxcbiAgdHlwZTogXCJzdHJpbmdcIixcbiAgc2NoZW1hVHlwZTogXCJzdHJpbmdcIixcbiAgJGRhdGE6IHRydWUsXG4gIGVycm9yLFxuICBjb2RlKGN4dCkge1xuICAgIGNvbnN0IHtnZW4sIGRhdGEsIHNjaGVtYUNvZGUsIGtleXdvcmQsIGl0fSA9IGN4dFxuICAgIGNvbnN0IHtvcHRzLCBzZWxmfSA9IGl0XG4gICAgaWYgKCFvcHRzLnZhbGlkYXRlRm9ybWF0cykgcmV0dXJuXG5cbiAgICBjb25zdCBmQ3h0ID0gbmV3IEtleXdvcmRDeHQoaXQsIChzZWxmLlJVTEVTLmFsbC5mb3JtYXQgYXMgUnVsZSkuZGVmaW5pdGlvbiwgXCJmb3JtYXRcIilcbiAgICBpZiAoZkN4dC4kZGF0YSkgdmFsaWRhdGUkRGF0YUZvcm1hdCgpXG4gICAgZWxzZSB2YWxpZGF0ZUZvcm1hdCgpXG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZSREYXRhRm9ybWF0KCk6IHZvaWQge1xuICAgICAgY29uc3QgZm10cyA9IGdlbi5zY29wZVZhbHVlKFwiZm9ybWF0c1wiLCB7XG4gICAgICAgIHJlZjogc2VsZi5mb3JtYXRzLFxuICAgICAgICBjb2RlOiBvcHRzLmNvZGUuZm9ybWF0cyxcbiAgICAgIH0pXG4gICAgICBjb25zdCBmbXQgPSBnZW4uY29uc3QoXCJmbXRcIiwgX2Ake2ZtdHN9WyR7ZkN4dC5zY2hlbWFDb2RlfV1gKVxuICAgICAgY3h0LmZhaWwkZGF0YShcbiAgICAgICAgb3IoXG4gICAgICAgICAgX2B0eXBlb2YgJHtmbXR9ICE9IFwib2JqZWN0XCJgLFxuICAgICAgICAgIF9gJHtmbXR9IGluc3RhbmNlb2YgUmVnRXhwYCxcbiAgICAgICAgICBfYHR5cGVvZiAke2ZtdH0uY29tcGFyZSAhPSBcImZ1bmN0aW9uXCJgLFxuICAgICAgICAgIGNvbXBhcmVDb2RlKGZtdClcbiAgICAgICAgKVxuICAgICAgKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KCk6IHZvaWQge1xuICAgICAgY29uc3QgZm9ybWF0ID0gZkN4dC5zY2hlbWEgYXMgc3RyaW5nXG4gICAgICBjb25zdCBmbXREZWY6IEFkZGVkRm9ybWF0IHwgdW5kZWZpbmVkID0gc2VsZi5mb3JtYXRzW2Zvcm1hdF1cbiAgICAgIGlmICghZm10RGVmIHx8IGZtdERlZiA9PT0gdHJ1ZSkgcmV0dXJuXG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBmbXREZWYgIT0gXCJvYmplY3RcIiB8fFxuICAgICAgICBmbXREZWYgaW5zdGFuY2VvZiBSZWdFeHAgfHxcbiAgICAgICAgdHlwZW9mIGZtdERlZi5jb21wYXJlICE9IFwiZnVuY3Rpb25cIlxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2tleXdvcmR9XCI6IGZvcm1hdCBcIiR7Zm9ybWF0fVwiIGRvZXMgbm90IGRlZmluZSBcImNvbXBhcmVcIiBmdW5jdGlvbmApXG4gICAgICB9XG4gICAgICBjb25zdCBmbXQgPSBnZW4uc2NvcGVWYWx1ZShcImZvcm1hdHNcIiwge1xuICAgICAgICBrZXk6IGZvcm1hdCxcbiAgICAgICAgcmVmOiBmbXREZWYsXG4gICAgICAgIGNvZGU6IG9wdHMuY29kZS5mb3JtYXRzID8gX2Ake29wdHMuY29kZS5mb3JtYXRzfSR7Z2V0UHJvcGVydHkoZm9ybWF0KX1gIDogdW5kZWZpbmVkLFxuICAgICAgfSlcblxuICAgICAgY3h0LmZhaWwkZGF0YShjb21wYXJlQ29kZShmbXQpKVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbXBhcmVDb2RlKGZtdDogTmFtZSk6IENvZGUge1xuICAgICAgcmV0dXJuIF9gJHtmbXR9LmNvbXBhcmUoJHtkYXRhfSwgJHtzY2hlbWFDb2RlfSkgJHtLV0RzW2tleXdvcmQgYXMgS3dkXS5mYWlsfSAwYFxuICAgIH1cbiAgfSxcbiAgZGVwZW5kZW5jaWVzOiBbXCJmb3JtYXRcIl0sXG59XG5cbmNvbnN0IGZvcm1hdExpbWl0UGx1Z2luOiBQbHVnaW48dW5kZWZpbmVkPiA9IChhanY6IEFqdik6IEFqdiA9PiB7XG4gIGFqdi5hZGRLZXl3b3JkKGZvcm1hdExpbWl0RGVmaW5pdGlvbilcbiAgcmV0dXJuIGFqdlxufVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRMaW1pdFBsdWdpblxuIiwgImltcG9ydCB7XG4gIERlZmluZWRGb3JtYXRzLFxuICBGb3JtYXRNb2RlLFxuICBGb3JtYXROYW1lLFxuICBmb3JtYXROYW1lcyxcbiAgZmFzdEZvcm1hdHMsXG4gIGZ1bGxGb3JtYXRzLFxufSBmcm9tIFwiLi9mb3JtYXRzXCJcbmltcG9ydCBmb3JtYXRMaW1pdCBmcm9tIFwiLi9saW1pdFwiXG5pbXBvcnQgdHlwZSBBanYgZnJvbSBcImFqdlwiXG5pbXBvcnQgdHlwZSB7UGx1Z2luLCBGb3JtYXR9IGZyb20gXCJhanZcIlxuaW1wb3J0IHtfLCBOYW1lfSBmcm9tIFwiYWp2L2Rpc3QvY29tcGlsZS9jb2RlZ2VuXCJcblxuZXhwb3J0IHtGb3JtYXRNb2RlLCBGb3JtYXROYW1lfSBmcm9tIFwiLi9mb3JtYXRzXCJcbmV4cG9ydCB7TGltaXRGb3JtYXRFcnJvcn0gZnJvbSBcIi4vbGltaXRcIlxuZXhwb3J0IGludGVyZmFjZSBGb3JtYXRPcHRpb25zIHtcbiAgbW9kZT86IEZvcm1hdE1vZGVcbiAgZm9ybWF0cz86IEZvcm1hdE5hbWVbXVxuICBrZXl3b3Jkcz86IGJvb2xlYW5cbn1cblxuZXhwb3J0IHR5cGUgRm9ybWF0c1BsdWdpbk9wdGlvbnMgPSBGb3JtYXROYW1lW10gfCBGb3JtYXRPcHRpb25zXG5cbmV4cG9ydCBpbnRlcmZhY2UgRm9ybWF0c1BsdWdpbiBleHRlbmRzIFBsdWdpbjxGb3JtYXRzUGx1Z2luT3B0aW9ucz4ge1xuICBnZXQ6IChmb3JtYXQ6IEZvcm1hdE5hbWUsIG1vZGU/OiBGb3JtYXRNb2RlKSA9PiBGb3JtYXRcbn1cblxuY29uc3QgZnVsbE5hbWUgPSBuZXcgTmFtZShcImZ1bGxGb3JtYXRzXCIpXG5jb25zdCBmYXN0TmFtZSA9IG5ldyBOYW1lKFwiZmFzdEZvcm1hdHNcIilcblxuY29uc3QgZm9ybWF0c1BsdWdpbjogRm9ybWF0c1BsdWdpbiA9IChcbiAgYWp2OiBBanYsXG4gIG9wdHM6IEZvcm1hdHNQbHVnaW5PcHRpb25zID0ge2tleXdvcmRzOiB0cnVlfVxuKTogQWp2ID0+IHtcbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0cykpIHtcbiAgICBhZGRGb3JtYXRzKGFqdiwgb3B0cywgZnVsbEZvcm1hdHMsIGZ1bGxOYW1lKVxuICAgIHJldHVybiBhanZcbiAgfVxuICBjb25zdCBbZm9ybWF0cywgZXhwb3J0TmFtZV0gPVxuICAgIG9wdHMubW9kZSA9PT0gXCJmYXN0XCIgPyBbZmFzdEZvcm1hdHMsIGZhc3ROYW1lXSA6IFtmdWxsRm9ybWF0cywgZnVsbE5hbWVdXG4gIGNvbnN0IGxpc3QgPSBvcHRzLmZvcm1hdHMgfHwgZm9ybWF0TmFtZXNcbiAgYWRkRm9ybWF0cyhhanYsIGxpc3QsIGZvcm1hdHMsIGV4cG9ydE5hbWUpXG4gIGlmIChvcHRzLmtleXdvcmRzKSBmb3JtYXRMaW1pdChhanYpXG4gIHJldHVybiBhanZcbn1cblxuZm9ybWF0c1BsdWdpbi5nZXQgPSAobmFtZTogRm9ybWF0TmFtZSwgbW9kZTogRm9ybWF0TW9kZSA9IFwiZnVsbFwiKTogRm9ybWF0ID0+IHtcbiAgY29uc3QgZm9ybWF0cyA9IG1vZGUgPT09IFwiZmFzdFwiID8gZmFzdEZvcm1hdHMgOiBmdWxsRm9ybWF0c1xuICBjb25zdCBmID0gZm9ybWF0c1tuYW1lXVxuICBpZiAoIWYpIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBmb3JtYXQgXCIke25hbWV9XCJgKVxuICByZXR1cm4gZlxufVxuXG5mdW5jdGlvbiBhZGRGb3JtYXRzKGFqdjogQWp2LCBsaXN0OiBGb3JtYXROYW1lW10sIGZzOiBEZWZpbmVkRm9ybWF0cywgZXhwb3J0TmFtZTogTmFtZSk6IHZvaWQge1xuICBhanYub3B0cy5jb2RlLmZvcm1hdHMgPz89IF9gcmVxdWlyZShcImFqdi1mb3JtYXRzL2Rpc3QvZm9ybWF0c1wiKS4ke2V4cG9ydE5hbWV9YFxuICBmb3IgKGNvbnN0IGYgb2YgbGlzdCkgYWp2LmFkZEZvcm1hdChmLCBmc1tmXSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZm9ybWF0c1BsdWdpblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7dmFsdWU6IHRydWV9KVxuXG5leHBvcnQgZGVmYXVsdCBmb3JtYXRzUGx1Z2luXG4iLCAiZXhwb3J0IHZhciB1dGlsO1xuKGZ1bmN0aW9uICh1dGlsKSB7XG4gICAgdXRpbC5hc3NlcnRFcXVhbCA9IChfKSA9PiB7IH07XG4gICAgZnVuY3Rpb24gYXNzZXJ0SXMoX2FyZykgeyB9XG4gICAgdXRpbC5hc3NlcnRJcyA9IGFzc2VydElzO1xuICAgIGZ1bmN0aW9uIGFzc2VydE5ldmVyKF94KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgIH1cbiAgICB1dGlsLmFzc2VydE5ldmVyID0gYXNzZXJ0TmV2ZXI7XG4gICAgdXRpbC5hcnJheVRvRW51bSA9IChpdGVtcykgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBvYmpbaXRlbV0gPSBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgICB1dGlsLmdldFZhbGlkRW51bVZhbHVlcyA9IChvYmopID0+IHtcbiAgICAgICAgY29uc3QgdmFsaWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKG9iaikuZmlsdGVyKChrKSA9PiB0eXBlb2Ygb2JqW29ialtrXV0gIT09IFwibnVtYmVyXCIpO1xuICAgICAgICBjb25zdCBmaWx0ZXJlZCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGsgb2YgdmFsaWRLZXlzKSB7XG4gICAgICAgICAgICBmaWx0ZXJlZFtrXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXRpbC5vYmplY3RWYWx1ZXMoZmlsdGVyZWQpO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RWYWx1ZXMgPSAob2JqKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdEtleXMob2JqKS5tYXAoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmpbZV07XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdXRpbC5vYmplY3RLZXlzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSBcImZ1bmN0aW9uXCIgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgID8gKG9iaikgPT4gT2JqZWN0LmtleXMob2JqKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGJhbi9iYW5cbiAgICAgICAgOiAob2JqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5cztcbiAgICAgICAgfTtcbiAgICB1dGlsLmZpbmQgPSAoYXJyLCBjaGVja2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyKGl0ZW0pKVxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB1dGlsLmlzSW50ZWdlciA9IHR5cGVvZiBOdW1iZXIuaXNJbnRlZ2VyID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyAodmFsKSA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBiYW4vYmFuXG4gICAgICAgIDogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gXCJudW1iZXJcIiAmJiBOdW1iZXIuaXNGaW5pdGUodmFsKSAmJiBNYXRoLmZsb29yKHZhbCkgPT09IHZhbDtcbiAgICBmdW5jdGlvbiBqb2luVmFsdWVzKGFycmF5LCBzZXBhcmF0b3IgPSBcIiB8IFwiKSB7XG4gICAgICAgIHJldHVybiBhcnJheS5tYXAoKHZhbCkgPT4gKHR5cGVvZiB2YWwgPT09IFwic3RyaW5nXCIgPyBgJyR7dmFsfSdgIDogdmFsKSkuam9pbihzZXBhcmF0b3IpO1xuICAgIH1cbiAgICB1dGlsLmpvaW5WYWx1ZXMgPSBqb2luVmFsdWVzO1xuICAgIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyID0gKF8sIHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufSkodXRpbCB8fCAodXRpbCA9IHt9KSk7XG5leHBvcnQgdmFyIG9iamVjdFV0aWw7XG4oZnVuY3Rpb24gKG9iamVjdFV0aWwpIHtcbiAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzID0gKGZpcnN0LCBzZWNvbmQpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmZpcnN0LFxuICAgICAgICAgICAgLi4uc2Vjb25kLCAvLyBzZWNvbmQgb3ZlcndyaXRlcyBmaXJzdFxuICAgICAgICB9O1xuICAgIH07XG59KShvYmplY3RVdGlsIHx8IChvYmplY3RVdGlsID0ge30pKTtcbmV4cG9ydCBjb25zdCBab2RQYXJzZWRUeXBlID0gdXRpbC5hcnJheVRvRW51bShbXG4gICAgXCJzdHJpbmdcIixcbiAgICBcIm5hblwiLFxuICAgIFwibnVtYmVyXCIsXG4gICAgXCJpbnRlZ2VyXCIsXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiYm9vbGVhblwiLFxuICAgIFwiZGF0ZVwiLFxuICAgIFwiYmlnaW50XCIsXG4gICAgXCJzeW1ib2xcIixcbiAgICBcImZ1bmN0aW9uXCIsXG4gICAgXCJ1bmRlZmluZWRcIixcbiAgICBcIm51bGxcIixcbiAgICBcImFycmF5XCIsXG4gICAgXCJvYmplY3RcIixcbiAgICBcInVua25vd25cIixcbiAgICBcInByb21pc2VcIixcbiAgICBcInZvaWRcIixcbiAgICBcIm5ldmVyXCIsXG4gICAgXCJtYXBcIixcbiAgICBcInNldFwiLFxuXSk7XG5leHBvcnQgY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQ7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN0cmluZztcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFpvZFBhcnNlZFR5cGUubmFuIDogWm9kUGFyc2VkVHlwZS5udW1iZXI7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5ib29sZWFuO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmZ1bmN0aW9uO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5iaWdpbnQ7XG4gICAgICAgIGNhc2UgXCJzeW1ib2xcIjpcbiAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnN5bWJvbDtcbiAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5hcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhLnRoZW4gJiYgdHlwZW9mIGRhdGEudGhlbiA9PT0gXCJmdW5jdGlvblwiICYmIGRhdGEuY2F0Y2ggJiYgdHlwZW9mIGRhdGEuY2F0Y2ggPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIE1hcCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFpvZFBhcnNlZFR5cGUubWFwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLnNldDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgRGF0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBab2RQYXJzZWRUeXBlLmRhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS5vYmplY3Q7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gWm9kUGFyc2VkVHlwZS51bmtub3duO1xuICAgIH1cbn07XG4iLCAiaW1wb3J0IHsgdXRpbCB9IGZyb20gXCIuL2hlbHBlcnMvdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0IFpvZElzc3VlQ29kZSA9IHV0aWwuYXJyYXlUb0VudW0oW1xuICAgIFwiaW52YWxpZF90eXBlXCIsXG4gICAgXCJpbnZhbGlkX2xpdGVyYWxcIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiaW52YWxpZF91bmlvblwiLFxuICAgIFwiaW52YWxpZF91bmlvbl9kaXNjcmltaW5hdG9yXCIsXG4gICAgXCJpbnZhbGlkX2VudW1fdmFsdWVcIixcbiAgICBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgXCJpbnZhbGlkX2FyZ3VtZW50c1wiLFxuICAgIFwiaW52YWxpZF9yZXR1cm5fdHlwZVwiLFxuICAgIFwiaW52YWxpZF9kYXRlXCIsXG4gICAgXCJpbnZhbGlkX3N0cmluZ1wiLFxuICAgIFwidG9vX3NtYWxsXCIsXG4gICAgXCJ0b29fYmlnXCIsXG4gICAgXCJpbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlc1wiLFxuICAgIFwibm90X211bHRpcGxlX29mXCIsXG4gICAgXCJub3RfZmluaXRlXCIsXG5dKTtcbmV4cG9ydCBjb25zdCBxdW90ZWxlc3NKc29uID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpO1xuICAgIHJldHVybiBqc29uLnJlcGxhY2UoL1wiKFteXCJdKylcIjovZywgXCIkMTpcIik7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzc3VlcztcbiAgICB9XG4gICAgY29uc3RydWN0b3IoaXNzdWVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gW107XG4gICAgICAgIHRoaXMuYWRkSXNzdWUgPSAoc3ViKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3Vlcywgc3ViXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRJc3N1ZXMgPSAoc3VicyA9IFtdKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmlzc3VlcyA9IFsuLi50aGlzLmlzc3VlcywgLi4uc3Vic107XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGFjdHVhbFByb3RvID0gbmV3LnRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgYWN0dWFsUHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBhY3R1YWxQcm90bztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVycm9yXCI7XG4gICAgICAgIHRoaXMuaXNzdWVzID0gaXNzdWVzO1xuICAgIH1cbiAgICBmb3JtYXQoX21hcHBlcikge1xuICAgICAgICBjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoaXNzdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNzdWUubWVzc2FnZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JzID0geyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICBjb25zdCBwcm9jZXNzRXJyb3IgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlLnVuaW9uRXJyb3JzLm1hcChwcm9jZXNzRXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfcmV0dXJuX3R5cGVcIikge1xuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoaXNzdWUucmV0dXJuVHlwZUVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2FyZ3VtZW50c1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcihpc3N1ZS5hcmd1bWVudHNFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjdXJyID0gZmllbGRFcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKGkgPCBpc3N1ZS5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZWwgPSBpc3N1ZS5wYXRoW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfSBlbHNlIGlmICh0eXBlb2YgZWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAgIGNvbnN0IGVycm9yQXJyYXk6IGFueSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgZXJyb3JBcnJheS5fZXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IGVycm9yQXJyYXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBwcm9jZXNzRXJyb3IodGhpcyk7XG4gICAgICAgIHJldHVybiBmaWVsZEVycm9ycztcbiAgICB9XG4gICAgc3RhdGljIGFzc2VydCh2YWx1ZSkge1xuICAgICAgICBpZiAoISh2YWx1ZSBpbnN0YW5jZW9mIFpvZEVycm9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb3QgYSBab2RFcnJvcjogJHt2YWx1ZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZTtcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh0aGlzLmlzc3VlcywgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgIH1cbiAgICBnZXQgaXNFbXB0eSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICB9XG4gICAgZmxhdHRlbihtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZmllbGRFcnJvcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBjb25zdCBmb3JtRXJyb3JzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgc3ViIG9mIHRoaXMuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoc3ViLnBhdGgubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0RWwgPSBzdWIucGF0aFswXTtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9yc1tmaXJzdEVsXSA9IGZpZWxkRXJyb3JzW2ZpcnN0RWxdIHx8IFtdO1xuICAgICAgICAgICAgICAgIGZpZWxkRXJyb3JzW2ZpcnN0RWxdLnB1c2gobWFwcGVyKHN1YikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBmb3JtRXJyb3JzLCBmaWVsZEVycm9ycyB9O1xuICAgIH1cbiAgICBnZXQgZm9ybUVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmxhdHRlbigpO1xuICAgIH1cbn1cblpvZEVycm9yLmNyZWF0ZSA9IChpc3N1ZXMpID0+IHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBab2RFcnJvcihpc3N1ZXMpO1xuICAgIHJldHVybiBlcnJvcjtcbn07XG4iLCAiaW1wb3J0IHsgWm9kSXNzdWVDb2RlIH0gZnJvbSBcIi4uL1pvZEVycm9yLmpzXCI7XG5pbXBvcnQgeyB1dGlsLCBab2RQYXJzZWRUeXBlIH0gZnJvbSBcIi4uL2hlbHBlcnMvdXRpbC5qc1wiO1xuY29uc3QgZXJyb3JNYXAgPSAoaXNzdWUsIF9jdHgpID0+IHtcbiAgICBsZXQgbWVzc2FnZTtcbiAgICBzd2l0Y2ggKGlzc3VlLmNvZGUpIHtcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnJlY2VpdmVkID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlJlcXVpcmVkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEV4cGVjdGVkICR7aXNzdWUuZXhwZWN0ZWR9LCByZWNlaXZlZCAke2lzc3VlLnJlY2VpdmVkfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9saXRlcmFsOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGxpdGVyYWwgdmFsdWUsIGV4cGVjdGVkICR7SlNPTi5zdHJpbmdpZnkoaXNzdWUuZXhwZWN0ZWQsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLnVucmVjb2duaXplZF9rZXlzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBVbnJlY29nbml6ZWQga2V5KHMpIGluIG9iamVjdDogJHt1dGlsLmpvaW5WYWx1ZXMoaXNzdWUua2V5cywgXCIsIFwiKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb246XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb25fZGlzY3JpbWluYXRvcjpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX1gO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBlbnVtIHZhbHVlLiBFeHBlY3RlZCAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5vcHRpb25zKX0sIHJlY2VpdmVkICcke2lzc3VlLnJlY2VpdmVkfSdgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfYXJndW1lbnRzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGZ1bmN0aW9uIGFyZ3VtZW50c2A7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9yZXR1cm5fdHlwZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBmdW5jdGlvbiByZXR1cm4gdHlwZWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUuaW52YWxpZF9kYXRlOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnZhbGlkIGRhdGVgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaW5jbHVkZXNcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBpbmNsdWRlIFwiJHtpc3N1ZS52YWxpZGF0aW9uLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpc3N1ZS52YWxpZGF0aW9uLnBvc2l0aW9uID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYCR7bWVzc2FnZX0gYXQgb25lIG9yIG1vcmUgcG9zaXRpb25zIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke2lzc3VlLnZhbGlkYXRpb24ucG9zaXRpb259YDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcInN0YXJ0c1dpdGhcIiBpbiBpc3N1ZS52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBpbnB1dDogbXVzdCBzdGFydCB3aXRoIFwiJHtpc3N1ZS52YWxpZGF0aW9uLnN0YXJ0c1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChcImVuZHNXaXRoXCIgaW4gaXNzdWUudmFsaWRhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXQ6IG11c3QgZW5kIHdpdGggXCIke2lzc3VlLnZhbGlkYXRpb24uZW5kc1dpdGh9XCJgO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihpc3N1ZS52YWxpZGF0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS52YWxpZGF0aW9uICE9PSBcInJlZ2V4XCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgJHtpc3N1ZS52YWxpZGF0aW9ufWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX3NtYWxsOlxuICAgICAgICAgICAgaWYgKGlzc3VlLnR5cGUgPT09IFwiYXJyYXlcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYEFycmF5IG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG1vcmUgdGhhbmB9ICR7aXNzdWUubWluaW11bX0gZWxlbWVudChzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgU3RyaW5nIG11c3QgY29udGFpbiAke2lzc3VlLmV4YWN0ID8gXCJleGFjdGx5XCIgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgYXQgbGVhc3RgIDogYG92ZXJgfSAke2lzc3VlLm1pbmltdW19IGNoYXJhY3RlcihzKWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgTnVtYmVyIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5IGVxdWFsIHRvIGAgOiBpc3N1ZS5pbmNsdXNpdmUgPyBgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIGAgOiBgZ3JlYXRlciB0aGFuIGB9JHtpc3N1ZS5taW5pbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImRhdGVcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYERhdGUgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHkgZXF1YWwgdG8gYCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gYCA6IGBncmVhdGVyIHRoYW4gYH0ke25ldyBEYXRlKE51bWJlcihpc3N1ZS5taW5pbXVtKSl9YDtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUudG9vX2JpZzpcbiAgICAgICAgICAgIGlmIChpc3N1ZS50eXBlID09PSBcImFycmF5XCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBBcnJheSBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGBsZXNzIHRoYW5gfSAke2lzc3VlLm1heGltdW19IGVsZW1lbnQocylgO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gYFN0cmluZyBtdXN0IGNvbnRhaW4gJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBhdCBtb3N0YCA6IGB1bmRlcmB9ICR7aXNzdWUubWF4aW11bX0gY2hhcmFjdGVyKHMpYDtcbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLnR5cGUgPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBOdW1iZXIgbXVzdCBiZSAke2lzc3VlLmV4YWN0ID8gYGV4YWN0bHlgIDogaXNzdWUuaW5jbHVzaXZlID8gYGxlc3MgdGhhbiBvciBlcXVhbCB0b2AgOiBgbGVzcyB0aGFuYH0gJHtpc3N1ZS5tYXhpbXVtfWA7XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS50eXBlID09PSBcImJpZ2ludFwiKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBgQmlnSW50IG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBsZXNzIHRoYW4gb3IgZXF1YWwgdG9gIDogYGxlc3MgdGhhbmB9ICR7aXNzdWUubWF4aW11bX1gO1xuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUudHlwZSA9PT0gXCJkYXRlXCIpXG4gICAgICAgICAgICAgICAgbWVzc2FnZSA9IGBEYXRlIG11c3QgYmUgJHtpc3N1ZS5leGFjdCA/IGBleGFjdGx5YCA6IGlzc3VlLmluY2x1c2l2ZSA/IGBzbWFsbGVyIHRoYW4gb3IgZXF1YWwgdG9gIDogYHNtYWxsZXIgdGhhbmB9ICR7bmV3IERhdGUoTnVtYmVyKGlzc3VlLm1heGltdW0pKX1gO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5jdXN0b206XG4gICAgICAgICAgICBtZXNzYWdlID0gYEludmFsaWQgaW5wdXRgO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgWm9kSXNzdWVDb2RlLmludmFsaWRfaW50ZXJzZWN0aW9uX3R5cGVzOlxuICAgICAgICAgICAgbWVzc2FnZSA9IGBJbnRlcnNlY3Rpb24gcmVzdWx0cyBjb3VsZCBub3QgYmUgbWVyZ2VkYDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFpvZElzc3VlQ29kZS5ub3RfbXVsdGlwbGVfb2Y6XG4gICAgICAgICAgICBtZXNzYWdlID0gYE51bWJlciBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgJHtpc3N1ZS5tdWx0aXBsZU9mfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBab2RJc3N1ZUNvZGUubm90X2Zpbml0ZTpcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIk51bWJlciBtdXN0IGJlIGZpbml0ZVwiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBtZXNzYWdlID0gX2N0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGlzc3VlKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgbWVzc2FnZSB9O1xufTtcbmV4cG9ydCBkZWZhdWx0IGVycm9yTWFwO1xuIiwgImltcG9ydCBkZWZhdWx0RXJyb3JNYXAgZnJvbSBcIi4vbG9jYWxlcy9lbi5qc1wiO1xubGV0IG92ZXJyaWRlRXJyb3JNYXAgPSBkZWZhdWx0RXJyb3JNYXA7XG5leHBvcnQgeyBkZWZhdWx0RXJyb3JNYXAgfTtcbmV4cG9ydCBmdW5jdGlvbiBzZXRFcnJvck1hcChtYXApIHtcbiAgICBvdmVycmlkZUVycm9yTWFwID0gbWFwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVycm9yTWFwKCkge1xuICAgIHJldHVybiBvdmVycmlkZUVycm9yTWFwO1xufVxuIiwgImltcG9ydCB7IGdldEVycm9yTWFwIH0gZnJvbSBcIi4uL2Vycm9ycy5qc1wiO1xuaW1wb3J0IGRlZmF1bHRFcnJvck1hcCBmcm9tIFwiLi4vbG9jYWxlcy9lbi5qc1wiO1xuZXhwb3J0IGNvbnN0IG1ha2VJc3N1ZSA9IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCB7IGRhdGEsIHBhdGgsIGVycm9yTWFwcywgaXNzdWVEYXRhIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgZnVsbFBhdGggPSBbLi4ucGF0aCwgLi4uKGlzc3VlRGF0YS5wYXRoIHx8IFtdKV07XG4gICAgY29uc3QgZnVsbElzc3VlID0ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgIH07XG4gICAgaWYgKGlzc3VlRGF0YS5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmlzc3VlRGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICAgICAgbWVzc2FnZTogaXNzdWVEYXRhLm1lc3NhZ2UsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGxldCBlcnJvck1lc3NhZ2UgPSBcIlwiO1xuICAgIGNvbnN0IG1hcHMgPSBlcnJvck1hcHNcbiAgICAgICAgLmZpbHRlcigobSkgPT4gISFtKVxuICAgICAgICAuc2xpY2UoKVxuICAgICAgICAucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3QgbWFwIG9mIG1hcHMpIHtcbiAgICAgICAgZXJyb3JNZXNzYWdlID0gbWFwKGZ1bGxJc3N1ZSwgeyBkYXRhLCBkZWZhdWx0RXJyb3I6IGVycm9yTWVzc2FnZSB9KS5tZXNzYWdlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5pc3N1ZURhdGEsXG4gICAgICAgIHBhdGg6IGZ1bGxQYXRoLFxuICAgICAgICBtZXNzYWdlOiBlcnJvck1lc3NhZ2UsXG4gICAgfTtcbn07XG5leHBvcnQgY29uc3QgRU1QVFlfUEFUSCA9IFtdO1xuZXhwb3J0IGZ1bmN0aW9uIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgaXNzdWVEYXRhKSB7XG4gICAgY29uc3Qgb3ZlcnJpZGVNYXAgPSBnZXRFcnJvck1hcCgpO1xuICAgIGNvbnN0IGlzc3VlID0gbWFrZUlzc3VlKHtcbiAgICAgICAgaXNzdWVEYXRhOiBpc3N1ZURhdGEsXG4gICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgZXJyb3JNYXBzOiBbXG4gICAgICAgICAgICBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgLy8gY29udGV4dHVhbCBlcnJvciBtYXAgaXMgZmlyc3QgcHJpb3JpdHlcbiAgICAgICAgICAgIGN0eC5zY2hlbWFFcnJvck1hcCwgLy8gdGhlbiBzY2hlbWEtYm91bmQgbWFwIGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAsIC8vIHRoZW4gZ2xvYmFsIG92ZXJyaWRlIG1hcFxuICAgICAgICAgICAgb3ZlcnJpZGVNYXAgPT09IGRlZmF1bHRFcnJvck1hcCA/IHVuZGVmaW5lZCA6IGRlZmF1bHRFcnJvck1hcCwgLy8gdGhlbiBnbG9iYWwgZGVmYXVsdCBtYXBcbiAgICAgICAgXS5maWx0ZXIoKHgpID0+ICEheCksXG4gICAgfSk7XG4gICAgY3R4LmNvbW1vbi5pc3N1ZXMucHVzaChpc3N1ZSk7XG59XG5leHBvcnQgY2xhc3MgUGFyc2VTdGF0dXMge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlID0gXCJ2YWxpZFwiO1xuICAgIH1cbiAgICBkaXJ0eSgpIHtcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgPT09IFwidmFsaWRcIilcbiAgICAgICAgICAgIHRoaXMudmFsdWUgPSBcImRpcnR5XCI7XG4gICAgfVxuICAgIGFib3J0KCkge1xuICAgICAgICBpZiAodGhpcy52YWx1ZSAhPT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gXCJhYm9ydGVkXCI7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZUFycmF5KHN0YXR1cywgcmVzdWx0cykge1xuICAgICAgICBjb25zdCBhcnJheVZhbHVlID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocy5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKHMuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICBhcnJheVZhbHVlLnB1c2gocy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBhcnJheVZhbHVlIH07XG4gICAgfVxuICAgIHN0YXRpYyBhc3luYyBtZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpIHtcbiAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYXdhaXQgcGFpci5rZXk7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICBzeW5jUGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHN5bmNQYWlycyk7XG4gICAgfVxuICAgIHN0YXRpYyBtZXJnZU9iamVjdFN5bmMoc3RhdHVzLCBwYWlycykge1xuICAgICAgICBjb25zdCBmaW5hbE9iamVjdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhaXIgb2YgcGFpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gcGFpcjtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIGlmIChrZXkudmFsdWUgIT09IFwiX19wcm90b19fXCIgJiYgKHR5cGVvZiB2YWx1ZS52YWx1ZSAhPT0gXCJ1bmRlZmluZWRcIiB8fCBwYWlyLmFsd2F5c1NldCkpIHtcbiAgICAgICAgICAgICAgICBmaW5hbE9iamVjdFtrZXkudmFsdWVdID0gdmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBmaW5hbE9iamVjdCB9O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBJTlZBTElEID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgc3RhdHVzOiBcImFib3J0ZWRcIixcbn0pO1xuZXhwb3J0IGNvbnN0IERJUlRZID0gKHZhbHVlKSA9PiAoeyBzdGF0dXM6IFwiZGlydHlcIiwgdmFsdWUgfSk7XG5leHBvcnQgY29uc3QgT0sgPSAodmFsdWUpID0+ICh7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZSB9KTtcbmV4cG9ydCBjb25zdCBpc0Fib3J0ZWQgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiO1xuZXhwb3J0IGNvbnN0IGlzRGlydHkgPSAoeCkgPT4geC5zdGF0dXMgPT09IFwiZGlydHlcIjtcbmV4cG9ydCBjb25zdCBpc1ZhbGlkID0gKHgpID0+IHguc3RhdHVzID09PSBcInZhbGlkXCI7XG5leHBvcnQgY29uc3QgaXNBc3luYyA9ICh4KSA9PiB0eXBlb2YgUHJvbWlzZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB4IGluc3RhbmNlb2YgUHJvbWlzZTtcbiIsICJleHBvcnQgdmFyIGVycm9yVXRpbDtcbihmdW5jdGlvbiAoZXJyb3JVdGlsKSB7XG4gICAgZXJyb3JVdGlsLmVyclRvT2JqID0gKG1lc3NhZ2UpID0+IHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlIH0gOiBtZXNzYWdlIHx8IHt9O1xuICAgIC8vIGJpb21lLWlnbm9yZSBsaW50OlxuICAgIGVycm9yVXRpbC50b1N0cmluZyA9IChtZXNzYWdlKSA9PiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIiA/IG1lc3NhZ2UgOiBtZXNzYWdlPy5tZXNzYWdlO1xufSkoZXJyb3JVdGlsIHx8IChlcnJvclV0aWwgPSB7fSkpO1xuIiwgImltcG9ydCB7IFpvZEVycm9yLCBab2RJc3N1ZUNvZGUsIH0gZnJvbSBcIi4vWm9kRXJyb3IuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRFcnJvck1hcCwgZ2V0RXJyb3JNYXAgfSBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmltcG9ydCB7IGVycm9yVXRpbCB9IGZyb20gXCIuL2hlbHBlcnMvZXJyb3JVdGlsLmpzXCI7XG5pbXBvcnQgeyBESVJUWSwgSU5WQUxJRCwgT0ssIFBhcnNlU3RhdHVzLCBhZGRJc3N1ZVRvQ29udGV4dCwgaXNBYm9ydGVkLCBpc0FzeW5jLCBpc0RpcnR5LCBpc1ZhbGlkLCBtYWtlSXNzdWUsIH0gZnJvbSBcIi4vaGVscGVycy9wYXJzZVV0aWwuanNcIjtcbmltcG9ydCB7IHV0aWwsIFpvZFBhcnNlZFR5cGUsIGdldFBhcnNlZFR5cGUgfSBmcm9tIFwiLi9oZWxwZXJzL3V0aWwuanNcIjtcbmNsYXNzIFBhcnNlSW5wdXRMYXp5UGF0aCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCB2YWx1ZSwgcGF0aCwga2V5KSB7XG4gICAgICAgIHRoaXMuX2NhY2hlZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgICAgIHRoaXMuZGF0YSA9IHZhbHVlO1xuICAgICAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5fa2V5ID0ga2V5O1xuICAgIH1cbiAgICBnZXQgcGF0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZWRQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5fa2V5KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlZFBhdGgucHVzaCguLi50aGlzLl9wYXRoLCAuLi50aGlzLl9rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2FjaGVkUGF0aC5wdXNoKC4uLnRoaXMuX3BhdGgsIHRoaXMuX2tleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlZFBhdGg7XG4gICAgfVxufVxuY29uc3QgaGFuZGxlUmVzdWx0ID0gKGN0eCwgcmVzdWx0KSA9PiB7XG4gICAgaWYgKGlzVmFsaWQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICghY3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWxpZGF0aW9uIGZhaWxlZCBidXQgbm8gaXNzdWVzIGRldGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Vycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZXJyb3I7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgWm9kRXJyb3IoY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Vycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuZnVuY3Rpb24gcHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpIHtcbiAgICBpZiAoIXBhcmFtcylcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IHsgZXJyb3JNYXAsIGludmFsaWRfdHlwZV9lcnJvciwgcmVxdWlyZWRfZXJyb3IsIGRlc2NyaXB0aW9uIH0gPSBwYXJhbXM7XG4gICAgaWYgKGVycm9yTWFwICYmIChpbnZhbGlkX3R5cGVfZXJyb3IgfHwgcmVxdWlyZWRfZXJyb3IpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgdXNlIFwiaW52YWxpZF90eXBlX2Vycm9yXCIgb3IgXCJyZXF1aXJlZF9lcnJvclwiIGluIGNvbmp1bmN0aW9uIHdpdGggY3VzdG9tIGVycm9yIG1hcC5gKTtcbiAgICB9XG4gICAgaWYgKGVycm9yTWFwKVxuICAgICAgICByZXR1cm4geyBlcnJvck1hcDogZXJyb3JNYXAsIGRlc2NyaXB0aW9uIH07XG4gICAgY29uc3QgY3VzdG9tTWFwID0gKGlzcywgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gcGFyYW1zO1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwiaW52YWxpZF9lbnVtX3ZhbHVlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmRhdGEgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IG1lc3NhZ2UgPz8gcmVxdWlyZWRfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc3MuY29kZSAhPT0gXCJpbnZhbGlkX3R5cGVcIilcbiAgICAgICAgICAgIHJldHVybiB7IG1lc3NhZ2U6IGN0eC5kZWZhdWx0RXJyb3IgfTtcbiAgICAgICAgcmV0dXJuIHsgbWVzc2FnZTogbWVzc2FnZSA/PyBpbnZhbGlkX3R5cGVfZXJyb3IgPz8gY3R4LmRlZmF1bHRFcnJvciB9O1xuICAgIH07XG4gICAgcmV0dXJuIHsgZXJyb3JNYXA6IGN1c3RvbU1hcCwgZGVzY3JpcHRpb24gfTtcbn1cbmV4cG9ydCBjbGFzcyBab2RUeXBlIHtcbiAgICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZGVzY3JpcHRpb247XG4gICAgfVxuICAgIF9nZXRUeXBlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRQYXJzZWRUeXBlKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBfZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCkge1xuICAgICAgICByZXR1cm4gKGN0eCB8fCB7XG4gICAgICAgICAgICBjb21tb246IGlucHV0LnBhcmVudC5jb21tb24sXG4gICAgICAgICAgICBkYXRhOiBpbnB1dC5kYXRhLFxuICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgIHNjaGVtYUVycm9yTWFwOiB0aGlzLl9kZWYuZXJyb3JNYXAsXG4gICAgICAgICAgICBwYXRoOiBpbnB1dC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0dXM6IG5ldyBQYXJzZVN0YXR1cygpLFxuICAgICAgICAgICAgY3R4OiB7XG4gICAgICAgICAgICAgICAgY29tbW9uOiBpbnB1dC5wYXJlbnQuY29tbW9uLFxuICAgICAgICAgICAgICAgIGRhdGE6IGlucHV0LmRhdGEsXG4gICAgICAgICAgICAgICAgcGFyc2VkVHlwZTogZ2V0UGFyc2VkVHlwZShpbnB1dC5kYXRhKSxcbiAgICAgICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgICAgIHBhdGg6IGlucHV0LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpbnB1dC5wYXJlbnQsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfcGFyc2VTeW5jKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKGlzQXN5bmMocmVzdWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3luY2hyb25vdXMgcGFyc2UgZW5jb3VudGVyZWQgcHJvbWlzZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgX3BhcnNlQXN5bmMoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fcGFyc2UoaW5wdXQpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgfVxuICAgIHBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNhZmVQYXJzZShkYXRhLCBwYXJhbXMpO1xuICAgICAgICBpZiAocmVzdWx0LnN1Y2Nlc3MpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LmRhdGE7XG4gICAgICAgIHRocm93IHJlc3VsdC5lcnJvcjtcbiAgICB9XG4gICAgc2FmZVBhcnNlKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiBwYXJhbXM/LmFzeW5jID8/IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuX3BhcnNlU3luYyh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIFwifnZhbGlkYXRlXCIoZGF0YSkge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGFzeW5jOiAhIXRoaXNbXCJ+c3RhbmRhcmRcIl0uYXN5bmMsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcGF0aDogW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9wYXJzZVN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWQocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnI/Lm1lc3NhZ2U/LnRvTG93ZXJDYXNlKCk/LmluY2x1ZGVzKFwiZW5jb3VudGVyZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tcIn5zdGFuZGFyZFwiXS5hc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN0eC5jb21tb24gPSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICAgICAgICAgIGFzeW5jOiB0cnVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlQXN5bmMoeyBkYXRhLCBwYXRoOiBbXSwgcGFyZW50OiBjdHggfSkudGhlbigocmVzdWx0KSA9PiBpc1ZhbGlkKHJlc3VsdClcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQudmFsdWUsXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IGN0eC5jb21tb24uaXNzdWVzLFxuICAgICAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2FmZVBhcnNlQXN5bmMoZGF0YSwgcGFyYW1zKTtcbiAgICAgICAgaWYgKHJlc3VsdC5zdWNjZXNzKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5kYXRhO1xuICAgICAgICB0aHJvdyByZXN1bHQuZXJyb3I7XG4gICAgfVxuICAgIGFzeW5jIHNhZmVQYXJzZUFzeW5jKGRhdGEsIHBhcmFtcykge1xuICAgICAgICBjb25zdCBjdHggPSB7XG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgIGNvbnRleHR1YWxFcnJvck1hcDogcGFyYW1zPy5lcnJvck1hcCxcbiAgICAgICAgICAgICAgICBhc3luYzogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXRoOiBwYXJhbXM/LnBhdGggfHwgW10sXG4gICAgICAgICAgICBzY2hlbWFFcnJvck1hcDogdGhpcy5fZGVmLmVycm9yTWFwLFxuICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhcnNlZFR5cGU6IGdldFBhcnNlZFR5cGUoZGF0YSksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG1heWJlQXN5bmNSZXN1bHQgPSB0aGlzLl9wYXJzZSh7IGRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgKGlzQXN5bmMobWF5YmVBc3luY1Jlc3VsdCkgPyBtYXliZUFzeW5jUmVzdWx0IDogUHJvbWlzZS5yZXNvbHZlKG1heWJlQXN5bmNSZXN1bHQpKTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZVJlc3VsdChjdHgsIHJlc3VsdCk7XG4gICAgfVxuICAgIHJlZmluZShjaGVjaywgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBnZXRJc3N1ZVByb3BlcnRpZXMgPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIG1lc3NhZ2UgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBtZXNzYWdlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVmaW5lbWVudCgodmFsLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGNoZWNrKHZhbCk7XG4gICAgICAgICAgICBjb25zdCBzZXRFcnJvciA9ICgpID0+IGN0eC5hZGRJc3N1ZSh7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmN1c3RvbSxcbiAgICAgICAgICAgICAgICAuLi5nZXRJc3N1ZVByb3BlcnRpZXModmFsKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBQcm9taXNlICE9PSBcInVuZGVmaW5lZFwiICYmIHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgc2V0RXJyb3IoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlZmluZW1lbnQoY2hlY2ssIHJlZmluZW1lbnREYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KCh2YWwsIGN0eCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjaGVjayh2YWwpKSB7XG4gICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHR5cGVvZiByZWZpbmVtZW50RGF0YSA9PT0gXCJmdW5jdGlvblwiID8gcmVmaW5lbWVudERhdGEodmFsLCBjdHgpIDogcmVmaW5lbWVudERhdGEpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3JlZmluZW1lbnQocmVmaW5lbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLFxuICAgICAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicmVmaW5lbWVudFwiLCByZWZpbmVtZW50IH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdXBlclJlZmluZShyZWZpbmVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWZpbmVtZW50KHJlZmluZW1lbnQpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihkZWYpIHtcbiAgICAgICAgLyoqIEFsaWFzIG9mIHNhZmVQYXJzZUFzeW5jICovXG4gICAgICAgIHRoaXMuc3BhID0gdGhpcy5zYWZlUGFyc2VBc3luYztcbiAgICAgICAgdGhpcy5fZGVmID0gZGVmO1xuICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5wYXJzZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZSA9IHRoaXMuc2FmZVBhcnNlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFyc2VBc3luYyA9IHRoaXMucGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNhZmVQYXJzZUFzeW5jID0gdGhpcy5zYWZlUGFyc2VBc3luYy5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnNwYSA9IHRoaXMuc3BhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucmVmaW5lID0gdGhpcy5yZWZpbmUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWZpbmVtZW50ID0gdGhpcy5yZWZpbmVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3VwZXJSZWZpbmUgPSB0aGlzLnN1cGVyUmVmaW5lLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub3B0aW9uYWwgPSB0aGlzLm9wdGlvbmFsLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGFibGUgPSB0aGlzLm51bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMubnVsbGlzaCA9IHRoaXMubnVsbGlzaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmFycmF5ID0gdGhpcy5hcnJheS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnByb21pc2UgPSB0aGlzLnByb21pc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vciA9IHRoaXMub3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5hbmQgPSB0aGlzLmFuZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybSA9IHRoaXMudHJhbnNmb3JtLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYnJhbmQgPSB0aGlzLmJyYW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuZGVmYXVsdCA9IHRoaXMuZGVmYXVsdC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmNhdGNoID0gdGhpcy5jYXRjaC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmRlc2NyaWJlID0gdGhpcy5kZXNjcmliZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpcGUgPSB0aGlzLnBpcGUuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5yZWFkb25seSA9IHRoaXMucmVhZG9ubHkuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5pc051bGxhYmxlID0gdGhpcy5pc051bGxhYmxlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuaXNPcHRpb25hbCA9IHRoaXMuaXNPcHRpb25hbC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzW1wifnN0YW5kYXJkXCJdID0ge1xuICAgICAgICAgICAgdmVyc2lvbjogMSxcbiAgICAgICAgICAgIHZlbmRvcjogXCJ6b2RcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiAoZGF0YSkgPT4gdGhpc1tcIn52YWxpZGF0ZVwiXShkYXRhKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgb3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUodGhpcywgdGhpcy5fZGVmKTtcbiAgICB9XG4gICAgbnVsbGlzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubnVsbGFibGUoKS5vcHRpb25hbCgpO1xuICAgIH1cbiAgICBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZEFycmF5LmNyZWF0ZSh0aGlzKTtcbiAgICB9XG4gICAgcHJvbWlzZSgpIHtcbiAgICAgICAgcmV0dXJuIFpvZFByb21pc2UuY3JlYXRlKHRoaXMsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIG9yKG9wdGlvbikge1xuICAgICAgICByZXR1cm4gWm9kVW5pb24uY3JlYXRlKFt0aGlzLCBvcHRpb25dLCB0aGlzLl9kZWYpO1xuICAgIH1cbiAgICBhbmQoaW5jb21pbmcpIHtcbiAgICAgICAgcmV0dXJuIFpvZEludGVyc2VjdGlvbi5jcmVhdGUodGhpcywgaW5jb21pbmcsIHRoaXMuX2RlZik7XG4gICAgfVxuICAgIHRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RFZmZlY3RzKHtcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXModGhpcy5fZGVmKSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcyxcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgICAgIGVmZmVjdDogeyB0eXBlOiBcInRyYW5zZm9ybVwiLCB0cmFuc2Zvcm0gfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQoZGVmKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGVmYXVsdCh7XG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgICAgICBpbm5lclR5cGU6IHRoaXMsXG4gICAgICAgICAgICBkZWZhdWx0VmFsdWU6IGRlZmF1bHRWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZERlZmF1bHQsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBicmFuZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RCcmFuZGVkKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kQnJhbmRlZCxcbiAgICAgICAgICAgIHR5cGU6IHRoaXMsXG4gICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXMuX2RlZiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaChkZWYpIHtcbiAgICAgICAgY29uc3QgY2F0Y2hWYWx1ZUZ1bmMgPSB0eXBlb2YgZGVmID09PSBcImZ1bmN0aW9uXCIgPyBkZWYgOiAoKSA9PiBkZWY7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQ2F0Y2goe1xuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyh0aGlzLl9kZWYpLFxuICAgICAgICAgICAgaW5uZXJUeXBlOiB0aGlzLFxuICAgICAgICAgICAgY2F0Y2hWYWx1ZTogY2F0Y2hWYWx1ZUZ1bmMsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZENhdGNoLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzY3JpYmUoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgVGhpcyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHJldHVybiBuZXcgVGhpcyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBpcGUodGFyZ2V0KSB7XG4gICAgICAgIHJldHVybiBab2RQaXBlbGluZS5jcmVhdGUodGhpcywgdGFyZ2V0KTtcbiAgICB9XG4gICAgcmVhZG9ubHkoKSB7XG4gICAgICAgIHJldHVybiBab2RSZWFkb25seS5jcmVhdGUodGhpcyk7XG4gICAgfVxuICAgIGlzT3B0aW9uYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZSh1bmRlZmluZWQpLnN1Y2Nlc3M7XG4gICAgfVxuICAgIGlzTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIH1cbn1cbmNvbnN0IGN1aWRSZWdleCA9IC9eY1teXFxzLV17OCx9JC9pO1xuY29uc3QgY3VpZDJSZWdleCA9IC9eWzAtOWEtel0rJC87XG5jb25zdCB1bGlkUmVnZXggPSAvXlswLTlBLUhKS01OUC1UVi1aXXsyNn0kL2k7XG4vLyBjb25zdCB1dWlkUmVnZXggPVxuLy8gICAvXihbYS1mMC05XXs4fS1bYS1mMC05XXs0fS1bMS01XVthLWYwLTldezN9LVthLWYwLTldezR9LVthLWYwLTldezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pO1xuY29uc3QgdXVpZFJlZ2V4ID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2k7XG5jb25zdCBuYW5vaWRSZWdleCA9IC9eW2EtejAtOV8tXXsyMX0kL2k7XG5jb25zdCBqd3RSZWdleCA9IC9eW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dK1xcLltBLVphLXowLTktX10qJC87XG5jb25zdCBkdXJhdGlvblJlZ2V4ID0gL15bLStdP1AoPyEkKSg/Oig/OlstK10/XFxkK1kpfCg/OlstK10/XFxkK1suLF1cXGQrWSQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86KD86Wy0rXT9cXGQrVyl8KD86Wy0rXT9cXGQrWy4sXVxcZCtXJCkpPyg/Oig/OlstK10/XFxkK0QpfCg/OlstK10/XFxkK1suLF1cXGQrRCQpKT8oPzpUKD89W1xcZCstXSkoPzooPzpbLStdP1xcZCtIKXwoPzpbLStdP1xcZCtbLixdXFxkK0gkKSk/KD86KD86Wy0rXT9cXGQrTSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtNJCkpPyg/OlstK10/XFxkKyg/OlsuLF1cXGQrKT9TKT8pPz8kLztcbi8vIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ2MTgxLzE1NTAxNTVcbi8vIG9sZCB2ZXJzaW9uOiB0b28gc2xvdywgZGlkbid0IHN1cHBvcnQgdW5pY29kZVxuLy8gY29uc3QgZW1haWxSZWdleCA9IC9eKCgoW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKyhcXC4oW2Etel18XFxkfFshI1xcJCUmJ1xcKlxcK1xcLVxcLz1cXD9cXF5fYHtcXHx9fl18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKykqKXwoKFxceDIyKSgoKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KChbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHg3Zl18XFx4MjF8W1xceDIzLVxceDViXXxbXFx4NWQtXFx4N2VdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoXFxcXChbXFx4MDEtXFx4MDlcXHgwYlxceDBjXFx4MGQtXFx4N2ZdfFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKSkpKSooKChcXHgyMHxcXHgwOSkqKFxceDBkXFx4MGEpKT8oXFx4MjB8XFx4MDkpKyk/KFxceDIyKSkpQCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKSQvaTtcbi8vb2xkIGVtYWlsIHJlZ2V4XG4vLyBjb25zdCBlbWFpbFJlZ2V4ID0gL14oKFtePD4oKVtcXF0uLDs6XFxzQFwiXSsoXFwuW148PigpW1xcXS4sOzpcXHNAXCJdKykqKXwoXCIuK1wiKSlAKCg/IS0pKFtePD4oKVtcXF0uLDs6XFxzQFwiXStcXC4pK1tePD4oKVtcXF0uLDs6XFxzQFwiXXsxLH0pW14tPD4oKVtcXF0uLDs6XFxzQFwiXSQvaTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKChbXjw+KClbXFxdXFxcXC4sOzpcXHNAXFxcIl0rKFxcLltePD4oKVtcXF1cXFxcLiw7Olxcc0BcXFwiXSspKil8KFxcXCIuK1xcXCIpKUAoKFxcWygoKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcLil7M30oKDI1WzAtNV0pfCgyWzAtNF1bMC05XSl8KDFbMC05XXsyfSl8KFswLTldezEsMn0pKVxcXSl8KFxcW0lQdjY6KChbYS1mMC05XXsxLDR9Oil7N318OjooW2EtZjAtOV17MSw0fTopezAsNn18KFthLWYwLTldezEsNH06KXsxfTooW2EtZjAtOV17MSw0fTopezAsNX18KFthLWYwLTldezEsNH06KXsyfTooW2EtZjAtOV17MSw0fTopezAsNH18KFthLWYwLTldezEsNH06KXszfTooW2EtZjAtOV17MSw0fTopezAsM318KFthLWYwLTldezEsNH06KXs0fTooW2EtZjAtOV17MSw0fTopezAsMn18KFthLWYwLTldezEsNH06KXs1fTooW2EtZjAtOV17MSw0fTopezAsMX0pKFthLWYwLTldezEsNH18KCgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpXFwuKXszfSgoMjVbMC01XSl8KDJbMC00XVswLTldKXwoMVswLTldezJ9KXwoWzAtOV17MSwyfSkpKVxcXSl8KFtBLVphLXowLTldKFtBLVphLXowLTktXSpbQS1aYS16MC05XSkqKFxcLltBLVphLXpdezIsfSkrKSkkLztcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXpBLVowLTlcXC5cXCFcXCNcXCRcXCVcXCZcXCdcXCpcXCtcXC9cXD1cXD9cXF5cXF9cXGBcXHtcXHxcXH1cXH5cXC1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXC5bYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8pKiQvO1xuLy8gY29uc3QgZW1haWxSZWdleCA9XG4vLyAgIC9eKD86W2EtejAtOSEjJCUmJyorLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXowLTkhIyQlJicqKy89P15fYHt8fX4tXSspKnxcIig/OltcXHgwMS1cXHgwOFxceDBiXFx4MGNcXHgwZS1cXHgxZlxceDIxXFx4MjMtXFx4NWJcXHg1ZC1cXHg3Zl18XFxcXFtcXHgwMS1cXHgwOVxceDBiXFx4MGNcXHgwZS1cXHg3Zl0pKlwiKUAoPzooPzpbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/XFwuKStbYS16MC05XSg/OlthLXowLTktXSpbYS16MC05XSk/fFxcWyg/Oig/OjI1WzAtNV18MlswLTRdWzAtOV18WzAxXT9bMC05XVswLTldPylcXC4pezN9KD86MjVbMC01XXwyWzAtNF1bMC05XXxbMDFdP1swLTldWzAtOV0/fFthLXowLTktXSpbYS16MC05XTooPzpbXFx4MDEtXFx4MDhcXHgwYlxceDBjXFx4MGUtXFx4MWZcXHgyMS1cXHg1YVxceDUzLVxceDdmXXxcXFxcW1xceDAxLVxceDA5XFx4MGJcXHgwY1xceDBlLVxceDdmXSkrKVxcXSkkL2k7XG5jb25zdCBlbWFpbFJlZ2V4ID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVowLTlfJytcXC1cXC5dKilbQS1aMC05XystXUAoW0EtWjAtOV1bQS1aMC05XFwtXSpcXC4pK1tBLVpdezIsfSQvaTtcbi8vIGNvbnN0IGVtYWlsUmVnZXggPVxuLy8gICAvXlthLXowLTkuISMkJSZcdTIwMTkqKy89P15fYHt8fX4tXStAW2EtejAtOS1dKyg/OlxcLlthLXowLTlcXC1dKykqJC9pO1xuLy8gZnJvbSBodHRwczovL3RoZWtldmluc2NvdHQuY29tL2Vtb2ppcy1pbi1qYXZhc2NyaXB0LyN3cml0aW5nLWEtcmVndWxhci1leHByZXNzaW9uXG5jb25zdCBfZW1vamlSZWdleCA9IGBeKFxcXFxwe0V4dGVuZGVkX1BpY3RvZ3JhcGhpY318XFxcXHB7RW1vamlfQ29tcG9uZW50fSkrJGA7XG5sZXQgZW1vamlSZWdleDtcbi8vIGZhc3Rlciwgc2ltcGxlciwgc2FmZXJcbmNvbnN0IGlwdjRSZWdleCA9IC9eKD86KD86MjVbMC01XXwyWzAtNF1bMC05XXwxWzAtOV1bMC05XXxbMS05XVswLTldfFswLTldKVxcLil7M30oPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pJC87XG5jb25zdCBpcHY0Q2lkclJlZ2V4ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC87XG4vLyBjb25zdCBpcHY2UmVnZXggPVxuLy8gL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC87XG5jb25zdCBpcHY2UmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSkkLztcbmNvbnN0IGlwdjZDaWRyUmVnZXggPSAvXigoWzAtOWEtZkEtRl17MSw0fTopezcsN31bMC05YS1mQS1GXXsxLDR9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw3fTp8KFswLTlhLWZBLUZdezEsNH06KXsxLDZ9OlswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDV9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDJ9fChbMC05YS1mQS1GXXsxLDR9Oil7MSw0fSg6WzAtOWEtZkEtRl17MSw0fSl7MSwzfXwoWzAtOWEtZkEtRl17MSw0fTopezEsM30oOlswLTlhLWZBLUZdezEsNH0pezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDJ9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDV9fFswLTlhLWZBLUZdezEsNH06KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw2fSl8OigoOlswLTlhLWZBLUZdezEsNH0pezEsN318Oil8ZmU4MDooOlswLTlhLWZBLUZdezAsNH0pezAsNH0lWzAtOWEtekEtWl17MSx9fDo6KGZmZmYoOjB7MSw0fSl7MCwxfTopezAsMX0oKDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKVxcLil7MywzfSgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSl8KFswLTlhLWZBLUZdezEsNH06KXsxLDR9OigoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5jb25zdCBiYXNlNjRSZWdleCA9IC9eKFswLTlhLXpBLVorL117NH0pKigoWzAtOWEtekEtWisvXXsyfT09KXwoWzAtOWEtekEtWisvXXszfT0pKT8kLztcbi8vIGh0dHBzOi8vYmFzZTY0Lmd1cnUvc3RhbmRhcmRzL2Jhc2U2NHVybFxuY29uc3QgYmFzZTY0dXJsUmVnZXggPSAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC87XG4vLyBzaW1wbGVcbi8vIGNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGBcXFxcZHs0fS1cXFxcZHsyfS1cXFxcZHsyfWA7XG4vLyBubyBsZWFwIHllYXIgdmFsaWRhdGlvblxuLy8gY29uc3QgZGF0ZVJlZ2V4U291cmNlID0gYFxcXFxkezR9LSgoMFsxMzU3OF18MTB8MTIpLTMxfCgwWzEzLTldfDFbMC0yXSktMzB8KDBbMS05XXwxWzAtMl0pLSgwWzEtOV18MVxcXFxkfDJcXFxcZCkpYDtcbi8vIHdpdGggbGVhcCB5ZWFyIHZhbGlkYXRpb25cbmNvbnN0IGRhdGVSZWdleFNvdXJjZSA9IGAoKFxcXFxkXFxcXGRbMjQ2OF1bMDQ4XXxcXFxcZFxcXFxkWzEzNTc5XVsyNl18XFxcXGRcXFxcZDBbNDhdfFswMjQ2OF1bMDQ4XTAwfFsxMzU3OV1bMjZdMDApLTAyLTI5fFxcXFxkezR9LSgoMFsxMzU3OF18MVswMl0pLSgwWzEtOV18WzEyXVxcXFxkfDNbMDFdKXwoMFs0NjldfDExKS0oMFsxLTldfFsxMl1cXFxcZHwzMCl8KDAyKS0oMFsxLTldfDFcXFxcZHwyWzAtOF0pKSlgO1xuY29uc3QgZGF0ZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXiR7ZGF0ZVJlZ2V4U291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVSZWdleFNvdXJjZShhcmdzKSB7XG4gICAgbGV0IHNlY29uZHNSZWdleFNvdXJjZSA9IGBbMC01XVxcXFxkYDtcbiAgICBpZiAoYXJncy5wcmVjaXNpb24pIHtcbiAgICAgICAgc2Vjb25kc1JlZ2V4U291cmNlID0gYCR7c2Vjb25kc1JlZ2V4U291cmNlfVxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YDtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXJncy5wcmVjaXNpb24gPT0gbnVsbCkge1xuICAgICAgICBzZWNvbmRzUmVnZXhTb3VyY2UgPSBgJHtzZWNvbmRzUmVnZXhTb3VyY2V9KFxcXFwuXFxcXGQrKT9gO1xuICAgIH1cbiAgICBjb25zdCBzZWNvbmRzUXVhbnRpZmllciA9IGFyZ3MucHJlY2lzaW9uID8gXCIrXCIgOiBcIj9cIjsgLy8gcmVxdWlyZSBzZWNvbmRzIGlmIHByZWNpc2lvbiBpcyBub256ZXJvXG4gICAgcmV0dXJuIGAoWzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZCg6JHtzZWNvbmRzUmVnZXhTb3VyY2V9KSR7c2Vjb25kc1F1YW50aWZpZXJ9YDtcbn1cbmZ1bmN0aW9uIHRpbWVSZWdleChhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3RpbWVSZWdleFNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZVJlZ2V4KGFyZ3MpIHtcbiAgICBsZXQgcmVnZXggPSBgJHtkYXRlUmVnZXhTb3VyY2V9VCR7dGltZVJlZ2V4U291cmNlKGFyZ3MpfWA7XG4gICAgY29uc3Qgb3B0cyA9IFtdO1xuICAgIG9wdHMucHVzaChhcmdzLmxvY2FsID8gYFo/YCA6IGBaYCk7XG4gICAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgICAgICBvcHRzLnB1c2goYChbKy1dXFxcXGR7Mn06P1xcXFxkezJ9KWApO1xuICAgIHJlZ2V4ID0gYCR7cmVnZXh9KCR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuZnVuY3Rpb24gaXNWYWxpZElQKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY2XCIgfHwgIXZlcnNpb24pICYmIGlwdjZSZWdleC50ZXN0KGlwKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaXNWYWxpZEpXVChqd3QsIGFsZykge1xuICAgIGlmICghand0UmVnZXgudGVzdChqd3QpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgW2hlYWRlcl0gPSBqd3Quc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQ29udmVydCBiYXNlNjR1cmwgdG8gYmFzZTY0XG4gICAgICAgIGNvbnN0IGJhc2U2NCA9IGhlYWRlclxuICAgICAgICAgICAgLnJlcGxhY2UoLy0vZywgXCIrXCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXy9nLCBcIi9cIilcbiAgICAgICAgICAgIC5wYWRFbmQoaGVhZGVyLmxlbmd0aCArICgoNCAtIChoZWFkZXIubGVuZ3RoICUgNCkpICUgNCksIFwiPVwiKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBkZWNvZGVkID0gSlNPTi5wYXJzZShhdG9iKGJhc2U2NCkpO1xuICAgICAgICBpZiAodHlwZW9mIGRlY29kZWQgIT09IFwib2JqZWN0XCIgfHwgZGVjb2RlZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKFwidHlwXCIgaW4gZGVjb2RlZCAmJiBkZWNvZGVkPy50eXAgIT09IFwiSldUXCIpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmICghZGVjb2RlZC5hbGcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChhbGcgJiYgZGVjb2RlZC5hbGcgIT09IGFsZylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzVmFsaWRDaWRyKGlwLCB2ZXJzaW9uKSB7XG4gICAgaWYgKCh2ZXJzaW9uID09PSBcInY0XCIgfHwgIXZlcnNpb24pICYmIGlwdjRDaWRyUmVnZXgudGVzdChpcCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICgodmVyc2lvbiA9PT0gXCJ2NlwiIHx8ICF2ZXJzaW9uKSAmJiBpcHY2Q2lkclJlZ2V4LnRlc3QoaXApKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgY2xhc3MgWm9kU3RyaW5nIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gU3RyaW5nKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnN0cmluZyxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb0JpZyA9IGlucHV0LmRhdGEubGVuZ3RoID4gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vU21hbGwgPSBpbnB1dC5kYXRhLmxlbmd0aCA8IGNoZWNrLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b29CaWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0b29TbWFsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbWFpbFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJlbWFpbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW1vamlcIikge1xuICAgICAgICAgICAgICAgIGlmICghZW1vamlSZWdleCkge1xuICAgICAgICAgICAgICAgICAgICBlbW9qaVJlZ2V4ID0gbmV3IFJlZ0V4cChfZW1vamlSZWdleCwgXCJ1XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWVtb2ppUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImVtb2ppXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ1dWlkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV1aWRSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXVpZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW5hbm9pZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJuYW5vaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImN1aWRcIikge1xuICAgICAgICAgICAgICAgIGlmICghY3VpZFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdWlkMlJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJjdWlkMlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bGlkUmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcInVsaWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInVybFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICBuZXcgVVJMKGlucHV0LmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgY2hlY2sucmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gY2hlY2sucmVnZXgudGVzdChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRlc3RSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJyZWdleFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidHJpbVwiKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IGlucHV0LmRhdGEudHJpbSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJpbmNsdWRlc1wiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbnB1dC5kYXRhLmluY2x1ZGVzKGNoZWNrLnZhbHVlLCBjaGVjay5wb3NpdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBpbmNsdWRlczogY2hlY2sudmFsdWUsIHBvc2l0aW9uOiBjaGVjay5wb3NpdGlvbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwidG9Mb3dlckNhc2VcIikge1xuICAgICAgICAgICAgICAgIGlucHV0LmRhdGEgPSBpbnB1dC5kYXRhLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcInRvVXBwZXJDYXNlXCIpIHtcbiAgICAgICAgICAgICAgICBpbnB1dC5kYXRhID0gaW5wdXQuZGF0YS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJzdGFydHNXaXRoXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlucHV0LmRhdGEuc3RhcnRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBzdGFydHNXaXRoOiBjaGVjay52YWx1ZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZW5kc1dpdGhcIikge1xuICAgICAgICAgICAgICAgIGlmICghaW5wdXQuZGF0YS5lbmRzV2l0aChjaGVjay52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogeyBlbmRzV2l0aDogY2hlY2sudmFsdWUgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImRhdGV0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGV0aW1lUmVnZXgoY2hlY2spO1xuICAgICAgICAgICAgICAgIGlmICghcmVnZXgudGVzdChpbnB1dC5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImRhdGV0aW1lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJkYXRlXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IGRhdGVSZWdleDtcbiAgICAgICAgICAgICAgICBpZiAoIXJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IHRpbWVSZWdleChjaGVjayk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwidGltZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiZHVyYXRpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZHVyYXRpb25SZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiZHVyYXRpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImlwXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRJUChpbnB1dC5kYXRhLCBjaGVjay52ZXJzaW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0aW9uOiBcImlwXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZEpXVChpbnB1dC5kYXRhLCBjaGVjay5hbGcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiand0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJjaWRyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDaWRyKGlucHV0LmRhdGEsIGNoZWNrLnZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiY2lkclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWJhc2U2NFJlZ2V4LnRlc3QoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvbjogXCJiYXNlNjRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3N0cmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcImJhc2U2NHVybFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFiYXNlNjR1cmxSZWdleC50ZXN0KGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IFwiYmFzZTY0dXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9zdHJpbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdXRpbC5hc3NlcnROZXZlcihjaGVjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiBzdGF0dXMudmFsdWUsIHZhbHVlOiBpbnB1dC5kYXRhIH07XG4gICAgfVxuICAgIF9yZWdleChyZWdleCwgdmFsaWRhdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWZpbmVtZW50KChkYXRhKSA9PiByZWdleC50ZXN0KGRhdGEpLCB7XG4gICAgICAgICAgICB2YWxpZGF0aW9uLFxuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfc3RyaW5nLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kU3RyaW5nKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVtYWlsKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJlbWFpbFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVybChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXJsXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgZW1vamkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImVtb2ppXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgdXVpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwidXVpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIG5hbm9pZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwibmFub2lkXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSB9KTtcbiAgICB9XG4gICAgY3VpZChtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiY3VpZFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGN1aWQyKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjdWlkMlwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIHVsaWQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcInVsaWRcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICBiYXNlNjQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImJhc2U2NFwiLCAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSkgfSk7XG4gICAgfVxuICAgIGJhc2U2NHVybChtZXNzYWdlKSB7XG4gICAgICAgIC8vIGJhc2U2NHVybCBlbmNvZGluZyBpcyBhIG1vZGlmaWNhdGlvbiBvZiBiYXNlNjQgdGhhdCBjYW4gc2FmZWx5IGJlIHVzZWQgaW4gVVJMcyBhbmQgZmlsZW5hbWVzXG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgand0KG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJqd3RcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBpcChvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiaXBcIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG9wdGlvbnMpIH0pO1xuICAgIH1cbiAgICBjaWRyKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHsga2luZDogXCJjaWRyXCIsIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zKSB9KTtcbiAgICB9XG4gICAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICAgICAga2luZDogXCJkYXRldGltZVwiLFxuICAgICAgICAgICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGxvY2FsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBvcHRpb25zLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIG9wdGlvbnM/LnByZWNpc2lvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zPy5wcmVjaXNpb24sXG4gICAgICAgICAgICBvZmZzZXQ6IG9wdGlvbnM/Lm9mZnNldCA/PyBmYWxzZSxcbiAgICAgICAgICAgIGxvY2FsOiBvcHRpb25zPy5sb2NhbCA/PyBmYWxzZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRhdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soeyBraW5kOiBcImRhdGVcIiwgbWVzc2FnZSB9KTtcbiAgICB9XG4gICAgdGltZShvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogb3B0aW9ucyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcInRpbWVcIixcbiAgICAgICAgICAgIHByZWNpc2lvbjogdHlwZW9mIG9wdGlvbnM/LnByZWNpc2lvbiA9PT0gXCJ1bmRlZmluZWRcIiA/IG51bGwgOiBvcHRpb25zPy5wcmVjaXNpb24sXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoob3B0aW9ucz8ubWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkdXJhdGlvbihtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7IGtpbmQ6IFwiZHVyYXRpb25cIiwgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpIH0pO1xuICAgIH1cbiAgICByZWdleChyZWdleCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJyZWdleFwiLFxuICAgICAgICAgICAgcmVnZXg6IHJlZ2V4LFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jbHVkZXModmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiaW5jbHVkZXNcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBvcHRpb25zPy5wb3NpdGlvbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihvcHRpb25zPy5tZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXJ0c1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwic3RhcnRzV2l0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kc1dpdGgodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwiZW5kc1dpdGhcIixcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5MZW5ndGgsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogbWluTGVuZ3RoLFxuICAgICAgICAgICAgLi4uZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiBtYXhMZW5ndGgsXG4gICAgICAgICAgICAuLi5lcnJvclV0aWwuZXJyVG9PYmoobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBsZW5ndGgobGVuLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcImxlbmd0aFwiLFxuICAgICAgICAgICAgdmFsdWU6IGxlbixcbiAgICAgICAgICAgIC4uLmVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVxdWl2YWxlbnQgdG8gYC5taW4oMSlgXG4gICAgICovXG4gICAgbm9uZW1wdHkobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oMSwgZXJyb3JVdGlsLmVyclRvT2JqKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgdHJpbSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbLi4udGhpcy5fZGVmLmNoZWNrcywgeyBraW5kOiBcInRyaW1cIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvTG93ZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9Mb3dlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvVXBwZXJDYXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFN0cmluZyh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCB7IGtpbmQ6IFwidG9VcHBlckNhc2VcIiB9XSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBpc0RhdGV0aW1lKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGV0aW1lXCIpO1xuICAgIH1cbiAgICBnZXQgaXNEYXRlKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImRhdGVcIik7XG4gICAgfVxuICAgIGdldCBpc1RpbWUoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidGltZVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzRHVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwiZHVyYXRpb25cIik7XG4gICAgfVxuICAgIGdldCBpc0VtYWlsKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImVtYWlsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVUkwoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwidXJsXCIpO1xuICAgIH1cbiAgICBnZXQgaXNFbW9qaSgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJlbW9qaVwiKTtcbiAgICB9XG4gICAgZ2V0IGlzVVVJRCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJ1dWlkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNOQU5PSUQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuX2RlZi5jaGVja3MuZmluZCgoY2gpID0+IGNoLmtpbmQgPT09IFwibmFub2lkXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDVUlEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWRcIik7XG4gICAgfVxuICAgIGdldCBpc0NVSUQyKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImN1aWQyXCIpO1xuICAgIH1cbiAgICBnZXQgaXNVTElEKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcInVsaWRcIik7XG4gICAgfVxuICAgIGdldCBpc0lQKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImlwXCIpO1xuICAgIH1cbiAgICBnZXQgaXNDSURSKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9kZWYuY2hlY2tzLmZpbmQoKGNoKSA9PiBjaC5raW5kID09PSBcImNpZHJcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjRcIik7XG4gICAgfVxuICAgIGdldCBpc0Jhc2U2NHVybCgpIHtcbiAgICAgICAgLy8gYmFzZTY0dXJsIGVuY29kaW5nIGlzIGEgbW9kaWZpY2F0aW9uIG9mIGJhc2U2NCB0aGF0IGNhbiBzYWZlbHkgYmUgdXNlZCBpbiBVUkxzIGFuZCBmaWxlbmFtZXNcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJiYXNlNjR1cmxcIik7XG4gICAgfVxuICAgIGdldCBtaW5MZW5ndGgoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heExlbmd0aCgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZFN0cmluZy5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTdHJpbmcoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFN0cmluZyxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSA/PyBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzM5NjY0ODQvd2h5LWRvZXMtbW9kdWx1cy1vcGVyYXRvci1yZXR1cm4tZnJhY3Rpb25hbC1udW1iZXItaW4tamF2YXNjcmlwdC8zMTcxMTAzNCMzMTcxMTAzNFxuZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcERlY0NvdW50ID0gKHN0ZXAudG9TdHJpbmcoKS5zcGxpdChcIi5cIilbMV0gfHwgXCJcIikubGVuZ3RoO1xuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBOdW1iZXIucGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyAxMCAqKiBkZWNDb3VudDtcbn1cbmV4cG9ydCBjbGFzcyBab2ROdW1iZXIgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5taW4gPSB0aGlzLmd0ZTtcbiAgICAgICAgdGhpcy5tYXggPSB0aGlzLmx0ZTtcbiAgICAgICAgdGhpcy5zdGVwID0gdGhpcy5tdWx0aXBsZU9mO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIGlucHV0LmRhdGEgPSBOdW1iZXIoaW5wdXQuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udW1iZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubnVtYmVyLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwiaW50XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXV0aWwuaXNJbnRlZ2VyKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJpbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWNlaXZlZDogXCJmbG9hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmxvYXRTYWZlUmVtYWluZGVyKGlucHV0LmRhdGEsIGNoZWNrLnZhbHVlKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUubm90X211bHRpcGxlX29mLFxuICAgICAgICAgICAgICAgICAgICAgICAgbXVsdGlwbGVPZjogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJmaW5pdGVcIikge1xuICAgICAgICAgICAgICAgIGlmICghTnVtYmVyLmlzRmluaXRlKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5ub3RfZmluaXRlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBndGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGd0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWluXCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgbHRlKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCB0cnVlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdCh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1heFwiLCB2YWx1ZSwgZmFsc2UsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIHNldExpbWl0KGtpbmQsIHZhbHVlLCBpbmNsdXNpdmUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2ROdW1iZXIoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2hlY2tzOiBbXG4gICAgICAgICAgICAgICAgLi4udGhpcy5fZGVmLmNoZWNrcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9hZGRDaGVjayhjaGVjaykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFsuLi50aGlzLl9kZWYuY2hlY2tzLCBjaGVja10sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpbnQobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJpbnRcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogMCxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuZWdhdGl2ZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1heFwiLFxuICAgICAgICAgICAgdmFsdWU6IDAsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGZhbHNlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ucG9zaXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtYXhcIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiAwLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbXVsdGlwbGVPZih2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtdWx0aXBsZU9mXCIsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5pdGUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJmaW5pdGVcIixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNhZmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUixcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSkuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluVmFsdWUoKSB7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1pbiA9PT0gbnVsbCB8fCBjaC52YWx1ZSA+IG1pbilcbiAgICAgICAgICAgICAgICAgICAgbWluID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICB9XG4gICAgZ2V0IG1heFZhbHVlKCkge1xuICAgICAgICBsZXQgbWF4ID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChtYXggPT09IG51bGwgfHwgY2gudmFsdWUgPCBtYXgpXG4gICAgICAgICAgICAgICAgICAgIG1heCA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgfVxuICAgIGdldCBpc0ludCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fZGVmLmNoZWNrcy5maW5kKChjaCkgPT4gY2gua2luZCA9PT0gXCJpbnRcIiB8fCAoY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIgJiYgdXRpbC5pc0ludGVnZXIoY2gudmFsdWUpKSk7XG4gICAgfVxuICAgIGdldCBpc0Zpbml0ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGxldCBtaW4gPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcImZpbml0ZVwiIHx8IGNoLmtpbmQgPT09IFwiaW50XCIgfHwgY2gua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTnVtYmVyLmlzRmluaXRlKG1pbikgJiYgTnVtYmVyLmlzRmluaXRlKG1heCk7XG4gICAgfVxufVxuWm9kTnVtYmVyLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE51bWJlcih7XG4gICAgICAgIGNoZWNrczogW10sXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVtYmVyLFxuICAgICAgICBjb2VyY2U6IHBhcmFtcz8uY29lcmNlIHx8IGZhbHNlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEJpZ0ludCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm1pbiA9IHRoaXMuZ3RlO1xuICAgICAgICB0aGlzLm1heCA9IHRoaXMubHRlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGF0YSA9IEJpZ0ludChpbnB1dC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZ2V0SW52YWxpZElucHV0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJpZ2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludmFsaWRJbnB1dChpbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN0eCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gbmV3IFBhcnNlU3RhdHVzKCk7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2sgb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoZWNrLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGNoZWNrLmluY2x1c2l2ZSA/IGlucHV0LmRhdGEgPCBjaGVjay52YWx1ZSA6IGlucHV0LmRhdGEgPD0gY2hlY2sudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHRvb1NtYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWluaW11bTogY2hlY2sudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IGNoZWNrLmluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjaGVjay5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9vQmlnID0gY2hlY2suaW5jbHVzaXZlID8gaW5wdXQuZGF0YSA+IGNoZWNrLnZhbHVlIDogaW5wdXQuZGF0YSA+PSBjaGVjay52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9vQmlnKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5jbHVzaXZlOiBjaGVjay5pbmNsdXNpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBjaGVjay5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtdWx0aXBsZU9mXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuZGF0YSAlIGNoZWNrLnZhbHVlICE9PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLm5vdF9tdWx0aXBsZV9vZixcbiAgICAgICAgICAgICAgICAgICAgICAgIG11bHRpcGxlT2Y6IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHV0aWwuYXNzZXJ0TmV2ZXIoY2hlY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogaW5wdXQuZGF0YSB9O1xuICAgIH1cbiAgICBfZ2V0SW52YWxpZElucHV0KGlucHV0KSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYmlnaW50LFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxuICAgIGd0ZSh2YWx1ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZXRMaW1pdChcIm1pblwiLCB2YWx1ZSwgdHJ1ZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgZ3QodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtaW5cIiwgdmFsdWUsIGZhbHNlLCBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkpO1xuICAgIH1cbiAgICBsdGUodmFsdWUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2V0TGltaXQoXCJtYXhcIiwgdmFsdWUsIHRydWUsIGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSk7XG4gICAgfVxuICAgIGx0KHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldExpbWl0KFwibWF4XCIsIHZhbHVlLCBmYWxzZSwgZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgc2V0TGltaXQoa2luZCwgdmFsdWUsIGluY2x1c2l2ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEJpZ0ludCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuY2hlY2tzLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2FkZENoZWNrKGNoZWNrKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQmlnSW50KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWluXCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5lZ2F0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbnBvc2l0aXZlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogQmlnSW50KDApLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9ubmVnYXRpdmUobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWRkQ2hlY2soe1xuICAgICAgICAgICAga2luZDogXCJtaW5cIixcbiAgICAgICAgICAgIHZhbHVlOiBCaWdJbnQoMCksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtdWx0aXBsZU9mKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm11bHRpcGxlT2ZcIixcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0IG1pblZhbHVlKCkge1xuICAgICAgICBsZXQgbWluID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBjaCBvZiB0aGlzLl9kZWYuY2hlY2tzKSB7XG4gICAgICAgICAgICBpZiAoY2gua2luZCA9PT0gXCJtaW5cIikge1xuICAgICAgICAgICAgICAgIGlmIChtaW4gPT09IG51bGwgfHwgY2gudmFsdWUgPiBtaW4pXG4gICAgICAgICAgICAgICAgICAgIG1pbiA9IGNoLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtaW47XG4gICAgfVxuICAgIGdldCBtYXhWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG1heCA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWF4XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWF4ID09PSBudWxsIHx8IGNoLnZhbHVlIDwgbWF4KVxuICAgICAgICAgICAgICAgICAgICBtYXggPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWF4O1xuICAgIH1cbn1cblpvZEJpZ0ludC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RCaWdJbnQoe1xuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJpZ0ludCxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSA/PyBmYWxzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RCb29sZWFuIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGlmICh0aGlzLl9kZWYuY29lcmNlKSB7XG4gICAgICAgICAgICBpbnB1dC5kYXRhID0gQm9vbGVhbihpbnB1dC5kYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLmJvb2xlYW4pIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYm9vbGVhbixcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RCb29sZWFuLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEJvb2xlYW4oe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEJvb2xlYW4sXG4gICAgICAgIGNvZXJjZTogcGFyYW1zPy5jb2VyY2UgfHwgZmFsc2UsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRGF0ZSBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAodGhpcy5fZGVmLmNvZXJjZSkge1xuICAgICAgICAgICAgaW5wdXQuZGF0YSA9IG5ldyBEYXRlKGlucHV0LmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5kYXRlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKE51bWJlci5pc05hTihpbnB1dC5kYXRhLmdldFRpbWUoKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YXR1cyA9IG5ldyBQYXJzZVN0YXR1cygpO1xuICAgICAgICBsZXQgY3R4ID0gdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaGVjay5raW5kID09PSBcIm1pblwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmRhdGEuZ2V0VGltZSgpIDwgY2hlY2sudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQsIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGNoZWNrLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBleGFjdDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiBjaGVjay52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2sua2luZCA9PT0gXCJtYXhcIikge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5kYXRhLmdldFRpbWUoKSA+IGNoZWNrLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogY2hlY2subWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IGNoZWNrLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJkYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1dGlsLmFzc2VydE5ldmVyKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IERhdGUoaW5wdXQuZGF0YS5nZXRUaW1lKCkpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBfYWRkQ2hlY2soY2hlY2spIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIGNoZWNrczogWy4uLnRoaXMuX2RlZi5jaGVja3MsIGNoZWNrXSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG1pbihtaW5EYXRlLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hZGRDaGVjayh7XG4gICAgICAgICAgICBraW5kOiBcIm1pblwiLFxuICAgICAgICAgICAgdmFsdWU6IG1pbkRhdGUuZ2V0VGltZSgpLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heERhdGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZENoZWNrKHtcbiAgICAgICAgICAgIGtpbmQ6IFwibWF4XCIsXG4gICAgICAgICAgICB2YWx1ZTogbWF4RGF0ZS5nZXRUaW1lKCksXG4gICAgICAgICAgICBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgbWluRGF0ZSgpIHtcbiAgICAgICAgbGV0IG1pbiA9IG51bGw7XG4gICAgICAgIGZvciAoY29uc3QgY2ggb2YgdGhpcy5fZGVmLmNoZWNrcykge1xuICAgICAgICAgICAgaWYgKGNoLmtpbmQgPT09IFwibWluXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAobWluID09PSBudWxsIHx8IGNoLnZhbHVlID4gbWluKVxuICAgICAgICAgICAgICAgICAgICBtaW4gPSBjaC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWluICE9IG51bGwgPyBuZXcgRGF0ZShtaW4pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IG1heERhdGUoKSB7XG4gICAgICAgIGxldCBtYXggPSBudWxsO1xuICAgICAgICBmb3IgKGNvbnN0IGNoIG9mIHRoaXMuX2RlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIGlmIChjaC5raW5kID09PSBcIm1heFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1heCA9PT0gbnVsbCB8fCBjaC52YWx1ZSA8IG1heClcbiAgICAgICAgICAgICAgICAgICAgbWF4ID0gY2gudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1heCAhPSBudWxsID8gbmV3IERhdGUobWF4KSA6IG51bGw7XG4gICAgfVxufVxuWm9kRGF0ZS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2REYXRlKHtcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgY29lcmNlOiBwYXJhbXM/LmNvZXJjZSB8fCBmYWxzZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2REYXRlLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFN5bWJvbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnN5bWJvbCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5zeW1ib2wsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kU3ltYm9sLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFN5bWJvbCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU3ltYm9sLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVuZGVmaW5lZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS51bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kVW5kZWZpbmVkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuZGVmaW5lZCh7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5kZWZpbmVkLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE51bGwgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5udWxsKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm51bGwsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT0soaW5wdXQuZGF0YSk7XG4gICAgfVxufVxuWm9kTnVsbC5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROdWxsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEFueSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICAvLyB0byBwcmV2ZW50IGluc3RhbmNlcyBvZiBvdGhlciBjbGFzc2VzIGZyb20gZXh0ZW5kaW5nIFpvZEFueS4gdGhpcyBjYXVzZXMgaXNzdWVzIHdpdGggY2F0Y2hhbGwgaW4gWm9kT2JqZWN0LlxuICAgICAgICB0aGlzLl9hbnkgPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZEFueS5jcmVhdGUgPSAocGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RBbnkoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEFueSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RVbmtub3duIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIC8vIHJlcXVpcmVkXG4gICAgICAgIHRoaXMuX3Vua25vd24gPSB0cnVlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbn1cblpvZFVua25vd24uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kVW5rbm93bih7XG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5rbm93bixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2ROZXZlciBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLm5ldmVyLFxuICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgfVxufVxuWm9kTmV2ZXIuY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmV2ZXIoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE5ldmVyLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFZvaWQgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkVHlwZSA9IHRoaXMuX2dldFR5cGUoaW5wdXQpO1xuICAgICAgICBpZiAocGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS51bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2dldE9yUmV0dXJuQ3R4KGlucHV0KTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUudm9pZCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPSyhpbnB1dC5kYXRhKTtcbiAgICB9XG59XG5ab2RWb2lkLmNyZWF0ZSA9IChwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFZvaWQoe1xuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFZvaWQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQXJyYXkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHgsIHN0YXR1cyB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGVmID0gdGhpcy5fZGVmO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuYXJyYXksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLmV4YWN0TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29CaWcgPSBjdHguZGF0YS5sZW5ndGggPiBkZWYuZXhhY3RMZW5ndGgudmFsdWU7XG4gICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5leGFjdExlbmd0aC52YWx1ZTtcbiAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogdG9vQmlnID8gWm9kSXNzdWVDb2RlLnRvb19iaWcgOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgICAgICBtaW5pbXVtOiAodG9vU21hbGwgPyBkZWYuZXhhY3RMZW5ndGgudmFsdWUgOiB1bmRlZmluZWQpLFxuICAgICAgICAgICAgICAgICAgICBtYXhpbXVtOiAodG9vQmlnID8gZGVmLmV4YWN0TGVuZ3RoLnZhbHVlIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWYuZXhhY3RMZW5ndGgubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1pbkxlbmd0aCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGN0eC5kYXRhLmxlbmd0aCA8IGRlZi5taW5MZW5ndGgudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19zbWFsbCxcbiAgICAgICAgICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbkxlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pbkxlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkZWYubWF4TGVuZ3RoICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEubGVuZ3RoID4gZGVmLm1heExlbmd0aC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX2JpZyxcbiAgICAgICAgICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heExlbmd0aC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJhcnJheVwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heExlbmd0aC5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmLnR5cGUuX3BhcnNlQXN5bmMobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSk7XG4gICAgICAgICAgICB9KSkudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gWy4uLmN0eC5kYXRhXS5tYXAoKGl0ZW0sIGkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWYudHlwZS5fcGFyc2VTeW5jKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBpdGVtLCBjdHgucGF0aCwgaSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHQpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlO1xuICAgIH1cbiAgICBtaW4obWluTGVuZ3RoLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluTGVuZ3RoOiB7IHZhbHVlOiBtaW5MZW5ndGgsIG1lc3NhZ2U6IGVycm9yVXRpbC50b1N0cmluZyhtZXNzYWdlKSB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWF4KG1heExlbmd0aCwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEFycmF5KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIG1heExlbmd0aDogeyB2YWx1ZTogbWF4TGVuZ3RoLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxlbmd0aChsZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBleGFjdExlbmd0aDogeyB2YWx1ZTogbGVuLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5vbmVtcHR5KG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWluKDEsIG1lc3NhZ2UpO1xuICAgIH1cbn1cblpvZEFycmF5LmNyZWF0ZSA9IChzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kQXJyYXkoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIG1pbkxlbmd0aDogbnVsbCxcbiAgICAgICAgbWF4TGVuZ3RoOiBudWxsLFxuICAgICAgICBleGFjdExlbmd0aDogbnVsbCxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RBcnJheSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYSkge1xuICAgIGlmIChzY2hlbWEgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hLnNoYXBlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFNjaGVtYSA9IHNjaGVtYS5zaGFwZVtrZXldO1xuICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IFpvZE9wdGlvbmFsLmNyZWF0ZShkZWVwUGFydGlhbGlmeShmaWVsZFNjaGVtYSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnNjaGVtYS5fZGVmLFxuICAgICAgICAgICAgc2hhcGU6ICgpID0+IG5ld1NoYXBlLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc2NoZW1hIGluc3RhbmNlb2YgWm9kQXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RBcnJheSh7XG4gICAgICAgICAgICAuLi5zY2hlbWEuX2RlZixcbiAgICAgICAgICAgIHR5cGU6IGRlZXBQYXJ0aWFsaWZ5KHNjaGVtYS5lbGVtZW50KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgIHJldHVybiBab2RPcHRpb25hbC5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZE51bGxhYmxlKSB7XG4gICAgICAgIHJldHVybiBab2ROdWxsYWJsZS5jcmVhdGUoZGVlcFBhcnRpYWxpZnkoc2NoZW1hLnVud3JhcCgpKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNjaGVtYSBpbnN0YW5jZW9mIFpvZFR1cGxlKSB7XG4gICAgICAgIHJldHVybiBab2RUdXBsZS5jcmVhdGUoc2NoZW1hLml0ZW1zLm1hcCgoaXRlbSkgPT4gZGVlcFBhcnRpYWxpZnkoaXRlbSkpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZE9iamVjdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBubyBsb25nZXIgbmVlZGVkIC0gdW5rbm93biBwcm9wZXJ0aWVzIGFyZSBub3cgc2lsZW50bHkgc3RyaXBwZWQuXG4gICAgICAgICAqIElmIHlvdSB3YW50IHRvIHBhc3MgdGhyb3VnaCB1bmtub3duIHByb3BlcnRpZXMsIHVzZSBgLnBhc3N0aHJvdWdoKClgIGluc3RlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vbnN0cmljdCA9IHRoaXMucGFzc3Rocm91Z2g7XG4gICAgICAgIC8vIGV4dGVuZDxcbiAgICAgICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZSxcbiAgICAgICAgLy8gICBOZXdPdXRwdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgT3V0cHV0XTogayBleHRlbmRzIGtleW9mIEF1Z21lbnRhdGlvblxuICAgICAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9vdXRwdXRcIl1cbiAgICAgICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgICAgIC8vICAgICAgID8gT3V0cHV0W2tdXG4gICAgICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgICAgIC8vICAgfT4sXG4gICAgICAgIC8vICAgTmV3SW5wdXQgZXh0ZW5kcyB1dGlsLmZsYXR0ZW48e1xuICAgICAgICAvLyAgICAgW2sgaW4ga2V5b2YgQXVnbWVudGF0aW9uIHwga2V5b2YgSW5wdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICAgICAgID8gQXVnbWVudGF0aW9uW2tdW1wiX2lucHV0XCJdXG4gICAgICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgICAgIC8vICAgICAgID8gSW5wdXRba11cbiAgICAgICAgLy8gICAgICAgOiBuZXZlcjtcbiAgICAgICAgLy8gICB9PlxuICAgICAgICAvLyA+KFxuICAgICAgICAvLyAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgICAgIC8vICk6IFpvZE9iamVjdDxcbiAgICAgICAgLy8gICBleHRlbmRTaGFwZTxULCBBdWdtZW50YXRpb24+LFxuICAgICAgICAvLyAgIFVua25vd25LZXlzLFxuICAgICAgICAvLyAgIENhdGNoYWxsLFxuICAgICAgICAvLyAgIE5ld091dHB1dCxcbiAgICAgICAgLy8gICBOZXdJbnB1dFxuICAgICAgICAvLyA+IHtcbiAgICAgICAgLy8gICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIC8vICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgIC8vICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgLy8gICAgICAgLi4udGhpcy5fZGVmLnNoYXBlKCksXG4gICAgICAgIC8vICAgICAgIC4uLmF1Z21lbnRhdGlvbixcbiAgICAgICAgLy8gICAgIH0pLFxuICAgICAgICAvLyAgIH0pIGFzIGFueTtcbiAgICAgICAgLy8gfVxuICAgICAgICAvKipcbiAgICAgICAgICogQGRlcHJlY2F0ZWQgVXNlIGAuZXh0ZW5kYCBpbnN0ZWFkXG4gICAgICAgICAqICAqL1xuICAgICAgICB0aGlzLmF1Z21lbnQgPSB0aGlzLmV4dGVuZDtcbiAgICB9XG4gICAgX2dldENhY2hlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhY2hlZCAhPT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5fZGVmLnNoYXBlKCk7XG4gICAgICAgIGNvbnN0IGtleXMgPSB1dGlsLm9iamVjdEtleXMoc2hhcGUpO1xuICAgICAgICB0aGlzLl9jYWNoZWQgPSB7IHNoYXBlLCBrZXlzIH07XG4gICAgICAgIHJldHVybiB0aGlzLl9jYWNoZWQ7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCB7IHNoYXBlLCBrZXlzOiBzaGFwZUtleXMgfSA9IHRoaXMuX2dldENhY2hlZCgpO1xuICAgICAgICBjb25zdCBleHRyYUtleXMgPSBbXTtcbiAgICAgICAgaWYgKCEodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIgJiYgdGhpcy5fZGVmLnVua25vd25LZXlzID09PSBcInN0cmlwXCIpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjdHguZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmICghc2hhcGVLZXlzLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXh0cmFLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFpcnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygc2hhcGVLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBrZXlWYWxpZGF0b3IgPSBzaGFwZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZToga2V5IH0sXG4gICAgICAgICAgICAgICAgdmFsdWU6IGtleVZhbGlkYXRvci5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwga2V5KSksXG4gICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBrZXkgaW4gY3R4LmRhdGEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fZGVmLmNhdGNoYWxsIGluc3RhbmNlb2YgWm9kTmV2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHVua25vd25LZXlzID0gdGhpcy5fZGVmLnVua25vd25LZXlzO1xuICAgICAgICAgICAgaWYgKHVua25vd25LZXlzID09PSBcInBhc3N0aHJvdWdoXCIpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBleHRyYUtleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFpcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7IHN0YXR1czogXCJ2YWxpZFwiLCB2YWx1ZTogY3R4LmRhdGFba2V5XSB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh1bmtub3duS2V5cyA9PT0gXCJzdHJpY3RcIikge1xuICAgICAgICAgICAgICAgIGlmIChleHRyYUtleXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS51bnJlY29nbml6ZWRfa2V5cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleXM6IGV4dHJhS2V5cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHVua25vd25LZXlzID09PSBcInN0cmlwXCIpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgWm9kT2JqZWN0IGVycm9yOiBpbnZhbGlkIHVua25vd25LZXlzIHZhbHVlLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gcnVuIGNhdGNoYWxsIHZhbGlkYXRpb25cbiAgICAgICAgICAgIGNvbnN0IGNhdGNoYWxsID0gdGhpcy5fZGVmLmNhdGNoYWxsO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgZXh0cmFLZXlzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjdHguZGF0YVtrZXldO1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBrZXk6IHsgc3RhdHVzOiBcInZhbGlkXCIsIHZhbHVlOiBrZXkgfSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGNhdGNoYWxsLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgdmFsdWUsIGN0eC5wYXRoLCBrZXkpIC8vLCBjdHguY2hpbGQoa2V5KSwgdmFsdWUsIGdldFBhcnNlZFR5cGUodmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcbiAgICAgICAgICAgICAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3luY1BhaXJzID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGF3YWl0IHBhaXIua2V5O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGF3YWl0IHBhaXIudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHN5bmNQYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWx3YXlzU2V0OiBwYWlyLmFsd2F5c1NldCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBzeW5jUGFpcnM7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC50aGVuKChzeW5jUGFpcnMpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyc2VTdGF0dXMubWVyZ2VPYmplY3RTeW5jKHN0YXR1cywgc3luY1BhaXJzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuc2hhcGUoKTtcbiAgICB9XG4gICAgc3RyaWN0KG1lc3NhZ2UpIHtcbiAgICAgICAgZXJyb3JVdGlsLmVyclRvT2JqO1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNYXA6IChpc3N1ZSwgY3R4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0RXJyb3IgPSB0aGlzLl9kZWYuZXJyb3JNYXA/Lihpc3N1ZSwgY3R4KS5tZXNzYWdlID8/IGN0eC5kZWZhdWx0RXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yVXRpbC5lcnJUb09iaihtZXNzYWdlKS5tZXNzYWdlID8/IGRlZmF1bHRFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBkZWZhdWx0RXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0cmlwKCkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGFzc3Rocm91Z2goKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHVua25vd25LZXlzOiBcInBhc3N0aHJvdWdoXCIsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBjb25zdCBBdWdtZW50RmFjdG9yeSA9XG4gICAgLy8gICA8RGVmIGV4dGVuZHMgWm9kT2JqZWN0RGVmPihkZWY6IERlZikgPT5cbiAgICAvLyAgIDxBdWdtZW50YXRpb24gZXh0ZW5kcyBab2RSYXdTaGFwZT4oXG4gICAgLy8gICAgIGF1Z21lbnRhdGlvbjogQXVnbWVudGF0aW9uXG4gICAgLy8gICApOiBab2RPYmplY3Q8XG4gICAgLy8gICAgIGV4dGVuZFNoYXBlPFJldHVyblR5cGU8RGVmW1wic2hhcGVcIl0+LCBBdWdtZW50YXRpb24+LFxuICAgIC8vICAgICBEZWZbXCJ1bmtub3duS2V5c1wiXSxcbiAgICAvLyAgICAgRGVmW1wiY2F0Y2hhbGxcIl1cbiAgICAvLyAgID4gPT4ge1xuICAgIC8vICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgLy8gICAgICAgLi4uZGVmLFxuICAgIC8vICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgIC8vICAgICAgICAgLi4uZGVmLnNoYXBlKCksXG4gICAgLy8gICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgLy8gICAgICAgfSksXG4gICAgLy8gICAgIH0pIGFzIGFueTtcbiAgICAvLyAgIH07XG4gICAgZXh0ZW5kKGF1Z21lbnRhdGlvbikge1xuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAgICAgICAgICAgICAuLi5hdWdtZW50YXRpb24sXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByaW9yIHRvIHpvZEAxLjAuMTIgdGhlcmUgd2FzIGEgYnVnIGluIHRoZVxuICAgICAqIGluZmVycmVkIHR5cGUgb2YgbWVyZ2VkIG9iamVjdHMuIFBsZWFzZVxuICAgICAqIHVwZ3JhZGUgaWYgeW91IGFyZSBleHBlcmllbmNpbmcgaXNzdWVzLlxuICAgICAqL1xuICAgIG1lcmdlKG1lcmdpbmcpIHtcbiAgICAgICAgY29uc3QgbWVyZ2VkID0gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IG1lcmdpbmcuX2RlZi5jYXRjaGFsbCxcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiAoe1xuICAgICAgICAgICAgICAgIC4uLnRoaXMuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgICAgIC4uLm1lcmdpbmcuX2RlZi5zaGFwZSgpLFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtZXJnZWQ7XG4gICAgfVxuICAgIC8vIG1lcmdlPFxuICAgIC8vICAgSW5jb21pbmcgZXh0ZW5kcyBBbnlab2RPYmplY3QsXG4gICAgLy8gICBBdWdtZW50YXRpb24gZXh0ZW5kcyBJbmNvbWluZ1tcInNoYXBlXCJdLFxuICAgIC8vICAgTmV3T3V0cHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBPdXRwdXRdOiBrIGV4dGVuZHMga2V5b2YgQXVnbWVudGF0aW9uXG4gICAgLy8gICAgICAgPyBBdWdtZW50YXRpb25ba11bXCJfb3V0cHV0XCJdXG4gICAgLy8gICAgICAgOiBrIGV4dGVuZHMga2V5b2YgT3V0cHV0XG4gICAgLy8gICAgICAgPyBPdXRwdXRba11cbiAgICAvLyAgICAgICA6IG5ldmVyO1xuICAgIC8vICAgfSxcbiAgICAvLyAgIE5ld0lucHV0IGV4dGVuZHMge1xuICAgIC8vICAgICBbayBpbiBrZXlvZiBBdWdtZW50YXRpb24gfCBrZXlvZiBJbnB1dF06IGsgZXh0ZW5kcyBrZXlvZiBBdWdtZW50YXRpb25cbiAgICAvLyAgICAgICA/IEF1Z21lbnRhdGlvbltrXVtcIl9pbnB1dFwiXVxuICAgIC8vICAgICAgIDogayBleHRlbmRzIGtleW9mIElucHV0XG4gICAgLy8gICAgICAgPyBJbnB1dFtrXVxuICAgIC8vICAgICAgIDogbmV2ZXI7XG4gICAgLy8gICB9XG4gICAgLy8gPihcbiAgICAvLyAgIG1lcmdpbmc6IEluY29taW5nXG4gICAgLy8gKTogWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXSxcbiAgICAvLyAgIE5ld091dHB1dCxcbiAgICAvLyAgIE5ld0lucHV0XG4gICAgLy8gPiB7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgc2V0S2V5KGtleSwgc2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF1Z21lbnQoeyBba2V5XTogc2NoZW1hIH0pO1xuICAgIH1cbiAgICAvLyBtZXJnZTxJbmNvbWluZyBleHRlbmRzIEFueVpvZE9iamVjdD4oXG4gICAgLy8gICBtZXJnaW5nOiBJbmNvbWluZ1xuICAgIC8vICk6IC8vWm9kT2JqZWN0PFQgJiBJbmNvbWluZ1tcIl9zaGFwZVwiXSwgVW5rbm93bktleXMsIENhdGNoYWxsPiA9IChtZXJnaW5nKSA9PiB7XG4gICAgLy8gWm9kT2JqZWN0PFxuICAgIC8vICAgZXh0ZW5kU2hhcGU8VCwgUmV0dXJuVHlwZTxJbmNvbWluZ1tcIl9kZWZcIl1bXCJzaGFwZVwiXT4+LFxuICAgIC8vICAgSW5jb21pbmdbXCJfZGVmXCJdW1widW5rbm93bktleXNcIl0sXG4gICAgLy8gICBJbmNvbWluZ1tcIl9kZWZcIl1bXCJjYXRjaGFsbFwiXVxuICAgIC8vID4ge1xuICAgIC8vICAgLy8gY29uc3QgbWVyZ2VkU2hhcGUgPSBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKFxuICAgIC8vICAgLy8gICB0aGlzLl9kZWYuc2hhcGUoKSxcbiAgICAvLyAgIC8vICAgbWVyZ2luZy5fZGVmLnNoYXBlKClcbiAgICAvLyAgIC8vICk7XG4gICAgLy8gICBjb25zdCBtZXJnZWQ6IGFueSA9IG5ldyBab2RPYmplY3Qoe1xuICAgIC8vICAgICB1bmtub3duS2V5czogbWVyZ2luZy5fZGVmLnVua25vd25LZXlzLFxuICAgIC8vICAgICBjYXRjaGFsbDogbWVyZ2luZy5fZGVmLmNhdGNoYWxsLFxuICAgIC8vICAgICBzaGFwZTogKCkgPT5cbiAgICAvLyAgICAgICBvYmplY3RVdGlsLm1lcmdlU2hhcGVzKHRoaXMuX2RlZi5zaGFwZSgpLCBtZXJnaW5nLl9kZWYuc2hhcGUoKSksXG4gICAgLy8gICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgIC8vICAgfSkgYXMgYW55O1xuICAgIC8vICAgcmV0dXJuIG1lcmdlZDtcbiAgICAvLyB9XG4gICAgY2F0Y2hhbGwoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgY2F0Y2hhbGw6IGluZGV4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGljayhtYXNrKSB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHV0aWwub2JqZWN0S2V5cyhtYXNrKSkge1xuICAgICAgICAgICAgaWYgKG1hc2tba2V5XSAmJiB0aGlzLnNoYXBlW2tleV0pIHtcbiAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG9taXQobWFzaykge1xuICAgICAgICBjb25zdCBzaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGlmICghbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gc2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGRlZXBQYXJ0aWFsKCkge1xuICAgICAgICByZXR1cm4gZGVlcFBhcnRpYWxpZnkodGhpcyk7XG4gICAgfVxuICAgIHBhcnRpYWwobWFzaykge1xuICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1dGlsLm9iamVjdEtleXModGhpcy5zaGFwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgaWYgKG1hc2sgJiYgIW1hc2tba2V5XSkge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBmaWVsZFNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIHNoYXBlOiAoKSA9PiBuZXdTaGFwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlcXVpcmVkKG1hc2spIHtcbiAgICAgICAgY29uc3QgbmV3U2hhcGUgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKSB7XG4gICAgICAgICAgICBpZiAobWFzayAmJiAhbWFza1trZXldKSB7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IHRoaXMuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkU2NoZW1hID0gdGhpcy5zaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIGxldCBuZXdGaWVsZCA9IGZpZWxkU2NoZW1hO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuZXdGaWVsZCBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0ZpZWxkID0gbmV3RmllbGQuX2RlZi5pbm5lclR5cGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5ld1NoYXBlW2tleV0gPSBuZXdGaWVsZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBzaGFwZTogKCkgPT4gbmV3U2hhcGUsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlvZigpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVpvZEVudW0odXRpbC5vYmplY3RLZXlzKHRoaXMuc2hhcGUpKTtcbiAgICB9XG59XG5ab2RPYmplY3QuY3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlOiAoKSA9PiBzaGFwZSxcbiAgICAgICAgdW5rbm93bktleXM6IFwic3RyaXBcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5zdHJpY3RDcmVhdGUgPSAoc2hhcGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kT2JqZWN0KHtcbiAgICAgICAgc2hhcGU6ICgpID0+IHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpY3RcIixcbiAgICAgICAgY2F0Y2hhbGw6IFpvZE5ldmVyLmNyZWF0ZSgpLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9iamVjdCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcblpvZE9iamVjdC5sYXp5Y3JlYXRlID0gKHNoYXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHNoYXBlLFxuICAgICAgICB1bmtub3duS2V5czogXCJzdHJpcFwiLFxuICAgICAgICBjYXRjaGFsbDogWm9kTmV2ZXIuY3JlYXRlKCksXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kT2JqZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFVuaW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJlc3VsdHMocmVzdWx0cykge1xuICAgICAgICAgICAgLy8gcmV0dXJuIGZpcnN0IGlzc3VlLWZyZWUgdmFsaWRhdGlvbiBpZiBpdCBleGlzdHNcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGlzc3VlcyBmcm9tIGRpcnR5IG9wdGlvblxuICAgICAgICAgICAgICAgICAgICBjdHguY29tbW9uLmlzc3Vlcy5wdXNoKC4uLnJlc3VsdC5jdHguY29tbW9uLmlzc3Vlcyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldHVybiBpbnZhbGlkXG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IG5ldyBab2RFcnJvcihyZXN1bHQuY3R4LmNvbW1vbi5pc3N1ZXMpKTtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uLFxuICAgICAgICAgICAgICAgIHVuaW9uRXJyb3JzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKG9wdGlvbnMubWFwKGFzeW5jIChvcHRpb24pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZEN0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uY3R4LFxuICAgICAgICAgICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLmN0eC5jb21tb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQ6IGF3YWl0IG9wdGlvbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjaGlsZEN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIGN0eDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pKS50aGVuKGhhbmRsZVJlc3VsdHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgaXNzdWVzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRDdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgICAgICAgICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBudWxsLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY2hpbGRDdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwidmFsaWRcIikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIgJiYgIWRpcnR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnR5ID0geyByZXN1bHQsIGN0eDogY2hpbGRDdHggfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGNoaWxkQ3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICAgICAgICAgIGN0eC5jb21tb24uaXNzdWVzLnB1c2goLi4uZGlydHkuY3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBkaXJ0eS5yZXN1bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB1bmlvbkVycm9ycyA9IGlzc3Vlcy5tYXAoKGlzc3VlcykgPT4gbmV3IFpvZEVycm9yKGlzc3VlcykpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdW5pb24sXG4gICAgICAgICAgICAgICAgdW5pb25FcnJvcnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxufVxuWm9kVW5pb24uY3JlYXRlID0gKHR5cGVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFVuaW9uKHtcbiAgICAgICAgb3B0aW9uczogdHlwZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVW5pb24sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vLy8vLy8vXG4vLy8vLy8vLy8vICAgICAgWm9kRGlzY3JpbWluYXRlZFVuaW9uICAgICAgLy8vLy8vLy8vL1xuLy8vLy8vLy8vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuY29uc3QgZ2V0RGlzY3JpbWluYXRvciA9ICh0eXBlKSA9PiB7XG4gICAgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMYXp5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUuc2NoZW1hKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZEVmZmVjdHMpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5pbm5lclR5cGUoKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RMaXRlcmFsKSB7XG4gICAgICAgIHJldHVybiBbdHlwZS52YWx1ZV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RFbnVtKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROYXRpdmVFbnVtKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBiYW4vYmFuXG4gICAgICAgIHJldHVybiB1dGlsLm9iamVjdFZhbHVlcyh0eXBlLmVudW0pO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kRGVmYXVsdCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLl9kZWYuaW5uZXJUeXBlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsKSB7XG4gICAgICAgIHJldHVybiBbbnVsbF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gW3VuZGVmaW5lZCwgLi4uZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgaW5zdGFuY2VvZiBab2ROdWxsYWJsZSkge1xuICAgICAgICByZXR1cm4gW251bGwsIC4uLmdldERpc2NyaW1pbmF0b3IodHlwZS51bndyYXAoKSldO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQnJhbmRlZCkge1xuICAgICAgICByZXR1cm4gZ2V0RGlzY3JpbWluYXRvcih0eXBlLnVud3JhcCgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSBpbnN0YW5jZW9mIFpvZFJlYWRvbmx5KSB7XG4gICAgICAgIHJldHVybiBnZXREaXNjcmltaW5hdG9yKHR5cGUudW53cmFwKCkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlIGluc3RhbmNlb2YgWm9kQ2F0Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldERpc2NyaW1pbmF0b3IodHlwZS5fZGVmLmlubmVyVHlwZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufTtcbmV4cG9ydCBjbGFzcyBab2REaXNjcmltaW5hdGVkVW5pb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5vYmplY3QpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUub2JqZWN0LFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvciA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlID0gY3R4LmRhdGFbZGlzY3JpbWluYXRvcl07XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHRoaXMub3B0aW9uc01hcC5nZXQoZGlzY3JpbWluYXRvclZhbHVlKTtcbiAgICAgICAgaWYgKCFvcHRpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3VuaW9uX2Rpc2NyaW1pbmF0b3IsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogQXJyYXkuZnJvbSh0aGlzLm9wdGlvbnNNYXAua2V5cygpKSxcbiAgICAgICAgICAgICAgICBwYXRoOiBbZGlzY3JpbWluYXRvcl0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9uLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbi5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBkaXNjcmltaW5hdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmRpc2NyaW1pbmF0b3I7XG4gICAgfVxuICAgIGdldCBvcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnM7XG4gICAgfVxuICAgIGdldCBvcHRpb25zTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLm9wdGlvbnNNYXA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb25zdHJ1Y3RvciBvZiB0aGUgZGlzY3JpbWluYXRlZCB1bmlvbiBzY2hlbWEuIEl0cyBiZWhhdmlvdXIgaXMgdmVyeSBzaW1pbGFyIHRvIHRoYXQgb2YgdGhlIG5vcm1hbCB6LnVuaW9uKCkgY29uc3RydWN0b3IuXG4gICAgICogSG93ZXZlciwgaXQgb25seSBhbGxvd3MgYSB1bmlvbiBvZiBvYmplY3RzLCBhbGwgb2Ygd2hpY2ggbmVlZCB0byBzaGFyZSBhIGRpc2NyaW1pbmF0b3IgcHJvcGVydHkuIFRoaXMgcHJvcGVydHkgbXVzdFxuICAgICAqIGhhdmUgYSBkaWZmZXJlbnQgdmFsdWUgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSB1bmlvbi5cbiAgICAgKiBAcGFyYW0gZGlzY3JpbWluYXRvciB0aGUgbmFtZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eVxuICAgICAqIEBwYXJhbSB0eXBlcyBhbiBhcnJheSBvZiBvYmplY3Qgc2NoZW1hc1xuICAgICAqIEBwYXJhbSBwYXJhbXNcbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGRpc2NyaW1pbmF0b3IsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgICAgICAvLyBHZXQgYWxsIHRoZSB2YWxpZCBkaXNjcmltaW5hdG9yIHZhbHVlc1xuICAgICAgICBjb25zdCBvcHRpb25zTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyB0cnkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2Ygb3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZGlzY3JpbWluYXRvclZhbHVlcyA9IGdldERpc2NyaW1pbmF0b3IodHlwZS5zaGFwZVtkaXNjcmltaW5hdG9yXSk7XG4gICAgICAgICAgICBpZiAoIWRpc2NyaW1pbmF0b3JWYWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGRpc2NyaW1pbmF0b3IgdmFsdWUgZm9yIGtleSBcXGAke2Rpc2NyaW1pbmF0b3J9XFxgIGNvdWxkIG5vdCBiZSBleHRyYWN0ZWQgZnJvbSBhbGwgc2NoZW1hIG9wdGlvbnNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZGlzY3JpbWluYXRvclZhbHVlcykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zTWFwLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaXNjcmltaW5hdG9yIHByb3BlcnR5ICR7U3RyaW5nKGRpc2NyaW1pbmF0b3IpfSBoYXMgZHVwbGljYXRlIHZhbHVlICR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb3B0aW9uc01hcC5zZXQodmFsdWUsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRGlzY3JpbWluYXRlZFVuaW9uKHtcbiAgICAgICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGlzY3JpbWluYXRlZFVuaW9uLFxuICAgICAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICBvcHRpb25zTWFwLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gICAgY29uc3QgYVR5cGUgPSBnZXRQYXJzZWRUeXBlKGEpO1xuICAgIGNvbnN0IGJUeXBlID0gZ2V0UGFyc2VkVHlwZShiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5vYmplY3QgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUub2JqZWN0KSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gdXRpbC5vYmplY3RLZXlzKGIpO1xuICAgICAgICBjb25zdCBzaGFyZWRLZXlzID0gdXRpbC5vYmplY3RLZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcbiAgICAgICAgY29uc3QgbmV3T2JqID0geyAuLi5hLCAuLi5iIH07XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHNoYXJlZEtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3T2JqW2tleV0gPSBzaGFyZWRWYWx1ZS5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdPYmogfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYVR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuYXJyYXkpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3QXJyYXkgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgaXRlbUIgPSBiW2luZGV4XTtcbiAgICAgICAgICAgIGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWxpZDogZmFsc2UgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld0FycmF5LnB1c2goc2hhcmVkVmFsdWUuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IG5ld0FycmF5IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGFUeXBlID09PSBab2RQYXJzZWRUeXBlLmRhdGUgJiYgYlR5cGUgPT09IFpvZFBhcnNlZFR5cGUuZGF0ZSAmJiArYSA9PT0gK2IpIHtcbiAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IHRydWUsIGRhdGE6IGEgfTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiBmYWxzZSB9O1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBab2RJbnRlcnNlY3Rpb24gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgaGFuZGxlUGFyc2VkID0gKHBhcnNlZExlZnQsIHBhcnNlZFJpZ2h0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNBYm9ydGVkKHBhcnNlZExlZnQpIHx8IGlzQWJvcnRlZChwYXJzZWRSaWdodCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKHBhcnNlZExlZnQudmFsdWUsIHBhcnNlZFJpZ2h0LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghbWVyZ2VkLnZhbGlkKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX2ludGVyc2VjdGlvbl90eXBlcyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0RpcnR5KHBhcnNlZExlZnQpIHx8IGlzRGlydHkocGFyc2VkUmlnaHQpKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IG1lcmdlZC5kYXRhIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB0aGlzLl9kZWYucmlnaHQuX3BhcnNlQXN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4gaGFuZGxlUGFyc2VkKGxlZnQsIHJpZ2h0KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlUGFyc2VkKHRoaXMuX2RlZi5sZWZ0Ll9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICAgICAgfSksIHRoaXMuX2RlZi5yaWdodC5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBjdHguZGF0YSxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblpvZEludGVyc2VjdGlvbi5jcmVhdGUgPSAobGVmdCwgcmlnaHQsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEludGVyc2VjdGlvbixcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vIHR5cGUgWm9kVHVwbGVJdGVtcyA9IFtab2RUeXBlQW55LCAuLi5ab2RUeXBlQW55W11dO1xuZXhwb3J0IGNsYXNzIFpvZFR1cGxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5hcnJheSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5hcnJheSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHguZGF0YS5sZW5ndGggPCB0aGlzLl9kZWYuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUudG9vX3NtYWxsLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3QgPSB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgaWYgKCFyZXN0ICYmIGN0eC5kYXRhLmxlbmd0aCA+IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fYmlnLFxuICAgICAgICAgICAgICAgIG1heGltdW06IHRoaXMuX2RlZi5pdGVtcy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gWy4uLmN0eC5kYXRhXVxuICAgICAgICAgICAgLm1hcCgoaXRlbSwgaXRlbUluZGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSB0aGlzLl9kZWYuaXRlbXNbaXRlbUluZGV4XSB8fCB0aGlzLl9kZWYucmVzdDtcbiAgICAgICAgICAgIGlmICghc2NoZW1hKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHNjaGVtYS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpdGVtSW5kZXgpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5maWx0ZXIoKHgpID0+ICEheCk7IC8vIGZpbHRlciBudWxsc1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGl0ZW1zKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlQXJyYXkoc3RhdHVzLCBpdGVtcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGl0ZW1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLml0ZW1zO1xuICAgIH1cbiAgICByZXN0KHJlc3QpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RUdXBsZSh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICByZXN0LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5ab2RUdXBsZS5jcmVhdGUgPSAoc2NoZW1hcywgcGFyYW1zKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHNjaGVtYXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIllvdSBtdXN0IHBhc3MgYW4gYXJyYXkgb2Ygc2NoZW1hcyB0byB6LnR1cGxlKFsgLi4uIF0pXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgaXRlbXM6IHNjaGVtYXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kVHVwbGUsXG4gICAgICAgIHJlc3Q6IG51bGwsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kUmVjb3JkIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgZ2V0IGtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgIH1cbiAgICBnZXQgdmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgIH1cbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBzdGF0dXMsIGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm9iamVjdCkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5vYmplY3QsXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYWlycyA9IFtdO1xuICAgICAgICBjb25zdCBrZXlUeXBlID0gdGhpcy5fZGVmLmtleVR5cGU7XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGN0eC5kYXRhKSB7XG4gICAgICAgICAgICBwYWlycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBrZXkpKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVUeXBlLl9wYXJzZShuZXcgUGFyc2VJbnB1dExhenlQYXRoKGN0eCwgY3R4LmRhdGFba2V5XSwgY3R4LnBhdGgsIGtleSkpLFxuICAgICAgICAgICAgICAgIGFsd2F5c1NldDoga2V5IGluIGN0eC5kYXRhLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJzZVN0YXR1cy5tZXJnZU9iamVjdEFzeW5jKHN0YXR1cywgcGFpcnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFBhcnNlU3RhdHVzLm1lcmdlT2JqZWN0U3luYyhzdGF0dXMsIHBhaXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGUoZmlyc3QsIHNlY29uZCwgdGhpcmQpIHtcbiAgICAgICAgaWYgKHNlY29uZCBpbnN0YW5jZW9mIFpvZFR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgICAgICBrZXlUeXBlOiBmaXJzdCxcbiAgICAgICAgICAgICAgICB2YWx1ZVR5cGU6IHNlY29uZCxcbiAgICAgICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHRoaXJkKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgICAgIGtleVR5cGU6IFpvZFN0cmluZy5jcmVhdGUoKSxcbiAgICAgICAgICAgIHZhbHVlVHlwZTogZmlyc3QsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFJlY29yZCxcbiAgICAgICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMoc2Vjb25kKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZE1hcCBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBrZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYua2V5VHlwZTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlVHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5tYXApIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUubWFwLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5VHlwZSA9IHRoaXMuX2RlZi5rZXlUeXBlO1xuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBjb25zdCBwYWlycyA9IFsuLi5jdHguZGF0YS5lbnRyaWVzKCldLm1hcCgoW2tleSwgdmFsdWVdLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleVR5cGUuX3BhcnNlKG5ldyBQYXJzZUlucHV0TGF6eVBhdGgoY3R4LCBrZXksIGN0eC5wYXRoLCBbaW5kZXgsIFwia2V5XCJdKSksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIHZhbHVlLCBjdHgucGF0aCwgW2luZGV4LCBcInZhbHVlXCJdKSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcGFpciBvZiBwYWlycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBhd2FpdCBwYWlyLmtleTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBhd2FpdCBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIgfHwgdmFsdWUuc3RhdHVzID09PSBcImFib3J0ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleS5zdGF0dXMgPT09IFwiZGlydHlcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxNYXAuc2V0KGtleS52YWx1ZSwgdmFsdWUudmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBwYWlyIG9mIHBhaXJzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gcGFpci5rZXk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYWlyLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChrZXkuc3RhdHVzID09PSBcImFib3J0ZWRcIiB8fCB2YWx1ZS5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5LnN0YXR1cyA9PT0gXCJkaXJ0eVwiIHx8IHZhbHVlLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbE1hcC5zZXQoa2V5LnZhbHVlLCB2YWx1ZS52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGZpbmFsTWFwIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5ab2RNYXAuY3JlYXRlID0gKGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RNYXAoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTWFwLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFNldCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IHN0YXR1cywgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuc2V0KSB7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF90eXBlLFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBab2RQYXJzZWRUeXBlLnNldCxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZiA9IHRoaXMuX2RlZjtcbiAgICAgICAgaWYgKGRlZi5taW5TaXplICE9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3R4LmRhdGEuc2l6ZSA8IGRlZi5taW5TaXplLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS50b29fc21hbGwsXG4gICAgICAgICAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5TaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1pblNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLm1heFNpemUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChjdHguZGF0YS5zaXplID4gZGVmLm1heFNpemUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLnRvb19iaWcsXG4gICAgICAgICAgICAgICAgICAgIG1heGltdW06IGRlZi5tYXhTaXplLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGV4YWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZGVmLm1heFNpemUubWVzc2FnZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZVR5cGUgPSB0aGlzLl9kZWYudmFsdWVUeXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5hbGl6ZVNldChlbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5kaXJ0eSgpO1xuICAgICAgICAgICAgICAgIHBhcnNlZFNldC5hZGQoZWxlbWVudC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IHBhcnNlZFNldCB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRzID0gWy4uLmN0eC5kYXRhLnZhbHVlcygpXS5tYXAoKGl0ZW0sIGkpID0+IHZhbHVlVHlwZS5fcGFyc2UobmV3IFBhcnNlSW5wdXRMYXp5UGF0aChjdHgsIGl0ZW0sIGN0eC5wYXRoLCBpKSkpO1xuICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGVsZW1lbnRzKS50aGVuKChlbGVtZW50cykgPT4gZmluYWxpemVTZXQoZWxlbWVudHMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5hbGl6ZVNldChlbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWluKG1pblNpemUsIG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgbWluU2l6ZTogeyB2YWx1ZTogbWluU2l6ZSwgbWVzc2FnZTogZXJyb3JVdGlsLnRvU3RyaW5nKG1lc3NhZ2UpIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXgobWF4U2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICBtYXhTaXplOiB7IHZhbHVlOiBtYXhTaXplLCBtZXNzYWdlOiBlcnJvclV0aWwudG9TdHJpbmcobWVzc2FnZSkgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpemUoc2l6ZSwgbWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW4oc2l6ZSwgbWVzc2FnZSkubWF4KHNpemUsIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBub25lbXB0eShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1pbigxLCBtZXNzYWdlKTtcbiAgICB9XG59XG5ab2RTZXQuY3JlYXRlID0gKHZhbHVlVHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RTZXQoe1xuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIG1pblNpemU6IG51bGwsXG4gICAgICAgIG1heFNpemU6IG51bGwsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kU2V0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZEZ1bmN0aW9uIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUgPSB0aGlzLmltcGxlbWVudDtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24pIHtcbiAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwge1xuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFpvZFBhcnNlZFR5cGUuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBtYWtlQXJnc0lzc3VlKGFyZ3MsIGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUlzc3VlKHtcbiAgICAgICAgICAgICAgICBkYXRhOiBhcmdzLFxuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwczogW2N0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwLCBjdHguc2NoZW1hRXJyb3JNYXAsIGdldEVycm9yTWFwKCksIGRlZmF1bHRFcnJvck1hcF0uZmlsdGVyKCh4KSA9PiAhIXgpLFxuICAgICAgICAgICAgICAgIGlzc3VlRGF0YToge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBab2RJc3N1ZUNvZGUuaW52YWxpZF9hcmd1bWVudHMsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50c0Vycm9yOiBlcnJvcixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gbWFrZVJldHVybnNJc3N1ZShyZXR1cm5zLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJc3N1ZSh7XG4gICAgICAgICAgICAgICAgZGF0YTogcmV0dXJucyxcbiAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICBlcnJvck1hcHM6IFtjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCwgY3R4LnNjaGVtYUVycm9yTWFwLCBnZXRFcnJvck1hcCgpLCBkZWZhdWx0RXJyb3JNYXBdLmZpbHRlcigoeCkgPT4gISF4KSxcbiAgICAgICAgICAgICAgICBpc3N1ZURhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfcmV0dXJuX3R5cGUsXG4gICAgICAgICAgICAgICAgICAgIHJldHVyblR5cGVFcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHsgZXJyb3JNYXA6IGN0eC5jb21tb24uY29udGV4dHVhbEVycm9yTWFwIH07XG4gICAgICAgIGNvbnN0IGZuID0gY3R4LmRhdGE7XG4gICAgICAgIGlmICh0aGlzLl9kZWYucmV0dXJucyBpbnN0YW5jZW9mIFpvZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIFdvdWxkIGxvdmUgYSB3YXkgdG8gYXZvaWQgZGlzYWJsaW5nIHRoaXMgcnVsZSwgYnV0IHdlIG5lZWRcbiAgICAgICAgICAgIC8vIGFuIGFsaWFzICh1c2luZyBhbiBhcnJvdyBmdW5jdGlvbiB3YXMgd2hhdCBjYXVzZWQgMjY1MSkuXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXNcbiAgICAgICAgICAgIGNvbnN0IG1lID0gdGhpcztcbiAgICAgICAgICAgIHJldHVybiBPSyhhc3luYyBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IFpvZEVycm9yKFtdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRBcmdzID0gYXdhaXQgbWUuX2RlZi5hcmdzLnBhcnNlQXN5bmMoYXJncywgcGFyYW1zKS5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlQXJnc0lzc3VlKGFyZ3MsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkUmV0dXJucyA9IGF3YWl0IG1lLl9kZWYucmV0dXJucy5fZGVmLnR5cGVcbiAgICAgICAgICAgICAgICAgICAgLnBhcnNlQXN5bmMocmVzdWx0LCBwYXJhbXMpXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hZGRJc3N1ZShtYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgZSkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkUmV0dXJucztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gV291bGQgbG92ZSBhIHdheSB0byBhdm9pZCBkaXNhYmxpbmcgdGhpcyBydWxlLCBidXQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gYW4gYWxpYXMgKHVzaW5nIGFuIGFycm93IGZ1bmN0aW9uIHdhcyB3aGF0IGNhdXNlZCAyNjUxKS5cbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICAgICAgY29uc3QgbWUgPSB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIE9LKGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IG1lLl9kZWYuYXJncy5zYWZlUGFyc2UoYXJncywgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZEFyZ3Muc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgWm9kRXJyb3IoW21ha2VBcmdzSXNzdWUoYXJncywgcGFyc2VkQXJncy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmbiwgdGhpcywgcGFyc2VkQXJncy5kYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRSZXR1cm5zID0gbWUuX2RlZi5yZXR1cm5zLnNhZmVQYXJzZShyZXN1bHQsIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXR1cm5zLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFpvZEVycm9yKFttYWtlUmV0dXJuc0lzc3VlKHJlc3VsdCwgcGFyc2VkUmV0dXJucy5lcnJvcildKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlZFJldHVybnMuZGF0YTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuYXJncztcbiAgICB9XG4gICAgcmV0dXJuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5yZXR1cm5zO1xuICAgIH1cbiAgICBhcmdzKC4uLml0ZW1zKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgYXJnczogWm9kVHVwbGUuY3JlYXRlKGl0ZW1zKS5yZXN0KFpvZFVua25vd24uY3JlYXRlKCkpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJucyhyZXR1cm5UeXBlKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICAgICAgLi4udGhpcy5fZGVmLFxuICAgICAgICAgICAgcmV0dXJuczogcmV0dXJuVHlwZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGltcGxlbWVudChmdW5jKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlZEZ1bmMgPSB0aGlzLnBhcnNlKGZ1bmMpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGVkRnVuYztcbiAgICB9XG4gICAgc3RyaWN0SW1wbGVtZW50KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGVkRnVuYyA9IHRoaXMucGFyc2UoZnVuYyk7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZWRGdW5jO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlKGFyZ3MsIHJldHVybnMsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFpvZEZ1bmN0aW9uKHtcbiAgICAgICAgICAgIGFyZ3M6IChhcmdzID8gYXJncyA6IFpvZFR1cGxlLmNyZWF0ZShbXSkucmVzdChab2RVbmtub3duLmNyZWF0ZSgpKSksXG4gICAgICAgICAgICByZXR1cm5zOiByZXR1cm5zIHx8IFpvZFVua25vd24uY3JlYXRlKCksXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEZ1bmN0aW9uLFxuICAgICAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kTGF6eSBleHRlbmRzIFpvZFR5cGUge1xuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuZ2V0dGVyKCk7XG4gICAgfVxuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGF6eVNjaGVtYSA9IHRoaXMuX2RlZi5nZXR0ZXIoKTtcbiAgICAgICAgcmV0dXJuIGxhenlTY2hlbWEuX3BhcnNlKHsgZGF0YTogY3R4LmRhdGEsIHBhdGg6IGN0eC5wYXRoLCBwYXJlbnQ6IGN0eCB9KTtcbiAgICB9XG59XG5ab2RMYXp5LmNyZWF0ZSA9IChnZXR0ZXIsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIGdldHRlcjogZ2V0dGVyLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZExhenksXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kTGl0ZXJhbCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuZGF0YSAhPT0gdGhpcy5fZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfbGl0ZXJhbCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdGhpcy5fZGVmLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG4gICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnZhbHVlO1xuICAgIH1cbn1cblpvZExpdGVyYWwuY3JlYXRlID0gKHZhbHVlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZExpdGVyYWwoe1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTGl0ZXJhbCxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmZ1bmN0aW9uIGNyZWF0ZVpvZEVudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICB2YWx1ZXMsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRW51bSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNsYXNzIFpvZEVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5kYXRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogdXRpbC5qb2luVmFsdWVzKGV4cGVjdGVkVmFsdWVzKSxcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LnBhcnNlZFR5cGUsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGUgPSBuZXcgU2V0KHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUuaGFzKGlucHV0LmRhdGEpKSB7XG4gICAgICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgb3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxuICAgIGdldCBlbnVtKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZ2V0IFZhbHVlcygpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHZhbCBvZiB0aGlzLl9kZWYudmFsdWVzKSB7XG4gICAgICAgICAgICBlbnVtVmFsdWVzW3ZhbF0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudW1WYWx1ZXM7XG4gICAgfVxuICAgIGdldCBFbnVtKCkge1xuICAgICAgICBjb25zdCBlbnVtVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3QgdmFsIG9mIHRoaXMuX2RlZi52YWx1ZXMpIHtcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbdmFsXSA9IHZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW51bVZhbHVlcztcbiAgICB9XG4gICAgZXh0cmFjdCh2YWx1ZXMsIG5ld0RlZiA9IHRoaXMuX2RlZikge1xuICAgICAgICByZXR1cm4gWm9kRW51bS5jcmVhdGUodmFsdWVzLCB7XG4gICAgICAgICAgICAuLi50aGlzLl9kZWYsXG4gICAgICAgICAgICAuLi5uZXdEZWYsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBleGNsdWRlKHZhbHVlcywgbmV3RGVmID0gdGhpcy5fZGVmKSB7XG4gICAgICAgIHJldHVybiBab2RFbnVtLmNyZWF0ZSh0aGlzLm9wdGlvbnMuZmlsdGVyKChvcHQpID0+ICF2YWx1ZXMuaW5jbHVkZXMob3B0KSksIHtcbiAgICAgICAgICAgIC4uLnRoaXMuX2RlZixcbiAgICAgICAgICAgIC4uLm5ld0RlZixcbiAgICAgICAgfSk7XG4gICAgfVxufVxuWm9kRW51bS5jcmVhdGUgPSBjcmVhdGVab2RFbnVtO1xuZXhwb3J0IGNsYXNzIFpvZE5hdGl2ZUVudW0gZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgbmF0aXZlRW51bVZhbHVlcyA9IHV0aWwuZ2V0VmFsaWRFbnVtVmFsdWVzKHRoaXMuX2RlZi52YWx1ZXMpO1xuICAgICAgICBjb25zdCBjdHggPSB0aGlzLl9nZXRPclJldHVybkN0eChpbnB1dCk7XG4gICAgICAgIGlmIChjdHgucGFyc2VkVHlwZSAhPT0gWm9kUGFyc2VkVHlwZS5zdHJpbmcgJiYgY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUubnVtYmVyKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFZhbHVlcyA9IHV0aWwub2JqZWN0VmFsdWVzKG5hdGl2ZUVudW1WYWx1ZXMpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IHV0aWwuam9pblZhbHVlcyhleHBlY3RlZFZhbHVlcyksXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgICAgIGNvZGU6IFpvZElzc3VlQ29kZS5pbnZhbGlkX3R5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhY2hlID0gbmV3IFNldCh1dGlsLmdldFZhbGlkRW51bVZhbHVlcyh0aGlzLl9kZWYudmFsdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9jYWNoZS5oYXMoaW5wdXQuZGF0YSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVmFsdWVzID0gdXRpbC5vYmplY3RWYWx1ZXMobmF0aXZlRW51bVZhbHVlcyk7XG4gICAgICAgICAgICBhZGRJc3N1ZVRvQ29udGV4dChjdHgsIHtcbiAgICAgICAgICAgICAgICByZWNlaXZlZDogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfZW51bV92YWx1ZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBleHBlY3RlZFZhbHVlcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIE9LKGlucHV0LmRhdGEpO1xuICAgIH1cbiAgICBnZXQgZW51bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi52YWx1ZXM7XG4gICAgfVxufVxuWm9kTmF0aXZlRW51bS5jcmVhdGUgPSAodmFsdWVzLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE5hdGl2ZUVudW0oe1xuICAgICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYXRpdmVFbnVtLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZFByb21pc2UgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYudHlwZTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgY3R4IH0gPSB0aGlzLl9wcm9jZXNzSW5wdXRQYXJhbXMoaW5wdXQpO1xuICAgICAgICBpZiAoY3R4LnBhcnNlZFR5cGUgIT09IFpvZFBhcnNlZFR5cGUucHJvbWlzZSAmJiBjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5wcm9taXNlLFxuICAgICAgICAgICAgICAgIHJlY2VpdmVkOiBjdHgucGFyc2VkVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbWlzaWZpZWQgPSBjdHgucGFyc2VkVHlwZSA9PT0gWm9kUGFyc2VkVHlwZS5wcm9taXNlID8gY3R4LmRhdGEgOiBQcm9taXNlLnJlc29sdmUoY3R4LmRhdGEpO1xuICAgICAgICByZXR1cm4gT0socHJvbWlzaWZpZWQudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi50eXBlLnBhcnNlQXN5bmMoZGF0YSwge1xuICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgIGVycm9yTWFwOiBjdHguY29tbW9uLmNvbnRleHR1YWxFcnJvck1hcCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuWm9kUHJvbWlzZS5jcmVhdGUgPSAoc2NoZW1hLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICB0eXBlOiBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kUHJvbWlzZSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbmV4cG9ydCBjbGFzcyBab2RFZmZlY3RzIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgaW5uZXJUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgc291cmNlVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5zY2hlbWEuX2RlZi50eXBlTmFtZSA9PT0gWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZEVmZmVjdHNcbiAgICAgICAgICAgID8gdGhpcy5fZGVmLnNjaGVtYS5zb3VyY2VUeXBlKClcbiAgICAgICAgICAgIDogdGhpcy5fZGVmLnNjaGVtYTtcbiAgICB9XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGNvbnN0IGVmZmVjdCA9IHRoaXMuX2RlZi5lZmZlY3QgfHwgbnVsbDtcbiAgICAgICAgY29uc3QgY2hlY2tDdHggPSB7XG4gICAgICAgICAgICBhZGRJc3N1ZTogKGFyZykgPT4ge1xuICAgICAgICAgICAgICAgIGFkZElzc3VlVG9Db250ZXh0KGN0eCwgYXJnKTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnLmZhdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5hYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBwYXRoKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdHgucGF0aDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGNoZWNrQ3R4LmFkZElzc3VlID0gY2hlY2tDdHguYWRkSXNzdWUuYmluZChjaGVja0N0eCk7XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJwcmVwcm9jZXNzXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGVmZmVjdC50cmFuc2Zvcm0oY3R4LmRhdGEsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwcm9jZXNzZWQpLnRoZW4oYXN5bmMgKHByb2Nlc3NlZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IHByb2Nlc3NlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzLnZhbHVlID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gRElSVFkocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuc2NoZW1hLl9wYXJzZVN5bmMoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhOiBwcm9jZXNzZWQsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuc3RhdHVzID09PSBcImRpcnR5XCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBESVJUWShyZXN1bHQudmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMudmFsdWUgPT09IFwiZGlydHlcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKHJlc3VsdC52YWx1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZWZmZWN0LnR5cGUgPT09IFwicmVmaW5lbWVudFwiKSB7XG4gICAgICAgICAgICBjb25zdCBleGVjdXRlUmVmaW5lbWVudCA9IChhY2MpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QucmVmaW5lbWVudChhY2MsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNvbW1vbi5hc3luYykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHJlZmluZW1lbnQgZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlubmVyID0gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VTeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIuc3RhdHVzID09PSBcImFib3J0ZWRcIilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIElOVkFMSUQ7XG4gICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAvLyByZXR1cm4gdmFsdWUgaXMgaWdub3JlZFxuICAgICAgICAgICAgICAgIGV4ZWN1dGVSZWZpbmVtZW50KGlubmVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoaW5uZXIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyLnN0YXR1cyA9PT0gXCJkaXJ0eVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBleGVjdXRlUmVmaW5lbWVudChpbm5lci52YWx1ZSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IHN0YXR1cy52YWx1ZSwgdmFsdWU6IGlubmVyLnZhbHVlIH07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlZmZlY3QudHlwZSA9PT0gXCJ0cmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgaWYgKGN0eC5jb21tb24uYXN5bmMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmFzZSA9IHRoaXMuX2RlZi5zY2hlbWEuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKGJhc2UpKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFzeW5jaHJvbm91cyB0cmFuc2Zvcm0gZW5jb3VudGVyZWQgZHVyaW5nIHN5bmNocm9ub3VzIHBhcnNlIG9wZXJhdGlvbi4gVXNlIC5wYXJzZUFzeW5jIGluc3RlYWQuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXR1czogc3RhdHVzLnZhbHVlLCB2YWx1ZTogcmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnNjaGVtYS5fcGFyc2VBc3luYyh7IGRhdGE6IGN0eC5kYXRhLCBwYXRoOiBjdHgucGF0aCwgcGFyZW50OiBjdHggfSkudGhlbigoYmFzZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWQoYmFzZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShlZmZlY3QudHJhbnNmb3JtKGJhc2UudmFsdWUsIGNoZWNrQ3R4KSkudGhlbigocmVzdWx0KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBzdGF0dXMudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdXRpbC5hc3NlcnROZXZlcihlZmZlY3QpO1xuICAgIH1cbn1cblpvZEVmZmVjdHMuY3JlYXRlID0gKHNjaGVtYSwgZWZmZWN0LCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZEVmZmVjdHMoe1xuICAgICAgICBzY2hlbWEsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRWZmZWN0cyxcbiAgICAgICAgZWZmZWN0LFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuWm9kRWZmZWN0cy5jcmVhdGVXaXRoUHJlcHJvY2VzcyA9IChwcmVwcm9jZXNzLCBzY2hlbWEsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kRWZmZWN0cyh7XG4gICAgICAgIHNjaGVtYSxcbiAgICAgICAgZWZmZWN0OiB7IHR5cGU6IFwicHJlcHJvY2Vzc1wiLCB0cmFuc2Zvcm06IHByZXByb2Nlc3MgfSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RFZmZlY3RzLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IHsgWm9kRWZmZWN0cyBhcyBab2RUcmFuc2Zvcm1lciB9O1xuZXhwb3J0IGNsYXNzIFpvZE9wdGlvbmFsIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUudW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gT0sodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgIH1cbiAgICB1bndyYXAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlO1xuICAgIH1cbn1cblpvZE9wdGlvbmFsLmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZE9wdGlvbmFsKHtcbiAgICAgICAgaW5uZXJUeXBlOiB0eXBlLFxuICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZE9wdGlvbmFsLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE51bGxhYmxlIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHBhcnNlZFR5cGUgPSB0aGlzLl9nZXRUeXBlKGlucHV0KTtcbiAgICAgICAgaWYgKHBhcnNlZFR5cGUgPT09IFpvZFBhcnNlZFR5cGUubnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9LKG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZShpbnB1dCk7XG4gICAgfVxuICAgIHVud3JhcCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5pbm5lclR5cGU7XG4gICAgfVxufVxuWm9kTnVsbGFibGUuY3JlYXRlID0gKHR5cGUsIHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTnVsbGFibGUoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kTnVsbGFibGUsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kRGVmYXVsdCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgbGV0IGRhdGEgPSBjdHguZGF0YTtcbiAgICAgICAgaWYgKGN0eC5wYXJzZWRUeXBlID09PSBab2RQYXJzZWRUeXBlLnVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2RlZi5kZWZhdWx0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2Uoe1xuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IGN0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW1vdmVEZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2REZWZhdWx0LmNyZWF0ZSA9ICh0eXBlLCBwYXJhbXMpID0+IHtcbiAgICByZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuICAgICAgICBpbm5lclR5cGU6IHR5cGUsXG4gICAgICAgIHR5cGVOYW1lOiBab2RGaXJzdFBhcnR5VHlwZUtpbmQuWm9kRGVmYXVsdCxcbiAgICAgICAgZGVmYXVsdFZhbHVlOiB0eXBlb2YgcGFyYW1zLmRlZmF1bHQgPT09IFwiZnVuY3Rpb25cIiA/IHBhcmFtcy5kZWZhdWx0IDogKCkgPT4gcGFyYW1zLmRlZmF1bHQsXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY2xhc3MgWm9kQ2F0Y2ggZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgeyBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIC8vIG5ld0N0eCBpcyB1c2VkIHRvIG5vdCBjb2xsZWN0IGlzc3VlcyBmcm9tIGlubmVyIHR5cGVzIGluIGN0eFxuICAgICAgICBjb25zdCBuZXdDdHggPSB7XG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgICAgICBjb21tb246IHtcbiAgICAgICAgICAgICAgICAuLi5jdHguY29tbW9uLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9kZWYuaW5uZXJUeXBlLl9wYXJzZSh7XG4gICAgICAgICAgICBkYXRhOiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgIHBhdGg6IG5ld0N0eC5wYXRoLFxuICAgICAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgICAgICAgLi4ubmV3Q3R4LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc0FzeW5jKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcInZhbGlkXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiByZXN1bHQuc3RhdHVzID09PSBcInZhbGlkXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuX2RlZi5jYXRjaFZhbHVlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IG5ld0N0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0dXM6IFwidmFsaWRcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogcmVzdWx0LnN0YXR1cyA9PT0gXCJ2YWxpZFwiXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogdGhpcy5fZGVmLmNhdGNoVmFsdWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0IGVycm9yKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgWm9kRXJyb3IobmV3Q3R4LmNvbW1vbi5pc3N1ZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBuZXdDdHguZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZUNhdGNoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RDYXRjaC5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RDYXRjaCxcbiAgICAgICAgY2F0Y2hWYWx1ZTogdHlwZW9mIHBhcmFtcy5jYXRjaCA9PT0gXCJmdW5jdGlvblwiID8gcGFyYW1zLmNhdGNoIDogKCkgPT4gcGFyYW1zLmNhdGNoLFxuICAgICAgICAuLi5wcm9jZXNzQ3JlYXRlUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59O1xuZXhwb3J0IGNsYXNzIFpvZE5hTiBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCBwYXJzZWRUeXBlID0gdGhpcy5fZ2V0VHlwZShpbnB1dCk7XG4gICAgICAgIGlmIChwYXJzZWRUeXBlICE9PSBab2RQYXJzZWRUeXBlLm5hbikge1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5fZ2V0T3JSZXR1cm5DdHgoaW5wdXQpO1xuICAgICAgICAgICAgYWRkSXNzdWVUb0NvbnRleHQoY3R4LCB7XG4gICAgICAgICAgICAgICAgY29kZTogWm9kSXNzdWVDb2RlLmludmFsaWRfdHlwZSxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogWm9kUGFyc2VkVHlwZS5uYW4sXG4gICAgICAgICAgICAgICAgcmVjZWl2ZWQ6IGN0eC5wYXJzZWRUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gSU5WQUxJRDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdGF0dXM6IFwidmFsaWRcIiwgdmFsdWU6IGlucHV0LmRhdGEgfTtcbiAgICB9XG59XG5ab2ROYU4uY3JlYXRlID0gKHBhcmFtcykgPT4ge1xuICAgIHJldHVybiBuZXcgWm9kTmFOKHtcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2ROYU4sXG4gICAgICAgIC4uLnByb2Nlc3NDcmVhdGVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgQlJBTkQgPSBTeW1ib2woXCJ6b2RfYnJhbmRcIik7XG5leHBvcnQgY2xhc3MgWm9kQnJhbmRlZCBleHRlbmRzIFpvZFR5cGUge1xuICAgIF9wYXJzZShpbnB1dCkge1xuICAgICAgICBjb25zdCB7IGN0eCB9ID0gdGhpcy5fcHJvY2Vzc0lucHV0UGFyYW1zKGlucHV0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhO1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGUuX3BhcnNlKHtcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgIHBhcmVudDogY3R4LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLnR5cGU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFpvZFBpcGVsaW5lIGV4dGVuZHMgWm9kVHlwZSB7XG4gICAgX3BhcnNlKGlucHV0KSB7XG4gICAgICAgIGNvbnN0IHsgc3RhdHVzLCBjdHggfSA9IHRoaXMuX3Byb2Nlc3NJbnB1dFBhcmFtcyhpbnB1dCk7XG4gICAgICAgIGlmIChjdHguY29tbW9uLmFzeW5jKSB7XG4gICAgICAgICAgICBjb25zdCBoYW5kbGVBc3luYyA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpblJlc3VsdCA9IGF3YWl0IHRoaXMuX2RlZi5pbi5fcGFyc2VBc3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGN0eC5kYXRhLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJhYm9ydGVkXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiZGlydHlcIikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZGlydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIERJUlRZKGluUmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9kZWYub3V0Ll9wYXJzZUFzeW5jKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnQ6IGN0eCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVBc3luYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgaW5SZXN1bHQgPSB0aGlzLl9kZWYuaW4uX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgZGF0YTogY3R4LmRhdGEsXG4gICAgICAgICAgICAgICAgcGF0aDogY3R4LnBhdGgsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpblJlc3VsdC5zdGF0dXMgPT09IFwiYWJvcnRlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybiBJTlZBTElEO1xuICAgICAgICAgICAgaWYgKGluUmVzdWx0LnN0YXR1cyA9PT0gXCJkaXJ0eVwiKSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzLmRpcnR5KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBcImRpcnR5XCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBpblJlc3VsdC52YWx1ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2RlZi5vdXQuX3BhcnNlU3luYyh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IGluUmVzdWx0LnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdHgucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50OiBjdHgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShhLCBiKSB7XG4gICAgICAgIHJldHVybiBuZXcgWm9kUGlwZWxpbmUoe1xuICAgICAgICAgICAgaW46IGEsXG4gICAgICAgICAgICBvdXQ6IGIsXG4gICAgICAgICAgICB0eXBlTmFtZTogWm9kRmlyc3RQYXJ0eVR5cGVLaW5kLlpvZFBpcGVsaW5lLFxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgWm9kUmVhZG9ubHkgZXh0ZW5kcyBab2RUeXBlIHtcbiAgICBfcGFyc2UoaW5wdXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5fZGVmLmlubmVyVHlwZS5fcGFyc2UoaW5wdXQpO1xuICAgICAgICBjb25zdCBmcmVlemUgPSAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWQoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShkYXRhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXNBc3luYyhyZXN1bHQpID8gcmVzdWx0LnRoZW4oKGRhdGEpID0+IGZyZWV6ZShkYXRhKSkgOiBmcmVlemUocmVzdWx0KTtcbiAgICB9XG4gICAgdW53cmFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmLmlubmVyVHlwZTtcbiAgICB9XG59XG5ab2RSZWFkb25seS5jcmVhdGUgPSAodHlwZSwgcGFyYW1zKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBab2RSZWFkb25seSh7XG4gICAgICAgIGlubmVyVHlwZTogdHlwZSxcbiAgICAgICAgdHlwZU5hbWU6IFpvZEZpcnN0UGFydHlUeXBlS2luZC5ab2RSZWFkb25seSxcbiAgICAgICAgLi4ucHJvY2Vzc0NyZWF0ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICB6LmN1c3RvbSAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8gICAgICAgICAgICAgICAgICAgIC8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmZ1bmN0aW9uIGNsZWFuUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgIGNvbnN0IHAgPSB0eXBlb2YgcGFyYW1zID09PSBcImZ1bmN0aW9uXCIgPyBwYXJhbXMoZGF0YSkgOiB0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwYXJhbXMgfSA6IHBhcmFtcztcbiAgICBjb25zdCBwMiA9IHR5cGVvZiBwID09PSBcInN0cmluZ1wiID8geyBtZXNzYWdlOiBwIH0gOiBwO1xuICAgIHJldHVybiBwMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjdXN0b20oY2hlY2ssIF9wYXJhbXMgPSB7fSwgXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKlxuICogUGFzcyBgZmF0YWxgIGludG8gdGhlIHBhcmFtcyBvYmplY3QgaW5zdGVhZDpcbiAqXG4gKiBgYGB0c1xuICogei5zdHJpbmcoKS5jdXN0b20oKHZhbCkgPT4gdmFsLmxlbmd0aCA+IDUsIHsgZmF0YWw6IGZhbHNlIH0pXG4gKiBgYGBcbiAqXG4gKi9cbmZhdGFsKSB7XG4gICAgaWYgKGNoZWNrKVxuICAgICAgICByZXR1cm4gWm9kQW55LmNyZWF0ZSgpLnN1cGVyUmVmaW5lKChkYXRhLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHIgPSBjaGVjayhkYXRhKTtcbiAgICAgICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByLnRoZW4oKHIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IF9mYXRhbCA9IHBhcmFtcy5mYXRhbCA/PyBmYXRhbCA/PyB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3R4LmFkZElzc3VlKHsgY29kZTogXCJjdXN0b21cIiwgLi4ucGFyYW1zLCBmYXRhbDogX2ZhdGFsIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjbGVhblBhcmFtcyhfcGFyYW1zLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBfZmF0YWwgPSBwYXJhbXMuZmF0YWwgPz8gZmF0YWwgPz8gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjdHguYWRkSXNzdWUoeyBjb2RlOiBcImN1c3RvbVwiLCAuLi5wYXJhbXMsIGZhdGFsOiBfZmF0YWwgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIHJldHVybiBab2RBbnkuY3JlYXRlKCk7XG59XG5leHBvcnQgeyBab2RUeXBlIGFzIFNjaGVtYSwgWm9kVHlwZSBhcyBab2RTY2hlbWEgfTtcbmV4cG9ydCBjb25zdCBsYXRlID0ge1xuICAgIG9iamVjdDogWm9kT2JqZWN0LmxhenljcmVhdGUsXG59O1xuZXhwb3J0IHZhciBab2RGaXJzdFBhcnR5VHlwZUtpbmQ7XG4oZnVuY3Rpb24gKFpvZEZpcnN0UGFydHlUeXBlS2luZCkge1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFN0cmluZ1wiXSA9IFwiWm9kU3RyaW5nXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVtYmVyXCJdID0gXCJab2ROdW1iZXJcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2ROYU5cIl0gPSBcIlpvZE5hTlwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEJpZ0ludFwiXSA9IFwiWm9kQmlnSW50XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQm9vbGVhblwiXSA9IFwiWm9kQm9vbGVhblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERhdGVcIl0gPSBcIlpvZERhdGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RTeW1ib2xcIl0gPSBcIlpvZFN5bWJvbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuZGVmaW5lZFwiXSA9IFwiWm9kVW5kZWZpbmVkXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTnVsbFwiXSA9IFwiWm9kTnVsbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEFueVwiXSA9IFwiWm9kQW55XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kVW5rbm93blwiXSA9IFwiWm9kVW5rbm93blwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE5ldmVyXCJdID0gXCJab2ROZXZlclwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFZvaWRcIl0gPSBcIlpvZFZvaWRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RBcnJheVwiXSA9IFwiWm9kQXJyYXlcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RPYmplY3RcIl0gPSBcIlpvZE9iamVjdFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFVuaW9uXCJdID0gXCJab2RVbmlvblwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERpc2NyaW1pbmF0ZWRVbmlvblwiXSA9IFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kSW50ZXJzZWN0aW9uXCJdID0gXCJab2RJbnRlcnNlY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RUdXBsZVwiXSA9IFwiWm9kVHVwbGVcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RSZWNvcmRcIl0gPSBcIlpvZFJlY29yZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE1hcFwiXSA9IFwiWm9kTWFwXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kU2V0XCJdID0gXCJab2RTZXRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RGdW5jdGlvblwiXSA9IFwiWm9kRnVuY3Rpb25cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RMYXp5XCJdID0gXCJab2RMYXp5XCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTGl0ZXJhbFwiXSA9IFwiWm9kTGl0ZXJhbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZEVudW1cIl0gPSBcIlpvZEVudW1cIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RFZmZlY3RzXCJdID0gXCJab2RFZmZlY3RzXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kTmF0aXZlRW51bVwiXSA9IFwiWm9kTmF0aXZlRW51bVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE9wdGlvbmFsXCJdID0gXCJab2RPcHRpb25hbFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZE51bGxhYmxlXCJdID0gXCJab2ROdWxsYWJsZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZERlZmF1bHRcIl0gPSBcIlpvZERlZmF1bHRcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RDYXRjaFwiXSA9IFwiWm9kQ2F0Y2hcIjtcbiAgICBab2RGaXJzdFBhcnR5VHlwZUtpbmRbXCJab2RQcm9taXNlXCJdID0gXCJab2RQcm9taXNlXCI7XG4gICAgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kW1wiWm9kQnJhbmRlZFwiXSA9IFwiWm9kQnJhbmRlZFwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFBpcGVsaW5lXCJdID0gXCJab2RQaXBlbGluZVwiO1xuICAgIFpvZEZpcnN0UGFydHlUeXBlS2luZFtcIlpvZFJlYWRvbmx5XCJdID0gXCJab2RSZWFkb25seVwiO1xufSkoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIHx8IChab2RGaXJzdFBhcnR5VHlwZUtpbmQgPSB7fSkpO1xuLy8gcmVxdWlyZXMgVFMgNC40K1xuY2xhc3MgQ2xhc3Mge1xuICAgIGNvbnN0cnVjdG9yKC4uLl8pIHsgfVxufVxuY29uc3QgaW5zdGFuY2VPZlR5cGUgPSAoXG4vLyBjb25zdCBpbnN0YW5jZU9mVHlwZSA9IDxUIGV4dGVuZHMgbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gYW55PihcbmNscywgcGFyYW1zID0ge1xuICAgIG1lc3NhZ2U6IGBJbnB1dCBub3QgaW5zdGFuY2Ugb2YgJHtjbHMubmFtZX1gLFxufSkgPT4gY3VzdG9tKChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLCBwYXJhbXMpO1xuY29uc3Qgc3RyaW5nVHlwZSA9IFpvZFN0cmluZy5jcmVhdGU7XG5jb25zdCBudW1iZXJUeXBlID0gWm9kTnVtYmVyLmNyZWF0ZTtcbmNvbnN0IG5hblR5cGUgPSBab2ROYU4uY3JlYXRlO1xuY29uc3QgYmlnSW50VHlwZSA9IFpvZEJpZ0ludC5jcmVhdGU7XG5jb25zdCBib29sZWFuVHlwZSA9IFpvZEJvb2xlYW4uY3JlYXRlO1xuY29uc3QgZGF0ZVR5cGUgPSBab2REYXRlLmNyZWF0ZTtcbmNvbnN0IHN5bWJvbFR5cGUgPSBab2RTeW1ib2wuY3JlYXRlO1xuY29uc3QgdW5kZWZpbmVkVHlwZSA9IFpvZFVuZGVmaW5lZC5jcmVhdGU7XG5jb25zdCBudWxsVHlwZSA9IFpvZE51bGwuY3JlYXRlO1xuY29uc3QgYW55VHlwZSA9IFpvZEFueS5jcmVhdGU7XG5jb25zdCB1bmtub3duVHlwZSA9IFpvZFVua25vd24uY3JlYXRlO1xuY29uc3QgbmV2ZXJUeXBlID0gWm9kTmV2ZXIuY3JlYXRlO1xuY29uc3Qgdm9pZFR5cGUgPSBab2RWb2lkLmNyZWF0ZTtcbmNvbnN0IGFycmF5VHlwZSA9IFpvZEFycmF5LmNyZWF0ZTtcbmNvbnN0IG9iamVjdFR5cGUgPSBab2RPYmplY3QuY3JlYXRlO1xuY29uc3Qgc3RyaWN0T2JqZWN0VHlwZSA9IFpvZE9iamVjdC5zdHJpY3RDcmVhdGU7XG5jb25zdCB1bmlvblR5cGUgPSBab2RVbmlvbi5jcmVhdGU7XG5jb25zdCBkaXNjcmltaW5hdGVkVW5pb25UeXBlID0gWm9kRGlzY3JpbWluYXRlZFVuaW9uLmNyZWF0ZTtcbmNvbnN0IGludGVyc2VjdGlvblR5cGUgPSBab2RJbnRlcnNlY3Rpb24uY3JlYXRlO1xuY29uc3QgdHVwbGVUeXBlID0gWm9kVHVwbGUuY3JlYXRlO1xuY29uc3QgcmVjb3JkVHlwZSA9IFpvZFJlY29yZC5jcmVhdGU7XG5jb25zdCBtYXBUeXBlID0gWm9kTWFwLmNyZWF0ZTtcbmNvbnN0IHNldFR5cGUgPSBab2RTZXQuY3JlYXRlO1xuY29uc3QgZnVuY3Rpb25UeXBlID0gWm9kRnVuY3Rpb24uY3JlYXRlO1xuY29uc3QgbGF6eVR5cGUgPSBab2RMYXp5LmNyZWF0ZTtcbmNvbnN0IGxpdGVyYWxUeXBlID0gWm9kTGl0ZXJhbC5jcmVhdGU7XG5jb25zdCBlbnVtVHlwZSA9IFpvZEVudW0uY3JlYXRlO1xuY29uc3QgbmF0aXZlRW51bVR5cGUgPSBab2ROYXRpdmVFbnVtLmNyZWF0ZTtcbmNvbnN0IHByb21pc2VUeXBlID0gWm9kUHJvbWlzZS5jcmVhdGU7XG5jb25zdCBlZmZlY3RzVHlwZSA9IFpvZEVmZmVjdHMuY3JlYXRlO1xuY29uc3Qgb3B0aW9uYWxUeXBlID0gWm9kT3B0aW9uYWwuY3JlYXRlO1xuY29uc3QgbnVsbGFibGVUeXBlID0gWm9kTnVsbGFibGUuY3JlYXRlO1xuY29uc3QgcHJlcHJvY2Vzc1R5cGUgPSBab2RFZmZlY3RzLmNyZWF0ZVdpdGhQcmVwcm9jZXNzO1xuY29uc3QgcGlwZWxpbmVUeXBlID0gWm9kUGlwZWxpbmUuY3JlYXRlO1xuY29uc3Qgb3N0cmluZyA9ICgpID0+IHN0cmluZ1R5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb251bWJlciA9ICgpID0+IG51bWJlclR5cGUoKS5vcHRpb25hbCgpO1xuY29uc3Qgb2Jvb2xlYW4gPSAoKSA9PiBib29sZWFuVHlwZSgpLm9wdGlvbmFsKCk7XG5leHBvcnQgY29uc3QgY29lcmNlID0ge1xuICAgIHN0cmluZzogKChhcmcpID0+IFpvZFN0cmluZy5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG4gICAgbnVtYmVyOiAoKGFyZykgPT4gWm9kTnVtYmVyLmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBib29sZWFuOiAoKGFyZykgPT4gWm9kQm9vbGVhbi5jcmVhdGUoe1xuICAgICAgICAuLi5hcmcsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICB9KSksXG4gICAgYmlnaW50OiAoKGFyZykgPT4gWm9kQmlnSW50LmNyZWF0ZSh7IC4uLmFyZywgY29lcmNlOiB0cnVlIH0pKSxcbiAgICBkYXRlOiAoKGFyZykgPT4gWm9kRGF0ZS5jcmVhdGUoeyAuLi5hcmcsIGNvZXJjZTogdHJ1ZSB9KSksXG59O1xuZXhwb3J0IHsgYW55VHlwZSBhcyBhbnksIGFycmF5VHlwZSBhcyBhcnJheSwgYmlnSW50VHlwZSBhcyBiaWdpbnQsIGJvb2xlYW5UeXBlIGFzIGJvb2xlYW4sIGRhdGVUeXBlIGFzIGRhdGUsIGRpc2NyaW1pbmF0ZWRVbmlvblR5cGUgYXMgZGlzY3JpbWluYXRlZFVuaW9uLCBlZmZlY3RzVHlwZSBhcyBlZmZlY3QsIGVudW1UeXBlIGFzIGVudW0sIGZ1bmN0aW9uVHlwZSBhcyBmdW5jdGlvbiwgaW5zdGFuY2VPZlR5cGUgYXMgaW5zdGFuY2VvZiwgaW50ZXJzZWN0aW9uVHlwZSBhcyBpbnRlcnNlY3Rpb24sIGxhenlUeXBlIGFzIGxhenksIGxpdGVyYWxUeXBlIGFzIGxpdGVyYWwsIG1hcFR5cGUgYXMgbWFwLCBuYW5UeXBlIGFzIG5hbiwgbmF0aXZlRW51bVR5cGUgYXMgbmF0aXZlRW51bSwgbmV2ZXJUeXBlIGFzIG5ldmVyLCBudWxsVHlwZSBhcyBudWxsLCBudWxsYWJsZVR5cGUgYXMgbnVsbGFibGUsIG51bWJlclR5cGUgYXMgbnVtYmVyLCBvYmplY3RUeXBlIGFzIG9iamVjdCwgb2Jvb2xlYW4sIG9udW1iZXIsIG9wdGlvbmFsVHlwZSBhcyBvcHRpb25hbCwgb3N0cmluZywgcGlwZWxpbmVUeXBlIGFzIHBpcGVsaW5lLCBwcmVwcm9jZXNzVHlwZSBhcyBwcmVwcm9jZXNzLCBwcm9taXNlVHlwZSBhcyBwcm9taXNlLCByZWNvcmRUeXBlIGFzIHJlY29yZCwgc2V0VHlwZSBhcyBzZXQsIHN0cmljdE9iamVjdFR5cGUgYXMgc3RyaWN0T2JqZWN0LCBzdHJpbmdUeXBlIGFzIHN0cmluZywgc3ltYm9sVHlwZSBhcyBzeW1ib2wsIGVmZmVjdHNUeXBlIGFzIHRyYW5zZm9ybWVyLCB0dXBsZVR5cGUgYXMgdHVwbGUsIHVuZGVmaW5lZFR5cGUgYXMgdW5kZWZpbmVkLCB1bmlvblR5cGUgYXMgdW5pb24sIHVua25vd25UeXBlIGFzIHVua25vd24sIHZvaWRUeXBlIGFzIHZvaWQsIH07XG5leHBvcnQgY29uc3QgTkVWRVIgPSBJTlZBTElEO1xuIiwgIi8qKiBBIHNwZWNpYWwgY29uc3RhbnQgd2l0aCB0eXBlIGBuZXZlcmAgKi9cbmV4cG9ydCBjb25zdCBORVZFUiA9IE9iamVjdC5mcmVlemUoe1xuICAgIHN0YXR1czogXCJhYm9ydGVkXCIsXG59KTtcbmV4cG9ydCAvKkBfX05PX1NJREVfRUZGRUNUU19fKi8gZnVuY3Rpb24gJGNvbnN0cnVjdG9yKG5hbWUsIGluaXRpYWxpemVyLCBwYXJhbXMpIHtcbiAgICBmdW5jdGlvbiBpbml0KGluc3QsIGRlZikge1xuICAgICAgICBpZiAoIWluc3QuX3pvZCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX3pvZFwiLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGVmLFxuICAgICAgICAgICAgICAgICAgICBjb25zdHI6IF8sXG4gICAgICAgICAgICAgICAgICAgIHRyYWl0czogbmV3IFNldCgpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5zdC5fem9kLnRyYWl0cy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpbnN0Ll96b2QudHJhaXRzLmFkZChuYW1lKTtcbiAgICAgICAgaW5pdGlhbGl6ZXIoaW5zdCwgZGVmKTtcbiAgICAgICAgLy8gc3VwcG9ydCBwcm90b3R5cGUgbW9kaWZpY2F0aW9uc1xuICAgICAgICBjb25zdCBwcm90byA9IF8ucHJvdG90eXBlO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMocHJvdG8pO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgaWYgKCEoayBpbiBpbnN0KSkge1xuICAgICAgICAgICAgICAgIGluc3Rba10gPSBwcm90b1trXS5iaW5kKGluc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGRvZXNuJ3Qgd29yayBpZiBQYXJlbnQgaGFzIGEgY29uc3RydWN0b3Igd2l0aCBhcmd1bWVudHNcbiAgICBjb25zdCBQYXJlbnQgPSBwYXJhbXM/LlBhcmVudCA/PyBPYmplY3Q7XG4gICAgY2xhc3MgRGVmaW5pdGlvbiBleHRlbmRzIFBhcmVudCB7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShEZWZpbml0aW9uLCBcIm5hbWVcIiwgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICBmdW5jdGlvbiBfKGRlZikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGluc3QgPSBwYXJhbXM/LlBhcmVudCA/IG5ldyBEZWZpbml0aW9uKCkgOiB0aGlzO1xuICAgICAgICBpbml0KGluc3QsIGRlZik7XG4gICAgICAgIChfYSA9IGluc3QuX3pvZCkuZGVmZXJyZWQgPz8gKF9hLmRlZmVycmVkID0gW10pO1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIGluc3QuX3pvZC5kZWZlcnJlZCkge1xuICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdDtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwiaW5pdFwiLCB7IHZhbHVlOiBpbml0IH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICAgICAgdmFsdWU6IChpbnN0KSA9PiB7XG4gICAgICAgICAgICBpZiAocGFyYW1zPy5QYXJlbnQgJiYgaW5zdCBpbnN0YW5jZW9mIHBhcmFtcy5QYXJlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICByZXR1cm4gaW5zdD8uX3pvZD8udHJhaXRzPy5oYXMobmFtZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pO1xuICAgIHJldHVybiBfO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgVVRJTElUSUVTICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgY29uc3QgJGJyYW5kID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xuZXhwb3J0IGNsYXNzICRab2RBc3luY0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcihgRW5jb3VudGVyZWQgUHJvbWlzZSBkdXJpbmcgc3luY2hyb25vdXMgcGFyc2UuIFVzZSAucGFyc2VBc3luYygpIGluc3RlYWQuYCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzICRab2RFbmNvZGVFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lKSB7XG4gICAgICAgIHN1cGVyKGBFbmNvdW50ZXJlZCB1bmlkaXJlY3Rpb25hbCB0cmFuc2Zvcm0gZHVyaW5nIGVuY29kZTogJHtuYW1lfWApO1xuICAgICAgICB0aGlzLm5hbWUgPSBcIlpvZEVuY29kZUVycm9yXCI7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IGdsb2JhbENvbmZpZyA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmZpZyhuZXdDb25maWcpIHtcbiAgICBpZiAobmV3Q29uZmlnKVxuICAgICAgICBPYmplY3QuYXNzaWduKGdsb2JhbENvbmZpZywgbmV3Q29uZmlnKTtcbiAgICByZXR1cm4gZ2xvYmFsQ29uZmlnO1xufVxuIiwgIi8vIGZ1bmN0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydEVxdWFsKHZhbCkge1xuICAgIHJldHVybiB2YWw7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0Tm90RXF1YWwodmFsKSB7XG4gICAgcmV0dXJuIHZhbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnRJcyhfYXJnKSB7IH1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnROZXZlcihfeCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgdmFsdWUgaW4gZXhoYXVzdGl2ZSBjaGVja1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQoXykgeyB9XG5leHBvcnQgZnVuY3Rpb24gZ2V0RW51bVZhbHVlcyhlbnRyaWVzKSB7XG4gICAgY29uc3QgbnVtZXJpY1ZhbHVlcyA9IE9iamVjdC52YWx1ZXMoZW50cmllcykuZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIik7XG4gICAgY29uc3QgdmFsdWVzID0gT2JqZWN0LmVudHJpZXMoZW50cmllcylcbiAgICAgICAgLmZpbHRlcigoW2ssIF9dKSA9PiBudW1lcmljVmFsdWVzLmluZGV4T2YoK2spID09PSAtMSlcbiAgICAgICAgLm1hcCgoW18sIHZdKSA9PiB2KTtcbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGpvaW5WYWx1ZXMoYXJyYXksIHNlcGFyYXRvciA9IFwifFwiKSB7XG4gICAgcmV0dXJuIGFycmF5Lm1hcCgodmFsKSA9PiBzdHJpbmdpZnlQcmltaXRpdmUodmFsKSkuam9pbihzZXBhcmF0b3IpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGpzb25TdHJpbmdpZnlSZXBsYWNlcihfLCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpXG4gICAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjYWNoZWQoZ2V0dGVyKSB7XG4gICAgY29uc3Qgc2V0ID0gZmFsc2U7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IHZhbHVlKCkge1xuICAgICAgICAgICAgaWYgKCFzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcInZhbHVlXCIsIHsgdmFsdWUgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2FjaGVkIHZhbHVlIGFscmVhZHkgc2V0XCIpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gbnVsbGlzaChpbnB1dCkge1xuICAgIHJldHVybiBpbnB1dCA9PT0gbnVsbCB8fCBpbnB1dCA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFuUmVnZXgoc291cmNlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBzb3VyY2Uuc3RhcnRzV2l0aChcIl5cIikgPyAxIDogMDtcbiAgICBjb25zdCBlbmQgPSBzb3VyY2UuZW5kc1dpdGgoXCIkXCIpID8gc291cmNlLmxlbmd0aCAtIDEgOiBzb3VyY2UubGVuZ3RoO1xuICAgIHJldHVybiBzb3VyY2Uuc2xpY2Uoc3RhcnQsIGVuZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZmxvYXRTYWZlUmVtYWluZGVyKHZhbCwgc3RlcCkge1xuICAgIGNvbnN0IHZhbERlY0NvdW50ID0gKHZhbC50b1N0cmluZygpLnNwbGl0KFwiLlwiKVsxXSB8fCBcIlwiKS5sZW5ndGg7XG4gICAgY29uc3Qgc3RlcFN0cmluZyA9IHN0ZXAudG9TdHJpbmcoKTtcbiAgICBsZXQgc3RlcERlY0NvdW50ID0gKHN0ZXBTdHJpbmcuc3BsaXQoXCIuXCIpWzFdIHx8IFwiXCIpLmxlbmd0aDtcbiAgICBpZiAoc3RlcERlY0NvdW50ID09PSAwICYmIC9cXGQ/ZS1cXGQ/Ly50ZXN0KHN0ZXBTdHJpbmcpKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gc3RlcFN0cmluZy5tYXRjaCgvXFxkP2UtKFxcZD8pLyk7XG4gICAgICAgIGlmIChtYXRjaD8uWzFdKSB7XG4gICAgICAgICAgICBzdGVwRGVjQ291bnQgPSBOdW1iZXIucGFyc2VJbnQobWF0Y2hbMV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRlY0NvdW50ID0gdmFsRGVjQ291bnQgPiBzdGVwRGVjQ291bnQgPyB2YWxEZWNDb3VudCA6IHN0ZXBEZWNDb3VudDtcbiAgICBjb25zdCB2YWxJbnQgPSBOdW1iZXIucGFyc2VJbnQodmFsLnRvRml4ZWQoZGVjQ291bnQpLnJlcGxhY2UoXCIuXCIsIFwiXCIpKTtcbiAgICBjb25zdCBzdGVwSW50ID0gTnVtYmVyLnBhcnNlSW50KHN0ZXAudG9GaXhlZChkZWNDb3VudCkucmVwbGFjZShcIi5cIiwgXCJcIikpO1xuICAgIHJldHVybiAodmFsSW50ICUgc3RlcEludCkgLyAxMCAqKiBkZWNDb3VudDtcbn1cbmNvbnN0IEVWQUxVQVRJTkcgPSBTeW1ib2woXCJldmFsdWF0aW5nXCIpO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZUxhenkob2JqZWN0LCBrZXksIGdldHRlcikge1xuICAgIGxldCB2YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBrZXksIHtcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSBFVkFMVUFUSU5HKSB7XG4gICAgICAgICAgICAgICAgLy8gQ2lyY3VsYXIgcmVmZXJlbmNlIGRldGVjdGVkLCByZXR1cm4gdW5kZWZpbmVkIHRvIGJyZWFrIHRoZSBjeWNsZVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gRVZBTFVBVElORztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldHRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9LFxuICAgICAgICBzZXQodikge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwga2V5LCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IHYsXG4gICAgICAgICAgICAgICAgLy8gY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBvYmplY3Rba2V5XSA9IHY7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3RDbG9uZShvYmopIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob2JqKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzaWduUHJvcCh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZURlZnMoLi4uZGVmcykge1xuICAgIGNvbnN0IG1lcmdlZERlc2NyaXB0b3JzID0ge307XG4gICAgZm9yIChjb25zdCBkZWYgb2YgZGVmcykge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKGRlZik7XG4gICAgICAgIE9iamVjdC5hc3NpZ24obWVyZ2VkRGVzY3JpcHRvcnMsIGRlc2NyaXB0b3JzKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCBtZXJnZWREZXNjcmlwdG9ycyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY2xvbmVEZWYoc2NoZW1hKSB7XG4gICAgcmV0dXJuIG1lcmdlRGVmcyhzY2hlbWEuX3pvZC5kZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEVsZW1lbnRBdFBhdGgob2JqLCBwYXRoKSB7XG4gICAgaWYgKCFwYXRoKVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIHJldHVybiBwYXRoLnJlZHVjZSgoYWNjLCBrZXkpID0+IGFjYz8uW2tleV0sIG9iaik7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZUFsbE9iamVjdChwcm9taXNlc09iaikge1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhwcm9taXNlc09iaik7XG4gICAgY29uc3QgcHJvbWlzZXMgPSBrZXlzLm1hcCgoa2V5KSA9PiBwcm9taXNlc09ialtrZXldKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpLnRoZW4oKHJlc3VsdHMpID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWRPYmogPSB7fTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByZXNvbHZlZE9ialtrZXlzW2ldXSA9IHJlc3VsdHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVkT2JqO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVN0cmluZyhsZW5ndGggPSAxMCkge1xuICAgIGNvbnN0IGNoYXJzID0gXCJhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5elwiO1xuICAgIGxldCBzdHIgPSBcIlwiO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RyICs9IGNoYXJzW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJzLmxlbmd0aCldO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVzYyhzdHIpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoc3RyKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzbHVnaWZ5KGlucHV0KSB7XG4gICAgcmV0dXJuIGlucHV0XG4gICAgICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIC50cmltKClcbiAgICAgICAgLnJlcGxhY2UoL1teXFx3XFxzLV0vZywgXCJcIilcbiAgICAgICAgLnJlcGxhY2UoL1tcXHNfLV0rL2csIFwiLVwiKVxuICAgICAgICAucmVwbGFjZSgvXi0rfC0rJC9nLCBcIlwiKTtcbn1cbmV4cG9ydCBjb25zdCBjYXB0dXJlU3RhY2tUcmFjZSA9IChcImNhcHR1cmVTdGFja1RyYWNlXCIgaW4gRXJyb3IgPyBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA6ICguLi5fYXJncykgPT4geyB9KTtcbmV4cG9ydCBmdW5jdGlvbiBpc09iamVjdChkYXRhKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIGRhdGEgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5leHBvcnQgY29uc3QgYWxsb3dzRXZhbCA9IGNhY2hlZCgoKSA9PiB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIG5hdmlnYXRvcj8udXNlckFnZW50Py5pbmNsdWRlcyhcIkNsb3VkZmxhcmVcIikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBjb25zdCBGID0gRnVuY3Rpb247XG4gICAgICAgIG5ldyBGKFwiXCIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF8pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGxhaW5PYmplY3Qobykge1xuICAgIGlmIChpc09iamVjdChvKSA9PT0gZmFsc2UpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBtb2RpZmllZCBjb25zdHJ1Y3RvclxuICAgIGNvbnN0IGN0b3IgPSBvLmNvbnN0cnVjdG9yO1xuICAgIGlmIChjdG9yID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmICh0eXBlb2YgY3RvciAhPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAvLyBtb2RpZmllZCBwcm90b3R5cGVcbiAgICBjb25zdCBwcm90ID0gY3Rvci5wcm90b3R5cGU7XG4gICAgaWYgKGlzT2JqZWN0KHByb3QpID09PSBmYWxzZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIC8vIGN0b3IgZG9lc24ndCBoYXZlIHN0YXRpYyBgaXNQcm90b3R5cGVPZmBcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3QsIFwiaXNQcm90b3R5cGVPZlwiKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzaGFsbG93Q2xvbmUobykge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KG8pKVxuICAgICAgICByZXR1cm4geyAuLi5vIH07XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobykpXG4gICAgICAgIHJldHVybiBbLi4ub107XG4gICAgcmV0dXJuIG87XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtS2V5cyhkYXRhKSB7XG4gICAgbGV0IGtleUNvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSkge1xuICAgICAgICAgICAga2V5Q291bnQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga2V5Q291bnQ7XG59XG5leHBvcnQgY29uc3QgZ2V0UGFyc2VkVHlwZSA9IChkYXRhKSA9PiB7XG4gICAgY29uc3QgdCA9IHR5cGVvZiBkYXRhO1xuICAgIHN3aXRjaCAodCkge1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJ1bmRlZmluZWRcIjtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIFwic3RyaW5nXCI7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oZGF0YSkgPyBcIm5hblwiIDogXCJudW1iZXJcIjtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICByZXR1cm4gXCJmdW5jdGlvblwiO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgICByZXR1cm4gXCJiaWdpbnRcIjtcbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgICAgcmV0dXJuIFwic3ltYm9sXCI7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEudGhlbiAmJiB0eXBlb2YgZGF0YS50aGVuID09PSBcImZ1bmN0aW9uXCIgJiYgZGF0YS5jYXRjaCAmJiB0eXBlb2YgZGF0YS5jYXRjaCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwicHJvbWlzZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBNYXAgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIm1hcFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBTZXQgIT09IFwidW5kZWZpbmVkXCIgJiYgZGF0YSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcInNldFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBEYXRlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZGF0ZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBGaWxlICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiZmlsZVwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGF0YSB0eXBlOiAke3R9YCk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBwcm9wZXJ0eUtleVR5cGVzID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJzeW1ib2xcIl0pO1xuZXhwb3J0IGNvbnN0IHByaW1pdGl2ZVR5cGVzID0gbmV3IFNldChbXCJzdHJpbmdcIiwgXCJudW1iZXJcIiwgXCJiaWdpbnRcIiwgXCJib29sZWFuXCIsIFwic3ltYm9sXCIsIFwidW5kZWZpbmVkXCJdKTtcbmV4cG9ydCBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgICByZXR1cm4gc3RyLnJlcGxhY2UoL1suKis/XiR7fSgpfFtcXF1cXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbi8vIHpvZC1zcGVjaWZpYyB1dGlsc1xuZXhwb3J0IGZ1bmN0aW9uIGNsb25lKGluc3QsIGRlZiwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2wgPSBuZXcgaW5zdC5fem9kLmNvbnN0cihkZWYgPz8gaW5zdC5fem9kLmRlZik7XG4gICAgaWYgKCFkZWYgfHwgcGFyYW1zPy5wYXJlbnQpXG4gICAgICAgIGNsLl96b2QucGFyZW50ID0gaW5zdDtcbiAgICByZXR1cm4gY2w7XG59XG5leHBvcnQgZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBfcGFyYW1zO1xuICAgIGlmICghcGFyYW1zKVxuICAgICAgICByZXR1cm4ge307XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB7IGVycm9yOiAoKSA9PiBwYXJhbXMgfTtcbiAgICBpZiAocGFyYW1zPy5tZXNzYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcmFtcz8uZXJyb3IgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJvdGggYG1lc3NhZ2VgIGFuZCBgZXJyb3JgIHBhcmFtc1wiKTtcbiAgICAgICAgcGFyYW1zLmVycm9yID0gcGFyYW1zLm1lc3NhZ2U7XG4gICAgfVxuICAgIGRlbGV0ZSBwYXJhbXMubWVzc2FnZTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5lcnJvciA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIHsgLi4ucGFyYW1zLCBlcnJvcjogKCkgPT4gcGFyYW1zLmVycm9yIH07XG4gICAgcmV0dXJuIHBhcmFtcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUcmFuc3BhcmVudFByb3h5KGdldHRlcikge1xuICAgIGxldCB0YXJnZXQ7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQoXywgcHJvcCwgcmVjZWl2ZXIpIHtcbiAgICAgICAgICAgIHRhcmdldCA/PyAodGFyZ2V0ID0gZ2V0dGVyKCkpO1xuICAgICAgICAgICAgcmV0dXJuIFJlZmxlY3QuZ2V0KHRhcmdldCwgcHJvcCwgcmVjZWl2ZXIpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoXywgcHJvcCwgdmFsdWUsIHJlY2VpdmVyKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LnNldCh0YXJnZXQsIHByb3AsIHZhbHVlLCByZWNlaXZlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGhhcyhfLCBwcm9wKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0Lmhhcyh0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eShfLCBwcm9wKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRhcmdldCwgcHJvcCk7XG4gICAgICAgIH0sXG4gICAgICAgIG93bktleXMoXykge1xuICAgICAgICAgICAgdGFyZ2V0ID8/ICh0YXJnZXQgPSBnZXR0ZXIoKSk7XG4gICAgICAgICAgICByZXR1cm4gUmVmbGVjdC5vd25LZXlzKHRhcmdldCk7XG4gICAgICAgIH0sXG4gICAgICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihfLCBwcm9wKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIHByb3ApO1xuICAgICAgICB9LFxuICAgICAgICBkZWZpbmVQcm9wZXJ0eShfLCBwcm9wLCBkZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICB0YXJnZXQgPz8gKHRhcmdldCA9IGdldHRlcigpKTtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcCwgZGVzY3JpcHRvcik7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5naWZ5UHJpbWl0aXZlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkgKyBcIm5cIjtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKVxuICAgICAgICByZXR1cm4gYFwiJHt2YWx1ZX1cImA7XG4gICAgcmV0dXJuIGAke3ZhbHVlfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gb3B0aW9uYWxLZXlzKHNoYXBlKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNoYXBlKS5maWx0ZXIoKGspID0+IHtcbiAgICAgICAgcmV0dXJuIHNoYXBlW2tdLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIiAmJiBzaGFwZVtrXS5fem9kLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IE5VTUJFUl9GT1JNQVRfUkFOR0VTID0ge1xuICAgIHNhZmVpbnQ6IFtOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdLFxuICAgIGludDMyOiBbLTIxNDc0ODM2NDgsIDIxNDc0ODM2NDddLFxuICAgIHVpbnQzMjogWzAsIDQyOTQ5NjcyOTVdLFxuICAgIGZsb2F0MzI6IFstMy40MDI4MjM0NjYzODUyODg2ZTM4LCAzLjQwMjgyMzQ2NjM4NTI4ODZlMzhdLFxuICAgIGZsb2F0NjQ6IFstTnVtYmVyLk1BWF9WQUxVRSwgTnVtYmVyLk1BWF9WQUxVRV0sXG59O1xuZXhwb3J0IGNvbnN0IEJJR0lOVF9GT1JNQVRfUkFOR0VTID0ge1xuICAgIGludDY0OiBbLyogQF9fUFVSRV9fKi8gQmlnSW50KFwiLTkyMjMzNzIwMzY4NTQ3NzU4MDhcIiksIC8qIEBfX1BVUkVfXyovIEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIildLFxuICAgIHVpbnQ2NDogWy8qIEBfX1BVUkVfXyovIEJpZ0ludCgwKSwgLyogQF9fUFVSRV9fKi8gQmlnSW50KFwiMTg0NDY3NDQwNzM3MDk1NTE2MTVcIildLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBwaWNrKHNjaGVtYSwgbWFzaykge1xuICAgIGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgY2hlY2tzID0gY3VyckRlZi5jaGVja3M7XG4gICAgY29uc3QgaGFzQ2hlY2tzID0gY2hlY2tzICYmIGNoZWNrcy5sZW5ndGggPiAwO1xuICAgIGlmIChoYXNDaGVja3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiLnBpY2soKSBjYW5ub3QgYmUgdXNlZCBvbiBvYmplY3Qgc2NoZW1hcyBjb250YWluaW5nIHJlZmluZW1lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NoYXBlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGN1cnJEZWYuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbmV3U2hhcGVba2V5XSA9IGN1cnJEZWYuc2hhcGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBuZXdTaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIG5ld1NoYXBlO1xuICAgICAgICB9LFxuICAgICAgICBjaGVja3M6IFtdLFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG5leHBvcnQgZnVuY3Rpb24gb21pdChzY2hlbWEsIG1hc2spIHtcbiAgICBjb25zdCBjdXJyRGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IGNoZWNrcyA9IGN1cnJEZWYuY2hlY2tzO1xuICAgIGNvbnN0IGhhc0NoZWNrcyA9IGNoZWNrcyAmJiBjaGVja3MubGVuZ3RoID4gMDtcbiAgICBpZiAoaGFzQ2hlY2tzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5vbWl0KCkgY2Fubm90IGJlIHVzZWQgb24gb2JqZWN0IHNjaGVtYXMgY29udGFpbmluZyByZWZpbmVtZW50c1wiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlIH07XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIGN1cnJEZWYuc2hhcGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIW1hc2tba2V5XSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld1NoYXBlW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgbmV3U2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBuZXdTaGFwZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGV4dGVuZChzY2hlbWEsIHNoYXBlKSB7XG4gICAgaWYgKCFpc1BsYWluT2JqZWN0KHNoYXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIGV4dGVuZDogZXhwZWN0ZWQgYSBwbGFpbiBvYmplY3RcIik7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrcyA9IHNjaGVtYS5fem9kLmRlZi5jaGVja3M7XG4gICAgY29uc3QgaGFzQ2hlY2tzID0gY2hlY2tzICYmIGNoZWNrcy5sZW5ndGggPiAwO1xuICAgIGlmIChoYXNDaGVja3MpIHtcbiAgICAgICAgLy8gT25seSB0aHJvdyBpZiBuZXcgc2hhcGUgb3ZlcmxhcHMgd2l0aCBleGlzdGluZyBzaGFwZVxuICAgICAgICAvLyBVc2UgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHRvIGNoZWNrIGtleSBleGlzdGVuY2Ugd2l0aG91dCBhY2Nlc3NpbmcgdmFsdWVzXG4gICAgICAgIGNvbnN0IGV4aXN0aW5nU2hhcGUgPSBzY2hlbWEuX3pvZC5kZWYuc2hhcGU7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNoYXBlKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihleGlzdGluZ1NoYXBlLCBrZXkpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgb3ZlcndyaXRlIGtleXMgb24gb2JqZWN0IHNjaGVtYXMgY29udGFpbmluZyByZWZpbmVtZW50cy4gVXNlIGAuc2FmZUV4dGVuZCgpYCBpbnN0ZWFkLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IF9zaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlLCAuLi5zaGFwZSB9O1xuICAgICAgICAgICAgYXNzaWduUHJvcCh0aGlzLCBcInNoYXBlXCIsIF9zaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIF9zaGFwZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNhZmVFeHRlbmQoc2NoZW1hLCBzaGFwZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdChzaGFwZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBzYWZlRXh0ZW5kOiBleHBlY3RlZCBhIHBsYWluIG9iamVjdFwiKTtcbiAgICB9XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKHNjaGVtYS5fem9kLmRlZiwge1xuICAgICAgICBnZXQgc2hhcGUoKSB7XG4gICAgICAgICAgICBjb25zdCBfc2hhcGUgPSB7IC4uLnNjaGVtYS5fem9kLmRlZi5zaGFwZSwgLi4uc2hhcGUgfTtcbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBfc2hhcGU7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lKHNjaGVtYSwgZGVmKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZShhLCBiKSB7XG4gICAgY29uc3QgZGVmID0gbWVyZ2VEZWZzKGEuX3pvZC5kZWYsIHtcbiAgICAgICAgZ2V0IHNoYXBlKCkge1xuICAgICAgICAgICAgY29uc3QgX3NoYXBlID0geyAuLi5hLl96b2QuZGVmLnNoYXBlLCAuLi5iLl96b2QuZGVmLnNoYXBlIH07XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTsgLy8gc2VsZi1jYWNoaW5nXG4gICAgICAgICAgICByZXR1cm4gX3NoYXBlO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgY2F0Y2hhbGwoKSB7XG4gICAgICAgICAgICByZXR1cm4gYi5fem9kLmRlZi5jYXRjaGFsbDtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tzOiBbXSwgLy8gZGVsZXRlIGV4aXN0aW5nIGNoZWNrc1xuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShhLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWwoQ2xhc3MsIHNjaGVtYSwgbWFzaykge1xuICAgIGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgY2hlY2tzID0gY3VyckRlZi5jaGVja3M7XG4gICAgY29uc3QgaGFzQ2hlY2tzID0gY2hlY2tzICYmIGNoZWNrcy5sZW5ndGggPiAwO1xuICAgIGlmIChoYXNDaGVja3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiLnBhcnRpYWwoKSBjYW5ub3QgYmUgdXNlZCBvbiBvYmplY3Qgc2NoZW1hcyBjb250YWluaW5nIHJlZmluZW1lbnRzXCIpO1xuICAgIH1cbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB7IC4uLm9sZFNoYXBlIH07XG4gICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIG9sZFNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgKG9sZFNoYXBlW2tleV0hLl96b2Qub3B0aW4gPT09IFwib3B0aW9uYWxcIikgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBDbGFzc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBuZXcgQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib3B0aW9uYWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBvbGRTaGFwZVtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIChvbGRTaGFwZVtrZXldIS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBzaGFwZVtrZXldID0gQ2xhc3NcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbmV3IENsYXNzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb2xkU2hhcGVba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgc2hhcGUpOyAvLyBzZWxmLWNhY2hpbmdcbiAgICAgICAgICAgIHJldHVybiBzaGFwZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICB9KTtcbiAgICByZXR1cm4gY2xvbmUoc2NoZW1hLCBkZWYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlcXVpcmVkKENsYXNzLCBzY2hlbWEsIG1hc2spIHtcbiAgICBjb25zdCBkZWYgPSBtZXJnZURlZnMoc2NoZW1hLl96b2QuZGVmLCB7XG4gICAgICAgIGdldCBzaGFwZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgICAgICAgICAgY29uc3Qgc2hhcGUgPSB7IC4uLm9sZFNoYXBlIH07XG4gICAgICAgICAgICBpZiAobWFzaykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIHNoYXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnJlY29nbml6ZWQga2V5OiBcIiR7a2V5fVwiYCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtYXNrW2tleV0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHdpdGggbm9uLW9wdGlvbmFsXG4gICAgICAgICAgICAgICAgICAgIHNoYXBlW2tleV0gPSBuZXcgQ2xhc3Moe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvbGRTaGFwZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdmVyd3JpdGUgd2l0aCBub24tb3B0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IG5ldyBDbGFzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbm5lclR5cGU6IG9sZFNoYXBlW2tleV0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBzaGFwZSk7IC8vIHNlbGYtY2FjaGluZ1xuICAgICAgICAgICAgcmV0dXJuIHNoYXBlO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBjbG9uZShzY2hlbWEsIGRlZik7XG59XG4vLyBpbnZhbGlkX3R5cGUgfCB0b29fYmlnIHwgdG9vX3NtYWxsIHwgaW52YWxpZF9mb3JtYXQgfCBub3RfbXVsdGlwbGVfb2YgfCB1bnJlY29nbml6ZWRfa2V5cyB8IGludmFsaWRfdW5pb24gfCBpbnZhbGlkX2tleSB8IGludmFsaWRfZWxlbWVudCB8IGludmFsaWRfdmFsdWUgfCBjdXN0b21cbmV4cG9ydCBmdW5jdGlvbiBhYm9ydGVkKHgsIHN0YXJ0SW5kZXggPSAwKSB7XG4gICAgaWYgKHguYWJvcnRlZCA9PT0gdHJ1ZSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0SW5kZXg7IGkgPCB4Lmlzc3Vlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoeC5pc3N1ZXNbaV0/LmNvbnRpbnVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gcHJlZml4SXNzdWVzKHBhdGgsIGlzc3Vlcykge1xuICAgIHJldHVybiBpc3N1ZXMubWFwKChpc3MpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBpc3MpLnBhdGggPz8gKF9hLnBhdGggPSBbXSk7XG4gICAgICAgIGlzcy5wYXRoLnVuc2hpZnQocGF0aCk7XG4gICAgICAgIHJldHVybiBpc3M7XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdW53cmFwTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2U/Lm1lc3NhZ2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKSB7XG4gICAgY29uc3QgZnVsbCA9IHsgLi4uaXNzLCBwYXRoOiBpc3MucGF0aCA/PyBbXSB9O1xuICAgIC8vIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgIGlmICghaXNzLm1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHVud3JhcE1lc3NhZ2UoaXNzLmluc3Q/Ll96b2QuZGVmPy5lcnJvcj8uKGlzcykpID8/XG4gICAgICAgICAgICB1bndyYXBNZXNzYWdlKGN0eD8uZXJyb3I/Lihpc3MpKSA/P1xuICAgICAgICAgICAgdW53cmFwTWVzc2FnZShjb25maWcuY3VzdG9tRXJyb3I/Lihpc3MpKSA/P1xuICAgICAgICAgICAgdW53cmFwTWVzc2FnZShjb25maWcubG9jYWxlRXJyb3I/Lihpc3MpKSA/P1xuICAgICAgICAgICAgXCJJbnZhbGlkIGlucHV0XCI7XG4gICAgICAgIGZ1bGwubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxuICAgIC8vIGRlbGV0ZSAoZnVsbCBhcyBhbnkpLmRlZjtcbiAgICBkZWxldGUgZnVsbC5pbnN0O1xuICAgIGRlbGV0ZSBmdWxsLmNvbnRpbnVlO1xuICAgIGlmICghY3R4Py5yZXBvcnRJbnB1dCkge1xuICAgICAgICBkZWxldGUgZnVsbC5pbnB1dDtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bGw7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U2l6YWJsZU9yaWdpbihpbnB1dCkge1xuICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFNldClcbiAgICAgICAgcmV0dXJuIFwic2V0XCI7XG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgTWFwKVxuICAgICAgICByZXR1cm4gXCJtYXBcIjtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgcmV0dXJuIFwiZmlsZVwiO1xuICAgIHJldHVybiBcInVua25vd25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5wdXQpKVxuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIHJldHVybiBcInVua25vd25cIjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZWRUeXBlKGRhdGEpIHtcbiAgICBjb25zdCB0ID0gdHlwZW9mIGRhdGE7XG4gICAgc3dpdGNoICh0KSB7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjoge1xuICAgICAgICAgICAgcmV0dXJuIE51bWJlci5pc05hTihkYXRhKSA/IFwibmFuXCIgOiBcIm51bWJlclwiO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImFycmF5XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvYmogPSBkYXRhO1xuICAgICAgICAgICAgaWYgKG9iaiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKSAhPT0gT2JqZWN0LnByb3RvdHlwZSAmJiBcImNvbnN0cnVjdG9yXCIgaW4gb2JqICYmIG9iai5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmouY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc3N1ZSguLi5hcmdzKSB7XG4gICAgY29uc3QgW2lzcywgaW5wdXQsIGluc3RdID0gYXJncztcbiAgICBpZiAodHlwZW9mIGlzcyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogaXNzLFxuICAgICAgICAgICAgY29kZTogXCJjdXN0b21cIixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsgLi4uaXNzIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY2xlYW5FbnVtKG9iaikge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopXG4gICAgICAgIC5maWx0ZXIoKFtrLCBfXSkgPT4ge1xuICAgICAgICAvLyByZXR1cm4gdHJ1ZSBpZiBOYU4sIG1lYW5pbmcgaXQncyBub3QgYSBudW1iZXIsIHRodXMgYSBzdHJpbmcga2V5XG4gICAgICAgIHJldHVybiBOdW1iZXIuaXNOYU4oTnVtYmVyLnBhcnNlSW50KGssIDEwKSk7XG4gICAgfSlcbiAgICAgICAgLm1hcCgoZWwpID0+IGVsWzFdKTtcbn1cbi8vIENvZGVjIHV0aWxpdHkgZnVuY3Rpb25zXG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NCkge1xuICAgIGNvbnN0IGJpbmFyeVN0cmluZyA9IGF0b2IoYmFzZTY0KTtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJpbmFyeVN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5U3RyaW5nLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5U3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9CYXNlNjQoYnl0ZXMpIHtcbiAgICBsZXQgYmluYXJ5U3RyaW5nID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJpbmFyeVN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EoYmluYXJ5U3RyaW5nKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjR1cmxUb1VpbnQ4QXJyYXkoYmFzZTY0dXJsKSB7XG4gICAgY29uc3QgYmFzZTY0ID0gYmFzZTY0dXJsLnJlcGxhY2UoLy0vZywgXCIrXCIpLnJlcGxhY2UoL18vZywgXCIvXCIpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSBcIj1cIi5yZXBlYXQoKDQgLSAoYmFzZTY0Lmxlbmd0aCAlIDQpKSAlIDQpO1xuICAgIHJldHVybiBiYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0ICsgcGFkZGluZyk7XG59XG5leHBvcnQgZnVuY3Rpb24gdWludDhBcnJheVRvQmFzZTY0dXJsKGJ5dGVzKSB7XG4gICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0Jhc2U2NChieXRlcykucmVwbGFjZSgvXFwrL2csIFwiLVwiKS5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoLz0vZywgXCJcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4VG9VaW50OEFycmF5KGhleCkge1xuICAgIGNvbnN0IGNsZWFuSGV4ID0gaGV4LnJlcGxhY2UoL14weC8sIFwiXCIpO1xuICAgIGlmIChjbGVhbkhleC5sZW5ndGggJSAyICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaGV4IHN0cmluZyBsZW5ndGhcIik7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoY2xlYW5IZXgubGVuZ3RoIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGVhbkhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBieXRlc1tpIC8gMl0gPSBOdW1iZXIucGFyc2VJbnQoY2xlYW5IZXguc2xpY2UoaSwgaSArIDIpLCAxNik7XG4gICAgfVxuICAgIHJldHVybiBieXRlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiB1aW50OEFycmF5VG9IZXgoYnl0ZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbShieXRlcylcbiAgICAgICAgLm1hcCgoYikgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpKVxuICAgICAgICAuam9pbihcIlwiKTtcbn1cbi8vIGluc3RhbmNlb2ZcbmV4cG9ydCBjbGFzcyBDbGFzcyB7XG4gICAgY29uc3RydWN0b3IoLi4uX2FyZ3MpIHsgfVxufVxuIiwgImltcG9ydCB7ICRjb25zdHJ1Y3RvciB9IGZyb20gXCIuL2NvcmUuanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuY29uc3QgaW5pdGlhbGl6ZXIgPSAoaW5zdCwgZGVmKSA9PiB7XG4gICAgaW5zdC5uYW1lID0gXCIkWm9kRXJyb3JcIjtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfem9kXCIsIHtcbiAgICAgICAgdmFsdWU6IGluc3QuX3pvZCxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiaXNzdWVzXCIsIHtcbiAgICAgICAgdmFsdWU6IGRlZixcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgfSk7XG4gICAgaW5zdC5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoZGVmLCB1dGlsLmpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwidG9TdHJpbmdcIiwge1xuICAgICAgICB2YWx1ZTogKCkgPT4gaW5zdC5tZXNzYWdlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB9KTtcbn07XG5leHBvcnQgY29uc3QgJFpvZEVycm9yID0gJGNvbnN0cnVjdG9yKFwiJFpvZEVycm9yXCIsIGluaXRpYWxpemVyKTtcbmV4cG9ydCBjb25zdCAkWm9kUmVhbEVycm9yID0gJGNvbnN0cnVjdG9yKFwiJFpvZEVycm9yXCIsIGluaXRpYWxpemVyLCB7IFBhcmVudDogRXJyb3IgfSk7XG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbkVycm9yKGVycm9yLCBtYXBwZXIgPSAoaXNzdWUpID0+IGlzc3VlLm1lc3NhZ2UpIHtcbiAgICBjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuICAgIGNvbnN0IGZvcm1FcnJvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHN1YiBvZiBlcnJvci5pc3N1ZXMpIHtcbiAgICAgICAgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSA9IGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXSB8fCBbXTtcbiAgICAgICAgICAgIGZpZWxkRXJyb3JzW3N1Yi5wYXRoWzBdXS5wdXNoKG1hcHBlcihzdWIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1FcnJvcnMucHVzaChtYXBwZXIoc3ViKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZm9ybUVycm9ycywgZmllbGRFcnJvcnMgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvciwgbWFwcGVyID0gKGlzc3VlKSA9PiBpc3N1ZS5tZXNzYWdlKSB7XG4gICAgY29uc3QgZmllbGRFcnJvcnMgPSB7IF9lcnJvcnM6IFtdIH07XG4gICAgY29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIgJiYgaXNzdWUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlzc3VlLmVycm9ycy5tYXAoKGlzc3VlcykgPT4gcHJvY2Vzc0Vycm9yKHsgaXNzdWVzIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9rZXlcIikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUuaXNzdWVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX2VsZW1lbnRcIikge1xuICAgICAgICAgICAgICAgIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUuaXNzdWVzIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNzdWUucGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBmaWVsZEVycm9ycy5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VyciA9IGZpZWxkRXJyb3JzO1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA8IGlzc3VlLnBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gaXNzdWUucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVybWluYWwgPSBpID09PSBpc3N1ZS5wYXRoLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJbZWxdID0gY3VycltlbF0gfHwgeyBfZXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyW2VsXS5fZXJyb3JzLnB1c2gobWFwcGVyKGlzc3VlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnJbZWxdO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBwcm9jZXNzRXJyb3IoZXJyb3IpO1xuICAgIHJldHVybiBmaWVsZEVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiB0cmVlaWZ5RXJyb3IoZXJyb3IsIG1hcHBlciA9IChpc3N1ZSkgPT4gaXNzdWUubWVzc2FnZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgZXJyb3JzOiBbXSB9O1xuICAgIGNvbnN0IHByb2Nlc3NFcnJvciA9IChlcnJvciwgcGF0aCA9IFtdKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGZvciAoY29uc3QgaXNzdWUgb2YgZXJyb3IuaXNzdWVzKSB7XG4gICAgICAgICAgICBpZiAoaXNzdWUuY29kZSA9PT0gXCJpbnZhbGlkX3VuaW9uXCIgJiYgaXNzdWUuZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIHJlZ3VsYXIgdW5pb24gZXJyb3JcbiAgICAgICAgICAgICAgICBpc3N1ZS5lcnJvcnMubWFwKChpc3N1ZXMpID0+IHByb2Nlc3NFcnJvcih7IGlzc3VlcyB9LCBpc3N1ZS5wYXRoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc3N1ZS5jb2RlID09PSBcImludmFsaWRfa2V5XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlLmlzc3VlcyB9LCBpc3N1ZS5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzc3VlLmNvZGUgPT09IFwiaW52YWxpZF9lbGVtZW50XCIpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlLmlzc3VlcyB9LCBpc3N1ZS5wYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxwYXRoID0gWy4uLnBhdGgsIC4uLmlzc3VlLnBhdGhdO1xuICAgICAgICAgICAgICAgIGlmIChmdWxscGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmVycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGN1cnIgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpIDwgZnVsbHBhdGgubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsID0gZnVsbHBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlcm1pbmFsID0gaSA9PT0gZnVsbHBhdGgubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyci5wcm9wZXJ0aWVzID8/IChjdXJyLnByb3BlcnRpZXMgPSB7fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBjdXJyLnByb3BlcnRpZXMpW2VsXSA/PyAoX2FbZWxdID0geyBlcnJvcnM6IFtdIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyciA9IGN1cnIucHJvcGVydGllc1tlbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyLml0ZW1zID8/IChjdXJyLml0ZW1zID0gW10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gY3Vyci5pdGVtcylbZWxdID8/IChfYltlbF0gPSB7IGVycm9yczogW10gfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyID0gY3Vyci5pdGVtc1tlbF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyLmVycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHByb2Nlc3NFcnJvcihlcnJvcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKiBGb3JtYXQgYSBab2RFcnJvciBhcyBhIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBpbiB0aGUgZm9sbG93aW5nIGZvcm0uXG4gKlxuICogRnJvbVxuICpcbiAqIGBgYHRzXG4gKiBab2RFcnJvciB7XG4gKiAgIGlzc3VlczogW1xuICogICAgIHtcbiAqICAgICAgIGV4cGVjdGVkOiAnc3RyaW5nJyxcbiAqICAgICAgIGNvZGU6ICdpbnZhbGlkX3R5cGUnLFxuICogICAgICAgcGF0aDogWyAndXNlcm5hbWUnIF0sXG4gKiAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dDogZXhwZWN0ZWQgc3RyaW5nJ1xuICogICAgIH0sXG4gKiAgICAge1xuICogICAgICAgZXhwZWN0ZWQ6ICdudW1iZXInLFxuICogICAgICAgY29kZTogJ2ludmFsaWRfdHlwZScsXG4gKiAgICAgICBwYXRoOiBbICdmYXZvcml0ZU51bWJlcnMnLCAxIF0sXG4gKiAgICAgICBtZXNzYWdlOiAnSW52YWxpZCBpbnB1dDogZXhwZWN0ZWQgbnVtYmVyJ1xuICogICAgIH1cbiAqICAgXTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIHRvXG4gKlxuICogYGBgXG4gKiB1c2VybmFtZVxuICogICBcdTI3MTYgRXhwZWN0ZWQgbnVtYmVyLCByZWNlaXZlZCBzdHJpbmcgYXQgXCJ1c2VybmFtZVxuICogZmF2b3JpdGVOdW1iZXJzWzBdXG4gKiAgIFx1MjcxNiBJbnZhbGlkIGlucHV0OiBleHBlY3RlZCBudW1iZXJcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9Eb3RQYXRoKF9wYXRoKSB7XG4gICAgY29uc3Qgc2VncyA9IFtdO1xuICAgIGNvbnN0IHBhdGggPSBfcGF0aC5tYXAoKHNlZykgPT4gKHR5cGVvZiBzZWcgPT09IFwib2JqZWN0XCIgPyBzZWcua2V5IDogc2VnKSk7XG4gICAgZm9yIChjb25zdCBzZWcgb2YgcGF0aCkge1xuICAgICAgICBpZiAodHlwZW9mIHNlZyA9PT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHNlZ3MucHVzaChgWyR7c2VnfV1gKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNlZyA9PT0gXCJzeW1ib2xcIilcbiAgICAgICAgICAgIHNlZ3MucHVzaChgWyR7SlNPTi5zdHJpbmdpZnkoU3RyaW5nKHNlZykpfV1gKTtcbiAgICAgICAgZWxzZSBpZiAoL1teXFx3JF0vLnRlc3Qoc2VnKSlcbiAgICAgICAgICAgIHNlZ3MucHVzaChgWyR7SlNPTi5zdHJpbmdpZnkoc2VnKX1dYCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHNlZ3MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHNlZ3MucHVzaChcIi5cIik7XG4gICAgICAgICAgICBzZWdzLnB1c2goc2VnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2Vncy5qb2luKFwiXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByZXR0aWZ5RXJyb3IoZXJyb3IpIHtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIC8vIHNvcnQgYnkgcGF0aCBsZW5ndGhcbiAgICBjb25zdCBpc3N1ZXMgPSBbLi4uZXJyb3IuaXNzdWVzXS5zb3J0KChhLCBiKSA9PiAoYS5wYXRoID8/IFtdKS5sZW5ndGggLSAoYi5wYXRoID8/IFtdKS5sZW5ndGgpO1xuICAgIC8vIFByb2Nlc3MgZWFjaCBpc3N1ZVxuICAgIGZvciAoY29uc3QgaXNzdWUgb2YgaXNzdWVzKSB7XG4gICAgICAgIGxpbmVzLnB1c2goYFx1MjcxNiAke2lzc3VlLm1lc3NhZ2V9YCk7XG4gICAgICAgIGlmIChpc3N1ZS5wYXRoPy5sZW5ndGgpXG4gICAgICAgICAgICBsaW5lcy5wdXNoKGAgIFx1MjE5MiBhdCAke3RvRG90UGF0aChpc3N1ZS5wYXRoKX1gKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCBNYXAgdG8gZm9ybWF0dGVkIHN0cmluZ1xuICAgIHJldHVybiBsaW5lcy5qb2luKFwiXFxuXCIpO1xufVxuIiwgImltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4vY29yZS5qc1wiO1xuaW1wb3J0ICogYXMgZXJyb3JzIGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tIFwiLi91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgX3BhcnNlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4LCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogZmFsc2UgfSkgOiB7IGFzeW5jOiBmYWxzZSB9O1xuICAgIGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7IHZhbHVlLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEFzeW5jRXJyb3IoKTtcbiAgICB9XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgKF9wYXJhbXM/LkVyciA/PyBfRXJyKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSk7XG4gICAgICAgIHV0aWwuY2FwdHVyZVN0YWNrVHJhY2UoZSwgX3BhcmFtcz8uY2FsbGVlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG5leHBvcnQgY29uc3QgcGFyc2UgPSAvKiBAX19QVVJFX18qLyBfcGFyc2UoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9wYXJzZUFzeW5jID0gKF9FcnIpID0+IGFzeW5jIChzY2hlbWEsIHZhbHVlLCBfY3R4LCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiB0cnVlIH0pIDogeyBhc3luYzogdHJ1ZSB9O1xuICAgIGxldCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICByZXN1bHQgPSBhd2FpdCByZXN1bHQ7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgKHBhcmFtcz8uRXJyID8/IF9FcnIpKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKTtcbiAgICAgICAgdXRpbC5jYXB0dXJlU3RhY2tUcmFjZShlLCBwYXJhbXM/LmNhbGxlZSk7XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQudmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfcGFyc2VBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVQYXJzZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyB7IC4uLl9jdHgsIGFzeW5jOiBmYWxzZSB9IDogeyBhc3luYzogZmFsc2UgfTtcbiAgICBjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQuaXNzdWVzLmxlbmd0aFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IG5ldyAoX0VyciA/PyBlcnJvcnMuJFpvZEVycm9yKShyZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSksXG4gICAgICAgIH1cbiAgICAgICAgOiB7IHN1Y2Nlc3M6IHRydWUsIGRhdGE6IHJlc3VsdC52YWx1ZSB9O1xufTtcbmV4cG9ydCBjb25zdCBzYWZlUGFyc2UgPSAvKiBAX19QVVJFX18qLyBfc2FmZVBhcnNlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZVBhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGFzeW5jOiB0cnVlIH0pIDogeyBhc3luYzogdHJ1ZSB9O1xuICAgIGxldCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oeyB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKVxuICAgICAgICByZXN1bHQgPSBhd2FpdCByZXN1bHQ7XG4gICAgcmV0dXJuIHJlc3VsdC5pc3N1ZXMubGVuZ3RoXG4gICAgICAgID8ge1xuICAgICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgICBlcnJvcjogbmV3IF9FcnIocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSkpLFxuICAgICAgICB9XG4gICAgICAgIDogeyBzdWNjZXNzOiB0cnVlLCBkYXRhOiByZXN1bHQudmFsdWUgfTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZVBhcnNlQXN5bmMgPSAvKiBAX19QVVJFX18qLyBfc2FmZVBhcnNlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9lbmNvZGUgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH0pIDogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9O1xuICAgIHJldHVybiBfcGFyc2UoX0Vycikoc2NoZW1hLCB2YWx1ZSwgY3R4KTtcbn07XG5leHBvcnQgY29uc3QgZW5jb2RlID0gLyogQF9fUFVSRV9fKi8gX2VuY29kZShlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX2RlY29kZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIHJldHVybiBfcGFyc2UoX0Vycikoc2NoZW1hLCB2YWx1ZSwgX2N0eCk7XG59O1xuZXhwb3J0IGNvbnN0IGRlY29kZSA9IC8qIEBfX1BVUkVfXyovIF9kZWNvZGUoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9lbmNvZGVBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfSkgOiB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH07XG4gICAgcmV0dXJuIF9wYXJzZUFzeW5jKF9FcnIpKHNjaGVtYSwgdmFsdWUsIGN0eCk7XG59O1xuZXhwb3J0IGNvbnN0IGVuY29kZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX2VuY29kZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfZGVjb2RlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICByZXR1cm4gX3BhcnNlQXN5bmMoX0Vycikoc2NoZW1hLCB2YWx1ZSwgX2N0eCk7XG59O1xuZXhwb3J0IGNvbnN0IGRlY29kZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX2RlY29kZUFzeW5jKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZUVuY29kZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgZGlyZWN0aW9uOiBcImJhY2t3YXJkXCIgfSkgOiB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH07XG4gICAgcmV0dXJuIF9zYWZlUGFyc2UoX0Vycikoc2NoZW1hLCB2YWx1ZSwgY3R4KTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZUVuY29kZSA9IC8qIEBfX1BVUkVfXyovIF9zYWZlRW5jb2RlKGVycm9ycy4kWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBfc2FmZURlY29kZSA9IChfRXJyKSA9PiAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIHJldHVybiBfc2FmZVBhcnNlKF9FcnIpKHNjaGVtYSwgdmFsdWUsIF9jdHgpO1xufTtcbmV4cG9ydCBjb25zdCBzYWZlRGVjb2RlID0gLyogQF9fUFVSRV9fKi8gX3NhZmVEZWNvZGUoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IF9zYWZlRW5jb2RlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcbiAgICBjb25zdCBjdHggPSBfY3R4ID8gT2JqZWN0LmFzc2lnbihfY3R4LCB7IGRpcmVjdGlvbjogXCJiYWNrd2FyZFwiIH0pIDogeyBkaXJlY3Rpb246IFwiYmFja3dhcmRcIiB9O1xuICAgIHJldHVybiBfc2FmZVBhcnNlQXN5bmMoX0Vycikoc2NoZW1hLCB2YWx1ZSwgY3R4KTtcbn07XG5leHBvcnQgY29uc3Qgc2FmZUVuY29kZUFzeW5jID0gLyogQF9fUFVSRV9fKi8gX3NhZmVFbmNvZGVBc3luYyhlcnJvcnMuJFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgX3NhZmVEZWNvZGVBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCkgPT4ge1xuICAgIHJldHVybiBfc2FmZVBhcnNlQXN5bmMoX0Vycikoc2NoZW1hLCB2YWx1ZSwgX2N0eCk7XG59O1xuZXhwb3J0IGNvbnN0IHNhZmVEZWNvZGVBc3luYyA9IC8qIEBfX1BVUkVfXyovIF9zYWZlRGVjb2RlQXN5bmMoZXJyb3JzLiRab2RSZWFsRXJyb3IpO1xuIiwgImltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0IGN1aWQgPSAvXltjQ11bXlxccy1dezgsfSQvO1xuZXhwb3J0IGNvbnN0IGN1aWQyID0gL15bMC05YS16XSskLztcbmV4cG9ydCBjb25zdCB1bGlkID0gL15bMC05QS1ISktNTlAtVFYtWmEtaGprbW5wLXR2LXpdezI2fSQvO1xuZXhwb3J0IGNvbnN0IHhpZCA9IC9eWzAtOWEtdkEtVl17MjB9JC87XG5leHBvcnQgY29uc3Qga3N1aWQgPSAvXltBLVphLXowLTldezI3fSQvO1xuZXhwb3J0IGNvbnN0IG5hbm9pZCA9IC9eW2EtekEtWjAtOV8tXXsyMX0kLztcbi8qKiBJU08gODYwMS0xIGR1cmF0aW9uIHJlZ2V4LiBEb2VzIG5vdCBzdXBwb3J0IHRoZSA4NjAxLTIgZXh0ZW5zaW9ucyBsaWtlIG5lZ2F0aXZlIGR1cmF0aW9ucyBvciBmcmFjdGlvbmFsL25lZ2F0aXZlIGNvbXBvbmVudHMuICovXG5leHBvcnQgY29uc3QgZHVyYXRpb24gPSAvXlAoPzooXFxkK1cpfCg/IS4qVykoPz1cXGR8VFxcZCkoXFxkK1kpPyhcXGQrTSk/KFxcZCtEKT8oVCg/PVxcZCkoXFxkK0gpPyhcXGQrTSk/KFxcZCsoWy4sXVxcZCspP1MpPyk/KSQvO1xuLyoqIEltcGxlbWVudHMgSVNPIDg2MDEtMiBleHRlbnNpb25zIGxpa2UgZXhwbGljaXQgKy0gcHJlZml4ZXMsIG1peGluZyB3ZWVrcyB3aXRoIG90aGVyIHVuaXRzLCBhbmQgZnJhY3Rpb25hbC9uZWdhdGl2ZSBjb21wb25lbnRzLiAqL1xuZXhwb3J0IGNvbnN0IGV4dGVuZGVkRHVyYXRpb24gPSAvXlstK10/UCg/ISQpKD86KD86Wy0rXT9cXGQrWSl8KD86Wy0rXT9cXGQrWy4sXVxcZCtZJCkpPyg/Oig/OlstK10/XFxkK00pfCg/OlstK10/XFxkK1suLF1cXGQrTSQpKT8oPzooPzpbLStdP1xcZCtXKXwoPzpbLStdP1xcZCtbLixdXFxkK1ckKSk/KD86KD86Wy0rXT9cXGQrRCl8KD86Wy0rXT9cXGQrWy4sXVxcZCtEJCkpPyg/OlQoPz1bXFxkKy1dKSg/Oig/OlstK10/XFxkK0gpfCg/OlstK10/XFxkK1suLF1cXGQrSCQpKT8oPzooPzpbLStdP1xcZCtNKXwoPzpbLStdP1xcZCtbLixdXFxkK00kKSk/KD86Wy0rXT9cXGQrKD86Wy4sXVxcZCspP1MpPyk/PyQvO1xuLyoqIEEgcmVnZXggZm9yIGFueSBVVUlELWxpa2UgaWRlbnRpZmllcjogOC00LTQtNC0xMiBoZXggcGF0dGVybiAqL1xuZXhwb3J0IGNvbnN0IGd1aWQgPSAvXihbMC05YS1mQS1GXXs4fS1bMC05YS1mQS1GXXs0fS1bMC05YS1mQS1GXXs0fS1bMC05YS1mQS1GXXs0fS1bMC05YS1mQS1GXXsxMn0pJC87XG4vKiogUmV0dXJucyBhIHJlZ2V4IGZvciB2YWxpZGF0aW5nIGFuIFJGQyA5NTYyLzQxMjIgVVVJRC5cbiAqXG4gKiBAcGFyYW0gdmVyc2lvbiBPcHRpb25hbGx5IHNwZWNpZnkgYSB2ZXJzaW9uIDEtOC4gSWYgbm8gdmVyc2lvbiBpcyBzcGVjaWZpZWQsIGFsbCB2ZXJzaW9ucyBhcmUgc3VwcG9ydGVkLiAqL1xuZXhwb3J0IGNvbnN0IHV1aWQgPSAodmVyc2lvbikgPT4ge1xuICAgIGlmICghdmVyc2lvbilcbiAgICAgICAgcmV0dXJuIC9eKFswLTlhLWZBLUZdezh9LVswLTlhLWZBLUZdezR9LVsxLThdWzAtOWEtZkEtRl17M30tWzg5YWJBQl1bMC05YS1mQS1GXXszfS1bMC05YS1mQS1GXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwfGZmZmZmZmZmLWZmZmYtZmZmZi1mZmZmLWZmZmZmZmZmZmZmZikkLztcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXihbMC05YS1mQS1GXXs4fS1bMC05YS1mQS1GXXs0fS0ke3ZlcnNpb259WzAtOWEtZkEtRl17M30tWzg5YWJBQl1bMC05YS1mQS1GXXszfS1bMC05YS1mQS1GXXsxMn0pJGApO1xufTtcbmV4cG9ydCBjb25zdCB1dWlkNCA9IC8qQF9fUFVSRV9fKi8gdXVpZCg0KTtcbmV4cG9ydCBjb25zdCB1dWlkNiA9IC8qQF9fUFVSRV9fKi8gdXVpZCg2KTtcbmV4cG9ydCBjb25zdCB1dWlkNyA9IC8qQF9fUFVSRV9fKi8gdXVpZCg3KTtcbi8qKiBQcmFjdGljYWwgZW1haWwgdmFsaWRhdGlvbiAqL1xuZXhwb3J0IGNvbnN0IGVtYWlsID0gL14oPyFcXC4pKD8hLipcXC5cXC4pKFtBLVphLXowLTlfJytcXC1cXC5dKilbQS1aYS16MC05XystXUAoW0EtWmEtejAtOV1bQS1aYS16MC05XFwtXSpcXC4pK1tBLVphLXpdezIsfSQvO1xuLyoqIEVxdWl2YWxlbnQgdG8gdGhlIEhUTUw1IGlucHV0W3R5cGU9ZW1haWxdIHZhbGlkYXRpb24gaW1wbGVtZW50ZWQgYnkgYnJvd3NlcnMuIFNvdXJjZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0L2VtYWlsICovXG5leHBvcnQgY29uc3QgaHRtbDVFbWFpbCA9IC9eW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8qKiBUaGUgY2xhc3NpYyBlbWFpbHJlZ2V4LmNvbSByZWdleCBmb3IgUkZDIDUzMjItY29tcGxpYW50IGVtYWlscyAqL1xuZXhwb3J0IGNvbnN0IHJmYzUzMjJFbWFpbCA9IC9eKChbXjw+KClcXFtcXF1cXFxcLiw7Olxcc0BcIl0rKFxcLltePD4oKVxcW1xcXVxcXFwuLDs6XFxzQFwiXSspKil8KFwiLitcIikpQCgoXFxbWzAtOV17MSwzfVxcLlswLTldezEsM31cXC5bMC05XXsxLDN9XFwuWzAtOV17MSwzfV0pfCgoW2EtekEtWlxcLTAtOV0rXFwuKStbYS16QS1aXXsyLH0pKSQvO1xuLyoqIEEgbG9vc2UgcmVnZXggdGhhdCBhbGxvd3MgVW5pY29kZSBjaGFyYWN0ZXJzLCBlbmZvcmNlcyBsZW5ndGggbGltaXRzLCBhbmQgdGhhdCdzIGFib3V0IGl0LiAqL1xuZXhwb3J0IGNvbnN0IHVuaWNvZGVFbWFpbCA9IC9eW15cXHNAXCJdezEsNjR9QFteXFxzQF17MSwyNTV9JC91O1xuZXhwb3J0IGNvbnN0IGlkbkVtYWlsID0gdW5pY29kZUVtYWlsO1xuZXhwb3J0IGNvbnN0IGJyb3dzZXJFbWFpbCA9IC9eW2EtekEtWjAtOS4hIyQlJicqKy89P15fYHt8fX4tXStAW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSokLztcbi8vIGZyb20gaHR0cHM6Ly90aGVrZXZpbnNjb3R0LmNvbS9lbW9qaXMtaW4tamF2YXNjcmlwdC8jd3JpdGluZy1hLXJlZ3VsYXItZXhwcmVzc2lvblxuY29uc3QgX2Vtb2ppID0gYF4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskYDtcbmV4cG9ydCBmdW5jdGlvbiBlbW9qaSgpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChfZW1vamksIFwidVwiKTtcbn1cbmV4cG9ydCBjb25zdCBpcHY0ID0gL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLztcbmV4cG9ydCBjb25zdCBpcHY2ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KSkkLztcbmV4cG9ydCBjb25zdCBtYWMgPSAoZGVsaW1pdGVyKSA9PiB7XG4gICAgY29uc3QgZXNjYXBlZERlbGltID0gdXRpbC5lc2NhcGVSZWdleChkZWxpbWl0ZXIgPz8gXCI6XCIpO1xuICAgIHJldHVybiBuZXcgUmVnRXhwKGBeKD86WzAtOUEtRl17Mn0ke2VzY2FwZWREZWxpbX0pezV9WzAtOUEtRl17Mn0kfF4oPzpbMC05YS1mXXsyfSR7ZXNjYXBlZERlbGltfSl7NX1bMC05YS1mXXsyfSRgKTtcbn07XG5leHBvcnQgY29uc3QgY2lkcnY0ID0gL14oKDI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC4pezN9KDI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oWzAtOV18WzEtMl1bMC05XXwzWzAtMl0pJC87XG5leHBvcnQgY29uc3QgY2lkcnY2ID0gL14oKFswLTlhLWZBLUZdezEsNH06KXs3fVswLTlhLWZBLUZdezEsNH18Ojp8KFswLTlhLWZBLUZdezEsNH0pPzo6KFswLTlhLWZBLUZdezEsNH06Pyl7MCw2fSlcXC8oMTJbMC04XXwxWzAxXVswLTldfFsxLTldP1swLTldKSQvO1xuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzg2MDM5Mi9kZXRlcm1pbmUtaWYtc3RyaW5nLWlzLWluLWJhc2U2NC11c2luZy1qYXZhc2NyaXB0XG5leHBvcnQgY29uc3QgYmFzZTY0ID0gL14kfF4oPzpbMC05YS16QS1aKy9dezR9KSooPzooPzpbMC05YS16QS1aKy9dezJ9PT0pfCg/OlswLTlhLXpBLVorL117M309KSk/JC87XG5leHBvcnQgY29uc3QgYmFzZTY0dXJsID0gL15bQS1aYS16MC05Xy1dKiQvO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTA2MTc5L3JlZ3VsYXItZXhwcmVzc2lvbi10by1tYXRjaC1kbnMtaG9zdG5hbWUtb3ItaXAtYWRkcmVzc1xuLy8gZXhwb3J0IGNvbnN0IGhvc3RuYW1lOiBSZWdFeHAgPSAvXihbYS16QS1aMC05LV0rXFwuKSpbYS16QS1aMC05LV0rJC87XG5leHBvcnQgY29uc3QgaG9zdG5hbWUgPSAvXig/PS57MSwyNTN9XFwuPyQpW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KD86XFwuW2EtekEtWjAtOV0oPzpbLTAtOWEtekEtWl17MCw2MX1bMC05YS16QS1aXSk/KSpcXC4/JC87XG5leHBvcnQgY29uc3QgZG9tYWluID0gL14oW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/XFwuKStbYS16QS1aXXsyLH0kLztcbi8vIGh0dHBzOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvdmFsaWRhdGUtcGhvbmUtbnVtYmVyI3I0LTMgKHJlZ2V4IHNhbnMgc3BhY2VzKVxuLy8gRS4xNjQ6IGxlYWRpbmcgZGlnaXQgbXVzdCBiZSAxLTk7IHRvdGFsIGRpZ2l0cyAoZXhjbHVkaW5nICcrJykgYmV0d2VlbiA3LTE1XG5leHBvcnQgY29uc3QgZTE2NCA9IC9eXFwrWzEtOV1cXGR7NiwxNH0kLztcbi8vIGNvbnN0IGRhdGVTb3VyY2UgPSBgKChcXFxcZFxcXFxkWzI0NjhdWzA0OF18XFxcXGRcXFxcZFsxMzU3OV1bMjZdfFxcXFxkXFxcXGQwWzQ4XXxbMDI0NjhdWzA0OF0wMHxbMTM1NzldWzI2XTAwKS0wMi0yOXxcXFxcZHs0fS0oKDBbMTM1NzhdfDFbMDJdKS0oMFsxLTldfFsxMl1cXFxcZHwzWzAxXSl8KDBbNDY5XXwxMSktKDBbMS05XXxbMTJdXFxcXGR8MzApfCgwMiktKDBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmNvbnN0IGRhdGVTb3VyY2UgPSBgKD86KD86XFxcXGRcXFxcZFsyNDY4XVswNDhdfFxcXFxkXFxcXGRbMTM1NzldWzI2XXxcXFxcZFxcXFxkMFs0OF18WzAyNDY4XVswNDhdMDB8WzEzNTc5XVsyNl0wMCktMDItMjl8XFxcXGR7NH0tKD86KD86MFsxMzU3OF18MVswMl0pLSg/OjBbMS05XXxbMTJdXFxcXGR8M1swMV0pfCg/OjBbNDY5XXwxMSktKD86MFsxLTldfFsxMl1cXFxcZHwzMCl8KD86MDIpLSg/OjBbMS05XXwxXFxcXGR8MlswLThdKSkpYDtcbmV4cG9ydCBjb25zdCBkYXRlID0gLypAX19QVVJFX18qLyBuZXcgUmVnRXhwKGBeJHtkYXRlU291cmNlfSRgKTtcbmZ1bmN0aW9uIHRpbWVTb3VyY2UoYXJncykge1xuICAgIGNvbnN0IGhobW0gPSBgKD86WzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZGA7XG4gICAgY29uc3QgcmVnZXggPSB0eXBlb2YgYXJncy5wcmVjaXNpb24gPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyBhcmdzLnByZWNpc2lvbiA9PT0gLTFcbiAgICAgICAgICAgID8gYCR7aGhtbX1gXG4gICAgICAgICAgICA6IGFyZ3MucHJlY2lzaW9uID09PSAwXG4gICAgICAgICAgICAgICAgPyBgJHtoaG1tfTpbMC01XVxcXFxkYFxuICAgICAgICAgICAgICAgIDogYCR7aGhtbX06WzAtNV1cXFxcZFxcXFwuXFxcXGR7JHthcmdzLnByZWNpc2lvbn19YFxuICAgICAgICA6IGAke2hobW19KD86OlswLTVdXFxcXGQoPzpcXFxcLlxcXFxkKyk/KT9gO1xuICAgIHJldHVybiByZWdleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0aW1lKGFyZ3MpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7dGltZVNvdXJjZShhcmdzKX0kYCk7XG59XG4vLyBBZGFwdGVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzMxNDMyMzFcbmV4cG9ydCBmdW5jdGlvbiBkYXRldGltZShhcmdzKSB7XG4gICAgY29uc3QgdGltZSA9IHRpbWVTb3VyY2UoeyBwcmVjaXNpb246IGFyZ3MucHJlY2lzaW9uIH0pO1xuICAgIGNvbnN0IG9wdHMgPSBbXCJaXCJdO1xuICAgIGlmIChhcmdzLmxvY2FsKVxuICAgICAgICBvcHRzLnB1c2goXCJcIik7XG4gICAgLy8gaWYgKGFyZ3Mub2Zmc2V0KSBvcHRzLnB1c2goYChbKy1dXFxcXGR7Mn06XFxcXGR7Mn0pYCk7XG4gICAgaWYgKGFyZ3Mub2Zmc2V0KVxuICAgICAgICBvcHRzLnB1c2goYChbKy1dKD86WzAxXVxcXFxkfDJbMC0zXSk6WzAtNV1cXFxcZClgKTtcbiAgICBjb25zdCB0aW1lUmVnZXggPSBgJHt0aW1lfSg/OiR7b3B0cy5qb2luKFwifFwiKX0pYDtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7ZGF0ZVNvdXJjZX1UKD86JHt0aW1lUmVnZXh9KSRgKTtcbn1cbmV4cG9ydCBjb25zdCBzdHJpbmcgPSAocGFyYW1zKSA9PiB7XG4gICAgY29uc3QgcmVnZXggPSBwYXJhbXMgPyBgW1xcXFxzXFxcXFNdeyR7cGFyYW1zPy5taW5pbXVtID8/IDB9LCR7cGFyYW1zPy5tYXhpbXVtID8/IFwiXCJ9fWAgOiBgW1xcXFxzXFxcXFNdKmA7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke3JlZ2V4fSRgKTtcbn07XG5leHBvcnQgY29uc3QgYmlnaW50ID0gL14tP1xcZCtuPyQvO1xuZXhwb3J0IGNvbnN0IGludGVnZXIgPSAvXi0/XFxkKyQvO1xuZXhwb3J0IGNvbnN0IG51bWJlciA9IC9eLT9cXGQrKD86XFwuXFxkKyk/JC87XG5leHBvcnQgY29uc3QgYm9vbGVhbiA9IC9eKD86dHJ1ZXxmYWxzZSkkL2k7XG5jb25zdCBfbnVsbCA9IC9ebnVsbCQvaTtcbmV4cG9ydCB7IF9udWxsIGFzIG51bGwgfTtcbmNvbnN0IF91bmRlZmluZWQgPSAvXnVuZGVmaW5lZCQvaTtcbmV4cG9ydCB7IF91bmRlZmluZWQgYXMgdW5kZWZpbmVkIH07XG4vLyByZWdleCBmb3Igc3RyaW5nIHdpdGggbm8gdXBwZXJjYXNlIGxldHRlcnNcbmV4cG9ydCBjb25zdCBsb3dlcmNhc2UgPSAvXlteQS1aXSokLztcbi8vIHJlZ2V4IGZvciBzdHJpbmcgd2l0aCBubyBsb3dlcmNhc2UgbGV0dGVyc1xuZXhwb3J0IGNvbnN0IHVwcGVyY2FzZSA9IC9eW15hLXpdKiQvO1xuLy8gcmVnZXggZm9yIGhleGFkZWNpbWFsIHN0cmluZ3MgKGFueSBsZW5ndGgpXG5leHBvcnQgY29uc3QgaGV4ID0gL15bMC05YS1mQS1GXSokLztcbi8vIEhhc2ggcmVnZXhlcyBmb3IgZGlmZmVyZW50IGFsZ29yaXRobXMgYW5kIGVuY29kaW5nc1xuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBiYXNlNjQgcmVnZXggd2l0aCBleGFjdCBsZW5ndGggYW5kIHBhZGRpbmdcbmZ1bmN0aW9uIGZpeGVkQmFzZTY0KGJvZHlMZW5ndGgsIHBhZGRpbmcpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXltBLVphLXowLTkrL117JHtib2R5TGVuZ3RofX0ke3BhZGRpbmd9JGApO1xufVxuLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBiYXNlNjR1cmwgcmVnZXggd2l0aCBleGFjdCBsZW5ndGggKG5vIHBhZGRpbmcpXG5mdW5jdGlvbiBmaXhlZEJhc2U2NHVybChsZW5ndGgpIHtcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgXltBLVphLXowLTlfLV17JHtsZW5ndGh9fSRgKTtcbn1cbi8vIE1ENSAoMTYgYnl0ZXMpOiBiYXNlNjQgPSAyNCBjaGFycyB0b3RhbCAoMjIgKyBcIj09XCIpXG5leHBvcnQgY29uc3QgbWQ1X2hleCA9IC9eWzAtOWEtZkEtRl17MzJ9JC87XG5leHBvcnQgY29uc3QgbWQ1X2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoMjIsIFwiPT1cIik7XG5leHBvcnQgY29uc3QgbWQ1X2Jhc2U2NHVybCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjR1cmwoMjIpO1xuLy8gU0hBMSAoMjAgYnl0ZXMpOiBiYXNlNjQgPSAyOCBjaGFycyB0b3RhbCAoMjcgKyBcIj1cIilcbmV4cG9ydCBjb25zdCBzaGExX2hleCA9IC9eWzAtOWEtZkEtRl17NDB9JC87XG5leHBvcnQgY29uc3Qgc2hhMV9iYXNlNjQgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0KDI3LCBcIj1cIik7XG5leHBvcnQgY29uc3Qgc2hhMV9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDI3KTtcbi8vIFNIQTI1NiAoMzIgYnl0ZXMpOiBiYXNlNjQgPSA0NCBjaGFycyB0b3RhbCAoNDMgKyBcIj1cIilcbmV4cG9ydCBjb25zdCBzaGEyNTZfaGV4ID0gL15bMC05YS1mQS1GXXs2NH0kLztcbmV4cG9ydCBjb25zdCBzaGEyNTZfYmFzZTY0ID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NCg0MywgXCI9XCIpO1xuZXhwb3J0IGNvbnN0IHNoYTI1Nl9iYXNlNjR1cmwgPSAvKkBfX1BVUkVfXyovIGZpeGVkQmFzZTY0dXJsKDQzKTtcbi8vIFNIQTM4NCAoNDggYnl0ZXMpOiBiYXNlNjQgPSA2NCBjaGFycyB0b3RhbCAobm8gcGFkZGluZylcbmV4cG9ydCBjb25zdCBzaGEzODRfaGV4ID0gL15bMC05YS1mQS1GXXs5Nn0kLztcbmV4cG9ydCBjb25zdCBzaGEzODRfYmFzZTY0ID0gLypAX19QVVJFX18qLyBmaXhlZEJhc2U2NCg2NCwgXCJcIik7XG5leHBvcnQgY29uc3Qgc2hhMzg0X2Jhc2U2NHVybCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjR1cmwoNjQpO1xuLy8gU0hBNTEyICg2NCBieXRlcyk6IGJhc2U2NCA9IDg4IGNoYXJzIHRvdGFsICg4NiArIFwiPT1cIilcbmV4cG9ydCBjb25zdCBzaGE1MTJfaGV4ID0gL15bMC05YS1mQS1GXXsxMjh9JC87XG5leHBvcnQgY29uc3Qgc2hhNTEyX2Jhc2U2NCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjQoODYsIFwiPT1cIik7XG5leHBvcnQgY29uc3Qgc2hhNTEyX2Jhc2U2NHVybCA9IC8qQF9fUFVSRV9fKi8gZml4ZWRCYXNlNjR1cmwoODYpO1xuIiwgIi8vIGltcG9ydCB7ICRab2RUeXBlIH0gZnJvbSBcIi4vc2NoZW1hcy5qc1wiO1xuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi9jb3JlLmpzXCI7XG5pbXBvcnQgKiBhcyByZWdleGVzIGZyb20gXCIuL3JlZ2V4ZXMuanNcIjtcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4vdXRpbC5qc1wiO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVjayA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICBpbnN0Ll96b2QgPz8gKGluc3QuX3pvZCA9IHt9KTtcbiAgICBpbnN0Ll96b2QuZGVmID0gZGVmO1xuICAgIChfYSA9IGluc3QuX3pvZCkub25hdHRhY2ggPz8gKF9hLm9uYXR0YWNoID0gW10pO1xufSk7XG5jb25zdCBudW1lcmljT3JpZ2luTWFwID0ge1xuICAgIG51bWJlcjogXCJudW1iZXJcIixcbiAgICBiaWdpbnQ6IFwiYmlnaW50XCIsXG4gICAgb2JqZWN0OiBcImRhdGVcIixcbn07XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTGVzc1RoYW4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTGVzc1RoYW5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3Qgb3JpZ2luID0gbnVtZXJpY09yaWdpbk1hcFt0eXBlb2YgZGVmLnZhbHVlXTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBjb25zdCBjdXJyID0gKGRlZi5pbmNsdXNpdmUgPyBiYWcubWF4aW11bSA6IGJhZy5leGNsdXNpdmVNYXhpbXVtKSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gICAgICAgIGlmIChkZWYudmFsdWUgPCBjdXJyKSB7XG4gICAgICAgICAgICBpZiAoZGVmLmluY2x1c2l2ZSlcbiAgICAgICAgICAgICAgICBiYWcubWF4aW11bSA9IGRlZi52YWx1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBiYWcuZXhjbHVzaXZlTWF4aW11bSA9IGRlZi52YWx1ZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChkZWYuaW5jbHVzaXZlID8gcGF5bG9hZC52YWx1ZSA8PSBkZWYudmFsdWUgOiBwYXlsb2FkLnZhbHVlIDwgZGVmLnZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW4sXG4gICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgIG1heGltdW06IHR5cGVvZiBkZWYudmFsdWUgPT09IFwib2JqZWN0XCIgPyBkZWYudmFsdWUuZ2V0VGltZSgpIDogZGVmLnZhbHVlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbmNsdXNpdmU6IGRlZi5pbmNsdXNpdmUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tHcmVhdGVyVGhhbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tHcmVhdGVyVGhhblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBvcmlnaW4gPSBudW1lcmljT3JpZ2luTWFwW3R5cGVvZiBkZWYudmFsdWVdO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoZGVmLmluY2x1c2l2ZSA/IGJhZy5taW5pbXVtIDogYmFnLmV4Y2x1c2l2ZU1pbmltdW0pID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgICAgICAgaWYgKGRlZi52YWx1ZSA+IGN1cnIpIHtcbiAgICAgICAgICAgIGlmIChkZWYuaW5jbHVzaXZlKVxuICAgICAgICAgICAgICAgIGJhZy5taW5pbXVtID0gZGVmLnZhbHVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGJhZy5leGNsdXNpdmVNaW5pbXVtID0gZGVmLnZhbHVlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGRlZi5pbmNsdXNpdmUgPyBwYXlsb2FkLnZhbHVlID49IGRlZi52YWx1ZSA6IHBheWxvYWQudmFsdWUgPiBkZWYudmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX3NtYWxsXCIsXG4gICAgICAgICAgICBtaW5pbXVtOiB0eXBlb2YgZGVmLnZhbHVlID09PSBcIm9iamVjdFwiID8gZGVmLnZhbHVlLmdldFRpbWUoKSA6IGRlZi52YWx1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiBkZWYuaW5jbHVzaXZlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTXVsdGlwbGVPZiA9IFxuLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja011bHRpcGxlT2ZcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSBpbnN0Ll96b2QuYmFnKS5tdWx0aXBsZU9mID8/IChfYS5tdWx0aXBsZU9mID0gZGVmLnZhbHVlKTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgIT09IHR5cGVvZiBkZWYudmFsdWUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWl4IG51bWJlciBhbmQgYmlnaW50IGluIG11bHRpcGxlX29mIGNoZWNrLlwiKTtcbiAgICAgICAgY29uc3QgaXNNdWx0aXBsZSA9IHR5cGVvZiBwYXlsb2FkLnZhbHVlID09PSBcImJpZ2ludFwiXG4gICAgICAgICAgICA/IHBheWxvYWQudmFsdWUgJSBkZWYudmFsdWUgPT09IEJpZ0ludCgwKVxuICAgICAgICAgICAgOiB1dGlsLmZsb2F0U2FmZVJlbWFpbmRlcihwYXlsb2FkLnZhbHVlLCBkZWYudmFsdWUpID09PSAwO1xuICAgICAgICBpZiAoaXNNdWx0aXBsZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IHR5cGVvZiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgY29kZTogXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICAgICAgICAgIGRpdmlzb3I6IGRlZi52YWx1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTnVtYmVyRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja051bWJlckZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTsgLy8gbm8gZm9ybWF0IGNoZWNrc1xuICAgIGRlZi5mb3JtYXQgPSBkZWYuZm9ybWF0IHx8IFwiZmxvYXQ2NFwiO1xuICAgIGNvbnN0IGlzSW50ID0gZGVmLmZvcm1hdD8uaW5jbHVkZXMoXCJpbnRcIik7XG4gICAgY29uc3Qgb3JpZ2luID0gaXNJbnQgPyBcImludFwiIDogXCJudW1iZXJcIjtcbiAgICBjb25zdCBbbWluaW11bSwgbWF4aW11bV0gPSB1dGlsLk5VTUJFUl9GT1JNQVRfUkFOR0VTW2RlZi5mb3JtYXRdO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5mb3JtYXQgPSBkZWYuZm9ybWF0O1xuICAgICAgICBiYWcubWluaW11bSA9IG1pbmltdW07XG4gICAgICAgIGJhZy5tYXhpbXVtID0gbWF4aW11bTtcbiAgICAgICAgaWYgKGlzSW50KVxuICAgICAgICAgICAgYmFnLnBhdHRlcm4gPSByZWdleGVzLmludGVnZXI7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoaXNJbnQpIHtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBpbnZhbGlkX2Zvcm1hdCBpc3N1ZVxuICAgICAgICAgICAgICAgIC8vIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIC8vICAgZXhwZWN0ZWQ6IGRlZi5mb3JtYXQsXG4gICAgICAgICAgICAgICAgLy8gICBmb3JtYXQ6IGRlZi5mb3JtYXQsXG4gICAgICAgICAgICAgICAgLy8gICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgLy8gICBpbnB1dCxcbiAgICAgICAgICAgICAgICAvLyAgIGluc3QsXG4gICAgICAgICAgICAgICAgLy8gfSk7XG4gICAgICAgICAgICAgICAgLy8gaW52YWxpZF90eXBlIGlzc3VlXG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBvcmlnaW4sXG4gICAgICAgICAgICAgICAgICAgIGZvcm1hdDogZGVmLmZvcm1hdCxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gbm90X211bHRpcGxlX29mIGlzc3VlXG4gICAgICAgICAgICAgICAgLy8gcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgLy8gICBjb2RlOiBcIm5vdF9tdWx0aXBsZV9vZlwiLFxuICAgICAgICAgICAgICAgIC8vICAgb3JpZ2luOiBcIm51bWJlclwiLFxuICAgICAgICAgICAgICAgIC8vICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgLy8gICBpbnN0LFxuICAgICAgICAgICAgICAgIC8vICAgZGl2aXNvcjogMSxcbiAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0b29fYmlnXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcInRvb19iaWdcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heGltdW06IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogXCJJbnRlZ2VycyBtdXN0IGJlIHdpdGhpbiB0aGUgc2FmZSBpbnRlZ2VyIHJhbmdlLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvb19zbWFsbFxuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbmltdW06IE51bWJlci5NSU5fU0FGRV9JTlRFR0VSLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogXCJJbnRlZ2VycyBtdXN0IGJlIHdpdGhpbiB0aGUgc2FmZSBpbnRlZ2VyIHJhbmdlLlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnB1dCA8IG1pbmltdW0pIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJudW1iZXJcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgICAgIG1pbmltdW0sXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgPiBtYXhpbXVtKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwibnVtYmVyXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICAgICAgbWF4aW11bSxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0JpZ0ludEZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tCaWdJbnRGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7IC8vIG5vIGZvcm1hdCBjaGVja3NcbiAgICBjb25zdCBbbWluaW11bSwgbWF4aW11bV0gPSB1dGlsLkJJR0lOVF9GT1JNQVRfUkFOR0VTW2RlZi5mb3JtYXRdO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5mb3JtYXQgPSBkZWYuZm9ybWF0O1xuICAgICAgICBiYWcubWluaW11bSA9IG1pbmltdW07XG4gICAgICAgIGJhZy5tYXhpbXVtID0gbWF4aW11bTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmIChpbnB1dCA8IG1pbmltdW0pIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJiaWdpbnRcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgICAgIG1pbmltdW06IG1pbmltdW0sXG4gICAgICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgPiBtYXhpbXVtKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwiYmlnaW50XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICAgICAgbWF4aW11bSxcbiAgICAgICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja01heFNpemUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWF4U2l6ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLnNpemUgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyID0gKGluc3QuX3pvZC5iYWcubWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBpZiAoZGVmLm1heGltdW0gPCBjdXJyKVxuICAgICAgICAgICAgaW5zdC5fem9kLmJhZy5tYXhpbXVtID0gZGVmLm1heGltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBzaXplID0gaW5wdXQuc2l6ZTtcbiAgICAgICAgaWYgKHNpemUgPD0gZGVmLm1heGltdW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luOiB1dGlsLmdldFNpemFibGVPcmlnaW4oaW5wdXQpLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fYmlnXCIsXG4gICAgICAgICAgICBtYXhpbXVtOiBkZWYubWF4aW11bSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTWluU2l6ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNaW5TaXplXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwuc2l6ZSAhPT0gdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnIgPSAoaW5zdC5fem9kLmJhZy5taW5pbXVtID8/IE51bWJlci5ORUdBVElWRV9JTkZJTklUWSk7XG4gICAgICAgIGlmIChkZWYubWluaW11bSA+IGN1cnIpXG4gICAgICAgICAgICBpbnN0Ll96b2QuYmFnLm1pbmltdW0gPSBkZWYubWluaW11bTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IHNpemUgPSBpbnB1dC5zaXplO1xuICAgICAgICBpZiAoc2l6ZSA+PSBkZWYubWluaW11bSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IHV0aWwuZ2V0U2l6YWJsZU9yaWdpbihpbnB1dCksXG4gICAgICAgICAgICBjb2RlOiBcInRvb19zbWFsbFwiLFxuICAgICAgICAgICAgbWluaW11bTogZGVmLm1pbmltdW0sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja1NpemVFcXVhbHMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrU2l6ZUVxdWFsc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgKF9hID0gaW5zdC5fem9kLmRlZikud2hlbiA/PyAoX2Eud2hlbiA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIHJldHVybiAhdXRpbC5udWxsaXNoKHZhbCkgJiYgdmFsLnNpemUgIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBiYWcgPSBpbnN0Ll96b2QuYmFnO1xuICAgICAgICBiYWcubWluaW11bSA9IGRlZi5zaXplO1xuICAgICAgICBiYWcubWF4aW11bSA9IGRlZi5zaXplO1xuICAgICAgICBiYWcuc2l6ZSA9IGRlZi5zaXplO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IGlucHV0LnNpemU7XG4gICAgICAgIGlmIChzaXplID09PSBkZWYuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdG9vQmlnID0gc2l6ZSA+IGRlZi5zaXplO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogdXRpbC5nZXRTaXphYmxlT3JpZ2luKGlucHV0KSxcbiAgICAgICAgICAgIC4uLih0b29CaWcgPyB7IGNvZGU6IFwidG9vX2JpZ1wiLCBtYXhpbXVtOiBkZWYuc2l6ZSB9IDogeyBjb2RlOiBcInRvb19zbWFsbFwiLCBtaW5pbXVtOiBkZWYuc2l6ZSB9KSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICAgICAgICAgIGV4YWN0OiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNYXhMZW5ndGggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWF4TGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyciA9IChpbnN0Ll96b2QuYmFnLm1heGltdW0gPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKTtcbiAgICAgICAgaWYgKGRlZi5tYXhpbXVtIDwgY3VycilcbiAgICAgICAgICAgIGluc3QuX3pvZC5iYWcubWF4aW11bSA9IGRlZi5tYXhpbXVtO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoIDw9IGRlZi5tYXhpbXVtKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcmlnaW4gPSB1dGlsLmdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIGNvZGU6IFwidG9vX2JpZ1wiLFxuICAgICAgICAgICAgbWF4aW11bTogZGVmLm1heGltdW0sXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja01pbkxlbmd0aCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNaW5MZW5ndGhcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIHZhciBfYTtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICByZXR1cm4gIXV0aWwubnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2Qub25hdHRhY2gucHVzaCgoaW5zdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyID0gKGluc3QuX3pvZC5iYWcubWluaW11bSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpO1xuICAgICAgICBpZiAoZGVmLm1pbmltdW0gPiBjdXJyKVxuICAgICAgICAgICAgaW5zdC5fem9kLmJhZy5taW5pbXVtID0gZGVmLm1pbmltdW07XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBpbnB1dC5sZW5ndGg7XG4gICAgICAgIGlmIChsZW5ndGggPj0gZGVmLm1pbmltdW0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IG9yaWdpbiA9IHV0aWwuZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgb3JpZ2luLFxuICAgICAgICAgICAgY29kZTogXCJ0b29fc21hbGxcIixcbiAgICAgICAgICAgIG1pbmltdW06IGRlZi5taW5pbXVtLFxuICAgICAgICAgICAgaW5jbHVzaXZlOiB0cnVlLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tMZW5ndGhFcXVhbHMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTGVuZ3RoRXF1YWxzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICAoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgdmFsID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgcmV0dXJuICF1dGlsLm51bGxpc2godmFsKSAmJiB2YWwubGVuZ3RoICE9PSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLm1pbmltdW0gPSBkZWYubGVuZ3RoO1xuICAgICAgICBiYWcubWF4aW11bSA9IGRlZi5sZW5ndGg7XG4gICAgICAgIGJhZy5sZW5ndGggPSBkZWYubGVuZ3RoO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoID09PSBkZWYubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvcmlnaW4gPSB1dGlsLmdldExlbmd0aGFibGVPcmlnaW4oaW5wdXQpO1xuICAgICAgICBjb25zdCB0b29CaWcgPSBsZW5ndGggPiBkZWYubGVuZ3RoO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbixcbiAgICAgICAgICAgIC4uLih0b29CaWcgPyB7IGNvZGU6IFwidG9vX2JpZ1wiLCBtYXhpbXVtOiBkZWYubGVuZ3RoIH0gOiB7IGNvZGU6IFwidG9vX3NtYWxsXCIsIG1pbmltdW06IGRlZi5sZW5ndGggfSksXG4gICAgICAgICAgICBpbmNsdXNpdmU6IHRydWUsXG4gICAgICAgICAgICBleGFjdDogdHJ1ZSxcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrU3RyaW5nRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1N0cmluZ0Zvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5mb3JtYXQgPSBkZWYuZm9ybWF0O1xuICAgICAgICBpZiAoZGVmLnBhdHRlcm4pIHtcbiAgICAgICAgICAgIGJhZy5wYXR0ZXJucyA/PyAoYmFnLnBhdHRlcm5zID0gbmV3IFNldCgpKTtcbiAgICAgICAgICAgIGJhZy5wYXR0ZXJucy5hZGQoZGVmLnBhdHRlcm4pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGRlZi5wYXR0ZXJuKVxuICAgICAgICAoX2EgPSBpbnN0Ll96b2QpLmNoZWNrID8/IChfYS5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBkZWYucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaWYgKGRlZi5wYXR0ZXJuLnRlc3QocGF5bG9hZC52YWx1ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgb3JpZ2luOiBcInN0cmluZ1wiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IGRlZi5mb3JtYXQsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgLi4uKGRlZi5wYXR0ZXJuID8geyBwYXR0ZXJuOiBkZWYucGF0dGVybi50b1N0cmluZygpIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICBlbHNlXG4gICAgICAgIChfYiA9IGluc3QuX3pvZCkuY2hlY2sgPz8gKF9iLmNoZWNrID0gKCkgPT4geyB9KTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja1JlZ2V4ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja1JlZ2V4XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2tTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGRlZi5wYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgICAgIGlmIChkZWYucGF0dGVybi50ZXN0KHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJyZWdleFwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBwYXR0ZXJuOiBkZWYucGF0dGVybi50b1N0cmluZygpLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENoZWNrTG93ZXJDYXNlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0xvd2VyQ2FzZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5sb3dlcmNhc2UpO1xuICAgICRab2RDaGVja1N0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tVcHBlckNhc2UgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrVXBwZXJDYXNlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnVwcGVyY2FzZSk7XG4gICAgJFpvZENoZWNrU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja0luY2x1ZGVzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDaGVja0luY2x1ZGVzXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvbnN0IGVzY2FwZWRSZWdleCA9IHV0aWwuZXNjYXBlUmVnZXgoZGVmLmluY2x1ZGVzKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cCh0eXBlb2YgZGVmLnBvc2l0aW9uID09PSBcIm51bWJlclwiID8gYF4ueyR7ZGVmLnBvc2l0aW9ufX0ke2VzY2FwZWRSZWdleH1gIDogZXNjYXBlZFJlZ2V4KTtcbiAgICBkZWYucGF0dGVybiA9IHBhdHRlcm47XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICAgICAgYmFnLnBhdHRlcm5zID8/IChiYWcucGF0dGVybnMgPSBuZXcgU2V0KCkpO1xuICAgICAgICBiYWcucGF0dGVybnMuYWRkKHBhdHRlcm4pO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlLmluY2x1ZGVzKGRlZi5pbmNsdWRlcywgZGVmLnBvc2l0aW9uKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiaW5jbHVkZXNcIixcbiAgICAgICAgICAgIGluY2x1ZGVzOiBkZWYuaW5jbHVkZXMsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja1N0YXJ0c1dpdGggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrU3RhcnRzV2l0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChgXiR7dXRpbC5lc2NhcGVSZWdleChkZWYucHJlZml4KX0uKmApO1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHBhdHRlcm4pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5wYXR0ZXJucyA/PyAoYmFnLnBhdHRlcm5zID0gbmV3IFNldCgpKTtcbiAgICAgICAgYmFnLnBhdHRlcm5zLmFkZChwYXR0ZXJuKTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZS5zdGFydHNXaXRoKGRlZi5wcmVmaXgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIG9yaWdpbjogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJzdGFydHNfd2l0aFwiLFxuICAgICAgICAgICAgcHJlZml4OiBkZWYucHJlZml4LFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tFbmRzV2l0aCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tFbmRzV2l0aFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gbmV3IFJlZ0V4cChgLioke3V0aWwuZXNjYXBlUmVnZXgoZGVmLnN1ZmZpeCl9JGApO1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHBhdHRlcm4pO1xuICAgIGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0KSA9PiB7XG4gICAgICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgICAgIGJhZy5wYXR0ZXJucyA/PyAoYmFnLnBhdHRlcm5zID0gbmV3IFNldCgpKTtcbiAgICAgICAgYmFnLnBhdHRlcm5zLmFkZChwYXR0ZXJuKTtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZS5lbmRzV2l0aChkZWYuc3VmZml4KSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBvcmlnaW46IFwic3RyaW5nXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICBmb3JtYXQ6IFwiZW5kc193aXRoXCIsXG4gICAgICAgICAgICBzdWZmaXg6IGRlZi5zdWZmaXgsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8vICAgICRab2RDaGVja1Byb3BlcnR5ICAgIC8vLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gaGFuZGxlQ2hlY2tQcm9wZXJ0eVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIHByb3BlcnR5KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMocHJvcGVydHksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgJFpvZENoZWNrUHJvcGVydHkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrUHJvcGVydHlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLnNjaGVtYS5fem9kLnJ1bih7XG4gICAgICAgICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZVtkZWYucHJvcGVydHldLFxuICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgfSwge30pO1xuICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZUNoZWNrUHJvcGVydHlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBkZWYucHJvcGVydHkpKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVDaGVja1Byb3BlcnR5UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgZGVmLnByb3BlcnR5KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ2hlY2tNaW1lVHlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNaW1lVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZENoZWNrLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBtaW1lU2V0ID0gbmV3IFNldChkZWYubWltZSk7XG4gICAgaW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QpID0+IHtcbiAgICAgICAgaW5zdC5fem9kLmJhZy5taW1lID0gZGVmLm1pbWU7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKG1pbWVTZXQuaGFzKHBheWxvYWQudmFsdWUudHlwZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IGRlZi5taW1lLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUudHlwZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDaGVja092ZXJ3cml0ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tPdmVyd3JpdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi50eChwYXlsb2FkLnZhbHVlKTtcbiAgICB9O1xufSk7XG4iLCAiZXhwb3J0IGNsYXNzIERvYyB7XG4gICAgY29uc3RydWN0b3IoYXJncyA9IFtdKSB7XG4gICAgICAgIHRoaXMuY29udGVudCA9IFtdO1xuICAgICAgICB0aGlzLmluZGVudCA9IDA7XG4gICAgICAgIGlmICh0aGlzKVxuICAgICAgICAgICAgdGhpcy5hcmdzID0gYXJncztcbiAgICB9XG4gICAgaW5kZW50ZWQoZm4pIHtcbiAgICAgICAgdGhpcy5pbmRlbnQgKz0gMTtcbiAgICAgICAgZm4odGhpcyk7XG4gICAgICAgIHRoaXMuaW5kZW50IC09IDE7XG4gICAgfVxuICAgIHdyaXRlKGFyZykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhcmcodGhpcywgeyBleGVjdXRpb246IFwic3luY1wiIH0pO1xuICAgICAgICAgICAgYXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcImFzeW5jXCIgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29udGVudCA9IGFyZztcbiAgICAgICAgY29uc3QgbGluZXMgPSBjb250ZW50LnNwbGl0KFwiXFxuXCIpLmZpbHRlcigoeCkgPT4geCk7XG4gICAgICAgIGNvbnN0IG1pbkluZGVudCA9IE1hdGgubWluKC4uLmxpbmVzLm1hcCgoeCkgPT4geC5sZW5ndGggLSB4LnRyaW1TdGFydCgpLmxlbmd0aCkpO1xuICAgICAgICBjb25zdCBkZWRlbnRlZCA9IGxpbmVzLm1hcCgoeCkgPT4geC5zbGljZShtaW5JbmRlbnQpKS5tYXAoKHgpID0+IFwiIFwiLnJlcGVhdCh0aGlzLmluZGVudCAqIDIpICsgeCk7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBkZWRlbnRlZCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50LnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcGlsZSgpIHtcbiAgICAgICAgY29uc3QgRiA9IEZ1bmN0aW9uO1xuICAgICAgICBjb25zdCBhcmdzID0gdGhpcz8uYXJncztcbiAgICAgICAgY29uc3QgY29udGVudCA9IHRoaXM/LmNvbnRlbnQgPz8gW2BgXTtcbiAgICAgICAgY29uc3QgbGluZXMgPSBbLi4uY29udGVudC5tYXAoKHgpID0+IGAgICR7eH1gKV07XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGxpbmVzLmpvaW4oXCJcXG5cIikpO1xuICAgICAgICByZXR1cm4gbmV3IEYoLi4uYXJncywgbGluZXMuam9pbihcIlxcblwiKSk7XG4gICAgfVxufVxuIiwgImV4cG9ydCBjb25zdCB2ZXJzaW9uID0ge1xuICAgIG1ham9yOiA0LFxuICAgIG1pbm9yOiAzLFxuICAgIHBhdGNoOiA2LFxufTtcbiIsICJpbXBvcnQgKiBhcyBjaGVja3MgZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgKiBhcyBjb3JlIGZyb20gXCIuL2NvcmUuanNcIjtcbmltcG9ydCB7IERvYyB9IGZyb20gXCIuL2RvYy5qc1wiO1xuaW1wb3J0IHsgcGFyc2UsIHBhcnNlQXN5bmMsIHNhZmVQYXJzZSwgc2FmZVBhcnNlQXN5bmMgfSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuaW1wb3J0ICogYXMgcmVnZXhlcyBmcm9tIFwiLi9yZWdleGVzLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi92ZXJzaW9ucy5qc1wiO1xuZXhwb3J0IGNvbnN0ICRab2RUeXBlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RUeXBlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaW5zdCA/PyAoaW5zdCA9IHt9KTtcbiAgICBpbnN0Ll96b2QuZGVmID0gZGVmOyAvLyBzZXQgX2RlZiBwcm9wZXJ0eVxuICAgIGluc3QuX3pvZC5iYWcgPSBpbnN0Ll96b2QuYmFnIHx8IHt9OyAvLyBpbml0aWFsaXplIF9iYWcgb2JqZWN0XG4gICAgaW5zdC5fem9kLnZlcnNpb24gPSB2ZXJzaW9uO1xuICAgIGNvbnN0IGNoZWNrcyA9IFsuLi4oaW5zdC5fem9kLmRlZi5jaGVja3MgPz8gW10pXTtcbiAgICAvLyBpZiBpbnN0IGlzIGl0c2VsZiBhIGNoZWNrcy4kWm9kQ2hlY2ssIHJ1biBpdCBhcyBhIGNoZWNrXG4gICAgaWYgKGluc3QuX3pvZC50cmFpdHMuaGFzKFwiJFpvZENoZWNrXCIpKSB7XG4gICAgICAgIGNoZWNrcy51bnNoaWZ0KGluc3QpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNoIG9mIGNoZWNrcykge1xuICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIGNoLl96b2Qub25hdHRhY2gpIHtcbiAgICAgICAgICAgIGZuKGluc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjaGVja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGRlZmVycmVkIGluaXRpYWxpemVyXG4gICAgICAgIC8vIGluc3QuX3pvZC5wYXJzZSBpcyBub3QgeWV0IGRlZmluZWRcbiAgICAgICAgKF9hID0gaW5zdC5fem9kKS5kZWZlcnJlZCA/PyAoX2EuZGVmZXJyZWQgPSBbXSk7XG4gICAgICAgIGluc3QuX3pvZC5kZWZlcnJlZD8ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBpbnN0Ll96b2QucnVuID0gaW5zdC5fem9kLnBhcnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJ1bkNoZWNrcyA9IChwYXlsb2FkLCBjaGVja3MsIGN0eCkgPT4ge1xuICAgICAgICAgICAgbGV0IGlzQWJvcnRlZCA9IHV0aWwuYWJvcnRlZChwYXlsb2FkKTtcbiAgICAgICAgICAgIGxldCBhc3luY1Jlc3VsdDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2ggb2YgY2hlY2tzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoLl96b2QuZGVmLndoZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkUnVuID0gY2guX3pvZC5kZWYud2hlbihwYXlsb2FkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG91bGRSdW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBYm9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyTGVuID0gcGF5bG9hZC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBjaC5fem9kLmNoZWNrKHBheWxvYWQpO1xuICAgICAgICAgICAgICAgIGlmIChfIGluc3RhbmNlb2YgUHJvbWlzZSAmJiBjdHg/LmFzeW5jID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYXN5bmNSZXN1bHQgfHwgXyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN5bmNSZXN1bHQgPSAoYXN5bmNSZXN1bHQgPz8gUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgXztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRMZW4gPSBwYXlsb2FkLmlzc3Vlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV4dExlbiA9PT0gY3VyckxlbilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzQWJvcnRlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc0Fib3J0ZWQgPSB1dGlsLmFib3J0ZWQocGF5bG9hZCwgY3Vyckxlbik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dExlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRMZW4gPT09IGN1cnJMZW4pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Fib3J0ZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0Fib3J0ZWQgPSB1dGlsLmFib3J0ZWQocGF5bG9hZCwgY3Vyckxlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzeW5jUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFzeW5jUmVzdWx0LnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVDYW5hcnlSZXN1bHQgPSAoY2FuYXJ5LCBwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgICAgIC8vIGFib3J0IGlmIHRoZSBjYW5hcnkgaXMgYWJvcnRlZFxuICAgICAgICAgICAgaWYgKHV0aWwuYWJvcnRlZChjYW5hcnkpKSB7XG4gICAgICAgICAgICAgICAgY2FuYXJ5LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBjYW5hcnk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBydW4gY2hlY2tzIGZpcnN0LCB0aGVuXG4gICAgICAgICAgICBjb25zdCBjaGVja1Jlc3VsdCA9IHJ1bkNoZWNrcyhwYXlsb2FkLCBjaGVja3MsIGN0eCk7XG4gICAgICAgICAgICBpZiAoY2hlY2tSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5hc3luYyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrUmVzdWx0LnRoZW4oKGNoZWNrUmVzdWx0KSA9PiBpbnN0Ll96b2QucGFyc2UoY2hlY2tSZXN1bHQsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGluc3QuX3pvZC5wYXJzZShjaGVja1Jlc3VsdCwgY3R4KTtcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdC5fem9kLnJ1biA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgICAgIGlmIChjdHguc2tpcENoZWNrcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0Ll96b2QucGFyc2UocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBydW4gY2FuYXJ5XG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbCBwYXNzIChubyBjaGVja3MpXG4gICAgICAgICAgICAgICAgY29uc3QgY2FuYXJ5ID0gaW5zdC5fem9kLnBhcnNlKHsgdmFsdWU6IHBheWxvYWQudmFsdWUsIGlzc3VlczogW10gfSwgeyAuLi5jdHgsIHNraXBDaGVja3M6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmFyeSBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbmFyeS50aGVuKChjYW5hcnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYW5hcnlSZXN1bHQoY2FuYXJ5LCBwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNhbmFyeVJlc3VsdChjYW5hcnksIHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3J3YXJkXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpbnN0Ll96b2QucGFyc2UocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN0eC5hc3luYyA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RBc3luY0Vycm9yKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHJ1bkNoZWNrcyhyZXN1bHQsIGNoZWNrcywgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVuQ2hlY2tzKHJlc3VsdCwgY2hlY2tzLCBjdHgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBMYXp5IGluaXRpYWxpemUgfnN0YW5kYXJkIHRvIGF2b2lkIGNyZWF0aW5nIG9iamVjdHMgZm9yIGV2ZXJ5IHNjaGVtYVxuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0LCBcIn5zdGFuZGFyZFwiLCAoKSA9PiAoe1xuICAgICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzYWZlUGFyc2UoaW5zdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiByLnN1Y2Nlc3MgPyB7IHZhbHVlOiByLmRhdGEgfSA6IHsgaXNzdWVzOiByLmVycm9yPy5pc3N1ZXMgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNhZmVQYXJzZUFzeW5jKGluc3QsIHZhbHVlKS50aGVuKChyKSA9PiAoci5zdWNjZXNzID8geyB2YWx1ZTogci5kYXRhIH0gOiB7IGlzc3Vlczogci5lcnJvcj8uaXNzdWVzIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmVuZG9yOiBcInpvZFwiLFxuICAgICAgICB2ZXJzaW9uOiAxLFxuICAgIH0pKTtcbn0pO1xuZXhwb3J0IHsgY2xvbmUgfSBmcm9tIFwiLi91dGlsLmpzXCI7XG5leHBvcnQgY29uc3QgJFpvZFN0cmluZyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU3RyaW5nXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBbLi4uKGluc3Q/Ll96b2QuYmFnPy5wYXR0ZXJucyA/PyBbXSldLnBvcCgpID8/IHJlZ2V4ZXMuc3RyaW5nKGluc3QuX3pvZC5iYWcpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfKSA9PiB7XG4gICAgICAgIGlmIChkZWYuY29lcmNlKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gU3RyaW5nKHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF8pIHsgfVxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFN0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU3RyaW5nRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBjaGVjayBpbml0aWFsaXphdGlvbiBtdXN0IGNvbWUgZmlyc3RcbiAgICBjaGVja3MuJFpvZENoZWNrU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICAkWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RHVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RHVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmd1aWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFVVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGlmIChkZWYudmVyc2lvbikge1xuICAgICAgICBjb25zdCB2ZXJzaW9uTWFwID0ge1xuICAgICAgICAgICAgdjE6IDEsXG4gICAgICAgICAgICB2MjogMixcbiAgICAgICAgICAgIHYzOiAzLFxuICAgICAgICAgICAgdjQ6IDQsXG4gICAgICAgICAgICB2NTogNSxcbiAgICAgICAgICAgIHY2OiA2LFxuICAgICAgICAgICAgdjc6IDcsXG4gICAgICAgICAgICB2ODogOCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdiA9IHZlcnNpb25NYXBbZGVmLnZlcnNpb25dO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIFVVSUQgdmVyc2lvbjogXCIke2RlZi52ZXJzaW9ufVwiYCk7XG4gICAgICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMudXVpZCh2KSk7XG4gICAgfVxuICAgIGVsc2VcbiAgICAgICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy51dWlkKCkpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEVtYWlsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RFbWFpbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5lbWFpbCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVVJMID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVUkxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcmltIHdoaXRlc3BhY2UgZnJvbSBpbnB1dFxuICAgICAgICAgICAgY29uc3QgdHJpbW1lZCA9IHBheWxvYWQudmFsdWUudHJpbSgpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgdXJsID0gbmV3IFVSTCh0cmltbWVkKTtcbiAgICAgICAgICAgIGlmIChkZWYuaG9zdG5hbWUpIHtcbiAgICAgICAgICAgICAgICBkZWYuaG9zdG5hbWUubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoIWRlZi5ob3N0bmFtZS50ZXN0KHVybC5ob3N0bmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IFwidXJsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBub3RlOiBcIkludmFsaWQgaG9zdG5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm46IGRlZi5ob3N0bmFtZS5zb3VyY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlZi5wcm90b2NvbCkge1xuICAgICAgICAgICAgICAgIGRlZi5wcm90b2NvbC5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIGlmICghZGVmLnByb3RvY29sLnRlc3QodXJsLnByb3RvY29sLmVuZHNXaXRoKFwiOlwiKSA/IHVybC5wcm90b2NvbC5zbGljZSgwLCAtMSkgOiB1cmwucHJvdG9jb2wpKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0OiBcInVybFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgbm90ZTogXCJJbnZhbGlkIHByb3RvY29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBkZWYucHJvdG9jb2wuc291cmNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB0aGUgb3V0cHV0IHZhbHVlIGJhc2VkIG9uIG5vcm1hbGl6ZSBmbGFnXG4gICAgICAgICAgICBpZiAoZGVmLm5vcm1hbGl6ZSkge1xuICAgICAgICAgICAgICAgIC8vIFVzZSBub3JtYWxpemVkIFVSTFxuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSB1cmwuaHJlZjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFByZXNlcnZlIHRoZSBvcmlnaW5hbCBpbnB1dCAodHJpbW1lZClcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gdHJpbW1lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogXCJ1cmxcIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEVtb2ppID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RFbW9qaVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5lbW9qaSgpKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROYW5vSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE5hbm9JRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5uYW5vaWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuY3VpZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ1VJRDIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENVSUQyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmN1aWQyKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RVTElEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVTElEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnVsaWQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFhJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kWElEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnhpZCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kS1NVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEtTVUlEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmtzdWlkKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJU09EYXRlVGltZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVNPRGF0ZVRpbWVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuZGF0ZXRpbWUoZGVmKSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVNPRGF0ZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSVNPRGF0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5kYXRlKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJU09UaW1lID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJU09UaW1lXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLnRpbWUoZGVmKSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kSVNPRHVyYXRpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElTT0R1cmF0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmR1cmF0aW9uKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RJUHY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RJUHY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmlwdjQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5iYWcuZm9ybWF0ID0gYGlwdjRgO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZElQdjYgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZElQdjZcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuaXB2Nik7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmJhZy5mb3JtYXQgPSBgaXB2NmA7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIG5ldyBVUkwoYGh0dHA6Ly9bJHtwYXlsb2FkLnZhbHVlfV1gKTtcbiAgICAgICAgICAgIC8vIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfZm9ybWF0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0OiBcImlwdjZcIixcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE1BQyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTUFDXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLm1hYyhkZWYuZGVsaW1pdGVyKSk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmJhZy5mb3JtYXQgPSBgbWFjYDtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDSURSdjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZENJRFJ2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5jaWRydjQpO1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZENJRFJ2NiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ0lEUnY2XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmNpZHJ2Nik7IC8vIG5vdCB1c2VkIGZvciB2YWxpZGF0aW9uXG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBwYXlsb2FkLnZhbHVlLnNwbGl0KFwiL1wiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChwYXJ0cy5sZW5ndGggIT09IDIpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCBbYWRkcmVzcywgcHJlZml4XSA9IHBhcnRzO1xuICAgICAgICAgICAgaWYgKCFwcmVmaXgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXhOdW0gPSBOdW1iZXIocHJlZml4KTtcbiAgICAgICAgICAgIGlmIChgJHtwcmVmaXhOdW19YCAhPT0gcHJlZml4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgaWYgKHByZWZpeE51bSA8IDAgfHwgcHJlZml4TnVtID4gMTI4KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgbmV3IFVSTChgaHR0cDovL1ske2FkZHJlc3N9XWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgICAgICBmb3JtYXQ6IFwiY2lkcnY2XCIsXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBjb250aW51ZTogIWRlZi5hYm9ydCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgWm9kQmFzZTY0ICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEJhc2U2NChkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT09IFwiXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChkYXRhLmxlbmd0aCAlIDQgIT09IDApXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGF0b2IoZGF0YSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgJFpvZEJhc2U2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQmFzZTY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYucGF0dGVybiA/PyAoZGVmLnBhdHRlcm4gPSByZWdleGVzLmJhc2U2NCk7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmJhZy5jb250ZW50RW5jb2RpbmcgPSBcImJhc2U2NFwiO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChpc1ZhbGlkQmFzZTY0KHBheWxvYWQudmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF9mb3JtYXRcIixcbiAgICAgICAgICAgIGZvcm1hdDogXCJiYXNlNjRcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhZGVmLmFib3J0LFxuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8gICBab2RCYXNlNjQgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkQmFzZTY0VVJMKGRhdGEpIHtcbiAgICBpZiAoIXJlZ2V4ZXMuYmFzZTY0dXJsLnRlc3QoZGF0YSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjb25zdCBiYXNlNjQgPSBkYXRhLnJlcGxhY2UoL1stX10vZywgKGMpID0+IChjID09PSBcIi1cIiA/IFwiK1wiIDogXCIvXCIpKTtcbiAgICBjb25zdCBwYWRkZWQgPSBiYXNlNjQucGFkRW5kKE1hdGguY2VpbChiYXNlNjQubGVuZ3RoIC8gNCkgKiA0LCBcIj1cIik7XG4gICAgcmV0dXJuIGlzVmFsaWRCYXNlNjQocGFkZGVkKTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kQmFzZTY0VVJMID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCYXNlNjRVUkxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGRlZi5wYXR0ZXJuID8/IChkZWYucGF0dGVybiA9IHJlZ2V4ZXMuYmFzZTY0dXJsKTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QuYmFnLmNvbnRlbnRFbmNvZGluZyA9IFwiYmFzZTY0dXJsXCI7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGlzVmFsaWRCYXNlNjRVUkwocGF5bG9hZC52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImJhc2U2NHVybFwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRTE2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRTE2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgZGVmLnBhdHRlcm4gPz8gKGRlZi5wYXR0ZXJuID0gcmVnZXhlcy5lMTY0KTtcbiAgICAkWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vICAgWm9kSldUICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZEpXVCh0b2tlbiwgYWxnb3JpdGhtID0gbnVsbCkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHRva2Vuc1BhcnRzID0gdG9rZW4uc3BsaXQoXCIuXCIpO1xuICAgICAgICBpZiAodG9rZW5zUGFydHMubGVuZ3RoICE9PSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBbaGVhZGVyXSA9IHRva2Vuc1BhcnRzO1xuICAgICAgICBpZiAoIWhlYWRlcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBjb25zdCBwYXJzZWRIZWFkZXIgPSBKU09OLnBhcnNlKGF0b2IoaGVhZGVyKSk7XG4gICAgICAgIGlmIChcInR5cFwiIGluIHBhcnNlZEhlYWRlciAmJiBwYXJzZWRIZWFkZXI/LnR5cCAhPT0gXCJKV1RcIilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgaWYgKCFwYXJzZWRIZWFkZXIuYWxnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoYWxnb3JpdGhtICYmICghKFwiYWxnXCIgaW4gcGFyc2VkSGVhZGVyKSB8fCBwYXJzZWRIZWFkZXIuYWxnICE9PSBhbGdvcml0aG0pKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2gge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0ICRab2RKV1QgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEpXVFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKGlzVmFsaWRKV1QocGF5bG9hZC52YWx1ZSwgZGVmLmFsZykpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBcImp3dFwiLFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ3VzdG9tU3RyaW5nRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDdXN0b21TdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGlmIChkZWYuZm4ocGF5bG9hZC52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgZm9ybWF0OiBkZWYuZm9ybWF0LFxuICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgY29udGludWU6ICFkZWYuYWJvcnQsXG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTnVtYmVyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROdW1iZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IGluc3QuX3pvZC5iYWcucGF0dGVybiA/PyByZWdleGVzLm51bWJlcjtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmNvZXJjZSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IE51bWJlcihwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChfKSB7IH1cbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiICYmICFOdW1iZXIuaXNOYU4oaW5wdXQpICYmIE51bWJlci5pc0Zpbml0ZShpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlY2VpdmVkID0gdHlwZW9mIGlucHV0ID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICA/IE51bWJlci5pc05hTihpbnB1dClcbiAgICAgICAgICAgICAgICA/IFwiTmFOXCJcbiAgICAgICAgICAgICAgICA6ICFOdW1iZXIuaXNGaW5pdGUoaW5wdXQpXG4gICAgICAgICAgICAgICAgICAgID8gXCJJbmZpbml0eVwiXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJudW1iZXJcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAuLi4ocmVjZWl2ZWQgPyB7IHJlY2VpdmVkIH0gOiB7fSksXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE51bWJlckZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kTnVtYmVyRm9ybWF0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjaGVja3MuJFpvZENoZWNrTnVtYmVyRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICAkWm9kTnVtYmVyLmluaXQoaW5zdCwgZGVmKTsgLy8gbm8gZm9ybWF0IGNoZWNrc1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEJvb2xlYW4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEJvb2xlYW5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IHJlZ2V4ZXMuYm9vbGVhbjtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAoZGVmLmNvZXJjZSlcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IEJvb2xlYW4ocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJib29sZWFuXCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJib29sZWFuXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RCaWdJbnQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEJpZ0ludFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gcmVnZXhlcy5iaWdpbnQ7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBCaWdJbnQocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoXykgeyB9XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC52YWx1ZSA9PT0gXCJiaWdpbnRcIilcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcImJpZ2ludFwiLFxuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQmlnSW50Rm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RCaWdJbnRGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNoZWNrcy4kWm9kQ2hlY2tCaWdJbnRGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgICRab2RCaWdJbnQuaW5pdChpbnN0LCBkZWYpOyAvLyBubyBmb3JtYXQgY2hlY2tzXG59KTtcbmV4cG9ydCBjb25zdCAkWm9kU3ltYm9sID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RTeW1ib2xcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwic3ltYm9sXCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJzeW1ib2xcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFVuZGVmaW5lZCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVW5kZWZpbmVkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSByZWdleGVzLnVuZGVmaW5lZDtcbiAgICBpbnN0Ll96b2QudmFsdWVzID0gbmV3IFNldChbdW5kZWZpbmVkXSk7XG4gICAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICAgIGluc3QuX3pvZC5vcHRvdXQgPSBcIm9wdGlvbmFsXCI7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwidW5kZWZpbmVkXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROdWxsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROdWxsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSByZWdleGVzLm51bGw7XG4gICAgaW5zdC5fem9kLnZhbHVlcyA9IG5ldyBTZXQoW251bGxdKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm51bGxcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEFueSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQW55XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQpID0+IHBheWxvYWQ7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kVW5rbm93biA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVW5rbm93blwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkKSA9PiBwYXlsb2FkO1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE5ldmVyID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROZXZlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgZXhwZWN0ZWQ6IFwibmV2ZXJcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFZvaWQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFZvaWRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBleHBlY3RlZDogXCJ2b2lkXCIsXG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2REYXRlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2REYXRlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5jb2VyY2UpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG5ldyBEYXRlKHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9lcnIpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgaXNEYXRlID0gaW5wdXQgaW5zdGFuY2VvZiBEYXRlO1xuICAgICAgICBjb25zdCBpc1ZhbGlkRGF0ZSA9IGlzRGF0ZSAmJiAhTnVtYmVyLmlzTmFOKGlucHV0LmdldFRpbWUoKSk7XG4gICAgICAgIGlmIChpc1ZhbGlkRGF0ZSlcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcImRhdGVcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIC4uLihpc0RhdGUgPyB7IHJlY2VpdmVkOiBcIkludmFsaWQgRGF0ZVwiIH0gOiB7fSksXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBmaW5hbCwgaW5kZXgpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoaW5kZXgsIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICB9XG4gICAgZmluYWwudmFsdWVbaW5kZXhdID0gcmVzdWx0LnZhbHVlO1xufVxuZXhwb3J0IGNvbnN0ICRab2RBcnJheSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYXJyYXlcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBBcnJheShpbnB1dC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBwcm9tcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gaW5wdXRbaV07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuZWxlbWVudC5fem9kLnJ1bih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGl0ZW0sXG4gICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlQXJyYXlSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7IC8vaGFuZGxlQXJyYXlSZXN1bHRzQXN5bmMocGFyc2VSZXN1bHRzLCBmaW5hbCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlSZXN1bHQocmVzdWx0LCBmaW5hbCwga2V5LCBpbnB1dCwgaXNPcHRpb25hbE91dCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAvLyBGb3Igb3B0aW9uYWwtb3V0IHNjaGVtYXMsIGlnbm9yZSBlcnJvcnMgb24gYWJzZW50IGtleXNcbiAgICAgICAgaWYgKGlzT3B0aW9uYWxPdXQgJiYgIShrZXkgaW4gaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG4gICAgfVxuICAgIGlmIChyZXN1bHQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoa2V5IGluIGlucHV0KSB7XG4gICAgICAgICAgICBmaW5hbC52YWx1ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBmaW5hbC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZURlZihkZWYpIHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZGVmLnNoYXBlKTtcbiAgICBmb3IgKGNvbnN0IGsgb2Yga2V5cykge1xuICAgICAgICBpZiAoIWRlZi5zaGFwZT8uW2tdPy5fem9kPy50cmFpdHM/LmhhcyhcIiRab2RUeXBlXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZWxlbWVudCBhdCBrZXkgXCIke2t9XCI6IGV4cGVjdGVkIGEgWm9kIHNjaGVtYWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG9rZXlzID0gdXRpbC5vcHRpb25hbEtleXMoZGVmLnNoYXBlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5kZWYsXG4gICAgICAgIGtleXMsXG4gICAgICAgIGtleVNldDogbmV3IFNldChrZXlzKSxcbiAgICAgICAgbnVtS2V5czoga2V5cy5sZW5ndGgsXG4gICAgICAgIG9wdGlvbmFsS2V5czogbmV3IFNldChva2V5cyksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUNhdGNoYWxsKHByb21zLCBpbnB1dCwgcGF5bG9hZCwgY3R4LCBkZWYsIGluc3QpIHtcbiAgICBjb25zdCB1bnJlY29nbml6ZWQgPSBbXTtcbiAgICAvLyBpdGVyYXRlIG92ZXIgaW5wdXQga2V5c1xuICAgIGNvbnN0IGtleVNldCA9IGRlZi5rZXlTZXQ7XG4gICAgY29uc3QgX2NhdGNoYWxsID0gZGVmLmNhdGNoYWxsLl96b2Q7XG4gICAgY29uc3QgdCA9IF9jYXRjaGFsbC5kZWYudHlwZTtcbiAgICBjb25zdCBpc09wdGlvbmFsT3V0ID0gX2NhdGNoYWxsLm9wdG91dCA9PT0gXCJvcHRpb25hbFwiO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGlucHV0KSB7XG4gICAgICAgIGlmIChrZXlTZXQuaGFzKGtleSkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHQgPT09IFwibmV2ZXJcIikge1xuICAgICAgICAgICAgdW5yZWNvZ25pemVkLnB1c2goa2V5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHIgPSBfY2F0Y2hhbGwucnVuKHsgdmFsdWU6IGlucHV0W2tleV0sIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICBwcm9tcy5wdXNoKHIudGhlbigocikgPT4gaGFuZGxlUHJvcGVydHlSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaXNPcHRpb25hbE91dCkpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhhbmRsZVByb3BlcnR5UmVzdWx0KHIsIHBheWxvYWQsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh1bnJlY29nbml6ZWQubGVuZ3RoKSB7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgICAgICAgICAga2V5czogdW5yZWNvZ25pemVkLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFwcm9tcy5sZW5ndGgpXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0ICRab2RPYmplY3QgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gcmVxdWlyZXMgY2FzdCBiZWNhdXNlIHRlY2huaWNhbGx5ICRab2RPYmplY3QgZG9lc24ndCBleHRlbmRcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgLy8gY29uc3Qgc2ggPSBkZWYuc2hhcGU7XG4gICAgY29uc3QgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZGVmLCBcInNoYXBlXCIpO1xuICAgIGlmICghZGVzYz8uZ2V0KSB7XG4gICAgICAgIGNvbnN0IHNoID0gZGVmLnNoYXBlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVmLCBcInNoYXBlXCIsIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1NoID0geyAuLi5zaCB9O1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWYsIFwic2hhcGVcIiwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV3U2gsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NoO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IF9ub3JtYWxpemVkID0gdXRpbC5jYWNoZWQoKCkgPT4gbm9ybWFsaXplRGVmKGRlZikpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNoYXBlID0gZGVmLnNoYXBlO1xuICAgICAgICBjb25zdCBwcm9wVmFsdWVzID0ge307XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNoYXBlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IHNoYXBlW2tleV0uX3pvZDtcbiAgICAgICAgICAgIGlmIChmaWVsZC52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBwcm9wVmFsdWVzW2tleV0gPz8gKHByb3BWYWx1ZXNba2V5XSA9IG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGZpZWxkLnZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgcHJvcFZhbHVlc1trZXldLmFkZCh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlcztcbiAgICB9KTtcbiAgICBjb25zdCBpc09iamVjdCA9IHV0aWwuaXNPYmplY3Q7XG4gICAgY29uc3QgY2F0Y2hhbGwgPSBkZWYuY2F0Y2hhbGw7XG4gICAgbGV0IHZhbHVlO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgdmFsdWUgPz8gKHZhbHVlID0gX25vcm1hbGl6ZWQudmFsdWUpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSB7fTtcbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB2YWx1ZS5zaGFwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWUua2V5cykge1xuICAgICAgICAgICAgY29uc3QgZWwgPSBzaGFwZVtrZXldO1xuICAgICAgICAgICAgY29uc3QgaXNPcHRpb25hbE91dCA9IGVsLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG4gICAgICAgICAgICBjb25zdCByID0gZWwuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbXMucHVzaChyLnRoZW4oKHIpID0+IGhhbmRsZVByb3BlcnR5UmVzdWx0KHIsIHBheWxvYWQsIGtleSwgaW5wdXQsIGlzT3B0aW9uYWxPdXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVQcm9wZXJ0eVJlc3VsdChyLCBwYXlsb2FkLCBrZXksIGlucHV0LCBpc09wdGlvbmFsT3V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNhdGNoYWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJvbXMubGVuZ3RoID8gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVDYXRjaGFsbChwcm9tcywgaW5wdXQsIHBheWxvYWQsIGN0eCwgX25vcm1hbGl6ZWQudmFsdWUsIGluc3QpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kT2JqZWN0SklUID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RPYmplY3RKSVRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIHJlcXVpcmVzIGNhc3QgYmVjYXVzZSB0ZWNobmljYWxseSAkWm9kT2JqZWN0IGRvZXNuJ3QgZXh0ZW5kXG4gICAgJFpvZE9iamVjdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3Qgc3VwZXJQYXJzZSA9IGluc3QuX3pvZC5wYXJzZTtcbiAgICBjb25zdCBfbm9ybWFsaXplZCA9IHV0aWwuY2FjaGVkKCgpID0+IG5vcm1hbGl6ZURlZihkZWYpKTtcbiAgICBjb25zdCBnZW5lcmF0ZUZhc3RwYXNzID0gKHNoYXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRvYyA9IG5ldyBEb2MoW1wic2hhcGVcIiwgXCJwYXlsb2FkXCIsIFwiY3R4XCJdKTtcbiAgICAgICAgY29uc3Qgbm9ybWFsaXplZCA9IF9ub3JtYWxpemVkLnZhbHVlO1xuICAgICAgICBjb25zdCBwYXJzZVN0ciA9IChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGsgPSB1dGlsLmVzYyhrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGBzaGFwZVske2t9XS5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dFske2t9XSwgaXNzdWVzOiBbXSB9LCBjdHgpYDtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jLndyaXRlKGBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7YCk7XG4gICAgICAgIGNvbnN0IGlkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGxldCBjb3VudGVyID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSB7XG4gICAgICAgICAgICBpZHNba2V5XSA9IGBrZXlfJHtjb3VudGVyKyt9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBOiBwcmVzZXJ2ZSBrZXkgb3JkZXIge1xuICAgICAgICBkb2Mud3JpdGUoYGNvbnN0IG5ld1Jlc3VsdCA9IHt9O2ApO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBub3JtYWxpemVkLmtleXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gaWRzW2tleV07XG4gICAgICAgICAgICBjb25zdCBrID0gdXRpbC5lc2Moa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IHNoYXBlW2tleV07XG4gICAgICAgICAgICBjb25zdCBpc09wdGlvbmFsT3V0ID0gc2NoZW1hPy5fem9kPy5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcbiAgICAgICAgICAgIGRvYy53cml0ZShgY29uc3QgJHtpZH0gPSAke3BhcnNlU3RyKGtleSl9O2ApO1xuICAgICAgICAgICAgaWYgKGlzT3B0aW9uYWxPdXQpIHtcbiAgICAgICAgICAgICAgICAvLyBGb3Igb3B0aW9uYWwtb3V0IHNjaGVtYXMsIGlnbm9yZSBlcnJvcnMgb24gYWJzZW50IGtleXNcbiAgICAgICAgICAgICAgICBkb2Mud3JpdGUoYFxuICAgICAgICBpZiAoJHtpZH0uaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3VlcyA9IHBheWxvYWQuaXNzdWVzLmNvbmNhdCgke2lkfS5pc3N1ZXMubWFwKGlzcyA9PiAoe1xuICAgICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICAgIHBhdGg6IGlzcy5wYXRoID8gWyR7a30sIC4uLmlzcy5wYXRoXSA6IFske2t9XVxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICgke2lkfS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCR7a30gaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UmVzdWx0WyR7a31dID0gJHtpZH0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRvYy53cml0ZShgXG4gICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoJHtpZH0uaXNzdWVzLm1hcChpc3MgPT4gKHtcbiAgICAgICAgICAgIC4uLmlzcyxcbiAgICAgICAgICAgIHBhdGg6IGlzcy5wYXRoID8gWyR7a30sIC4uLmlzcy5wYXRoXSA6IFske2t9XVxuICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICgke2lkfS52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKCR7a30gaW4gaW5wdXQpIHtcbiAgICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3UmVzdWx0WyR7a31dID0gJHtpZH0udmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICBgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkb2Mud3JpdGUoYHBheWxvYWQudmFsdWUgPSBuZXdSZXN1bHQ7YCk7XG4gICAgICAgIGRvYy53cml0ZShgcmV0dXJuIHBheWxvYWQ7YCk7XG4gICAgICAgIGNvbnN0IGZuID0gZG9jLmNvbXBpbGUoKTtcbiAgICAgICAgcmV0dXJuIChwYXlsb2FkLCBjdHgpID0+IGZuKHNoYXBlLCBwYXlsb2FkLCBjdHgpO1xuICAgIH07XG4gICAgbGV0IGZhc3RwYXNzO1xuICAgIGNvbnN0IGlzT2JqZWN0ID0gdXRpbC5pc09iamVjdDtcbiAgICBjb25zdCBqaXQgPSAhY29yZS5nbG9iYWxDb25maWcuaml0bGVzcztcbiAgICBjb25zdCBhbGxvd3NFdmFsID0gdXRpbC5hbGxvd3NFdmFsO1xuICAgIGNvbnN0IGZhc3RFbmFibGVkID0gaml0ICYmIGFsbG93c0V2YWwudmFsdWU7IC8vICYmICFkZWYuY2F0Y2hhbGw7XG4gICAgY29uc3QgY2F0Y2hhbGwgPSBkZWYuY2F0Y2hhbGw7XG4gICAgbGV0IHZhbHVlO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgdmFsdWUgPz8gKHZhbHVlID0gX25vcm1hbGl6ZWQudmFsdWUpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChqaXQgJiYgZmFzdEVuYWJsZWQgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UgJiYgY3R4LmppdGxlc3MgIT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIGFsd2F5cyBzeW5jaHJvbm91c1xuICAgICAgICAgICAgaWYgKCFmYXN0cGFzcylcbiAgICAgICAgICAgICAgICBmYXN0cGFzcyA9IGdlbmVyYXRlRmFzdHBhc3MoZGVmLnNoYXBlKTtcbiAgICAgICAgICAgIHBheWxvYWQgPSBmYXN0cGFzcyhwYXlsb2FkLCBjdHgpO1xuICAgICAgICAgICAgaWYgKCFjYXRjaGFsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDYXRjaGFsbChbXSwgaW5wdXQsIHBheWxvYWQsIGN0eCwgdmFsdWUsIGluc3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdXBlclBhcnNlKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMsIGZpbmFsLCBpbnN0LCBjdHgpIHtcbiAgICBmb3IgKGNvbnN0IHJlc3VsdCBvZiByZXN1bHRzKSB7XG4gICAgICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZmluYWwudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gZmluYWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgbm9uYWJvcnRlZCA9IHJlc3VsdHMuZmlsdGVyKChyKSA9PiAhdXRpbC5hYm9ydGVkKHIpKTtcbiAgICBpZiAobm9uYWJvcnRlZC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZmluYWwudmFsdWUgPSBub25hYm9ydGVkWzBdLnZhbHVlO1xuICAgICAgICByZXR1cm4gbm9uYWJvcnRlZFswXTtcbiAgICB9XG4gICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICBjb2RlOiBcImludmFsaWRfdW5pb25cIixcbiAgICAgICAgaW5wdXQ6IGZpbmFsLnZhbHVlLFxuICAgICAgICBpbnN0LFxuICAgICAgICBlcnJvcnM6IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKSxcbiAgICB9KTtcbiAgICByZXR1cm4gZmluYWw7XG59XG5leHBvcnQgY29uc3QgJFpvZFVuaW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLm9wdGlvbnMuc29tZSgobykgPT4gby5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpID8gXCJvcHRpb25hbFwiIDogdW5kZWZpbmVkKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3B0aW9ucy5zb21lKChvKSA9PiBvLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCIpID8gXCJvcHRpb25hbFwiIDogdW5kZWZpbmVkKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIGlmIChkZWYub3B0aW9ucy5ldmVyeSgobykgPT4gby5fem9kLnZhbHVlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2V0KGRlZi5vcHRpb25zLmZsYXRNYXAoKG9wdGlvbikgPT4gQXJyYXkuZnJvbShvcHRpb24uX3pvZC52YWx1ZXMpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4ge1xuICAgICAgICBpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybnMgPSBkZWYub3B0aW9ucy5tYXAoKG8pID0+IG8uX3pvZC5wYXR0ZXJuKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBeKCR7cGF0dGVybnMubWFwKChwKSA9PiB1dGlsLmNsZWFuUmVnZXgocC5zb3VyY2UpKS5qb2luKFwifFwiKX0pJGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgY29uc3Qgc2luZ2xlID0gZGVmLm9wdGlvbnMubGVuZ3RoID09PSAxO1xuICAgIGNvbnN0IGZpcnN0ID0gZGVmLm9wdGlvbnNbMF0uX3pvZC5ydW47XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoc2luZ2xlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmlyc3QocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gb3B0aW9uLl96b2QucnVuKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpc3N1ZXM6IFtdLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYXN5bmMpXG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaGFuZGxlVW5pb25SZXN1bHRzKHJlc3VsdHMsIHBheWxvYWQsIGluc3QsIGN0eCk7XG4gICAgICAgIH0pO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZUV4Y2x1c2l2ZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBmaW5hbCwgaW5zdCwgY3R4KSB7XG4gICAgY29uc3Qgc3VjY2Vzc2VzID0gcmVzdWx0cy5maWx0ZXIoKHIpID0+IHIuaXNzdWVzLmxlbmd0aCA9PT0gMCk7XG4gICAgaWYgKHN1Y2Nlc3Nlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZmluYWwudmFsdWUgPSBzdWNjZXNzZXNbMF0udmFsdWU7XG4gICAgICAgIHJldHVybiBmaW5hbDtcbiAgICB9XG4gICAgaWYgKHN1Y2Nlc3Nlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gTm8gbWF0Y2hlcyAtIHNhbWUgYXMgcmVndWxhciB1bmlvblxuICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdW5pb25cIixcbiAgICAgICAgICAgIGlucHV0OiBmaW5hbC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICBlcnJvcnM6IHJlc3VsdHMubWFwKChyZXN1bHQpID0+IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBNdWx0aXBsZSBtYXRjaGVzIC0gZXhjbHVzaXZlIHVuaW9uIGZhaWx1cmVcbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgICAgICAgICBpbnB1dDogZmluYWwudmFsdWUsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgIGluY2x1c2l2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWw7XG59XG5leHBvcnQgY29uc3QgJFpvZFhvciA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kWG9yXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIGRlZi5pbmNsdXNpdmUgPSBmYWxzZTtcbiAgICBjb25zdCBzaW5nbGUgPSBkZWYub3B0aW9ucy5sZW5ndGggPT09IDE7XG4gICAgY29uc3QgZmlyc3QgPSBkZWYub3B0aW9uc1swXS5fem9kLnJ1bjtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChzaW5nbGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmaXJzdChwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhc3luYyA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZi5vcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBvcHRpb24uX3pvZC5ydW4oe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBhc3luYyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFzeW5jKVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4Y2x1c2l2ZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocmVzdWx0cykudGhlbigocmVzdWx0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUV4Y2x1c2l2ZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZERpc2NyaW1pbmF0ZWRVbmlvbiA9IFxuLypAX19QVVJFX18qL1xuY29yZS4kY29uc3RydWN0b3IoXCIkWm9kRGlzY3JpbWluYXRlZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBkZWYuaW5jbHVzaXZlID0gZmFsc2U7XG4gICAgJFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCBfc3VwZXIgPSBpbnN0Ll96b2QucGFyc2U7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcFZhbHVlcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgcHYgPSBvcHRpb24uX3pvZC5wcm9wVmFsdWVzO1xuICAgICAgICAgICAgaWYgKCFwdiB8fCBPYmplY3Qua2V5cyhwdikubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkaXNjcmltaW5hdGVkIHVuaW9uIG9wdGlvbiBhdCBpbmRleCBcIiR7ZGVmLm9wdGlvbnMuaW5kZXhPZihvcHRpb24pfVwiYCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhwdikpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByb3BWYWx1ZXNba10pXG4gICAgICAgICAgICAgICAgICAgIHByb3BWYWx1ZXNba10gPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2YWwgb2Ygdikge1xuICAgICAgICAgICAgICAgICAgICBwcm9wVmFsdWVzW2tdLmFkZCh2YWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcFZhbHVlcztcbiAgICB9KTtcbiAgICBjb25zdCBkaXNjID0gdXRpbC5jYWNoZWQoKCkgPT4ge1xuICAgICAgICBjb25zdCBvcHRzID0gZGVmLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBvIG9mIG9wdHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlcyA9IG8uX3pvZC5wcm9wVmFsdWVzPy5bZGVmLmRpc2NyaW1pbmF0b3JdO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZXMgfHwgdmFsdWVzLnNpemUgPT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpc2NyaW1pbmF0ZWQgdW5pb24gb3B0aW9uIGF0IGluZGV4IFwiJHtkZWYub3B0aW9ucy5pbmRleE9mKG8pfVwiYCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5oYXModikpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgZGlzY3JpbWluYXRvciB2YWx1ZSBcIiR7U3RyaW5nKHYpfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1hcC5zZXQodiwgbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCF1dGlsLmlzT2JqZWN0KGlucHV0KSkge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHQgPSBkaXNjLnZhbHVlLmdldChpbnB1dD8uW2RlZi5kaXNjcmltaW5hdG9yXSk7XG4gICAgICAgIGlmIChvcHQpIHtcbiAgICAgICAgICAgIHJldHVybiBvcHQuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVmLnVuaW9uRmFsbGJhY2spIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBubyBtYXRjaGluZyBkaXNjcmltaW5hdG9yXG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG4gICAgICAgICAgICBlcnJvcnM6IFtdLFxuICAgICAgICAgICAgbm90ZTogXCJObyBtYXRjaGluZyBkaXNjcmltaW5hdG9yXCIsXG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yOiBkZWYuZGlzY3JpbWluYXRvcixcbiAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgcGF0aDogW2RlZi5kaXNjcmltaW5hdG9yXSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEludGVyc2VjdGlvbiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kSW50ZXJzZWN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkZWYubGVmdC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dCwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICBjb25zdCByaWdodCA9IGRlZi5yaWdodC5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dCwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICBjb25zdCBhc3luYyA9IGxlZnQgaW5zdGFuY2VvZiBQcm9taXNlIHx8IHJpZ2h0IGluc3RhbmNlb2YgUHJvbWlzZTtcbiAgICAgICAgaWYgKGFzeW5jKSB7XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW2xlZnQsIHJpZ2h0XSkudGhlbigoW2xlZnQsIHJpZ2h0XSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHBheWxvYWQsIGxlZnQsIHJpZ2h0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVJbnRlcnNlY3Rpb25SZXN1bHRzKHBheWxvYWQsIGxlZnQsIHJpZ2h0KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBtZXJnZVZhbHVlcyhhLCBiKSB7XG4gICAgLy8gY29uc3QgYVR5cGUgPSBwYXJzZS50KGEpO1xuICAgIC8vIGNvbnN0IGJUeXBlID0gcGFyc2UudChiKTtcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogYSB9O1xuICAgIH1cbiAgICBpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUgJiYgK2EgPT09ICtiKSB7XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBhIH07XG4gICAgfVxuICAgIGlmICh1dGlsLmlzUGxhaW5PYmplY3QoYSkgJiYgdXRpbC5pc1BsYWluT2JqZWN0KGIpKSB7XG4gICAgICAgIGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG4gICAgICAgIGNvbnN0IHNoYXJlZEtleXMgPSBPYmplY3Qua2V5cyhhKS5maWx0ZXIoKGtleSkgPT4gYktleXMuaW5kZXhPZihrZXkpICE9PSAtMSk7XG4gICAgICAgIGNvbnN0IG5ld09iaiA9IHsgLi4uYSwgLi4uYiB9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBzaGFyZWRLZXlzKSB7XG4gICAgICAgICAgICBjb25zdCBzaGFyZWRWYWx1ZSA9IG1lcmdlVmFsdWVzKGFba2V5XSwgYltrZXldKTtcbiAgICAgICAgICAgIGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lcmdlRXJyb3JQYXRoOiBba2V5LCAuLi5zaGFyZWRWYWx1ZS5tZXJnZUVycm9yUGF0aF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5ld09ialtrZXldID0gc2hhcmVkVmFsdWUuZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB2YWxpZDogdHJ1ZSwgZGF0YTogbmV3T2JqIH07XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KGEpICYmIEFycmF5LmlzQXJyYXkoYikpIHtcbiAgICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsaWQ6IGZhbHNlLCBtZXJnZUVycm9yUGF0aDogW10gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdBcnJheSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgYS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW1BID0gYVtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBpdGVtQiA9IGJbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhpdGVtQSwgaXRlbUIpO1xuICAgICAgICAgICAgaWYgKCFzaGFyZWRWYWx1ZS52YWxpZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbGlkOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWVyZ2VFcnJvclBhdGg6IFtpbmRleCwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdBcnJheS5wdXNoKHNoYXJlZFZhbHVlLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbGlkOiB0cnVlLCBkYXRhOiBuZXdBcnJheSB9O1xuICAgIH1cbiAgICByZXR1cm4geyB2YWxpZDogZmFsc2UsIG1lcmdlRXJyb3JQYXRoOiBbXSB9O1xufVxuZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhyZXN1bHQsIGxlZnQsIHJpZ2h0KSB7XG4gICAgLy8gVHJhY2sgd2hpY2ggc2lkZShzKSByZXBvcnQgZWFjaCBrZXkgYXMgdW5yZWNvZ25pemVkXG4gICAgY29uc3QgdW5yZWNLZXlzID0gbmV3IE1hcCgpO1xuICAgIGxldCB1bnJlY0lzc3VlO1xuICAgIGZvciAoY29uc3QgaXNzIG9mIGxlZnQuaXNzdWVzKSB7XG4gICAgICAgIGlmIChpc3MuY29kZSA9PT0gXCJ1bnJlY29nbml6ZWRfa2V5c1wiKSB7XG4gICAgICAgICAgICB1bnJlY0lzc3VlID8/ICh1bnJlY0lzc3VlID0gaXNzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgayBvZiBpc3Mua2V5cykge1xuICAgICAgICAgICAgICAgIGlmICghdW5yZWNLZXlzLmhhcyhrKSlcbiAgICAgICAgICAgICAgICAgICAgdW5yZWNLZXlzLnNldChrLCB7fSk7XG4gICAgICAgICAgICAgICAgdW5yZWNLZXlzLmdldChrKS5sID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5pc3N1ZXMucHVzaChpc3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgaXNzIG9mIHJpZ2h0Lmlzc3Vlcykge1xuICAgICAgICBpZiAoaXNzLmNvZGUgPT09IFwidW5yZWNvZ25pemVkX2tleXNcIikge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIGlzcy5rZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF1bnJlY0tleXMuaGFzKGspKVxuICAgICAgICAgICAgICAgICAgICB1bnJlY0tleXMuc2V0KGssIHt9KTtcbiAgICAgICAgICAgICAgICB1bnJlY0tleXMuZ2V0KGspLnIgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0Lmlzc3Vlcy5wdXNoKGlzcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gUmVwb3J0IG9ubHkga2V5cyB1bnJlY29nbml6ZWQgYnkgQk9USCBzaWRlc1xuICAgIGNvbnN0IGJvdGhLZXlzID0gWy4uLnVucmVjS2V5c10uZmlsdGVyKChbLCBmXSkgPT4gZi5sICYmIGYucikubWFwKChba10pID0+IGspO1xuICAgIGlmIChib3RoS2V5cy5sZW5ndGggJiYgdW5yZWNJc3N1ZSkge1xuICAgICAgICByZXN1bHQuaXNzdWVzLnB1c2goeyAuLi51bnJlY0lzc3VlLCBrZXlzOiBib3RoS2V5cyB9KTtcbiAgICB9XG4gICAgaWYgKHV0aWwuYWJvcnRlZChyZXN1bHQpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlVmFsdWVzKGxlZnQudmFsdWUsIHJpZ2h0LnZhbHVlKTtcbiAgICBpZiAoIW1lcmdlZC52YWxpZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVubWVyZ2FibGUgaW50ZXJzZWN0aW9uLiBFcnJvciBwYXRoOiBgICsgYCR7SlNPTi5zdHJpbmdpZnkobWVyZ2VkLm1lcmdlRXJyb3JQYXRoKX1gKTtcbiAgICB9XG4gICAgcmVzdWx0LnZhbHVlID0gbWVyZ2VkLmRhdGE7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kVHVwbGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFR1cGxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgY29uc3QgaXRlbXMgPSBkZWYuaXRlbXM7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gW107XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIGNvbnN0IHJldmVyc2VkSW5kZXggPSBbLi4uaXRlbXNdLnJldmVyc2UoKS5maW5kSW5kZXgoKGl0ZW0pID0+IGl0ZW0uX3pvZC5vcHRpbiAhPT0gXCJvcHRpb25hbFwiKTtcbiAgICAgICAgY29uc3Qgb3B0U3RhcnQgPSByZXZlcnNlZEluZGV4ID09PSAtMSA/IDAgOiBpdGVtcy5sZW5ndGggLSByZXZlcnNlZEluZGV4O1xuICAgICAgICBpZiAoIWRlZi5yZXN0KSB7XG4gICAgICAgICAgICBjb25zdCB0b29CaWcgPSBpbnB1dC5sZW5ndGggPiBpdGVtcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCB0b29TbWFsbCA9IGlucHV0Lmxlbmd0aCA8IG9wdFN0YXJ0IC0gMTtcbiAgICAgICAgICAgIGlmICh0b29CaWcgfHwgdG9vU21hbGwpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgLi4uKHRvb0JpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IGNvZGU6IFwidG9vX2JpZ1wiLCBtYXhpbXVtOiBpdGVtcy5sZW5ndGgsIGluY2x1c2l2ZTogdHJ1ZSB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgY29kZTogXCJ0b29fc21hbGxcIiwgbWluaW11bTogaXRlbXMubGVuZ3RoIH0pLFxuICAgICAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcImFycmF5XCIsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSAtMTtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBpZiAoaSA+PSBpbnB1dC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgaWYgKGkgPj0gb3B0U3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gaXRlbS5fem9kLnJ1bih7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGlucHV0W2ldLFxuICAgICAgICAgICAgICAgIGlzc3VlczogW10sXG4gICAgICAgICAgICB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZVR1cGxlUmVzdWx0KHJlc3VsdCwgcGF5bG9hZCwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5yZXN0KSB7XG4gICAgICAgICAgICBjb25zdCByZXN0ID0gaW5wdXQuc2xpY2UoaXRlbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgcmVzdCkge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYucmVzdC5fem9kLnJ1bih7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgaXNzdWVzOiBbXSxcbiAgICAgICAgICAgICAgICB9LCBjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlVHVwbGVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlVHVwbGVSZXN1bHQocmVzdWx0LCBwYXlsb2FkLCBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlVHVwbGVSZXN1bHQocmVzdWx0LCBmaW5hbCwgaW5kZXgpIHtcbiAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoaW5kZXgsIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICB9XG4gICAgZmluYWwudmFsdWVbaW5kZXhdID0gcmVzdWx0LnZhbHVlO1xufVxuZXhwb3J0IGNvbnN0ICRab2RSZWNvcmQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFJlY29yZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAoIXV0aWwuaXNQbGFpbk9iamVjdChpbnB1dCkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInJlY29yZFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvbXMgPSBbXTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gZGVmLmtleVR5cGUuX3pvZC52YWx1ZXM7XG4gICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IHJlY29yZEtleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2Yga2V5ID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiBrZXkgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3JkS2V5cy5hZGQodHlwZW9mIGtleSA9PT0gXCJudW1iZXJcIiA/IGtleS50b1N0cmluZygpIDoga2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLnZhbHVlVHlwZS5fem9kLnJ1bih7IHZhbHVlOiBpbnB1dFtrZXldLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9tcy5wdXNoKHJlc3VsdC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCB1bnJlY29nbml6ZWQ7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgICAgIGlmICghcmVjb3JkS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB1bnJlY29nbml6ZWQgPSB1bnJlY29nbml6ZWQgPz8gW107XG4gICAgICAgICAgICAgICAgICAgIHVucmVjb2duaXplZC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVucmVjb2duaXplZCAmJiB1bnJlY29nbml6ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcInVucmVjb2duaXplZF9rZXlzXCIsXG4gICAgICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICBrZXlzOiB1bnJlY29nbml6ZWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBSZWZsZWN0Lm93bktleXMoaW5wdXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJfX3Byb3RvX19cIilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgbGV0IGtleVJlc3VsdCA9IGRlZi5rZXlUeXBlLl96b2QucnVuKHsgdmFsdWU6IGtleSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFzeW5jIHNjaGVtYXMgbm90IHN1cHBvcnRlZCBpbiBvYmplY3Qga2V5cyBjdXJyZW50bHlcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIE51bWVyaWMgc3RyaW5nIGZhbGxiYWNrOiBpZiBrZXkgaXMgYSBudW1lcmljIHN0cmluZyBhbmQgZmFpbGVkLCByZXRyeSB3aXRoIE51bWJlcihrZXkpXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHoubnVtYmVyKCksIHoubGl0ZXJhbChbMSwgMiwgM10pLCBhbmQgdW5pb25zIGNvbnRhaW5pbmcgbnVtZXJpYyBsaXRlcmFsc1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoZWNrTnVtZXJpY0tleSA9IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgcmVnZXhlcy5udW1iZXIudGVzdChrZXkpICYmIGtleVJlc3VsdC5pc3N1ZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChjaGVja051bWVyaWNLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlSZXN1bHQgPSBkZWYua2V5VHlwZS5fem9kLnJ1bih7IHZhbHVlOiBOdW1iZXIoa2V5KSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmV0cnlSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBc3luYyBzY2hlbWFzIG5vdCBzdXBwb3J0ZWQgaW4gb2JqZWN0IGtleXMgY3VycmVudGx5XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXRyeVJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlSZXN1bHQgPSByZXRyeVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoa2V5UmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZi5tb2RlID09PSBcImxvb3NlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB1bmNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWVba2V5XSA9IGlucHV0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEZWZhdWx0IFwic3RyaWN0XCIgYmVoYXZpb3I6IGVycm9yIG9uIGludmFsaWQga2V5XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfa2V5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBcInJlY29yZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzc3Vlczoga2V5UmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi52YWx1ZVR5cGUuX3pvZC5ydW4oeyB2YWx1ZTogaW5wdXRba2V5XSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCguLi51dGlsLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWVba2V5UmVzdWx0LnZhbHVlXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKC4uLnV0aWwucHJlZml4SXNzdWVzKGtleSwgcmVzdWx0Lmlzc3VlcykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWVba2V5UmVzdWx0LnZhbHVlXSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb21zLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kTWFwID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RNYXBcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBNYXApKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJtYXBcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgICAgIGlucHV0LFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIGlucHV0KSB7XG4gICAgICAgICAgICBjb25zdCBrZXlSZXN1bHQgPSBkZWYua2V5VHlwZS5fem9kLnJ1bih7IHZhbHVlOiBrZXksIGlzc3VlczogW10gfSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlUmVzdWx0ID0gZGVmLnZhbHVlVHlwZS5fem9kLnJ1bih7IHZhbHVlOiB2YWx1ZSwgaXNzdWVzOiBbXSB9LCBjdHgpO1xuICAgICAgICAgICAgaWYgKGtleVJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UgfHwgdmFsdWVSZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcHJvbXMucHVzaChQcm9taXNlLmFsbChba2V5UmVzdWx0LCB2YWx1ZVJlc3VsdF0pLnRoZW4oKFtrZXlSZXN1bHQsIHZhbHVlUmVzdWx0XSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVNYXBSZXN1bHQoa2V5UmVzdWx0LCB2YWx1ZVJlc3VsdCwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaW5zdCwgY3R4KTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVNYXBSZXN1bHQoa2V5UmVzdWx0LCB2YWx1ZVJlc3VsdCwgcGF5bG9hZCwga2V5LCBpbnB1dCwgaW5zdCwgY3R4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVNYXBSZXN1bHQoa2V5UmVzdWx0LCB2YWx1ZVJlc3VsdCwgZmluYWwsIGtleSwgaW5wdXQsIGluc3QsIGN0eCkge1xuICAgIGlmIChrZXlSZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodXRpbC5wcm9wZXJ0eUtleVR5cGVzLmhhcyh0eXBlb2Yga2V5KSkge1xuICAgICAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCBrZXlSZXN1bHQuaXNzdWVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2tleVwiLFxuICAgICAgICAgICAgICAgIG9yaWdpbjogXCJtYXBcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGlzc3Vlczoga2V5UmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gdXRpbC5maW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb3JlLmNvbmZpZygpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWVSZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBpZiAodXRpbC5wcm9wZXJ0eUtleVR5cGVzLmhhcyh0eXBlb2Yga2V5KSkge1xuICAgICAgICAgICAgZmluYWwuaXNzdWVzLnB1c2goLi4udXRpbC5wcmVmaXhJc3N1ZXMoa2V5LCB2YWx1ZVJlc3VsdC5pc3N1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpbmFsLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBvcmlnaW46IFwibWFwXCIsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2VsZW1lbnRcIixcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgIGlzc3VlczogdmFsdWVSZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiB1dGlsLmZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvcmUuY29uZmlnKCkpKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmFsLnZhbHVlLnNldChrZXlSZXN1bHQudmFsdWUsIHZhbHVlUmVzdWx0LnZhbHVlKTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kU2V0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RTZXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKCEoaW5wdXQgaW5zdGFuY2VvZiBTZXQpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcInNldFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21zID0gW107XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBpbnB1dCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVmLnZhbHVlVHlwZS5fem9kLnJ1bih7IHZhbHVlOiBpdGVtLCBpc3N1ZXM6IFtdIH0sIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHByb21zLnB1c2gocmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4gaGFuZGxlU2V0UmVzdWx0KHJlc3VsdCwgcGF5bG9hZCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoYW5kbGVTZXRSZXN1bHQocmVzdWx0LCBwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbXMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21zKS50aGVuKCgpID0+IHBheWxvYWQpO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVTZXRSZXN1bHQocmVzdWx0LCBmaW5hbCkge1xuICAgIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICBmaW5hbC5pc3N1ZXMucHVzaCguLi5yZXN1bHQuaXNzdWVzKTtcbiAgICB9XG4gICAgZmluYWwudmFsdWUuYWRkKHJlc3VsdC52YWx1ZSk7XG59XG5leHBvcnQgY29uc3QgJFpvZEVudW0gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEVudW1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCB2YWx1ZXMgPSB1dGlsLmdldEVudW1WYWx1ZXMoZGVmLmVudHJpZXMpO1xuICAgIGNvbnN0IHZhbHVlc1NldCA9IG5ldyBTZXQodmFsdWVzKTtcbiAgICBpbnN0Ll96b2QudmFsdWVzID0gdmFsdWVzU2V0O1xuICAgIGluc3QuX3pvZC5wYXR0ZXJuID0gbmV3IFJlZ0V4cChgXigke3ZhbHVlc1xuICAgICAgICAuZmlsdGVyKChrKSA9PiB1dGlsLnByb3BlcnR5S2V5VHlwZXMuaGFzKHR5cGVvZiBrKSlcbiAgICAgICAgLm1hcCgobykgPT4gKHR5cGVvZiBvID09PSBcInN0cmluZ1wiID8gdXRpbC5lc2NhcGVSZWdleChvKSA6IG8udG9TdHJpbmcoKSkpXG4gICAgICAgIC5qb2luKFwifFwiKX0pJGApO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlc1NldC5oYXMoaW5wdXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgICAgICAgICAgdmFsdWVzLFxuICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICBpbnN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RMaXRlcmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RMaXRlcmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaWYgKGRlZi52YWx1ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBjcmVhdGUgbGl0ZXJhbCBzY2hlbWEgd2l0aCBubyB2YWxpZCB2YWx1ZXNcIik7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IG5ldyBTZXQoZGVmLnZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnZhbHVlcyA9IHZhbHVlcztcbiAgICBpbnN0Ll96b2QucGF0dGVybiA9IG5ldyBSZWdFeHAoYF4oJHtkZWYudmFsdWVzXG4gICAgICAgIC5tYXAoKG8pID0+ICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIiA/IHV0aWwuZXNjYXBlUmVnZXgobykgOiBvID8gdXRpbC5lc2NhcGVSZWdleChvLnRvU3RyaW5nKCkpIDogU3RyaW5nKG8pKSlcbiAgICAgICAgLmpvaW4oXCJ8XCIpfSkkYCk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgY29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuICAgICAgICBpZiAodmFsdWVzLmhhcyhpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3ZhbHVlXCIsXG4gICAgICAgICAgICB2YWx1ZXM6IGRlZi52YWx1ZXMsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZEZpbGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEZpbGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGlucHV0IGluc3RhbmNlb2YgRmlsZSlcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcImZpbGVcIixcbiAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZFRyYW5zZm9ybSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kVHJhbnNmb3JtXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kRW5jb2RlRXJyb3IoaW5zdC5jb25zdHJ1Y3Rvci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBfb3V0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICAgICAgaWYgKGN0eC5hc3luYykge1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gX291dCBpbnN0YW5jZW9mIFByb21pc2UgPyBfb3V0IDogUHJvbWlzZS5yZXNvbHZlKF9vdXQpO1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9vdXQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgY29yZS4kWm9kQXN5bmNFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSBfb3V0O1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVPcHRpb25hbFJlc3VsdChyZXN1bHQsIGlucHV0KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoICYmIGlucHV0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHsgaXNzdWVzOiBbXSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNvbnN0ICRab2RPcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG4gICAgaW5zdC5fem9kLm9wdG91dCA9IFwib3B0aW9uYWxcIjtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzID8gbmV3IFNldChbLi4uZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcywgdW5kZWZpbmVkXSkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuICAgICAgICByZXR1cm4gcGF0dGVybiA/IG5ldyBSZWdFeHAoYF4oJHt1dGlsLmNsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfSk/JGApIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHIpID0+IGhhbmRsZU9wdGlvbmFsUmVzdWx0KHIsIHBheWxvYWQudmFsdWUpKTtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVPcHRpb25hbFJlc3VsdChyZXN1bHQsIHBheWxvYWQudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXlsb2FkLnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RFeGFjdE9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RFeGFjdE9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBDYWxsIHBhcmVudCBpbml0IC0gaW5oZXJpdHMgb3B0aW4vb3B0b3V0ID0gXCJvcHRpb25hbFwiXG4gICAgJFpvZE9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcbiAgICAvLyBPdmVycmlkZSB2YWx1ZXMvcGF0dGVybiB0byBOT1QgYWRkIHVuZGVmaW5lZFxuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QucGF0dGVybik7XG4gICAgLy8gT3ZlcnJpZGUgcGFyc2UgdG8ganVzdCBkZWxlZ2F0ZSAobm8gdW5kZWZpbmVkIGhhbmRsaW5nKVxuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE51bGxhYmxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdGluKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInBhdHRlcm5cIiwgKCkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm47XG4gICAgICAgIHJldHVybiBwYXR0ZXJuID8gbmV3IFJlZ0V4cChgXigke3V0aWwuY2xlYW5SZWdleChwYXR0ZXJuLnNvdXJjZSl9fG51bGwpJGApIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyBuZXcgU2V0KFsuLi5kZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzLCBudWxsXSkgOiB1bmRlZmluZWQ7XG4gICAgfSk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICAvLyBGb3J3YXJkIGRpcmVjdGlvbiAoZGVjb2RlKTogYWxsb3cgbnVsbCB0byBwYXNzIHRocm91Z2hcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZERlZmF1bHQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZERlZmF1bHRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICAvLyBpbnN0Ll96b2QucWluID0gXCJ0cnVlXCI7XG4gICAgaW5zdC5fem9kLm9wdGluID0gXCJvcHRpb25hbFwiO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3J3YXJkIGRpcmVjdGlvbiAoZGVjb2RlKTogYXBwbHkgZGVmYXVsdHMgZm9yIHVuZGVmaW5lZCBpbnB1dFxuICAgICAgICBpZiAocGF5bG9hZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogJFpvZERlZmF1bHQgcmV0dXJucyB0aGUgZGVmYXVsdCB2YWx1ZSBpbW1lZGlhdGVseSBpbiBmb3J3YXJkIGRpcmVjdGlvbi5cbiAgICAgICAgICAgICAqIEl0IGRvZXNuJ3QgcGFzcyB0aGUgZGVmYXVsdCB2YWx1ZSBpbnRvIHRoZSB2YWxpZGF0b3IgKFwicHJlZmF1bHRcIikuIFRoZXJlJ3Mgbm8gcmVhc29uIHRvIHBhc3MgdGhlIGRlZmF1bHQgdmFsdWUgdGhyb3VnaCB2YWxpZGF0aW9uLiBUaGUgdmFsaWRpdHkgb2YgdGhlIGRlZmF1bHQgaXMgZW5mb3JjZWQgYnkgVHlwZVNjcmlwdCBzdGF0aWNhbGx5LiBPdGhlcndpc2UsIGl0J3MgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIHRoZSB1c2VyIHRvIGVuc3VyZSB0aGUgZGVmYXVsdCBpcyB2YWxpZC4gSW4gdGhlIGNhc2Ugb2YgcGlwZXMgd2l0aCBkaXZlcmdlbnQgaW4vb3V0IHR5cGVzLCB5b3UgY2FuIHNwZWNpZnkgdGhlIGRlZmF1bHQgb24gdGhlIGBpbmAgc2NoZW1hIG9mIHlvdXIgWm9kUGlwZSB0byBzZXQgYSBcInByZWZhdWx0XCIgZm9yIHRoZSBwaXBlLiAgICovXG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3J3YXJkIGRpcmVjdGlvbjogY29udGludWUgd2l0aCBkZWZhdWx0IGhhbmRsaW5nXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVEZWZhdWx0UmVzdWx0KHJlc3VsdCwgZGVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhhbmRsZURlZmF1bHRSZXN1bHQocmVzdWx0LCBkZWYpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZURlZmF1bHRSZXN1bHQocGF5bG9hZCwgZGVmKSB7XG4gICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5leHBvcnQgY29uc3QgJFpvZFByZWZhdWx0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RQcmVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGlmIChjdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRm9yd2FyZCBkaXJlY3Rpb24gKGRlY29kZSk6IGFwcGx5IHByZWZhdWx0IGZvciB1bmRlZmluZWQgaW5wdXRcbiAgICAgICAgaWYgKHBheWxvYWQudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGRlZi5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZE5vbk9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2ROb25PcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcbiAgICAgICAgY29uc3QgdiA9IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXM7XG4gICAgICAgIHJldHVybiB2ID8gbmV3IFNldChbLi4udl0uZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0KSA9PiBoYW5kbGVOb25PcHRpb25hbFJlc3VsdChyZXN1bHQsIGluc3QpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnN0KTtcbiAgICB9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVOb25PcHRpb25hbFJlc3VsdChwYXlsb2FkLCBpbnN0KSB7XG4gICAgaWYgKCFwYXlsb2FkLmlzc3Vlcy5sZW5ndGggJiYgcGF5bG9hZC52YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5vbm9wdGlvbmFsXCIsXG4gICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgIGluc3QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kU3VjY2VzcyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kU3VjY2Vzc1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGNvcmUuJFpvZEVuY29kZUVycm9yKFwiWm9kU3VjY2Vzc1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSByZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQudmFsdWUgPSByZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2RDYXRjaCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kQ2F0Y2hcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdG91dCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LmRpcmVjdGlvbiA9PT0gXCJiYWNrd2FyZFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZvcndhcmQgZGlyZWN0aW9uIChkZWNvZGUpOiBhcHBseSBjYXRjaCBsb2dpY1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5wYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwYXlsb2FkLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG4gICAgICAgICAgICAgICAgLi4ucGF5bG9hZCxcbiAgICAgICAgICAgICAgICBlcnJvcjoge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZXM6IHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IHV0aWwuZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29yZS5jb25maWcoKSkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGNvbnN0ICRab2ROYU4gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZE5hTlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC52YWx1ZSAhPT0gXCJudW1iZXJcIiB8fCAhTnVtYmVyLmlzTmFOKHBheWxvYWQudmFsdWUpKSB7XG4gICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpbnB1dDogcGF5bG9hZC52YWx1ZSxcbiAgICAgICAgICAgICAgICBpbnN0LFxuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcIm5hblwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kUGlwZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kUGlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbi5fem9kLnZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW4uX3pvZC5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLm91dC5fem9kLm9wdG91dCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IGRlZi5pbi5fem9kLnByb3BWYWx1ZXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSBkZWYub3V0Ll96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0LnRoZW4oKHJpZ2h0KSA9PiBoYW5kbGVQaXBlUmVzdWx0KHJpZ2h0LCBkZWYuaW4sIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVBpcGVSZXN1bHQocmlnaHQsIGRlZi5pbiwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZWZ0ID0gZGVmLmluLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxlZnQudGhlbigobGVmdCkgPT4gaGFuZGxlUGlwZVJlc3VsdChsZWZ0LCBkZWYub3V0LCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlUGlwZVJlc3VsdChsZWZ0LCBkZWYub3V0LCBjdHgpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgbmV4dCwgY3R4KSB7XG4gICAgaWYgKGxlZnQuaXNzdWVzLmxlbmd0aCkge1xuICAgICAgICAvLyBwcmV2ZW50IGZ1cnRoZXIgY2hlY2tzXG4gICAgICAgIGxlZnQuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybiBsZWZ0O1xuICAgIH1cbiAgICByZXR1cm4gbmV4dC5fem9kLnJ1bih7IHZhbHVlOiBsZWZ0LnZhbHVlLCBpc3N1ZXM6IGxlZnQuaXNzdWVzIH0sIGN0eCk7XG59XG5leHBvcnQgY29uc3QgJFpvZENvZGVjID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDb2RlY1wiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IGRlZi5pbi5fem9kLnZhbHVlcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW4uX3pvZC5vcHRpbik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gZGVmLm91dC5fem9kLm9wdG91dCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IGRlZi5pbi5fem9kLnByb3BWYWx1ZXMpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gY3R4LmRpcmVjdGlvbiB8fCBcImZvcndhcmRcIjtcbiAgICAgICAgaWYgKGRpcmVjdGlvbiA9PT0gXCJmb3J3YXJkXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBkZWYuaW4uX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmIChsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0LnRoZW4oKGxlZnQpID0+IGhhbmRsZUNvZGVjQVJlc3VsdChsZWZ0LCBkZWYsIGN0eCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZUNvZGVjQVJlc3VsdChsZWZ0LCBkZWYsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCByaWdodCA9IGRlZi5vdXQuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgICAgIGlmIChyaWdodCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHQudGhlbigocmlnaHQpID0+IGhhbmRsZUNvZGVjQVJlc3VsdChyaWdodCwgZGVmLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVDb2RlY0FSZXN1bHQocmlnaHQsIGRlZiwgY3R4KTtcbiAgICAgICAgfVxuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZUNvZGVjQVJlc3VsdChyZXN1bHQsIGRlZiwgY3R4KSB7XG4gICAgaWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgIC8vIHByZXZlbnQgZnVydGhlciBjaGVja3NcbiAgICAgICAgcmVzdWx0LmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBkaXJlY3Rpb24gPSBjdHguZGlyZWN0aW9uIHx8IFwiZm9yd2FyZFwiO1xuICAgIGlmIChkaXJlY3Rpb24gPT09IFwiZm9yd2FyZFwiKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybWVkID0gZGVmLnRyYW5zZm9ybShyZXN1bHQudmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZC50aGVuKCh2YWx1ZSkgPT4gaGFuZGxlQ29kZWNUeFJlc3VsdChyZXN1bHQsIHZhbHVlLCBkZWYub3V0LCBjdHgpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGFuZGxlQ29kZWNUeFJlc3VsdChyZXN1bHQsIHRyYW5zZm9ybWVkLCBkZWYub3V0LCBjdHgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBkZWYucmV2ZXJzZVRyYW5zZm9ybShyZXN1bHQudmFsdWUsIHJlc3VsdCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1lZCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1lZC50aGVuKCh2YWx1ZSkgPT4gaGFuZGxlQ29kZWNUeFJlc3VsdChyZXN1bHQsIHZhbHVlLCBkZWYuaW4sIGN0eCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVDb2RlY1R4UmVzdWx0KHJlc3VsdCwgdHJhbnNmb3JtZWQsIGRlZi5pbiwgY3R4KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVDb2RlY1R4UmVzdWx0KGxlZnQsIHZhbHVlLCBuZXh0U2NoZW1hLCBjdHgpIHtcbiAgICAvLyBDaGVjayBpZiB0cmFuc2Zvcm0gYWRkZWQgYW55IGlzc3Vlc1xuICAgIGlmIChsZWZ0Lmlzc3Vlcy5sZW5ndGgpIHtcbiAgICAgICAgbGVmdC5hYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGxlZnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXh0U2NoZW1hLl96b2QucnVuKHsgdmFsdWUsIGlzc3VlczogbGVmdC5pc3N1ZXMgfSwgY3R4KTtcbn1cbmV4cG9ydCBjb25zdCAkWm9kUmVhZG9ubHkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwcm9wVmFsdWVzXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5wcm9wVmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGU/Ll96b2Q/Lm9wdGluKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlPy5fem9kPy5vcHRvdXQpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgaWYgKGN0eC5kaXJlY3Rpb24gPT09IFwiYmFja3dhcmRcIikge1xuICAgICAgICAgICAgcmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG4gICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0LnRoZW4oaGFuZGxlUmVhZG9ubHlSZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVSZWFkb25seVJlc3VsdChyZXN1bHQpO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVJlYWRvbmx5UmVzdWx0KHBheWxvYWQpIHtcbiAgICBwYXlsb2FkLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShwYXlsb2FkLnZhbHVlKTtcbiAgICByZXR1cm4gcGF5bG9hZDtcbn1cbmV4cG9ydCBjb25zdCAkWm9kVGVtcGxhdGVMaXRlcmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RUZW1wbGF0ZUxpdGVyYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb25zdCByZWdleFBhcnRzID0gW107XG4gICAgZm9yIChjb25zdCBwYXJ0IG9mIGRlZi5wYXJ0cykge1xuICAgICAgICBpZiAodHlwZW9mIHBhcnQgPT09IFwib2JqZWN0XCIgJiYgcGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gaXMgWm9kIHNjaGVtYVxuICAgICAgICAgICAgaWYgKCFwYXJ0Ll96b2QucGF0dGVybikge1xuICAgICAgICAgICAgICAgIC8vIGlmICghc291cmNlKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZW1wbGF0ZSBsaXRlcmFsIHBhcnQsIG5vIHBhdHRlcm4gZm91bmQ6ICR7Wy4uLnBhcnQuX3pvZC50cmFpdHNdLnNoaWZ0KCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBwYXJ0Ll96b2QucGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCA/IHBhcnQuX3pvZC5wYXR0ZXJuLnNvdXJjZSA6IHBhcnQuX3pvZC5wYXR0ZXJuO1xuICAgICAgICAgICAgaWYgKCFzb3VyY2UpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHRlbXBsYXRlIGxpdGVyYWwgcGFydDogJHtwYXJ0Ll96b2QudHJhaXRzfWApO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBzb3VyY2Uuc3RhcnRzV2l0aChcIl5cIikgPyAxIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHNvdXJjZS5lbmRzV2l0aChcIiRcIikgPyBzb3VyY2UubGVuZ3RoIC0gMSA6IHNvdXJjZS5sZW5ndGg7XG4gICAgICAgICAgICByZWdleFBhcnRzLnB1c2goc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJ0ID09PSBudWxsIHx8IHV0aWwucHJpbWl0aXZlVHlwZXMuaGFzKHR5cGVvZiBwYXJ0KSkge1xuICAgICAgICAgICAgcmVnZXhQYXJ0cy5wdXNoKHV0aWwuZXNjYXBlUmVnZXgoYCR7cGFydH1gKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdGVtcGxhdGUgbGl0ZXJhbCBwYXJ0OiAke3BhcnR9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5zdC5fem9kLnBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeJHtyZWdleFBhcnRzLmpvaW4oXCJcIil9JGApO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF5bG9hZC52YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgaW5zdCxcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJzdHJpbmdcIixcbiAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgICAgICBpbnN0Ll96b2QucGF0dGVybi5sYXN0SW5kZXggPSAwO1xuICAgICAgICBpZiAoIWluc3QuX3pvZC5wYXR0ZXJuLnRlc3QocGF5bG9hZC52YWx1ZSkpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgICAgICAgICAgICAgIGZvcm1hdDogZGVmLmZvcm1hdCA/PyBcInRlbXBsYXRlX2xpdGVyYWxcIixcbiAgICAgICAgICAgICAgICBwYXR0ZXJuOiBpbnN0Ll96b2QucGF0dGVybi5zb3VyY2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kRnVuY3Rpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZEZ1bmN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fZGVmID0gZGVmO1xuICAgIGluc3QuX3pvZC5kZWYgPSBkZWY7XG4gICAgaW5zdC5pbXBsZW1lbnQgPSAoZnVuYykgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW1wbGVtZW50KCkgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoLi4uYXJncykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VkQXJncyA9IGluc3QuX2RlZi5pbnB1dCA/IHBhcnNlKGluc3QuX2RlZi5pbnB1dCwgYXJncykgOiBhcmdzO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gUmVmbGVjdC5hcHBseShmdW5jLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgIGlmIChpbnN0Ll9kZWYub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlKGluc3QuX2RlZi5vdXRwdXQsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgIH07XG4gICAgaW5zdC5pbXBsZW1lbnRBc3luYyA9IChmdW5jKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgZnVuYyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbXBsZW1lbnRBc3luYygpIG11c3QgYmUgY2FsbGVkIHdpdGggYSBmdW5jdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXN5bmMgZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEFyZ3MgPSBpbnN0Ll9kZWYuaW5wdXQgPyBhd2FpdCBwYXJzZUFzeW5jKGluc3QuX2RlZi5pbnB1dCwgYXJncykgOiBhcmdzO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgUmVmbGVjdC5hcHBseShmdW5jLCB0aGlzLCBwYXJzZWRBcmdzKTtcbiAgICAgICAgICAgIGlmIChpbnN0Ll9kZWYub3V0cHV0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHBhcnNlQXN5bmMoaW5zdC5fZGVmLm91dHB1dCwgcmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQudmFsdWUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgY29kZTogXCJpbnZhbGlkX3R5cGVcIixcbiAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIG91dHB1dCBpcyBhIHByb21pc2UgdHlwZSB0byBkZXRlcm1pbmUgaWYgd2Ugc2hvdWxkIHVzZSBhc3luYyBpbXBsZW1lbnRhdGlvblxuICAgICAgICBjb25zdCBoYXNQcm9taXNlT3V0cHV0ID0gaW5zdC5fZGVmLm91dHB1dCAmJiBpbnN0Ll9kZWYub3V0cHV0Ll96b2QuZGVmLnR5cGUgPT09IFwicHJvbWlzZVwiO1xuICAgICAgICBpZiAoaGFzUHJvbWlzZU91dHB1dCkge1xuICAgICAgICAgICAgcGF5bG9hZC52YWx1ZSA9IGluc3QuaW1wbGVtZW50QXN5bmMocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gaW5zdC5pbXBsZW1lbnQocGF5bG9hZC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbiAgICBpbnN0LmlucHV0ID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgRiA9IGluc3QuY29uc3RydWN0b3I7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZ3NbMF0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEYoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICBpbnB1dDogbmV3ICRab2RUdXBsZSh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgICAgICAgICAgICAgaXRlbXM6IGFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgIHJlc3Q6IGFyZ3NbMV0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBpbnN0Ll9kZWYub3V0cHV0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGlucHV0OiBhcmdzWzBdLFxuICAgICAgICAgICAgb3V0cHV0OiBpbnN0Ll9kZWYub3V0cHV0LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGluc3Qub3V0cHV0ID0gKG91dHB1dCkgPT4ge1xuICAgICAgICBjb25zdCBGID0gaW5zdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgcmV0dXJuIG5ldyBGKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgIGlucHV0OiBpbnN0Ll9kZWYuaW5wdXQsXG4gICAgICAgICAgICBvdXRwdXQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIGluc3Q7XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kUHJvbWlzZSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCIkWm9kUHJvbWlzZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgJFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShwYXlsb2FkLnZhbHVlKS50aGVuKChpbm5lcikgPT4gZGVmLmlubmVyVHlwZS5fem9kLnJ1bih7IHZhbHVlOiBpbm5lciwgaXNzdWVzOiBbXSB9LCBjdHgpKTtcbiAgICB9O1xufSk7XG5leHBvcnQgY29uc3QgJFpvZExhenkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiJFpvZExhenlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICAvLyBsZXQgX2lubmVyVHlwZSE6IGFueTtcbiAgICAvLyB1dGlsLmRlZmluZUxhenkoZGVmLCBcImdldHRlclwiLCAoKSA9PiB7XG4gICAgLy8gICBpZiAoIV9pbm5lclR5cGUpIHtcbiAgICAvLyAgICAgX2lubmVyVHlwZSA9IGRlZi5nZXR0ZXIoKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiAoKSA9PiBfaW5uZXJUeXBlO1xuICAgIC8vIH0pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwiaW5uZXJUeXBlXCIsICgpID0+IGRlZi5nZXR0ZXIoKSk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IGluc3QuX3pvZC5pbm5lclR5cGU/Ll96b2Q/LnBhdHRlcm4pO1xuICAgIHV0aWwuZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiBpbnN0Ll96b2QuaW5uZXJUeXBlPy5fem9kPy5wcm9wVmFsdWVzKTtcbiAgICB1dGlsLmRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGluc3QuX3pvZC5pbm5lclR5cGU/Ll96b2Q/Lm9wdGluID8/IHVuZGVmaW5lZCk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRvdXRcIiwgKCkgPT4gaW5zdC5fem9kLmlubmVyVHlwZT8uX3pvZD8ub3B0b3V0ID8/IHVuZGVmaW5lZCk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuICAgICAgICBjb25zdCBpbm5lciA9IGluc3QuX3pvZC5pbm5lclR5cGU7XG4gICAgICAgIHJldHVybiBpbm5lci5fem9kLnJ1bihwYXlsb2FkLCBjdHgpO1xuICAgIH07XG59KTtcbmV4cG9ydCBjb25zdCAkWm9kQ3VzdG9tID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIiRab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNoZWNrcy4kWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuICAgICRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgXykgPT4ge1xuICAgICAgICByZXR1cm4gcGF5bG9hZDtcbiAgICB9O1xuICAgIGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgIGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcbiAgICAgICAgY29uc3QgciA9IGRlZi5mbihpbnB1dCk7XG4gICAgICAgIGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHIudGhlbigocikgPT4gaGFuZGxlUmVmaW5lUmVzdWx0KHIsIHBheWxvYWQsIGlucHV0LCBpbnN0KSk7XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlUmVmaW5lUmVzdWx0KHIsIHBheWxvYWQsIGlucHV0LCBpbnN0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVJlZmluZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGlucHV0LCBpbnN0KSB7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgY29uc3QgX2lzcyA9IHtcbiAgICAgICAgICAgIGNvZGU6IFwiY3VzdG9tXCIsXG4gICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgIGluc3QsIC8vIGluY29ycG9yYXRlcyBwYXJhbXMuZXJyb3IgaW50byBpc3N1ZSByZXBvcnRpbmdcbiAgICAgICAgICAgIHBhdGg6IFsuLi4oaW5zdC5fem9kLmRlZi5wYXRoID8/IFtdKV0sIC8vIGluY29ycG9yYXRlcyBwYXJhbXMuZXJyb3IgaW50byBpc3N1ZSByZXBvcnRpbmdcbiAgICAgICAgICAgIGNvbnRpbnVlOiAhaW5zdC5fem9kLmRlZi5hYm9ydCxcbiAgICAgICAgICAgIC8vIHBhcmFtczogaW5zdC5fem9kLmRlZi5wYXJhbXMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpbnN0Ll96b2QuZGVmLnBhcmFtcylcbiAgICAgICAgICAgIF9pc3MucGFyYW1zID0gaW5zdC5fem9kLmRlZi5wYXJhbXM7XG4gICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2godXRpbC5pc3N1ZShfaXNzKSk7XG4gICAgfVxufVxuIiwgImltcG9ydCAqIGFzIHV0aWwgZnJvbSBcIi4uL2NvcmUvdXRpbC5qc1wiO1xuY29uc3QgZXJyb3IgPSAoKSA9PiB7XG4gICAgY29uc3QgU2l6YWJsZSA9IHtcbiAgICAgICAgc3RyaW5nOiB7IHVuaXQ6IFwiY2hhcmFjdGVyc1wiLCB2ZXJiOiBcInRvIGhhdmVcIiB9LFxuICAgICAgICBmaWxlOiB7IHVuaXQ6IFwiYnl0ZXNcIiwgdmVyYjogXCJ0byBoYXZlXCIgfSxcbiAgICAgICAgYXJyYXk6IHsgdW5pdDogXCJpdGVtc1wiLCB2ZXJiOiBcInRvIGhhdmVcIiB9LFxuICAgICAgICBzZXQ6IHsgdW5pdDogXCJpdGVtc1wiLCB2ZXJiOiBcInRvIGhhdmVcIiB9LFxuICAgICAgICBtYXA6IHsgdW5pdDogXCJlbnRyaWVzXCIsIHZlcmI6IFwidG8gaGF2ZVwiIH0sXG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRTaXppbmcob3JpZ2luKSB7XG4gICAgICAgIHJldHVybiBTaXphYmxlW29yaWdpbl0gPz8gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgRm9ybWF0RGljdGlvbmFyeSA9IHtcbiAgICAgICAgcmVnZXg6IFwiaW5wdXRcIixcbiAgICAgICAgZW1haWw6IFwiZW1haWwgYWRkcmVzc1wiLFxuICAgICAgICB1cmw6IFwiVVJMXCIsXG4gICAgICAgIGVtb2ppOiBcImVtb2ppXCIsXG4gICAgICAgIHV1aWQ6IFwiVVVJRFwiLFxuICAgICAgICB1dWlkdjQ6IFwiVVVJRHY0XCIsXG4gICAgICAgIHV1aWR2NjogXCJVVUlEdjZcIixcbiAgICAgICAgbmFub2lkOiBcIm5hbm9pZFwiLFxuICAgICAgICBndWlkOiBcIkdVSURcIixcbiAgICAgICAgY3VpZDogXCJjdWlkXCIsXG4gICAgICAgIGN1aWQyOiBcImN1aWQyXCIsXG4gICAgICAgIHVsaWQ6IFwiVUxJRFwiLFxuICAgICAgICB4aWQ6IFwiWElEXCIsXG4gICAgICAgIGtzdWlkOiBcIktTVUlEXCIsXG4gICAgICAgIGRhdGV0aW1lOiBcIklTTyBkYXRldGltZVwiLFxuICAgICAgICBkYXRlOiBcIklTTyBkYXRlXCIsXG4gICAgICAgIHRpbWU6IFwiSVNPIHRpbWVcIixcbiAgICAgICAgZHVyYXRpb246IFwiSVNPIGR1cmF0aW9uXCIsXG4gICAgICAgIGlwdjQ6IFwiSVB2NCBhZGRyZXNzXCIsXG4gICAgICAgIGlwdjY6IFwiSVB2NiBhZGRyZXNzXCIsXG4gICAgICAgIG1hYzogXCJNQUMgYWRkcmVzc1wiLFxuICAgICAgICBjaWRydjQ6IFwiSVB2NCByYW5nZVwiLFxuICAgICAgICBjaWRydjY6IFwiSVB2NiByYW5nZVwiLFxuICAgICAgICBiYXNlNjQ6IFwiYmFzZTY0LWVuY29kZWQgc3RyaW5nXCIsXG4gICAgICAgIGJhc2U2NHVybDogXCJiYXNlNjR1cmwtZW5jb2RlZCBzdHJpbmdcIixcbiAgICAgICAganNvbl9zdHJpbmc6IFwiSlNPTiBzdHJpbmdcIixcbiAgICAgICAgZTE2NDogXCJFLjE2NCBudW1iZXJcIixcbiAgICAgICAgand0OiBcIkpXVFwiLFxuICAgICAgICB0ZW1wbGF0ZV9saXRlcmFsOiBcImlucHV0XCIsXG4gICAgfTtcbiAgICAvLyB0eXBlIG5hbWVzOiBtaXNzaW5nIGtleXMgPSBkbyBub3QgdHJhbnNsYXRlICh1c2UgcmF3IHZhbHVlIHZpYSA/PyBmYWxsYmFjaylcbiAgICBjb25zdCBUeXBlRGljdGlvbmFyeSA9IHtcbiAgICAgICAgLy8gQ29tcGF0aWJpbGl0eTogXCJuYW5cIiAtPiBcIk5hTlwiIGZvciBkaXNwbGF5XG4gICAgICAgIG5hbjogXCJOYU5cIixcbiAgICAgICAgLy8gQWxsIG90aGVyIHR5cGUgbmFtZXMgb21pdHRlZCAtIHRoZXkgZmFsbCBiYWNrIHRvIHJhdyB2YWx1ZXMgdmlhID8/IG9wZXJhdG9yXG4gICAgfTtcbiAgICByZXR1cm4gKGlzc3VlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAoaXNzdWUuY29kZSkge1xuICAgICAgICAgICAgY2FzZSBcImludmFsaWRfdHlwZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWQgPSBUeXBlRGljdGlvbmFyeVtpc3N1ZS5leHBlY3RlZF0gPz8gaXNzdWUuZXhwZWN0ZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWl2ZWRUeXBlID0gdXRpbC5wYXJzZWRUeXBlKGlzc3VlLmlucHV0KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNlaXZlZCA9IFR5cGVEaWN0aW9uYXJ5W3JlY2VpdmVkVHlwZV0gPz8gcmVjZWl2ZWRUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBpbnB1dDogZXhwZWN0ZWQgJHtleHBlY3RlZH0sIHJlY2VpdmVkICR7cmVjZWl2ZWR9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX3ZhbHVlXCI6XG4gICAgICAgICAgICAgICAgaWYgKGlzc3VlLnZhbHVlcy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBpbnB1dDogZXhwZWN0ZWQgJHt1dGlsLnN0cmluZ2lmeVByaW1pdGl2ZShpc3N1ZS52YWx1ZXNbMF0pfWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIG9wdGlvbjogZXhwZWN0ZWQgb25lIG9mICR7dXRpbC5qb2luVmFsdWVzKGlzc3VlLnZhbHVlcywgXCJ8XCIpfWA7XG4gICAgICAgICAgICBjYXNlIFwidG9vX2JpZ1wiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRqID0gaXNzdWUuaW5jbHVzaXZlID8gXCI8PVwiIDogXCI8XCI7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2l6aW5nID0gZ2V0U2l6aW5nKGlzc3VlLm9yaWdpbik7XG4gICAgICAgICAgICAgICAgaWYgKHNpemluZylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBUb28gYmlnOiBleHBlY3RlZCAke2lzc3VlLm9yaWdpbiA/PyBcInZhbHVlXCJ9IHRvIGhhdmUgJHthZGp9JHtpc3N1ZS5tYXhpbXVtLnRvU3RyaW5nKCl9ICR7c2l6aW5nLnVuaXQgPz8gXCJlbGVtZW50c1wifWA7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBUb28gYmlnOiBleHBlY3RlZCAke2lzc3VlLm9yaWdpbiA/PyBcInZhbHVlXCJ9IHRvIGJlICR7YWRqfSR7aXNzdWUubWF4aW11bS50b1N0cmluZygpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidG9vX3NtYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhZGogPSBpc3N1ZS5pbmNsdXNpdmUgPyBcIj49XCIgOiBcIj5cIjtcbiAgICAgICAgICAgICAgICBjb25zdCBzaXppbmcgPSBnZXRTaXppbmcoaXNzdWUub3JpZ2luKTtcbiAgICAgICAgICAgICAgICBpZiAoc2l6aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgVG9vIHNtYWxsOiBleHBlY3RlZCAke2lzc3VlLm9yaWdpbn0gdG8gaGF2ZSAke2Fkan0ke2lzc3VlLm1pbmltdW0udG9TdHJpbmcoKX0gJHtzaXppbmcudW5pdH1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gYFRvbyBzbWFsbDogZXhwZWN0ZWQgJHtpc3N1ZS5vcmlnaW59IHRvIGJlICR7YWRqfSR7aXNzdWUubWluaW11bS50b1N0cmluZygpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9mb3JtYXRcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9pc3N1ZSA9IGlzc3VlO1xuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZm9ybWF0ID09PSBcInN0YXJ0c193aXRoXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIHN0cmluZzogbXVzdCBzdGFydCB3aXRoIFwiJHtfaXNzdWUucHJlZml4fVwiYDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mb3JtYXQgPT09IFwiZW5kc193aXRoXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBzdHJpbmc6IG11c3QgZW5kIHdpdGggXCIke19pc3N1ZS5zdWZmaXh9XCJgO1xuICAgICAgICAgICAgICAgIGlmIChfaXNzdWUuZm9ybWF0ID09PSBcImluY2x1ZGVzXCIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCBzdHJpbmc6IG11c3QgaW5jbHVkZSBcIiR7X2lzc3VlLmluY2x1ZGVzfVwiYDtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZvcm1hdCA9PT0gXCJyZWdleFwiKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgc3RyaW5nOiBtdXN0IG1hdGNoIHBhdHRlcm4gJHtfaXNzdWUucGF0dGVybn1gO1xuICAgICAgICAgICAgICAgIHJldHVybiBgSW52YWxpZCAke0Zvcm1hdERpY3Rpb25hcnlbX2lzc3VlLmZvcm1hdF0gPz8gaXNzdWUuZm9ybWF0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwibm90X211bHRpcGxlX29mXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIG51bWJlcjogbXVzdCBiZSBhIG11bHRpcGxlIG9mICR7aXNzdWUuZGl2aXNvcn1gO1xuICAgICAgICAgICAgY2FzZSBcInVucmVjb2duaXplZF9rZXlzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBVbnJlY29nbml6ZWQga2V5JHtpc3N1ZS5rZXlzLmxlbmd0aCA+IDEgPyBcInNcIiA6IFwiXCJ9OiAke3V0aWwuam9pblZhbHVlcyhpc3N1ZS5rZXlzLCBcIiwgXCIpfWA7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF9rZXlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQga2V5IGluICR7aXNzdWUub3JpZ2lufWA7XG4gICAgICAgICAgICBjYXNlIFwiaW52YWxpZF91bmlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcIkludmFsaWQgaW5wdXRcIjtcbiAgICAgICAgICAgIGNhc2UgXCJpbnZhbGlkX2VsZW1lbnRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gYEludmFsaWQgdmFsdWUgaW4gJHtpc3N1ZS5vcmlnaW59YDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGBJbnZhbGlkIGlucHV0YDtcbiAgICAgICAgfVxuICAgIH07XG59O1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGxvY2FsZUVycm9yOiBlcnJvcigpLFxuICAgIH07XG59XG4iLCAidmFyIF9hO1xuZXhwb3J0IGNvbnN0ICRvdXRwdXQgPSBTeW1ib2woXCJab2RPdXRwdXRcIik7XG5leHBvcnQgY29uc3QgJGlucHV0ID0gU3ltYm9sKFwiWm9kSW5wdXRcIik7XG5leHBvcnQgY2xhc3MgJFpvZFJlZ2lzdHJ5IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fbWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5faWRtYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGFkZChzY2hlbWEsIC4uLl9tZXRhKSB7XG4gICAgICAgIGNvbnN0IG1ldGEgPSBfbWV0YVswXTtcbiAgICAgICAgdGhpcy5fbWFwLnNldChzY2hlbWEsIG1ldGEpO1xuICAgICAgICBpZiAobWV0YSAmJiB0eXBlb2YgbWV0YSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gbWV0YSkge1xuICAgICAgICAgICAgdGhpcy5faWRtYXAuc2V0KG1ldGEuaWQsIHNjaGVtYSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl9tYXAgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLl9pZG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHJlbW92ZShzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IHRoaXMuX21hcC5nZXQoc2NoZW1hKTtcbiAgICAgICAgaWYgKG1ldGEgJiYgdHlwZW9mIG1ldGEgPT09IFwib2JqZWN0XCIgJiYgXCJpZFwiIGluIG1ldGEpIHtcbiAgICAgICAgICAgIHRoaXMuX2lkbWFwLmRlbGV0ZShtZXRhLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tYXAuZGVsZXRlKHNjaGVtYSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXQoc2NoZW1hKSB7XG4gICAgICAgIC8vIHJldHVybiB0aGlzLl9tYXAuZ2V0KHNjaGVtYSkgYXMgYW55O1xuICAgICAgICAvLyBpbmhlcml0IG1ldGFkYXRhXG4gICAgICAgIGNvbnN0IHAgPSBzY2hlbWEuX3pvZC5wYXJlbnQ7XG4gICAgICAgIGlmIChwKSB7XG4gICAgICAgICAgICBjb25zdCBwbSA9IHsgLi4uKHRoaXMuZ2V0KHApID8/IHt9KSB9O1xuICAgICAgICAgICAgZGVsZXRlIHBtLmlkOyAvLyBkbyBub3QgaW5oZXJpdCBpZFxuICAgICAgICAgICAgY29uc3QgZiA9IHsgLi4ucG0sIC4uLnRoaXMuX21hcC5nZXQoc2NoZW1hKSB9O1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKGYpLmxlbmd0aCA/IGYgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hcC5nZXQoc2NoZW1hKTtcbiAgICB9XG4gICAgaGFzKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWFwLmhhcyhzY2hlbWEpO1xuICAgIH1cbn1cbi8vIHJlZ2lzdHJpZXNcbmV4cG9ydCBmdW5jdGlvbiByZWdpc3RyeSgpIHtcbiAgICByZXR1cm4gbmV3ICRab2RSZWdpc3RyeSgpO1xufVxuKF9hID0gZ2xvYmFsVGhpcykuX196b2RfZ2xvYmFsUmVnaXN0cnkgPz8gKF9hLl9fem9kX2dsb2JhbFJlZ2lzdHJ5ID0gcmVnaXN0cnkoKSk7XG5leHBvcnQgY29uc3QgZ2xvYmFsUmVnaXN0cnkgPSBnbG9iYWxUaGlzLl9fem9kX2dsb2JhbFJlZ2lzdHJ5O1xuIiwgImltcG9ydCAqIGFzIGNoZWNrcyBmcm9tIFwiLi9jaGVja3MuanNcIjtcbmltcG9ydCAqIGFzIHJlZ2lzdHJpZXMgZnJvbSBcIi4vcmVnaXN0cmllcy5qc1wiO1xuaW1wb3J0ICogYXMgc2NoZW1hcyBmcm9tIFwiLi9zY2hlbWFzLmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3N0cmluZyhDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jb2VyY2VkU3RyaW5nKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZW1haWwoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZW1haWxcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ndWlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImd1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91dWlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInV1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91dWlkdjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidXVpZFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgdmVyc2lvbjogXCJ2NFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXVpZHY2KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInV1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIHZlcnNpb246IFwidjZcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3V1aWR2NyhDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJ1dWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICB2ZXJzaW9uOiBcInY3XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91cmwoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwidXJsXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZW1vamkoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZW1vamlcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9uYW5vaWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwibmFub2lkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY3VpZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJjdWlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY3VpZDIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiY3VpZDJcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91bGlkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInVsaWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF94aWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwieGlkXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfa3N1aWQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwia3N1aWRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pcHY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImlwdjRcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pcHY2KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImlwdjZcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9tYWMoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwibWFjXCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY2lkcnY0KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImNpZHJ2NFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NpZHJ2NihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJjaWRydjZcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlNjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiYmFzZTY0XCIsXG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYmFzZTY0dXJsKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImJhc2U2NHVybFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2UxNjQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZTE2NFwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2p3dChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJqd3RcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBhYm9ydDogZmFsc2UsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgVGltZVByZWNpc2lvbiA9IHtcbiAgICBBbnk6IG51bGwsXG4gICAgTWludXRlOiAtMSxcbiAgICBTZWNvbmQ6IDAsXG4gICAgTWlsbGlzZWNvbmQ6IDMsXG4gICAgTWljcm9zZWNvbmQ6IDYsXG59O1xuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaXNvRGF0ZVRpbWUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZGF0ZXRpbWVcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBvZmZzZXQ6IGZhbHNlLFxuICAgICAgICBsb2NhbDogZmFsc2UsXG4gICAgICAgIHByZWNpc2lvbjogbnVsbCxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2lzb0RhdGUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQ6IFwiZGF0ZVwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pc29UaW1lKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcInRpbWVcIixcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBwcmVjaXNpb246IG51bGwsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pc29EdXJhdGlvbihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICAgIGZvcm1hdDogXCJkdXJhdGlvblwiLFxuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9udW1iZXIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlZE51bWJlcihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNvZXJjZTogdHJ1ZSxcbiAgICAgICAgY2hlY2tzOiBbXSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2ludChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNoZWNrOiBcIm51bWJlcl9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwic2FmZWludFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZmxvYXQzMihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNoZWNrOiBcIm51bWJlcl9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwiZmxvYXQzMlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZmxvYXQ2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVtYmVyXCIsXG4gICAgICAgIGNoZWNrOiBcIm51bWJlcl9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwiZmxvYXQ2NFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaW50MzIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcImludDMyXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF91aW50MzIoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bWJlclwiLFxuICAgICAgICBjaGVjazogXCJudW1iZXJfZm9ybWF0XCIsXG4gICAgICAgIGFib3J0OiBmYWxzZSxcbiAgICAgICAgZm9ybWF0OiBcInVpbnQzMlwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYm9vbGVhbihDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYm9vbGVhblwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlZEJvb2xlYW4oQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJvb2xlYW5cIixcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYmlnaW50KENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJiaWdpbnRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NvZXJjZWRCaWdpbnQoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImJpZ2ludFwiLFxuICAgICAgICBjb2VyY2U6IHRydWUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9pbnQ2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIGNoZWNrOiBcImJpZ2ludF9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwiaW50NjRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3VpbnQ2NChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiYmlnaW50XCIsXG4gICAgICAgIGNoZWNrOiBcImJpZ2ludF9mb3JtYXRcIixcbiAgICAgICAgYWJvcnQ6IGZhbHNlLFxuICAgICAgICBmb3JtYXQ6IFwidWludDY0XCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zeW1ib2woQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInN5bWJvbFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdW5kZWZpbmVkKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ1bmRlZmluZWRcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX251bGwoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcIm51bGxcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2FueShDbGFzcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImFueVwiLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdW5rbm93bihDbGFzcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVua25vd25cIixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25ldmVyKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJuZXZlclwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdm9pZChDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidm9pZFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZGF0ZShDbGFzcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZGF0ZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfY29lcmNlZERhdGUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImRhdGVcIixcbiAgICAgICAgY29lcmNlOiB0cnVlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbmFuKENsYXNzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJuYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2x0KHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tMZXNzVGhhbih7XG4gICAgICAgIGNoZWNrOiBcImxlc3NfdGhhblwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2x0ZSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTGVzc1RoYW4oe1xuICAgICAgICBjaGVjazogXCJsZXNzX3RoYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IFxuLyoqIEBkZXByZWNhdGVkIFVzZSBgei5sdGUoKWAgaW5zdGVhZC4gKi9cbl9sdGUgYXMgX21heCwgfTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2d0KHZhbHVlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tHcmVhdGVyVGhhbih7XG4gICAgICAgIGNoZWNrOiBcImdyZWF0ZXJfdGhhblwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2d0ZSh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrR3JlYXRlclRoYW4oe1xuICAgICAgICBjaGVjazogXCJncmVhdGVyX3RoYW5cIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGluY2x1c2l2ZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydCB7IFxuLyoqIEBkZXByZWNhdGVkIFVzZSBgei5ndGUoKWAgaW5zdGVhZC4gKi9cbl9ndGUgYXMgX21pbiwgfTtcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3Bvc2l0aXZlKHBhcmFtcykge1xuICAgIHJldHVybiBfZ3QoMCwgcGFyYW1zKTtcbn1cbi8vIG5lZ2F0aXZlXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9uZWdhdGl2ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gX2x0KDAsIHBhcmFtcyk7XG59XG4vLyBub25wb3NpdGl2ZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbm9ucG9zaXRpdmUocGFyYW1zKSB7XG4gICAgcmV0dXJuIF9sdGUoMCwgcGFyYW1zKTtcbn1cbi8vIG5vbm5lZ2F0aXZlXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ub25uZWdhdGl2ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gX2d0ZSgwLCBwYXJhbXMpO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbXVsdGlwbGVPZih2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTXVsdGlwbGVPZih7XG4gICAgICAgIGNoZWNrOiBcIm11bHRpcGxlX29mXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHZhbHVlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWF4U2l6ZShtYXhpbXVtLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNYXhTaXplKHtcbiAgICAgICAgY2hlY2s6IFwibWF4X3NpemVcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgbWF4aW11bSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21pblNpemUobWluaW11bSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTWluU2l6ZSh7XG4gICAgICAgIGNoZWNrOiBcIm1pbl9zaXplXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIG1pbmltdW0sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zaXplKHNpemUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1NpemVFcXVhbHMoe1xuICAgICAgICBjaGVjazogXCJzaXplX2VxdWFsc1wiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBzaXplLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWF4TGVuZ3RoKG1heGltdW0sIHBhcmFtcykge1xuICAgIGNvbnN0IGNoID0gbmV3IGNoZWNrcy4kWm9kQ2hlY2tNYXhMZW5ndGgoe1xuICAgICAgICBjaGVjazogXCJtYXhfbGVuZ3RoXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIG1heGltdW0sXG4gICAgfSk7XG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWluTGVuZ3RoKG1pbmltdW0sIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja01pbkxlbmd0aCh7XG4gICAgICAgIGNoZWNrOiBcIm1pbl9sZW5ndGhcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgbWluaW11bSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2xlbmd0aChsZW5ndGgsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0xlbmd0aEVxdWFscyh7XG4gICAgICAgIGNoZWNrOiBcImxlbmd0aF9lcXVhbHNcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgbGVuZ3RoLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcmVnZXgocGF0dGVybiwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrUmVnZXgoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJyZWdleFwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICBwYXR0ZXJuLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbG93ZXJjYXNlKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0xvd2VyQ2FzZSh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcImxvd2VyY2FzZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdXBwZXJjYXNlKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja1VwcGVyQ2FzZSh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcInVwcGVyY2FzZVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfaW5jbHVkZXMoaW5jbHVkZXMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgY2hlY2tzLiRab2RDaGVja0luY2x1ZGVzKHtcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICBmb3JtYXQ6IFwiaW5jbHVkZXNcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgaW5jbHVkZXMsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdGFydHNXaXRoKHByZWZpeCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrU3RhcnRzV2l0aCh7XG4gICAgICAgIGNoZWNrOiBcInN0cmluZ19mb3JtYXRcIixcbiAgICAgICAgZm9ybWF0OiBcInN0YXJ0c193aXRoXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgICAgIHByZWZpeCxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2VuZHNXaXRoKHN1ZmZpeCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrRW5kc1dpdGgoe1xuICAgICAgICBjaGVjazogXCJzdHJpbmdfZm9ybWF0XCIsXG4gICAgICAgIGZvcm1hdDogXCJlbmRzX3dpdGhcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgc3VmZml4LFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcHJvcGVydHkocHJvcGVydHksIHNjaGVtYSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrUHJvcGVydHkoe1xuICAgICAgICBjaGVjazogXCJwcm9wZXJ0eVwiLFxuICAgICAgICBwcm9wZXJ0eSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbWltZSh0eXBlcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBjaGVja3MuJFpvZENoZWNrTWltZVR5cGUoe1xuICAgICAgICBjaGVjazogXCJtaW1lX3R5cGVcIixcbiAgICAgICAgbWltZTogdHlwZXMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9vdmVyd3JpdGUodHgpIHtcbiAgICByZXR1cm4gbmV3IGNoZWNrcy4kWm9kQ2hlY2tPdmVyd3JpdGUoe1xuICAgICAgICBjaGVjazogXCJvdmVyd3JpdGVcIixcbiAgICAgICAgdHgsXG4gICAgfSk7XG59XG4vLyBub3JtYWxpemVcbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX25vcm1hbGl6ZShmb3JtKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiBpbnB1dC5ub3JtYWxpemUoZm9ybSkpO1xufVxuLy8gdHJpbVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdHJpbSgpIHtcbiAgICByZXR1cm4gX292ZXJ3cml0ZSgoaW5wdXQpID0+IGlucHV0LnRyaW0oKSk7XG59XG4vLyB0b0xvd2VyQ2FzZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdG9Mb3dlckNhc2UoKSB7XG4gICAgcmV0dXJuIF9vdmVyd3JpdGUoKGlucHV0KSA9PiBpbnB1dC50b0xvd2VyQ2FzZSgpKTtcbn1cbi8vIHRvVXBwZXJDYXNlXG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90b1VwcGVyQ2FzZSgpIHtcbiAgICByZXR1cm4gX292ZXJ3cml0ZSgoaW5wdXQpID0+IGlucHV0LnRvVXBwZXJDYXNlKCkpO1xufVxuLy8gc2x1Z2lmeVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc2x1Z2lmeSgpIHtcbiAgICByZXR1cm4gX292ZXJ3cml0ZSgoaW5wdXQpID0+IHV0aWwuc2x1Z2lmeShpbnB1dCkpO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfYXJyYXkoQ2xhc3MsIGVsZW1lbnQsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImFycmF5XCIsXG4gICAgICAgIGVsZW1lbnQsXG4gICAgICAgIC8vIGdldCBlbGVtZW50KCkge1xuICAgICAgICAvLyAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICAvLyB9LFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfdW5pb24oQ2xhc3MsIG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX3hvcihDbGFzcywgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2Rpc2NyaW1pbmF0ZWRVbmlvbihDbGFzcywgZGlzY3JpbWluYXRvciwgb3B0aW9ucywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgZGlzY3JpbWluYXRvcixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2ludGVyc2VjdGlvbihDbGFzcywgbGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJpbnRlcnNlY3Rpb25cIixcbiAgICAgICAgbGVmdCxcbiAgICAgICAgcmlnaHQsXG4gICAgfSk7XG59XG4vLyBleHBvcnQgZnVuY3Rpb24gX3R1cGxlKFxuLy8gICBDbGFzczogdXRpbC5TY2hlbWFDbGFzczxzY2hlbWFzLiRab2RUdXBsZT4sXG4vLyAgIGl0ZW1zOiBbXSxcbi8vICAgcGFyYW1zPzogc3RyaW5nIHwgJFpvZFR1cGxlUGFyYW1zXG4vLyApOiBzY2hlbWFzLiRab2RUdXBsZTxbXSwgbnVsbD47XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90dXBsZShDbGFzcywgaXRlbXMsIF9wYXJhbXNPclJlc3QsIF9wYXJhbXMpIHtcbiAgICBjb25zdCBoYXNSZXN0ID0gX3BhcmFtc09yUmVzdCBpbnN0YW5jZW9mIHNjaGVtYXMuJFpvZFR5cGU7XG4gICAgY29uc3QgcGFyYW1zID0gaGFzUmVzdCA/IF9wYXJhbXMgOiBfcGFyYW1zT3JSZXN0O1xuICAgIGNvbnN0IHJlc3QgPSBoYXNSZXN0ID8gX3BhcmFtc09yUmVzdCA6IG51bGw7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwidHVwbGVcIixcbiAgICAgICAgaXRlbXMsXG4gICAgICAgIHJlc3QsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9yZWNvcmQoQ2xhc3MsIGtleVR5cGUsIHZhbHVlVHlwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX21hcChDbGFzcywga2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJtYXBcIixcbiAgICAgICAga2V5VHlwZSxcbiAgICAgICAgdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc2V0KENsYXNzLCB2YWx1ZVR5cGUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcInNldFwiLFxuICAgICAgICB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9lbnVtKENsYXNzLCB2YWx1ZXMsIHBhcmFtcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlcykgPyBPYmplY3QuZnJvbUVudHJpZXModmFsdWVzLm1hcCgodikgPT4gW3YsIHZdKSkgOiB2YWx1ZXM7XG4gICAgLy8gaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgIC8vICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAvLyAgICAgZW50cmllc1t2YWx1ZV0gPSB2YWx1ZTtcbiAgICAvLyAgIH1cbiAgICAvLyB9IGVsc2Uge1xuICAgIC8vICAgT2JqZWN0LmFzc2lnbihlbnRyaWVzLCB2YWx1ZXMpO1xuICAgIC8vIH1cbiAgICAvLyBjb25zdCBlbnRyaWVzOiB1dGlsLkVudW1MaWtlID0ge307XG4gICAgLy8gZm9yIChjb25zdCB2YWwgb2YgdmFsdWVzKSB7XG4gICAgLy8gICBlbnRyaWVzW3ZhbF0gPSB2YWw7XG4gICAgLy8gfVxuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG4vKiogQGRlcHJlY2F0ZWQgVGhpcyBBUEkgaGFzIGJlZW4gbWVyZ2VkIGludG8gYHouZW51bSgpYC4gVXNlIGB6LmVudW0oKWAgaW5zdGVhZC5cbiAqXG4gKiBgYGB0c1xuICogZW51bSBDb2xvcnMgeyByZWQsIGdyZWVuLCBibHVlIH1cbiAqIHouZW51bShDb2xvcnMpO1xuICogYGBgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBfbmF0aXZlRW51bShDbGFzcywgZW50cmllcywgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbGl0ZXJhbChDbGFzcywgdmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICAgICAgdmFsdWVzOiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2ZpbGUoQ2xhc3MsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgQ2xhc3Moe1xuICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3RyYW5zZm9ybShDbGFzcywgZm4pIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgdHJhbnNmb3JtOiBmbixcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX29wdGlvbmFsKENsYXNzLCBpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJvcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9udWxsYWJsZShDbGFzcywgaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICAgICAgaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfZGVmYXVsdChDbGFzcywgaW5uZXJUeXBlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICAgICAgZ2V0IGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZGVmYXVsdFZhbHVlID09PSBcImZ1bmN0aW9uXCIgPyBkZWZhdWx0VmFsdWUoKSA6IHV0aWwuc2hhbGxvd0Nsb25lKGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH0sXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9ub25vcHRpb25hbChDbGFzcywgaW5uZXJUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdWNjZXNzKENsYXNzLCBpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJzdWNjZXNzXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2NhdGNoKENsYXNzLCBpbm5lclR5cGUsIGNhdGNoVmFsdWUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJjYXRjaFwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgICAgIGNhdGNoVmFsdWU6ICh0eXBlb2YgY2F0Y2hWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2F0Y2hWYWx1ZSA6ICgpID0+IGNhdGNoVmFsdWUpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcGlwZShDbGFzcywgaW5fLCBvdXQpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJwaXBlXCIsXG4gICAgICAgIGluOiBpbl8sXG4gICAgICAgIG91dCxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX3JlYWRvbmx5KENsYXNzLCBpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJyZWFkb25seVwiLFxuICAgICAgICBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF90ZW1wbGF0ZUxpdGVyYWwoQ2xhc3MsIHBhcnRzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJ0ZW1wbGF0ZV9saXRlcmFsXCIsXG4gICAgICAgIHBhcnRzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfbGF6eShDbGFzcywgZ2V0dGVyKSB7XG4gICAgcmV0dXJuIG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwibGF6eVwiLFxuICAgICAgICBnZXR0ZXIsXG4gICAgfSk7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9wcm9taXNlKENsYXNzLCBpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJwcm9taXNlXCIsXG4gICAgICAgIGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbi8vIEBfX05PX1NJREVfRUZGRUNUU19fXG5leHBvcnQgZnVuY3Rpb24gX2N1c3RvbShDbGFzcywgZm4sIF9wYXJhbXMpIHtcbiAgICBjb25zdCBub3JtID0gdXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyk7XG4gICAgbm9ybS5hYm9ydCA/PyAobm9ybS5hYm9ydCA9IHRydWUpOyAvLyBkZWZhdWx0IHRvIGFib3J0OmZhbHNlXG4gICAgY29uc3Qgc2NoZW1hID0gbmV3IENsYXNzKHtcbiAgICAgICAgdHlwZTogXCJjdXN0b21cIixcbiAgICAgICAgY2hlY2s6IFwiY3VzdG9tXCIsXG4gICAgICAgIGZuOiBmbixcbiAgICAgICAgLi4ubm9ybSxcbiAgICB9KTtcbiAgICByZXR1cm4gc2NoZW1hO1xufVxuLy8gc2FtZSBhcyBfY3VzdG9tIGJ1dCBkZWZhdWx0cyB0byBhYm9ydDpmYWxzZVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfcmVmaW5lKENsYXNzLCBmbiwgX3BhcmFtcykge1xuICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBDbGFzcyh7XG4gICAgICAgIHR5cGU6IFwiY3VzdG9tXCIsXG4gICAgICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgICAgICBmbjogZm4sXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKF9wYXJhbXMpLFxuICAgIH0pO1xuICAgIHJldHVybiBzY2hlbWE7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdXBlclJlZmluZShmbikge1xuICAgIGNvbnN0IGNoID0gX2NoZWNrKChwYXlsb2FkKSA9PiB7XG4gICAgICAgIHBheWxvYWQuYWRkSXNzdWUgPSAoaXNzdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWwuaXNzdWUoaXNzdWUsIHBheWxvYWQudmFsdWUsIGNoLl96b2QuZGVmKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBmb3IgWm9kIDMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgICAgICBjb25zdCBfaXNzdWUgPSBpc3N1ZTtcbiAgICAgICAgICAgICAgICBpZiAoX2lzc3VlLmZhdGFsKVxuICAgICAgICAgICAgICAgICAgICBfaXNzdWUuY29udGludWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuY29kZSA/PyAoX2lzc3VlLmNvZGUgPSBcImN1c3RvbVwiKTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuaW5wdXQgPz8gKF9pc3N1ZS5pbnB1dCA9IHBheWxvYWQudmFsdWUpO1xuICAgICAgICAgICAgICAgIF9pc3N1ZS5pbnN0ID8/IChfaXNzdWUuaW5zdCA9IGNoKTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuY29udGludWUgPz8gKF9pc3N1ZS5jb250aW51ZSA9ICFjaC5fem9kLmRlZi5hYm9ydCk7IC8vIGFib3J0IGlzIGFsd2F5cyB1bmRlZmluZWQsIHNvIHRoaXMgaXMgYWx3YXlzIHRydWUuLi5cbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWwuaXNzdWUoX2lzc3VlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmbihwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2g7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9jaGVjayhmbiwgcGFyYW1zKSB7XG4gICAgY29uc3QgY2ggPSBuZXcgY2hlY2tzLiRab2RDaGVjayh7XG4gICAgICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xuICAgIGNoLl96b2QuY2hlY2sgPSBmbjtcbiAgICByZXR1cm4gY2g7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIGRlc2NyaWJlKGRlc2NyaXB0aW9uKSB7XG4gICAgY29uc3QgY2ggPSBuZXcgY2hlY2tzLiRab2RDaGVjayh7IGNoZWNrOiBcImRlc2NyaWJlXCIgfSk7XG4gICAgY2guX3pvZC5vbmF0dGFjaCA9IFtcbiAgICAgICAgKGluc3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nID0gcmVnaXN0cmllcy5nbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCkgPz8ge307XG4gICAgICAgICAgICByZWdpc3RyaWVzLmdsb2JhbFJlZ2lzdHJ5LmFkZChpbnN0LCB7IC4uLmV4aXN0aW5nLCBkZXNjcmlwdGlvbiB9KTtcbiAgICAgICAgfSxcbiAgICBdO1xuICAgIGNoLl96b2QuY2hlY2sgPSAoKSA9PiB7IH07IC8vIG5vLW9wIGNoZWNrXG4gICAgcmV0dXJuIGNoO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBtZXRhKG1ldGFkYXRhKSB7XG4gICAgY29uc3QgY2ggPSBuZXcgY2hlY2tzLiRab2RDaGVjayh7IGNoZWNrOiBcIm1ldGFcIiB9KTtcbiAgICBjaC5fem9kLm9uYXR0YWNoID0gW1xuICAgICAgICAoaW5zdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSByZWdpc3RyaWVzLmdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KSA/PyB7fTtcbiAgICAgICAgICAgIHJlZ2lzdHJpZXMuZ2xvYmFsUmVnaXN0cnkuYWRkKGluc3QsIHsgLi4uZXhpc3RpbmcsIC4uLm1ldGFkYXRhIH0pO1xuICAgICAgICB9LFxuICAgIF07XG4gICAgY2guX3pvZC5jaGVjayA9ICgpID0+IHsgfTsgLy8gbm8tb3AgY2hlY2tcbiAgICByZXR1cm4gY2g7XG59XG4vLyBAX19OT19TSURFX0VGRkVDVFNfX1xuZXhwb3J0IGZ1bmN0aW9uIF9zdHJpbmdib29sKENsYXNzZXMsIF9wYXJhbXMpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB1dGlsLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKTtcbiAgICBsZXQgdHJ1dGh5QXJyYXkgPSBwYXJhbXMudHJ1dGh5ID8/IFtcInRydWVcIiwgXCIxXCIsIFwieWVzXCIsIFwib25cIiwgXCJ5XCIsIFwiZW5hYmxlZFwiXTtcbiAgICBsZXQgZmFsc3lBcnJheSA9IHBhcmFtcy5mYWxzeSA/PyBbXCJmYWxzZVwiLCBcIjBcIiwgXCJub1wiLCBcIm9mZlwiLCBcIm5cIiwgXCJkaXNhYmxlZFwiXTtcbiAgICBpZiAocGFyYW1zLmNhc2UgIT09IFwic2Vuc2l0aXZlXCIpIHtcbiAgICAgICAgdHJ1dGh5QXJyYXkgPSB0cnV0aHlBcnJheS5tYXAoKHYpID0+ICh0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiA/IHYudG9Mb3dlckNhc2UoKSA6IHYpKTtcbiAgICAgICAgZmFsc3lBcnJheSA9IGZhbHN5QXJyYXkubWFwKCh2KSA9PiAodHlwZW9mIHYgPT09IFwic3RyaW5nXCIgPyB2LnRvTG93ZXJDYXNlKCkgOiB2KSk7XG4gICAgfVxuICAgIGNvbnN0IHRydXRoeVNldCA9IG5ldyBTZXQodHJ1dGh5QXJyYXkpO1xuICAgIGNvbnN0IGZhbHN5U2V0ID0gbmV3IFNldChmYWxzeUFycmF5KTtcbiAgICBjb25zdCBfQ29kZWMgPSBDbGFzc2VzLkNvZGVjID8/IHNjaGVtYXMuJFpvZENvZGVjO1xuICAgIGNvbnN0IF9Cb29sZWFuID0gQ2xhc3Nlcy5Cb29sZWFuID8/IHNjaGVtYXMuJFpvZEJvb2xlYW47XG4gICAgY29uc3QgX1N0cmluZyA9IENsYXNzZXMuU3RyaW5nID8/IHNjaGVtYXMuJFpvZFN0cmluZztcbiAgICBjb25zdCBzdHJpbmdTY2hlbWEgPSBuZXcgX1N0cmluZyh7IHR5cGU6IFwic3RyaW5nXCIsIGVycm9yOiBwYXJhbXMuZXJyb3IgfSk7XG4gICAgY29uc3QgYm9vbGVhblNjaGVtYSA9IG5ldyBfQm9vbGVhbih7IHR5cGU6IFwiYm9vbGVhblwiLCBlcnJvcjogcGFyYW1zLmVycm9yIH0pO1xuICAgIGNvbnN0IGNvZGVjID0gbmV3IF9Db2RlYyh7XG4gICAgICAgIHR5cGU6IFwicGlwZVwiLFxuICAgICAgICBpbjogc3RyaW5nU2NoZW1hLFxuICAgICAgICBvdXQ6IGJvb2xlYW5TY2hlbWEsXG4gICAgICAgIHRyYW5zZm9ybTogKChpbnB1dCwgcGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBpbnB1dDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuY2FzZSAhPT0gXCJzZW5zaXRpdmVcIilcbiAgICAgICAgICAgICAgICBkYXRhID0gZGF0YS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKHRydXRoeVNldC5oYXMoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZhbHN5U2V0LmhhcyhkYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBcImludmFsaWRfdmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwic3RyaW5nYm9vbFwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IFsuLi50cnV0aHlTZXQsIC4uLmZhbHN5U2V0XSxcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IHBheWxvYWQudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGluc3Q6IGNvZGVjLFxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgcmV2ZXJzZVRyYW5zZm9ybTogKChpbnB1dCwgX3BheWxvYWQpID0+IHtcbiAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnV0aHlBcnJheVswXSB8fCBcInRydWVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzeUFycmF5WzBdIHx8IFwiZmFsc2VcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBwYXJhbXMuZXJyb3IsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvZGVjO1xufVxuLy8gQF9fTk9fU0lERV9FRkZFQ1RTX19cbmV4cG9ydCBmdW5jdGlvbiBfc3RyaW5nRm9ybWF0KENsYXNzLCBmb3JtYXQsIGZuT3JSZWdleCwgX3BhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgcGFyYW1zID0gdXRpbC5ub3JtYWxpemVQYXJhbXMoX3BhcmFtcyk7XG4gICAgY29uc3QgZGVmID0ge1xuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSxcbiAgICAgICAgY2hlY2s6IFwic3RyaW5nX2Zvcm1hdFwiLFxuICAgICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgICAgICBmb3JtYXQsXG4gICAgICAgIGZuOiB0eXBlb2YgZm5PclJlZ2V4ID09PSBcImZ1bmN0aW9uXCIgPyBmbk9yUmVnZXggOiAodmFsKSA9PiBmbk9yUmVnZXgudGVzdCh2YWwpLFxuICAgICAgICAuLi5wYXJhbXMsXG4gICAgfTtcbiAgICBpZiAoZm5PclJlZ2V4IGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIGRlZi5wYXR0ZXJuID0gZm5PclJlZ2V4O1xuICAgIH1cbiAgICBjb25zdCBpbnN0ID0gbmV3IENsYXNzKGRlZik7XG4gICAgcmV0dXJuIGluc3Q7XG59XG4iLCAiaW1wb3J0IHsgZ2xvYmFsUmVnaXN0cnkgfSBmcm9tIFwiLi9yZWdpc3RyaWVzLmpzXCI7XG4vLyBmdW5jdGlvbiBpbml0aWFsaXplQ29udGV4dDxUIGV4dGVuZHMgc2NoZW1hcy4kWm9kVHlwZT4oaW5wdXRzOiBKU09OU2NoZW1hR2VuZXJhdG9yUGFyYW1zPFQ+KTogVG9KU09OU2NoZW1hQ29udGV4dDxUPiB7XG4vLyAgIHJldHVybiB7XG4vLyAgICAgcHJvY2Vzc29yOiBpbnB1dHMucHJvY2Vzc29yLFxuLy8gICAgIG1ldGFkYXRhUmVnaXN0cnk6IGlucHV0cy5tZXRhZGF0YSA/PyBnbG9iYWxSZWdpc3RyeSxcbi8vICAgICB0YXJnZXQ6IGlucHV0cy50YXJnZXQgPz8gXCJkcmFmdC0yMDIwLTEyXCIsXG4vLyAgICAgdW5yZXByZXNlbnRhYmxlOiBpbnB1dHMudW5yZXByZXNlbnRhYmxlID8/IFwidGhyb3dcIixcbi8vICAgfTtcbi8vIH1cbmV4cG9ydCBmdW5jdGlvbiBpbml0aWFsaXplQ29udGV4dChwYXJhbXMpIHtcbiAgICAvLyBOb3JtYWxpemUgdGFyZ2V0OiBjb252ZXJ0IG9sZCBub24taHlwaGVuYXRlZCB2ZXJzaW9ucyB0byBoeXBoZW5hdGVkIHZlcnNpb25zXG4gICAgbGV0IHRhcmdldCA9IHBhcmFtcz8udGFyZ2V0ID8/IFwiZHJhZnQtMjAyMC0xMlwiO1xuICAgIGlmICh0YXJnZXQgPT09IFwiZHJhZnQtNFwiKVxuICAgICAgICB0YXJnZXQgPSBcImRyYWZ0LTA0XCI7XG4gICAgaWYgKHRhcmdldCA9PT0gXCJkcmFmdC03XCIpXG4gICAgICAgIHRhcmdldCA9IFwiZHJhZnQtMDdcIjtcbiAgICByZXR1cm4ge1xuICAgICAgICBwcm9jZXNzb3JzOiBwYXJhbXMucHJvY2Vzc29ycyA/PyB7fSxcbiAgICAgICAgbWV0YWRhdGFSZWdpc3RyeTogcGFyYW1zPy5tZXRhZGF0YSA/PyBnbG9iYWxSZWdpc3RyeSxcbiAgICAgICAgdGFyZ2V0LFxuICAgICAgICB1bnJlcHJlc2VudGFibGU6IHBhcmFtcz8udW5yZXByZXNlbnRhYmxlID8/IFwidGhyb3dcIixcbiAgICAgICAgb3ZlcnJpZGU6IHBhcmFtcz8ub3ZlcnJpZGUgPz8gKCgpID0+IHsgfSksXG4gICAgICAgIGlvOiBwYXJhbXM/LmlvID8/IFwib3V0cHV0XCIsXG4gICAgICAgIGNvdW50ZXI6IDAsXG4gICAgICAgIHNlZW46IG5ldyBNYXAoKSxcbiAgICAgICAgY3ljbGVzOiBwYXJhbXM/LmN5Y2xlcyA/PyBcInJlZlwiLFxuICAgICAgICByZXVzZWQ6IHBhcmFtcz8ucmV1c2VkID8/IFwiaW5saW5lXCIsXG4gICAgICAgIGV4dGVybmFsOiBwYXJhbXM/LmV4dGVybmFsID8/IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHByb2Nlc3Moc2NoZW1hLCBjdHgsIF9wYXJhbXMgPSB7IHBhdGg6IFtdLCBzY2hlbWFQYXRoOiBbXSB9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICAvLyBjaGVjayBmb3Igc2NoZW1hIGluIHNlZW5zXG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIGlmIChzZWVuKSB7XG4gICAgICAgIHNlZW4uY291bnQrKztcbiAgICAgICAgLy8gY2hlY2sgaWYgY3ljbGVcbiAgICAgICAgY29uc3QgaXNDeWNsZSA9IF9wYXJhbXMuc2NoZW1hUGF0aC5pbmNsdWRlcyhzY2hlbWEpO1xuICAgICAgICBpZiAoaXNDeWNsZSkge1xuICAgICAgICAgICAgc2Vlbi5jeWNsZSA9IF9wYXJhbXMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2Vlbi5zY2hlbWE7XG4gICAgfVxuICAgIC8vIGluaXRpYWxpemVcbiAgICBjb25zdCByZXN1bHQgPSB7IHNjaGVtYToge30sIGNvdW50OiAxLCBjeWNsZTogdW5kZWZpbmVkLCBwYXRoOiBfcGFyYW1zLnBhdGggfTtcbiAgICBjdHguc2Vlbi5zZXQoc2NoZW1hLCByZXN1bHQpO1xuICAgIC8vIGN1c3RvbSBtZXRob2Qgb3ZlcnJpZGVzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICBjb25zdCBvdmVycmlkZVNjaGVtYSA9IHNjaGVtYS5fem9kLnRvSlNPTlNjaGVtYT8uKCk7XG4gICAgaWYgKG92ZXJyaWRlU2NoZW1hKSB7XG4gICAgICAgIHJlc3VsdC5zY2hlbWEgPSBvdmVycmlkZVNjaGVtYTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLl9wYXJhbXMsXG4gICAgICAgICAgICBzY2hlbWFQYXRoOiBbLi4uX3BhcmFtcy5zY2hlbWFQYXRoLCBzY2hlbWFdLFxuICAgICAgICAgICAgcGF0aDogX3BhcmFtcy5wYXRoLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoc2NoZW1hLl96b2QucHJvY2Vzc0pTT05TY2hlbWEpIHtcbiAgICAgICAgICAgIHNjaGVtYS5fem9kLnByb2Nlc3NKU09OU2NoZW1hKGN0eCwgcmVzdWx0LnNjaGVtYSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IF9qc29uID0gcmVzdWx0LnNjaGVtYTtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NvciA9IGN0eC5wcm9jZXNzb3JzW2RlZi50eXBlXTtcbiAgICAgICAgICAgIGlmICghcHJvY2Vzc29yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBbdG9KU09OU2NoZW1hXTogTm9uLXJlcHJlc2VudGFibGUgdHlwZSBlbmNvdW50ZXJlZDogJHtkZWYudHlwZX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb2Nlc3NvcihzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyZW50ID0gc2NoZW1hLl96b2QucGFyZW50O1xuICAgICAgICBpZiAocGFyZW50KSB7XG4gICAgICAgICAgICAvLyBBbHNvIHNldCByZWYgaWYgcHJvY2Vzc29yIGRpZG4ndCAoZm9yIGluaGVyaXRhbmNlKVxuICAgICAgICAgICAgaWYgKCFyZXN1bHQucmVmKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWYgPSBwYXJlbnQ7XG4gICAgICAgICAgICBwcm9jZXNzKHBhcmVudCwgY3R4LCBwYXJhbXMpO1xuICAgICAgICAgICAgY3R4LnNlZW4uZ2V0KHBhcmVudCkuaXNQYXJlbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIG1ldGFkYXRhXG4gICAgY29uc3QgbWV0YSA9IGN0eC5tZXRhZGF0YVJlZ2lzdHJ5LmdldChzY2hlbWEpO1xuICAgIGlmIChtZXRhKVxuICAgICAgICBPYmplY3QuYXNzaWduKHJlc3VsdC5zY2hlbWEsIG1ldGEpO1xuICAgIGlmIChjdHguaW8gPT09IFwiaW5wdXRcIiAmJiBpc1RyYW5zZm9ybWluZyhzY2hlbWEpKSB7XG4gICAgICAgIC8vIGV4YW1wbGVzL2RlZmF1bHRzIG9ubHkgYXBwbHkgdG8gb3V0cHV0IHR5cGUgb2YgcGlwZVxuICAgICAgICBkZWxldGUgcmVzdWx0LnNjaGVtYS5leGFtcGxlcztcbiAgICAgICAgZGVsZXRlIHJlc3VsdC5zY2hlbWEuZGVmYXVsdDtcbiAgICB9XG4gICAgLy8gc2V0IHByZWZhdWx0IGFzIGRlZmF1bHRcbiAgICBpZiAoY3R4LmlvID09PSBcImlucHV0XCIgJiYgcmVzdWx0LnNjaGVtYS5fcHJlZmF1bHQpXG4gICAgICAgIChfYSA9IHJlc3VsdC5zY2hlbWEpLmRlZmF1bHQgPz8gKF9hLmRlZmF1bHQgPSByZXN1bHQuc2NoZW1hLl9wcmVmYXVsdCk7XG4gICAgZGVsZXRlIHJlc3VsdC5zY2hlbWEuX3ByZWZhdWx0O1xuICAgIC8vIHB1bGxpbmcgZnJlc2ggZnJvbSBjdHguc2VlbiBpbiBjYXNlIGl0IHdhcyBvdmVyd3JpdHRlblxuICAgIGNvbnN0IF9yZXN1bHQgPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICByZXR1cm4gX3Jlc3VsdC5zY2hlbWE7XG59XG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdERlZnMoY3R4LCBzY2hlbWFcbi8vIHBhcmFtczogRW1pdFBhcmFtc1xuKSB7XG4gICAgLy8gaXRlcmF0ZSBvdmVyIHNlZW4gbWFwO1xuICAgIGNvbnN0IHJvb3QgPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucHJvY2Vzc2VkIHNjaGVtYS4gVGhpcyBpcyBhIGJ1ZyBpbiBab2QuXCIpO1xuICAgIC8vIFRyYWNrIGlkcyB0byBkZXRlY3QgZHVwbGljYXRlcyBhY3Jvc3MgZGlmZmVyZW50IHNjaGVtYXNcbiAgICBjb25zdCBpZFRvU2NoZW1hID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZW50cnkgb2YgY3R4LnNlZW4uZW50cmllcygpKSB7XG4gICAgICAgIGNvbnN0IGlkID0gY3R4Lm1ldGFkYXRhUmVnaXN0cnkuZ2V0KGVudHJ5WzBdKT8uaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBpZFRvU2NoZW1hLmdldChpZCk7XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmcgJiYgZXhpc3RpbmcgIT09IGVudHJ5WzBdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEdXBsaWNhdGUgc2NoZW1hIGlkIFwiJHtpZH1cIiBkZXRlY3RlZCBkdXJpbmcgSlNPTiBTY2hlbWEgY29udmVyc2lvbi4gVHdvIGRpZmZlcmVudCBzY2hlbWFzIGNhbm5vdCBzaGFyZSB0aGUgc2FtZSBpZCB3aGVuIGNvbnZlcnRlZCB0b2dldGhlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkVG9TY2hlbWEuc2V0KGlkLCBlbnRyeVswXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcmV0dXJucyBhIHJlZiB0byB0aGUgc2NoZW1hXG4gICAgLy8gZGVmSWQgd2lsbCBiZSBlbXB0eSBpZiB0aGUgcmVmIHBvaW50cyB0byBhbiBleHRlcm5hbCBzY2hlbWEgKG9yICMpXG4gICAgY29uc3QgbWFrZVVSSSA9IChlbnRyeSkgPT4ge1xuICAgICAgICAvLyBjb21wYXJpbmcgdGhlIHNlZW4gb2JqZWN0cyBiZWNhdXNlIHNvbWV0aW1lc1xuICAgICAgICAvLyBtdWx0aXBsZSBzY2hlbWFzIG1hcCB0byB0aGUgc2FtZSBzZWVuIG9iamVjdC5cbiAgICAgICAgLy8gZS5nLiBsYXp5XG4gICAgICAgIC8vIGV4dGVybmFsIGlzIGNvbmZpZ3VyZWRcbiAgICAgICAgY29uc3QgZGVmc1NlZ21lbnQgPSBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwiJGRlZnNcIiA6IFwiZGVmaW5pdGlvbnNcIjtcbiAgICAgICAgaWYgKGN0eC5leHRlcm5hbCkge1xuICAgICAgICAgICAgY29uc3QgZXh0ZXJuYWxJZCA9IGN0eC5leHRlcm5hbC5yZWdpc3RyeS5nZXQoZW50cnlbMF0pPy5pZDsgLy8gPz8gXCJfX3NoYXJlZFwiOy8vIGBfX3NjaGVtYSR7Y3R4LmNvdW50ZXIrK31gO1xuICAgICAgICAgICAgLy8gY2hlY2sgaWYgc2NoZW1hIGlzIGluIHRoZSBleHRlcm5hbCByZWdpc3RyeVxuICAgICAgICAgICAgY29uc3QgdXJpR2VuZXJhdG9yID0gY3R4LmV4dGVybmFsLnVyaSA/PyAoKGlkKSA9PiBpZCk7XG4gICAgICAgICAgICBpZiAoZXh0ZXJuYWxJZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHJlZjogdXJpR2VuZXJhdG9yKGV4dGVybmFsSWQpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvdGhlcndpc2UsIGFkZCB0byBfX3NoYXJlZFxuICAgICAgICAgICAgY29uc3QgaWQgPSBlbnRyeVsxXS5kZWZJZCA/PyBlbnRyeVsxXS5zY2hlbWEuaWQgPz8gYHNjaGVtYSR7Y3R4LmNvdW50ZXIrK31gO1xuICAgICAgICAgICAgZW50cnlbMV0uZGVmSWQgPSBpZDsgLy8gc2V0IGRlZklkIHNvIGl0IHdpbGwgYmUgcmV1c2VkIGlmIG5lZWRlZFxuICAgICAgICAgICAgcmV0dXJuIHsgZGVmSWQ6IGlkLCByZWY6IGAke3VyaUdlbmVyYXRvcihcIl9fc2hhcmVkXCIpfSMvJHtkZWZzU2VnbWVudH0vJHtpZH1gIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5WzFdID09PSByb290KSB7XG4gICAgICAgICAgICByZXR1cm4geyByZWY6IFwiI1wiIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2VsZi1jb250YWluZWQgc2NoZW1hXG4gICAgICAgIGNvbnN0IHVyaVByZWZpeCA9IGAjYDtcbiAgICAgICAgY29uc3QgZGVmVXJpUHJlZml4ID0gYCR7dXJpUHJlZml4fS8ke2RlZnNTZWdtZW50fS9gO1xuICAgICAgICBjb25zdCBkZWZJZCA9IGVudHJ5WzFdLnNjaGVtYS5pZCA/PyBgX19zY2hlbWEke2N0eC5jb3VudGVyKyt9YDtcbiAgICAgICAgcmV0dXJuIHsgZGVmSWQsIHJlZjogZGVmVXJpUHJlZml4ICsgZGVmSWQgfTtcbiAgICB9O1xuICAgIC8vIHN0b3JlZCBjYWNoZWQgdmVyc2lvbiBpbiBgZGVmYCBwcm9wZXJ0eVxuICAgIC8vIHJlbW92ZSBhbGwgcHJvcGVydGllcywgc2V0ICRyZWZcbiAgICBjb25zdCBleHRyYWN0VG9EZWYgPSAoZW50cnkpID0+IHtcbiAgICAgICAgLy8gaWYgdGhlIHNjaGVtYSBpcyBhbHJlYWR5IGEgcmVmZXJlbmNlLCBkbyBub3QgZXh0cmFjdCBpdFxuICAgICAgICBpZiAoZW50cnlbMV0uc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVuID0gZW50cnlbMV07XG4gICAgICAgIGNvbnN0IHsgcmVmLCBkZWZJZCB9ID0gbWFrZVVSSShlbnRyeSk7XG4gICAgICAgIHNlZW4uZGVmID0geyAuLi5zZWVuLnNjaGVtYSB9O1xuICAgICAgICAvLyBkZWZJZCB3b24ndCBiZSBzZXQgaWYgdGhlIHNjaGVtYSBpcyBhIHJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzY2hlbWFcbiAgICAgICAgLy8gb3IgaWYgdGhlIHNjaGVtYSBpcyB0aGUgcm9vdCBzY2hlbWFcbiAgICAgICAgaWYgKGRlZklkKVxuICAgICAgICAgICAgc2Vlbi5kZWZJZCA9IGRlZklkO1xuICAgICAgICAvLyB3aXBlIGF3YXkgYWxsIHByb3BlcnRpZXMgZXhjZXB0ICRyZWZcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gc2Vlbi5zY2hlbWE7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHNjaGVtYSkge1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS4kcmVmID0gcmVmO1xuICAgIH07XG4gICAgLy8gdGhyb3cgb24gY3ljbGVzXG4gICAgLy8gYnJlYWsgY3ljbGVzXG4gICAgaWYgKGN0eC5jeWNsZXMgPT09IFwidGhyb3dcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGN0eC5zZWVuLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3Qgc2VlbiA9IGVudHJ5WzFdO1xuICAgICAgICAgICAgaWYgKHNlZW4uY3ljbGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDeWNsZSBkZXRlY3RlZDogXCIgK1xuICAgICAgICAgICAgICAgICAgICBgIy8ke3NlZW4uY3ljbGU/LmpvaW4oXCIvXCIpfS88cm9vdD5gICtcbiAgICAgICAgICAgICAgICAgICAgJ1xcblxcblNldCB0aGUgYGN5Y2xlc2AgcGFyYW1ldGVyIHRvIGBcInJlZlwiYCB0byByZXNvbHZlIGN5Y2xpY2FsIHNjaGVtYXMgd2l0aCBkZWZzLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGV4dHJhY3Qgc2NoZW1hcyBpbnRvICRkZWZzXG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBjdHguc2Vlbi5lbnRyaWVzKCkpIHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IGVudHJ5WzFdO1xuICAgICAgICAvLyBjb252ZXJ0IHJvb3Qgc2NoZW1hIHRvICMgJHJlZlxuICAgICAgICBpZiAoc2NoZW1hID09PSBlbnRyeVswXSkge1xuICAgICAgICAgICAgZXh0cmFjdFRvRGVmKGVudHJ5KTsgLy8gdGhpcyBoYXMgc3BlY2lhbCBoYW5kbGluZyBmb3IgdGhlIHJvb3Qgc2NoZW1hXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHRyYWN0IHNjaGVtYXMgdGhhdCBhcmUgaW4gdGhlIGV4dGVybmFsIHJlZ2lzdHJ5XG4gICAgICAgIGlmIChjdHguZXh0ZXJuYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IGN0eC5leHRlcm5hbC5yZWdpc3RyeS5nZXQoZW50cnlbMF0pPy5pZDtcbiAgICAgICAgICAgIGlmIChzY2hlbWEgIT09IGVudHJ5WzBdICYmIGV4dCkge1xuICAgICAgICAgICAgICAgIGV4dHJhY3RUb0RlZihlbnRyeSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0cmFjdCBzY2hlbWFzIHdpdGggYGlkYCBtZXRhXG4gICAgICAgIGNvbnN0IGlkID0gY3R4Lm1ldGFkYXRhUmVnaXN0cnkuZ2V0KGVudHJ5WzBdKT8uaWQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgZXh0cmFjdFRvRGVmKGVudHJ5KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJyZWFrIGN5Y2xlc1xuICAgICAgICBpZiAoc2Vlbi5jeWNsZSkge1xuICAgICAgICAgICAgLy8gYW55XG4gICAgICAgICAgICBleHRyYWN0VG9EZWYoZW50cnkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXh0cmFjdCByZXVzZWQgc2NoZW1hc1xuICAgICAgICBpZiAoc2Vlbi5jb3VudCA+IDEpIHtcbiAgICAgICAgICAgIGlmIChjdHgucmV1c2VkID09PSBcInJlZlwiKSB7XG4gICAgICAgICAgICAgICAgZXh0cmFjdFRvRGVmKGVudHJ5KTtcbiAgICAgICAgICAgICAgICAvLyBiaW9tZS1pZ25vcmUgbGludDpcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5hbGl6ZShjdHgsIHNjaGVtYSkge1xuICAgIGNvbnN0IHJvb3QgPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBpZiAoIXJvb3QpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVucHJvY2Vzc2VkIHNjaGVtYS4gVGhpcyBpcyBhIGJ1ZyBpbiBab2QuXCIpO1xuICAgIC8vIGZsYXR0ZW4gcmVmcyAtIGluaGVyaXQgcHJvcGVydGllcyBmcm9tIHBhcmVudCBzY2hlbWFzXG4gICAgY29uc3QgZmxhdHRlblJlZiA9ICh6b2RTY2hlbWEpID0+IHtcbiAgICAgICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldCh6b2RTY2hlbWEpO1xuICAgICAgICAvLyBhbHJlYWR5IHByb2Nlc3NlZFxuICAgICAgICBpZiAoc2Vlbi5yZWYgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHNlZW4uZGVmID8/IHNlZW4uc2NoZW1hO1xuICAgICAgICBjb25zdCBfY2FjaGVkID0geyAuLi5zY2hlbWEgfTtcbiAgICAgICAgY29uc3QgcmVmID0gc2Vlbi5yZWY7XG4gICAgICAgIHNlZW4ucmVmID0gbnVsbDsgLy8gcHJldmVudCBpbmZpbml0ZSByZWN1cnNpb25cbiAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgZmxhdHRlblJlZihyZWYpO1xuICAgICAgICAgICAgY29uc3QgcmVmU2VlbiA9IGN0eC5zZWVuLmdldChyZWYpO1xuICAgICAgICAgICAgY29uc3QgcmVmU2NoZW1hID0gcmVmU2Vlbi5zY2hlbWE7XG4gICAgICAgICAgICAvLyBtZXJnZSByZWZlcmVuY2VkIHNjaGVtYSBpbnRvIGN1cnJlbnRcbiAgICAgICAgICAgIGlmIChyZWZTY2hlbWEuJHJlZiAmJiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wN1wiIHx8IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIiB8fCBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpKSB7XG4gICAgICAgICAgICAgICAgLy8gb2xkZXIgZHJhZnRzIGNhbid0IGNvbWJpbmUgJHJlZiB3aXRoIG90aGVyIHByb3BlcnRpZXNcbiAgICAgICAgICAgICAgICBzY2hlbWEuYWxsT2YgPSBzY2hlbWEuYWxsT2YgPz8gW107XG4gICAgICAgICAgICAgICAgc2NoZW1hLmFsbE9mLnB1c2gocmVmU2NoZW1hKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2NoZW1hLCByZWZTY2hlbWEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVzdG9yZSBjaGlsZCdzIG93biBwcm9wZXJ0aWVzIChjaGlsZCB3aW5zKVxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzY2hlbWEsIF9jYWNoZWQpO1xuICAgICAgICAgICAgY29uc3QgaXNQYXJlbnRSZWYgPSB6b2RTY2hlbWEuX3pvZC5wYXJlbnQgPT09IHJlZjtcbiAgICAgICAgICAgIC8vIEZvciBwYXJlbnQgY2hhaW4sIGNoaWxkIGlzIGEgcmVmaW5lbWVudCAtIHJlbW92ZSBwYXJlbnQtb25seSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBpZiAoaXNQYXJlbnRSZWYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIgfHwga2V5ID09PSBcImFsbE9mXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIF9jYWNoZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBXaGVuIHJlZiB3YXMgZXh0cmFjdGVkIHRvICRkZWZzLCByZW1vdmUgcHJvcGVydGllcyB0aGF0IG1hdGNoIHRoZSBkZWZpbml0aW9uXG4gICAgICAgICAgICBpZiAocmVmU2NoZW1hLiRyZWYgJiYgcmVmU2Vlbi5kZWYpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gXCIkcmVmXCIgfHwga2V5ID09PSBcImFsbE9mXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiByZWZTZWVuLmRlZiAmJiBKU09OLnN0cmluZ2lmeShzY2hlbWFba2V5XSkgPT09IEpTT04uc3RyaW5naWZ5KHJlZlNlZW4uZGVmW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgcGFyZW50IHdhcyBleHRyYWN0ZWQgKGhhcyAkcmVmKSwgcHJvcGFnYXRlICRyZWYgdG8gdGhpcyBzY2hlbWFcbiAgICAgICAgLy8gVGhpcyBoYW5kbGVzIGNhc2VzIGxpa2U6IHJlYWRvbmx5KCkubWV0YSh7aWR9KS5kZXNjcmliZSgpXG4gICAgICAgIC8vIHdoZXJlIHByb2Nlc3NvciBzZXRzIHJlZiB0byBpbm5lclR5cGUgYnV0IHBhcmVudCBzaG91bGQgYmUgcmVmZXJlbmNlZFxuICAgICAgICBjb25zdCBwYXJlbnQgPSB6b2RTY2hlbWEuX3pvZC5wYXJlbnQ7XG4gICAgICAgIGlmIChwYXJlbnQgJiYgcGFyZW50ICE9PSByZWYpIHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSBwYXJlbnQgaXMgcHJvY2Vzc2VkIGZpcnN0IHNvIGl0cyBkZWYgaGFzIGluaGVyaXRlZCBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBmbGF0dGVuUmVmKHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnRTZWVuID0gY3R4LnNlZW4uZ2V0KHBhcmVudCk7XG4gICAgICAgICAgICBpZiAocGFyZW50U2Vlbj8uc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgICAgICAgICBzY2hlbWEuJHJlZiA9IHBhcmVudFNlZW4uc2NoZW1hLiRyZWY7XG4gICAgICAgICAgICAgICAgLy8gRGUtZHVwbGljYXRlIHdpdGggcGFyZW50J3MgZGVmaW5pdGlvblxuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTZWVuLmRlZikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT09IFwiJHJlZlwiIHx8IGtleSA9PT0gXCJhbGxPZlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSBpbiBwYXJlbnRTZWVuLmRlZiAmJiBKU09OLnN0cmluZ2lmeShzY2hlbWFba2V5XSkgPT09IEpTT04uc3RyaW5naWZ5KHBhcmVudFNlZW4uZGVmW2tleV0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYVtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGV4ZWN1dGUgb3ZlcnJpZGVzXG4gICAgICAgIGN0eC5vdmVycmlkZSh7XG4gICAgICAgICAgICB6b2RTY2hlbWE6IHpvZFNjaGVtYSxcbiAgICAgICAgICAgIGpzb25TY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgICAgIHBhdGg6IHNlZW4ucGF0aCA/PyBbXSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIFsuLi5jdHguc2Vlbi5lbnRyaWVzKCldLnJldmVyc2UoKSkge1xuICAgICAgICBmbGF0dGVuUmVmKGVudHJ5WzBdKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiKSB7XG4gICAgICAgIHJlc3VsdC4kc2NoZW1hID0gXCJodHRwczovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC8yMDIwLTEyL3NjaGVtYVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA3XCIpIHtcbiAgICAgICAgcmVzdWx0LiRzY2hlbWEgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIpIHtcbiAgICAgICAgcmVzdWx0LiRzY2hlbWEgPSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hI1wiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgLy8gT3BlbkFQSSAzLjAgc2NoZW1hIG9iamVjdHMgc2hvdWxkIG5vdCBpbmNsdWRlIGEgJHNjaGVtYSBwcm9wZXJ0eVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQXJiaXRyYXJ5IHN0cmluZyB2YWx1ZXMgYXJlIGFsbG93ZWQgYnV0IHdvbid0IGhhdmUgYSAkc2NoZW1hIHByb3BlcnR5IHNldFxuICAgIH1cbiAgICBpZiAoY3R4LmV4dGVybmFsPy51cmkpIHtcbiAgICAgICAgY29uc3QgaWQgPSBjdHguZXh0ZXJuYWwucmVnaXN0cnkuZ2V0KHNjaGVtYSk/LmlkO1xuICAgICAgICBpZiAoIWlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2NoZW1hIGlzIG1pc3NpbmcgYW4gYGlkYCBwcm9wZXJ0eVwiKTtcbiAgICAgICAgcmVzdWx0LiRpZCA9IGN0eC5leHRlcm5hbC51cmkoaWQpO1xuICAgIH1cbiAgICBPYmplY3QuYXNzaWduKHJlc3VsdCwgcm9vdC5kZWYgPz8gcm9vdC5zY2hlbWEpO1xuICAgIC8vIGJ1aWxkIGRlZnMgb2JqZWN0XG4gICAgY29uc3QgZGVmcyA9IGN0eC5leHRlcm5hbD8uZGVmcyA/PyB7fTtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGN0eC5zZWVuLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBzZWVuID0gZW50cnlbMV07XG4gICAgICAgIGlmIChzZWVuLmRlZiAmJiBzZWVuLmRlZklkKSB7XG4gICAgICAgICAgICBkZWZzW3NlZW4uZGVmSWRdID0gc2Vlbi5kZWY7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gc2V0IGRlZmluaXRpb25zIGluIHJlc3VsdFxuICAgIGlmIChjdHguZXh0ZXJuYWwpIHtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWZzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0yMDIwLTEyXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQuJGRlZnMgPSBkZWZzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRlZmluaXRpb25zID0gZGVmcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB0aGlzIFwiZmluYWxpemVzXCIgdGhpcyBzY2hlbWEgYW5kIGVuc3VyZXMgYWxsIGN5Y2xlcyBhcmUgcmVtb3ZlZFxuICAgICAgICAvLyBlYWNoIGNhbGwgdG8gZmluYWxpemUoKSBpcyBmdW5jdGlvbmFsbHkgaW5kZXBlbmRlbnRcbiAgICAgICAgLy8gdGhvdWdoIHRoZSBzZWVuIG1hcCBpcyBzaGFyZWRcbiAgICAgICAgY29uc3QgZmluYWxpemVkID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXN1bHQpKTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZpbmFsaXplZCwgXCJ+c3RhbmRhcmRcIiwge1xuICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAuLi5zY2hlbWFbXCJ+c3RhbmRhcmRcIl0sXG4gICAgICAgICAgICAgICAganNvblNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kKHNjaGVtYSwgXCJpbnB1dFwiLCBjdHgucHJvY2Vzc29ycyksXG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kKHNjaGVtYSwgXCJvdXRwdXRcIiwgY3R4LnByb2Nlc3NvcnMpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZmluYWxpemVkO1xuICAgIH1cbiAgICBjYXRjaCAoX2Vycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb252ZXJ0aW5nIHNjaGVtYSB0byBKU09OLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc1RyYW5zZm9ybWluZyhfc2NoZW1hLCBfY3R4KSB7XG4gICAgY29uc3QgY3R4ID0gX2N0eCA/PyB7IHNlZW46IG5ldyBTZXQoKSB9O1xuICAgIGlmIChjdHguc2Vlbi5oYXMoX3NjaGVtYSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjdHguc2Vlbi5hZGQoX3NjaGVtYSk7XG4gICAgY29uc3QgZGVmID0gX3NjaGVtYS5fem9kLmRlZjtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwidHJhbnNmb3JtXCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGlmIChkZWYudHlwZSA9PT0gXCJhcnJheVwiKVxuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmVsZW1lbnQsIGN0eCk7XG4gICAgaWYgKGRlZi50eXBlID09PSBcInNldFwiKVxuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLnZhbHVlVHlwZSwgY3R4KTtcbiAgICBpZiAoZGVmLnR5cGUgPT09IFwibGF6eVwiKVxuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmdldHRlcigpLCBjdHgpO1xuICAgIGlmIChkZWYudHlwZSA9PT0gXCJwcm9taXNlXCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwib3B0aW9uYWxcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJub25vcHRpb25hbFwiIHx8XG4gICAgICAgIGRlZi50eXBlID09PSBcIm51bGxhYmxlXCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwicmVhZG9ubHlcIiB8fFxuICAgICAgICBkZWYudHlwZSA9PT0gXCJkZWZhdWx0XCIgfHxcbiAgICAgICAgZGVmLnR5cGUgPT09IFwicHJlZmF1bHRcIikge1xuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmlubmVyVHlwZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGRlZi50eXBlID09PSBcImludGVyc2VjdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpc1RyYW5zZm9ybWluZyhkZWYubGVmdCwgY3R4KSB8fCBpc1RyYW5zZm9ybWluZyhkZWYucmlnaHQsIGN0eCk7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJyZWNvcmRcIiB8fCBkZWYudHlwZSA9PT0gXCJtYXBcIikge1xuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmtleVR5cGUsIGN0eCkgfHwgaXNUcmFuc2Zvcm1pbmcoZGVmLnZhbHVlVHlwZSwgY3R4KTtcbiAgICB9XG4gICAgaWYgKGRlZi50eXBlID09PSBcInBpcGVcIikge1xuICAgICAgICByZXR1cm4gaXNUcmFuc2Zvcm1pbmcoZGVmLmluLCBjdHgpIHx8IGlzVHJhbnNmb3JtaW5nKGRlZi5vdXQsIGN0eCk7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkZWYuc2hhcGUpIHtcbiAgICAgICAgICAgIGlmIChpc1RyYW5zZm9ybWluZyhkZWYuc2hhcGVba2V5XSwgY3R4KSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWYudHlwZSA9PT0gXCJ1bmlvblwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGRlZi5vcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoaXNUcmFuc2Zvcm1pbmcob3B0aW9uLCBjdHgpKVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlZi50eXBlID09PSBcInR1cGxlXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGRlZi5pdGVtcykge1xuICAgICAgICAgICAgaWYgKGlzVHJhbnNmb3JtaW5nKGl0ZW0sIGN0eCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlZi5yZXN0ICYmIGlzVHJhbnNmb3JtaW5nKGRlZi5yZXN0LCBjdHgpKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgdG9KU09OU2NoZW1hIG1ldGhvZCBmb3IgYSBzY2hlbWEgaW5zdGFuY2UuXG4gKiBUaGlzIGVuY2Fwc3VsYXRlcyB0aGUgbG9naWMgb2YgaW5pdGlhbGl6aW5nIGNvbnRleHQsIHByb2Nlc3NpbmcsIGV4dHJhY3RpbmcgZGVmcywgYW5kIGZpbmFsaXppbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVUb0pTT05TY2hlbWFNZXRob2QgPSAoc2NoZW1hLCBwcm9jZXNzb3JzID0ge30pID0+IChwYXJhbXMpID0+IHtcbiAgICBjb25zdCBjdHggPSBpbml0aWFsaXplQ29udGV4dCh7IC4uLnBhcmFtcywgcHJvY2Vzc29ycyB9KTtcbiAgICBwcm9jZXNzKHNjaGVtYSwgY3R4KTtcbiAgICBleHRyYWN0RGVmcyhjdHgsIHNjaGVtYSk7XG4gICAgcmV0dXJuIGZpbmFsaXplKGN0eCwgc2NoZW1hKTtcbn07XG5leHBvcnQgY29uc3QgY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kID0gKHNjaGVtYSwgaW8sIHByb2Nlc3NvcnMgPSB7fSkgPT4gKHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IHsgbGlicmFyeU9wdGlvbnMsIHRhcmdldCB9ID0gcGFyYW1zID8/IHt9O1xuICAgIGNvbnN0IGN0eCA9IGluaXRpYWxpemVDb250ZXh0KHsgLi4uKGxpYnJhcnlPcHRpb25zID8/IHt9KSwgdGFyZ2V0LCBpbywgcHJvY2Vzc29ycyB9KTtcbiAgICBwcm9jZXNzKHNjaGVtYSwgY3R4KTtcbiAgICBleHRyYWN0RGVmcyhjdHgsIHNjaGVtYSk7XG4gICAgcmV0dXJuIGZpbmFsaXplKGN0eCwgc2NoZW1hKTtcbn07XG4iLCAiaW1wb3J0IHsgZXh0cmFjdERlZnMsIGZpbmFsaXplLCBpbml0aWFsaXplQ29udGV4dCwgcHJvY2VzcywgfSBmcm9tIFwiLi90by1qc29uLXNjaGVtYS5qc1wiO1xuaW1wb3J0IHsgZ2V0RW51bVZhbHVlcyB9IGZyb20gXCIuL3V0aWwuanNcIjtcbmNvbnN0IGZvcm1hdE1hcCA9IHtcbiAgICBndWlkOiBcInV1aWRcIixcbiAgICB1cmw6IFwidXJpXCIsXG4gICAgZGF0ZXRpbWU6IFwiZGF0ZS10aW1lXCIsXG4gICAganNvbl9zdHJpbmc6IFwianNvbi1zdHJpbmdcIixcbiAgICByZWdleDogXCJcIiwgLy8gZG8gbm90IHNldFxufTtcbi8vID09PT09PT09PT09PT09PT09PT09IFNJTVBMRSBUWVBFIFBST0NFU1NPUlMgPT09PT09PT09PT09PT09PT09PT1cbmV4cG9ydCBjb25zdCBzdHJpbmdQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGpzb24udHlwZSA9IFwic3RyaW5nXCI7XG4gICAgY29uc3QgeyBtaW5pbXVtLCBtYXhpbXVtLCBmb3JtYXQsIHBhdHRlcm5zLCBjb250ZW50RW5jb2RpbmcgfSA9IHNjaGVtYS5fem9kXG4gICAgICAgIC5iYWc7XG4gICAgaWYgKHR5cGVvZiBtaW5pbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1pbkxlbmd0aCA9IG1pbmltdW07XG4gICAgaWYgKHR5cGVvZiBtYXhpbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1heExlbmd0aCA9IG1heGltdW07XG4gICAgLy8gY3VzdG9tIHBhdHRlcm4gb3ZlcnJpZGVzIGZvcm1hdFxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAganNvbi5mb3JtYXQgPSBmb3JtYXRNYXBbZm9ybWF0XSA/PyBmb3JtYXQ7XG4gICAgICAgIGlmIChqc29uLmZvcm1hdCA9PT0gXCJcIilcbiAgICAgICAgICAgIGRlbGV0ZSBqc29uLmZvcm1hdDsgLy8gZW1wdHkgZm9ybWF0IGlzIG5vdCB2YWxpZFxuICAgICAgICAvLyBKU09OIFNjaGVtYSBmb3JtYXQ6IFwidGltZVwiIHJlcXVpcmVzIGEgZnVsbCB0aW1lIHdpdGggb2Zmc2V0IG9yIFpcbiAgICAgICAgLy8gei5pc28udGltZSgpIGRvZXMgbm90IGluY2x1ZGUgdGltZXpvbmUgaW5mb3JtYXRpb24sIHNvIGZvcm1hdDogXCJ0aW1lXCIgc2hvdWxkIG5ldmVyIGJlIHVzZWRcbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gXCJ0aW1lXCIpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBqc29uLmZvcm1hdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29udGVudEVuY29kaW5nKVxuICAgICAgICBqc29uLmNvbnRlbnRFbmNvZGluZyA9IGNvbnRlbnRFbmNvZGluZztcbiAgICBpZiAocGF0dGVybnMgJiYgcGF0dGVybnMuc2l6ZSA+IDApIHtcbiAgICAgICAgY29uc3QgcmVnZXhlcyA9IFsuLi5wYXR0ZXJuc107XG4gICAgICAgIGlmIChyZWdleGVzLmxlbmd0aCA9PT0gMSlcbiAgICAgICAgICAgIGpzb24ucGF0dGVybiA9IHJlZ2V4ZXNbMF0uc291cmNlO1xuICAgICAgICBlbHNlIGlmIChyZWdleGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGpzb24uYWxsT2YgPSBbXG4gICAgICAgICAgICAgICAgLi4ucmVnZXhlcy5tYXAoKHJlZ2V4KSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi4oY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wN1wiIHx8IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIiB8fCBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCJcbiAgICAgICAgICAgICAgICAgICAgICAgID8geyB0eXBlOiBcInN0cmluZ1wiIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiByZWdleC5zb3VyY2UsXG4gICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbnVtYmVyUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0sIGZvcm1hdCwgbXVsdGlwbGVPZiwgZXhjbHVzaXZlTWF4aW11bSwgZXhjbHVzaXZlTWluaW11bSB9ID0gc2NoZW1hLl96b2QuYmFnO1xuICAgIGlmICh0eXBlb2YgZm9ybWF0ID09PSBcInN0cmluZ1wiICYmIGZvcm1hdC5pbmNsdWRlcyhcImludFwiKSlcbiAgICAgICAganNvbi50eXBlID0gXCJpbnRlZ2VyXCI7XG4gICAgZWxzZVxuICAgICAgICBqc29uLnR5cGUgPSBcIm51bWJlclwiO1xuICAgIGlmICh0eXBlb2YgZXhjbHVzaXZlTWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBpZiAoY3R4LnRhcmdldCA9PT0gXCJkcmFmdC0wNFwiIHx8IGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICAgICAganNvbi5taW5pbXVtID0gZXhjbHVzaXZlTWluaW11bTtcbiAgICAgICAgICAgIGpzb24uZXhjbHVzaXZlTWluaW11bSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBqc29uLmV4Y2x1c2l2ZU1pbmltdW0gPSBleGNsdXNpdmVNaW5pbXVtO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgbWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBqc29uLm1pbmltdW0gPSBtaW5pbXVtO1xuICAgICAgICBpZiAodHlwZW9mIGV4Y2x1c2l2ZU1pbmltdW0gPT09IFwibnVtYmVyXCIgJiYgY3R4LnRhcmdldCAhPT0gXCJkcmFmdC0wNFwiKSB7XG4gICAgICAgICAgICBpZiAoZXhjbHVzaXZlTWluaW11bSA+PSBtaW5pbXVtKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLm1pbmltdW07XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZGVsZXRlIGpzb24uZXhjbHVzaXZlTWluaW11bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGV4Y2x1c2l2ZU1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDRcIiB8fCBjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgICAgIGpzb24ubWF4aW11bSA9IGV4Y2x1c2l2ZU1heGltdW07XG4gICAgICAgICAgICBqc29uLmV4Y2x1c2l2ZU1heGltdW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAganNvbi5leGNsdXNpdmVNYXhpbXVtID0gZXhjbHVzaXZlTWF4aW11bTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAganNvbi5tYXhpbXVtID0gbWF4aW11bTtcbiAgICAgICAgaWYgKHR5cGVvZiBleGNsdXNpdmVNYXhpbXVtID09PSBcIm51bWJlclwiICYmIGN0eC50YXJnZXQgIT09IFwiZHJhZnQtMDRcIikge1xuICAgICAgICAgICAgaWYgKGV4Y2x1c2l2ZU1heGltdW0gPD0gbWF4aW11bSlcbiAgICAgICAgICAgICAgICBkZWxldGUganNvbi5tYXhpbXVtO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uLmV4Y2x1c2l2ZU1heGltdW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtdWx0aXBsZU9mID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm11bHRpcGxlT2YgPSBtdWx0aXBsZU9mO1xufTtcbmV4cG9ydCBjb25zdCBib29sZWFuUHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBqc29uLnR5cGUgPSBcImJvb2xlYW5cIjtcbn07XG5leHBvcnQgY29uc3QgYmlnaW50UHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkJpZ0ludCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBzeW1ib2xQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3ltYm9scyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBudWxsUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAganNvbi50eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAganNvbi5udWxsYWJsZSA9IHRydWU7XG4gICAgICAgIGpzb24uZW51bSA9IFtudWxsXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb24udHlwZSA9IFwibnVsbFwiO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdW5kZWZpbmVkUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZGVmaW5lZCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB2b2lkUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZvaWQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgbmV2ZXJQcm9jZXNzb3IgPSAoX3NjaGVtYSwgX2N0eCwganNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGpzb24ubm90ID0ge307XG59O1xuZXhwb3J0IGNvbnN0IGFueVByb2Nlc3NvciA9IChfc2NoZW1hLCBfY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIC8vIGVtcHR5IHNjaGVtYSBhY2NlcHRzIGFueXRoaW5nXG59O1xuZXhwb3J0IGNvbnN0IHVua25vd25Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgX2N0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICAvLyBlbXB0eSBzY2hlbWEgYWNjZXB0cyBhbnl0aGluZ1xufTtcbmV4cG9ydCBjb25zdCBkYXRlUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGUgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgZW51bVByb2Nlc3NvciA9IChzY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgdmFsdWVzID0gZ2V0RW51bVZhbHVlcyhkZWYuZW50cmllcyk7XG4gICAgLy8gTnVtYmVyIGVudW1zIGNhbiBoYXZlIGJvdGggc3RyaW5nIGFuZCBudW1iZXIgdmFsdWVzXG4gICAgaWYgKHZhbHVlcy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpKVxuICAgICAgICBqc29uLnR5cGUgPSBcIm51bWJlclwiO1xuICAgIGlmICh2YWx1ZXMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSlcbiAgICAgICAganNvbi50eXBlID0gXCJzdHJpbmdcIjtcbiAgICBqc29uLmVudW0gPSB2YWx1ZXM7XG59O1xuZXhwb3J0IGNvbnN0IGxpdGVyYWxQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgdmFscyA9IFtdO1xuICAgIGZvciAoY29uc3QgdmFsIG9mIGRlZi52YWx1ZXMpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGl0ZXJhbCBgdW5kZWZpbmVkYCBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBkbyBub3QgYWRkIHRvIHZhbHNcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSBcImJpZ2ludFwiKSB7XG4gICAgICAgICAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQmlnSW50IGxpdGVyYWxzIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHMucHVzaChOdW1iZXIodmFsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWxzLnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgLy8gZG8gbm90aGluZyAoYW4gdW5kZWZpbmVkIGxpdGVyYWwgd2FzIHN0cmlwcGVkKVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWxzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCB2YWwgPSB2YWxzWzBdO1xuICAgICAgICBqc29uLnR5cGUgPSB2YWwgPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiB2YWw7XG4gICAgICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTA0XCIgfHwgY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiKSB7XG4gICAgICAgICAgICBqc29uLmVudW0gPSBbdmFsXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGpzb24uY29uc3QgPSB2YWw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh2YWxzLmV2ZXJ5KCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIikpXG4gICAgICAgICAgICBqc29uLnR5cGUgPSBcIm51bWJlclwiO1xuICAgICAgICBpZiAodmFscy5ldmVyeSgodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIpKVxuICAgICAgICAgICAganNvbi50eXBlID0gXCJzdHJpbmdcIjtcbiAgICAgICAgaWYgKHZhbHMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcImJvb2xlYW5cIikpXG4gICAgICAgICAgICBqc29uLnR5cGUgPSBcImJvb2xlYW5cIjtcbiAgICAgICAgaWYgKHZhbHMuZXZlcnkoKHYpID0+IHYgPT09IG51bGwpKVxuICAgICAgICAgICAganNvbi50eXBlID0gXCJudWxsXCI7XG4gICAgICAgIGpzb24uZW51bSA9IHZhbHM7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBuYW5Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmFOIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHRlbXBsYXRlTGl0ZXJhbFByb2Nlc3NvciA9IChzY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBfanNvbiA9IGpzb247XG4gICAgY29uc3QgcGF0dGVybiA9IHNjaGVtYS5fem9kLnBhdHRlcm47XG4gICAgaWYgKCFwYXR0ZXJuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXR0ZXJuIG5vdCBmb3VuZCBpbiB0ZW1wbGF0ZSBsaXRlcmFsXCIpO1xuICAgIF9qc29uLnR5cGUgPSBcInN0cmluZ1wiO1xuICAgIF9qc29uLnBhdHRlcm4gPSBwYXR0ZXJuLnNvdXJjZTtcbn07XG5leHBvcnQgY29uc3QgZmlsZVByb2Nlc3NvciA9IChzY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBjb25zdCBfanNvbiA9IGpzb247XG4gICAgY29uc3QgZmlsZSA9IHtcbiAgICAgICAgdHlwZTogXCJzdHJpbmdcIixcbiAgICAgICAgZm9ybWF0OiBcImJpbmFyeVwiLFxuICAgICAgICBjb250ZW50RW5jb2Rpbmc6IFwiYmluYXJ5XCIsXG4gICAgfTtcbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0sIG1pbWUgfSA9IHNjaGVtYS5fem9kLmJhZztcbiAgICBpZiAobWluaW11bSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBmaWxlLm1pbkxlbmd0aCA9IG1pbmltdW07XG4gICAgaWYgKG1heGltdW0gIT09IHVuZGVmaW5lZClcbiAgICAgICAgZmlsZS5tYXhMZW5ndGggPSBtYXhpbXVtO1xuICAgIGlmIChtaW1lKSB7XG4gICAgICAgIGlmIChtaW1lLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgZmlsZS5jb250ZW50TWVkaWFUeXBlID0gbWltZVswXTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oX2pzb24sIGZpbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihfanNvbiwgZmlsZSk7IC8vIHNoYXJlZCBwcm9wcyBhdCByb290XG4gICAgICAgICAgICBfanNvbi5hbnlPZiA9IG1pbWUubWFwKChtKSA9PiAoeyBjb250ZW50TWVkaWFUeXBlOiBtIH0pKTsgLy8gb25seSBjb250ZW50TWVkaWFUeXBlIGRpZmZlcnNcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihfanNvbiwgZmlsZSk7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBzdWNjZXNzUHJvY2Vzc29yID0gKF9zY2hlbWEsIF9jdHgsIGpzb24sIF9wYXJhbXMpID0+IHtcbiAgICBqc29uLnR5cGUgPSBcImJvb2xlYW5cIjtcbn07XG5leHBvcnQgY29uc3QgY3VzdG9tUHJvY2Vzc29yID0gKF9zY2hlbWEsIGN0eCwgX2pzb24sIF9wYXJhbXMpID0+IHtcbiAgICBpZiAoY3R4LnVucmVwcmVzZW50YWJsZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkN1c3RvbSB0eXBlcyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBmdW5jdGlvblByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGdW5jdGlvbiB0eXBlcyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1Qcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNmb3JtcyBjYW5ub3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBtYXBQcm9jZXNzb3IgPSAoX3NjaGVtYSwgY3R4LCBfanNvbiwgX3BhcmFtcykgPT4ge1xuICAgIGlmIChjdHgudW5yZXByZXNlbnRhYmxlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWFwIGNhbm5vdCBiZSByZXByZXNlbnRlZCBpbiBKU09OIFNjaGVtYVwiKTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IHNldFByb2Nlc3NvciA9IChfc2NoZW1hLCBjdHgsIF9qc29uLCBfcGFyYW1zKSA9PiB7XG4gICAgaWYgKGN0eC51bnJlcHJlc2VudGFibGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTZXQgY2Fubm90IGJlIHJlcHJlc2VudGVkIGluIEpTT04gU2NoZW1hXCIpO1xuICAgIH1cbn07XG4vLyA9PT09PT09PT09PT09PT09PT09PSBDT01QT1NJVEUgVFlQRSBQUk9DRVNTT1JTID09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgY29uc3QgYXJyYXlQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBqc29uID0gX2pzb247XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIGNvbnN0IHsgbWluaW11bSwgbWF4aW11bSB9ID0gc2NoZW1hLl96b2QuYmFnO1xuICAgIGlmICh0eXBlb2YgbWluaW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5taW5JdGVtcyA9IG1pbmltdW07XG4gICAgaWYgKHR5cGVvZiBtYXhpbXVtID09PSBcIm51bWJlclwiKVxuICAgICAgICBqc29uLm1heEl0ZW1zID0gbWF4aW11bTtcbiAgICBqc29uLnR5cGUgPSBcImFycmF5XCI7XG4gICAganNvbi5pdGVtcyA9IHByb2Nlc3MoZGVmLmVsZW1lbnQsIGN0eCwgeyAuLi5wYXJhbXMsIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJpdGVtc1wiXSB9KTtcbn07XG5leHBvcnQgY29uc3Qgb2JqZWN0UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QganNvbiA9IF9qc29uO1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBqc29uLnR5cGUgPSBcIm9iamVjdFwiO1xuICAgIGpzb24ucHJvcGVydGllcyA9IHt9O1xuICAgIGNvbnN0IHNoYXBlID0gZGVmLnNoYXBlO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHNoYXBlKSB7XG4gICAgICAgIGpzb24ucHJvcGVydGllc1trZXldID0gcHJvY2VzcyhzaGFwZVtrZXldLCBjdHgsIHtcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJwcm9wZXJ0aWVzXCIsIGtleV0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyByZXF1aXJlZCBrZXlzXG4gICAgY29uc3QgYWxsS2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoc2hhcGUpKTtcbiAgICBjb25zdCByZXF1aXJlZEtleXMgPSBuZXcgU2V0KFsuLi5hbGxLZXlzXS5maWx0ZXIoKGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2ID0gZGVmLnNoYXBlW2tleV0uX3pvZDtcbiAgICAgICAgaWYgKGN0eC5pbyA9PT0gXCJpbnB1dFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdi5vcHRpbiA9PT0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHYub3B0b3V0ID09PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KSk7XG4gICAgaWYgKHJlcXVpcmVkS2V5cy5zaXplID4gMCkge1xuICAgICAgICBqc29uLnJlcXVpcmVkID0gQXJyYXkuZnJvbShyZXF1aXJlZEtleXMpO1xuICAgIH1cbiAgICAvLyBjYXRjaGFsbFxuICAgIGlmIChkZWYuY2F0Y2hhbGw/Ll96b2QuZGVmLnR5cGUgPT09IFwibmV2ZXJcIikge1xuICAgICAgICAvLyBzdHJpY3RcbiAgICAgICAganNvbi5hZGRpdGlvbmFsUHJvcGVydGllcyA9IGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghZGVmLmNhdGNoYWxsKSB7XG4gICAgICAgIC8vIHJlZ3VsYXJcbiAgICAgICAgaWYgKGN0eC5pbyA9PT0gXCJvdXRwdXRcIilcbiAgICAgICAgICAgIGpzb24uYWRkaXRpb25hbFByb3BlcnRpZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGVmLmNhdGNoYWxsKSB7XG4gICAgICAgIGpzb24uYWRkaXRpb25hbFByb3BlcnRpZXMgPSBwcm9jZXNzKGRlZi5jYXRjaGFsbCwgY3R4LCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIl0sXG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5leHBvcnQgY29uc3QgdW5pb25Qcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICAvLyBFeGNsdXNpdmUgdW5pb25zIChpbmNsdXNpdmUgPT09IGZhbHNlKSB1c2Ugb25lT2YgKGV4YWN0bHkgb25lIG1hdGNoKSBpbnN0ZWFkIG9mIGFueU9mIChvbmUgb3IgbW9yZSBtYXRjaGVzKVxuICAgIC8vIFRoaXMgaW5jbHVkZXMgYm90aCB6LnhvcigpIGFuZCBkaXNjcmltaW5hdGVkIHVuaW9uc1xuICAgIGNvbnN0IGlzRXhjbHVzaXZlID0gZGVmLmluY2x1c2l2ZSA9PT0gZmFsc2U7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGRlZi5vcHRpb25zLm1hcCgoeCwgaSkgPT4gcHJvY2Vzcyh4LCBjdHgsIHtcbiAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIGlzRXhjbHVzaXZlID8gXCJvbmVPZlwiIDogXCJhbnlPZlwiLCBpXSxcbiAgICB9KSk7XG4gICAgaWYgKGlzRXhjbHVzaXZlKSB7XG4gICAgICAgIGpzb24ub25lT2YgPSBvcHRpb25zO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbi5hbnlPZiA9IG9wdGlvbnM7XG4gICAgfVxufTtcbmV4cG9ydCBjb25zdCBpbnRlcnNlY3Rpb25Qcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBjb25zdCBhID0gcHJvY2VzcyhkZWYubGVmdCwgY3R4LCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcImFsbE9mXCIsIDBdLFxuICAgIH0pO1xuICAgIGNvbnN0IGIgPSBwcm9jZXNzKGRlZi5yaWdodCwgY3R4LCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBcImFsbE9mXCIsIDFdLFxuICAgIH0pO1xuICAgIGNvbnN0IGlzU2ltcGxlSW50ZXJzZWN0aW9uID0gKHZhbCkgPT4gXCJhbGxPZlwiIGluIHZhbCAmJiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMTtcbiAgICBjb25zdCBhbGxPZiA9IFtcbiAgICAgICAgLi4uKGlzU2ltcGxlSW50ZXJzZWN0aW9uKGEpID8gYS5hbGxPZiA6IFthXSksXG4gICAgICAgIC4uLihpc1NpbXBsZUludGVyc2VjdGlvbihiKSA/IGIuYWxsT2YgOiBbYl0pLFxuICAgIF07XG4gICAganNvbi5hbGxPZiA9IGFsbE9mO1xufTtcbmV4cG9ydCBjb25zdCB0dXBsZVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAganNvbi50eXBlID0gXCJhcnJheVwiO1xuICAgIGNvbnN0IHByZWZpeFBhdGggPSBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIiA/IFwicHJlZml4SXRlbXNcIiA6IFwiaXRlbXNcIjtcbiAgICBjb25zdCByZXN0UGF0aCA9IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiID8gXCJpdGVtc1wiIDogY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiID8gXCJpdGVtc1wiIDogXCJhZGRpdGlvbmFsSXRlbXNcIjtcbiAgICBjb25zdCBwcmVmaXhJdGVtcyA9IGRlZi5pdGVtcy5tYXAoKHgsIGkpID0+IHByb2Nlc3MoeCwgY3R4LCB7XG4gICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgcGF0aDogWy4uLnBhcmFtcy5wYXRoLCBwcmVmaXhQYXRoLCBpXSxcbiAgICB9KSk7XG4gICAgY29uc3QgcmVzdCA9IGRlZi5yZXN0XG4gICAgICAgID8gcHJvY2VzcyhkZWYucmVzdCwgY3R4LCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIHJlc3RQYXRoLCAuLi4oY3R4LnRhcmdldCA9PT0gXCJvcGVuYXBpLTMuMFwiID8gW2RlZi5pdGVtcy5sZW5ndGhdIDogW10pXSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBudWxsO1xuICAgIGlmIChjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIikge1xuICAgICAgICBqc29uLnByZWZpeEl0ZW1zID0gcHJlZml4SXRlbXM7XG4gICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICBqc29uLml0ZW1zID0gcmVzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChjdHgudGFyZ2V0ID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAganNvbi5pdGVtcyA9IHtcbiAgICAgICAgICAgIGFueU9mOiBwcmVmaXhJdGVtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgIGpzb24uaXRlbXMuYW55T2YucHVzaChyZXN0KTtcbiAgICAgICAgfVxuICAgICAgICBqc29uLm1pbkl0ZW1zID0gcHJlZml4SXRlbXMubGVuZ3RoO1xuICAgICAgICBpZiAoIXJlc3QpIHtcbiAgICAgICAgICAgIGpzb24ubWF4SXRlbXMgPSBwcmVmaXhJdGVtcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGpzb24uaXRlbXMgPSBwcmVmaXhJdGVtcztcbiAgICAgICAgaWYgKHJlc3QpIHtcbiAgICAgICAgICAgIGpzb24uYWRkaXRpb25hbEl0ZW1zID0gcmVzdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBsZW5ndGhcbiAgICBjb25zdCB7IG1pbmltdW0sIG1heGltdW0gfSA9IHNjaGVtYS5fem9kLmJhZztcbiAgICBpZiAodHlwZW9mIG1pbmltdW0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgIGpzb24ubWluSXRlbXMgPSBtaW5pbXVtO1xuICAgIGlmICh0eXBlb2YgbWF4aW11bSA9PT0gXCJudW1iZXJcIilcbiAgICAgICAganNvbi5tYXhJdGVtcyA9IG1heGltdW07XG59O1xuZXhwb3J0IGNvbnN0IHJlY29yZFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGpzb24gPSBfanNvbjtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAganNvbi50eXBlID0gXCJvYmplY3RcIjtcbiAgICAvLyBGb3IgbG9vc2VSZWNvcmQgd2l0aCByZWdleCBwYXR0ZXJucywgdXNlIHBhdHRlcm5Qcm9wZXJ0aWVzXG4gICAgLy8gVGhpcyBjb3JyZWN0bHkgcmVwcmVzZW50cyBcIm9ubHkgdmFsaWRhdGUga2V5cyBtYXRjaGluZyB0aGUgcGF0dGVyblwiIHNlbWFudGljc1xuICAgIC8vIGFuZCBjb21wb3NlcyB3ZWxsIHdpdGggYWxsT2YgKGludGVyc2VjdGlvbnMpXG4gICAgY29uc3Qga2V5VHlwZSA9IGRlZi5rZXlUeXBlO1xuICAgIGNvbnN0IGtleUJhZyA9IGtleVR5cGUuX3pvZC5iYWc7XG4gICAgY29uc3QgcGF0dGVybnMgPSBrZXlCYWc/LnBhdHRlcm5zO1xuICAgIGlmIChkZWYubW9kZSA9PT0gXCJsb29zZVwiICYmIHBhdHRlcm5zICYmIHBhdHRlcm5zLnNpemUgPiAwKSB7XG4gICAgICAgIC8vIFVzZSBwYXR0ZXJuUHJvcGVydGllcyBmb3IgbG9vc2VSZWNvcmQgd2l0aCByZWdleCBwYXR0ZXJuc1xuICAgICAgICBjb25zdCB2YWx1ZVNjaGVtYSA9IHByb2Nlc3MoZGVmLnZhbHVlVHlwZSwgY3R4LCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwicGF0dGVyblByb3BlcnRpZXNcIiwgXCIqXCJdLFxuICAgICAgICB9KTtcbiAgICAgICAganNvbi5wYXR0ZXJuUHJvcGVydGllcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybnMpIHtcbiAgICAgICAgICAgIGpzb24ucGF0dGVyblByb3BlcnRpZXNbcGF0dGVybi5zb3VyY2VdID0gdmFsdWVTY2hlbWE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3I6IHVzZSBwcm9wZXJ0eU5hbWVzICsgYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgICAgaWYgKGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMDdcIiB8fCBjdHgudGFyZ2V0ID09PSBcImRyYWZ0LTIwMjAtMTJcIikge1xuICAgICAgICAgICAganNvbi5wcm9wZXJ0eU5hbWVzID0gcHJvY2VzcyhkZWYua2V5VHlwZSwgY3R4LCB7XG4gICAgICAgICAgICAgICAgLi4ucGFyYW1zLFxuICAgICAgICAgICAgICAgIHBhdGg6IFsuLi5wYXJhbXMucGF0aCwgXCJwcm9wZXJ0eU5hbWVzXCJdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAganNvbi5hZGRpdGlvbmFsUHJvcGVydGllcyA9IHByb2Nlc3MoZGVmLnZhbHVlVHlwZSwgY3R4LCB7XG4gICAgICAgICAgICAuLi5wYXJhbXMsXG4gICAgICAgICAgICBwYXRoOiBbLi4ucGFyYW1zLnBhdGgsIFwiYWRkaXRpb25hbFByb3BlcnRpZXNcIl0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBBZGQgcmVxdWlyZWQgZm9yIGtleXMgd2l0aCBkaXNjcmV0ZSB2YWx1ZXMgKGVudW0sIGxpdGVyYWwsIGV0Yy4pXG4gICAgY29uc3Qga2V5VmFsdWVzID0ga2V5VHlwZS5fem9kLnZhbHVlcztcbiAgICBpZiAoa2V5VmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkS2V5VmFsdWVzID0gWy4uLmtleVZhbHVlc10uZmlsdGVyKCh2KSA9PiB0eXBlb2YgdiA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdiA9PT0gXCJudW1iZXJcIik7XG4gICAgICAgIGlmICh2YWxpZEtleVZhbHVlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBqc29uLnJlcXVpcmVkID0gdmFsaWRLZXlWYWx1ZXM7XG4gICAgICAgIH1cbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG51bGxhYmxlUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgaW5uZXIgPSBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgaWYgKGN0eC50YXJnZXQgPT09IFwib3BlbmFwaS0zLjBcIikge1xuICAgICAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG4gICAgICAgIGpzb24ubnVsbGFibGUgPSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAganNvbi5hbnlPZiA9IFtpbm5lciwgeyB0eXBlOiBcIm51bGxcIiB9XTtcbiAgICB9XG59O1xuZXhwb3J0IGNvbnN0IG5vbm9wdGlvbmFsUHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG59O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIGpzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xuICAgIGpzb24uZGVmYXVsdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmLmRlZmF1bHRWYWx1ZSkpO1xufTtcbmV4cG9ydCBjb25zdCBwcmVmYXVsdFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG4gICAgaWYgKGN0eC5pbyA9PT0gXCJpbnB1dFwiKVxuICAgICAgICBqc29uLl9wcmVmYXVsdCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoZGVmLmRlZmF1bHRWYWx1ZSkpO1xufTtcbmV4cG9ydCBjb25zdCBjYXRjaFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwganNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgZGVmID0gc2NoZW1hLl96b2QuZGVmO1xuICAgIHByb2Nlc3MoZGVmLmlubmVyVHlwZSwgY3R4LCBwYXJhbXMpO1xuICAgIGNvbnN0IHNlZW4gPSBjdHguc2Vlbi5nZXQoc2NoZW1hKTtcbiAgICBzZWVuLnJlZiA9IGRlZi5pbm5lclR5cGU7XG4gICAgbGV0IGNhdGNoVmFsdWU7XG4gICAgdHJ5IHtcbiAgICAgICAgY2F0Y2hWYWx1ZSA9IGRlZi5jYXRjaFZhbHVlKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHluYW1pYyBjYXRjaCB2YWx1ZXMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gSlNPTiBTY2hlbWFcIik7XG4gICAgfVxuICAgIGpzb24uZGVmYXVsdCA9IGNhdGNoVmFsdWU7XG59O1xuZXhwb3J0IGNvbnN0IHBpcGVQcm9jZXNzb3IgPSAoc2NoZW1hLCBjdHgsIF9qc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgY29uc3QgaW5uZXJUeXBlID0gY3R4LmlvID09PSBcImlucHV0XCIgPyAoZGVmLmluLl96b2QuZGVmLnR5cGUgPT09IFwidHJhbnNmb3JtXCIgPyBkZWYub3V0IDogZGVmLmluKSA6IGRlZi5vdXQ7XG4gICAgcHJvY2Vzcyhpbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBpbm5lclR5cGU7XG59O1xuZXhwb3J0IGNvbnN0IHJlYWRvbmx5UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBqc29uLCBwYXJhbXMpID0+IHtcbiAgICBjb25zdCBkZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG4gICAgcHJvY2VzcyhkZWYuaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gZGVmLmlubmVyVHlwZTtcbiAgICBqc29uLnJlYWRPbmx5ID0gdHJ1ZTtcbn07XG5leHBvcnQgY29uc3QgcHJvbWlzZVByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xufTtcbmV4cG9ydCBjb25zdCBvcHRpb25hbFByb2Nlc3NvciA9IChzY2hlbWEsIGN0eCwgX2pzb24sIHBhcmFtcykgPT4ge1xuICAgIGNvbnN0IGRlZiA9IHNjaGVtYS5fem9kLmRlZjtcbiAgICBwcm9jZXNzKGRlZi5pbm5lclR5cGUsIGN0eCwgcGFyYW1zKTtcbiAgICBjb25zdCBzZWVuID0gY3R4LnNlZW4uZ2V0KHNjaGVtYSk7XG4gICAgc2Vlbi5yZWYgPSBkZWYuaW5uZXJUeXBlO1xufTtcbmV4cG9ydCBjb25zdCBsYXp5UHJvY2Vzc29yID0gKHNjaGVtYSwgY3R4LCBfanNvbiwgcGFyYW1zKSA9PiB7XG4gICAgY29uc3QgaW5uZXJUeXBlID0gc2NoZW1hLl96b2QuaW5uZXJUeXBlO1xuICAgIHByb2Nlc3MoaW5uZXJUeXBlLCBjdHgsIHBhcmFtcyk7XG4gICAgY29uc3Qgc2VlbiA9IGN0eC5zZWVuLmdldChzY2hlbWEpO1xuICAgIHNlZW4ucmVmID0gaW5uZXJUeXBlO1xufTtcbi8vID09PT09PT09PT09PT09PT09PT09IEFMTCBQUk9DRVNTT1JTID09PT09PT09PT09PT09PT09PT09XG5leHBvcnQgY29uc3QgYWxsUHJvY2Vzc29ycyA9IHtcbiAgICBzdHJpbmc6IHN0cmluZ1Byb2Nlc3NvcixcbiAgICBudW1iZXI6IG51bWJlclByb2Nlc3NvcixcbiAgICBib29sZWFuOiBib29sZWFuUHJvY2Vzc29yLFxuICAgIGJpZ2ludDogYmlnaW50UHJvY2Vzc29yLFxuICAgIHN5bWJvbDogc3ltYm9sUHJvY2Vzc29yLFxuICAgIG51bGw6IG51bGxQcm9jZXNzb3IsXG4gICAgdW5kZWZpbmVkOiB1bmRlZmluZWRQcm9jZXNzb3IsXG4gICAgdm9pZDogdm9pZFByb2Nlc3NvcixcbiAgICBuZXZlcjogbmV2ZXJQcm9jZXNzb3IsXG4gICAgYW55OiBhbnlQcm9jZXNzb3IsXG4gICAgdW5rbm93bjogdW5rbm93blByb2Nlc3NvcixcbiAgICBkYXRlOiBkYXRlUHJvY2Vzc29yLFxuICAgIGVudW06IGVudW1Qcm9jZXNzb3IsXG4gICAgbGl0ZXJhbDogbGl0ZXJhbFByb2Nlc3NvcixcbiAgICBuYW46IG5hblByb2Nlc3NvcixcbiAgICB0ZW1wbGF0ZV9saXRlcmFsOiB0ZW1wbGF0ZUxpdGVyYWxQcm9jZXNzb3IsXG4gICAgZmlsZTogZmlsZVByb2Nlc3NvcixcbiAgICBzdWNjZXNzOiBzdWNjZXNzUHJvY2Vzc29yLFxuICAgIGN1c3RvbTogY3VzdG9tUHJvY2Vzc29yLFxuICAgIGZ1bmN0aW9uOiBmdW5jdGlvblByb2Nlc3NvcixcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybVByb2Nlc3NvcixcbiAgICBtYXA6IG1hcFByb2Nlc3NvcixcbiAgICBzZXQ6IHNldFByb2Nlc3NvcixcbiAgICBhcnJheTogYXJyYXlQcm9jZXNzb3IsXG4gICAgb2JqZWN0OiBvYmplY3RQcm9jZXNzb3IsXG4gICAgdW5pb246IHVuaW9uUHJvY2Vzc29yLFxuICAgIGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uUHJvY2Vzc29yLFxuICAgIHR1cGxlOiB0dXBsZVByb2Nlc3NvcixcbiAgICByZWNvcmQ6IHJlY29yZFByb2Nlc3NvcixcbiAgICBudWxsYWJsZTogbnVsbGFibGVQcm9jZXNzb3IsXG4gICAgbm9ub3B0aW9uYWw6IG5vbm9wdGlvbmFsUHJvY2Vzc29yLFxuICAgIGRlZmF1bHQ6IGRlZmF1bHRQcm9jZXNzb3IsXG4gICAgcHJlZmF1bHQ6IHByZWZhdWx0UHJvY2Vzc29yLFxuICAgIGNhdGNoOiBjYXRjaFByb2Nlc3NvcixcbiAgICBwaXBlOiBwaXBlUHJvY2Vzc29yLFxuICAgIHJlYWRvbmx5OiByZWFkb25seVByb2Nlc3NvcixcbiAgICBwcm9taXNlOiBwcm9taXNlUHJvY2Vzc29yLFxuICAgIG9wdGlvbmFsOiBvcHRpb25hbFByb2Nlc3NvcixcbiAgICBsYXp5OiBsYXp5UHJvY2Vzc29yLFxufTtcbmV4cG9ydCBmdW5jdGlvbiB0b0pTT05TY2hlbWEoaW5wdXQsIHBhcmFtcykge1xuICAgIGlmIChcIl9pZG1hcFwiIGluIGlucHV0KSB7XG4gICAgICAgIC8vIFJlZ2lzdHJ5IGNhc2VcbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBpbnB1dDtcbiAgICAgICAgY29uc3QgY3R4ID0gaW5pdGlhbGl6ZUNvbnRleHQoeyAuLi5wYXJhbXMsIHByb2Nlc3NvcnM6IGFsbFByb2Nlc3NvcnMgfSk7XG4gICAgICAgIGNvbnN0IGRlZnMgPSB7fTtcbiAgICAgICAgLy8gRmlyc3QgcGFzczogcHJvY2VzcyBhbGwgc2NoZW1hcyB0byBidWlsZCB0aGUgc2VlbiBtYXBcbiAgICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiByZWdpc3RyeS5faWRtYXAuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjb25zdCBbXywgc2NoZW1hXSA9IGVudHJ5O1xuICAgICAgICAgICAgcHJvY2VzcyhzY2hlbWEsIGN0eCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hcyA9IHt9O1xuICAgICAgICBjb25zdCBleHRlcm5hbCA9IHtcbiAgICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICAgICAgdXJpOiBwYXJhbXM/LnVyaSxcbiAgICAgICAgICAgIGRlZnMsXG4gICAgICAgIH07XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY29udGV4dCB3aXRoIGV4dGVybmFsIGNvbmZpZ3VyYXRpb25cbiAgICAgICAgY3R4LmV4dGVybmFsID0gZXh0ZXJuYWw7XG4gICAgICAgIC8vIFNlY29uZCBwYXNzOiBlbWl0IGVhY2ggc2NoZW1hXG4gICAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgcmVnaXN0cnkuX2lkbWFwLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgW2tleSwgc2NoZW1hXSA9IGVudHJ5O1xuICAgICAgICAgICAgZXh0cmFjdERlZnMoY3R4LCBzY2hlbWEpO1xuICAgICAgICAgICAgc2NoZW1hc1trZXldID0gZmluYWxpemUoY3R4LCBzY2hlbWEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkZWZzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZzU2VnbWVudCA9IGN0eC50YXJnZXQgPT09IFwiZHJhZnQtMjAyMC0xMlwiID8gXCIkZGVmc1wiIDogXCJkZWZpbml0aW9uc1wiO1xuICAgICAgICAgICAgc2NoZW1hcy5fX3NoYXJlZCA9IHtcbiAgICAgICAgICAgICAgICBbZGVmc1NlZ21lbnRdOiBkZWZzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzY2hlbWFzIH07XG4gICAgfVxuICAgIC8vIFNpbmdsZSBzY2hlbWEgY2FzZVxuICAgIGNvbnN0IGN0eCA9IGluaXRpYWxpemVDb250ZXh0KHsgLi4ucGFyYW1zLCBwcm9jZXNzb3JzOiBhbGxQcm9jZXNzb3JzIH0pO1xuICAgIHByb2Nlc3MoaW5wdXQsIGN0eCk7XG4gICAgZXh0cmFjdERlZnMoY3R4LCBpbnB1dCk7XG4gICAgcmV0dXJuIGZpbmFsaXplKGN0eCwgaW5wdXQpO1xufVxuIiwgbnVsbCwgImltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCB7IHV0aWwgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuaW1wb3J0ICogYXMgcHJvY2Vzc29ycyBmcm9tIFwiLi4vY29yZS9qc29uLXNjaGVtYS1wcm9jZXNzb3JzLmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVTdGFuZGFyZEpTT05TY2hlbWFNZXRob2QsIGNyZWF0ZVRvSlNPTlNjaGVtYU1ldGhvZCB9IGZyb20gXCIuLi9jb3JlL3RvLWpzb24tc2NoZW1hLmpzXCI7XG5pbXBvcnQgKiBhcyBjaGVja3MgZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgKiBhcyBpc28gZnJvbSBcIi4vaXNvLmpzXCI7XG5pbXBvcnQgKiBhcyBwYXJzZSBmcm9tIFwiLi9wYXJzZS5qc1wiO1xuZXhwb3J0IGNvbnN0IFpvZFR5cGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgT2JqZWN0LmFzc2lnbihpbnN0W1wifnN0YW5kYXJkXCJdLCB7XG4gICAgICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICAgICAgIGlucHV0OiBjcmVhdGVTdGFuZGFyZEpTT05TY2hlbWFNZXRob2QoaW5zdCwgXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIG91dHB1dDogY3JlYXRlU3RhbmRhcmRKU09OU2NoZW1hTWV0aG9kKGluc3QsIFwib3V0cHV0XCIpLFxuICAgICAgICB9LFxuICAgIH0pO1xuICAgIGluc3QudG9KU09OU2NoZW1hID0gY3JlYXRlVG9KU09OU2NoZW1hTWV0aG9kKGluc3QsIHt9KTtcbiAgICBpbnN0LmRlZiA9IGRlZjtcbiAgICBpbnN0LnR5cGUgPSBkZWYudHlwZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfZGVmXCIsIHsgdmFsdWU6IGRlZiB9KTtcbiAgICAvLyBiYXNlIG1ldGhvZHNcbiAgICBpbnN0LmNoZWNrID0gKC4uLmNoZWNrcykgPT4ge1xuICAgICAgICByZXR1cm4gaW5zdC5jbG9uZSh1dGlsLm1lcmdlRGVmcyhkZWYsIHtcbiAgICAgICAgICAgIGNoZWNrczogW1xuICAgICAgICAgICAgICAgIC4uLihkZWYuY2hlY2tzID8/IFtdKSxcbiAgICAgICAgICAgICAgICAuLi5jaGVja3MubWFwKChjaCkgPT4gdHlwZW9mIGNoID09PSBcImZ1bmN0aW9uXCIgPyB7IF96b2Q6IHsgY2hlY2s6IGNoLCBkZWY6IHsgY2hlY2s6IFwiY3VzdG9tXCIgfSwgb25hdHRhY2g6IFtdIH0gfSA6IGNoKSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgICBwYXJlbnQ6IHRydWUsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaW5zdC53aXRoID0gaW5zdC5jaGVjaztcbiAgICBpbnN0LmNsb25lID0gKGRlZiwgcGFyYW1zKSA9PiBjb3JlLmNsb25lKGluc3QsIGRlZiwgcGFyYW1zKTtcbiAgICBpbnN0LmJyYW5kID0gKCkgPT4gaW5zdDtcbiAgICBpbnN0LnJlZ2lzdGVyID0gKChyZWcsIG1ldGEpID0+IHtcbiAgICAgICAgcmVnLmFkZChpbnN0LCBtZXRhKTtcbiAgICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSk7XG4gICAgLy8gcGFyc2luZ1xuICAgIGluc3QucGFyc2UgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5wYXJzZShpbnN0LCBkYXRhLCBwYXJhbXMsIHsgY2FsbGVlOiBpbnN0LnBhcnNlIH0pO1xuICAgIGluc3Quc2FmZVBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gcGFyc2Uuc2FmZVBhcnNlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5wYXJzZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gcGFyc2UucGFyc2VBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMsIHsgY2FsbGVlOiBpbnN0LnBhcnNlQXN5bmMgfSk7XG4gICAgaW5zdC5zYWZlUGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVQYXJzZUFzeW5jKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zcGEgPSBpbnN0LnNhZmVQYXJzZUFzeW5jO1xuICAgIC8vIGVuY29kaW5nL2RlY29kaW5nXG4gICAgaW5zdC5lbmNvZGUgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5lbmNvZGUoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LmRlY29kZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLmRlY29kZShpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3QuZW5jb2RlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5lbmNvZGVBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3QuZGVjb2RlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5kZWNvZGVBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIGluc3Quc2FmZUVuY29kZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVFbmNvZGUoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnNhZmVEZWNvZGUgPSAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlRGVjb2RlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG4gICAgaW5zdC5zYWZlRW5jb2RlQXN5bmMgPSBhc3luYyAoZGF0YSwgcGFyYW1zKSA9PiBwYXJzZS5zYWZlRW5jb2RlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcbiAgICBpbnN0LnNhZmVEZWNvZGVBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlLnNhZmVEZWNvZGVBc3luYyhpbnN0LCBkYXRhLCBwYXJhbXMpO1xuICAgIC8vIHJlZmluZW1lbnRzXG4gICAgaW5zdC5yZWZpbmUgPSAoY2hlY2ssIHBhcmFtcykgPT4gaW5zdC5jaGVjayhyZWZpbmUoY2hlY2ssIHBhcmFtcykpO1xuICAgIGluc3Quc3VwZXJSZWZpbmUgPSAocmVmaW5lbWVudCkgPT4gaW5zdC5jaGVjayhzdXBlclJlZmluZShyZWZpbmVtZW50KSk7XG4gICAgaW5zdC5vdmVyd3JpdGUgPSAoZm4pID0+IGluc3QuY2hlY2soY2hlY2tzLm92ZXJ3cml0ZShmbikpO1xuICAgIC8vIHdyYXBwZXJzXG4gICAgaW5zdC5vcHRpb25hbCA9ICgpID0+IG9wdGlvbmFsKGluc3QpO1xuICAgIGluc3QuZXhhY3RPcHRpb25hbCA9ICgpID0+IGV4YWN0T3B0aW9uYWwoaW5zdCk7XG4gICAgaW5zdC5udWxsYWJsZSA9ICgpID0+IG51bGxhYmxlKGluc3QpO1xuICAgIGluc3QubnVsbGlzaCA9ICgpID0+IG9wdGlvbmFsKG51bGxhYmxlKGluc3QpKTtcbiAgICBpbnN0Lm5vbm9wdGlvbmFsID0gKHBhcmFtcykgPT4gbm9ub3B0aW9uYWwoaW5zdCwgcGFyYW1zKTtcbiAgICBpbnN0LmFycmF5ID0gKCkgPT4gYXJyYXkoaW5zdCk7XG4gICAgaW5zdC5vciA9IChhcmcpID0+IHVuaW9uKFtpbnN0LCBhcmddKTtcbiAgICBpbnN0LmFuZCA9IChhcmcpID0+IGludGVyc2VjdGlvbihpbnN0LCBhcmcpO1xuICAgIGluc3QudHJhbnNmb3JtID0gKHR4KSA9PiBwaXBlKGluc3QsIHRyYW5zZm9ybSh0eCkpO1xuICAgIGluc3QuZGVmYXVsdCA9IChkZWYpID0+IF9kZWZhdWx0KGluc3QsIGRlZik7XG4gICAgaW5zdC5wcmVmYXVsdCA9IChkZWYpID0+IHByZWZhdWx0KGluc3QsIGRlZik7XG4gICAgLy8gaW5zdC5jb2FsZXNjZSA9IChkZWYsIHBhcmFtcykgPT4gY29hbGVzY2UoaW5zdCwgZGVmLCBwYXJhbXMpO1xuICAgIGluc3QuY2F0Y2ggPSAocGFyYW1zKSA9PiBfY2F0Y2goaW5zdCwgcGFyYW1zKTtcbiAgICBpbnN0LnBpcGUgPSAodGFyZ2V0KSA9PiBwaXBlKGluc3QsIHRhcmdldCk7XG4gICAgaW5zdC5yZWFkb25seSA9ICgpID0+IHJlYWRvbmx5KGluc3QpO1xuICAgIC8vIG1ldGFcbiAgICBpbnN0LmRlc2NyaWJlID0gKGRlc2NyaXB0aW9uKSA9PiB7XG4gICAgICAgIGNvbnN0IGNsID0gaW5zdC5jbG9uZSgpO1xuICAgICAgICBjb3JlLmdsb2JhbFJlZ2lzdHJ5LmFkZChjbCwgeyBkZXNjcmlwdGlvbiB9KTtcbiAgICAgICAgcmV0dXJuIGNsO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiZGVzY3JpcHRpb25cIiwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5nbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCk/LmRlc2NyaXB0aW9uO1xuICAgICAgICB9LFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgfSk7XG4gICAgaW5zdC5tZXRhID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29yZS5nbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2wgPSBpbnN0LmNsb25lKCk7XG4gICAgICAgIGNvcmUuZ2xvYmFsUmVnaXN0cnkuYWRkKGNsLCBhcmdzWzBdKTtcbiAgICAgICAgcmV0dXJuIGNsO1xuICAgIH07XG4gICAgLy8gaGVscGVyc1xuICAgIGluc3QuaXNPcHRpb25hbCA9ICgpID0+IGluc3Quc2FmZVBhcnNlKHVuZGVmaW5lZCkuc3VjY2VzcztcbiAgICBpbnN0LmlzTnVsbGFibGUgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuICAgIGluc3QuYXBwbHkgPSAoZm4pID0+IGZuKGluc3QpO1xuICAgIHJldHVybiBpbnN0O1xufSk7XG4vKiogQGludGVybmFsICovXG5leHBvcnQgY29uc3QgX1pvZFN0cmluZyA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJfWm9kU3RyaW5nXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTdHJpbmcuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5zdHJpbmdQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgaW5zdC5mb3JtYXQgPSBiYWcuZm9ybWF0ID8/IG51bGw7XG4gICAgaW5zdC5taW5MZW5ndGggPSBiYWcubWluaW11bSA/PyBudWxsO1xuICAgIGluc3QubWF4TGVuZ3RoID0gYmFnLm1heGltdW0gPz8gbnVsbDtcbiAgICAvLyB2YWxpZGF0aW9uc1xuICAgIGluc3QucmVnZXggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MucmVnZXgoLi4uYXJncykpO1xuICAgIGluc3QuaW5jbHVkZXMgPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MuaW5jbHVkZXMoLi4uYXJncykpO1xuICAgIGluc3Quc3RhcnRzV2l0aCA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5zdGFydHNXaXRoKC4uLmFyZ3MpKTtcbiAgICBpbnN0LmVuZHNXaXRoID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLmVuZHNXaXRoKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lm1pbiA9ICguLi5hcmdzKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5taW5MZW5ndGgoLi4uYXJncykpO1xuICAgIGluc3QubWF4ID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLm1heExlbmd0aCguLi5hcmdzKSk7XG4gICAgaW5zdC5sZW5ndGggPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3MubGVuZ3RoKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lm5vbmVtcHR5ID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY2hlY2tzLm1pbkxlbmd0aCgxLCAuLi5hcmdzKSk7XG4gICAgaW5zdC5sb3dlcmNhc2UgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sb3dlcmNhc2UocGFyYW1zKSk7XG4gICAgaW5zdC51cHBlcmNhc2UgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy51cHBlcmNhc2UocGFyYW1zKSk7XG4gICAgLy8gdHJhbnNmb3Jtc1xuICAgIGluc3QudHJpbSA9ICgpID0+IGluc3QuY2hlY2soY2hlY2tzLnRyaW0oKSk7XG4gICAgaW5zdC5ub3JtYWxpemUgPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjaGVja3Mubm9ybWFsaXplKC4uLmFyZ3MpKTtcbiAgICBpbnN0LnRvTG93ZXJDYXNlID0gKCkgPT4gaW5zdC5jaGVjayhjaGVja3MudG9Mb3dlckNhc2UoKSk7XG4gICAgaW5zdC50b1VwcGVyQ2FzZSA9ICgpID0+IGluc3QuY2hlY2soY2hlY2tzLnRvVXBwZXJDYXNlKCkpO1xuICAgIGluc3Quc2x1Z2lmeSA9ICgpID0+IGluc3QuY2hlY2soY2hlY2tzLnNsdWdpZnkoKSk7XG59KTtcbmV4cG9ydCBjb25zdCBab2RTdHJpbmcgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kU3RyaW5nXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RTdHJpbmcuaW5pdChpbnN0LCBkZWYpO1xuICAgIF9ab2RTdHJpbmcuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuZW1haWwgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2VtYWlsKFpvZEVtYWlsLCBwYXJhbXMpKTtcbiAgICBpbnN0LnVybCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXJsKFpvZFVSTCwgcGFyYW1zKSk7XG4gICAgaW5zdC5qd3QgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2p3dChab2RKV1QsIHBhcmFtcykpO1xuICAgIGluc3QuZW1vamkgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2Vtb2ppKFpvZEVtb2ppLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmd1aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2d1aWQoWm9kR1VJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC51dWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91dWlkKFpvZFVVSUQsIHBhcmFtcykpO1xuICAgIGluc3QudXVpZHY0ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl91dWlkdjQoWm9kVVVJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC51dWlkdjYgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3V1aWR2Nihab2RVVUlELCBwYXJhbXMpKTtcbiAgICBpbnN0LnV1aWR2NyA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fdXVpZHY3KFpvZFVVSUQsIHBhcmFtcykpO1xuICAgIGluc3QubmFub2lkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9uYW5vaWQoWm9kTmFub0lELCBwYXJhbXMpKTtcbiAgICBpbnN0Lmd1aWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2d1aWQoWm9kR1VJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5jdWlkID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9jdWlkKFpvZENVSUQsIHBhcmFtcykpO1xuICAgIGluc3QuY3VpZDIgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2N1aWQyKFpvZENVSUQyLCBwYXJhbXMpKTtcbiAgICBpbnN0LnVsaWQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX3VsaWQoWm9kVUxJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5iYXNlNjQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2Jhc2U2NChab2RCYXNlNjQsIHBhcmFtcykpO1xuICAgIGluc3QuYmFzZTY0dXJsID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9iYXNlNjR1cmwoWm9kQmFzZTY0VVJMLCBwYXJhbXMpKTtcbiAgICBpbnN0LnhpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5feGlkKFpvZFhJRCwgcGFyYW1zKSk7XG4gICAgaW5zdC5rc3VpZCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5fa3N1aWQoWm9kS1NVSUQsIHBhcmFtcykpO1xuICAgIGluc3QuaXB2NCA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY29yZS5faXB2NChab2RJUHY0LCBwYXJhbXMpKTtcbiAgICBpbnN0LmlwdjYgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2lwdjYoWm9kSVB2NiwgcGFyYW1zKSk7XG4gICAgaW5zdC5jaWRydjQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2NpZHJ2NChab2RDSURSdjQsIHBhcmFtcykpO1xuICAgIGluc3QuY2lkcnY2ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9jaWRydjYoWm9kQ0lEUnY2LCBwYXJhbXMpKTtcbiAgICBpbnN0LmUxNjQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX2UxNjQoWm9kRTE2NCwgcGFyYW1zKSk7XG4gICAgLy8gaXNvXG4gICAgaW5zdC5kYXRldGltZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaXNvLmRhdGV0aW1lKHBhcmFtcykpO1xuICAgIGluc3QuZGF0ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soaXNvLmRhdGUocGFyYW1zKSk7XG4gICAgaW5zdC50aW1lID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpc28udGltZShwYXJhbXMpKTtcbiAgICBpbnN0LmR1cmF0aW9uID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhpc28uZHVyYXRpb24ocGFyYW1zKSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmcocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZyhab2RTdHJpbmcsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kU3RyaW5nRm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFN0cmluZ0Zvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBfWm9kU3RyaW5nLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGNvbnN0IFpvZEVtYWlsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEVtYWlsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZEVtYWlsLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZW1haWwocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2VtYWlsKFpvZEVtYWlsLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEdVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kR1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RHVUlELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZ3VpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZ3VpZChab2RHVUlELCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFVVSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVVVJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RVVUlELmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdXVpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXVpZChab2RVVUlELCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHV1aWR2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXVpZHY0KFpvZFVVSUQsIHBhcmFtcyk7XG59XG4vLyBab2RVVUlEdjZcbmV4cG9ydCBmdW5jdGlvbiB1dWlkdjYocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3V1aWR2Nihab2RVVUlELCBwYXJhbXMpO1xufVxuLy8gWm9kVVVJRHY3XG5leHBvcnQgZnVuY3Rpb24gdXVpZHY3KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91dWlkdjcoWm9kVVVJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RVUkwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVVJMXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZFVSTC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHVybChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdXJsKFpvZFVSTCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBodHRwVXJsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91cmwoWm9kVVJMLCB7XG4gICAgICAgIHByb3RvY29sOiAvXmh0dHBzPyQvLFxuICAgICAgICBob3N0bmFtZTogY29yZS5yZWdleGVzLmRvbWFpbixcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RFbW9qaSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RFbW9qaVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RFbW9qaS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGVtb2ppKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9lbW9qaShab2RFbW9qaSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2ROYW5vSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTmFub0lEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZE5hbm9JRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG5hbm9pZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbmFub2lkKFpvZE5hbm9JRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RDVUlEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENVSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQ1VJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGN1aWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2N1aWQoWm9kQ1VJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RDVUlEMiA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDVUlEMlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RDVUlEMi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGN1aWQyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jdWlkMihab2RDVUlEMiwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RVTElEID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVMSURcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kVUxJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHVsaWQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VsaWQoWm9kVUxJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RYSUQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kWElEXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZFhJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHhpZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5feGlkKFpvZFhJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RLU1VJRCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RLU1VJRFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RLU1VJRC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGtzdWlkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9rc3VpZChab2RLU1VJRCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJUHY0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElQdjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kSVB2NC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlwdjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lwdjQoWm9kSVB2NCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RNQUMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTUFDXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICAvLyBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZE1BQy5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG1hYyhwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbWFjKFpvZE1BQywgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RJUHY2ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElQdjZcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kSVB2Ni5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGlwdjYocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lwdjYoWm9kSVB2NiwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RDSURSdjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ0lEUnY0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RDSURSdjQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBjaWRydjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2NpZHJ2NChab2RDSURSdjQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQ0lEUnY2ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZENJRFJ2NlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQ0lEUnY2LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gY2lkcnY2KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9jaWRydjYoWm9kQ0lEUnY2LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEJhc2U2NCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCYXNlNjRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQmFzZTY0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9iYXNlNjQoWm9kQmFzZTY0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEJhc2U2NFVSTCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RCYXNlNjRVUkxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQmFzZTY0VVJMLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYmFzZTY0dXJsKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9iYXNlNjR1cmwoWm9kQmFzZTY0VVJMLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEUxNjQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRTE2NFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgLy8gWm9kU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBjb3JlLiRab2RFMTY0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZTE2NChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZTE2NChab2RFMTY0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEpXVCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RKV1RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kSldULmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gand0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9qd3QoWm9kSldULCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RDdXN0b21TdHJpbmdGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIC8vIFpvZFN0cmluZ0Zvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kQ3VzdG9tU3RyaW5nRm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nRm9ybWF0KGZvcm1hdCwgZm5PclJlZ2V4LCBfcGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gY29yZS5fc3RyaW5nRm9ybWF0KFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCwgZm9ybWF0LCBmbk9yUmVnZXgsIF9wYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhvc3RuYW1lKF9wYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fc3RyaW5nRm9ybWF0KFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCwgXCJob3N0bmFtZVwiLCBjb3JlLnJlZ2V4ZXMuaG9zdG5hbWUsIF9wYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleChfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3N0cmluZ0Zvcm1hdChab2RDdXN0b21TdHJpbmdGb3JtYXQsIFwiaGV4XCIsIGNvcmUucmVnZXhlcy5oZXgsIF9wYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2goYWxnLCBwYXJhbXMpIHtcbiAgICBjb25zdCBlbmMgPSBwYXJhbXM/LmVuYyA/PyBcImhleFwiO1xuICAgIGNvbnN0IGZvcm1hdCA9IGAke2FsZ31fJHtlbmN9YDtcbiAgICBjb25zdCByZWdleCA9IGNvcmUucmVnZXhlc1tmb3JtYXRdO1xuICAgIGlmICghcmVnZXgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGhhc2ggZm9ybWF0OiAke2Zvcm1hdH1gKTtcbiAgICByZXR1cm4gY29yZS5fc3RyaW5nRm9ybWF0KFpvZEN1c3RvbVN0cmluZ0Zvcm1hdCwgZm9ybWF0LCByZWdleCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2ROdW1iZXIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTnVtYmVyXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROdW1iZXIuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5udW1iZXJQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuZ3QgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3QodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QuZ3RlID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5taW4gPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmx0ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0KHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmx0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5pbnQgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGludChwYXJhbXMpKTtcbiAgICBpbnN0LnNhZmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGludChwYXJhbXMpKTtcbiAgICBpbnN0LnBvc2l0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3QoMCwgcGFyYW1zKSk7XG4gICAgaW5zdC5ub25uZWdhdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSgwLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5lZ2F0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHQoMCwgcGFyYW1zKSk7XG4gICAgaW5zdC5ub25wb3NpdGl2ZSA9IChwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmx0ZSgwLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm11bHRpcGxlT2YgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubXVsdGlwbGVPZih2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5zdGVwID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm11bHRpcGxlT2YodmFsdWUsIHBhcmFtcykpO1xuICAgIC8vIGluc3QuZmluaXRlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLmZpbml0ZShwYXJhbXMpKTtcbiAgICBpbnN0LmZpbml0ZSA9ICgpID0+IGluc3Q7XG4gICAgY29uc3QgYmFnID0gaW5zdC5fem9kLmJhZztcbiAgICBpbnN0Lm1pblZhbHVlID1cbiAgICAgICAgTWF0aC5tYXgoYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLCBiYWcuZXhjbHVzaXZlTWluaW11bSA/PyBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpID8/IG51bGw7XG4gICAgaW5zdC5tYXhWYWx1ZSA9XG4gICAgICAgIE1hdGgubWluKGJhZy5tYXhpbXVtID8/IE51bWJlci5QT1NJVElWRV9JTkZJTklUWSwgYmFnLmV4Y2x1c2l2ZU1heGltdW0gPz8gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSA/PyBudWxsO1xuICAgIGluc3QuaXNJbnQgPSAoYmFnLmZvcm1hdCA/PyBcIlwiKS5pbmNsdWRlcyhcImludFwiKSB8fCBOdW1iZXIuaXNTYWZlSW50ZWdlcihiYWcubXVsdGlwbGVPZiA/PyAwLjUpO1xuICAgIGluc3QuaXNGaW5pdGUgPSB0cnVlO1xuICAgIGluc3QuZm9ybWF0ID0gYmFnLmZvcm1hdCA/PyBudWxsO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9udW1iZXIoWm9kTnVtYmVyLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZE51bWJlckZvcm1hdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2ROdW1iZXJGb3JtYXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE51bWJlckZvcm1hdC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kTnVtYmVyLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGludChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faW50KFpvZE51bWJlckZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmbG9hdDMyKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9mbG9hdDMyKFpvZE51bWJlckZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmbG9hdDY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9mbG9hdDY0KFpvZE51bWJlckZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnQzMihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faW50MzIoWm9kTnVtYmVyRm9ybWF0LCBwYXJhbXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVpbnQzMihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdWludDMyKFpvZE51bWJlckZvcm1hdCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCb29sZWFuID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEJvb2xlYW5cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEJvb2xlYW4uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5ib29sZWFuUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGJvb2xlYW4ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2Jvb2xlYW4oWm9kQm9vbGVhbiwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RCaWdJbnQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQmlnSW50XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RCaWdJbnQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5iaWdpbnRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuZ3RlID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5taW4gPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmd0ID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0KHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lmd0ZSA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QubWluID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5sdCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdCh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5sdGUgPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm1heCA9ICh2YWx1ZSwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUodmFsdWUsIHBhcmFtcykpO1xuICAgIGluc3QucG9zaXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5ndChCaWdJbnQoMCksIHBhcmFtcykpO1xuICAgIGluc3QubmVnYXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdChCaWdJbnQoMCksIHBhcmFtcykpO1xuICAgIGluc3Qubm9ucG9zaXRpdmUgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sdGUoQmlnSW50KDApLCBwYXJhbXMpKTtcbiAgICBpbnN0Lm5vbm5lZ2F0aXZlID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MuZ3RlKEJpZ0ludCgwKSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tdWx0aXBsZU9mID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm11bHRpcGxlT2YodmFsdWUsIHBhcmFtcykpO1xuICAgIGNvbnN0IGJhZyA9IGluc3QuX3pvZC5iYWc7XG4gICAgaW5zdC5taW5WYWx1ZSA9IGJhZy5taW5pbXVtID8/IG51bGw7XG4gICAgaW5zdC5tYXhWYWx1ZSA9IGJhZy5tYXhpbXVtID8/IG51bGw7XG4gICAgaW5zdC5mb3JtYXQgPSBiYWcuZm9ybWF0ID8/IG51bGw7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBiaWdpbnQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2JpZ2ludChab2RCaWdJbnQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kQmlnSW50Rm9ybWF0ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEJpZ0ludEZvcm1hdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQmlnSW50Rm9ybWF0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RCaWdJbnQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG4vLyBpbnQ2NFxuZXhwb3J0IGZ1bmN0aW9uIGludDY0KHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9pbnQ2NChab2RCaWdJbnRGb3JtYXQsIHBhcmFtcyk7XG59XG4vLyB1aW50NjRcbmV4cG9ydCBmdW5jdGlvbiB1aW50NjQocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX3VpbnQ2NChab2RCaWdJbnRGb3JtYXQsIHBhcmFtcyk7XG59XG5leHBvcnQgY29uc3QgWm9kU3ltYm9sID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFN5bWJvbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kU3ltYm9sLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuc3ltYm9sUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHN5bWJvbChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fc3ltYm9sKFpvZFN5bWJvbCwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RVbmRlZmluZWQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVW5kZWZpbmVkXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RVbmRlZmluZWQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy51bmRlZmluZWRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5mdW5jdGlvbiBfdW5kZWZpbmVkKHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl91bmRlZmluZWQoWm9kVW5kZWZpbmVkLCBwYXJhbXMpO1xufVxuZXhwb3J0IHsgX3VuZGVmaW5lZCBhcyB1bmRlZmluZWQgfTtcbmV4cG9ydCBjb25zdCBab2ROdWxsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE51bGxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE51bGwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5udWxsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZnVuY3Rpb24gX251bGwocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX251bGwoWm9kTnVsbCwgcGFyYW1zKTtcbn1cbmV4cG9ydCB7IF9udWxsIGFzIG51bGwgfTtcbmV4cG9ydCBjb25zdCBab2RBbnkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQW55XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RBbnkuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5hbnlQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gYW55KCkge1xuICAgIHJldHVybiBjb3JlLl9hbnkoWm9kQW55KTtcbn1cbmV4cG9ydCBjb25zdCBab2RVbmtub3duID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVua25vd25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFVua25vd24uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy51bmtub3duUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHVua25vd24oKSB7XG4gICAgcmV0dXJuIGNvcmUuX3Vua25vd24oWm9kVW5rbm93bik7XG59XG5leHBvcnQgY29uc3QgWm9kTmV2ZXIgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kTmV2ZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE5ldmVyLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubmV2ZXJQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbmV2ZXIocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX25ldmVyKFpvZE5ldmVyLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFZvaWQgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVm9pZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kVm9pZC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnZvaWRQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5mdW5jdGlvbiBfdm9pZChwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fdm9pZChab2RWb2lkLCBwYXJhbXMpO1xufVxuZXhwb3J0IHsgX3ZvaWQgYXMgdm9pZCB9O1xuZXhwb3J0IGNvbnN0IFpvZERhdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRGF0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRGF0ZS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmRhdGVQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QubWluID0gKHZhbHVlLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLmd0ZSh2YWx1ZSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAodmFsdWUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjaGVja3MubHRlKHZhbHVlLCBwYXJhbXMpKTtcbiAgICBjb25zdCBjID0gaW5zdC5fem9kLmJhZztcbiAgICBpbnN0Lm1pbkRhdGUgPSBjLm1pbmltdW0gPyBuZXcgRGF0ZShjLm1pbmltdW0pIDogbnVsbDtcbiAgICBpbnN0Lm1heERhdGUgPSBjLm1heGltdW0gPyBuZXcgRGF0ZShjLm1heGltdW0pIDogbnVsbDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGRhdGUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2RhdGUoWm9kRGF0ZSwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RBcnJheSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RBcnJheVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kQXJyYXkuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5hcnJheVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5lbGVtZW50ID0gZGVmLmVsZW1lbnQ7XG4gICAgaW5zdC5taW4gPSAobWluTGVuZ3RoLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm1pbkxlbmd0aChtaW5MZW5ndGgsIHBhcmFtcykpO1xuICAgIGluc3Qubm9uZW1wdHkgPSAocGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5taW5MZW5ndGgoMSwgcGFyYW1zKSk7XG4gICAgaW5zdC5tYXggPSAobWF4TGVuZ3RoLCBwYXJhbXMpID0+IGluc3QuY2hlY2soY2hlY2tzLm1heExlbmd0aChtYXhMZW5ndGgsIHBhcmFtcykpO1xuICAgIGluc3QubGVuZ3RoID0gKGxlbiwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNoZWNrcy5sZW5ndGgobGVuLCBwYXJhbXMpKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuZWxlbWVudDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGFycmF5KGVsZW1lbnQsIHBhcmFtcykge1xuICAgIHJldHVybiBjb3JlLl9hcnJheShab2RBcnJheSwgZWxlbWVudCwgcGFyYW1zKTtcbn1cbi8vIC5rZXlvZlxuZXhwb3J0IGZ1bmN0aW9uIGtleW9mKHNjaGVtYSkge1xuICAgIGNvbnN0IHNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuICAgIHJldHVybiBfZW51bShPYmplY3Qua2V5cyhzaGFwZSkpO1xufVxuZXhwb3J0IGNvbnN0IFpvZE9iamVjdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RPYmplY3RcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZE9iamVjdEpJVC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm9iamVjdFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgdXRpbC5kZWZpbmVMYXp5KGluc3QsIFwic2hhcGVcIiwgKCkgPT4ge1xuICAgICAgICByZXR1cm4gZGVmLnNoYXBlO1xuICAgIH0pO1xuICAgIGluc3Qua2V5b2YgPSAoKSA9PiBfZW51bShPYmplY3Qua2V5cyhpbnN0Ll96b2QuZGVmLnNoYXBlKSk7XG4gICAgaW5zdC5jYXRjaGFsbCA9IChjYXRjaGFsbCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiBjYXRjaGFsbCB9KTtcbiAgICBpbnN0LnBhc3N0aHJvdWdoID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiB1bmtub3duKCkgfSk7XG4gICAgaW5zdC5sb29zZSA9ICgpID0+IGluc3QuY2xvbmUoeyAuLi5pbnN0Ll96b2QuZGVmLCBjYXRjaGFsbDogdW5rbm93bigpIH0pO1xuICAgIGluc3Quc3RyaWN0ID0gKCkgPT4gaW5zdC5jbG9uZSh7IC4uLmluc3QuX3pvZC5kZWYsIGNhdGNoYWxsOiBuZXZlcigpIH0pO1xuICAgIGluc3Quc3RyaXAgPSAoKSA9PiBpbnN0LmNsb25lKHsgLi4uaW5zdC5fem9kLmRlZiwgY2F0Y2hhbGw6IHVuZGVmaW5lZCB9KTtcbiAgICBpbnN0LmV4dGVuZCA9IChpbmNvbWluZykgPT4ge1xuICAgICAgICByZXR1cm4gdXRpbC5leHRlbmQoaW5zdCwgaW5jb21pbmcpO1xuICAgIH07XG4gICAgaW5zdC5zYWZlRXh0ZW5kID0gKGluY29taW5nKSA9PiB7XG4gICAgICAgIHJldHVybiB1dGlsLnNhZmVFeHRlbmQoaW5zdCwgaW5jb21pbmcpO1xuICAgIH07XG4gICAgaW5zdC5tZXJnZSA9IChvdGhlcikgPT4gdXRpbC5tZXJnZShpbnN0LCBvdGhlcik7XG4gICAgaW5zdC5waWNrID0gKG1hc2spID0+IHV0aWwucGljayhpbnN0LCBtYXNrKTtcbiAgICBpbnN0Lm9taXQgPSAobWFzaykgPT4gdXRpbC5vbWl0KGluc3QsIG1hc2spO1xuICAgIGluc3QucGFydGlhbCA9ICguLi5hcmdzKSA9PiB1dGlsLnBhcnRpYWwoWm9kT3B0aW9uYWwsIGluc3QsIGFyZ3NbMF0pO1xuICAgIGluc3QucmVxdWlyZWQgPSAoLi4uYXJncykgPT4gdXRpbC5yZXF1aXJlZChab2ROb25PcHRpb25hbCwgaW5zdCwgYXJnc1swXSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBvYmplY3Qoc2hhcGUsIHBhcmFtcykge1xuICAgIGNvbnN0IGRlZiA9IHtcbiAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgc2hhcGU6IHNoYXBlID8/IHt9LFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3QoZGVmKTtcbn1cbi8vIHN0cmljdE9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIHN0cmljdE9iamVjdChzaGFwZSwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIG5ldyBab2RPYmplY3Qoe1xuICAgICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgICBzaGFwZSxcbiAgICAgICAgY2F0Y2hhbGw6IG5ldmVyKCksXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG4vLyBsb29zZU9iamVjdFxuZXhwb3J0IGZ1bmN0aW9uIGxvb3NlT2JqZWN0KHNoYXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZE9iamVjdCh7XG4gICAgICAgIHR5cGU6IFwib2JqZWN0XCIsXG4gICAgICAgIHNoYXBlLFxuICAgICAgICBjYXRjaGFsbDogdW5rbm93bigpLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFVuaW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnVuaW9uUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm9wdGlvbnMgPSBkZWYub3B0aW9ucztcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uKG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kVW5pb24oe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnM6IG9wdGlvbnMsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kWG9yID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFhvclwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgWm9kVW5pb24uaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZFhvci5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnVuaW9uUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0Lm9wdGlvbnMgPSBkZWYub3B0aW9ucztcbn0pO1xuLyoqIENyZWF0ZXMgYW4gZXhjbHVzaXZlIHVuaW9uIChYT1IpIHdoZXJlIGV4YWN0bHkgb25lIG9wdGlvbiBtdXN0IG1hdGNoLlxuICogVW5saWtlIHJlZ3VsYXIgdW5pb25zIHRoYXQgc3VjY2VlZCB3aGVuIGFueSBvcHRpb24gbWF0Y2hlcywgeG9yIGZhaWxzIGlmXG4gKiB6ZXJvIG9yIG1vcmUgdGhhbiBvbmUgb3B0aW9uIG1hdGNoZXMgdGhlIGlucHV0LiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHhvcihvcHRpb25zLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFhvcih7XG4gICAgICAgIHR5cGU6IFwidW5pb25cIixcbiAgICAgICAgb3B0aW9uczogb3B0aW9ucyxcbiAgICAgICAgaW5jbHVzaXZlOiBmYWxzZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2REaXNjcmltaW5hdGVkVW5pb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRGlzY3JpbWluYXRlZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBab2RVbmlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgY29yZS4kWm9kRGlzY3JpbWluYXRlZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGRpc2NyaW1pbmF0ZWRVbmlvbihkaXNjcmltaW5hdG9yLCBvcHRpb25zLCBwYXJhbXMpIHtcbiAgICAvLyBjb25zdCBbb3B0aW9ucywgcGFyYW1zXSA9IGFyZ3M7XG4gICAgcmV0dXJuIG5ldyBab2REaXNjcmltaW5hdGVkVW5pb24oe1xuICAgICAgICB0eXBlOiBcInVuaW9uXCIsXG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIGRpc2NyaW1pbmF0b3IsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kSW50ZXJzZWN0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZEludGVyc2VjdGlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSW50ZXJzZWN0aW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuaW50ZXJzZWN0aW9uUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdGlvbihsZWZ0LCByaWdodCkge1xuICAgIHJldHVybiBuZXcgWm9kSW50ZXJzZWN0aW9uKHtcbiAgICAgICAgdHlwZTogXCJpbnRlcnNlY3Rpb25cIixcbiAgICAgICAgbGVmdDogbGVmdCxcbiAgICAgICAgcmlnaHQ6IHJpZ2h0LFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFR1cGxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFR1cGxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RUdXBsZS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnR1cGxlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnJlc3QgPSAocmVzdCkgPT4gaW5zdC5jbG9uZSh7XG4gICAgICAgIC4uLmluc3QuX3pvZC5kZWYsXG4gICAgICAgIHJlc3Q6IHJlc3QsXG4gICAgfSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiB0dXBsZShpdGVtcywgX3BhcmFtc09yUmVzdCwgX3BhcmFtcykge1xuICAgIGNvbnN0IGhhc1Jlc3QgPSBfcGFyYW1zT3JSZXN0IGluc3RhbmNlb2YgY29yZS4kWm9kVHlwZTtcbiAgICBjb25zdCBwYXJhbXMgPSBoYXNSZXN0ID8gX3BhcmFtcyA6IF9wYXJhbXNPclJlc3Q7XG4gICAgY29uc3QgcmVzdCA9IGhhc1Jlc3QgPyBfcGFyYW1zT3JSZXN0IDogbnVsbDtcbiAgICByZXR1cm4gbmV3IFpvZFR1cGxlKHtcbiAgICAgICAgdHlwZTogXCJ0dXBsZVwiLFxuICAgICAgICBpdGVtczogaXRlbXMsXG4gICAgICAgIHJlc3QsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kUmVjb3JkID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFJlY29yZFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kUmVjb3JkLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucmVjb3JkUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LmtleVR5cGUgPSBkZWYua2V5VHlwZTtcbiAgICBpbnN0LnZhbHVlVHlwZSA9IGRlZi52YWx1ZVR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiByZWNvcmQoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuLy8gdHlwZSBhbGtzamYgPSBjb3JlLm91dHB1dDxjb3JlLiRab2RSZWNvcmRLZXk+O1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWxSZWNvcmQoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBrID0gY29yZS5jbG9uZShrZXlUeXBlKTtcbiAgICBrLl96b2QudmFsdWVzID0gdW5kZWZpbmVkO1xuICAgIHJldHVybiBuZXcgWm9kUmVjb3JkKHtcbiAgICAgICAgdHlwZTogXCJyZWNvcmRcIixcbiAgICAgICAga2V5VHlwZTogayxcbiAgICAgICAgdmFsdWVUeXBlOiB2YWx1ZVR5cGUsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gbG9vc2VSZWNvcmQoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFJlY29yZCh7XG4gICAgICAgIHR5cGU6IFwicmVjb3JkXCIsXG4gICAgICAgIGtleVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICBtb2RlOiBcImxvb3NlXCIsXG4gICAgICAgIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kTWFwID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE1hcFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTWFwLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubWFwUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LmtleVR5cGUgPSBkZWYua2V5VHlwZTtcbiAgICBpbnN0LnZhbHVlVHlwZSA9IGRlZi52YWx1ZVR5cGU7XG4gICAgaW5zdC5taW4gPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW5TaXplKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lm5vbmVtcHR5ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW5TaXplKDEsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fbWF4U2l6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC5zaXplID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fc2l6ZSguLi5hcmdzKSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBtYXAoa2V5VHlwZSwgdmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZE1hcCh7XG4gICAgICAgIHR5cGU6IFwibWFwXCIsXG4gICAgICAgIGtleVR5cGU6IGtleVR5cGUsXG4gICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZFNldCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RTZXRcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFNldC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnNldFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5taW4gPSAoLi4uYXJncykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW5TaXplKC4uLmFyZ3MpKTtcbiAgICBpbnN0Lm5vbmVtcHR5ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW5TaXplKDEsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fbWF4U2l6ZSguLi5hcmdzKSk7XG4gICAgaW5zdC5zaXplID0gKC4uLmFyZ3MpID0+IGluc3QuY2hlY2soY29yZS5fc2l6ZSguLi5hcmdzKSk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBzZXQodmFsdWVUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFNldCh7XG4gICAgICAgIHR5cGU6IFwic2V0XCIsXG4gICAgICAgIHZhbHVlVHlwZTogdmFsdWVUeXBlLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEVudW0gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRW51bVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRW51bS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmVudW1Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QuZW51bSA9IGRlZi5lbnRyaWVzO1xuICAgIGluc3Qub3B0aW9ucyA9IE9iamVjdC52YWx1ZXMoZGVmLmVudHJpZXMpO1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKGRlZi5lbnRyaWVzKSk7XG4gICAgaW5zdC5leHRyYWN0ID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmIChrZXlzLmhhcyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBuZXdFbnRyaWVzW3ZhbHVlXSA9IGRlZi5lbnRyaWVzW3ZhbHVlXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEtleSAke3ZhbHVlfSBub3QgZm91bmQgaW4gZW51bWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgICAgICAuLi5kZWYsXG4gICAgICAgICAgICBjaGVja3M6IFtdLFxuICAgICAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICAgICAgICAgIGVudHJpZXM6IG5ld0VudHJpZXMsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaW5zdC5leGNsdWRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld0VudHJpZXMgPSB7IC4uLmRlZi5lbnRyaWVzIH07XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoa2V5cy5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIG5ld0VudHJpZXNbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgS2V5ICR7dmFsdWV9IG5vdCBmb3VuZCBpbiBlbnVtYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBab2RFbnVtKHtcbiAgICAgICAgICAgIC4uLmRlZixcbiAgICAgICAgICAgIGNoZWNrczogW10sXG4gICAgICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgICAgICAgICAgZW50cmllczogbmV3RW50cmllcyxcbiAgICAgICAgfSk7XG4gICAgfTtcbn0pO1xuZnVuY3Rpb24gX2VudW0odmFsdWVzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gQXJyYXkuaXNBcnJheSh2YWx1ZXMpID8gT2JqZWN0LmZyb21FbnRyaWVzKHZhbHVlcy5tYXAoKHYpID0+IFt2LCB2XSkpIDogdmFsdWVzO1xuICAgIHJldHVybiBuZXcgWm9kRW51bSh7XG4gICAgICAgIHR5cGU6IFwiZW51bVwiLFxuICAgICAgICBlbnRyaWVzLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IHsgX2VudW0gYXMgZW51bSB9O1xuLyoqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIG1lcmdlZCBpbnRvIGB6LmVudW0oKWAuIFVzZSBgei5lbnVtKClgIGluc3RlYWQuXG4gKlxuICogYGBgdHNcbiAqIGVudW0gQ29sb3JzIHsgcmVkLCBncmVlbiwgYmx1ZSB9XG4gKiB6LmVudW0oQ29sb3JzKTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gbmF0aXZlRW51bShlbnRyaWVzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZEVudW0oe1xuICAgICAgICB0eXBlOiBcImVudW1cIixcbiAgICAgICAgZW50cmllcyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RMaXRlcmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZExpdGVyYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZExpdGVyYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5saXRlcmFsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnZhbHVlcyA9IG5ldyBTZXQoZGVmLnZhbHVlcyk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwidmFsdWVcIiwge1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICBpZiAoZGVmLnZhbHVlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBzY2hlbWEgY29udGFpbnMgbXVsdGlwbGUgdmFsaWQgbGl0ZXJhbCB2YWx1ZXMuIFVzZSBgLnZhbHVlc2AgaW5zdGVhZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVmLnZhbHVlc1swXTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGxpdGVyYWwodmFsdWUsIHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kTGl0ZXJhbCh7XG4gICAgICAgIHR5cGU6IFwibGl0ZXJhbFwiLFxuICAgICAgICB2YWx1ZXM6IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdLFxuICAgICAgICAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEZpbGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRmlsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRmlsZS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLmZpbGVQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QubWluID0gKHNpemUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9taW5TaXplKHNpemUsIHBhcmFtcykpO1xuICAgIGluc3QubWF4ID0gKHNpemUsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhjb3JlLl9tYXhTaXplKHNpemUsIHBhcmFtcykpO1xuICAgIGluc3QubWltZSA9ICh0eXBlcywgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKGNvcmUuX21pbWUoQXJyYXkuaXNBcnJheSh0eXBlcykgPyB0eXBlcyA6IFt0eXBlc10sIHBhcmFtcykpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZmlsZShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fZmlsZShab2RGaWxlLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZFRyYW5zZm9ybSA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RUcmFuc2Zvcm1cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFRyYW5zZm9ybS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLnRyYW5zZm9ybVByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcbiAgICAgICAgaWYgKF9jdHguZGlyZWN0aW9uID09PSBcImJhY2t3YXJkXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBjb3JlLiRab2RFbmNvZGVFcnJvcihpbnN0LmNvbnN0cnVjdG9yLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHBheWxvYWQuYWRkSXNzdWUgPSAoaXNzdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaXNzdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmlzc3Vlcy5wdXNoKHV0aWwuaXNzdWUoaXNzdWUsIHBheWxvYWQudmFsdWUsIGRlZikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZm9yIFpvZCAzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICAgICAgICAgICAgY29uc3QgX2lzc3VlID0gaXNzdWU7XG4gICAgICAgICAgICAgICAgaWYgKF9pc3N1ZS5mYXRhbClcbiAgICAgICAgICAgICAgICAgICAgX2lzc3VlLmNvbnRpbnVlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmNvZGUgPz8gKF9pc3N1ZS5jb2RlID0gXCJjdXN0b21cIik7XG4gICAgICAgICAgICAgICAgX2lzc3VlLmlucHV0ID8/IChfaXNzdWUuaW5wdXQgPSBwYXlsb2FkLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBfaXNzdWUuaW5zdCA/PyAoX2lzc3VlLmluc3QgPSBpbnN0KTtcbiAgICAgICAgICAgICAgICAvLyBfaXNzdWUuY29udGludWUgPz89IHRydWU7XG4gICAgICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMucHVzaCh1dGlsLmlzc3VlKF9pc3N1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBkZWYudHJhbnNmb3JtKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuICAgICAgICBpZiAob3V0cHV0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG91dHB1dC50aGVuKChvdXRwdXQpID0+IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLnZhbHVlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgfTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIHJldHVybiBuZXcgWm9kVHJhbnNmb3JtKHtcbiAgICAgICAgdHlwZTogXCJ0cmFuc2Zvcm1cIixcbiAgICAgICAgdHJhbnNmb3JtOiBmbixcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RPcHRpb25hbCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5vcHRpb25hbFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG9wdGlvbmFsKGlubmVyVHlwZSkge1xuICAgIHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZEV4YWN0T3B0aW9uYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRXhhY3RPcHRpb25hbFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kRXhhY3RPcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm9wdGlvbmFsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZXhhY3RPcHRpb25hbChpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZEV4YWN0T3B0aW9uYWwoe1xuICAgICAgICB0eXBlOiBcIm9wdGlvbmFsXCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE51bGxhYmxlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE51bGxhYmxlXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROdWxsYWJsZS5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm51bGxhYmxlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbnVsbGFibGUoaW5uZXJUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG4gICAgICAgIHR5cGU6IFwibnVsbGFibGVcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG4vLyBudWxsaXNoXG5leHBvcnQgZnVuY3Rpb24gbnVsbGlzaChpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gb3B0aW9uYWwobnVsbGFibGUoaW5uZXJUeXBlKSk7XG59XG5leHBvcnQgY29uc3QgWm9kRGVmYXVsdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2REZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuZGVmYXVsdFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbiAgICBpbnN0LnJlbW92ZURlZmF1bHQgPSBpbnN0LnVud3JhcDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIF9kZWZhdWx0KGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBab2REZWZhdWx0KHtcbiAgICAgICAgdHlwZTogXCJkZWZhdWx0XCIsXG4gICAgICAgIGlubmVyVHlwZTogaW5uZXJUeXBlLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogdXRpbC5zaGFsbG93Q2xvbmUoZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RQcmVmYXVsdCA9IC8qQF9fUFVSRV9fKi8gY29yZS4kY29uc3RydWN0b3IoXCJab2RQcmVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kUHJlZmF1bHQuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5wcmVmYXVsdFByb2Nlc3NvcihpbnN0LCBjdHgsIGpzb24sIHBhcmFtcyk7XG4gICAgaW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHByZWZhdWx0KGlubmVyVHlwZSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RQcmVmYXVsdCh7XG4gICAgICAgIHR5cGU6IFwicHJlZmF1bHRcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgICAgIGdldCBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiB1dGlsLnNoYWxsb3dDbG9uZShkZWZhdWx0VmFsdWUpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuZXhwb3J0IGNvbnN0IFpvZE5vbk9wdGlvbmFsID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE5vbk9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2ROb25PcHRpb25hbC5pbml0KGluc3QsIGRlZik7XG4gICAgWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG4gICAgaW5zdC5fem9kLnByb2Nlc3NKU09OU2NoZW1hID0gKGN0eCwganNvbiwgcGFyYW1zKSA9PiBwcm9jZXNzb3JzLm5vbm9wdGlvbmFsUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gbm9ub3B0aW9uYWwoaW5uZXJUeXBlLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZE5vbk9wdGlvbmFsKHtcbiAgICAgICAgdHlwZTogXCJub25vcHRpb25hbFwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RTdWNjZXNzID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFN1Y2Nlc3NcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFN1Y2Nlc3MuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5zdWNjZXNzUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gc3VjY2Vzcyhpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZFN1Y2Nlc3Moe1xuICAgICAgICB0eXBlOiBcInN1Y2Nlc3NcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kQ2F0Y2ggPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ2F0Y2hcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZENhdGNoLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuY2F0Y2hQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG4gICAgaW5zdC5yZW1vdmVDYXRjaCA9IGluc3QudW53cmFwO1xufSk7XG5mdW5jdGlvbiBfY2F0Y2goaW5uZXJUeXBlLCBjYXRjaFZhbHVlKSB7XG4gICAgcmV0dXJuIG5ldyBab2RDYXRjaCh7XG4gICAgICAgIHR5cGU6IFwiY2F0Y2hcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgICAgIGNhdGNoVmFsdWU6ICh0eXBlb2YgY2F0Y2hWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2F0Y2hWYWx1ZSA6ICgpID0+IGNhdGNoVmFsdWUpLFxuICAgIH0pO1xufVxuZXhwb3J0IHsgX2NhdGNoIGFzIGNhdGNoIH07XG5leHBvcnQgY29uc3QgWm9kTmFOID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZE5hTlwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kTmFOLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMubmFuUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIG5hbihwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5fbmFuKFpvZE5hTiwgcGFyYW1zKTtcbn1cbmV4cG9ydCBjb25zdCBab2RQaXBlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFBpcGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5waXBlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LmluID0gZGVmLmluO1xuICAgIGluc3Qub3V0ID0gZGVmLm91dDtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIHBpcGUoaW5fLCBvdXQpIHtcbiAgICByZXR1cm4gbmV3IFpvZFBpcGUoe1xuICAgICAgICB0eXBlOiBcInBpcGVcIixcbiAgICAgICAgaW46IGluXyxcbiAgICAgICAgb3V0OiBvdXQsXG4gICAgICAgIC8vIC4uLnV0aWwubm9ybWFsaXplUGFyYW1zKHBhcmFtcyksXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kQ29kZWMgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ29kZWNcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIFpvZFBpcGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGNvcmUuJFpvZENvZGVjLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZXhwb3J0IGZ1bmN0aW9uIGNvZGVjKGluXywgb3V0LCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZENvZGVjKHtcbiAgICAgICAgdHlwZTogXCJwaXBlXCIsXG4gICAgICAgIGluOiBpbl8sXG4gICAgICAgIG91dDogb3V0LFxuICAgICAgICB0cmFuc2Zvcm06IHBhcmFtcy5kZWNvZGUsXG4gICAgICAgIHJldmVyc2VUcmFuc2Zvcm06IHBhcmFtcy5lbmNvZGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kUmVhZG9ubHkgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kUmVhZG9ubHlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFJlYWRvbmx5LmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMucmVhZG9ubHlQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xuICAgIGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiByZWFkb25seShpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcbiAgICAgICAgdHlwZTogXCJyZWFkb25seVwiLFxuICAgICAgICBpbm5lclR5cGU6IGlubmVyVHlwZSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RUZW1wbGF0ZUxpdGVyYWwgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kVGVtcGxhdGVMaXRlcmFsXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RUZW1wbGF0ZUxpdGVyYWwuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy50ZW1wbGF0ZUxpdGVyYWxQcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVMaXRlcmFsKHBhcnRzLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFpvZFRlbXBsYXRlTGl0ZXJhbCh7XG4gICAgICAgIHR5cGU6IFwidGVtcGxhdGVfbGl0ZXJhbFwiLFxuICAgICAgICBwYXJ0cyxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RMYXp5ID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZExhenlcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZExhenkuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5sYXp5UHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuZ2V0dGVyKCk7XG59KTtcbmV4cG9ydCBmdW5jdGlvbiBsYXp5KGdldHRlcikge1xuICAgIHJldHVybiBuZXcgWm9kTGF6eSh7XG4gICAgICAgIHR5cGU6IFwibGF6eVwiLFxuICAgICAgICBnZXR0ZXI6IGdldHRlcixcbiAgICB9KTtcbn1cbmV4cG9ydCBjb25zdCBab2RQcm9taXNlID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZFByb21pc2VcIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZFByb21pc2UuaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5wcm9taXNlUHJvY2Vzc29yKGluc3QsIGN0eCwganNvbiwgcGFyYW1zKTtcbiAgICBpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzZShpbm5lclR5cGUpIHtcbiAgICByZXR1cm4gbmV3IFpvZFByb21pc2Uoe1xuICAgICAgICB0eXBlOiBcInByb21pc2VcIixcbiAgICAgICAgaW5uZXJUeXBlOiBpbm5lclR5cGUsXG4gICAgfSk7XG59XG5leHBvcnQgY29uc3QgWm9kRnVuY3Rpb24gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kRnVuY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuICAgIGNvcmUuJFpvZEZ1bmN0aW9uLmluaXQoaW5zdCwgZGVmKTtcbiAgICBab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbiAgICBpbnN0Ll96b2QucHJvY2Vzc0pTT05TY2hlbWEgPSAoY3R4LCBqc29uLCBwYXJhbXMpID0+IHByb2Nlc3NvcnMuZnVuY3Rpb25Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gX2Z1bmN0aW9uKHBhcmFtcykge1xuICAgIHJldHVybiBuZXcgWm9kRnVuY3Rpb24oe1xuICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgIGlucHV0OiBBcnJheS5pc0FycmF5KHBhcmFtcz8uaW5wdXQpID8gdHVwbGUocGFyYW1zPy5pbnB1dCkgOiAocGFyYW1zPy5pbnB1dCA/PyBhcnJheSh1bmtub3duKCkpKSxcbiAgICAgICAgb3V0cHV0OiBwYXJhbXM/Lm91dHB1dCA/PyB1bmtub3duKCksXG4gICAgfSk7XG59XG5leHBvcnQgeyBfZnVuY3Rpb24gYXMgZnVuY3Rpb24gfTtcbmV4cG9ydCBjb25zdCBab2RDdXN0b20gPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kQ3VzdG9tXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RDdXN0b20uaW5pdChpbnN0LCBkZWYpO1xuICAgIFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuICAgIGluc3QuX3pvZC5wcm9jZXNzSlNPTlNjaGVtYSA9IChjdHgsIGpzb24sIHBhcmFtcykgPT4gcHJvY2Vzc29ycy5jdXN0b21Qcm9jZXNzb3IoaW5zdCwgY3R4LCBqc29uLCBwYXJhbXMpO1xufSk7XG4vLyBjdXN0b20gY2hlY2tzXG5leHBvcnQgZnVuY3Rpb24gY2hlY2soZm4pIHtcbiAgICBjb25zdCBjaCA9IG5ldyBjb3JlLiRab2RDaGVjayh7XG4gICAgICAgIGNoZWNrOiBcImN1c3RvbVwiLFxuICAgICAgICAvLyAuLi51dGlsLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuICAgIH0pO1xuICAgIGNoLl96b2QuY2hlY2sgPSBmbjtcbiAgICByZXR1cm4gY2g7XG59XG5leHBvcnQgZnVuY3Rpb24gY3VzdG9tKGZuLCBfcGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2N1c3RvbShab2RDdXN0b20sIGZuID8/ICgoKSA9PiB0cnVlKSwgX3BhcmFtcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcmVmaW5lKGZuLCBfcGFyYW1zID0ge30pIHtcbiAgICByZXR1cm4gY29yZS5fcmVmaW5lKFpvZEN1c3RvbSwgZm4sIF9wYXJhbXMpO1xufVxuLy8gc3VwZXJSZWZpbmVcbmV4cG9ydCBmdW5jdGlvbiBzdXBlclJlZmluZShmbikge1xuICAgIHJldHVybiBjb3JlLl9zdXBlclJlZmluZShmbik7XG59XG4vLyBSZS1leHBvcnQgZGVzY3JpYmUgYW5kIG1ldGEgZnJvbSBjb3JlXG5leHBvcnQgY29uc3QgZGVzY3JpYmUgPSBjb3JlLmRlc2NyaWJlO1xuZXhwb3J0IGNvbnN0IG1ldGEgPSBjb3JlLm1ldGE7XG5mdW5jdGlvbiBfaW5zdGFuY2VvZihjbHMsIHBhcmFtcyA9IHt9KSB7XG4gICAgY29uc3QgaW5zdCA9IG5ldyBab2RDdXN0b20oe1xuICAgICAgICB0eXBlOiBcImN1c3RvbVwiLFxuICAgICAgICBjaGVjazogXCJjdXN0b21cIixcbiAgICAgICAgZm46IChkYXRhKSA9PiBkYXRhIGluc3RhbmNlb2YgY2xzLFxuICAgICAgICBhYm9ydDogdHJ1ZSxcbiAgICAgICAgLi4udXRpbC5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcbiAgICB9KTtcbiAgICBpbnN0Ll96b2QuYmFnLkNsYXNzID0gY2xzO1xuICAgIC8vIE92ZXJyaWRlIGNoZWNrIHRvIGVtaXQgaW52YWxpZF90eXBlIGluc3RlYWQgb2YgY3VzdG9tXG4gICAgaW5zdC5fem9kLmNoZWNrID0gKHBheWxvYWQpID0+IHtcbiAgICAgICAgaWYgKCEocGF5bG9hZC52YWx1ZSBpbnN0YW5jZW9mIGNscykpIHtcbiAgICAgICAgICAgIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGNscy5uYW1lLFxuICAgICAgICAgICAgICAgIGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuICAgICAgICAgICAgICAgIGluc3QsXG4gICAgICAgICAgICAgICAgcGF0aDogWy4uLihpbnN0Ll96b2QuZGVmLnBhdGggPz8gW10pXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gaW5zdDtcbn1cbmV4cG9ydCB7IF9pbnN0YW5jZW9mIGFzIGluc3RhbmNlb2YgfTtcbi8vIHN0cmluZ2Jvb2xcbmV4cG9ydCBjb25zdCBzdHJpbmdib29sID0gKC4uLmFyZ3MpID0+IGNvcmUuX3N0cmluZ2Jvb2woe1xuICAgIENvZGVjOiBab2RDb2RlYyxcbiAgICBCb29sZWFuOiBab2RCb29sZWFuLFxuICAgIFN0cmluZzogWm9kU3RyaW5nLFxufSwgLi4uYXJncyk7XG5leHBvcnQgZnVuY3Rpb24ganNvbihwYXJhbXMpIHtcbiAgICBjb25zdCBqc29uU2NoZW1hID0gbGF6eSgoKSA9PiB7XG4gICAgICAgIHJldHVybiB1bmlvbihbc3RyaW5nKHBhcmFtcyksIG51bWJlcigpLCBib29sZWFuKCksIF9udWxsKCksIGFycmF5KGpzb25TY2hlbWEpLCByZWNvcmQoc3RyaW5nKCksIGpzb25TY2hlbWEpXSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGpzb25TY2hlbWE7XG59XG4vLyBwcmVwcm9jZXNzXG4vLyAvKiogQGRlcHJlY2F0ZWQgVXNlIGB6LnBpcGUoKWAgYW5kIGB6LnRyYW5zZm9ybSgpYCBpbnN0ZWFkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHByZXByb2Nlc3MoZm4sIHNjaGVtYSkge1xuICAgIHJldHVybiBwaXBlKHRyYW5zZm9ybShmbiksIHNjaGVtYSk7XG59XG4iLCAiZXhwb3J0IHsgX2x0IGFzIGx0LCBfbHRlIGFzIGx0ZSwgX2d0IGFzIGd0LCBfZ3RlIGFzIGd0ZSwgX3Bvc2l0aXZlIGFzIHBvc2l0aXZlLCBfbmVnYXRpdmUgYXMgbmVnYXRpdmUsIF9ub25wb3NpdGl2ZSBhcyBub25wb3NpdGl2ZSwgX25vbm5lZ2F0aXZlIGFzIG5vbm5lZ2F0aXZlLCBfbXVsdGlwbGVPZiBhcyBtdWx0aXBsZU9mLCBfbWF4U2l6ZSBhcyBtYXhTaXplLCBfbWluU2l6ZSBhcyBtaW5TaXplLCBfc2l6ZSBhcyBzaXplLCBfbWF4TGVuZ3RoIGFzIG1heExlbmd0aCwgX21pbkxlbmd0aCBhcyBtaW5MZW5ndGgsIF9sZW5ndGggYXMgbGVuZ3RoLCBfcmVnZXggYXMgcmVnZXgsIF9sb3dlcmNhc2UgYXMgbG93ZXJjYXNlLCBfdXBwZXJjYXNlIGFzIHVwcGVyY2FzZSwgX2luY2x1ZGVzIGFzIGluY2x1ZGVzLCBfc3RhcnRzV2l0aCBhcyBzdGFydHNXaXRoLCBfZW5kc1dpdGggYXMgZW5kc1dpdGgsIF9wcm9wZXJ0eSBhcyBwcm9wZXJ0eSwgX21pbWUgYXMgbWltZSwgX292ZXJ3cml0ZSBhcyBvdmVyd3JpdGUsIF9ub3JtYWxpemUgYXMgbm9ybWFsaXplLCBfdHJpbSBhcyB0cmltLCBfdG9Mb3dlckNhc2UgYXMgdG9Mb3dlckNhc2UsIF90b1VwcGVyQ2FzZSBhcyB0b1VwcGVyQ2FzZSwgX3NsdWdpZnkgYXMgc2x1Z2lmeSwgfSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuIiwgImltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCAqIGFzIHNjaGVtYXMgZnJvbSBcIi4vc2NoZW1hcy5qc1wiO1xuZXhwb3J0IGNvbnN0IFpvZElTT0RhdGVUaW1lID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElTT0RhdGVUaW1lXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RJU09EYXRlVGltZS5pbml0KGluc3QsIGRlZik7XG4gICAgc2NoZW1hcy5ab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZXRpbWUocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lzb0RhdGVUaW1lKFpvZElTT0RhdGVUaW1lLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZElTT0RhdGUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSVNPRGF0ZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSVNPRGF0ZS5pbml0KGluc3QsIGRlZik7XG4gICAgc2NoZW1hcy5ab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZGF0ZShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faXNvRGF0ZShab2RJU09EYXRlLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZElTT1RpbWUgPSAvKkBfX1BVUkVfXyovIGNvcmUuJGNvbnN0cnVjdG9yKFwiWm9kSVNPVGltZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG4gICAgY29yZS4kWm9kSVNPVGltZS5pbml0KGluc3QsIGRlZik7XG4gICAgc2NoZW1hcy5ab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gdGltZShwYXJhbXMpIHtcbiAgICByZXR1cm4gY29yZS5faXNvVGltZShab2RJU09UaW1lLCBwYXJhbXMpO1xufVxuZXhwb3J0IGNvbnN0IFpvZElTT0R1cmF0aW9uID0gLypAX19QVVJFX18qLyBjb3JlLiRjb25zdHJ1Y3RvcihcIlpvZElTT0R1cmF0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcbiAgICBjb3JlLiRab2RJU09EdXJhdGlvbi5pbml0KGluc3QsIGRlZik7XG4gICAgc2NoZW1hcy5ab2RTdHJpbmdGb3JtYXQuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5leHBvcnQgZnVuY3Rpb24gZHVyYXRpb24ocGFyYW1zKSB7XG4gICAgcmV0dXJuIGNvcmUuX2lzb0R1cmF0aW9uKFpvZElTT0R1cmF0aW9uLCBwYXJhbXMpO1xufVxuIiwgImltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCB7ICRab2RFcnJvciB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gXCIuLi9jb3JlL3V0aWwuanNcIjtcbmNvbnN0IGluaXRpYWxpemVyID0gKGluc3QsIGlzc3VlcykgPT4ge1xuICAgICRab2RFcnJvci5pbml0KGluc3QsIGlzc3Vlcyk7XG4gICAgaW5zdC5uYW1lID0gXCJab2RFcnJvclwiO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGluc3QsIHtcbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgICB2YWx1ZTogKG1hcHBlcikgPT4gY29yZS5mb3JtYXRFcnJvcihpbnN0LCBtYXBwZXIpLFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGZsYXR0ZW46IHtcbiAgICAgICAgICAgIHZhbHVlOiAobWFwcGVyKSA9PiBjb3JlLmZsYXR0ZW5FcnJvcihpbnN0LCBtYXBwZXIpLFxuICAgICAgICAgICAgLy8gZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIGFkZElzc3VlOiB7XG4gICAgICAgICAgICB2YWx1ZTogKGlzc3VlKSA9PiB7XG4gICAgICAgICAgICAgICAgaW5zdC5pc3N1ZXMucHVzaChpc3N1ZSk7XG4gICAgICAgICAgICAgICAgaW5zdC5tZXNzYWdlID0gSlNPTi5zdHJpbmdpZnkoaW5zdC5pc3N1ZXMsIHV0aWwuanNvblN0cmluZ2lmeVJlcGxhY2VyLCAyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgYWRkSXNzdWVzOiB7XG4gICAgICAgICAgICB2YWx1ZTogKGlzc3VlcykgPT4ge1xuICAgICAgICAgICAgICAgIGluc3QuaXNzdWVzLnB1c2goLi4uaXNzdWVzKTtcbiAgICAgICAgICAgICAgICBpbnN0Lm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShpbnN0Lmlzc3VlcywgdXRpbC5qc29uU3RyaW5naWZ5UmVwbGFjZXIsIDIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICBpc0VtcHR5OiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3QuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICAvLyBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJpc0VtcHR5XCIsIHtcbiAgICAvLyAgIGdldCgpIHtcbiAgICAvLyAgICAgcmV0dXJuIGluc3QuaXNzdWVzLmxlbmd0aCA9PT0gMDtcbiAgICAvLyAgIH0sXG4gICAgLy8gfSk7XG59O1xuZXhwb3J0IGNvbnN0IFpvZEVycm9yID0gY29yZS4kY29uc3RydWN0b3IoXCJab2RFcnJvclwiLCBpbml0aWFsaXplcik7XG5leHBvcnQgY29uc3QgWm9kUmVhbEVycm9yID0gY29yZS4kY29uc3RydWN0b3IoXCJab2RFcnJvclwiLCBpbml0aWFsaXplciwge1xuICAgIFBhcmVudDogRXJyb3IsXG59KTtcbi8vIC8qKiBAZGVwcmVjYXRlZCBVc2UgYHouY29yZS4kWm9kRXJyb3JNYXBDdHhgIGluc3RlYWQuICovXG4vLyBleHBvcnQgdHlwZSBFcnJvck1hcEN0eCA9IGNvcmUuJFpvZEVycm9yTWFwQ3R4O1xuIiwgImltcG9ydCAqIGFzIGNvcmUgZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmltcG9ydCB7IFpvZFJlYWxFcnJvciB9IGZyb20gXCIuL2Vycm9ycy5qc1wiO1xuZXhwb3J0IGNvbnN0IHBhcnNlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3BhcnNlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgcGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBjb3JlLl9wYXJzZUFzeW5jKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZVBhcnNlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVQYXJzZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IHNhZmVQYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVQYXJzZUFzeW5jKFpvZFJlYWxFcnJvcik7XG4vLyBDb2RlYyBmdW5jdGlvbnNcbmV4cG9ydCBjb25zdCBlbmNvZGUgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fZW5jb2RlKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgZGVjb2RlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX2RlY29kZShab2RSZWFsRXJyb3IpO1xuZXhwb3J0IGNvbnN0IGVuY29kZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX2VuY29kZUFzeW5jKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3QgZGVjb2RlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fZGVjb2RlQXN5bmMoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlRW5jb2RlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVFbmNvZGUoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlRGVjb2RlID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVEZWNvZGUoWm9kUmVhbEVycm9yKTtcbmV4cG9ydCBjb25zdCBzYWZlRW5jb2RlQXN5bmMgPSAvKiBAX19QVVJFX18gKi8gY29yZS5fc2FmZUVuY29kZUFzeW5jKFpvZFJlYWxFcnJvcik7XG5leHBvcnQgY29uc3Qgc2FmZURlY29kZUFzeW5jID0gLyogQF9fUFVSRV9fICovIGNvcmUuX3NhZmVEZWNvZGVBc3luYyhab2RSZWFsRXJyb3IpO1xuIiwgIi8vIFpvZCAzIGNvbXBhdCBsYXllclxuaW1wb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuLyoqIEBkZXByZWNhdGVkIFVzZSB0aGUgcmF3IHN0cmluZyBsaXRlcmFsIGNvZGVzIGluc3RlYWQsIGUuZy4gXCJpbnZhbGlkX3R5cGVcIi4gKi9cbmV4cG9ydCBjb25zdCBab2RJc3N1ZUNvZGUgPSB7XG4gICAgaW52YWxpZF90eXBlOiBcImludmFsaWRfdHlwZVwiLFxuICAgIHRvb19iaWc6IFwidG9vX2JpZ1wiLFxuICAgIHRvb19zbWFsbDogXCJ0b29fc21hbGxcIixcbiAgICBpbnZhbGlkX2Zvcm1hdDogXCJpbnZhbGlkX2Zvcm1hdFwiLFxuICAgIG5vdF9tdWx0aXBsZV9vZjogXCJub3RfbXVsdGlwbGVfb2ZcIixcbiAgICB1bnJlY29nbml6ZWRfa2V5czogXCJ1bnJlY29nbml6ZWRfa2V5c1wiLFxuICAgIGludmFsaWRfdW5pb246IFwiaW52YWxpZF91bmlvblwiLFxuICAgIGludmFsaWRfa2V5OiBcImludmFsaWRfa2V5XCIsXG4gICAgaW52YWxpZF9lbGVtZW50OiBcImludmFsaWRfZWxlbWVudFwiLFxuICAgIGludmFsaWRfdmFsdWU6IFwiaW52YWxpZF92YWx1ZVwiLFxuICAgIGN1c3RvbTogXCJjdXN0b21cIixcbn07XG5leHBvcnQgeyAkYnJhbmQsIGNvbmZpZyB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG4vKiogQGRlcHJlY2F0ZWQgVXNlIGB6LmNvbmZpZyhwYXJhbXMpYCBpbnN0ZWFkLiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldEVycm9yTWFwKG1hcCkge1xuICAgIGNvcmUuY29uZmlnKHtcbiAgICAgICAgY3VzdG9tRXJyb3I6IG1hcCxcbiAgICB9KTtcbn1cbi8qKiBAZGVwcmVjYXRlZCBVc2UgYHouY29uZmlnKClgIGluc3RlYWQuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JNYXAoKSB7XG4gICAgcmV0dXJuIGNvcmUuY29uZmlnKCkuY3VzdG9tRXJyb3I7XG59XG4vKiogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZS4gU3R1YiBkZWZpbml0aW9uLCBvbmx5IGluY2x1ZGVkIGZvciB6b2QtdG8tanNvbi1zY2hlbWEgY29tcGF0aWJpbGl0eS4gKi9cbmV4cG9ydCB2YXIgWm9kRmlyc3RQYXJ0eVR5cGVLaW5kO1xuKGZ1bmN0aW9uIChab2RGaXJzdFBhcnR5VHlwZUtpbmQpIHtcbn0pKFpvZEZpcnN0UGFydHlUeXBlS2luZCB8fCAoWm9kRmlyc3RQYXJ0eVR5cGVLaW5kID0ge30pKTtcbiIsICJpbXBvcnQgeyBnbG9iYWxSZWdpc3RyeSB9IGZyb20gXCIuLi9jb3JlL3JlZ2lzdHJpZXMuanNcIjtcbmltcG9ydCAqIGFzIF9jaGVja3MgZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgKiBhcyBfaXNvIGZyb20gXCIuL2lzby5qc1wiO1xuaW1wb3J0ICogYXMgX3NjaGVtYXMgZnJvbSBcIi4vc2NoZW1hcy5qc1wiO1xuLy8gTG9jYWwgeiBvYmplY3QgdG8gYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jeSB3aXRoIC4uL2luZGV4LmpzXG5jb25zdCB6ID0ge1xuICAgIC4uLl9zY2hlbWFzLFxuICAgIC4uLl9jaGVja3MsXG4gICAgaXNvOiBfaXNvLFxufTtcbi8vIEtleXMgdGhhdCBhcmUgcmVjb2duaXplZCBhbmQgaGFuZGxlZCBieSB0aGUgY29udmVyc2lvbiBsb2dpY1xuY29uc3QgUkVDT0dOSVpFRF9LRVlTID0gbmV3IFNldChbXG4gICAgLy8gU2NoZW1hIGlkZW50aWZpY2F0aW9uXG4gICAgXCIkc2NoZW1hXCIsXG4gICAgXCIkcmVmXCIsXG4gICAgXCIkZGVmc1wiLFxuICAgIFwiZGVmaW5pdGlvbnNcIixcbiAgICAvLyBDb3JlIHNjaGVtYSBrZXl3b3Jkc1xuICAgIFwiJGlkXCIsXG4gICAgXCJpZFwiLFxuICAgIFwiJGNvbW1lbnRcIixcbiAgICBcIiRhbmNob3JcIixcbiAgICBcIiR2b2NhYnVsYXJ5XCIsXG4gICAgXCIkZHluYW1pY1JlZlwiLFxuICAgIFwiJGR5bmFtaWNBbmNob3JcIixcbiAgICAvLyBUeXBlXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJlbnVtXCIsXG4gICAgXCJjb25zdFwiLFxuICAgIC8vIENvbXBvc2l0aW9uXG4gICAgXCJhbnlPZlwiLFxuICAgIFwib25lT2ZcIixcbiAgICBcImFsbE9mXCIsXG4gICAgXCJub3RcIixcbiAgICAvLyBPYmplY3RcbiAgICBcInByb3BlcnRpZXNcIixcbiAgICBcInJlcXVpcmVkXCIsXG4gICAgXCJhZGRpdGlvbmFsUHJvcGVydGllc1wiLFxuICAgIFwicGF0dGVyblByb3BlcnRpZXNcIixcbiAgICBcInByb3BlcnR5TmFtZXNcIixcbiAgICBcIm1pblByb3BlcnRpZXNcIixcbiAgICBcIm1heFByb3BlcnRpZXNcIixcbiAgICAvLyBBcnJheVxuICAgIFwiaXRlbXNcIixcbiAgICBcInByZWZpeEl0ZW1zXCIsXG4gICAgXCJhZGRpdGlvbmFsSXRlbXNcIixcbiAgICBcIm1pbkl0ZW1zXCIsXG4gICAgXCJtYXhJdGVtc1wiLFxuICAgIFwidW5pcXVlSXRlbXNcIixcbiAgICBcImNvbnRhaW5zXCIsXG4gICAgXCJtaW5Db250YWluc1wiLFxuICAgIFwibWF4Q29udGFpbnNcIixcbiAgICAvLyBTdHJpbmdcbiAgICBcIm1pbkxlbmd0aFwiLFxuICAgIFwibWF4TGVuZ3RoXCIsXG4gICAgXCJwYXR0ZXJuXCIsXG4gICAgXCJmb3JtYXRcIixcbiAgICAvLyBOdW1iZXJcbiAgICBcIm1pbmltdW1cIixcbiAgICBcIm1heGltdW1cIixcbiAgICBcImV4Y2x1c2l2ZU1pbmltdW1cIixcbiAgICBcImV4Y2x1c2l2ZU1heGltdW1cIixcbiAgICBcIm11bHRpcGxlT2ZcIixcbiAgICAvLyBBbHJlYWR5IGhhbmRsZWQgbWV0YWRhdGFcbiAgICBcImRlc2NyaXB0aW9uXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgLy8gQ29udGVudFxuICAgIFwiY29udGVudEVuY29kaW5nXCIsXG4gICAgXCJjb250ZW50TWVkaWFUeXBlXCIsXG4gICAgXCJjb250ZW50U2NoZW1hXCIsXG4gICAgLy8gVW5zdXBwb3J0ZWQgKGVycm9yLXRocm93aW5nKVxuICAgIFwidW5ldmFsdWF0ZWRJdGVtc1wiLFxuICAgIFwidW5ldmFsdWF0ZWRQcm9wZXJ0aWVzXCIsXG4gICAgXCJpZlwiLFxuICAgIFwidGhlblwiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZGVwZW5kZW50U2NoZW1hc1wiLFxuICAgIFwiZGVwZW5kZW50UmVxdWlyZWRcIixcbiAgICAvLyBPcGVuQVBJXG4gICAgXCJudWxsYWJsZVwiLFxuICAgIFwicmVhZE9ubHlcIixcbl0pO1xuZnVuY3Rpb24gZGV0ZWN0VmVyc2lvbihzY2hlbWEsIGRlZmF1bHRUYXJnZXQpIHtcbiAgICBjb25zdCAkc2NoZW1hID0gc2NoZW1hLiRzY2hlbWE7XG4gICAgaWYgKCRzY2hlbWEgPT09IFwiaHR0cHM6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQvMjAyMC0xMi9zY2hlbWFcIikge1xuICAgICAgICByZXR1cm4gXCJkcmFmdC0yMDIwLTEyXCI7XG4gICAgfVxuICAgIGlmICgkc2NoZW1hID09PSBcImh0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDcvc2NoZW1hI1wiKSB7XG4gICAgICAgIHJldHVybiBcImRyYWZ0LTdcIjtcbiAgICB9XG4gICAgaWYgKCRzY2hlbWEgPT09IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZHJhZnQtNFwiO1xuICAgIH1cbiAgICAvLyBVc2UgZGVmYXVsdFRhcmdldCBpZiBwcm92aWRlZCwgb3RoZXJ3aXNlIGRlZmF1bHQgdG8gZHJhZnQtMjAyMC0xMlxuICAgIHJldHVybiBkZWZhdWx0VGFyZ2V0ID8/IFwiZHJhZnQtMjAyMC0xMlwiO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJlZihyZWYsIGN0eCkge1xuICAgIGlmICghcmVmLnN0YXJ0c1dpdGgoXCIjXCIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkV4dGVybmFsICRyZWYgaXMgbm90IHN1cHBvcnRlZCwgb25seSBsb2NhbCByZWZzICgjLy4uLikgYXJlIGFsbG93ZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHBhdGggPSByZWYuc2xpY2UoMSkuc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcbiAgICAvLyBIYW5kbGUgcm9vdCByZWZlcmVuY2UgXCIjXCJcbiAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGN0eC5yb290U2NoZW1hO1xuICAgIH1cbiAgICBjb25zdCBkZWZzS2V5ID0gY3R4LnZlcnNpb24gPT09IFwiZHJhZnQtMjAyMC0xMlwiID8gXCIkZGVmc1wiIDogXCJkZWZpbml0aW9uc1wiO1xuICAgIGlmIChwYXRoWzBdID09PSBkZWZzS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHBhdGhbMV07XG4gICAgICAgIGlmICgha2V5IHx8ICFjdHguZGVmc1trZXldKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZmVyZW5jZSBub3QgZm91bmQ6ICR7cmVmfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjdHguZGVmc1trZXldO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFJlZmVyZW5jZSBub3QgZm91bmQ6ICR7cmVmfWApO1xufVxuZnVuY3Rpb24gY29udmVydEJhc2VTY2hlbWEoc2NoZW1hLCBjdHgpIHtcbiAgICAvLyBIYW5kbGUgdW5zdXBwb3J0ZWQgZmVhdHVyZXNcbiAgICBpZiAoc2NoZW1hLm5vdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZTogeyBub3Q6IHt9IH0gcmVwcmVzZW50cyBuZXZlclxuICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5ub3QgPT09IFwib2JqZWN0XCIgJiYgT2JqZWN0LmtleXMoc2NoZW1hLm5vdCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gei5uZXZlcigpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCBpcyBub3Qgc3VwcG9ydGVkIGluIFpvZCAoZXhjZXB0IHsgbm90OiB7fSB9IGZvciBuZXZlcilcIik7XG4gICAgfVxuICAgIGlmIChzY2hlbWEudW5ldmFsdWF0ZWRJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInVuZXZhbHVhdGVkSXRlbXMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS51bmV2YWx1YXRlZFByb3BlcnRpZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmV2YWx1YXRlZFByb3BlcnRpZXMgaXMgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYS5pZiAhPT0gdW5kZWZpbmVkIHx8IHNjaGVtYS50aGVuICE9PSB1bmRlZmluZWQgfHwgc2NoZW1hLmVsc2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb25kaXRpb25hbCBzY2hlbWFzIChpZi90aGVuL2Vsc2UpIGFyZSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmRlcGVuZGVudFNjaGVtYXMgIT09IHVuZGVmaW5lZCB8fCBzY2hlbWEuZGVwZW5kZW50UmVxdWlyZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJkZXBlbmRlbnRTY2hlbWFzIGFuZCBkZXBlbmRlbnRSZXF1aXJlZCBhcmUgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlICRyZWZcbiAgICBpZiAoc2NoZW1hLiRyZWYpIHtcbiAgICAgICAgY29uc3QgcmVmUGF0aCA9IHNjaGVtYS4kcmVmO1xuICAgICAgICBpZiAoY3R4LnJlZnMuaGFzKHJlZlBhdGgpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3R4LnJlZnMuZ2V0KHJlZlBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjdHgucHJvY2Vzc2luZy5oYXMocmVmUGF0aCkpIHtcbiAgICAgICAgICAgIC8vIENpcmN1bGFyIHJlZmVyZW5jZSAtIHVzZSBsYXp5XG4gICAgICAgICAgICByZXR1cm4gei5sYXp5KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIWN0eC5yZWZzLmhhcyhyZWZQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENpcmN1bGFyIHJlZmVyZW5jZSBub3QgcmVzb2x2ZWQ6ICR7cmVmUGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5yZWZzLmdldChyZWZQYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGN0eC5wcm9jZXNzaW5nLmFkZChyZWZQYXRoKTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlUmVmKHJlZlBhdGgsIGN0eCk7XG4gICAgICAgIGNvbnN0IHpvZFNjaGVtYSA9IGNvbnZlcnRTY2hlbWEocmVzb2x2ZWQsIGN0eCk7XG4gICAgICAgIGN0eC5yZWZzLnNldChyZWZQYXRoLCB6b2RTY2hlbWEpO1xuICAgICAgICBjdHgucHJvY2Vzc2luZy5kZWxldGUocmVmUGF0aCk7XG4gICAgICAgIHJldHVybiB6b2RTY2hlbWE7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBlbnVtXG4gICAgaWYgKHNjaGVtYS5lbnVtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZW51bVZhbHVlcyA9IHNjaGVtYS5lbnVtO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2U6IE9wZW5BUEkgMy4wIG51bGwgcmVwcmVzZW50YXRpb24geyB0eXBlOiBcInN0cmluZ1wiLCBudWxsYWJsZTogdHJ1ZSwgZW51bTogW251bGxdIH1cbiAgICAgICAgaWYgKGN0eC52ZXJzaW9uID09PSBcIm9wZW5hcGktMy4wXCIgJiZcbiAgICAgICAgICAgIHNjaGVtYS5udWxsYWJsZSA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgZW51bVZhbHVlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIGVudW1WYWx1ZXNbMF0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB6Lm51bGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZW51bVZhbHVlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB6Lm5ldmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudW1WYWx1ZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gei5saXRlcmFsKGVudW1WYWx1ZXNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrIGlmIGFsbCB2YWx1ZXMgYXJlIHN0cmluZ3NcbiAgICAgICAgaWYgKGVudW1WYWx1ZXMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgICAgcmV0dXJuIHouZW51bShlbnVtVmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNaXhlZCB0eXBlcyAtIHVzZSB1bmlvbiBvZiBsaXRlcmFsc1xuICAgICAgICBjb25zdCBsaXRlcmFsU2NoZW1hcyA9IGVudW1WYWx1ZXMubWFwKCh2KSA9PiB6LmxpdGVyYWwodikpO1xuICAgICAgICBpZiAobGl0ZXJhbFNjaGVtYXMubGVuZ3RoIDwgMikge1xuICAgICAgICAgICAgcmV0dXJuIGxpdGVyYWxTY2hlbWFzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LnVuaW9uKFtsaXRlcmFsU2NoZW1hc1swXSwgbGl0ZXJhbFNjaGVtYXNbMV0sIC4uLmxpdGVyYWxTY2hlbWFzLnNsaWNlKDIpXSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSBjb25zdFxuICAgIGlmIChzY2hlbWEuY29uc3QgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gei5saXRlcmFsKHNjaGVtYS5jb25zdCk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSB0eXBlXG4gICAgY29uc3QgdHlwZSA9IHNjaGVtYS50eXBlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIC8vIEV4cGFuZCB0eXBlIGFycmF5IGludG8gYW55T2YgdW5pb25cbiAgICAgICAgY29uc3QgdHlwZVNjaGVtYXMgPSB0eXBlLm1hcCgodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdHlwZVNjaGVtYSA9IHsgLi4uc2NoZW1hLCB0eXBlOiB0IH07XG4gICAgICAgICAgICByZXR1cm4gY29udmVydEJhc2VTY2hlbWEodHlwZVNjaGVtYSwgY3R4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0eXBlU2NoZW1hcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB6Lm5ldmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVTY2hlbWFzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVTY2hlbWFzWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB6LnVuaW9uKHR5cGVTY2hlbWFzKTtcbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIC8vIE5vIHR5cGUgc3BlY2lmaWVkIC0gZW1wdHkgc2NoZW1hIChhbnkpXG4gICAgICAgIHJldHVybiB6LmFueSgpO1xuICAgIH1cbiAgICBsZXQgem9kU2NoZW1hO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHtcbiAgICAgICAgICAgIGxldCBzdHJpbmdTY2hlbWEgPSB6LnN0cmluZygpO1xuICAgICAgICAgICAgLy8gQXBwbHkgZm9ybWF0IHVzaW5nIC5jaGVjaygpIHdpdGggWm9kIGZvcm1hdCBmdW5jdGlvbnNcbiAgICAgICAgICAgIGlmIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZm9ybWF0ID0gc2NoZW1hLmZvcm1hdDtcbiAgICAgICAgICAgICAgICAvLyBNYXAgY29tbW9uIGZvcm1hdHMgdG8gWm9kIGNoZWNrIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChmb3JtYXQgPT09IFwiZW1haWxcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5lbWFpbCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInVyaVwiIHx8IGZvcm1hdCA9PT0gXCJ1cmktcmVmZXJlbmNlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoudXJsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwidXVpZFwiIHx8IGZvcm1hdCA9PT0gXCJndWlkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoudXVpZCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImRhdGUtdGltZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lmlzby5kYXRldGltZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImRhdGVcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pc28uZGF0ZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcInRpbWVcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5pc28udGltZSgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImR1cmF0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXNvLmR1cmF0aW9uKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiaXB2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmlwdjQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJpcHY2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouaXB2NigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcIm1hY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6Lm1hYygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZm9ybWF0ID09PSBcImNpZHJcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5jaWRydjQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJjaWRyLXY2XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouY2lkcnY2KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiYmFzZTY0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouYmFzZTY0KCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiYmFzZTY0dXJsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHouYmFzZTY0dXJsKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiZTE2NFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmUxNjQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJqd3RcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei5qd3QoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJlbW9qaVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmVtb2ppKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwibmFub2lkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLmNoZWNrKHoubmFub2lkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwiY3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmN1aWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJjdWlkMlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmN1aWQyKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmb3JtYXQgPT09IFwidWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LnVsaWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJ4aWRcIikge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEuY2hlY2soei54aWQoKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcm1hdCA9PT0gXCJrc3VpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5jaGVjayh6LmtzdWlkKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBqc29uLXN0cmluZyBmb3JtYXQgaXMgbm90IGN1cnJlbnRseSBzdXBwb3J0ZWQgYnkgWm9kXG4gICAgICAgICAgICAgICAgLy8gQ3VzdG9tIGZvcm1hdHMgYXJlIGlnbm9yZWQgLSBrZWVwIGFzIHBsYWluIHN0cmluZ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQXBwbHkgY29uc3RyYWludHNcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbkxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHN0cmluZ1NjaGVtYSA9IHN0cmluZ1NjaGVtYS5taW4oc2NoZW1hLm1pbkxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNjaGVtYS5tYXhMZW5ndGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmdTY2hlbWEgPSBzdHJpbmdTY2hlbWEubWF4KHNjaGVtYS5tYXhMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjaGVtYS5wYXR0ZXJuKSB7XG4gICAgICAgICAgICAgICAgLy8gSlNPTiBTY2hlbWEgcGF0dGVybnMgYXJlIG5vdCBpbXBsaWNpdGx5IGFuY2hvcmVkIChtYXRjaCBhbnl3aGVyZSBpbiBzdHJpbmcpXG4gICAgICAgICAgICAgICAgc3RyaW5nU2NoZW1hID0gc3RyaW5nU2NoZW1hLnJlZ2V4KG5ldyBSZWdFeHAoc2NoZW1hLnBhdHRlcm4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpvZFNjaGVtYSA9IHN0cmluZ1NjaGVtYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgY2FzZSBcImludGVnZXJcIjoge1xuICAgICAgICAgICAgbGV0IG51bWJlclNjaGVtYSA9IHR5cGUgPT09IFwiaW50ZWdlclwiID8gei5udW1iZXIoKS5pbnQoKSA6IHoubnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBBcHBseSBjb25zdHJhaW50c1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5taW4oc2NoZW1hLm1pbmltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5tYXgoc2NoZW1hLm1heGltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuZXhjbHVzaXZlTWluaW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5ndChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzY2hlbWEuZXhjbHVzaXZlTWluaW11bSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygc2NoZW1hLm1pbmltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEuZ3Qoc2NoZW1hLm1pbmltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5sdChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzY2hlbWEuZXhjbHVzaXZlTWF4aW11bSA9PT0gdHJ1ZSAmJiB0eXBlb2Ygc2NoZW1hLm1heGltdW0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJTY2hlbWEgPSBudW1iZXJTY2hlbWEubHQoc2NoZW1hLm1heGltdW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubXVsdGlwbGVPZiA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIG51bWJlclNjaGVtYSA9IG51bWJlclNjaGVtYS5tdWx0aXBsZU9mKHNjaGVtYS5tdWx0aXBsZU9mKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHpvZFNjaGVtYSA9IG51bWJlclNjaGVtYTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6IHtcbiAgICAgICAgICAgIHpvZFNjaGVtYSA9IHouYm9vbGVhbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIm51bGxcIjoge1xuICAgICAgICAgICAgem9kU2NoZW1hID0gei5udWxsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0ge307XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0aWVzID0gc2NoZW1hLnByb3BlcnRpZXMgfHwge307XG4gICAgICAgICAgICBjb25zdCByZXF1aXJlZFNldCA9IG5ldyBTZXQoc2NoZW1hLnJlcXVpcmVkIHx8IFtdKTtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcHJvcGVydGllcyAtIG1hcmsgb3B0aW9uYWwgb25lc1xuICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCBwcm9wU2NoZW1hXSBvZiBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3Bab2RTY2hlbWEgPSBjb252ZXJ0U2NoZW1hKHByb3BTY2hlbWEsIGN0eCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90IGluIHJlcXVpcmVkIGFycmF5LCBtYWtlIGl0IG9wdGlvbmFsXG4gICAgICAgICAgICAgICAgc2hhcGVba2V5XSA9IHJlcXVpcmVkU2V0LmhhcyhrZXkpID8gcHJvcFpvZFNjaGVtYSA6IHByb3Bab2RTY2hlbWEub3B0aW9uYWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBwcm9wZXJ0eU5hbWVzXG4gICAgICAgICAgICBpZiAoc2NoZW1hLnByb3BlcnR5TmFtZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlTY2hlbWEgPSBjb252ZXJ0U2NoZW1hKHNjaGVtYS5wcm9wZXJ0eU5hbWVzLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlU2NoZW1hID0gc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzICYmIHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgPT09IFwib2JqZWN0XCJcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0U2NoZW1hKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcywgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IHouYW55KCk7XG4gICAgICAgICAgICAgICAgLy8gQ2FzZSBBOiBObyBwcm9wZXJ0aWVzIChwdXJlIHJlY29yZClcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXMoc2hhcGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSB6LnJlY29yZChrZXlTY2hlbWEsIHZhbHVlU2NoZW1hKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIENhc2UgQjogV2l0aCBwcm9wZXJ0aWVzIChpbnRlcnNlY3Rpb24gb2Ygb2JqZWN0IGFuZCBsb29zZVJlY29yZClcbiAgICAgICAgICAgICAgICBjb25zdCBvYmplY3RTY2hlbWEgPSB6Lm9iamVjdChzaGFwZSkucGFzc3Rocm91Z2goKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWNvcmRTY2hlbWEgPSB6Lmxvb3NlUmVjb3JkKGtleVNjaGVtYSwgdmFsdWVTY2hlbWEpO1xuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHouaW50ZXJzZWN0aW9uKG9iamVjdFNjaGVtYSwgcmVjb3JkU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEhhbmRsZSBwYXR0ZXJuUHJvcGVydGllc1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5wYXR0ZXJuUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIC8vIHBhdHRlcm5Qcm9wZXJ0aWVzOiBrZXlzIG1hdGNoaW5nIHBhdHRlcm4gbXVzdCBzYXRpc2Z5IGNvcnJlc3BvbmRpbmcgc2NoZW1hXG4gICAgICAgICAgICAgICAgLy8gVXNlIGxvb3NlIHJlY29yZHMgc28gbm9uLW1hdGNoaW5nIGtleXMgcGFzcyB0aHJvdWdoXG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblByb3BzID0gc2NoZW1hLnBhdHRlcm5Qcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdHRlcm5LZXlzID0gT2JqZWN0LmtleXMocGF0dGVyblByb3BzKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb29zZVJlY29yZHMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHBhdHRlcm4gb2YgcGF0dGVybktleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0dGVyblZhbHVlID0gY29udmVydFNjaGVtYShwYXR0ZXJuUHJvcHNbcGF0dGVybl0sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleVNjaGVtYSA9IHouc3RyaW5nKCkucmVnZXgobmV3IFJlZ0V4cChwYXR0ZXJuKSk7XG4gICAgICAgICAgICAgICAgICAgIGxvb3NlUmVjb3Jkcy5wdXNoKHoubG9vc2VSZWNvcmQoa2V5U2NoZW1hLCBwYXR0ZXJuVmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQnVpbGQgaW50ZXJzZWN0aW9uOiBvYmplY3Qgc2NoZW1hICsgYWxsIHBhdHRlcm4gcHJvcGVydHkgcmVjb3Jkc1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYXNUb0ludGVyc2VjdCA9IFtdO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzaGFwZSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBVc2UgcGFzc3Rocm91Z2ggc28gcGF0dGVyblByb3BlcnRpZXMgY2FuIHZhbGlkYXRlIGFkZGl0aW9uYWwga2V5c1xuICAgICAgICAgICAgICAgICAgICBzY2hlbWFzVG9JbnRlcnNlY3QucHVzaCh6Lm9iamVjdChzaGFwZSkucGFzc3Rocm91Z2goKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNjaGVtYXNUb0ludGVyc2VjdC5wdXNoKC4uLmxvb3NlUmVjb3Jkcyk7XG4gICAgICAgICAgICAgICAgaWYgKHNjaGVtYXNUb0ludGVyc2VjdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei5vYmplY3Qoe30pLnBhc3N0aHJvdWdoKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHNjaGVtYXNUb0ludGVyc2VjdC5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gc2NoZW1hc1RvSW50ZXJzZWN0WzBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hhaW4gaW50ZXJzZWN0aW9uczogKEEgJiBCKSAmIEMgJiBEIC4uLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gei5pbnRlcnNlY3Rpb24oc2NoZW1hc1RvSW50ZXJzZWN0WzBdLCBzY2hlbWFzVG9JbnRlcnNlY3RbMV0pO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMjsgaSA8IHNjaGVtYXNUb0ludGVyc2VjdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gei5pbnRlcnNlY3Rpb24ocmVzdWx0LCBzY2hlbWFzVG9JbnRlcnNlY3RbaV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBIYW5kbGUgYWRkaXRpb25hbFByb3BlcnRpZXNcbiAgICAgICAgICAgIC8vIEluIEpTT04gU2NoZW1hLCBhZGRpdGlvbmFsUHJvcGVydGllcyBkZWZhdWx0cyB0byB0cnVlIChhbGxvdyBhbnkgZXh0cmEgcHJvcGVydGllcylcbiAgICAgICAgICAgIC8vIEluIFpvZCwgb2JqZWN0cyBzdHJpcCB1bmtub3duIGtleXMgYnkgZGVmYXVsdCwgc28gd2UgbmVlZCB0byBoYW5kbGUgdGhpcyBleHBsaWNpdGx5XG4gICAgICAgICAgICBjb25zdCBvYmplY3RTY2hlbWEgPSB6Lm9iamVjdChzaGFwZSk7XG4gICAgICAgICAgICBpZiAoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIC8vIFN0cmljdCBtb2RlIC0gbm8gZXh0cmEgcHJvcGVydGllcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gb2JqZWN0U2NoZW1hLnN0cmljdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIC8vIEV4dHJhIHByb3BlcnRpZXMgbXVzdCBtYXRjaCB0aGUgc3BlY2lmaWVkIHNjaGVtYVxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IG9iamVjdFNjaGVtYS5jYXRjaGFsbChjb252ZXJ0U2NoZW1hKHNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcywgY3R4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsUHJvcGVydGllcyBpcyB0cnVlIG9yIHVuZGVmaW5lZCAtIGFsbG93IGFueSBleHRyYSBwcm9wZXJ0aWVzIChwYXNzdGhyb3VnaClcbiAgICAgICAgICAgICAgICB6b2RTY2hlbWEgPSBvYmplY3RTY2hlbWEucGFzc3Rocm91Z2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJhcnJheVwiOiB7XG4gICAgICAgICAgICAvLyBUT0RPOiB1bmlxdWVJdGVtcyBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgICAgICAvLyBUT0RPOiBjb250YWlucy9taW5Db250YWlucy9tYXhDb250YWlucyBhcmUgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHR1cGxlIChwcmVmaXhJdGVtcyBvciBpdGVtcyBhcyBhcnJheSlcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeEl0ZW1zID0gc2NoZW1hLnByZWZpeEl0ZW1zO1xuICAgICAgICAgICAgY29uc3QgaXRlbXMgPSBzY2hlbWEuaXRlbXM7XG4gICAgICAgICAgICBpZiAocHJlZml4SXRlbXMgJiYgQXJyYXkuaXNBcnJheShwcmVmaXhJdGVtcykpIHtcbiAgICAgICAgICAgICAgICAvLyBUdXBsZSB3aXRoIHByZWZpeEl0ZW1zIChkcmFmdC0yMDIwLTEyKVxuICAgICAgICAgICAgICAgIGNvbnN0IHR1cGxlSXRlbXMgPSBwcmVmaXhJdGVtcy5tYXAoKGl0ZW0pID0+IGNvbnZlcnRTY2hlbWEoaXRlbSwgY3R4KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdCA9IGl0ZW1zICYmIHR5cGVvZiBpdGVtcyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShpdGVtcylcbiAgICAgICAgICAgICAgICAgICAgPyBjb252ZXJ0U2NoZW1hKGl0ZW1zLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoudHVwbGUodHVwbGVJdGVtcykucmVzdChyZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoudHVwbGUodHVwbGVJdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IG1pbkl0ZW1zL21heEl0ZW1zIGNvbnN0cmFpbnRzIHRvIHR1cGxlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbkl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5jaGVjayh6Lm1pbkxlbmd0aChzY2hlbWEubWluSXRlbXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4SXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmNoZWNrKHoubWF4TGVuZ3RoKHNjaGVtYS5tYXhJdGVtcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoaXRlbXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gVHVwbGUgd2l0aCBpdGVtcyBhcnJheSAoZHJhZnQtNylcbiAgICAgICAgICAgICAgICBjb25zdCB0dXBsZUl0ZW1zID0gaXRlbXMubWFwKChpdGVtKSA9PiBjb252ZXJ0U2NoZW1hKGl0ZW0sIGN0eCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zICYmIHR5cGVvZiBzY2hlbWEuYWRkaXRpb25hbEl0ZW1zID09PSBcIm9iamVjdFwiXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFNjaGVtYShzY2hlbWEuYWRkaXRpb25hbEl0ZW1zLCBjdHgpXG4gICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkOyAvLyBhZGRpdGlvbmFsSXRlbXM6IGZhbHNlIG1lYW5zIG5vIHJlc3QsIGhhbmRsZWQgYnkgZGVmYXVsdCB0dXBsZSBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGlmIChyZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoudHVwbGUodHVwbGVJdGVtcykucmVzdChyZXN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHoudHVwbGUodHVwbGVJdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFwcGx5IG1pbkl0ZW1zL21heEl0ZW1zIGNvbnN0cmFpbnRzIHRvIHR1cGxlc1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbkl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5jaGVjayh6Lm1pbkxlbmd0aChzY2hlbWEubWluSXRlbXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzY2hlbWEubWF4SXRlbXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgem9kU2NoZW1hID0gem9kU2NoZW1hLmNoZWNrKHoubWF4TGVuZ3RoKHNjaGVtYS5tYXhJdGVtcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW1zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZWd1bGFyIGFycmF5XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IGNvbnZlcnRTY2hlbWEoaXRlbXMsIGN0eCk7XG4gICAgICAgICAgICAgICAgbGV0IGFycmF5U2NoZW1hID0gei5hcnJheShlbGVtZW50KTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBjb25zdHJhaW50c1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1pbkl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5U2NoZW1hID0gYXJyYXlTY2hlbWEubWluKHNjaGVtYS5taW5JdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2NoZW1hLm1heEl0ZW1zID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFycmF5U2NoZW1hID0gYXJyYXlTY2hlbWEubWF4KHNjaGVtYS5tYXhJdGVtcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpvZFNjaGVtYSA9IGFycmF5U2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gaXRlbXMgc3BlY2lmaWVkIC0gYXJyYXkgb2YgYW55XG4gICAgICAgICAgICAgICAgem9kU2NoZW1hID0gei5hcnJheSh6LmFueSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHR5cGU6ICR7dHlwZX1gKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgbWV0YWRhdGFcbiAgICBpZiAoc2NoZW1hLmRlc2NyaXB0aW9uKSB7XG4gICAgICAgIHpvZFNjaGVtYSA9IHpvZFNjaGVtYS5kZXNjcmliZShzY2hlbWEuZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hLmRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB6b2RTY2hlbWEgPSB6b2RTY2hlbWEuZGVmYXVsdChzY2hlbWEuZGVmYXVsdCk7XG4gICAgfVxuICAgIHJldHVybiB6b2RTY2hlbWE7XG59XG5mdW5jdGlvbiBjb252ZXJ0U2NoZW1hKHNjaGVtYSwgY3R4KSB7XG4gICAgaWYgKHR5cGVvZiBzY2hlbWEgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiBzY2hlbWEgPyB6LmFueSgpIDogei5uZXZlcigpO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IGJhc2Ugc2NoZW1hIGZpcnN0IChpZ25vcmluZyBjb21wb3NpdGlvbiBrZXl3b3JkcylcbiAgICBsZXQgYmFzZVNjaGVtYSA9IGNvbnZlcnRCYXNlU2NoZW1hKHNjaGVtYSwgY3R4KTtcbiAgICBjb25zdCBoYXNFeHBsaWNpdFR5cGUgPSBzY2hlbWEudHlwZSB8fCBzY2hlbWEuZW51bSAhPT0gdW5kZWZpbmVkIHx8IHNjaGVtYS5jb25zdCAhPT0gdW5kZWZpbmVkO1xuICAgIC8vIFByb2Nlc3MgY29tcG9zaXRpb24ga2V5d29yZHMgTEFTVCAodGhleSBjYW4gYXBwZWFyIHRvZ2V0aGVyKVxuICAgIC8vIEhhbmRsZSBhbnlPZiAtIHdyYXAgYmFzZSBzY2hlbWEgd2l0aCB1bmlvblxuICAgIGlmIChzY2hlbWEuYW55T2YgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEuYW55T2YpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzY2hlbWEuYW55T2YubWFwKChzKSA9PiBjb252ZXJ0U2NoZW1hKHMsIGN0eCkpO1xuICAgICAgICBjb25zdCBhbnlPZlVuaW9uID0gei51bmlvbihvcHRpb25zKTtcbiAgICAgICAgYmFzZVNjaGVtYSA9IGhhc0V4cGxpY2l0VHlwZSA/IHouaW50ZXJzZWN0aW9uKGJhc2VTY2hlbWEsIGFueU9mVW5pb24pIDogYW55T2ZVbmlvbjtcbiAgICB9XG4gICAgLy8gSGFuZGxlIG9uZU9mIC0gZXhjbHVzaXZlIHVuaW9uIChleGFjdGx5IG9uZSBtdXN0IG1hdGNoKVxuICAgIGlmIChzY2hlbWEub25lT2YgJiYgQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzY2hlbWEub25lT2YubWFwKChzKSA9PiBjb252ZXJ0U2NoZW1hKHMsIGN0eCkpO1xuICAgICAgICBjb25zdCBvbmVPZlVuaW9uID0gei54b3Iob3B0aW9ucyk7XG4gICAgICAgIGJhc2VTY2hlbWEgPSBoYXNFeHBsaWNpdFR5cGUgPyB6LmludGVyc2VjdGlvbihiYXNlU2NoZW1hLCBvbmVPZlVuaW9uKSA6IG9uZU9mVW5pb247XG4gICAgfVxuICAgIC8vIEhhbmRsZSBhbGxPZiAtIHdyYXAgYmFzZSBzY2hlbWEgd2l0aCBpbnRlcnNlY3Rpb25cbiAgICBpZiAoc2NoZW1hLmFsbE9mICYmIEFycmF5LmlzQXJyYXkoc2NoZW1hLmFsbE9mKSkge1xuICAgICAgICBpZiAoc2NoZW1hLmFsbE9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgYmFzZVNjaGVtYSA9IGhhc0V4cGxpY2l0VHlwZSA/IGJhc2VTY2hlbWEgOiB6LmFueSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IGhhc0V4cGxpY2l0VHlwZSA/IGJhc2VTY2hlbWEgOiBjb252ZXJ0U2NoZW1hKHNjaGVtYS5hbGxPZlswXSwgY3R4KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0SWR4ID0gaGFzRXhwbGljaXRUeXBlID8gMCA6IDE7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJZHg7IGkgPCBzY2hlbWEuYWxsT2YubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB6LmludGVyc2VjdGlvbihyZXN1bHQsIGNvbnZlcnRTY2hlbWEoc2NoZW1hLmFsbE9mW2ldLCBjdHgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJhc2VTY2hlbWEgPSByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSGFuZGxlIG51bGxhYmxlIChPcGVuQVBJIDMuMClcbiAgICBpZiAoc2NoZW1hLm51bGxhYmxlID09PSB0cnVlICYmIGN0eC52ZXJzaW9uID09PSBcIm9wZW5hcGktMy4wXCIpIHtcbiAgICAgICAgYmFzZVNjaGVtYSA9IHoubnVsbGFibGUoYmFzZVNjaGVtYSk7XG4gICAgfVxuICAgIC8vIEhhbmRsZSByZWFkT25seVxuICAgIGlmIChzY2hlbWEucmVhZE9ubHkgPT09IHRydWUpIHtcbiAgICAgICAgYmFzZVNjaGVtYSA9IHoucmVhZG9ubHkoYmFzZVNjaGVtYSk7XG4gICAgfVxuICAgIC8vIENvbGxlY3QgbWV0YWRhdGE6IGNvcmUgc2NoZW1hIGtleXdvcmRzIGFuZCB1bnJlY29nbml6ZWQga2V5c1xuICAgIGNvbnN0IGV4dHJhTWV0YSA9IHt9O1xuICAgIC8vIENvcmUgc2NoZW1hIGtleXdvcmRzIHRoYXQgc2hvdWxkIGJlIGNhcHR1cmVkIGFzIG1ldGFkYXRhXG4gICAgY29uc3QgY29yZU1ldGFkYXRhS2V5cyA9IFtcIiRpZFwiLCBcImlkXCIsIFwiJGNvbW1lbnRcIiwgXCIkYW5jaG9yXCIsIFwiJHZvY2FidWxhcnlcIiwgXCIkZHluYW1pY1JlZlwiLCBcIiRkeW5hbWljQW5jaG9yXCJdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGNvcmVNZXRhZGF0YUtleXMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGV4dHJhTWV0YVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ29udGVudCBrZXl3b3JkcyAtIHN0b3JlIGFzIG1ldGFkYXRhXG4gICAgY29uc3QgY29udGVudE1ldGFkYXRhS2V5cyA9IFtcImNvbnRlbnRFbmNvZGluZ1wiLCBcImNvbnRlbnRNZWRpYVR5cGVcIiwgXCJjb250ZW50U2NoZW1hXCJdO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGNvbnRlbnRNZXRhZGF0YUtleXMpIHtcbiAgICAgICAgaWYgKGtleSBpbiBzY2hlbWEpIHtcbiAgICAgICAgICAgIGV4dHJhTWV0YVtrZXldID0gc2NoZW1hW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVW5yZWNvZ25pemVkIGtleXMgKGN1c3RvbSBtZXRhZGF0YSlcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzY2hlbWEpKSB7XG4gICAgICAgIGlmICghUkVDT0dOSVpFRF9LRVlTLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBleHRyYU1ldGFba2V5XSA9IHNjaGVtYVtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhleHRyYU1ldGEpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY3R4LnJlZ2lzdHJ5LmFkZChiYXNlU2NoZW1hLCBleHRyYU1ldGEpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZVNjaGVtYTtcbn1cbi8qKlxuICogQ29udmVydHMgYSBKU09OIFNjaGVtYSB0byBhIFpvZCBzY2hlbWEuIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNvbnNpZGVyZWQgc2VtaS1leHBlcmltZW50YWwuIEl0J3MgYmVoYXZpb3IgaXMgbGlhYmxlIHRvIGNoYW5nZS4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmcm9tSlNPTlNjaGVtYShzY2hlbWEsIHBhcmFtcykge1xuICAgIC8vIEhhbmRsZSBib29sZWFuIHNjaGVtYXNcbiAgICBpZiAodHlwZW9mIHNjaGVtYSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgcmV0dXJuIHNjaGVtYSA/IHouYW55KCkgOiB6Lm5ldmVyKCk7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBkZXRlY3RWZXJzaW9uKHNjaGVtYSwgcGFyYW1zPy5kZWZhdWx0VGFyZ2V0KTtcbiAgICBjb25zdCBkZWZzID0gKHNjaGVtYS4kZGVmcyB8fCBzY2hlbWEuZGVmaW5pdGlvbnMgfHwge30pO1xuICAgIGNvbnN0IGN0eCA9IHtcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgZGVmcyxcbiAgICAgICAgcmVmczogbmV3IE1hcCgpLFxuICAgICAgICBwcm9jZXNzaW5nOiBuZXcgU2V0KCksXG4gICAgICAgIHJvb3RTY2hlbWE6IHNjaGVtYSxcbiAgICAgICAgcmVnaXN0cnk6IHBhcmFtcz8ucmVnaXN0cnkgPz8gZ2xvYmFsUmVnaXN0cnksXG4gICAgfTtcbiAgICByZXR1cm4gY29udmVydFNjaGVtYShzY2hlbWEsIGN0eCk7XG59XG4iLCAiZXhwb3J0ICogYXMgY29yZSBmcm9tIFwiLi4vY29yZS9pbmRleC5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vc2NoZW1hcy5qc1wiO1xuZXhwb3J0ICogZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9lcnJvcnMuanNcIjtcbmV4cG9ydCAqIGZyb20gXCIuL3BhcnNlLmpzXCI7XG5leHBvcnQgKiBmcm9tIFwiLi9jb21wYXQuanNcIjtcbi8vIHpvZC1zcGVjaWZpZWRcbmltcG9ydCB7IGNvbmZpZyB9IGZyb20gXCIuLi9jb3JlL2luZGV4LmpzXCI7XG5pbXBvcnQgZW4gZnJvbSBcIi4uL2xvY2FsZXMvZW4uanNcIjtcbmNvbmZpZyhlbigpKTtcbmV4cG9ydCB7IGdsb2JhbFJlZ2lzdHJ5LCByZWdpc3RyeSwgY29uZmlnLCAkb3V0cHV0LCAkaW5wdXQsICRicmFuZCwgY2xvbmUsIHJlZ2V4ZXMsIHRyZWVpZnlFcnJvciwgcHJldHRpZnlFcnJvciwgZm9ybWF0RXJyb3IsIGZsYXR0ZW5FcnJvciwgVGltZVByZWNpc2lvbiwgdXRpbCwgTkVWRVIsIH0gZnJvbSBcIi4uL2NvcmUvaW5kZXguanNcIjtcbmV4cG9ydCB7IHRvSlNPTlNjaGVtYSB9IGZyb20gXCIuLi9jb3JlL2pzb24tc2NoZW1hLXByb2Nlc3NvcnMuanNcIjtcbmV4cG9ydCB7IGZyb21KU09OU2NoZW1hIH0gZnJvbSBcIi4vZnJvbS1qc29uLXNjaGVtYS5qc1wiO1xuZXhwb3J0ICogYXMgbG9jYWxlcyBmcm9tIFwiLi4vbG9jYWxlcy9pbmRleC5qc1wiO1xuLy8gaXNvXG4vLyBtdXN0IGJlIGV4cG9ydGVkIGZyb20gdG9wLWxldmVsXG4vLyBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvaXNzdWVzLzQ0OTFcbmV4cG9ydCB7IFpvZElTT0RhdGVUaW1lLCBab2RJU09EYXRlLCBab2RJU09UaW1lLCBab2RJU09EdXJhdGlvbiB9IGZyb20gXCIuL2lzby5qc1wiO1xuZXhwb3J0ICogYXMgaXNvIGZyb20gXCIuL2lzby5qc1wiO1xuZXhwb3J0ICogYXMgY29lcmNlIGZyb20gXCIuL2NvZXJjZS5qc1wiO1xuIiwgbnVsbCwgbnVsbCwgImV4cG9ydCBjb25zdCBpZ25vcmVPdmVycmlkZSA9IFN5bWJvbChcIkxldCB6b2RUb0pzb25TY2hlbWEgZGVjaWRlIG9uIHdoaWNoIHBhcnNlciB0byB1c2VcIik7XG5leHBvcnQgY29uc3QganNvbkRlc2NyaXB0aW9uID0gKGpzb25TY2hlbWEsIGRlZikgPT4ge1xuICAgIGlmIChkZWYuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4uanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgICAuLi5KU09OLnBhcnNlKGRlZi5kZXNjcmlwdGlvbiksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIHsgfVxuICAgIH1cbiAgICByZXR1cm4ganNvblNjaGVtYTtcbn07XG5leHBvcnQgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XG4gICAgbmFtZTogdW5kZWZpbmVkLFxuICAgICRyZWZTdHJhdGVneTogXCJyb290XCIsXG4gICAgYmFzZVBhdGg6IFtcIiNcIl0sXG4gICAgZWZmZWN0U3RyYXRlZ3k6IFwiaW5wdXRcIixcbiAgICBwaXBlU3RyYXRlZ3k6IFwiYWxsXCIsXG4gICAgZGF0ZVN0cmF0ZWd5OiBcImZvcm1hdDpkYXRlLXRpbWVcIixcbiAgICBtYXBTdHJhdGVneTogXCJlbnRyaWVzXCIsXG4gICAgcmVtb3ZlQWRkaXRpb25hbFN0cmF0ZWd5OiBcInBhc3N0aHJvdWdoXCIsXG4gICAgYWxsb3dlZEFkZGl0aW9uYWxQcm9wZXJ0aWVzOiB0cnVlLFxuICAgIHJlamVjdGVkQWRkaXRpb25hbFByb3BlcnRpZXM6IGZhbHNlLFxuICAgIGRlZmluaXRpb25QYXRoOiBcImRlZmluaXRpb25zXCIsXG4gICAgdGFyZ2V0OiBcImpzb25TY2hlbWE3XCIsXG4gICAgc3RyaWN0VW5pb25zOiBmYWxzZSxcbiAgICBkZWZpbml0aW9uczoge30sXG4gICAgZXJyb3JNZXNzYWdlczogZmFsc2UsXG4gICAgbWFya2Rvd25EZXNjcmlwdGlvbjogZmFsc2UsXG4gICAgcGF0dGVyblN0cmF0ZWd5OiBcImVzY2FwZVwiLFxuICAgIGFwcGx5UmVnZXhGbGFnczogZmFsc2UsXG4gICAgZW1haWxTdHJhdGVneTogXCJmb3JtYXQ6ZW1haWxcIixcbiAgICBiYXNlNjRTdHJhdGVneTogXCJjb250ZW50RW5jb2Rpbmc6YmFzZTY0XCIsXG4gICAgbmFtZVN0cmF0ZWd5OiBcInJlZlwiLFxuICAgIG9wZW5BaUFueVR5cGVOYW1lOiBcIk9wZW5BaUFueVR5cGVcIlxufTtcbmV4cG9ydCBjb25zdCBnZXREZWZhdWx0T3B0aW9ucyA9IChvcHRpb25zKSA9PiAodHlwZW9mIG9wdGlvbnMgPT09IFwic3RyaW5nXCJcbiAgICA/IHtcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAgIG5hbWU6IG9wdGlvbnMsXG4gICAgfVxuICAgIDoge1xuICAgICAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9KTtcbiIsICJpbXBvcnQgeyBzZXRSZXNwb25zZVZhbHVlQW5kRXJyb3JzIH0gZnJvbSBcIi4uL2Vycm9yTWVzc2FnZXMuanNcIjtcbmxldCBlbW9qaVJlZ2V4ID0gdW5kZWZpbmVkO1xuLyoqXG4gKiBHZW5lcmF0ZWQgZnJvbSB0aGUgcmVndWxhciBleHByZXNzaW9ucyBmb3VuZCBoZXJlIGFzIG9mIDIwMjQtMDUtMjI6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY29saW5oYWNrcy96b2QvYmxvYi9tYXN0ZXIvc3JjL3R5cGVzLnRzLlxuICpcbiAqIEV4cHJlc3Npb25zIHdpdGggL2kgZmxhZyBoYXZlIGJlZW4gY2hhbmdlZCBhY2NvcmRpbmdseS5cbiAqL1xuZXhwb3J0IGNvbnN0IHpvZFBhdHRlcm5zID0ge1xuICAgIC8qKlxuICAgICAqIGBjYCB3YXMgY2hhbmdlZCB0byBgW2NDXWAgdG8gcmVwbGljYXRlIC9pIGZsYWdcbiAgICAgKi9cbiAgICBjdWlkOiAvXltjQ11bXlxccy1dezgsfSQvLFxuICAgIGN1aWQyOiAvXlswLTlhLXpdKyQvLFxuICAgIHVsaWQ6IC9eWzAtOUEtSEpLTU5QLVRWLVpdezI2fSQvLFxuICAgIC8qKlxuICAgICAqIGBhLXpgIHdhcyBhZGRlZCB0byByZXBsaWNhdGUgL2kgZmxhZ1xuICAgICAqL1xuICAgIGVtYWlsOiAvXig/IVxcLikoPyEuKlxcLlxcLikoW2EtekEtWjAtOV8nK1xcLVxcLl0qKVthLXpBLVowLTlfKy1dQChbYS16QS1aMC05XVthLXpBLVowLTlcXC1dKlxcLikrW2EtekEtWl17Mix9JC8sXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0ZWQgYSB2YWxpZCBVbmljb2RlIFJlZ0V4cFxuICAgICAqXG4gICAgICogTGF6aWx5IGluc3RhbnRpYXRlIHNpbmNlIHRoaXMgdHlwZSBvZiByZWdleCBpc24ndCBzdXBwb3J0ZWRcbiAgICAgKiBpbiBhbGwgZW52cyAoZS5nLiBSZWFjdCBOYXRpdmUpLlxuICAgICAqXG4gICAgICogU2VlOlxuICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jb2xpbmhhY2tzL3pvZC9pc3N1ZXMvMjQzM1xuICAgICAqIEZpeCBpbiBab2Q6XG4gICAgICogaHR0cHM6Ly9naXRodWIuY29tL2NvbGluaGFja3Mvem9kL2NvbW1pdC85MzQwZmQ1MWU0ODU3NmE3NWFkYzkxOWJmZjY1ZGJjNGE1ZDRjOTliXG4gICAgICovXG4gICAgZW1vamk6ICgpID0+IHtcbiAgICAgICAgaWYgKGVtb2ppUmVnZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZW1vamlSZWdleCA9IFJlZ0V4cChcIl4oXFxcXHB7RXh0ZW5kZWRfUGljdG9ncmFwaGljfXxcXFxccHtFbW9qaV9Db21wb25lbnR9KSskXCIsIFwidVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW1vamlSZWdleDtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFVudXNlZFxuICAgICAqL1xuICAgIHV1aWQ6IC9eWzAtOWEtZkEtRl17OH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17NH1cXGItWzAtOWEtZkEtRl17MTJ9JC8sXG4gICAgLyoqXG4gICAgICogVW51c2VkXG4gICAgICovXG4gICAgaXB2NDogL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSkkLyxcbiAgICBpcHY0Q2lkcjogL14oPzooPzoyNVswLTVdfDJbMC00XVswLTldfDFbMC05XVswLTldfFsxLTldWzAtOV18WzAtOV0pXFwuKXszfSg/OjI1WzAtNV18MlswLTRdWzAtOV18MVswLTldWzAtOV18WzEtOV1bMC05XXxbMC05XSlcXC8oM1swLTJdfFsxMl0/WzAtOV0pJC8sXG4gICAgLyoqXG4gICAgICogVW51c2VkXG4gICAgICovXG4gICAgaXB2NjogL14oKFthLWYwLTldezEsNH06KXs3fXw6OihbYS1mMC05XXsxLDR9Oil7MCw2fXwoW2EtZjAtOV17MSw0fTopezF9OihbYS1mMC05XXsxLDR9Oil7MCw1fXwoW2EtZjAtOV17MSw0fTopezJ9OihbYS1mMC05XXsxLDR9Oil7MCw0fXwoW2EtZjAtOV17MSw0fTopezN9OihbYS1mMC05XXsxLDR9Oil7MCwzfXwoW2EtZjAtOV17MSw0fTopezR9OihbYS1mMC05XXsxLDR9Oil7MCwyfXwoW2EtZjAtOV17MSw0fTopezV9OihbYS1mMC05XXsxLDR9Oil7MCwxfSkoW2EtZjAtOV17MSw0fXwoKCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSlcXC4pezN9KCgyNVswLTVdKXwoMlswLTRdWzAtOV0pfCgxWzAtOV17Mn0pfChbMC05XXsxLDJ9KSkpJC8sXG4gICAgaXB2NkNpZHI6IC9eKChbMC05YS1mQS1GXXsxLDR9Oil7Nyw3fVswLTlhLWZBLUZdezEsNH18KFswLTlhLWZBLUZdezEsNH06KXsxLDd9OnwoWzAtOWEtZkEtRl17MSw0fTopezEsNn06WzAtOWEtZkEtRl17MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsNX0oOlswLTlhLWZBLUZdezEsNH0pezEsMn18KFswLTlhLWZBLUZdezEsNH06KXsxLDR9KDpbMC05YS1mQS1GXXsxLDR9KXsxLDN9fChbMC05YS1mQS1GXXsxLDR9Oil7MSwzfSg6WzAtOWEtZkEtRl17MSw0fSl7MSw0fXwoWzAtOWEtZkEtRl17MSw0fTopezEsMn0oOlswLTlhLWZBLUZdezEsNH0pezEsNX18WzAtOWEtZkEtRl17MSw0fTooKDpbMC05YS1mQS1GXXsxLDR9KXsxLDZ9KXw6KCg6WzAtOWEtZkEtRl17MSw0fSl7MSw3fXw6KXxmZTgwOig6WzAtOWEtZkEtRl17MCw0fSl7MCw0fSVbMC05YS16QS1aXXsxLH18OjooZmZmZig6MHsxLDR9KXswLDF9Oil7MCwxfSgoMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pXFwuKXszLDN9KDI1WzAtNV18KDJbMC00XXwxezAsMX1bMC05XSl7MCwxfVswLTldKXwoWzAtOWEtZkEtRl17MSw0fTopezEsNH06KCgyNVswLTVdfCgyWzAtNF18MXswLDF9WzAtOV0pezAsMX1bMC05XSlcXC4pezMsM30oMjVbMC01XXwoMlswLTRdfDF7MCwxfVswLTldKXswLDF9WzAtOV0pKVxcLygxMlswLThdfDFbMDFdWzAtOV18WzEtOV0/WzAtOV0pJC8sXG4gICAgYmFzZTY0OiAvXihbMC05YS16QS1aKy9dezR9KSooKFswLTlhLXpBLVorL117Mn09PSl8KFswLTlhLXpBLVorL117M309KSk/JC8sXG4gICAgYmFzZTY0dXJsOiAvXihbMC05YS16QS1aLV9dezR9KSooKFswLTlhLXpBLVotX117Mn0oPT0pPyl8KFswLTlhLXpBLVotX117M30oPSk/KSk/JC8sXG4gICAgbmFub2lkOiAvXlthLXpBLVowLTlfLV17MjF9JC8sXG4gICAgand0OiAvXltBLVphLXowLTktX10rXFwuW0EtWmEtejAtOS1fXStcXC5bQS1aYS16MC05LV9dKiQvLFxufTtcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVN0cmluZ0RlZihkZWYsIHJlZnMpIHtcbiAgICBjb25zdCByZXMgPSB7XG4gICAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgfTtcbiAgICBpZiAoZGVmLmNoZWNrcykge1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGRlZi5jaGVja3MpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hlY2sua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtaW5cIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluTGVuZ3RoXCIsIHR5cGVvZiByZXMubWluTGVuZ3RoID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KHJlcy5taW5MZW5ndGgsIGNoZWNrLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXhcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWF4TGVuZ3RoXCIsIHR5cGVvZiByZXMubWF4TGVuZ3RoID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWluKHJlcy5tYXhMZW5ndGgsIGNoZWNrLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJlbWFpbFwiOlxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlZnMuZW1haWxTdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1hdDplbWFpbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZW1haWxcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZm9ybWF0Omlkbi1lbWFpbFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaWRuLWVtYWlsXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcInBhdHRlcm46em9kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmVtYWlsLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidXJsXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwidXJpXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwidXVpZFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcInV1aWRcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJyZWdleFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgY2hlY2sucmVnZXgsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiY3VpZFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuY3VpZCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjdWlkMlwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuY3VpZDIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwic3RhcnRzV2l0aFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgUmVnRXhwKGBeJHtlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcyl9YCksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZW5kc1dpdGhcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIFJlZ0V4cChgJHtlc2NhcGVMaXRlcmFsQ2hlY2tWYWx1ZShjaGVjay52YWx1ZSwgcmVmcyl9JGApLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImRhdGV0aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZGF0ZS10aW1lXCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZGF0ZVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRGb3JtYXQocmVzLCBcImRhdGVcIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ0aW1lXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwidGltZVwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImR1cmF0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiZHVyYXRpb25cIiwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJsZW5ndGhcIjpcbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhyZXMsIFwibWluTGVuZ3RoXCIsIHR5cGVvZiByZXMubWluTGVuZ3RoID09PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgICAgICAgICA/IE1hdGgubWF4KHJlcy5taW5MZW5ndGgsIGNoZWNrLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGVjay52YWx1ZSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcIm1heExlbmd0aFwiLCB0eXBlb2YgcmVzLm1heExlbmd0aCA9PT0gXCJudW1iZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgPyBNYXRoLm1pbihyZXMubWF4TGVuZ3RoLCBjaGVjay52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogY2hlY2sudmFsdWUsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiaW5jbHVkZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgUmVnRXhwKGVzY2FwZUxpdGVyYWxDaGVja1ZhbHVlKGNoZWNrLnZhbHVlLCByZWZzKSksIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImlwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLnZlcnNpb24gIT09IFwidjZcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkRm9ybWF0KHJlcywgXCJpcHY0XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiaXB2NlwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NHVybFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuYmFzZTY0dXJsLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImp3dFwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuand0LCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNpZHJcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hlY2sudmVyc2lvbiAhPT0gXCJ2NlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuaXB2NENpZHIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGVjay52ZXJzaW9uICE9PSBcInY0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhdHRlcm4ocmVzLCB6b2RQYXR0ZXJucy5pcHY2Q2lkciwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJlbW9qaVwiOlxuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMuZW1vamkoKSwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1bGlkXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLnVsaWQsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImJhc2U2NFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocmVmcy5iYXNlNjRTdHJhdGVneSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImZvcm1hdDpiaW5hcnlcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZEZvcm1hdChyZXMsIFwiYmluYXJ5XCIsIGNoZWNrLm1lc3NhZ2UsIHJlZnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNvbnRlbnRFbmNvZGluZzpiYXNlNjRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMocmVzLCBcImNvbnRlbnRFbmNvZGluZ1wiLCBcImJhc2U2NFwiLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJwYXR0ZXJuOnpvZFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGF0dGVybihyZXMsIHpvZFBhdHRlcm5zLmJhc2U2NCwgY2hlY2subWVzc2FnZSwgcmVmcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJuYW5vaWRcIjoge1xuICAgICAgICAgICAgICAgICAgICBhZGRQYXR0ZXJuKHJlcywgem9kUGF0dGVybnMubmFub2lkLCBjaGVjay5tZXNzYWdlLCByZWZzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvTG93ZXJDYXNlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvVXBwZXJDYXNlXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcInRyaW1cIjpcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgKChfKSA9PiB7IH0pKGNoZWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gZXNjYXBlTGl0ZXJhbENoZWNrVmFsdWUobGl0ZXJhbCwgcmVmcykge1xuICAgIHJldHVybiByZWZzLnBhdHRlcm5TdHJhdGVneSA9PT0gXCJlc2NhcGVcIlxuICAgICAgICA/IGVzY2FwZU5vbkFscGhhTnVtZXJpYyhsaXRlcmFsKVxuICAgICAgICA6IGxpdGVyYWw7XG59XG5jb25zdCBBTFBIQV9OVU1FUklDID0gbmV3IFNldChcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2eHl6MDEyMzQ1Njc4OVwiKTtcbmZ1bmN0aW9uIGVzY2FwZU5vbkFscGhhTnVtZXJpYyhzb3VyY2UpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIUFMUEhBX05VTUVSSUMuaGFzKHNvdXJjZVtpXSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIlxcXFxcIjtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gc291cmNlW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gQWRkcyBhIFwiZm9ybWF0XCIga2V5d29yZCB0byB0aGUgc2NoZW1hLiBJZiBhIGZvcm1hdCBleGlzdHMsIGJvdGggZm9ybWF0cyB3aWxsIGJlIGpvaW5lZCBpbiBhbiBhbGxPZi1ub2RlLCBhbG9uZyB3aXRoIHN1YnNlcXVlbnQgb25lcy5cbmZ1bmN0aW9uIGFkZEZvcm1hdChzY2hlbWEsIHZhbHVlLCBtZXNzYWdlLCByZWZzKSB7XG4gICAgaWYgKHNjaGVtYS5mb3JtYXQgfHwgc2NoZW1hLmFueU9mPy5zb21lKCh4KSA9PiB4LmZvcm1hdCkpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEuYW55T2YpIHtcbiAgICAgICAgICAgIHNjaGVtYS5hbnlPZiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEuZm9ybWF0KSB7XG4gICAgICAgICAgICBzY2hlbWEuYW55T2YucHVzaCh7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBzY2hlbWEuZm9ybWF0LFxuICAgICAgICAgICAgICAgIC4uLihzY2hlbWEuZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogeyBmb3JtYXQ6IHNjaGVtYS5lcnJvck1lc3NhZ2UuZm9ybWF0IH0sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlbGV0ZSBzY2hlbWEuZm9ybWF0O1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5lcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLmVycm9yTWVzc2FnZS5mb3JtYXQ7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHNjaGVtYS5lcnJvck1lc3NhZ2UpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLmVycm9yTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2NoZW1hLmFueU9mLnB1c2goe1xuICAgICAgICAgICAgZm9ybWF0OiB2YWx1ZSxcbiAgICAgICAgICAgIC4uLihtZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgcmVmcy5lcnJvck1lc3NhZ2VzICYmIHsgZXJyb3JNZXNzYWdlOiB7IGZvcm1hdDogbWVzc2FnZSB9IH0pLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldFJlc3BvbnNlVmFsdWVBbmRFcnJvcnMoc2NoZW1hLCBcImZvcm1hdFwiLCB2YWx1ZSwgbWVzc2FnZSwgcmVmcyk7XG4gICAgfVxufVxuLy8gQWRkcyBhIFwicGF0dGVyblwiIGtleXdvcmQgdG8gdGhlIHNjaGVtYS4gSWYgYSBwYXR0ZXJuIGV4aXN0cywgYm90aCBwYXR0ZXJucyB3aWxsIGJlIGpvaW5lZCBpbiBhbiBhbGxPZi1ub2RlLCBhbG9uZyB3aXRoIHN1YnNlcXVlbnQgb25lcy5cbmZ1bmN0aW9uIGFkZFBhdHRlcm4oc2NoZW1hLCByZWdleCwgbWVzc2FnZSwgcmVmcykge1xuICAgIGlmIChzY2hlbWEucGF0dGVybiB8fCBzY2hlbWEuYWxsT2Y/LnNvbWUoKHgpID0+IHgucGF0dGVybikpIHtcbiAgICAgICAgaWYgKCFzY2hlbWEuYWxsT2YpIHtcbiAgICAgICAgICAgIHNjaGVtYS5hbGxPZiA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWEucGF0dGVybikge1xuICAgICAgICAgICAgc2NoZW1hLmFsbE9mLnB1c2goe1xuICAgICAgICAgICAgICAgIHBhdHRlcm46IHNjaGVtYS5wYXR0ZXJuLFxuICAgICAgICAgICAgICAgIC4uLihzY2hlbWEuZXJyb3JNZXNzYWdlICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yTWVzc2FnZTogeyBwYXR0ZXJuOiBzY2hlbWEuZXJyb3JNZXNzYWdlLnBhdHRlcm4gfSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5wYXR0ZXJuO1xuICAgICAgICAgICAgaWYgKHNjaGVtYS5lcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2NoZW1hLmVycm9yTWVzc2FnZS5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEuZXJyb3JNZXNzYWdlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHNjaGVtYS5lcnJvck1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNjaGVtYS5hbGxPZi5wdXNoKHtcbiAgICAgICAgICAgIHBhdHRlcm46IHN0cmluZ2lmeVJlZ0V4cFdpdGhGbGFncyhyZWdleCwgcmVmcyksXG4gICAgICAgICAgICAuLi4obWVzc2FnZSAmJlxuICAgICAgICAgICAgICAgIHJlZnMuZXJyb3JNZXNzYWdlcyAmJiB7IGVycm9yTWVzc2FnZTogeyBwYXR0ZXJuOiBtZXNzYWdlIH0gfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0UmVzcG9uc2VWYWx1ZUFuZEVycm9ycyhzY2hlbWEsIFwicGF0dGVyblwiLCBzdHJpbmdpZnlSZWdFeHBXaXRoRmxhZ3MocmVnZXgsIHJlZnMpLCBtZXNzYWdlLCByZWZzKTtcbiAgICB9XG59XG4vLyBNdXRhdGUgei5zdHJpbmcucmVnZXgoKSBpbiBhIGJlc3QgYXR0ZW1wdCB0byBhY2NvbW1vZGF0ZSBmb3IgcmVnZXggZmxhZ3Mgd2hlbiBhcHBseVJlZ2V4RmxhZ3MgaXMgdHJ1ZVxuZnVuY3Rpb24gc3RyaW5naWZ5UmVnRXhwV2l0aEZsYWdzKHJlZ2V4LCByZWZzKSB7XG4gICAgaWYgKCFyZWZzLmFwcGx5UmVnZXhGbGFncyB8fCAhcmVnZXguZmxhZ3MpIHtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnNvdXJjZTtcbiAgICB9XG4gICAgLy8gQ3VycmVudGx5IGhhbmRsZWQgZmxhZ3NcbiAgICBjb25zdCBmbGFncyA9IHtcbiAgICAgICAgaTogcmVnZXguZmxhZ3MuaW5jbHVkZXMoXCJpXCIpLFxuICAgICAgICBtOiByZWdleC5mbGFncy5pbmNsdWRlcyhcIm1cIiksXG4gICAgICAgIHM6IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKFwic1wiKSwgLy8gYC5gIG1hdGNoZXMgbmV3bGluZXNcbiAgICB9O1xuICAgIC8vIFRoZSBnZW5lcmFsIHByaW5jaXBsZSBoZXJlIGlzIHRvIHN0ZXAgdGhyb3VnaCBlYWNoIGNoYXJhY3Rlciwgb25lIGF0IGEgdGltZSwgYXBwbHlpbmcgbXV0YXRpb25zIGFzIGZsYWdzIHJlcXVpcmUuIFdlIGtlZXAgdHJhY2sgd2hlbiB0aGUgY3VycmVudCBjaGFyYWN0ZXIgaXMgZXNjYXBlZCwgYW5kIHdoZW4gaXQncyBpbnNpZGUgYSBncm91cCAvbGlrZSBbdGhpc10vIG9yIChhbHNvKSBhIHJhbmdlIGxpa2UgL1thLXpdLy4gVGhlIGZvbGxvd2luZyBpcyBmYWlybHkgYnJpdHRsZSBpbXBlcmF0aXZlIGNvZGU7IGVkaXQgYXQgeW91ciBwZXJpbCFcbiAgICBjb25zdCBzb3VyY2UgPSBmbGFncy5pID8gcmVnZXguc291cmNlLnRvTG93ZXJDYXNlKCkgOiByZWdleC5zb3VyY2U7XG4gICAgbGV0IHBhdHRlcm4gPSBcIlwiO1xuICAgIGxldCBpc0VzY2FwZWQgPSBmYWxzZTtcbiAgICBsZXQgaW5DaGFyR3JvdXAgPSBmYWxzZTtcbiAgICBsZXQgaW5DaGFyUmFuZ2UgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXNFc2NhcGVkKSB7XG4gICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgIGlzRXNjYXBlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzLmkpIHtcbiAgICAgICAgICAgIGlmIChpbkNoYXJHcm91cCkge1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaV0ubWF0Y2goL1thLXpdLykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluQ2hhclJhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYCR7c291cmNlW2kgLSAyXX0tJHtzb3VyY2VbaV19YC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5DaGFyUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChzb3VyY2VbaSArIDFdID09PSBcIi1cIiAmJiBzb3VyY2VbaSArIDJdPy5tYXRjaCgvW2Etel0vKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGF0dGVybiArPSBzb3VyY2VbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpbkNoYXJSYW5nZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuICs9IGAke3NvdXJjZVtpXX0ke3NvdXJjZVtpXS50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlW2ldLm1hdGNoKC9bYS16XS8pKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBgWyR7c291cmNlW2ldfSR7c291cmNlW2ldLnRvVXBwZXJDYXNlKCl9XWA7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsYWdzLm0pIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VbaV0gPT09IFwiXlwiKSB7XG4gICAgICAgICAgICAgICAgcGF0dGVybiArPSBgKF58KD88PVtcXHJcXG5dKSlgO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc291cmNlW2ldID09PSBcIiRcIikge1xuICAgICAgICAgICAgICAgIHBhdHRlcm4gKz0gYCgkfCg/PVtcXHJcXG5dKSlgO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbGFncy5zICYmIHNvdXJjZVtpXSA9PT0gXCIuXCIpIHtcbiAgICAgICAgICAgIHBhdHRlcm4gKz0gaW5DaGFyR3JvdXAgPyBgJHtzb3VyY2VbaV19XFxyXFxuYCA6IGBbJHtzb3VyY2VbaV19XFxyXFxuXWA7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBwYXR0ZXJuICs9IHNvdXJjZVtpXTtcbiAgICAgICAgaWYgKHNvdXJjZVtpXSA9PT0gXCJcXFxcXCIpIHtcbiAgICAgICAgICAgIGlzRXNjYXBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaW5DaGFyR3JvdXAgJiYgc291cmNlW2ldID09PSBcIl1cIikge1xuICAgICAgICAgICAgaW5DaGFyR3JvdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5DaGFyR3JvdXAgJiYgc291cmNlW2ldID09PSBcIltcIikge1xuICAgICAgICAgICAgaW5DaGFyR3JvdXAgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIG5ldyBSZWdFeHAocGF0dGVybik7XG4gICAgfVxuICAgIGNhdGNoIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgY29udmVydCByZWdleCBwYXR0ZXJuIGF0ICR7cmVmcy5jdXJyZW50UGF0aC5qb2luKFwiL1wiKX0gdG8gYSBmbGFnLWluZGVwZW5kZW50IGZvcm0hIEZhbGxpbmcgYmFjayB0byB0aGUgZmxhZy1pZ25vcmFudCBzb3VyY2VgKTtcbiAgICAgICAgcmV0dXJuIHJlZ2V4LnNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG59XG4iLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCAiLyoqXG4gKiBPbmxpbmVLb21tZW50YXIgQVBJIENsaWVudFxuICogU3dpc3MgTGVnYWwgRG9jdHJpbmUgKENvbW1lbnRhcnkpIEludGVncmF0aW9uXG4gKlxuICogQmFzZSBVUkw6IGh0dHBzOi8vb25saW5la29tbWVudGFyLmNoL2FwaVxuICogTm8gYXV0aGVudGljYXRpb24gcmVxdWlyZWRcbiAqL1xuXG5pbXBvcnQgdHlwZSB7XG4gIExhbmd1YWdlLFxuICBTb3J0T3B0aW9uLFxuICBTZWFyY2hDb21tZW50YXJpZXNPcHRpb25zLFxuICBDb21tZW50YXJ5LFxuICBDb21tZW50YXJ5RGV0YWlsLFxuICBMZWdpc2xhdGl2ZUFjdCxcbiAgU2VhcmNoUmVzdWx0LFxuICBBcGlSZXNwb25zZSxcbiAgTGVnaXNsYXRpdmVBY3RNYXBwaW5nLFxufSBmcm9tICcuL3R5cGVzLmpzJztcblxuY29uc3QgREVGQVVMVF9CQVNFX1VSTCA9ICdodHRwczovL29ubGluZWtvbW1lbnRhci5jaC9hcGknO1xuY29uc3QgREVGQVVMVF9SQVRFX0xJTUlUX01TID0gMTAwMDsgLy8gMSByZXF1ZXN0IHBlciBzZWNvbmRcbmNvbnN0IERFRkFVTFRfVElNRU9VVF9NUyA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2xpZW50T3B0aW9ucyB7XG4gIGJhc2VVcmw/OiBzdHJpbmc7XG4gIHJhdGVMaW1pdE1zPzogbnVtYmVyO1xuICB0aW1lb3V0TXM/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBPbmxpbmVLb21tZW50YXJDbGllbnQge1xuICBwcml2YXRlIGJhc2VVcmw6IHN0cmluZztcbiAgcHJpdmF0ZSByYXRlTGltaXRNczogbnVtYmVyO1xuICBwcml2YXRlIHRpbWVvdXRNczogbnVtYmVyO1xuICBwcml2YXRlIGxhc3RSZXF1ZXN0VGltZTogbnVtYmVyID0gMDtcbiAgcHJpdmF0ZSBsZWdpc2xhdGl2ZUFjdE1hcHBpbmc6IExlZ2lzbGF0aXZlQWN0TWFwcGluZyA9IHt9O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IENsaWVudE9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuYmFzZVVybCA9IG9wdGlvbnMuYmFzZVVybCA/PyBERUZBVUxUX0JBU0VfVVJMO1xuICAgIHRoaXMucmF0ZUxpbWl0TXMgPSBvcHRpb25zLnJhdGVMaW1pdE1zID8/IERFRkFVTFRfUkFURV9MSU1JVF9NUztcbiAgICB0aGlzLnRpbWVvdXRNcyA9IG9wdGlvbnMudGltZW91dE1zID8/IERFRkFVTFRfVElNRU9VVF9NUztcbiAgfVxuXG4gIC8qKlxuICAgKiBSYXRlLWxpbWl0ZWQgZmV0Y2ggd3JhcHBlclxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByYXRlTGltaXRlZEZldGNoKFxuICAgIHVybDogc3RyaW5nLFxuICAgIG9wdGlvbnM6IFJlcXVlc3RJbml0ID0ge31cbiAgKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuICAgIC8vIEFwcGx5IHJhdGUgbGltaXRpbmdcbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IHRpbWVTaW5jZUxhc3RSZXF1ZXN0ID0gbm93IC0gdGhpcy5sYXN0UmVxdWVzdFRpbWU7XG5cbiAgICBpZiAodGltZVNpbmNlTGFzdFJlcXVlc3QgPCB0aGlzLnJhdGVMaW1pdE1zKSB7XG4gICAgICBjb25zdCB3YWl0VGltZSA9IHRoaXMucmF0ZUxpbWl0TXMgLSB0aW1lU2luY2VMYXN0UmVxdWVzdDtcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHdhaXRUaW1lKSk7XG4gICAgfVxuXG4gICAgdGhpcy5sYXN0UmVxdWVzdFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gQ3JlYXRlIGFib3J0IGNvbnRyb2xsZXIgZm9yIHRpbWVvdXRcbiAgICBjb25zdCBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCB0aGlzLnRpbWVvdXRNcyk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgIEFjY2VwdDogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgLi4ub3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICB9LFxuICAgICAgfSk7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQVBJIGVycm9yOiAke3Jlc3BvbnNlLnN0YXR1c30gJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuXG4gICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZXF1ZXN0IHRpbWVvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgZXJyb3IubWVzc2FnZS5pbmNsdWRlcygnZmV0Y2gnKSB8fFxuICAgICAgICAgIGVycm9yLm1lc3NhZ2UuaW5jbHVkZXMoJ25ldHdvcmsnKVxuICAgICAgICApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05ldHdvcmsgcmVxdWVzdCBmYWlsZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIFVSTCB3aXRoIHF1ZXJ5IHBhcmFtZXRlcnNcbiAgICovXG4gIHByaXZhdGUgYnVpbGRVcmwoXG4gICAgZW5kcG9pbnQ6IHN0cmluZyxcbiAgICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IG51bWJlciB8IHVuZGVmaW5lZD4gPSB7fVxuICApOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwoYCR7dGhpcy5iYXNlVXJsfSR7ZW5kcG9pbnR9YCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhwYXJhbXMpKSB7XG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gJycpIHtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCBTdHJpbmcodmFsdWUpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICAvKipcbiAgICogU2VhcmNoIGNvbW1lbnRhcmllcyB3aXRoIGZpbHRlcmluZyBhbmQgcGFnaW5hdGlvblxuICAgKlxuICAgKiBAcGFyYW0gcXVlcnkgLSBTZWFyY2ggcXVlcnkgc3RyaW5nXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gU2VhcmNoIG9wdGlvbnMgKGxhbmd1YWdlLCBsZWdpc2xhdGl2ZV9hY3QsIHNvcnQsIHBhZ2UpXG4gICAqIEByZXR1cm5zIFNlYXJjaFJlc3VsdCB3aXRoIG1hdGNoaW5nIGNvbW1lbnRhcmllc1xuICAgKi9cbiAgYXN5bmMgc2VhcmNoQ29tbWVudGFyaWVzKFxuICAgIHF1ZXJ5OiBzdHJpbmcsXG4gICAgb3B0aW9uczogU2VhcmNoQ29tbWVudGFyaWVzT3B0aW9ucyA9IHt9XG4gICk6IFByb21pc2U8U2VhcmNoUmVzdWx0PiB7XG4gICAgY29uc3QgeyBsYW5ndWFnZSwgbGVnaXNsYXRpdmVfYWN0LCBzb3J0LCBwYWdlIH0gPSBvcHRpb25zO1xuXG4gICAgY29uc3QgdXJsID0gdGhpcy5idWlsZFVybCgnL2NvbW1lbnRhcmllcycsIHtcbiAgICAgIHNlYXJjaDogcXVlcnkgfHwgdW5kZWZpbmVkLFxuICAgICAgbGFuZ3VhZ2UsXG4gICAgICBsZWdpc2xhdGl2ZV9hY3QsXG4gICAgICBzb3J0LFxuICAgICAgcGFnZSxcbiAgICB9KTtcblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yYXRlTGltaXRlZEZldGNoKHVybCk7XG4gICAgY29uc3QgZGF0YSA9IChhd2FpdCByZXNwb25zZS5qc29uKCkpIGFzIEFwaVJlc3BvbnNlPFNlYXJjaFJlc3VsdD47XG5cbiAgICBpZiAoIWRhdGEuc3VjY2VzcyAmJiBkYXRhLmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZGF0YS5lcnJvcik7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGJvdGggd3JhcHBlZCBhbmQgdW53cmFwcGVkIEFQSSByZXNwb25zZXNcbiAgICBpZiAoZGF0YS5kYXRhKSB7XG4gICAgICByZXR1cm4gZGF0YS5kYXRhO1xuICAgIH1cblxuICAgIC8vIEFQSSByZXR1cm5zIHVud3JhcHBlZCByZXN1bHQgZGlyZWN0bHlcbiAgICByZXR1cm4gZGF0YSBhcyB1bmtub3duIGFzIFNlYXJjaFJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgZGV0YWlsZWQgY29tbWVudGFyeSBieSBJRFxuICAgKlxuICAgKiBAcGFyYW0gaWQgLSBDb21tZW50YXJ5IFVVSURcbiAgICogQHJldHVybnMgQ29tbWVudGFyeURldGFpbCB3aXRoIGZ1bGwgY29udGVudFxuICAgKi9cbiAgYXN5bmMgZ2V0Q29tbWVudGFyeShpZDogc3RyaW5nKTogUHJvbWlzZTxDb21tZW50YXJ5RGV0YWlsPiB7XG4gICAgLy8gVmFsaWRhdGUgSUQgZm9ybWF0IChiYXNpYyBVVUlEIGNoZWNrKVxuICAgIGlmICghaWQgfHwgIS9eW2EtekEtWjAtOS1dKyQvLnRlc3QoaWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tbWVudGFyeSBJRCcpO1xuICAgIH1cblxuICAgIGNvbnN0IHVybCA9IHRoaXMuYnVpbGRVcmwoYC9jb21tZW50YXJpZXMvJHtlbmNvZGVVUklDb21wb25lbnQoaWQpfWApO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnJhdGVMaW1pdGVkRmV0Y2godXJsKTtcbiAgICBjb25zdCBkYXRhID0gKGF3YWl0IHJlc3BvbnNlLmpzb24oKSkgYXMgQXBpUmVzcG9uc2U8Q29tbWVudGFyeURldGFpbD47XG5cbiAgICBpZiAoIWRhdGEuc3VjY2VzcyAmJiBkYXRhLmVycm9yKSB7XG4gICAgICBpZiAoZGF0YS5lcnJvci5pbmNsdWRlcygnbm90IGZvdW5kJykgfHwgZGF0YS5lcnJvci5pbmNsdWRlcygnNDA0JykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb21tZW50YXJ5IG5vdCBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKGRhdGEuZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBib3RoIHdyYXBwZWQgYW5kIHVud3JhcHBlZCBBUEkgcmVzcG9uc2VzXG4gICAgaWYgKGRhdGEuZGF0YSkge1xuICAgICAgcmV0dXJuIGRhdGEuZGF0YTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YSBhcyB1bmtub3duIGFzIENvbW1lbnRhcnlEZXRhaWw7XG4gIH1cblxuICAvKipcbiAgICogTGlzdCBhbGwgYXZhaWxhYmxlIGxlZ2lzbGF0aXZlIGFjdHNcbiAgICpcbiAgICogQHBhcmFtIGxhbmd1YWdlIC0gT3B0aW9uYWwgbGFuZ3VhZ2UgZmlsdGVyXG4gICAqIEByZXR1cm5zIEFycmF5IG9mIExlZ2lzbGF0aXZlQWN0XG4gICAqL1xuICBhc3luYyBsaXN0TGVnaXNsYXRpdmVBY3RzKGxhbmd1YWdlPzogTGFuZ3VhZ2UpOiBQcm9taXNlPExlZ2lzbGF0aXZlQWN0W10+IHtcbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVXJsKCcvbGVnaXNsYXRpdmUtYWN0cycsIHsgbGFuZ3VhZ2UgfSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucmF0ZUxpbWl0ZWRGZXRjaCh1cmwpO1xuICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKSBhcyBBcGlSZXNwb25zZTxMZWdpc2xhdGl2ZUFjdFtdPjtcblxuICAgIGlmICghZGF0YS5zdWNjZXNzICYmIGRhdGEuZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihkYXRhLmVycm9yKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3RzID0gZGF0YS5kYXRhID8/IChkYXRhIGFzIHVua25vd24gYXMgTGVnaXNsYXRpdmVBY3RbXSk7XG5cbiAgICAvLyBVcGRhdGUgdGhlIG1hcHBpbmcgY2FjaGVcbiAgICBmb3IgKGNvbnN0IGFjdCBvZiBhY3RzKSB7XG4gICAgICBpZiAoYWN0LmFiYnJldmlhdGlvbikge1xuICAgICAgICB0aGlzLmxlZ2lzbGF0aXZlQWN0TWFwcGluZ1thY3QuYWJicmV2aWF0aW9uLnRvTG93ZXJDYXNlKCldID0gYWN0LmlkO1xuICAgICAgfVxuICAgICAgaWYgKGFjdC5hYmJyZXZpYXRpb25fZGUpIHtcbiAgICAgICAgdGhpcy5sZWdpc2xhdGl2ZUFjdE1hcHBpbmdbYWN0LmFiYnJldmlhdGlvbl9kZS50b0xvd2VyQ2FzZSgpXSA9IGFjdC5pZDtcbiAgICAgIH1cbiAgICAgIGlmIChhY3QuYWJicmV2aWF0aW9uX2ZyKSB7XG4gICAgICAgIHRoaXMubGVnaXNsYXRpdmVBY3RNYXBwaW5nW2FjdC5hYmJyZXZpYXRpb25fZnIudG9Mb3dlckNhc2UoKV0gPSBhY3QuaWQ7XG4gICAgICB9XG4gICAgICBpZiAoYWN0LmFiYnJldmlhdGlvbl9pdCkge1xuICAgICAgICB0aGlzLmxlZ2lzbGF0aXZlQWN0TWFwcGluZ1thY3QuYWJicmV2aWF0aW9uX2l0LnRvTG93ZXJDYXNlKCldID0gYWN0LmlkO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBhY3RzO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjb21tZW50YXJ5IGZvciBhIHNwZWNpZmljIGFydGljbGUgcmVmZXJlbmNlXG4gICAqXG4gICAqIEtFWSBGRUFUVVJFOiBNYXBzIFwiQXJ0LiA5NyBPUlwiIHRvIGNvbW1lbnRhcnkgc2VhcmNoXG4gICAqXG4gICAqIEBwYXJhbSBhcnRpY2xlUmVmZXJlbmNlIC0gQXJ0aWNsZSByZWZlcmVuY2UgKGUuZy4sIFwiQXJ0LiA5NyBPUlwiLCBcImFydC4gOTcgQ09cIilcbiAgICogQHBhcmFtIGxhbmd1YWdlIC0gT3B0aW9uYWwgbGFuZ3VhZ2UgcHJlZmVyZW5jZVxuICAgKiBAcmV0dXJucyBTZWFyY2hSZXN1bHQgd2l0aCBtYXRjaGluZyBjb21tZW50YXJpZXNcbiAgICovXG4gIGFzeW5jIGdldENvbW1lbnRhcnlGb3JBcnRpY2xlKFxuICAgIGFydGljbGVSZWZlcmVuY2U6IHN0cmluZyxcbiAgICBsYW5ndWFnZT86IExhbmd1YWdlXG4gICk6IFByb21pc2U8U2VhcmNoUmVzdWx0PiB7XG4gICAgLy8gUGFyc2UgdGhlIGFydGljbGUgcmVmZXJlbmNlXG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZUFydGljbGVSZWZlcmVuY2UoYXJ0aWNsZVJlZmVyZW5jZSk7XG5cbiAgICBpZiAoIXBhcnNlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgSW52YWxpZCBhcnRpY2xlIHJlZmVyZW5jZSBmb3JtYXQ6ICR7YXJ0aWNsZVJlZmVyZW5jZX0uIEV4cGVjdGVkIGZvcm1hdCBsaWtlIFwiQXJ0LiA5NyBPUlwiIG9yIFwiYXJ0LiA5NyBhbC4gMiBDT1wiYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgbGVnaXNsYXRpdmUgYWN0IFVVSURcbiAgICBsZXQgbGVnaXNsYXRpdmVBY3RJZCA9IHRoaXMubGVnaXNsYXRpdmVBY3RNYXBwaW5nW3BhcnNlZC5hY3QudG9Mb3dlckNhc2UoKV07XG5cbiAgICAvLyBJZiBub3QgaW4gY2FjaGUsIGZldGNoIGxlZ2lzbGF0aXZlIGFjdHNcbiAgICBpZiAoIWxlZ2lzbGF0aXZlQWN0SWQpIHtcbiAgICAgIGF3YWl0IHRoaXMubGlzdExlZ2lzbGF0aXZlQWN0cygpO1xuICAgICAgbGVnaXNsYXRpdmVBY3RJZCA9IHRoaXMubGVnaXNsYXRpdmVBY3RNYXBwaW5nW3BhcnNlZC5hY3QudG9Mb3dlckNhc2UoKV07XG4gICAgfVxuXG4gICAgaWYgKCFsZWdpc2xhdGl2ZUFjdElkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gbGVnaXNsYXRpdmUgYWN0OiAke3BhcnNlZC5hY3R9YCk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciBjb21tZW50YXJpZXMgbWF0Y2hpbmcgdGhlIGFydGljbGVcbiAgICBjb25zdCBzZWFyY2hRdWVyeSA9IGAke3BhcnNlZC5hcnRpY2xlfSR7cGFyc2VkLnBhcmFncmFwaCA/IGAgJHtwYXJzZWQucGFyYWdyYXBofWAgOiAnJ31gO1xuXG4gICAgcmV0dXJuIHRoaXMuc2VhcmNoQ29tbWVudGFyaWVzKHNlYXJjaFF1ZXJ5LCB7XG4gICAgICBsYW5ndWFnZSxcbiAgICAgIGxlZ2lzbGF0aXZlX2FjdDogbGVnaXNsYXRpdmVBY3RJZCxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSBhcnRpY2xlIHJlZmVyZW5jZSBpbnRvIGNvbXBvbmVudHNcbiAgICpcbiAgICogSGFuZGxlcyBtdWx0aXBsZSBmb3JtYXRzOlxuICAgKiAtIEdlcm1hbjogXCJBcnQuIDk3IEFicy4gMSBsaXQuIGEgT1JcIlxuICAgKiAtIEZyZW5jaDogXCJhcnQuIDk3IGFsLiAyIGxldC4gYSBDT1wiXG4gICAqIC0gSXRhbGlhbjogXCJhcnQuIDk3IGNwdi4gMSBsZXR0LiBhIENPXCJcbiAgICovXG4gIHByaXZhdGUgcGFyc2VBcnRpY2xlUmVmZXJlbmNlKFxuICAgIHJlZmVyZW5jZTogc3RyaW5nXG4gICk6IHsgYXJ0aWNsZTogc3RyaW5nOyBwYXJhZ3JhcGg/OiBzdHJpbmc7IGFjdDogc3RyaW5nIH0gfCBudWxsIHtcbiAgICAvLyBOb3JtYWxpemU6IGxvd2VyY2FzZSBmb3IgcGFyc2luZywgcHJlc2VydmUgb3JpZ2luYWwgYXJ0aWNsZSBudW1iZXJzXG4gICAgY29uc3Qgbm9ybWFsaXplZCA9IHJlZmVyZW5jZS50cmltKCk7XG5cbiAgICAvLyBNYXRjaCBwYXR0ZXJucyBsaWtlIFwiQXJ0LiA5NyBbQWJzLi9hbC4vY3B2LiBYXSBbbGl0Li9sZXQuL2xldHQuIGFdIE9SL0NPL1pHQlwiXG4gICAgY29uc3QgcGF0dGVybnMgPSBbXG4gICAgICAvLyBGdWxsIHBhdHRlcm4gd2l0aCBwYXJhZ3JhcGggYW5kIGxldHRlclxuICAgICAgL15hcnRcXC4/XFxzKihcXGQrKD86YmlzfHRlcnxxdWF0ZXIpPylcXHMqKD86YWJzXFwuP3xhbFxcLj98Y3B2XFwuPylcXHMqKFxcZCspXFxzKig/OmxpdFxcLj98bGV0XFwuP3xsZXR0XFwuPylcXHMqKFthLXpdKVxccysoXFx3KykkL2ksXG4gICAgICAvLyBQYXR0ZXJuIHdpdGggcGFyYWdyYXBoIG9ubHlcbiAgICAgIC9eYXJ0XFwuP1xccyooXFxkKyg/OmJpc3x0ZXJ8cXVhdGVyKT8pXFxzKig/OmFic1xcLj98YWxcXC4/fGNwdlxcLj8pXFxzKihcXGQrKVxccysoXFx3KykkL2ksXG4gICAgICAvLyBTaW1wbGUgcGF0dGVybjogQXJ0LiBYIFNUQVRVVEVcbiAgICAgIC9eYXJ0XFwuP1xccyooXFxkKyg/OmJpc3x0ZXJ8cXVhdGVyKT8pXFxzKyhcXHcrKSQvaSxcbiAgICBdO1xuXG4gICAgZm9yIChjb25zdCBwYXR0ZXJuIG9mIHBhdHRlcm5zKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vcm1hbGl6ZWQubWF0Y2gocGF0dGVybik7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA9PT0gNSkge1xuICAgICAgICAgIC8vIEZ1bGwgcGF0dGVybiB3aXRoIHBhcmFncmFwaCBhbmQgbGV0dGVyXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFydGljbGU6IGBBcnQuICR7bWF0Y2hbMV19YCxcbiAgICAgICAgICAgIHBhcmFncmFwaDogYEFicy4gJHttYXRjaFsyXX0gbGl0LiAke21hdGNoWzNdfWAsXG4gICAgICAgICAgICBhY3Q6IG1hdGNoWzRdLFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgLy8gUGF0dGVybiB3aXRoIHBhcmFncmFwaCBvbmx5XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFydGljbGU6IGBBcnQuICR7bWF0Y2hbMV19YCxcbiAgICAgICAgICAgIHBhcmFncmFwaDogYEFicy4gJHttYXRjaFsyXX1gLFxuICAgICAgICAgICAgYWN0OiBtYXRjaFszXSxcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoLmxlbmd0aCA9PT0gMykge1xuICAgICAgICAgIC8vIFNpbXBsZSBwYXR0ZXJuXG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFydGljbGU6IGBBcnQuICR7bWF0Y2hbMV19YCxcbiAgICAgICAgICAgIGFjdDogbWF0Y2hbMl0sXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbGVnaXNsYXRpdmUgYWN0IG1hcHBpbmcgKGFiYnJldmlhdGlvbiAtPiBVVUlEKVxuICAgKi9cbiAgZ2V0TGVnaXNsYXRpdmVBY3RNYXBwaW5nKCk6IExlZ2lzbGF0aXZlQWN0TWFwcGluZyB7XG4gICAgcmV0dXJuIHsgLi4udGhpcy5sZWdpc2xhdGl2ZUFjdE1hcHBpbmcgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYW51YWxseSBzZXQgbGVnaXNsYXRpdmUgYWN0IG1hcHBpbmcgKHVzZWZ1bCBmb3IgdGVzdGluZylcbiAgICovXG4gIHNldExlZ2lzbGF0aXZlQWN0TWFwcGluZyhtYXBwaW5nOiBMZWdpc2xhdGl2ZUFjdE1hcHBpbmcpOiB2b2lkIHtcbiAgICB0aGlzLmxlZ2lzbGF0aXZlQWN0TWFwcGluZyA9IHsgLi4ubWFwcGluZyB9O1xuICB9XG59XG4iLCAiIyEvdXNyL2Jpbi9lbnYgbm9kZVxuLyoqXG4gKiBPbmxpbmVLb21tZW50YXIgTUNQIFNlcnZlclxuICogU3dpc3MgTGVnYWwgRG9jdHJpbmUgKENvbW1lbnRhcnkpIEludGVncmF0aW9uXG4gKlxuICogUHJvdmlkZXMgYWNjZXNzIHRvIE9ubGluZUtvbW1lbnRhci5jaCBBUEkgZm9yIFN3aXNzIGxlZ2FsIGNvbW1lbnRhcmllc1xuICogUGFydCBvZiB0aGUgQmV0dGVyQ2FsbENsYXVkZSBcIlN3aXNzIExlZ2FsIFJlc2VhcmNoIFRyaW5pdHlcIlxuICpcbiAqIFRvb2xzOlxuICogLSBzZWFyY2hfY29tbWVudGFyaWVzOiBTZWFyY2ggY29tbWVudGFyaWVzIHdpdGggZmlsdGVyc1xuICogLSBnZXRfY29tbWVudGFyeTogR2V0IGRldGFpbGVkIGNvbW1lbnRhcnkgYnkgSURcbiAqIC0gZ2V0X2NvbW1lbnRhcnlfZm9yX2FydGljbGU6IEZpbmQgY29tbWVudGFyaWVzIGZvciBhcnRpY2xlIHJlZmVyZW5jZXMgKEtFWSBGRUFUVVJFKVxuICogLSBsaXN0X2xlZ2lzbGF0aXZlX2FjdHM6IExpc3QgYXZhaWxhYmxlIGxlZ2lzbGF0aXZlIGFjdHNcbiAqL1xuXG5pbXBvcnQgeyBTZXJ2ZXIgfSBmcm9tICdAbW9kZWxjb250ZXh0cHJvdG9jb2wvc2RrL3NlcnZlci9pbmRleC5qcyc7XG5pbXBvcnQgeyBTdGRpb1NlcnZlclRyYW5zcG9ydCB9IGZyb20gJ0Btb2RlbGNvbnRleHRwcm90b2NvbC9zZGsvc2VydmVyL3N0ZGlvLmpzJztcbmltcG9ydCB7XG4gIENhbGxUb29sUmVxdWVzdFNjaGVtYSxcbiAgTGlzdFRvb2xzUmVxdWVzdFNjaGVtYSxcbn0gZnJvbSAnQG1vZGVsY29udGV4dHByb3RvY29sL3Nkay90eXBlcy5qcyc7XG5cbmltcG9ydCB7IE9ubGluZUtvbW1lbnRhckNsaWVudCB9IGZyb20gJy4vY2xpZW50LmpzJztcbmltcG9ydCB0eXBlIHsgTGFuZ3VhZ2UsIFNvcnRPcHRpb24gfSBmcm9tICcuL3R5cGVzLmpzJztcblxuLy8gSW5pdGlhbGl6ZSBzZXJ2ZXJcbmNvbnN0IHNlcnZlciA9IG5ldyBTZXJ2ZXIoXG4gIHtcbiAgICBuYW1lOiAnb25saW5la29tbWVudGFyJyxcbiAgICB2ZXJzaW9uOiAnMi4yLjAnLFxuICB9LFxuICB7XG4gICAgY2FwYWJpbGl0aWVzOiB7XG4gICAgICB0b29sczoge30sXG4gICAgfSxcbiAgfVxuKTtcblxuLy8gSW5pdGlhbGl6ZSBjbGllbnRcbmNvbnN0IGNsaWVudCA9IG5ldyBPbmxpbmVLb21tZW50YXJDbGllbnQoKTtcblxuLy8gVG9vbCBkZWZpbml0aW9uc1xuc2VydmVyLnNldFJlcXVlc3RIYW5kbGVyKExpc3RUb29sc1JlcXVlc3RTY2hlbWEsIGFzeW5jICgpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0b29sczogW1xuICAgICAge1xuICAgICAgICBuYW1lOiAnc2VhcmNoX2NvbW1lbnRhcmllcycsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBgU2VhcmNoIFN3aXNzIGxlZ2FsIGNvbW1lbnRhcmllcyBvbiBPbmxpbmVLb21tZW50YXIuY2guXG5cblN1cHBvcnRzIGZpbHRlcmluZyBieTpcbi0gTGFuZ3VhZ2UgKGRlLCBmciwgaXQsIGVuKVxuLSBMZWdpc2xhdGl2ZSBhY3QgKFVVSUQgZnJvbSBsaXN0X2xlZ2lzbGF0aXZlX2FjdHMpXG4tIFNvcnRpbmcgKHRpdGxlLCAtdGl0bGUsIGRhdGUsIC1kYXRlKVxuLSBQYWdpbmF0aW9uXG5cbkV4YW1wbGUgcXVlcmllczpcbi0gXCJBcnQuIDk3IE9SXCIgLSBGaW5kIGNvbW1lbnRhcmllcyBvbiBjb250cmFjdHVhbCBsaWFiaWxpdHlcbi0gXCJWZXJ0cmFnc2hhZnR1bmdcIiAtIFNlYXJjaCBmb3IgY29udHJhY3QgbGlhYmlsaXR5IGNvbW1lbnRhcmllc1xuLSBcInJlc3BvbnNhYmlsaXRcdTAwRTkgY29udHJhY3R1ZWxsZVwiIC0gRnJlbmNoIHNlYXJjaGAsXG4gICAgICAgIGlucHV0U2NoZW1hOiB7XG4gICAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnU2VhcmNoIHF1ZXJ5IHN0cmluZyAoYXJ0aWNsZSByZWZlcmVuY2UsIGxlZ2FsIHRlcm0sIGV0Yy4pJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZW51bTogWydkZScsICdmcicsICdpdCcsICdlbiddLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbHRlciBieSBsYW5ndWFnZSAoZGU9R2VybWFuLCBmcj1GcmVuY2gsIGl0PUl0YWxpYW4sIGVuPUVuZ2xpc2gpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsZWdpc2xhdGl2ZV9hY3Q6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmlsdGVyIGJ5IGxlZ2lzbGF0aXZlIGFjdCBVVUlEIChnZXQgVVVJRHMgZnJvbSBsaXN0X2xlZ2lzbGF0aXZlX2FjdHMpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzb3J0OiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBlbnVtOiBbJ3RpdGxlJywgJy10aXRsZScsICdkYXRlJywgJy1kYXRlJ10sXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnU29ydCBvcmRlcjogdGl0bGUgKEEtWiksIC10aXRsZSAoWi1BKSwgZGF0ZSAob2xkZXN0KSwgLWRhdGUgKG5ld2VzdCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhZ2U6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUGFnZSBudW1iZXIgZm9yIHBhZ2luYXRpb24gKGRlZmF1bHQ6IDEpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogW10sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBuYW1lOiAnZ2V0X2NvbW1lbnRhcnknLFxuICAgICAgICBkZXNjcmlwdGlvbjogYEdldCBkZXRhaWxlZCBjb21tZW50YXJ5IGNvbnRlbnQgYnkgSUQuXG5cblJldHVybnM6XG4tIEZ1bGwgY29tbWVudGFyeSB0ZXh0IGFuZCBzZWN0aW9uc1xuLSBBdXRob3JzIGFuZCBtZXRhZGF0YVxuLSBDaXRhdGlvbnMgKEJHRSwgQVRGLCBEVEYgcmVmZXJlbmNlcylcbi0gUmVsYXRlZCBjb21tZW50YXJpZXNcbi0gRGlyZWN0IFVSTCB0byBzb3VyY2VcblxuVXNlIGFmdGVyIHNlYXJjaF9jb21tZW50YXJpZXMgdG8gZ2V0IGZ1bGwgY29udGVudC5gLFxuICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGlkOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NvbW1lbnRhcnkgVVVJRCAoZnJvbSBzZWFyY2hfY29tbWVudGFyaWVzIHJlc3VsdHMpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXF1aXJlZDogWydpZCddLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ2dldF9jb21tZW50YXJ5X2Zvcl9hcnRpY2xlJyxcbiAgICAgICAgZGVzY3JpcHRpb246IGBLRVkgRkVBVFVSRTogRmluZCBjb21tZW50YXJpZXMgZm9yIGEgc3BlY2lmaWMgU3dpc3MgbGF3IGFydGljbGUgcmVmZXJlbmNlLlxuXG5BdXRvbWF0aWNhbGx5IHBhcnNlcyBhcnRpY2xlIHJlZmVyZW5jZXMgaW4gbXVsdGlwbGUgZm9ybWF0czpcbi0gR2VybWFuOiBcIkFydC4gOTcgT1JcIiwgXCJBcnQuIDk3IEFicy4gMSBPUlwiLCBcIkFydC4gOTcgQWJzLiAxIGxpdC4gYSBPUlwiXG4tIEZyZW5jaDogXCJhcnQuIDk3IENPXCIsIFwiYXJ0LiA5NyBhbC4gMiBDT1wiLCBcImFydC4gOTcgYWwuIDIgbGV0LiBhIENPXCJcbi0gSXRhbGlhbjogXCJhcnQuIDk3IENPXCIsIFwiYXJ0LiA5NyBjcHYuIDEgQ09cIiwgXCJhcnQuIDk3IGNwdi4gMSBsZXR0LiBhIENPXCJcblxuUmVzb2x2ZXMgYWJicmV2aWF0aW9ucyBhY3Jvc3MgbGFuZ3VhZ2VzOlxuLSBPUi9DTyBcdTIxOTIgT2JsaWdhdGlvbmVucmVjaHQgLyBDb2RlIGRlcyBvYmxpZ2F0aW9uc1xuLSBaR0IvQ0MgXHUyMTkyIFppdmlsZ2VzZXR6YnVjaCAvIENvZGUgY2l2aWxcbi0gU3RHQi9DUCBcdTIxOTIgU3RyYWZnZXNldHpidWNoIC8gQ29kZSBwXHUwMEU5bmFsXG5cbkV4YW1wbGU6IFwiQXJ0LiA5NyBPUlwiIFx1MjE5MiBGaW5kcyBhbGwgY29tbWVudGFyaWVzIG9uIE9SIEFydGljbGUgOTdgLFxuICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGFydGljbGVfcmVmZXJlbmNlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0FydGljbGUgcmVmZXJlbmNlIChlLmcuLCBcIkFydC4gOTcgT1JcIiwgXCJhcnQuIDk3IGFsLiAyIENPXCIpJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYW5ndWFnZToge1xuICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICAgICAgZW51bTogWydkZScsICdmcicsICdpdCcsICdlbiddLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ1ByZWZlcnJlZCBsYW5ndWFnZSBmb3IgcmVzdWx0cycsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgICAgcmVxdWlyZWQ6IFsnYXJ0aWNsZV9yZWZlcmVuY2UnXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdsaXN0X2xlZ2lzbGF0aXZlX2FjdHMnLFxuICAgICAgICBkZXNjcmlwdGlvbjogYExpc3QgYWxsIGF2YWlsYWJsZSBTd2lzcyBsZWdpc2xhdGl2ZSBhY3RzIChjb2Rlcy9zdGF0dXRlcykuXG5cblJldHVybnM6XG4tIExlZ2lzbGF0aXZlIGFjdCBVVUlEcyAoZm9yIGZpbHRlcmluZyBzZWFyY2hlcylcbi0gTmFtZXMgYW5kIGFiYnJldmlhdGlvbnMgaW4gYWxsIGxhbmd1YWdlc1xuLSBERTogT1IsIFpHQiwgU3RHQiwgWlBPLCBTdFBPLCBCViwgRFNHLCBVV0cuLi5cbi0gRlI6IENPLCBDQywgQ1AsIENQQywgQ1BQLi4uXG4tIElUOiBDTywgQ0MsIENQLCBDUEMsIENQUC4uLlxuXG5Vc2UgdGhpcyB0byBnZXQgVVVJRHMgZm9yIGZpbHRlcmluZyBzZWFyY2hfY29tbWVudGFyaWVzIGJ5IGxlZ2lzbGF0aXZlIGFjdC5gLFxuICAgICAgICBpbnB1dFNjaGVtYToge1xuICAgICAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIGxhbmd1YWdlOiB7XG4gICAgICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgICBlbnVtOiBbJ2RlJywgJ2ZyJywgJ2l0JywgJ2VuJ10sXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnRmlsdGVyIGJ5IGxhbmd1YWdlIChvcHRpb25hbCknLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlcXVpcmVkOiBbXSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgXSxcbiAgfTtcbn0pO1xuXG4vLyBUb29sIGNhbGwgaGFuZGxlclxuc2VydmVyLnNldFJlcXVlc3RIYW5kbGVyKENhbGxUb29sUmVxdWVzdFNjaGVtYSwgYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgY29uc3QgeyBuYW1lLCBhcmd1bWVudHM6IGFyZ3MgfSA9IHJlcXVlc3QucGFyYW1zO1xuXG4gIHRyeSB7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlICdzZWFyY2hfY29tbWVudGFyaWVzJzoge1xuICAgICAgICBjb25zdCBxdWVyeSA9IChhcmdzPy5xdWVyeSBhcyBzdHJpbmcpIHx8ICcnO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgIGxhbmd1YWdlOiBhcmdzPy5sYW5ndWFnZSBhcyBMYW5ndWFnZSB8IHVuZGVmaW5lZCxcbiAgICAgICAgICBsZWdpc2xhdGl2ZV9hY3Q6IGFyZ3M/LmxlZ2lzbGF0aXZlX2FjdCBhcyBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgICAgICAgc29ydDogYXJncz8uc29ydCBhcyBTb3J0T3B0aW9uIHwgdW5kZWZpbmVkLFxuICAgICAgICAgIHBhZ2U6IGFyZ3M/LnBhZ2UgYXMgbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5zZWFyY2hDb21tZW50YXJpZXMocXVlcnksIG9wdGlvbnMpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICBjb3VudDogcmVzdWx0LmNvdW50LFxuICAgICAgICAgICAgICAgICAgcGFnZTogcmVzdWx0LnBhZ2UsXG4gICAgICAgICAgICAgICAgICB0b3RhbF9wYWdlczogcmVzdWx0LnRvdGFsX3BhZ2VzLFxuICAgICAgICAgICAgICAgICAgY29tbWVudGFyaWVzOiByZXN1bHQuY29tbWVudGFyaWVzLm1hcCgoYykgPT4gKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGMuaWQsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBjLnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiBjLmF1dGhvcnMsXG4gICAgICAgICAgICAgICAgICAgIGxlZ2lzbGF0aXZlX2FjdDogYy5sZWdpc2xhdGl2ZV9hY3QuYWJicmV2aWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogYy5sYW5ndWFnZSxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlZDogYy51cGRhdGVkLFxuICAgICAgICAgICAgICAgICAgICB1cmw6IGMudXJsLFxuICAgICAgICAgICAgICAgICAgfSkpLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbnVsbCxcbiAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNhc2UgJ2dldF9jb21tZW50YXJ5Jzoge1xuICAgICAgICBjb25zdCBpZCA9IGFyZ3M/LmlkIGFzIHN0cmluZztcblxuICAgICAgICBpZiAoIWlkKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeSh7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogJ0NvbW1lbnRhcnkgSUQgaXMgcmVxdWlyZWQnIH0pLFxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGlzRXJyb3I6IHRydWUsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5nZXRDb21tZW50YXJ5KGlkKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY29tbWVudGFyeToge1xuICAgICAgICAgICAgICAgICAgICBpZDogcmVzdWx0LmlkLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogcmVzdWx0LnRpdGxlLFxuICAgICAgICAgICAgICAgICAgICBhdXRob3JzOiByZXN1bHQuYXV0aG9ycyxcbiAgICAgICAgICAgICAgICAgICAgbGVnaXNsYXRpdmVfYWN0OiByZXN1bHQubGVnaXNsYXRpdmVfYWN0LFxuICAgICAgICAgICAgICAgICAgICBsYW5ndWFnZTogcmVzdWx0Lmxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkOiByZXN1bHQudXBkYXRlZCxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiByZXN1bHQudXJsLFxuICAgICAgICAgICAgICAgICAgICBhYnN0cmFjdDogcmVzdWx0LmFic3RyYWN0LFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiByZXN1bHQuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbnM6IHJlc3VsdC5zZWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgY2l0YXRpb25zOiByZXN1bHQuY2l0YXRpb25zLFxuICAgICAgICAgICAgICAgICAgICByZWxhdGVkX2NvbW1lbnRhcmllczogcmVzdWx0LnJlbGF0ZWRfY29tbWVudGFyaWVzLFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjYXNlICdnZXRfY29tbWVudGFyeV9mb3JfYXJ0aWNsZSc6IHtcbiAgICAgICAgY29uc3QgYXJ0aWNsZVJlZmVyZW5jZSA9IGFyZ3M/LmFydGljbGVfcmVmZXJlbmNlIGFzIHN0cmluZztcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBhcmdzPy5sYW5ndWFnZSBhcyBMYW5ndWFnZSB8IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoIWFydGljbGVSZWZlcmVuY2UpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgZXJyb3I6ICdBcnRpY2xlIHJlZmVyZW5jZSBpcyByZXF1aXJlZCAoZS5nLiwgXCJBcnQuIDk3IE9SXCIpJyxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBpc0Vycm9yOiB0cnVlLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuZ2V0Q29tbWVudGFyeUZvckFydGljbGUoYXJ0aWNsZVJlZmVyZW5jZSwgbGFuZ3VhZ2UpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY29udGVudDogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWUsXG4gICAgICAgICAgICAgICAgICBhcnRpY2xlX3JlZmVyZW5jZTogYXJ0aWNsZVJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgIGNvdW50OiByZXN1bHQuY291bnQsXG4gICAgICAgICAgICAgICAgICBwYWdlOiByZXN1bHQucGFnZSxcbiAgICAgICAgICAgICAgICAgIHRvdGFsX3BhZ2VzOiByZXN1bHQudG90YWxfcGFnZXMsXG4gICAgICAgICAgICAgICAgICBjb21tZW50YXJpZXM6IHJlc3VsdC5jb21tZW50YXJpZXMubWFwKChjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBpZDogYy5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IGMudGl0bGUsXG4gICAgICAgICAgICAgICAgICAgIGF1dGhvcnM6IGMuYXV0aG9ycyxcbiAgICAgICAgICAgICAgICAgICAgbGVnaXNsYXRpdmVfYWN0OiBjLmxlZ2lzbGF0aXZlX2FjdC5hYmJyZXZpYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBjLmxhbmd1YWdlLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkOiBjLnVwZGF0ZWQsXG4gICAgICAgICAgICAgICAgICAgIHVybDogYy51cmwsXG4gICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgY2FzZSAnbGlzdF9sZWdpc2xhdGl2ZV9hY3RzJzoge1xuICAgICAgICBjb25zdCBsYW5ndWFnZSA9IGFyZ3M/Lmxhbmd1YWdlIGFzIExhbmd1YWdlIHwgdW5kZWZpbmVkO1xuXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5saXN0TGVnaXNsYXRpdmVBY3RzKGxhbmd1YWdlKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICB0ZXh0OiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgY291bnQ6IHJlc3VsdC5sZW5ndGgsXG4gICAgICAgICAgICAgICAgICBsZWdpc2xhdGl2ZV9hY3RzOiByZXN1bHQubWFwKChhY3QpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBhY3QuaWQsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGFjdC5uYW1lLFxuICAgICAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb246IGFjdC5hYmJyZXZpYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGFiYnJldmlhdGlvbl9kZTogYWN0LmFiYnJldmlhdGlvbl9kZSxcbiAgICAgICAgICAgICAgICAgICAgYWJicmV2aWF0aW9uX2ZyOiBhY3QuYWJicmV2aWF0aW9uX2ZyLFxuICAgICAgICAgICAgICAgICAgICBhYmJyZXZpYXRpb25faXQ6IGFjdC5hYmJyZXZpYXRpb25faXQsXG4gICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBhY3QubGFuZ3VhZ2UsXG4gICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICAgICAgICBtYXBwaW5nOiBjbGllbnQuZ2V0TGVnaXNsYXRpdmVBY3RNYXBwaW5nKCksXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBjb250ZW50OiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgdGV4dDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGVycm9yOiBgVW5rbm93biB0b29sOiAke25hbWV9YCxcbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIF0sXG4gICAgICAgICAgaXNFcnJvcjogdHJ1ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yLm1lc3NhZ2UgOiAnVW5rbm93biBlcnJvciBvY2N1cnJlZCc7XG5cbiAgICByZXR1cm4ge1xuICAgICAgY29udGVudDogW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgIHRleHQ6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IGVycm9yTWVzc2FnZSxcbiAgICAgICAgICB9KSxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgICBpc0Vycm9yOiB0cnVlLFxuICAgIH07XG4gIH1cbn0pO1xuXG4vLyBTdGFydCBzZXJ2ZXJcbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XG4gIGNvbnN0IHRyYW5zcG9ydCA9IG5ldyBTdGRpb1NlcnZlclRyYW5zcG9ydCgpO1xuICBhd2FpdCBzZXJ2ZXIuY29ubmVjdCh0cmFuc3BvcnQpO1xuICBjb25zb2xlLmVycm9yKCdPbmxpbmVLb21tZW50YXIgTUNQIFNlcnZlciB2Mi4yLjAgcnVubmluZyBvbiBzdGRpbycpO1xufVxuXG5tYWluKCkuY2F0Y2goKGVycm9yKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoJ0ZhdGFsIGVycm9yOicsIGVycm9yKTtcbiAgcHJvY2Vzcy5leGl0KDEpO1xufSk7XG4iXSwKICAibWFwcGluZ3MiOiAiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQ0EsUUFBc0IsY0FBdEIsTUFBaUM7O0FBQWpDLFlBQUEsY0FBQTtBQU9hLFlBQUEsYUFBYTtBQUUxQixRQUFhLE9BQWIsY0FBMEIsWUFBVztNQUVuQyxZQUFZLEdBQVM7QUFFbkIsWUFEQSxNQUFLLEdBQ0QsQ0FBQyxRQUFBLFdBQVcsS0FBSyxDQUFDO0FBQUcsZ0JBQU0sSUFBSSxNQUFNLDBDQUEwQztBQUNuRixhQUFLLE1BQU07TUFDYjtNQUVBLFdBQVE7QUFDTixlQUFPLEtBQUs7TUFDZDtNQUVBLFdBQVE7QUFDTixlQUFPO01BQ1Q7TUFFQSxJQUFJLFFBQUs7QUFDUCxlQUFPLEVBQUMsQ0FBQyxLQUFLLEdBQUcsR0FBRyxFQUFDO01BQ3ZCOztBQWxCRixZQUFBLE9BQUE7QUFxQkEsUUFBYSxRQUFiLGNBQTJCLFlBQVc7TUFLcEMsWUFBWSxNQUFrQztBQUM1QyxjQUFLLEdBQ0wsS0FBSyxTQUFTLE9BQU8sUUFBUyxXQUFXLENBQUMsSUFBSSxJQUFJO01BQ3BEO01BRUEsV0FBUTtBQUNOLGVBQU8sS0FBSztNQUNkO01BRUEsV0FBUTtBQUNOLFlB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Q1QsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLE9BQU8sR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUN6RTtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1osV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFVBQVUsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUM1RTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsTUFBTSxTQUFTO0FBQ1gsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFNBQVMsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMzRTtBQUFBLEVBQ0EsS0FBSyxTQUFTO0FBQ1YsV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFFBQVEsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUMxRTtBQUFBLEVBQ0EsT0FBTyxTQUFTO0FBQ1osV0FBTyxLQUFLLFVBQVUsRUFBRSxNQUFNLFVBQVUsR0FBRyxVQUFVLFNBQVMsT0FBTyxFQUFFLENBQUM7QUFBQSxFQUM1RTtBQUFBLEVBQ0EsVUFBVSxTQUFTO0FBRWYsV0FBTyxLQUFLLFVBQVU7QUFBQSxNQUNsQixNQUFNO0FBQUEsTUFDTixHQUFHLFVBQVUsU0FBUyxPQUFPO0FBQUEsSUFDakMsQ0FBQztBQUFBLEVBQ0w7QUFBQSxFQUNBLElBQUksU0FBUztBQUNULFdBQU8sS0FBSyxVQUFVLEVB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SyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxhQUFhO0FBQ2IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFVBQVU7QUFBQSxFQUNqRTtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxRQUFRO0FBQ1IsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLEtBQUs7QUFBQSxFQUM1RDtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxXQUFXO0FBQ1gsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLFFBQVE7QUFBQSxFQUMvRDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE1BQU07QUFBQSxFQUM3RDtBQUFBLEVBQ0EsSUFBSSxVQUFVO0FBQ1YsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFTLE9BQU87QUFBQSxFQUM5RDtBQUFBLEVBQ0EsSUFBSSxTQUFTO0FBQ1QsV0FBTyxDQUFDLENBQUMsS0FBSyxLQUFLLE9BQU8sS0FBSyxDQUFDLE9BQU8sR0FBRyxTQUFT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O0FBQUEsRUFBQSxpQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxtQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQSxrQkFBQUM7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUEsa0JBQUFDO0FBQUEsRUFBQSxlQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBLGlCQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUEsZ0JBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsYUFBQUM7QUFBQSxFQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBLGdCQUFBQztBQUFBLEVBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsYUFBQUM7QUFBQSxFQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUE7QUFBQSxhQUFBQztBQUFBLEVBQUEsZ0JBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxjQUFBQztBQUFBLEVBQUEsWUFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBLGVBQUFDO0FBQUEsRUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLGFBQUFDO0FBQUEsRUFBQTtBQUFBLGNBQUFDO0FBQUEsRUFBQTtBQUFBLGdCQUFBQztBQUFBLEVBQUE7QUFBQTtBQUFBO0FBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUEsaUJBQUFDO0FBQUEsRUFBQSxjQUFBQztBQUFBLEVBQUEsY0FBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxnQkFBQUM7QUFBQSxFQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7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V0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsU0FBUyxNQUFNLENBQUMsR0FDbEUsS0FBSyxTQUFTLENBQUMsV0FBVyxLQUFLLE1BQVcsUUFBUSxTQUFTLE1BQU0sQ0FBQyxHQUNsRSxLQUFLLFNBQVMsQ0FBQyxXQUFXLEtBQUssTUFBVyxRQUFRLFNBQVMsTUFBTSxDQUFDLEdBQ2xFLEtBQUssU0FBUyxDQUFDLFdBQVcsS0FBSyxNQUFXLFFBQVEsV0FBVyxNQUFNLENBQUMsR0FDcEUsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLE9BQU8sQ0FBQyxXQUFXLEtBQUssTUFBVyxNQUFNLFNBQVMsTUFBTSxDQUFDLEdBQzlELEtBQUssUUFBUSxDQUFDLFdBQVcsS0FBSyxNQUFXLE9BQU8sVUFBVSxNQUFNLENBQUMsR0FDakUsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLFNBQVMsQ0FBQyxXQUFXLEtBQUssTUFBVyxRQUFRLFdBQVcsTUFBTSxDQUFDLEdBQ3BFLEtBQUssWUFBWSxDQUFDLFdBQVcsS0FBSyxNQUFXLFdBQVcsY0FBYyxNQUFNLENBQUMsR0FDN0UsS0FBSyxNQUFNLENBQUMsV0FBVyxLQUFLLE1BQVcsS0FBSyxRQUFRLE1BQU0sQ0FBQyxHQUMzRCxLQUFLLFFBQVEsQ0FBQyxXQUFXLEtBQUssTUFBVyxPQUFPLFVBQVUsTUFBTSxDQUFDLEdBQ2pFLEtBQUssT0FBTyxDQUFDLFdBQVcsS0FBSyxNQUFXLE1BQU0sU0FBUyxNQUFNLENBQUMsR0FDOUQsS0FBSyxPQUFPLENBQUMsV0FBVyxLQUFLLE1BQVcsTUFBTSxTQUFTLE1BQU0sQ0FBQyxHQUM5RCxLQUFLLFNBQVMsQ0FBQyxXQUFX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TSxVQUFVO0FBRTlELFdBQU87QUFBQSxNQUNMLFNBQVM7QUFBQSxRQUNQO0FBQUEsVUFDRSxNQUFNO0FBQUEsVUFDTixNQUFNLEtBQUssVUFBVTtBQUFBLFlBQ25CLFNBQVM7QUFBQSxZQUNULE9BQU87QUFBQSxVQUNULENBQUM7QUFBQSxRQUNIO0FBQUEsTUFDRjtBQUFBLE1BQ0EsU0FBUztBQUFBLElBQ1g7QUFBQSxFQUNGO0FBQ0YsQ0FBQztBQUdELGVBQWUsT0FBTztBQUNwQixNQUFNLFlBQVksSUFBSSxxQkFBcUI7QUFDM0MsUUFBTSxPQUFPLFFBQVEsU0FBUyxHQUM5QixRQUFRLE1BQU0sb0RBQW9EO0FBQ3BFO0FBRUEsS0FBSyxFQUFFLE1BQU0sQ0FBQ0EsV0FBVTtBQUN0QixVQUFRLE1BQU0sZ0JBQWdCQSxNQUFLLEdBQ25DLFFBQVEsS0FBSyxDQUFDO0FBQ2hCLENBQUM7IiwKICAibmFtZXMiOiBbIl9hIiwgIlVzZWRWYWx1ZVN0YXRlIiwgIl9hIiwgImVycm9yIiwgIl9hIiwgImhhc2giLCAibWVyZ2VWYWx1ZXMiLCAiVHlwZSIsICJlcnJvciIsICJfYSIsICJEYXRhVHlwZSIsICJfYSIsICJfYSIsICJoZXgiLCAiaXB2NiIsICJlc2MiLCAicGFyc2UiLCAiX2EiLCAiQWp2IiwgIm1ldGEiLCAiX2EiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiZXJyb3IiLCAiRGlzY3JFcnJvciIsICJlcnJvciIsICJfYSIsICJyZXF1aXJlZCIsICJBanYiLCAiZGF0ZSIsICJ0aW1lIiwgImVycm9yIiwgIl9hIiwgInV0aWwiLCAiYXNzZXJ0SXMiLCAiYXNzZXJ0TmV2ZXIiLCAib2JqZWN0IiwgImpvaW5WYWx1ZXMiLCAiYXJyYXkiLCAib2JqZWN0VXRpbCIsICJpc3N1ZSIsICJlcnJvciIsICJpc3N1ZSIsICJtYXAiLCAiaXNzdWUiLCAiZXJyb3JVdGlsIiwgImVycm9yIiwgImVycm9yTWFwIiwgImNoZWNrIiwgInRyYW5zZm9ybSIsICJ2ZXJzaW9uIiwgImp3dCIsICJiYXNlNjQiLCAiX1pvZFN0cmluZyIsICJjdHgiLCAicmVzdWx0IiwgImlzc3VlIiwgImlzc3VlcyIsICJlbGVtZW50cyIsICJwcm9jZXNzZWQiLCAicHJlcHJvY2VzcyIsICJyZXN1bHQiLCAiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwgImluaXRpYWxpemVyIiwgIl9hIiwgImZsb2F0U2FmZVJlbWFpbmRlciIsICJnZXRQYXJzZWRUeXBlIiwgImFycmF5IiwgIm9iamVjdCIsICJDbGFzcyIsICJfYSIsICJjb25maWciLCAiYmFzZTY0IiwgImJhc2U2NHVybCIsICJoZXgiLCAiZXJyb3IiLCAiaXNzdWUiLCAidmVyc2lvbiIsICJ0aW1lIiwgInRpbWVSZWdleCIsICJfYSIsICJpbnN0IiwgImZsb2F0U2FmZVJlbWFpbmRlciIsICJyZXN1bHQiLCAiX2EiLCAiY2hlY2tzIiwgImlzQWJvcnRlZCIsICJjaGVja1Jlc3VsdCIsICJjYW5hcnkiLCAicmVzdWx0IiwgInVybCIsICJiYXNlNjQiLCAiaXNWYWxpZEpXVCIsICJyIiwgImlzT2JqZWN0IiwgInJlc3VsdHMiLCAibWFwIiwgImxlZnQiLCAicmlnaHQiLCAibWVyZ2VWYWx1ZXMiLCAia2V5UmVzdWx0IiwgInZhbHVlUmVzdWx0IiwgIm91dHB1dCIsICJpc3N1ZSIsICJlbl9kZWZhdWx0IiwgIm1ldGEiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiX2Vtb2ppIiwgIkNsYXNzIiwgIkNsYXNzIiwgIkNsYXNzIiwgIkNsYXNzIiwgIl91bmRlZmluZWQiLCAiX251bGwiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiQ2xhc3MiLCAiaXNzdWUiLCAiY29kZWMiLCAicHJvY2VzcyIsICJfYSIsICJtZXRhIiwgImlkIiwgInNjaGVtYSIsICJqc29uIiwgImZpbGUiLCAicHJvY2VzcyIsICJzYWZlUGFyc2UiLCAiZGVmIiwgInNjaGVtYXNfZXhwb3J0cyIsICJab2RBbnkiLCAiWm9kQXJyYXkiLCAiWm9kQmlnSW50IiwgIlpvZEJvb2xlYW4iLCAiWm9kQ2F0Y2giLCAiWm9kRGF0ZSIsICJab2REZWZhdWx0IiwgIlpvZERpc2NyaW1pbmF0ZWRVbmlvbiIsICJab2RFbnVtIiwgIlpvZEZ1bmN0aW9uIiwgIlpvZEludGVyc2VjdGlvbiIsICJab2RMYXp5IiwgIlpvZExpdGVyYWwiLCAiWm9kTWFwIiwgIlpvZE5hTiIsICJab2ROZXZlciIsICJab2ROdWxsIiwgIlpvZE51bGxhYmxlIiwgIlpvZE51bWJlciIsICJab2RPYmplY3QiLCAiWm9kT3B0aW9uYWwiLCAiWm9kUHJvbWlzZSIsICJab2RSZWFkb25seSIsICJab2RSZWNvcmQiLCAiWm9kU2V0IiwgIlpvZFN0cmluZyIsICJab2RTeW1ib2wiLCAiWm9kVHVwbGUiLCAiWm9kVHlwZSIsICJab2RVbmRlZmluZWQiLCAiWm9kVW5pb24iLCAiWm9kVW5rbm93biIsICJab2RWb2lkIiwgImJhc2U2NCIsICJiYXNlNjR1cmwiLCAiYmlnaW50IiwgImJvb2xlYW4iLCAiY2lkcnY0IiwgImNpZHJ2NiIsICJjdWlkIiwgImN1aWQyIiwgImRhdGUiLCAiZGVzY3JpYmUiLCAiZTE2NCIsICJlbWFpbCIsICJlbW9qaSIsICJndWlkIiwgImhleCIsICJob3N0bmFtZSIsICJpcHY0IiwgImlwdjYiLCAia3N1aWQiLCAibWFjIiwgIm1ldGEiLCAibmFub2lkIiwgIl9udWxsIiwgIm51bGxpc2giLCAibnVtYmVyIiwgIm9iamVjdCIsICJzdHJpbmciLCAidWxpZCIsICJfdW5kZWZpbmVkIiwgInV1aWQiLCAiX3ZvaWQiLCAieGlkIiwgImNoZWNrc19leHBvcnRzIiwgImlzb19leHBvcnRzIiwgImRhdGUiLCAiZGF0ZXRpbWUiLCAiZHVyYXRpb24iLCAidGltZSIsICJkYXRldGltZSIsICJkYXRlIiwgInRpbWUiLCAiZHVyYXRpb24iLCAiaW5pdGlhbGl6ZXIiLCAiaXNzdWUiLCAiaXNzdWVzIiwgIlpvZEVycm9yIiwgInBhcnNlIiwgInBhcnNlQXN5bmMiLCAic2FmZVBhcnNlIiwgInNhZmVQYXJzZUFzeW5jIiwgImVuY29kZSIsICJkZWNvZGUiLCAiZW5jb2RlQXN5bmMiLCAiZGVjb2RlQXN5bmMiLCAic2FmZUVuY29kZSIsICJzYWZlRGVjb2RlIiwgInNhZmVFbmNvZGVBc3luYyIsICJzYWZlRGVjb2RlQXN5bmMiLCAiWm9kVHlwZSIsICJkZWYiLCAibWV0YSIsICJwYXJzZSIsICJzYWZlUGFyc2UiLCAicGFyc2VBc3luYyIsICJzYWZlUGFyc2VBc3luYyIsICJlbmNvZGUiLCAiZGVjb2RlIiwgImVuY29kZUFzeW5jIiwgImRlY29kZUFzeW5jIiwgInNhZmVFbmNvZGUiLCAic2FmZURlY29kZSIsICJzYWZlRW5jb2RlQXN5bmMiLCAic2FmZURlY29kZUFzeW5jIiwgImNoZWNrIiwgImpzb24iLCAiWm9kU3RyaW5nIiwgIl9lbW9qaSIsICJkYXRldGltZSIsICJkYXRlIiwgInRpbWUiLCAiZHVyYXRpb24iLCAic3RyaW5nIiwgImVtYWlsIiwgImd1aWQiLCAidXVpZCIsICJlbW9qaSIsICJuYW5vaWQiLCAiY3VpZCIsICJjdWlkMiIsICJ1bGlkIiwgInhpZCIsICJrc3VpZCIsICJpcHY0IiwgIm1hYyIsICJpcHY2IiwgImNpZHJ2NCIsICJjaWRydjYiLCAiYmFzZTY0IiwgImJhc2U2NHVybCIsICJlMTY0IiwgImhvc3RuYW1lIiwgImhleCIsICJab2ROdW1iZXIiLCAibnVtYmVyIiwgIlpvZEJvb2xlYW4iLCAiYm9vbGVhbiIsICJab2RCaWdJbnQiLCAiYmlnaW50IiwgIlpvZFN5bWJvbCIsICJab2RVbmRlZmluZWQiLCAiX3VuZGVmaW5lZCIsICJab2ROdWxsIiwgIlpvZFR5cGUiLCAianNvbiIsICJfbnVsbCIsICJab2RBbnkiLCAiWm9kVHlwZSIsICJqc29uIiwgIlpvZFVua25vd24iLCAiWm9kTmV2ZXIiLCAiWm9kVm9pZCIsICJfdm9pZCIsICJab2REYXRlIiwgIlpvZFR5cGUiLCAianNvbiIsICJkYXRlIiwgIlpvZEFycmF5IiwgIlpvZE9iamVjdCIsICJab2RPcHRpb25hbCIsICJvYmplY3QiLCAiWm9kVW5pb24iLCAiWm9kRGlzY3JpbWluYXRlZFVuaW9uIiwgIlpvZEludGVyc2VjdGlvbiIsICJab2RUdXBsZSIsICJab2RSZWNvcmQiLCAiWm9kTWFwIiwgIlpvZFNldCIsICJab2RFbnVtIiwgIlpvZEVudW0iLCAiWm9kTGl0ZXJhbCIsICJab2RUeXBlIiwgImpzb24iLCAiaXNzdWUiLCAib3V0cHV0IiwgIlpvZE9wdGlvbmFsIiwgIlpvZE51bGxhYmxlIiwgIm51bGxpc2giLCAiWm9kRGVmYXVsdCIsICJab2RDYXRjaCIsICJab2ROYU4iLCAiWm9kVHlwZSIsICJqc29uIiwgIlpvZFJlYWRvbmx5IiwgIlpvZExhenkiLCAiWm9kUHJvbWlzZSIsICJab2RGdW5jdGlvbiIsICJab2RUeXBlIiwgImpzb24iLCAiZGVzY3JpYmUiLCAibWV0YSIsICJab2RCb29sZWFuIiwgIlpvZFN0cmluZyIsICJzdHJpbmciLCAibnVtYmVyIiwgImJvb2xlYW4iLCAiX251bGwiLCAiWm9kRmlyc3RQYXJ0eVR5cGVLaW5kIiwgInNjaGVtYXNfZXhwb3J0cyIsICJjaGVja3NfZXhwb3J0cyIsICJpc29fZXhwb3J0cyIsICJlbl9kZWZhdWx0IiwgInN0cmluZyIsICJudW1iZXIiLCAiX251bGwiLCAib2JqZWN0IiwgIkVycm9yQ29kZSIsICJvYmplY3QiLCAibnVtYmVyIiwgInN0cmluZyIsICJzdHJpbmciLCAib2JqZWN0IiwgImJvb2xlYW4iLCAib2JqZWN0IiwgInN0cmluZyIsICJib29sZWFuIiwgIm9iamVjdCIsICJudW1iZXIiLCAic3RyaW5nIiwgIl9udWxsIiwgImlzb19leHBvcnRzIiwgImJvb2xlYW4iLCAib2JqZWN0IiwgInN0cmluZyIsICJzdHJpbmciLCAibnVtYmVyIiwgImJvb2xlYW4iLCAib2JqZWN0IiwgInNhZmVQYXJzZSIsICJlcnJvciIsICJ0YXNrIiwgInNhZmVQYXJzZSIsICJqc29ucnBjTm90aWZpY2F0aW9uIiwgImlzUGxhaW5PYmplY3QiLCAiQWp2IiwgIl9hZGRGb3JtYXRzIiwgInNhZmVQYXJzZSIsICJlcnJvciIsICJwcm9jZXNzIiwgInByb2Nlc3MiLCAiZXJyb3IiLCAianNvbiIsICJ1cmwiLCAiZXJyb3IiLCAiZXJyb3IiXQp9Cg==
